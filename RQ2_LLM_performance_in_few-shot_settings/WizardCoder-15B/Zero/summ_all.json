[{"ID": 1, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = downstream; final SimplePlainQueue<U> q = queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); }\n\n    ### Response:", "ground_truth": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "predict": "/**\n     * Emits the given value to the downstream observer, if possible.\n     * <p>\n     * If the downstream observer is not ready to receive the value, the value is enqueued to the queue.\n     * If the queue is full, the method returns false and the value is not emitted.\n     * <p>\n     * If the downstream observer is ready to receive the value, the method returns true and the value is emitted.\n     * If the downstream observer is cancelled, the method returns false and the value is not emitted.\n     * <p>\n     * If the downstream observer is not ready to receive the value and the queue is full, the method blocks until the downstream observer is ready or the queue is no longer full.\n     * <p>\n     * The method is thread-safe and can be called from multiple threads concurrently.\n     *\n     * @param value the value to emit\n     * @param delayError if true, errors are delayed until all values have been emitted\n     * @param disposable the Disposable that represents the"}, {"ID": 2, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public static <T> Observable<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); }\n\n    ### Response:", "ground_truth": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n\nScheduler:\n{@code wrap} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "predict": "/**\n     * Wraps a source of elements into an Observable.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code wrap} does not operate by default on a particular scheduler and\n     *  the source's subscribeOn and observeOn methods are not honored by the operator.\n     *  If you need to specify a scheduler, use the {@code subscribeOn} and {@code observeOn}\n     *  methods before assembly the Observable.</dd>\n     * </dl>\n     *\n     * @param <T> the type of the elements in the source\n     * @param source the source of elements to wrap, not null\n     * @return an Observable that emits the same elements as the source\n     * @throws NullPointerException if source is null"}, {"ID": 3, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Observable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\"); return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); }\n\n    ### Response:", "ground_truth": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "predict": "/**\n     * Sorts the elements of this Observable in ascending order according to natural order or a specified\n     * {@link Comparator}.\n     * <p>\n     * <img width=\"640\" height=\"315\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/sorted.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code sorted} does not operate by default on a particular scheduler.\n     *  </dd>\n     * </dl>\n     *\n     * @param sortFunction\n     *            the {@link Comparator} to use for sorting the elements in ascending order, or null to use natural\n     *            order\n     * @return an Observable that emits the sorted elements\n     * @throws NullPointerException\n     *             if {@code sortFunction} is null\n     */\n    @CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Observable<T> sorted(Comparator<? super"}, {"ID": 4, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); }\n\n    ### Response:", "ground_truth": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "/**\r\n     * Returns an Observable that emits the same sequence of items as the source Observable,\r\n     * but where each item is emitted on a specified Scheduler.\r\n     * <p>\r\n     * <img width=\"640\" height=\"380\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png\" alt=\"\">\r\n     * <dl>\r\n     *  <dt><b>Scheduler:</b></dt>\r\n     *  <dd>{@code observeOn} does not operate by default on a particular Scheduler. The\n     *  implementation of the operator may operate on any Scheduler it chooses, based on the\n     *  runtime behavior of the underlying Observable.\n     *  </dd>\r\n     * </dl>\r\n     *\r\n     * @param scheduler the Scheduler to emit the items on.\r\n     * @param <T> the type of items emitted by the source and output Observables\r\n     * @return an Observable that emits the same sequence of items as the source Observable,"}, {"ID": 5, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); }\n\n    ### Response:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "predict": "/**\r\n     * Creates a new {@link UnicastProcessor} with the given capacity hint.\r\n     *\r\n     * @param capacityHint the capacity hint to use\r\n     * @param <T> the type of item emitted and received by the processor\r\n     * @return the new {@link UnicastProcessor}\r\n     * @throws NullPointerException if {@code capacityHint} is null\r\n     */\r\n    @CheckReturnValue\r\n    @NonNull\r\n    public static <T> UnicastProcessor<T> create(int capacityHint) {\r\n        return new UnicastProcessor<T>(capacityHint);\r\n    }"}, {"ID": 6, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) { ObjectHelper.requireNonNull(onCancelled, \"onTerminate\"); return new UnicastProcessor<T>(capacityHint, onCancelled); }\n\n    ### Response:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "predict": "/**\n     * Creates a new {@link UnicastProcessor} instance with the given capacity hint and a\n     * {@link Runnable} to be called when the processor is cancelled.\n     * <p>\n     * The returned processor will not be terminated until the returned {@link Disposable} is disposed.\n     * <p>\n     * Calling this method is equivalent to calling the constructor of {@link UnicastProcessor}.\n     *\n     * @param capacityHint the capacity hint to use\n     * @param onCancelled the {@link Runnable} to call when the processor is cancelled\n     * @param <T> the type of item emitted by the processor\n     * @return the new {@link UnicastProcessor} instance\n     * @throws NullPointerException if {@code onCancelled} is null\n     */\n    @CheckReturnValue\n    @NonNull\n    public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) {\n        ObjectHelper.requireNonNull(onCancelled, \"onTerminate\");\n        return new UnicastProcessor<T>(capacityHint, onCancelled);\n   "}, {"ID": 7, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (u == null) { EmptySubscription.complete(subscriber); return true; } subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u)); } else { r.subscribe(subscriber); } return true; } return false; }\n\n    ### Response:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param  the input value type\n@param  the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "predict": "/**\n     * Tries to subscribe to the source publisher and apply the mapper function to the result of the source publisher.\n     * If the result is a Callable, it will try to call it and subscribe to the result.\n     * If the result is not a Callable, it will subscribe to it directly.\n     * If the result is null, it will complete the subscriber.\n     * If the mapper function throws an exception, it will signal an error to the subscriber.\n     * If the source publisher throws an exception, it will signal an error to the subscriber.\n     * If the source publisher is a Callable and throws an exception, it will signal an error to the subscriber.\n     * If the source publisher is null, it will complete the subscriber.\n     *\n     * @param <T> the source value type\n     * @param <R> the result value type\n     * @param source the source publisher\n     * @param subscriber the subscriber to subscribe to the result publisher\n     * @param mapper the mapper function to apply to the source value\n     * @return true"}, {"ID": 8, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper)); }\n\n    ### Response:", "ground_truth": "Maps a scalar value into a Publisher and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "predict": "/**\n     * Maps the given value to a Publisher of a single element, and flattens the resulting Publisher into a single element.\n     *\n     * @param <T> the type of the input value\n     * @param <U> the type of the output value\n     * @param value the input value\n     * @param mapper the function that maps the input value to a Publisher of a single element\n     * @return a Flowable that emits the single element obtained by flattening the Publisher returned by the mapper function\n     */\n    public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) {\n        return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper));\n    }"}, {"ID": 9, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reset() { setErrorHandler(null); setScheduleHandler(null); setComputationSchedulerHandler(null); setInitComputationSchedulerHandler(null); setIoSchedulerHandler(null); setInitIoSchedulerHandler(null); setSingleSchedulerHandler(null); setInitSingleSchedulerHandler(null); setNewThreadSchedulerHandler(null); setInitNewThreadSchedulerHandler(null); setOnFlowableAssembly(null); setOnFlowableSubscribe(null); setOnObservableAssembly(null); setOnObservableSubscribe(null); setOnSingleAssembly(null); setOnSingleSubscribe(null); setOnCompletableAssembly(null); setOnCompletableSubscribe(null); setOnConnectableFlowableAssembly(null); setOnConnectableObservableAssembly(null); setOnMaybeAssembly(null); setOnMaybeSubscribe(null); setOnParallelAssembly(null); setFailOnNonBlockingScheduler(false); setOnBeforeBlocking(null); }\n\n    ### Response:", "ground_truth": "Removes all handlers and resets to default behavior.", "predict": "/**\n     * Resets all the handlers to their default values.\n     */\n    public static void reset() {\n        setErrorHandler(null);\n        setScheduleHandler(null);\n        setComputationSchedulerHandler(null);\n        setInitComputationSchedulerHandler(null);\n        setIoSchedulerHandler(null);\n        setInitIoSchedulerHandler(null);\n        setSingleSchedulerHandler(null);\n        setInitSingleSchedulerHandler(null);\n        setNewThreadSchedulerHandler(null);\n        setInitNewThreadSchedulerHandler(null);\n        setOnFlowableAssembly(null);\n        setOnFlowableSubscribe(null);\n        setOnObservableAssembly(null);\n        setOnObservableSubscribe(null);\n        setOnSingleAssembly(null);\n        setOnSingleSubscribe(null);\n        setOnCompletableAssembly(null);\n        setOnCompletableSubscribe(null);\n        setOnConnectableFlowableAssembly(null);\n        setOnConnectableObservableAssembly(null);\n        setOnMaybeAssembly(null);\n        setOnMaybeSubscribe(null);\n        setOnParallelAssembly("}, {"ID": 10, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); }\n\n    ### Response:", "ground_truth": "Wraps a CompletableSource into a Maybe.\n\n\nScheduler:\n{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "predict": "/**\n     * Converts a Completable into a Maybe.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromCompletable.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code fromCompletable} does not operate by default on a particular scheduler and\n     *  the subscribeOn operator can be used to specify a scheduler where the Completable\n     *  should be executed.</dd>\n     * </dl>\n     *\n     * @param completableSource\n     *            the Completable to convert\n     * @param <T>\n     *            the type of the item emitted by the Completable\n     * @return the new Maybe instance\n     * @throws NullPointerException\n     *             if completableSource is null\n     * @since 2.0\n     */\n    @CheckReturnValue\n    @NonNull\n    @"}, {"ID": 11, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) { ObjectHelper.requireNonNull(singleSource, \"singleSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource)); }\n\n    ### Response:", "ground_truth": "Wraps a SingleSource into a Maybe.\n\n\nScheduler:\n{@code fromSingle} does not operate by default on a particular {@link Scheduler}.\n\n@param  the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "predict": "/**\n     * Converts a Single into a Maybe.\n     * <p>\n     * <img width=\"640\" height=\"385\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromSingle.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code fromSingle} does not operate by default on a particular scheduler and\n     *  the subscribeOn operator can be used to specify a scheduler where the Single\n     *  should be executed.</dd>\n     * </dl>\n     *\n     * @param <T> the value type of the Single\n     * @param singleSource the Single to convert\n     * @return the new Maybe instance\n     * @throws NullPointerException if {@code singleSource} is null\n     * @since 2.0\n     */\n    @CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T> Maybe<T"}, {"ID": 12, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); }\n\n    ### Response:", "ground_truth": "Retries at most times or until the predicate returns false, whichever happens first.\n\n\nScheduler:\n{@code retry} does not operate by default on a particular {@link Scheduler}.\n\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "predict": "/**\n     * Retries the current Maybe source at most times or until the predicate condition is met.\n     *\n     * @param times the maximum number of times to retry.\n     * @param predicate the predicate to evaluate the error signal.\n     * @return the new Maybe instance that retries the current Maybe source at most times or until the predicate condition is met.\n     */\n    @CheckReturnValue\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) {\n        return toFlowable().retry(times, predicate).singleElement();\n    }"}, {"ID": 13, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T requireNonNull(T object, String message) { if (object == null) { throw new NullPointerException(message); } return object; }\n\n    ### Response:", "ground_truth": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param  the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "predict": "/**\r\n     * Returns the specified object if it is not null, otherwise throws a NullPointerException with the specified message.\r\n     * \r\n     * @param <T> the type of the object being checked\r\n     * @param object the object to check for nullity\r\n     * @param message the message to include in the NullPointerException if the object is null\r\n     * @return the object if it is not null\r\n     * @throws NullPointerException if the object is null\r\n     */\r\n    public static <T> T requireNonNull(T object, String message) {\r\n        if (object == null) {\r\n            throw new NullPointerException(message);\r\n        }\r\n        return object;\r\n    }"}, {"ID": 14, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; }\n\n    ### Response:", "ground_truth": "Returns an identity function that simply returns its argument.\n@param  the input and output value type\n@return the identity function", "predict": "/**\r\n     * Returns a function that returns the input argument.\r\n     *\r\n     * @param <T> the type of the input and output of the function\r\n     * @return a function that returns the input argument\r\n     */\r\n    @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; }"}, {"ID": 15, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); }\n\n    ### Response:", "ground_truth": "Returns a Callable that returns the given value.\n@param  the value type\n@param value the value to return\n@return the new Callable instance", "predict": "/**\r\n     * Returns a Callable that returns the given value.\r\n     *\r\n     * @param <T> the type of the value to be returned by the Callable\r\n     * @param value the value to be returned by the Callable\r\n     * @return a Callable that returns the given value\r\n     */\r\n    public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); }"}, {"ID": 16, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); }\n\n    ### Response:", "ground_truth": "Returns a Function that ignores its parameter and returns the given value.\n@param  the function's input type\n@param  the value and return type of the function\n@param value the value to return\n@return the new Function instance", "predict": "/**\r\n     * Returns a Function that always returns the given value.\r\n     *\r\n     * @param <T> the type of the input to the function\r\n     * @param <U> the type of the output of the function\r\n     * @param value the value to be returned by the function\r\n     * @return a Function that always returns the given value\r\n     */\r\n    public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); }"}, {"ID": 17, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); }\n\n    ### Response:", "ground_truth": "Returns a function that cast the incoming values via a Class object.\n@param  the input value type\n@param  the output and target type\n@param target the target class\n@return the new Function instance", "predict": "/**\r\n     * Returns a Function that casts objects of type T to type U.\r\n     * \r\n     * @param <T> the type of the input object\r\n     * @param <U> the type of the output object\r\n     * @param target the class to which objects of type T should be cast\r\n     * @return a Function that casts objects of type T to type U\r\n     */\r\n    public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); }"}, {"ID": 18, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param  the value type\n@return an UnicastSubject instance", "predict": "/**\n     * Creates a new {@link UnicastSubject} instance with a default buffer size of 16 and a default\n     * time-based scheduler.\n     * <p>\n     * The buffer size determines the maximum number of items that can be buffered by the subject before\n     * items are dropped. The time-based scheduler is used to drop items after a specified time interval\n     * if no observers are subscribed to the subject.\n     * <p>\n     * Note that the buffer size and time-based scheduler are configurable by calling the\n     * {@link #onBackpressureBuffer(int)} and {@link #onBackpressureDrop(long, TimeUnit)} methods\n     * respectively.\n     * <p>\n     * The returned subject is a hot and non-replayable subject that can be used to multicast a single\n     * item to multiple observers.\n     * <p>\n     * This method is thread-safe.\n     *\n     * @param <T> the type of item the subject will emit\n     * @return a new {@link Un"}, {"ID": 19, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "predict": "/**\n     * Creates a new {@link UnicastSubject} with the specified buffer capacity hint.\n     * <p>\n     * The buffer capacity hint is an indication of the expected number of items that will be\n     * added to the subject. The actual capacity of the subject may be greater or less than the hint.\n     * <p>\n     * Note that the capacity hint is a hint, not a requirement, and the subject may use a different\n     * capacity if it needs to grow beyond the hint.\n     * <p>\n     * The created subject is a hot and multicast subject, meaning that it can be subscribed to\n     * multiple times and it will multicast all of its items to all of its subscribers.\n     * <p>\n     * The returned subject is not thread-safe. If you need to use it from multiple threads, you\n     * should use appropriate synchronization.\n     *\n     * @param capacityHint the hint for the capacity of the buffer of the subject\n     * @param <T> the type of items that the subject will emit\n     *"}, {"ID": 20, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param  the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "predict": "/**\n     * Creates a new {@link UnicastSubject} with the given capacity hint and onTerminate action.\n     * <p>\n     * The onTerminate action is called when the last observer unsubscribes from the subject.\n     * <p>\n     * The created subject is a hot subject, meaning that it publishes its last value to any new observer.\n     * <p>\n     * The created subject is a non-null subject, meaning that it does not accept null values.\n     * <p>\n     * The created subject is a check-return-value subject, meaning that it throws an exception if the observer\n     * completes without a value.\n     *\n     * @param capacityHint the capacity hint for the subject's buffer, or {@code 16} if unspecified\n     * @param onTerminate the action to call when the last observer unsubscribes from the subject, or {@code null} if\n     *                    unspecified\n     * @param <T> the type of item emitted by the subject\n     * @return the new {@"}, {"ID": 21, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); }\n\n    ### Response:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\nThe callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\nHistory: 2.0.8 - experimental\n@param  the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "predict": "/**\n     * Creates a new {@link UnicastSubject} with the specified buffer size and delay-error mode.\n     *\n     * @param delayError\n     *            true if the subject should buffer errors until all observers have\n     *            received them, false if errors should be immediately emitted to\n     *            the first observer.\n     * @param <T>\n     *            the type of item observed and emitted by the subject\n     * @return a new {@link UnicastSubject}\n     */\n    @CheckReturnValue\n    @NonNull\n    public static <T> UnicastSubject<T> create(boolean delayError) {\n        return new UnicastSubject<T>(bufferSize(), delayError);\n    }"}, {"ID": 22, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Throwable blockingGetError() { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); await(); } catch (InterruptedException ex) { dispose(); return ex; } } return error; }\n\n    ### Response:", "ground_truth": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "predict": "/**\r\n     * Returns the error that occurred during a blocking operation.\r\n     * \r\n     * @return the error that occurred during a blocking operation, or null if no error occurred.\r\n     */\r\n    public Throwable blockingGetError() {\r\n        if (getCount() != 0) {\r\n            try {\r\n                BlockingHelper.verifyNonBlocking();\r\n                await();\r\n            } catch (InterruptedException ex) {\r\n                dispose();\r\n                return ex;\r\n            }\r\n        }\r\n        return error;\r\n    }"}, {"ID": 23, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; }\n\n    ### Response:", "ground_truth": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "predict": "/**\r\n     * Returns the error if the count is zero, otherwise blocks until the count becomes zero or the specified timeout elapses.\r\n     * \r\n     * @param timeout the maximum time to wait\r\n     * @param unit the time unit of the timeout argument\r\n     * @return the error, or null if the count is non-zero\r\n     * @throws InterruptedException if interrupted while waiting\r\n     * @throws TimeoutException if the specified timeout elapses before the count becomes zero\r\n     */\r\n    public Throwable blockingGetError(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException {\r\n        if (getCount() != 0) {\r\n            try {\r\n                BlockingHelper.verifyNonBlocking();\r\n                if (!await(timeout, unit)) {\r\n                    dispose();\r\n                    throw new TimeoutException(timeoutMessage(timeout, unit));\r\n                }\r\n            } catch (InterruptedException ex) {\r\n                dispose();\r\n                throw ex;\r\n            }\r\n        }\r\n        return error;\r\n    }"}, {"ID": 24, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; }\n\n    ### Response:", "ground_truth": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "predict": "/**\n     * Waits for the count to become zero or the specified timeout to elapse, whichever comes first.\n     * <p>\n     * If the count is zero, this method returns immediately with the value {@code true}.\n     * <p>\n     * If the current thread is interrupted while waiting, this method disposes the resource and re-interrupts the current thread.\n     * <p>\n     * If an error occurs while waiting, this method disposes the resource and throws the error.\n     *\n     * @param timeout the maximum time to wait\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if the count reached zero, or {@code false} if the timeout elapsed before the count reached zero\n     * @throws InterruptedException if the current thread is interrupted while waiting\n     * @throws Exception if an error occurs while waiting\n     */\n    public boolean blockingAwait(long timeout, TimeUnit unit) throws InterruptedException, Exception {\n        if (getCount() != 0) {\n            try {\n                Blocking"}, {"ID": 25, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\")); return; } } missed = qd.leave(-missed); if (missed == 0) { break; } } }\n\n    ### Response:", "ground_truth": "Drain the queue but give up with an error if there aren't enough requests.\n@param  the queue value type\n@param  the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "predict": "/**\n     * Drains the queue and emits events to the downstream until the queue is empty or the downstream is terminated.\n     * \n     * @param <T> the value type of the queue\n     * @param <U> the output value type\n     * @param q the queue to drain\n     * @param a the downstream subscriber\n     * @param delayError true if errors should be delayed until all values have been emitted, false otherwise\n     * @param dispose the Disposable to dispose on termination\n     * @param qd the queue drain to use\n     */\n    public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) {\n        int missed = 1;\n        for (;;) {\n            for (;;) {\n                boolean d = qd.done();\n                T v = q.poll();\n                boolean empty = v == null;\n                if (checkTerminated(d, empty, a, delayError,"}, {"ID": 26, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void request(Subscription s, int prefetch) { s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch); }\n\n    ### Response:", "ground_truth": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "predict": "/**\r\n     * Requests the given number of elements from the upstream publisher.\r\n     *\r\n     * @param s the subscription to request elements from\r\n     * @param prefetch the number of elements to request, or {@code Long.MAX_VALUE} to request an unbounded stream\r\n     */\r\n    public static void request(Subscription s, int prefetch) {\r\n        s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);\r\n    }"}, {"ID": 27, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } }\n\n    ### Response:", "ground_truth": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n\nDon't modify the queue after calling this method!\n\n\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param  the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "predict": "/**\n     * Post-processes the queue and signals the actual Subscriber with the onComplete signal if the queue is empty and the state is marked as complete.\n     *\n     * @param <T> the value type of the queue elements\n     * @param actual the Subscriber to signal with the onComplete signal if the queue is empty and the state is marked as complete\n     * @param queue the queue to post-process\n     * @param state the state of the queue, represented as a bitmask with the following bits:\n     * <ul>\n     *     <li>Bit 0: 1 if the queue is active, 0 otherwise</li>\n     *     <li>Bit 1: 1 if the queue is complete, 0 otherwise</li>\n     *     <li>Bits 2-63: the requested amount of elements to be drained from the queue</li>\n     * </ul>\n     * @param isCancelled a supplier that returns true if the subscription has been cancelled\n     */\n    public static <T> void post"}, {"ID": 28, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } }\n\n    ### Response:", "ground_truth": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "predict": "/**\n     * Completes the sequence with the given value.\n     *\n     * @param n the value to complete with\n     */\n    protected final void complete(R n) {\n        long p = produced;\n        if (p != 0) {\n            BackpressureHelper.produced(this, p);\n        }\n        for (;;) {\n            long r = get();\n            if ((r & COMPLETE_MASK) != 0) {\n                onDrop(n);\n                return;\n            }\n            if ((r & REQUEST_MASK) != 0) {\n                lazySet(COMPLETE_MASK + 1);\n                downstream.onNext(n);\n                downstream.onComplete();\n                return;\n            }\n            value = n;\n            if (compareAndSet(0, COMPLETE_MASK)) {\n                return;\n            }\n            value = null;\n        }\n    }"}, {"ID": 29, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; }\n\n    ### Response:", "ground_truth": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "predict": "/**\r\n     * Returns the value of the object.\r\n     *\r\n     * @return the value of the object, or null if the value is null or an error.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Nullable\r\n    public T getValue() {\r\n        Object o = value;\r\n        if (o != null && !NotificationLite.isError(o)) {\r\n            return (T) value;\r\n        }\r\n        return null;\r\n    }"}, {"ID": 30, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; }\n\n    ### Response:", "ground_truth": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "predict": "/**\n     * Returns the error object if the value is an error, otherwise returns null.\n     *\n     * @return the error object if the value is an error, otherwise returns null.\n     */\n    @Nullable public Throwable getError() {\n        Object o = value;\n        if (NotificationLite.isError(o)) {\n            return NotificationLite.getError(o);\n        }\n        return null;\n    }"}, {"ID": 31, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "predict": "/**\n     * Validates the given {@code observer} and returns true if it is valid, false otherwise.\n     * <p>\n     * This method checks if the given {@code observer} is null and throws a NullPointerException if it is.\n     * It then checks if the given {@code next} Disposable is null and throws a NullPointerException if it is.\n     * If the given {@code upstream} Disposable is not null, it disposes it and reports a double subscription to the given {@code observer}.\n     * If the given {@code upstream} Disposable is null, it returns true.\n     * <p>\n     * This method is thread-safe.\n     *\n     * @param upstream the upstream Disposable, not null\n     * @param next the next Disposable, not null\n     * @param observer the observer class, not null\n     * @return true if the observer is valid, false otherwise\n     * @throws NullPointerException if any of the arguments is null\n     */\n    public static boolean validate(Disposable upstream, Disposable next, Class<?> observer"}, {"ID": 32, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": "/**\n     * Atomically sets the {@code upstream} to the given {@code next} if it is {@code null},\n     * disposes the previous value if not {@code null}, and returns {@code true}.\n     * <p>\n     * If the {@code upstream} was already set, the previous value is disposed and the method\n     * returns {@code false}. If the previous value was already disposed, the method\n     * reports a double subscription to the given {@code observer} and returns {@code false}.\n     * <p>\n     * This method is thread-safe.\n     *\n     * @param <T> the type of the {@code Disposable}\n     * @param upstream the {@link AtomicReference} holding the current upstream {@code Disposable}\n     * @param next the {@code Disposable} to set as the new upstream\n     * @param observer the class of the observer that wants to subscribe to the upstream\n     * @return {@code true} if the {@code upstream} was set, {@code false} otherwise\n     * @"}, {"ID": 33, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "predict": "/**\n     * Validates the subscription chain by checking if the next subscription is null, and if the upstream subscription is not null, it cancels the next subscription and reports a double subscription error.\n     *\n     * @param upstream the upstream subscription, can be null\n     * @param next the next subscription, must not be null\n     * @param subscriber the subscriber class, used for reporting errors\n     * @return true if the subscription chain is valid, false otherwise\n     */\n    public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (upstream != null) {\n            next.cancel();\n            if (upstream != SubscriptionHelper.CANCELLED) {\n                reportDoubleSubscription(subscriber);\n            }\n            return false;\n        }\n        return true;\n    }"}, {"ID": 34, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; }\n\n    ### Response:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": "/**\n     * Atomically sets the given {@code next} {@link Subscription} if the current upstream {@link Subscription} is null,\n     * otherwise, cancels the current upstream and reports a double subscription to the given {@code subscriber}.\n     * <p>\n     * This method is thread-safe.\n     *\n     * @param upstream the {@link AtomicReference} holding the current upstream {@link Subscription}\n     * @param next the {@link Subscription} to set if the current upstream is null\n     * @param subscriber the class of the subscriber that wants to subscribe to the {@code next} {@link Subscription}\n     * @return true if the {@code next} {@link Subscription} was set, false otherwise\n     * @throws NullPointerException if {@code next} is null\n     */\n    public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) {\n        ObjectHelper.requireNonNull(next, \"next is null\");\n        if (!upstream.compareAndSet(null, next)) {\n            next.cancel();\n            if (upstream"}, {"ID": 35, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; }\n\n    ### Response:", "ground_truth": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "predict": "/**\r\n     * Adds two long values and caps the result at Long.MAX_VALUE if the result is negative.\r\n     * \r\n     * @param a the first long value\r\n     * @param b the second long value\r\n     * @return the sum of a and b, capped at Long.MAX_VALUE if the result is negative\r\n     */\r\n    public static long addCap(long a, long b) {\r\n        long u = a + b;\r\n        if (u < 0L) {\r\n            return Long.MAX_VALUE;\r\n        }\r\n        return u;\r\n    }"}, {"ID": 36, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; }\n\n    ### Response:", "ground_truth": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "predict": "/**\r\n     * This method multiplies two long values and checks if the result is within the maximum value of a long.\r\n     * If the result is outside the maximum value, it returns Long.MAX_VALUE.\r\n     * \r\n     * @param a the first long value to be multiplied\r\n     * @param b the second long value to be multiplied\r\n     * @return the result of the multiplication, or Long.MAX_VALUE if the result is outside the maximum value of a long\r\n     */\r\n    public static long multiplyCap(long a, long b) {\r\n        long u = a * b;\r\n        if (((a | b) >>> 31) != 0) {\r\n            if (u / a != b) {\r\n                return Long.MAX_VALUE;\r\n            }\r\n        }\r\n        return u;\r\n    }"}, {"ID": 37, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long add(AtomicLong requested, long n) { for (;;) { long r = requested.get(); if (r == Long.MAX_VALUE) { return Long.MAX_VALUE; } long u = addCap(r, n); if (requested.compareAndSet(r, u)) { return r; } } }\n\n    ### Response:", "ground_truth": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "predict": "/**\r\n * Atomically adds the given value to the current value of the given AtomicLong,\r\n * returning the updated value. If the current value is Long.MAX_VALUE, the\r\n * method returns Long.MAX_VALUE.\r\n *\r\n * @param requested the AtomicLong to be updated\r\n * @param n the value to be added to the current value of the AtomicLong\r\n * @return the updated value of the AtomicLong\r\n */\r\npublic static long add(AtomicLong requested, long n) {\r\n    for (;;) {\r\n        long r = requested.get();\r\n        if (r == Long.MAX_VALUE) {\r\n            return Long.MAX_VALUE;\r\n        }\r\n        long u = addCap(r, n);\r\n        if (requested.compareAndSet(r, u)) {\r\n            return r;\r\n        }\r\n    }\r\n}"}, {"ID": 38, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static NullPointerException toNpe(Throwable ex) { NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\"); npe.initCause(ex); return npe; }\n\n    ### Response:", "ground_truth": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "predict": "/**\r\n     * Converts a Throwable to a NullPointerException with a custom message and sets the cause of the exception to the original Throwable.\r\n     * \r\n     * @param ex the Throwable to convert to a NullPointerException\r\n     * @return a new NullPointerException with the custom message and the original Throwable as the cause\r\n     */\r\n    private static NullPointerException toNpe(Throwable ex) {\r\n        NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\");\r\n        npe.initCause(ex);\r\n        return npe;\r\n    }"}, {"ID": 39, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } }\n\n    ### Response:", "ground_truth": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "predict": "/**\r\n     * Adds an element to the end of the queue.\r\n     * \r\n     * @param o the element to be added to the queue\r\n     */\r\n    public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } }"}, {"ID": 40, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void shutdown() { ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null); if (exec != null) { exec.shutdownNow(); } POOLS.clear(); }\n\n    ### Response:", "ground_truth": "Stops the purge thread.", "predict": "/**\r\n * Shuts down the thread pool and clears the list of pools.\r\n */\r\npublic static void shutdown() {\r\n    ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null);\r\n    if (exec != null) {\r\n        exec.shutdownNow();\r\n    }\r\n    POOLS.clear();\r\n}"}, {"ID": 41, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; }\n\n    ### Response:", "ground_truth": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "predict": "/**\r\n     * Creates a new ScheduledExecutorService with a single thread and the given ThreadFactory.\r\n     *\r\n     * @param factory the ThreadFactory to use to create the thread\r\n     * @return a new ScheduledExecutorService with a single thread and the given ThreadFactory\r\n     */\r\n    public static ScheduledExecutorService create(ThreadFactory factory) {\r\n        final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\r\n        tryPutIntoPool(PURGE_ENABLED, exec);\r\n        return exec;\r\n    }"}, {"ID": 42, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); }\n\n    ### Response:", "ground_truth": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "predict": "/**\n     * Sets the subscription to the given value and requests the specified number of elements from it.\n     * <p>\n     * If the subscription is cancelled, the method will return without doing anything.\n     * <p>\n     * If the current number of requested elements is 0 and the CAS to 1 succeeds, the method will set the actual subscription and request the specified number of elements from it.\n     * <p>\n     * If the current number of requested elements is not 0, the method will add the given subscription to a queue of missed subscriptions and request the specified number of elements from the actual subscription.\n     * <p>\n     * If the current number of requested elements is not 0 and the CAS to 1 fails, the method will request the specified number of elements from the actual subscription.\n     * <p>\n     * If the current number of requested elements is not 0 and the CAS to 1 succeeds, the method will request the specified number of elements from the actual subscription.\n     * <p>\n    "}, {"ID": 43, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } }\n\n    ### Response:", "ground_truth": "Loops until all notifications in the queue has been processed.", "predict": "/**\r\n     * This method is responsible for emitting the events from the queue.\r\n     * It is called by the event loop in a separate thread.\r\n     * It uses a for loop with a label to repeatedly process the queue until it is empty.\r\n     * It uses a synchronized block to ensure that only one thread can access the queue at a time.\r\n     * It uses a while loop with a label to repeatedly call the forEachWhile method on the queue until it is empty.\r\n     * It uses a label to exit the loop if the queue becomes null or if the emitting flag is set to false.\r\n     */"}, {"ID": 44, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RuntimeException wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (RuntimeException)error; } return new RuntimeException(error); }\n\n    ### Response:", "ground_truth": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "predict": "/**\r\n     * Wraps the given {@code error} in a {@link RuntimeException} if it is an instance of {@link Error} or an instance of {@link RuntimeException}.\r\n     * Otherwise, returns a new {@link RuntimeException} with the given error message.\r\n     *\r\n     * @param error the error to wrap or throw\r\n     * @return the wrapped or thrown exception\r\n     */\r\n    public static RuntimeException wrapOrThrow(Throwable error) {\r\n        if (error instanceof Error) {\r\n            throw (Error) error;\r\n        }\r\n        if (error instanceof RuntimeException) {\r\n            return (RuntimeException) error;\r\n        }\r\n        return new RuntimeException(error);\r\n    }"}, {"ID": 45, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; }\n\n    ### Response:", "ground_truth": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "predict": "/**\r\n     * This method takes a Throwable object as input and returns a list of all the exceptions that are part of the composite exception.\r\n     * \r\n     * @param t - The Throwable object to be flattened.\r\n     * @return A list of all the exceptions that are part of the composite exception.\r\n     */\r\n    public static List<Throwable> flatten(Throwable t) {\r\n        List<Throwable> list = new ArrayList<Throwable>();\r\n        ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>();\r\n        deque.offer(t);\r\n        while (!deque.isEmpty()) {\r\n            Throwable e = deque.removeFirst();\r\n            if (e instanceof CompositeException) {\r\n                CompositeException ce = (CompositeException) e;\r\n                List<Throwable> exceptions = ce.getExceptions();\r\n                for (int i = exceptions.size() - 1; i >= 0; i--) {\r\n                    deque.offerFirst(exceptions.get(i));\r\n                }\r\n            } else {\r\n                list.add(e);\r\n            }\r\n        }\r\n        return list;\r\n    }"}, {"ID": 46, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return (Exception)e; } throw (E)e; }\n\n    ### Response:", "ground_truth": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param  the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "predict": "/**\r\n     * This method is used to throw an exception if the given Throwable is an instance of Exception.\r\n     * If the Throwable is not an instance of Exception, it is cast to the type E and thrown.\r\n     * \r\n     * @param <E> The type of exception to be thrown\r\n     * @param e The Throwable to be checked for exception\r\n     * @return An Exception if the given Throwable is an instance of Exception, otherwise the same Throwable cast to type E\r\n     * @throws E If the given Throwable is not an instance of Exception, it is cast to type E and thrown\r\n     */\r\n    @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E {\r\n        if (e instanceof Exception) {\r\n            return (Exception) e;\r\n        }\r\n        throw (E) e;\r\n    }"}, {"ID": 47, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); }\n\n    ### Response:", "ground_truth": "Atomically clears the container, then disposes all the previously contained Disposables.", "predict": "/**\r\n     * Clears the resources associated with this object.\r\n     *\r\n     * @throws IllegalStateException if the object has already been disposed.\r\n     */\r\n    public void clear() {\r\n        if (disposed) {\r\n            throw new IllegalStateException(\"Object has already been disposed\");\r\n        }\r\n        OpenHashSet<Disposable> set;\r\n        synchronized (this) {\r\n            if (disposed) {\r\n                throw new IllegalStateException(\"Object has already been disposed\");\r\n            }\r\n            set = resources;\r\n            resources = null;\r\n        }\r\n        dispose(set);\r\n    }"}, {"ID": 48, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int size() { if (disposed) { return 0; } synchronized (this) { if (disposed) { return 0; } OpenHashSet<Disposable> set = resources; return set != null ? set.size() : 0; } }\n\n    ### Response:", "ground_truth": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "predict": "/**\r\n     * Returns the number of resources in this set.\r\n     *\r\n     * @return the number of resources in this set\r\n     */\r\n    public int size() {\r\n        if (disposed) {\r\n            return 0;\r\n        }\r\n        synchronized (this) {\r\n            if (disposed) {\r\n                return 0;\r\n            }\r\n            OpenHashSet<Disposable> set = resources;\r\n            return set != null ? set.size() : 0;\r\n        }\r\n    }"}, {"ID": 49, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (u == null) { EmptyDisposable.complete(observer); return true; } ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u); observer.onSubscribe(sd); sd.run(); } else { r.subscribe(observer); } return true; } return false; }\n\n    ### Response:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param  the input value type\n@param  the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "predict": "/**\n     * Tries to subscribe to the source as a scalar value and then apply the mapper function to it.\n     * If the source is a Callable, it will be called and the result will be subscribed to.\n     * If the result is a Callable, it will be called and the result will be emitted to the downstream.\n     * If the result is not a Callable, it will be subscribed to directly.\n     * <p>\n     * If the source is not a Callable, the mapper function will be applied to it and the result will be subscribed to.\n     * <p>\n     * If the result is null, the downstream will be completed.\n     * <p>\n     * If any exception is thrown, the downstream will receive an onError event with the corresponding exception.\n     * <p>\n     * This method returns true if the source is a Callable and the result is a scalar value, false otherwise.\n     * <p>\n     * Note: This method is not thread-safe.\n     *\n     * @param <T> the source value"}, {"ID": 50, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); }\n\n    ### Response:", "ground_truth": "Maps a scalar value into an Observable and emits its values.\n\n@param  the scalar value type\n@param  the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "predict": "/**\n     * Maps the given value to an ObservableSource of a single element, and flattens the result by subscribing to it.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/scalarXMap.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code scalarXMap} does not operate by default on a particular scheduler and uses the {@code subscribeOn} and {@code observeOn} methods to control the\n     *  scheduler on which the underlying ObservableSource operates.</dd>\n     * </dl>\n     *\n     * @param <T> the type of the value to be mapped and flattened\n     * @param <U> the type of the element that the resulting ObservableSource will emit\n     * @param value the value to be mapped and flattened\n     * @param mapper"}, {"ID": 51, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; }\n\n    ### Response:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param  the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "predict": "/**\r\n     * Accepts a Subscriber and delivers any notifications it may have.\r\n     *\r\n     * @param subscriber the Subscriber to accept\r\n     * @return true if the Subscriber accepted at least one notification, false otherwise\r\n     */\r\n    public <U> boolean accept(Subscriber<? super U> subscriber) {\r\n        Object[] a = head;\r\n        final int c = capacity;\r\n        while (a != null) {\r\n            for (int i = 0; i < c; i++) {\r\n                Object o = a[i];\r\n                if (o == null) {\r\n                    break;\r\n                }\r\n                if (NotificationLite.acceptFull(o, subscriber)) {\r\n                    return true;\r\n                }\r\n            }\r\n            a = (Object[])a[c];\r\n        }\r\n        return false;\r\n    }"}, {"ID": 52, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; }\n\n    ### Response:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param  the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "predict": "/**\r\n     * Accepts an observer and returns true if the observer is accepted by at least one element in the list.\r\n     *\r\n     * @param observer the observer to accept\r\n     * @return true if the observer is accepted by at least one element in the list\r\n     */\r\n    public <U> boolean accept(Observer<? super U> observer) {\r\n        Object[] a = head;\r\n        final int c = capacity;\r\n        while (a != null) {\r\n            for (int i = 0; i < c; i++) {\r\n                Object o = a[i];\r\n                if (o == null) {\r\n                    break;\r\n                }\r\n                if (NotificationLite.acceptFull(o, observer)) {\r\n                    return true;\r\n                }\r\n            }\r\n            a = (Object[])a[c];\r\n        }\r\n        return false;\r\n    }"}, {"ID": 53, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } }\n\n    ### Response:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": "/**\n     * Initializes the subscription and the queue.\n     *\n     * @param bufferSize the size of the buffer to use for the queue\n     */\n    public void start(int bufferSize) {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscArrayQueue<T>(bufferSize);\n        }\n    }"}, {"ID": 54, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } }\n\n    ### Response:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": "/**\n     * Starts the unbounded flow by setting the upstream to an empty subscription and creating a new queue with the specified buffer size.\n     * @param bufferSize the buffer size for the queue\n     */\n    public void startUnbounded(int bufferSize) {\n        if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) {\n            queue = new SpscLinkedArrayQueue<T>(bufferSize);\n        }\n    }"}, {"ID": 55, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; }\n\n    ### Response:", "ground_truth": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "predict": "/**\n     * Adds the specified element to this queue, waiting if necessary for space to become available.\n     *\n     * @param t the element to add\n     * @return {@code true} if the element was added to this queue, else {@code false}\n     * @throws NullPointerException if the specified element is null\n     */\n    public boolean offer(T t) {\n        if (once.get()) {\n            return false;\n        }\n        ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\");\n        if (fusionMode == QueueSubscription.NONE) {\n            if (queue.offer(t)) {\n                drain();\n                return true;\n            }\n        }\n        return false;\n    }"}, {"ID": 56, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Nullable public Disposable get() { Disposable d = resource.get(); if (d == DisposableHelper.DISPOSED) { return Disposables.disposed(); } return d; }\n\n    ### Response:", "ground_truth": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "predict": "/**\r\n     * Returns the current value of the resource, or null if it has been disposed.\r\n     *\r\n     * @return the current value of the resource, or null if it has been disposed\r\n     */\r\n    @Nullable\r\n    public Disposable get() {\r\n        Disposable d = resource.get();\r\n        if (d == DisposableHelper.DISPOSED) {\r\n            return Disposables.disposed();\r\n        }\r\n        return d;\r\n    }"}, {"ID": 57, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } }\n\n    ### Response:", "ground_truth": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "predict": "/**\n     * Completes the sequence with the given value and sends it to downstream.\n     * \n     * @param value the value to complete with\n     */\n    public final void complete(T value) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        Observer<? super T> a = downstream;\n        if (state == FUSED_EMPTY) {\n            this.value = value;\n            lazySet(FUSED_READY);\n            a.onNext(null);\n        } else {\n            lazySet(TERMINATED);\n            a.onNext(value);\n        }\n        if (get() != DISPOSED) {\n            a.onComplete();\n        }\n    }"}, {"ID": 58, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); }\n\n    ### Response:", "ground_truth": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "predict": "/**\n     * Reports an error to the downstream subscriber(s) and terminates the sequence.\n     * <p>\n     * This method is thread-safe and may be invoked from multiple threads.\n     * <p>\n     * If the sequence is already terminated or disposed, the error is reported to the RxJavaPlugins error handler.\n     * <p>\n     * The method is final to prevent extension and ensure proper behavior of the operator chain.\n     * \n     * @param t the exception to report to the downstream subscriber(s)\n     */\n    public final void error(Throwable t) {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            RxJavaPlugins.onError(t);\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onError(t);\n    }"}, {"ID": 59, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); }\n\n    ### Response:", "ground_truth": "Complete the target without any value.", "predict": "/**\n     * Completes the stream by signalling the end of the sequence of elements.\n     * \n     * <p>\n     * This method is invoked by the last subscriber to the stream. Once invoked,\n     * the stream is considered complete and subsequent attempts to emit elements\n     * will result in an IllegalStateException.\n     * \n     * <p>\n     * This method is idempotent and thread-safe.\n     */\n    public final void complete() {\n        int state = get();\n        if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) {\n            return;\n        }\n        lazySet(TERMINATED);\n        downstream.onComplete();\n    }"}, {"ID": 60, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) { return concatMapDelayError(mapper, 2, true); }\n\n    ### Response:", "ground_truth": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that may throw an {@code IllegalStateException} when that\n{@code Publisher} completes.\nScheduler:\n{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.\n\n\n@param  the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "predict": "/**\n     * @param mapper the function to apply to each item emitted by the source Publisher\n     * @param prefetch the number of elements to prefetch from each inner Publisher\n     * @param delayError if true, the exception from any inner Publisher will be delayed until all elements from that Publisher have been emitted\n     * @param <R> the type of items emitted by the resulting Publisher\n     * @return a Flowable that emits the result of applying the given function to each item emitted by the source Publisher,\n     *         concatenating the results of the Publishers obtained from the function and emitting them in order,\n     *         with delays between each item and between each inner Publisher, and propagating any exception that occurs\n     */\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean delayError) {\n        return Flowable.concat"}, {"ID": 61, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) { return concatMapIterable(mapper, 2); }\n\n    ### Response:", "ground_truth": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n\nBackpressure:\nThe operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.\nScheduler:\n{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.\n\n\n@param \nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see ReactiveX operators documentation: FlatMap", "predict": "/**\n     * @param mapper the function to apply to each item emitted by the source Observable, that returns an Iterable of items, which are then emitted in turn by the resulting Observable.\n     * @return a Flowable that emits the items emitted by the Observables obtained by applying the specified function to each item emitted by the source Observable, in a sequential order.\n     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>\n     */\n    @CheckReturnValue\n    @BackpressureSupport(BackpressureKind.FULL)\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        return concatMapIterable(mapper, 2);\n    }"}, {"ID": 62, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @CheckReturnValue @NonNull @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction\"); return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); }\n\n    ### Response:", "ground_truth": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\nNote that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n\nBackpressure:\nThe operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).\nScheduler:\n{@code sorted} does not operate by default on a particular {@link Scheduler}.\n\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "predict": "/**\n     * Sorts the elements of this Flowable in ascending order according to the natural ordering of the\n     * elements or according to a specified Comparator.\n     * <p>\n     * The sort is performed on the elements emitted by the source Flowable.\n     * <p>\n     * Note that the source Flowable is expected to be finite. If the source is an infinite Flowable,\n     * the resulting Flowable will also be infinite.\n     * <p>\n     * This method modifies the source Flowable to be sorted.\n     * <p>\n     * The method returns a new Flowable, which will emit the sorted elements of the source Flowable.\n     * <p>\n     * Error signals are not delayed and may be lost if they are not consumed downstream.\n     * <p>\n     * The method is thread-safe.\n     * <p>\n     * The method is non-blocking.\n     * <p>\n     * The method supports backpressure.\n     * <p>\n     * The method is executed on the specified Scheduler"}, {"ID": 63, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PerfAsyncConsumer await(int count) { if (count <= 1000) { while (getCount() != 0) { } } else { try { await(); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } return this; }\n\n    ### Response:", "ground_truth": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "predict": "/**\r\n     * Waits for the specified number of messages to be consumed.\r\n     * \r\n     * @param count the number of messages to wait for\r\n     * @return the PerfAsyncConsumer instance\r\n     */\r\n    public PerfAsyncConsumer await(int count) {\r\n        if (count <= 1000) {\r\n            while (getCount() != 0) {\r\n            }\r\n        } else {\r\n            try {\r\n                await();\r\n            } catch (InterruptedException ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n        }\r\n        return this;\r\n    }"}, {"ID": 64, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void request(long n) { Subscription s = this.upstream; if (s != null) { s.request(n); } }\n\n    ### Response:", "ground_truth": "Requests from the upstream Subscription.\n@param n the request amount, positive", "predict": "/**\n     * Requests the specified number of elements from the upstream publisher.\n     *\n     * @param n the number of elements to request\n     */\n    protected final void request(long n) {\n        Subscription s = this.upstream;\n        if (s != null) {\n            s.request(n);\n        }\n    }"}, {"ID": 65, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    boolean add(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n + 1]; System.arraycopy(a, 0, b, 0, n); b[n] = ps; if (subscribers.compareAndSet(a, b)) { return true; } } }\n\n    ### Response:", "ground_truth": "Tries to add the given subscriber to the subscribers array atomically\nor returns false if the subject has terminated.\n@param ps the subscriber to add\n@return true if successful, false if the subject has terminated", "predict": "/**\n     * Adds the given PublishDisposable to the list of subscribers.\n     * \n     * @param ps the PublishDisposable to add\n     * @return true if the PublishDisposable was added successfully, false if the list was terminated\n     */\n    boolean add(PublishDisposable<T> ps) {\n        for (;;) {\n            PublishDisposable<T>[] a = subscribers.get();\n            if (a == TERMINATED) {\n                return false;\n            }\n            int n = a.length;\n            @SuppressWarnings(\"unchecked\")\n            PublishDisposable<T>[] b = new PublishDisposable[n + 1];\n            System.arraycopy(a, 0, b, 0, n);\n            b[n] = ps;\n            if (subscribers.compareAndSet(a, b)) {\n                return true;\n            }\n        }\n    }"}, {"ID": 66, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") void remove(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED || a == EMPTY) { return; } int n = a.length; int j = -1; for (int i = 0; i < n; i++) { if (a[i] == ps) { j = i; break; } } if (j < 0) { return; } PublishDisposable<T>[] b; if (n == 1) { b = EMPTY; } else { b = new PublishDisposable[n - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, n - j - 1); } if (subscribers.compareAndSet(a, b)) { return; } } }\n\n    ### Response:", "ground_truth": "Atomically removes the given subscriber if it is subscribed to the subject.\n@param ps the subject to remove", "predict": "/**\n     * Removes the specified PublishDisposable from the list of subscribers.\n     * <p>\n     * This method is thread-safe.\n     * \n     * @param ps the PublishDisposable to remove\n     */\n    @SuppressWarnings(\"unchecked\")\n    void remove(PublishDisposable<T> ps) {\n        for (;;) {\n            PublishDisposable<T>[] a = subscribers.get();\n            if (a == TERMINATED || a == EMPTY) {\n                return;\n            }\n            int n = a.length;\n            int j = -1;\n            for (int i = 0; i < n; i++) {\n                if (a[i] == ps) {\n                    j = i;\n                    break;\n                }\n            }\n            if (j < 0) {\n                return;\n            }\n            PublishDisposable<T>[] b;\n            if (n == 1) {\n                b = EMPTY;\n            } else {\n                b = new PublishDisposable[n - 1];\n                System.arraycopy(a, 0, b, 0,"}, {"ID": 67, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); }\n\n    ### Response:", "ground_truth": "Child Subscribers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param  the value type\n@param cf the ConnectableFlowable to wrap\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": "/**\n     * Observe the items of the given {@link ConnectableFlowable} on the specified {@link Scheduler} and return a new {@link ConnectableFlowableReplay} that replays the items to any subsequent\n     * {@link Subscriber}.\n     * <p>\n     * <img width=\"640\" height=\"380\" src=\"https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png\" alt=\"\">\n     * <dl>\n     *  <dt><b>Scheduler:</b></dt>\n     *  <dd>{@code observeOn} does not operate by default on a particular {@link Scheduler} and uses the {@code immediate} scheduler\n     *  if no scheduler is provided.</dd>\n     * </dl>\n     *\n     * @param cf\n     *            the {@link ConnectableFlowable} to observe\n     * @param scheduler\n     *            the {@link Scheduler} to observe on\n     * @param <T>\n     *            the type of"}, {"ID": 68, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \"'\" + getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } if (responseType == Response.class) { throw methodError(method, \"Response must include generic type (e.g., Response<String>)\"); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\"HEAD\") && !Void.class.equals(responseType)) { throw methodError(method, \"HEAD method must use Void as response type.\"); } Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable); } }\n\n    ### Response:", "ground_truth": "Inspects the annotations on an interface method to construct a reusable service method that\nspeaks HTTP. This requires potentially-expensive reflection so it is best to build each service\nmethod only once and reuse it.", "predict": "/**\n     * Parses the annotations on a Retrofit service method and returns an {@link HttpServiceMethod} that can be used to execute the method.\n     *\n     * @param retrofit the Retrofit instance that created the service method.\n     * @param method the service method to parse annotations for.\n     * @param requestFactory the {@link RequestFactory} to use to create the HTTP request.\n     * @param <ResponseT> the type of the HTTP response.\n     * @param <ReturnT> the type of the return value of the service method.\n     * @return an {@link HttpServiceMethod} that can be used to execute the method.\n     */\n    public static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(Retrofit retrofit, Method method, RequestFactory requestFactory) {\n        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;\n        boolean continuationWantsResponse = false;\n        boolean continuationBodyNullable = false;\n        Annotation[] annotations = method.getAnnotations();\n        Type"}, {"ID": 69, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDelay(long amount, TimeUnit unit) { if (amount < 0) { throw new IllegalArgumentException(\"Amount must be positive value.\"); } this.delayMs = unit.toMillis(amount); }\n\n    ### Response:", "ground_truth": "Set the network round trip delay.", "predict": "/**\r\n     * Sets the delay for the timer.\r\n     * \r\n     * @param amount the amount of time to delay\r\n     * @param unit the time unit of the amount\r\n     * @throws IllegalArgumentException if the amount is negative\r\n     */\r\n    public void setDelay(long amount, TimeUnit unit) {\r\n        if (amount < 0) {\r\n            throw new IllegalArgumentException(\"Amount must be positive value.\");\r\n        }\r\n        this.delayMs = unit.toMillis(amount);\r\n    }"}, {"ID": 70, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Response<?> createErrorResponse() { Response<?> call; try { call = errorFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; }\n\n    ### Response:", "ground_truth": "The HTTP error to be used when an error is triggered.", "predict": "/**\r\n     * Creates an error response object using the error factory.\r\n     * \r\n     * @return the error response object\r\n     * @throws IllegalStateException if the error factory returns null, or if it returns a successful response\r\n     */\r\n    public Response<?> createErrorResponse() {\r\n        Response<?> call;\r\n        try {\r\n            call = errorFactory.call();\r\n        } catch (Exception e) {\r\n            throw new IllegalStateException(\"Error factory threw an exception.\", e);\r\n        }\r\n        if (call == null) {\r\n            throw new IllegalStateException(\"Error factory returned null.\");\r\n        }\r\n        if (call.isSuccessful()) {\r\n            throw new IllegalStateException(\"Error factory returned successful response.\");\r\n        }\r\n        return call;\r\n    }"}, {"ID": 71, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long calculateDelay(TimeUnit unit) { float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta; // 0.2f --> 0.8f float upperBound = 1f + delta; // 0.2f --> 1.2f float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4) long callDelayMs = (long) (delayMs * delayPercent); return MILLISECONDS.convert(callDelayMs, unit); }\n\n    ### Response:", "ground_truth": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "predict": "/**\r\n     * Calculates the delay for a call based on the variance percentage and a random number generator.\r\n     * \r\n     * @param unit the time unit to convert the delay to\r\n     * @return the calculated delay in the specified time unit\r\n     */\r\n    public long calculateDelay(TimeUnit unit) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 72, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createSampleData(String username, String password) { Assert.notNull(documentDao, \"DocumentDao required\"); Assert.hasText(username, \"Username required\"); Authentication auth = new UsernamePasswordAuthenticationToken(username, password); try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder.getContext().setAuthentication(auth); // Create the home directory first Directory home = new Directory(username, Directory.ROOT_DIRECTORY); documentDao.create(home); addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN); addPermission(documentDao, home, \"ROLE_USER\", LEVEL_GRANT_READ); createFiles(documentDao, home); // Now create the confidential directory Directory confid = new Directory(\"confidential\", home); documentDao.create(confid); addPermission(documentDao, confid, \"ROLE_USER\", LEVEL_NEGATE_READ); createFiles(documentDao, confid); // Now create the shared directory Directory shared = new Directory(\"shared\", home); documentDao.create(shared); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_READ); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_WRITE); createFiles(documentDao, shared); } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder.clearContext(); } }\n\n    ### Response:", "ground_truth": "Creates a directory for the user, and a series of sub-directories. The root\ndirectory is the parent for the user directory. The sub-directories are\n\"confidential\" and \"shared\". The ROLE_USER will be given read and write access to\n\"shared\".", "predict": "/**\r\n     * This method creates sample data for the given user.\r\n     * \r\n     * @param username\r\n     *            The username of the user to create sample data for.\r\n     * @param password\r\n     *            The password of the user to create sample data for.\r\n     */\r\n    private void createSampleData(String username, String password) {\r\n        // TODO: Implement this method.\r\n    }"}, {"ID": 73, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; }\n\n    ### Response:", "ground_truth": "Provides a save way of obtaining the HttpMethod from a String. If the method is\ninvalid, returns null.\n\n@param method the HTTP method to use.\n\n@return the HttpMethod or null if method is invalid.", "predict": "/**\r\n     * Converts a string to an HttpMethod enum value.\r\n     *\r\n     * @param method the string to convert\r\n     * @return the corresponding HttpMethod enum value, or null if the string is not a valid value\r\n     */\r\n    private static HttpMethod valueOf(String method) {\r\n        try {\r\n            return HttpMethod.valueOf(method);\r\n        } catch (IllegalArgumentException e) {\r\n            // ignore\r\n        }\r\n        return null;\r\n    }"}, {"ID": 74, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public DirContextOperations searchForUser(String username) { if (logger.isDebugEnabled()) { logger.debug(\"Searching for user '\" + username + \"', with user search \" + this); } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate( contextSource); template.setSearchControls(searchControls); try { return template.searchForSingleEntry(searchBase, searchFilter, new String[] { username }); } catch (IncorrectResultSizeDataAccessException notFound) { if (notFound.getActualSize() == 0) { throw new UsernameNotFoundException(\"User \" + username + \" not found in directory.\"); } // Search should never return multiple results if properly configured, so just // rethrow throw notFound; } }\n\n    ### Response:", "ground_truth": "Return the LdapUserDetails containing the user's information\n\n@param username the username to search for.\n\n@return An LdapUserDetails object containing the details of the located user's\ndirectory entry\n\n@throws UsernameNotFoundException if no matching entry is found.", "predict": "/**\r\n     * Searches for a user by username in the LDAP directory.\r\n     *\r\n     * @param username the username to search for\r\n     * @return the DirContextOperations for the user, or null if not found\r\n     * @throws UsernameNotFoundException if the user is not found in the directory\r\n     */\r\n    @Override\r\n    public DirContextOperations searchForUser(String username) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 75, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(CharSequence rawPassword) { String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX; return digest(salt, rawPassword); }\n\n    ### Response:", "ground_truth": "Encodes the rawPass using a MessageDigest. If a salt is specified it will be merged\nwith the password before encoding.\n\n@param rawPassword The plain text password\n@return Hex string of password digest (or base64 encoded string if\nencodeHashAsBase64 is enabled.", "predict": "/**\r\n     * This method takes a raw password as input and returns a salted and hashed version of the password.\r\n     * \r\n     * @param rawPassword the password to be encoded\r\n     * @return the salted and hashed version of the password\r\n     */\r\n    public String encode(CharSequence rawPassword) {\r\n        String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX;\r\n        return digest(salt, rawPassword);\r\n    }"}, {"ID": 76, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matches(CharSequence rawPassword, String encodedPassword) { String salt = extractSalt(encodedPassword); String rawPasswordEncoded = digest(salt, rawPassword); return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded); }\n\n    ### Response:", "ground_truth": "Takes a previously encoded password and compares it with a rawpassword after mixing\nin the salt and encoding that value\n\n@param rawPassword plain text password\n@param encodedPassword previously encoded password\n@return true or false", "predict": "/**\r\n     * This method takes in a raw password and an encoded password and returns true if the raw password matches the encoded password.\r\n     *\r\n     * @param rawPassword the raw password to be checked against the encoded password\r\n     * @param encodedPassword the encoded password to be checked against the raw password\r\n     * @return true if the raw password matches the encoded password, false otherwise\r\n     */\r\n    public boolean matches(CharSequence rawPassword, String encodedPassword) {\r\n        String salt = extractSalt(encodedPassword);\r\n        String rawPasswordEncoded = digest(salt, rawPassword);\r\n        return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded);\r\n    }"}, {"ID": 77, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void performVersionChecks(String minSpringVersion) { if (minSpringVersion == null) { return; } // Check Spring Compatibility String springVersion = SpringVersion.getVersion(); String version = getVersion(); if (disableChecks(springVersion, version)) { return; } logger.info(\"You are running with Spring Security Core \" + version); if (new ComparableVersion(springVersion) .compareTo(new ComparableVersion(minSpringVersion)) < 0) { logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion); } }\n\n    ### Response:", "ground_truth": "Perform version checks with specific min Spring Version\n\n@param minSpringVersion", "predict": "/**\r\n     * Performs version checks to ensure compatibility with the specified minimum Spring version.\r\n     *\r\n     * @param minSpringVersion the minimum Spring version required for compatibility\r\n     */\r\n    private static void performVersionChecks(String minSpringVersion) {\r\n        if (minSpringVersion == null) {\r\n            return;\r\n        }\r\n        // Check Spring Compatibility\r\n        String springVersion = SpringVersion.getVersion();\r\n        String version = getVersion();\r\n        if (disableChecks(springVersion, version)) {\r\n            return;\r\n        }\r\n        logger.info(\"You are running with Spring Security Core \" + version);\r\n        if (new ComparableVersion(springVersion).compareTo(new ComparableVersion(minSpringVersion)) < 0) {\r\n            logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion);\r\n        }\r\n    }"}, {"ID": 78, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); }\n\n    ### Response:", "ground_truth": "Disable if springVersion and springSecurityVersion are the same to allow working\nwith Uber Jars.\n\n@param springVersion\n@param springSecurityVersion\n@return", "predict": "/**\r\n     * This method checks if the disable checks flag is set to true or not. If it is set to true, it returns true. If it is not set, it returns false.\r\n     * \r\n     * @param springVersion The version of Spring being used.\r\n     * @param springSecurityVersion The version of Spring Security being used.\r\n     * @return True if the disable checks flag is set to true, false otherwise.\r\n     */\r\n    private static boolean disableChecks(String springVersion, String springSecurityVersion) {\r\n        if (springVersion == null || springVersion.equals(springSecurityVersion)) {\r\n            return true;\r\n        }\r\n        return Boolean.getBoolean(DISABLE_CHECKS);\r\n    }"}, {"ID": 79, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getSpringVersion() { Properties properties = new Properties(); try { properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\")); } catch (IOException | NullPointerException e) { return null; } return properties.getProperty(\"org.springframework:spring-core\"); }\n\n    ### Response:", "ground_truth": "Loads the spring version or null if it cannot be found.\n@return", "predict": "/**\r\n     * Returns the version of Spring Core used by Spring Security.\r\n     *\r\n     * @return the Spring Core version, or null if it cannot be determined\r\n     */\r\n    private static String getSpringVersion() {\r\n        Properties properties = new Properties();\r\n        try {\r\n            properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\"));\r\n        } catch (IOException | NullPointerException e) {\r\n            return null;\r\n        }\r\n        return properties.getProperty(\"org.springframework:spring-core\");\r\n    }"}, {"ID": 80, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AttributeExchangeConfigurer attributeExchange(String identifierPattern) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer( identifierPattern); this.attributeExchangeConfigurers.add(attributeExchangeConfigurer); return attributeExchangeConfigurer; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Configures the attribute exchange for the current provider.\r\n     *\r\n     * @param identifierPattern the identifier pattern to use for attribute exchange\r\n     * @return the {@link AttributeExchangeConfigurer} for further customization\r\n     */\r\n    public AttributeExchangeConfigurer attributeExchange(String identifierPattern) {\r\n        AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer(identifierPattern);\r\n        this.attributeExchangeConfigurers.add(attributeExchangeConfigurer);\r\n        return attributeExchangeConfigurer;\r\n    }"}, {"ID": 81, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception { OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>()); this.postProcess(configurer); return configurer; }\n\n    ### Response:", "ground_truth": "Configures OAuth 2.0 Client support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ClientConfigurer} for further customizations\n@throws Exception", "predict": "/**\r\n     * Configures OAuth2 client support for the current {@link HttpSecurity}.\r\n     *\r\n     * @return the {@link OAuth2ClientConfigurer} to provide OAuth2 client configuration options\r\n     * @throws Exception if an error occurs while configuring OAuth2 client support\r\n     */\r\n    public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception {\r\n        OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>());\r\n        this.postProcess(configurer);\r\n        return configurer;\r\n    }"}, {"ID": 82, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception { OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); this.postProcess(configurer); return configurer; }\n\n    ### Response:", "ground_truth": "Configures OAuth 2.0 Resource Server support.\n\n@since 5.1\n@see OAuth 2.0 Authorization Framework\n@return the {@link OAuth2ResourceServerConfigurer} for further customizations\n@throws Exception", "predict": "/**\r\n     * Configures the OAuth2 resource server.\r\n     *\r\n     * @return the OAuth2 resource server configurer\r\n     * @throws Exception if an error occurs\r\n     */\r\n    public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception {\r\n        OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext()));\r\n        this.postProcess(configurer);\r\n        return configurer;\r\n    }"}, {"ID": 83, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); }\n\n    ### Response:", "ground_truth": "Configures channel security. In order for this configuration to be useful at least\none mapping to a required channel must be provided.\n\nExample Configuration\n\nThe example below demonstrates how to require HTTPs for every request. Only\nrequiring HTTPS for some requests is supported, but not recommended since an\napplication that allows for HTTP introduces many security vulnerabilities. For one\nsuch example, read about Firesheep.\n\n\n\n\n@return the {@link ChannelSecurityConfigurer} for further customizations\n@throws Exception", "predict": "/**\r\n     * Configures the channel security options for the current web application.\r\n     *\r\n     * @return the channel request matcher registry\r\n     * @throws Exception if an error occurs\r\n     */\r\n    public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception {\r\n        ApplicationContext context = getContext();\r\n        return getOrApply(new ChannelSecurityConfigurer<>(context)).getRegistry();\r\n    }"}, {"ID": 84, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean compare(final String dn, final String attributeName, final Object value) { final String comparisonFilter = \"(\" + attributeName + \"={0})\"; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext(DirContext ctx) throws NamingException { SearchControls ctls = new SearchControls(); ctls.setReturningAttributes(NO_ATTRS); ctls.setSearchScope(SearchControls.OBJECT_SCOPE); NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls); Boolean match = Boolean.valueOf(results.hasMore()); LdapUtils.closeEnumeration(results); return match; } } Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback()); return matches.booleanValue(); }\n\n    ### Response:", "ground_truth": "Performs an LDAP compare operation of the value of an attribute for a particular\ndirectory entry.\n\n@param dn the entry who's attribute is to be used\n@param attributeName the attribute who's value we want to compare\n@param value the value to be checked against the directory value\n\n@return true if the supplied value matches that in the directory", "predict": "/**\r\n     * Compares the value of an attribute in an LDAP entry with a given value.\r\n     * \r\n     * @param dn\r\n     *            the distinguished name of the LDAP entry to search\r\n     * @param attributeName\r\n     *            the name of the attribute to compare\r\n     * @param value\r\n     *            the value to compare the attribute with\r\n     * @return true if the attribute value matches the given value, false otherwise\r\n     * @throws NamingException\r\n     *             if an error occurs while searching for the LDAP entry or comparing the attribute values\r\n     */\r\n    public boolean compare(final String dn, final String attributeName, final Object value) throws NamingException {\r\n        // TODO Auto-generated method stub\r\n        return false;\r\n    }"}, {"ID": 85, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) { return (DirContextOperations) executeReadOnly(new ContextExecutor() { public Object executeWithContext(DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve); // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace())); } }); }\n\n    ### Response:", "ground_truth": "Composes an object from the attributes of the given DN.\n\n@param dn the directory entry which will be read\n@param attributesToRetrieve the named attributes which will be retrieved from the\ndirectory entry.\n\n@return the object created by the mapper", "predict": "/**\r\n     * Retrieves the entry with the specified distinguished name and retrieves the specified attributes.\r\n     * \r\n     * @param dn the distinguished name of the entry to retrieve\r\n     * @param attributesToRetrieve the attributes to retrieve\r\n     * @return the DirContextOperations object representing the retrieved entry\r\n     * @throws NamingException if an error occurs while retrieving the entry\r\n     */\r\n    public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) {\r\n        return (DirContextOperations) executeReadOnly(new ContextExecutor() {\r\n            public Object executeWithContext(DirContext ctx) throws NamingException {\r\n                Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve);\r\n                // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx));\r\n                return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace()));\r\n            }\r\n        });\r\n    }"}, {"ID": 86, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) { String[] attributeNames = new String[] { attributeName }; Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues( base, filter, params, attributeNames); Set<String> result = new HashSet<>(); for (Map<String, List<String>> map : multipleAttributeValues) { List<String> values = map.get(attributeName); if (values != null) { result.addAll(values); } } return result; }\n\n    ### Response:", "ground_truth": "Performs a search using the supplied filter and returns the union of the values of\nthe named attribute found in all entries matched by the search. Note that one\ndirectory entry may have several values for the attribute. Intended for role\nsearches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute who's values are to be retrieved.\n\n@return the set of String values for the attribute as a union of the values found\nin all the matching entries.", "predict": "/**\r\n     * This method searches for the values of a single attribute in the LDAP directory.\r\n     * \r\n     * @param base The base DN to search from.\r\n     * @param filter The filter to apply to the search.\r\n     * @param params The parameters to use in the filter.\r\n     * @param attributeName The name of the attribute to search for.\r\n     * @return A set of values for the specified attribute.\r\n     */\r\n    public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 87, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i = 0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, List<String>> record = new HashMap<String, List<String>>(); if (attributeNames == null || attributeNames.length == 0) { try { for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae .hasMore();) { Attribute attr = (Attribute) ae.next(); extractStringAttributeValues(adapter, record, attr.getID()); } } catch (NamingException x) { org.springframework.ldap.support.LdapUtils .convertLdapException(x); } } else { for (String attributeName : attributeNames) { extractStringAttributeValues(adapter, record, attributeName); } } record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter))); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null); search(base, formattedFilter, ctls, roleMapper); return set; }\n\n    ### Response:", "ground_truth": "Performs a search using the supplied filter and returns the values of each named\nattribute found in all entries matched by the search. Note that one directory entry\nmay have several values for the attribute. Intended for role searches and similar\nscenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching\nentries. The attribute name is the key for each set of values. In addition each map\ncontains the DN as a String with the key predefined key {@link #DN_KEY}.", "predict": "/**\n     * Searches for multiple attribute values in the directory.\n     * \n     * @param base the base of the search\n     * @param filter the filter to apply to the search\n     * @param params the parameters to escape and format the filter with\n     * @param attributeNames the names of the attributes to retrieve, or null to retrieve all attributes\n     * @return a set of maps, each containing the attribute values for a single entry\n     * @throws NamingException if an error occurs during the search\n     */\n    public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) throws NamingException { // Escape the params acording to RFC2254\n        Object[] encodedParams = new String[params.length];\n        for (int i = 0; i < params.length; i++) {\n            encodedParams[i] = LdapEncoder.filterEncode(params[i].toString());\n        }\n        String"}, {"ID": 88, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (DirContextAdapter) searchResult.getObject(); Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\"); if (logger.isDebugEnabled()) { logger.debug(\"Found DN: \" + dca.getDn()); } results.add(dca); } } catch (PartialResultException e) { LdapUtils.closeEnumeration(resultsEnum); logger.info(\"Ignoring PartialResultException\"); } if (results.size() == 0) { throw new IncorrectResultSizeDataAccessException(1, 0); } if (results.size() > 1) { throw new IncorrectResultSizeDataAccessException(1, results.size()); } return results.iterator().next(); }\n\n    ### Response:", "ground_truth": "Internal method extracted to avoid code duplication in AD search.", "predict": "/**\n     * Searches for a single entry in the directory using the specified search controls and filter.\n     *\n     * @param ctx the directory context to search in\n     * @param searchControls the search controls to use for the search\n     * @param base the base DN to search from\n     * @param filter the filter expression to use for the search\n     * @param params the parameters to use for the search\n     * @return the DirContextOperations for the single entry found\n     * @throws NamingException if an error occurs during the search\n     */\n    public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { }"}, {"ID": 89, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static SearchControls buildControls(SearchControls originalControls) { return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag()); }\n\n    ### Response:", "ground_truth": "We need to make sure the search controls has the return object flag set to true, in\norder for the search to return DirContextAdapter instances.\n@param originalControls\n@return", "predict": "/**\r\n     * Builds a new SearchControls object with the same settings as the original object, but with the return type set to OBJECT_SCOPE.\r\n     * \r\n     * @param originalControls the original SearchControls object\r\n     * @return a new SearchControls object with the same settings as the original object, but with the return type set to OBJECT_SCOPE\r\n     */\r\n    private static SearchControls buildControls(SearchControls originalControls) {\r\n        return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag());\r\n    }"}, {"ID": 90, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) { Assert.notNull(acls, \"ACLs are required\"); Assert.notEmpty(findNow, \"Items to find now required\"); String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size()); Set<Long> parentsToLookup = jdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { int i = 0; for (Long toFind : findNow) { i++; ps.setLong(i, toFind); } } }, new ProcessResultSet(acls, sids)); // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if (parentsToLookup.size() > 0) { lookupPrimaryKeys(acls, parentsToLookup, sids); } }\n\n    ### Response:", "ground_truth": "Locates the primary key IDs specified in \"findNow\", adding AclImpl instances with\nStubAclParents to the \"acls\" Map.\n\n@param acls the AclImpls (with StubAclParents)\n@param findNow Long-based primary keys to retrieve\n@param sids", "predict": "/**\n     * This method is responsible for looking up the primary keys of the given SIDs in the database. It first computes the SQL query to lookup the primary keys, based on the number of SIDs to find. It then executes the query using a JdbcTemplate, passing in a PreparedStatementSetter that sets the parameters for the query based on the SIDs to find. The method then processes the result set, adding the ACLs to the given Map for each SID found. If any SIDs are found to have parents, the method recursively calls itself to lookup those parents.\n     * \n     * @param acls\n     *            the Map to store the ACLs for each SID found\n     * @param findNow\n     *            the Set of SIDs to find now\n     * @param sids\n     *            the List of SIDs to find\n     */\n    private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) {\n        Assert.notNull(acls, \""}, {"ID": 91, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails( HttpServletRequest context) { Collection<String> j2eeUserRoles = getUserRoles(context); Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper .getGrantedAuthorities(j2eeUserRoles); if (logger.isDebugEnabled()) { logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\"); } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails( context, userGas); return result; }\n\n    ### Response:", "ground_truth": "Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)", "predict": "/**\n     * Builds a new instance of {@link PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails} based on the given\n     * {@link HttpServletRequest} and the mapped {@link GrantedAuthority}s obtained from the J2EE roles obtained from the\n     * request.\n     *\n     * @param context the {@link HttpServletRequest} to obtain the J2EE roles from.\n     * @return a new instance of {@link PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails} with the mapped\n     *         {@link GrantedAuthority}s obtained from the J2EE roles obtained from the request.\n     */\n    public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails(HttpServletRequest context) {\n        Collection<String> j2eeUserRoles = getUserRoles(context);\n        Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper.getGrantedAuthorities(j2eeUserRoles);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted"}, {"ID": 92, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); String suffix = element.getAttribute(ATT_ROOT_SUFFIX); if (!StringUtils.hasText(suffix)) { suffix = OPT_DEFAULT_ROOT_SUFFIX; } String port = element.getAttribute(ATT_PORT); if (!StringUtils.hasText(port)) { port = getDefaultPort(); if (logger.isDebugEnabled()) { logger.debug(\"Using default port of \" + port); } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder .rootBeanDefinition(CONTEXT_SOURCE_CLASS); contextSource.addConstructorArgValue(url); contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\"); contextSource.addPropertyValue(\"password\", \"secret\"); RootBeanDefinition apacheContainer = new RootBeanDefinition( \"org.springframework.security.ldap.server.ApacheDSContainer\", null, null); apacheContainer.setSource(source); apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix); String ldifs = element.getAttribute(ATT_LDIF_FILE); if (!StringUtils.hasText(ldifs)) { ldifs = OPT_DEFAULT_LDIF_FILE; } apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs); apacheContainer.getPropertyValues().addPropertyValue(\"port\", port); logger.info(\"Embedded LDAP server bean definition created for URL: \" + url); if (parserContext.getRegistry() .containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) { parserContext.getReaderContext().error( \"Only one embedded server bean is allowed per application context\", element); } parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer); return (RootBeanDefinition) contextSource.getBeanDefinition(); }\n\n    ### Response:", "ground_truth": "Will be called if no url attribute is supplied.\n\nRegisters beans to create an embedded apache directory server.\n\n@return the BeanDefinition for the ContextSource for the embedded server.\n\n@see ApacheDSContainer", "predict": "/**\n     * Creates a RootBeanDefinition for an embedded ApacheDS server.\n     *\n     * @param element the XML element that defines the embedded server\n     * @param parserContext the parser context\n     * @return the RootBeanDefinition for the embedded server\n     */\n    private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) {\n        // TODO: Implement method\n    }"}, {"ID": 93, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createServletApiFilter(BeanReference authenticationManager) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\"; final String DEF_SERVLET_API_PROVISION = \"true\"; String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION); if (!StringUtils.hasText(provideServletApi)) { provideServletApi = DEF_SERVLET_API_PROVISION; } if (\"true\".equals(provideServletApi)) { servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class); servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager); } }\n\n    ### Response:", "ground_truth": "Adds the servlet-api integration filter if required", "predict": "/**\r\n     * Creates a servlet API filter and registers it with the application context.\r\n     * \r\n     * @param authenticationManager the authentication manager to be used by the filter\r\n     */\r\n    private void createServletApiFilter(BeanReference authenticationManager) {\r\n        final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\";\r\n        final String DEF_SERVLET_API_PROVISION = \"true\";\r\n        String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION);\r\n        if (!StringUtils.hasText(provideServletApi)) {\r\n            provideServletApi = DEF_SERVLET_API_PROVISION;\r\n        }\r\n        if (\"true\".equals(provideServletApi)) {\r\n            servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class);\r\n            servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager);\r\n        }\r\n    }"}, {"ID": 94, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void createJaasApiFilter() { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\"; final String DEF_JAAS_API_PROVISION = \"false\"; String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION); if (!StringUtils.hasText(provideJaasApi)) { provideJaasApi = DEF_JAAS_API_PROVISION; } if (\"true\".equals(provideJaasApi)) { jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class); } }\n\n    ### Response:", "ground_truth": "Adds the jaas-api integration filter if required", "predict": "/**\r\n     * Creates a JAAS API filter based on the value of the \"jaas-api-provision\" attribute in the http element.\r\n     * If the attribute is not present or empty, the default value of \"false\" is used.\r\n     * If the attribute value is \"true\", a new RootBeanDefinition is created for the JaasApiIntegrationFilter.\r\n     */"}, {"ID": 95, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() { TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); result = result.init(JsonTypeInfo.Id.CLASS, null); result = result.inclusion(JsonTypeInfo.As.PROPERTY); return result; }\n\n    ### Response:", "ground_truth": "Creates a TypeResolverBuilder that performs whitelisting.\n@return a TypeResolverBuilder that performs whitelisting.", "predict": "/**\r\n     * Creates a new instance of the {@link WhitelistTypeResolverBuilder} with the default typing settings.\r\n     *\r\n     * @return a new instance of the {@link WhitelistTypeResolverBuilder} with the default typing settings.\r\n     */\r\n    private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() {\r\n        TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);\r\n        result = result.init(JsonTypeInfo.Id.CLASS, null);\r\n        result = result.inclusion(JsonTypeInfo.As.PROPERTY);\r\n        return result;\r\n    }"}, {"ID": 96, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = DEFAULT_FILTER_NAME; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy( filterName); String contextAttribute = getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } registerFilter(servletContext, true, filterName, springSecurityFilterChain); }\n\n    ### Response:", "ground_truth": "Registers the springSecurityFilterChain\n@param servletContext the {@link ServletContext}", "predict": "/**\r\n     * Inserts the Spring Security Filter Chain into the application's servlet context.\r\n     *\r\n     * @param servletContext the application's servlet context\r\n     */\r\n    private void insertSpringSecurityFilterChain(ServletContext servletContext) {\r\n        String filterName = DEFAULT_FILTER_NAME;\r\n        DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(filterName);\r\n        String contextAttribute = getWebApplicationContextAttribute();\r\n        if (contextAttribute != null) {\r\n            springSecurityFilterChain.setContextAttribute(contextAttribute);\r\n        }\r\n        registerFilter(servletContext, true, filterName, springSecurityFilterChain);\r\n    }"}, {"ID": 97, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) { try { return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() { public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException { return new PersistentRememberMeToken(rs.getString(1), rs .getString(2), rs.getString(3), rs.getTimestamp(4)); } }, seriesId); } catch (EmptyResultDataAccessException zeroResults) { if (logger.isDebugEnabled()) { logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults); } } catch (IncorrectResultSizeDataAccessException moreThanOne) { logger.error(\"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\"); } catch (DataAccessException e) { logger.error(\"Failed to load token for series \" + seriesId, e); } return null; }\n\n    ### Response:", "ground_truth": "Loads the token data for the supplied series identifier.\n\nIf an error occurs, it will be reported and null will be returned (since the result\nshould just be a failed persistent login).\n\n@param seriesId\n@return the token matching the series, or null if no match found or an exception\noccurred.", "predict": "/**\r\n     * Retrieves the token for the given series identifier.\r\n     *\r\n     * @param seriesId the series identifier\r\n     * @return the token, or null if none found\r\n     */\r\n    public PersistentRememberMeToken getTokenForSeries(String seriesId) {\r\n        try {\r\n            return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() {\r\n                public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n                    return new PersistentRememberMeToken(rs.getString(1), rs.getString(2), rs.getString(3), rs.getTimestamp(4));\r\n                }\r\n            }, seriesId);\r\n        } catch (EmptyResultDataAccessException zeroResults) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults);\r\n            }\r\n        } catch (IncorrectResultSizeDataAccessException moreThanOne) {\r\n            logger.error(\"Querying token for series '\" + seriesId + \"' returned more than"}, {"ID": 98, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { List<GrantedAuthority> result = new ArrayList<>(attributes.size()); for (String attribute : attributes) { result.add(getGrantedAuthority(attribute)); } return result; }\n\n    ### Response:", "ground_truth": "Map the given list of string attributes one-to-one to Spring Security\nGrantedAuthorities.", "predict": "/**\r\n     * This method takes a collection of attributes and returns a list of granted authorities for each attribute.\r\n     *\r\n     * @param attributes A collection of attributes to get granted authorities for.\r\n     * @return A list of granted authorities for each attribute in the input collection.\r\n     */\r\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {\r\n        List<GrantedAuthority> result = new ArrayList<>(attributes.size());\r\n        for (String attribute : attributes) {\r\n            result.add(getGrantedAuthority(attribute));\r\n        }\r\n        return result;\r\n    }"}, {"ID": 99, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cipher newCipher(String algorithm) { try { return Cipher.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e); } catch (NoSuchPaddingException e) { throw new IllegalStateException(\"Should not happen\", e); } }\n\n    ### Response:", "ground_truth": "Constructs a new Cipher.", "predict": "/**\r\n     * Creates a new Cipher object for the specified encryption algorithm.\r\n     *\r\n     * @param algorithm the name of the encryption algorithm to use\r\n     * @return a Cipher object for the specified algorithm\r\n     * @throws IllegalArgumentException if the algorithm is not valid\r\n     * @throws IllegalStateException if the Cipher object cannot be created\r\n     */\r\n    public static Cipher newCipher(String algorithm) {\r\n        try {\r\n            return Cipher.getInstance(algorithm);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e);\r\n        } catch (NoSuchPaddingException e) {\r\n            throw new IllegalStateException(\"Should not happen\", e);\r\n        }\r\n    }"}, {"ID": 100, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void afterPropertiesSet() { try { super.afterPropertiesSet(); } catch (ServletException e) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException(e); } Assert.notNull(authenticationManager, \"An AuthenticationManager must be set\"); }\n\n    ### Response:", "ground_truth": "Check whether all required properties have been set.", "predict": "/**\r\n     * This method is called by Spring after all properties have been set. It calls the super class's afterPropertiesSet method and catches any exceptions thrown. If an exception is caught, it is converted to a RuntimeException to passivity on the afterPropertiesSet signature. It also checks that an AuthenticationManager has been set.\r\n     */"}, {"ID": 101, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); }\n\n    ### Response:", "ground_truth": "Try to authenticate a pre-authenticated user with Spring Security if the user has\nnot yet been authenticated.", "predict": "/**\r\n * This method is called by the container each time a request/response pair is passed through the filter chain.\r\n * \r\n * @param request the incoming request object\r\n * @param response the outgoing response object\r\n * @param chain the filter chain object\r\n * @throws IOException if an I/O error occurs during request/response processing\r\n * @throws ServletException if a servlet error occurs during request/response processing\r\n */\r\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication());\r\n    }\r\n    if (requiresAuthentication((HttpServletRequest) request)) {\r\n        doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response);\r\n    }\r\n    chain.doFilter(request, response);\r\n}"}, {"ID": 102, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) { Object principal = getPreAuthenticatedPrincipal(request); if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) { return false; } if (principal != null && principal.equals(currentAuthentication.getPrincipal())) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\"); } return true; }\n\n    ### Response:", "ground_truth": "Determines if the current principal has changed. The default implementation tries\n\n\nIf the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is a String, the {@link Authentication#getName()} is compared against the pre authenticated principal\nOtherwise, the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is compared against the {@link Authentication#getPrincipal()}\n\n\nSubclasses can override this method to determine when a principal has changed.\n\n\n@param request\n@param currentAuthentication\n@return true if the principal has changed, else false", "predict": "/**\r\n     * Determines if the principal has changed since the last authentication.\r\n     * \r\n     * @param request the current HTTP request\r\n     * @param currentAuthentication the current authentication object\r\n     * @return true if the principal has changed, false otherwise\r\n     */\r\n    protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) {\r\n        Object principal = getPreAuthenticatedPrincipal(request);\r\n        if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) {\r\n            return false;\r\n        }\r\n        if (principal != null && principal.equals(currentAuthentication.getPrincipal())) {\r\n            return false;\r\n        }\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\");\r\n        }\r\n        return true;\r\n    }"}, {"ID": 103, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Authentication authResult; Object principal = getPreAuthenticatedPrincipal(request); Object credentials = getPreAuthenticatedCredentials(request); if (principal == null) { if (logger.isDebugEnabled()) { logger.debug(\"No pre-authenticated principal found in request\"); } return; } if (logger.isDebugEnabled()) { logger.debug(\"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\"); } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken( principal, credentials); authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); authResult = authenticationManager.authenticate(authRequest); successfulAuthentication(request, response, authResult); } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); if (!continueFilterChainOnUnsuccessfulAuthentication) { throw failed; } } }\n\n    ### Response:", "ground_truth": "Do the actual authentication for a pre-authenticated user.", "predict": "/**\r\n     * Performs authentication of the pre-authenticated principal obtained from the request.\r\n     *\r\n     * @param request the incoming request\r\n     * @param response the outgoing response\r\n     * @throws IOException if an I/O error occurs during the authentication process\r\n     * @throws ServletException if a servlet error occurs during the authentication process\r\n     */\r\n    private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 104, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkContentLength(long contentLengthToWrite) { this.contentWritten += contentLengthToWrite; boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength; int bufferSize = getBufferSize(); boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize; if (isBodyFullyWritten || requiresFlush) { doOnResponseCommitted(); } }\n\n    ### Response:", "ground_truth": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if\nthe response should be written.\n\n@param contentLengthToWrite the size of the content that is about to be written.", "predict": "/**\r\n     * Checks if the content length has been reached and flushes the buffer if necessary.\r\n     *\r\n     * @param contentLengthToWrite the length of the content to write\r\n     */\r\n    private void checkContentLength(long contentLengthToWrite) {\r\n        this.contentWritten += contentLengthToWrite;\r\n        boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength;\r\n        int bufferSize = getBufferSize();\r\n        boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize;\r\n        if (isBodyFullyWritten || requiresFlush) {\r\n            doOnResponseCommitted();\r\n        }\r\n    }"}, {"ID": 105, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; }\n\n    ### Response:", "ground_truth": "Creates a mapping of the supplied authorities based on the case-conversion and\nprefix settings. The mapping will be one-to-one unless duplicates are produced\nduring the conversion. If a default authority has been set, this will also be\nassigned to each mapping.\n\n@param authorities the original authorities\n\n@return the converted set of authorities", "predict": "/**\r\n     * Maps the given authorities to a new set of GrantedAuthority objects.\r\n     *\r\n     * @param authorities the authorities to map\r\n     * @return the mapped authorities\r\n     */\r\n    public Set<GrantedAuthority> mapAuthorities(Collection<? extends GrantedAuthority> authorities) {\r\n        HashSet<GrantedAuthority> mapped = new HashSet<>(authorities.size());\r\n        for (GrantedAuthority authority : authorities) {\r\n            mapped.add(mapAuthority(authority.getAuthority()));\r\n        }\r\n        if (defaultAuthority != null) {\r\n            mapped.add(defaultAuthority);\r\n        }\r\n        return mapped;\r\n    }"}, {"ID": 106, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); }\n\n    ### Response:", "ground_truth": "Specifies the URL to validate the credentials.\n\n@param loginProcessingUrl the URL to validate username and password\n@return the {@link FormLoginConfigurer} for additional customization", "predict": "/**\r\n     * Sets the login processing URL for the authentication filter.\r\n     * \r\n     * @param loginProcessingUrl the login processing URL to set\r\n     * @return the current instance of the object\r\n     */\r\n    public T loginProcessingUrl(String loginProcessingUrl) {\r\n        this.loginProcessingUrl = loginProcessingUrl;\r\n        authFilter.setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl));\r\n        return getSelf();\r\n    }"}, {"ID": 107, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } if (failureHandler == null) { failureUrl(loginPage + \"?error\"); } final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) { logoutConfigurer.logoutSuccessUrl(loginPage + \"?logout\"); } }\n\n    ### Response:", "ground_truth": "Updates the default values for authentication.\n\n@throws Exception", "predict": "/**\r\n     * Updates the default authentication settings for the application.\r\n     * \r\n     * This method should be called after the application has been fully configured.\r\n     * It sets the login processing URL to the login page if it has not been set,\r\n     * sets the failure URL to the login page with an error parameter if it has not been set,\r\n     * and sets the logout success URL to the login page with a logout parameter if it has not been set.\r\n     * \r\n     * @see org.springframework.security.config.annotation.web.builders.WebSecurity#authenticationDefaults(org.springframework.security.config.annotation.web.builders.AuthenticationManagerBuilder)\r\n     */\r\n    protected final void updateAuthenticationDefaults() {\r\n        if (loginProcessingUrl == null) {\r\n            loginProcessingUrl(loginPage);\r\n        }\r\n        if (failureHandler == null) {\r\n            failureUrl(loginPage + \"?error\");\r\n        }\r\n        final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer(LogoutConfigurer.class);\r\n        if (logoutConfigurer != null"}, {"ID": 108, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void updateAccessDefaults(B http) { if (permitAll) { PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl); } }\n\n    ### Response:", "ground_truth": "Updates the default values for access.", "predict": "/**\r\n     * Updates the access defaults for the given HTTP client.\r\n     * \r\n     * @param http the HTTP client to update\r\n     */\r\n    protected final void updateAccessDefaults(B http) {\r\n        if (permitAll) {\r\n            PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl);\r\n        }\r\n    }"}, {"ID": 109, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String mapPassword(Object passwordValue) { if (!(passwordValue instanceof String)) { // Assume it's binary passwordValue = new String((byte[]) passwordValue); } return (String) passwordValue; }\n\n    ### Response:", "ground_truth": "Extension point to allow customized creation of the user's password from the\nattribute stored in the directory.\n\n@param passwordValue the value of the password attribute\n@return a String representation of the password.", "predict": "/**\r\n     * Maps the given password value to a String.\r\n     * \r\n     * @param passwordValue the password value to map\r\n     * @return the mapped password value as a String\r\n     */\r\n    protected String mapPassword(Object passwordValue) {\r\n        if (!(passwordValue instanceof String)) {\r\n            // Assume it's binary\r\n            passwordValue = new String((byte[]) passwordValue);\r\n        }\r\n        return (String) passwordValue;\r\n    }"}, {"ID": 110, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String extractRememberMeCookie(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (cookieName.equals(cookie.getName())) { return cookie.getValue(); } } return null; }\n\n    ### Response:", "ground_truth": "Locates the Spring Security remember me cookie in the request and returns its\nvalue. The cookie is searched for by name and also by matching the context path to\nthe cookie path.\n\n@param request the submitted request which is to be authenticated\n@return the cookie value (if present), null otherwise.", "predict": "/**\r\n     * Extracts the remember me cookie value from the given HTTP request.\r\n     * \r\n     * @param request\r\n     *            the HTTP request\r\n     * @return the remember me cookie value, or null if not found\r\n     */\r\n    protected String extractRememberMeCookie(HttpServletRequest request) {\r\n        Cookie[] cookies = request.getCookies();\r\n        if ((cookies == null) || (cookies.length == 0)) {\r\n            return null;\r\n        }\r\n        for (Cookie cookie : cookies) {\r\n            if (cookieName.equals(cookie.getName())) {\r\n                return cookie.getValue();\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 111, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String encodeCookie(String[] cookieTokens) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cookieTokens.length; i++) { try { sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString())); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage(), e); } if (i < cookieTokens.length - 1) { sb.append(DELIMITER); } } String value = sb.toString(); sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes()))); while (sb.charAt(sb.length() - 1) == '=') { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Inverse operation of decodeCookie.\n\n@param cookieTokens the tokens to be encoded.\n@return base64 encoding of the tokens concatenated with the \":\" delimiter.", "predict": "/**\r\n     * Encodes the cookie tokens into a single string using the Base64 encoding scheme.\r\n     *\r\n     * @param cookieTokens the cookie tokens to be encoded\r\n     * @return the encoded cookie string\r\n     */\r\n    protected String encodeCookie(String[] cookieTokens) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < cookieTokens.length; i++) {\r\n            try {\r\n                sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString()));\r\n            } catch (UnsupportedEncodingException e) {\r\n                logger.error(e.getMessage(), e);\r\n            }\r\n            if (i < cookieTokens.length - 1) {\r\n                sb.append(DELIMITER);\r\n            }\r\n        }\r\n        String value = sb.toString();\r\n        sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes())));\r\n        while (sb.charAt(sb.length() - 1) == '=') {\r\n            sb.deleteCharAt(sb.length"}, {"ID": 112, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) { String cookieValue = encodeCookie(tokens); Cookie cookie = new Cookie(cookieName, cookieValue); cookie.setMaxAge(maxAge); cookie.setPath(getCookiePath(request)); if (cookieDomain != null) { cookie.setDomain(cookieDomain); } if (maxAge < 1) { cookie.setVersion(1); } if (useSecureCookie == null) { cookie.setSecure(request.isSecure()); } else { cookie.setSecure(useSecureCookie); } cookie.setHttpOnly(true); response.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "Sets the cookie on the response.\n\nBy default a secure cookie will be used if the connection is secure. You can set\nthe {@code useSecureCookie} property to {@code false} to override this. If you set\nit to {@code true}, the cookie will always be flagged as secure. By default the cookie\nwill be marked as HttpOnly.\n\n@param tokens the tokens which will be encoded to make the cookie value.\n@param maxAge the value passed to {@link Cookie#setMaxAge(int)}\n@param request the request\n@param response the response to add the cookie to.", "predict": "/**\r\n     * Sets the cookie with the given tokens and max age.\r\n     * \r\n     * @param tokens\r\n     *            the tokens to encode in the cookie\r\n     * @param maxAge\r\n     *            the maximum age of the cookie in seconds\r\n     * @param request\r\n     *            the current request\r\n     * @param response\r\n     *            the current response\r\n     */\r\n    protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) {\r\n        String cookieValue = encodeCookie(tokens);\r\n        Cookie cookie = new Cookie(cookieName, cookieValue);\r\n        cookie.setMaxAge(maxAge);\r\n        cookie.setPath(getCookiePath(request));\r\n        if (cookieDomain != null) {\r\n            cookie.setDomain(cookieDomain);\r\n        }\r\n        if (maxAge < 1) {\r\n            cookie.setVersion(1);\r\n        }\r\n        if (useSecureCookie == null) {\r\n            cookie.setSecure(request.isSecure());\r\n        } else {\r\n            cookie.setSecure(useSecureCookie);\r\n        }\r\n        cookie"}, {"ID": 113, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); }\n\n    ### Response:", "ground_truth": "resolve the argument to inject into the controller parameter.\n@param parameter the method parameter.\n@param bindingContext the binding context.\n@param exchange the server web exchange.\n@return the reactive mono object result.", "predict": "/**\n     * Resolves the argument for the given method parameter.\n     *\n     * @param parameter the method parameter to resolve the argument for\n     * @param bindingContext the binding context to use\n     * @param exchange the current server web exchange\n     * @return the resolved argument as a Mono\n     */\n    @Override\n    public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) {\n        ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType());\n        Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext();\n        if (reactiveSecurityContext == null) {\n            return null;\n        }\n        return reactiveSecurityContext.flatMap(a -> {\n            Object p = resolveSecurityContext(parameter, a);\n            Mono<Object> o = Mono.justOrEmpty(p);\n            return adapter == null ? o : Mono.just(adapter.fromPublisher(o));\n        });\n    }"}, {"ID": 114, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) { final String query = request.getQueryString(); if (query == null) { return null; } final String result = artifactPattern.matcher(query).replaceFirst(\"\"); if (result.length() == 0) { return null; } // strip off the trailing & only if the artifact was the first query param return result.startsWith(\"&\") ? result.substring(1) : result; }\n\n    ### Response:", "ground_truth": "If present, removes the artifactParameterName and the corresponding value from the\nquery String.\n@param request\n@return the query String minus the artifactParameterName and the corresponding\nvalue.", "predict": "/**\r\n     * Retrieves the query string from the request and replaces the first occurrence of the artifact pattern with an empty string.\r\n     * If the resulting string is empty, returns null. If the artifact was the first query parameter, strips off the trailing \"&\".\r\n     *\r\n     * @param request the HTTP request\r\n     * @param artifactPattern the pattern to match the artifact in the query string\r\n     * @return the modified query string or null if the artifact was not found or the resulting string is empty\r\n     */\r\n    private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) {\r\n        final String query = request.getQueryString();\r\n        if (query == null) {\r\n            return null;\r\n        }\r\n        final String result = artifactPattern.matcher(query).replaceFirst(\"\");\r\n        if (result.length() == 0) {\r\n            return null;\r\n        }\r\n        // strip off the trailing & only if the artifact was the first query param\r\n        return result.startsWith(\"&\") ? result.substring(1) : result;\r\n    }"}, {"ID": 115, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getServicePort(URL casServiceUrl) { int port = casServiceUrl.getPort(); if (port == -1) { port = casServiceUrl.getDefaultPort(); } return port; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Returns the port number of the CAS service URL.\r\n     * \r\n     * @param casServiceUrl the CAS service URL\r\n     * @return the port number of the CAS service URL\r\n     */\r\n    private static int getServicePort(URL casServiceUrl) {\r\n        int port = casServiceUrl.getPort();\r\n        if (port == -1) {\r\n            port = casServiceUrl.getDefaultPort();\r\n        }\r\n        return port;\r\n    }"}, {"ID": 116, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPrincipal() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); if (authentication == null) { log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\"); return \"\"; } Object principal = authentication.getPrincipal(); if (principal instanceof LdapUserDetails) { LdapUserDetails details = (LdapUserDetails) principal; return details.getDn(); } else if (authentication instanceof AnonymousAuthenticationToken) { if (log.isDebugEnabled()) { log.debug(\"Anonymous Authentication, returning empty String as Principal\"); } return \"\"; } else { throw new IllegalArgumentException( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\"); } }\n\n    ### Response:", "ground_truth": "Get the principals of the logged in user, in this case the distinguished name.\n\n@return the distinguished name of the logged in user.", "predict": "/**\r\n     * This method returns the principal of the current user.\r\n     * \r\n     * @return the principal of the current user.\r\n     */\r\n    public String getPrincipal() {\r\n        // code goes here\r\n    }"}, {"ID": 117, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, \"HttpServletRequest required\"); if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(\"Invalidating session: \" + session.getId()); session.invalidate(); } } if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } SecurityContextHolder.clearContext(); }\n\n    ### Response:", "ground_truth": "Requires the request to be passed in.\n\n@param request from which to obtain a HTTP session (cannot be null)\n@param response not used (can be null)\n@param authentication not used (can be null)", "predict": "/**\r\n     * Logs out the current user by invalidating the HTTP session and clearing the SecurityContextHolder.\r\n     *\r\n     * @param request the current HTTP request\r\n     * @param response the current HTTP response\r\n     * @param authentication the current user authentication\r\n     */\r\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\r\n        Assert.notNull(request, \"HttpServletRequest required\");\r\n        if (invalidateHttpSession) {\r\n            HttpSession session = request.getSession(false);\r\n            if (session != null) {\r\n                logger.debug(\"Invalidating session: \" + session.getId());\r\n                session.invalidate();\r\n            }\r\n        }\r\n        if (clearAuthentication) {\r\n            SecurityContext context = SecurityContextHolder.getContext();\r\n            context.setAuthentication(null);\r\n        }\r\n        SecurityContextHolder.clearContext();\r\n    }"}, {"ID": 118, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Authentication authenticate(Authentication auth) throws AuthenticationException { if (!(auth instanceof UsernamePasswordAuthenticationToken)) { return null; } UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth; Set<GrantedAuthority> authorities; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext( new InternalCallbackHandler(auth)); // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext.login(); // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet<>(); // Get the subject principals and pass them to each of the AuthorityGranters Set<Principal> principals = loginContext.getSubject().getPrincipals(); for (Principal principal : principals) { for (AuthorityGranter granter : this.authorityGranters) { Set<String> roles = granter.grant(principal); // If the granter doesn't wish to grant any authorities, it should // return null. if ((roles != null) && !roles.isEmpty()) { for (String role : roles) { authorities.add(new JaasGrantedAuthority(role, principal)); } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken( request.getPrincipal(), request.getCredentials(), new ArrayList<>(authorities), loginContext); // Publish the success event publishSuccessEvent(result); // we're done, return the token. return result; } catch (LoginException loginException) { AuthenticationException ase = this.loginExceptionResolver .resolveException(loginException); publishFailureEvent(request, ase); throw ase; } }\n\n    ### Response:", "ground_truth": "Attempts to login the user given the Authentication objects principal and\ncredential\n\n@param auth The Authentication object to be authenticated.\n\n@return The authenticated Authentication object, with it's grantedAuthorities set.\n\n@throws AuthenticationException This implementation does not handle 'locked' or\n'disabled' accounts. This method only throws a AuthenticationServiceException, with\nthe message of the LoginException that will be thrown, should the\nloginContext.login() method fail.", "predict": "/**\n     * Authenticates the given authentication request using the configured JAAS login modules.\n     *\n     * @param auth the authentication request to authenticate\n     * @return the authenticated token, or null if the authentication failed\n     * @throws AuthenticationException if the authentication failed due to an error\n     */\n    public Authentication authenticate(Authentication auth) throws AuthenticationException {\n        // TODO: Implement method\n    }"}, {"ID": 119, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String buildProviderUrl(List<String> urls, String baseDn) { Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\"); Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\"); String trimmedBaseDn = baseDn.trim(); StringBuilder providerUrl = new StringBuilder(); for (String serverUrl : urls) { String trimmedUrl = serverUrl.trim(); if (\"\".equals(trimmedUrl)) { continue; } providerUrl.append(trimmedUrl); if (!trimmedUrl.endsWith(\"/\")) { providerUrl.append(\"/\"); } providerUrl.append(trimmedBaseDn); providerUrl.append(\" \"); } return providerUrl.toString(); }\n\n    ### Response:", "ground_truth": "Builds a Spring LDAP-compliant Provider URL string, i.e. a space-separated list of\nLDAP servers with their base DNs. As the base DN must be identical for all servers,\nit needs to be supplied only once.\n\n@param urls A list of string values which are LDAP server URLs. An example would be\n\n\nldap://ldap.company.com:389\n\n\n. LDAPS URLs may be used as well, given that Spring Security is able to connect to\nthe server.\n@param baseDn The common Base DN for all provided servers, e.g.\n\n\ndc=company,dc=com\n\n\n.\n@return A Spring Security/Spring LDAP-compliant Provider URL string.", "predict": "/**\r\n     * Builds the provider URL for the LDAP server based on the provided list of URLs and the base DN.\r\n     * \r\n     * @param urls the list of LDAP server URLs\r\n     * @param baseDn the base DN for the LDAP server\r\n     * @return the provider URL for the LDAP server\r\n     * @throws IllegalArgumentException if the base DN is null or empty, or if the list of URLs is null or empty\r\n     */\r\n    private static String buildProviderUrl(List<String> urls, String baseDn) {\r\n        Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\");\r\n        Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\");\r\n        String trimmedBaseDn = baseDn.trim();\r\n        StringBuilder providerUrl = new StringBuilder();\r\n        for (String serverUrl : urls) {\r\n            String trimmedUrl = serverUrl.trim();\r\n            if (\"\".equals(trimmedUrl)) {\r\n                continue;\r\n            }\r\n            providerUrl.append(trimmedUrl);\r\n            if (!"}, {"ID": 120, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setContextEnvironmentProperties(Map<String, Object> environment) { Assert.notEmpty(environment, \"environment must not be empty\"); this.contextEnvironmentProperties = new Hashtable<>(environment); }\n\n    ### Response:", "ground_truth": "Allows a custom environment properties to be used to create initial LDAP context.\n\n@param environment the additional environment parameters to use when creating the LDAP Context", "predict": "/**\r\n     * Sets the context environment properties.\r\n     *\r\n     * @param environment the environment\r\n     */\r\n    public void setContextEnvironmentProperties(Map<String, Object> environment) {\r\n        Assert.notEmpty(environment, \"environment must not be empty\");\r\n        this.contextEnvironmentProperties = new Hashtable<>(environment);\r\n    }"}, {"ID": 121, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String getRedirectUrl() { return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString); }\n\n    ### Response:", "ground_truth": "Indicates the URL that the user agent used for this request.\n\n@return the full URL of this request", "predict": "/**\r\n     * Returns the redirect URL for the current request.\r\n     *\r\n     * @return the redirect URL for the current request.\r\n     */\r\n    @Override\r\n    public String getRedirectUrl() {\r\n        return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString);\r\n    }"}, {"ID": 122, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int doEndTag() throws JspException { try { if (!authorized && TagLibConfig.isUiSecurityDisabled()) { pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix()); } } catch (IOException e) { throw new JspException(e); } return EVAL_PAGE; }\n\n    ### Response:", "ground_truth": "Default processing of the end tag returning EVAL_PAGE.\n\n@return EVAL_PAGE\n@see Tag#doEndTag()", "predict": "/**\r\n     * This method is called by the JSP page compiler at the end of the tag.\r\n     * It writes the secured UI suffix to the output stream if the user is not authorized and the UI security is disabled.\r\n     * \r\n     * @return EVAL_PAGE\r\n     * @throws JspException\r\n     */"}, {"ID": 123, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void initUserDetailsService() throws Exception { for (UserDetailsBuilder userBuilder : userBuilders) { getUserDetailsService().createUser(userBuilder.build()); } for (UserDetails userDetails : this.users) { getUserDetailsService().createUser(userDetails); } }\n\n    ### Response:", "ground_truth": "Populates the users that have been added.\n\n@throws Exception", "predict": "/**\r\n     * Initializes the user details service with the given user details.\r\n     * \r\n     * @throws Exception\r\n     */\r\n    @Override\r\n    protected void initUserDetailsService() throws Exception {\r\n        for (UserDetailsBuilder userBuilder : userBuilders) {\r\n            getUserDetailsService().createUser(userBuilder.build());\r\n        }\r\n        for (UserDetails userDetails : this.users) {\r\n            getUserDetailsService().createUser(userDetails);\r\n        }\r\n    }"}, {"ID": 124, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private UserDetailsService getUserDetailsService() { Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class); if (beans.size() == 0) { beans = getBeansOfType(UserDetailsService.class); } if (beans.size() == 0) { throw new ApplicationContextException(\"No UserDetailsService registered.\"); } else if (beans.size() > 1) { throw new ApplicationContextException( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\"); } return (UserDetailsService) beans.values().toArray()[0]; }\n\n    ### Response:", "ground_truth": "Obtains a user details service for use in RememberMeServices etc. Will return a\ncaching version if available so should not be used for beans which need to separate\nthe two.", "predict": "/**\r\n     * Returns the UserDetailsService instance from the application context.\r\n     * \r\n     * @return the UserDetailsService instance\r\n     * @throws ApplicationContextException if no UserDetailsService is registered or more than one is registered\r\n     */\r\n    private UserDetailsService getUserDetailsService() {\r\n        Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class);\r\n        if (beans.size() == 0) {\r\n            beans = getBeansOfType(UserDetailsService.class);\r\n        }\r\n        if (beans.size() == 0) {\r\n            throw new ApplicationContextException(\"No UserDetailsService registered.\");\r\n        } else if (beans.size() > 1) {\r\n            throw new ApplicationContextException(\r\n                    \"More than one UserDetailsService registered. Please \"\r\n                            + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\");\r\n        }\r\n        return (UserDetailsService) beans.values().toArray()[0];\r\n    }"}, {"ID": 125, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) { String codeVerifier = this.codeVerifierGenerator.generateKey(); attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier); try { String codeChallenge = createCodeChallenge(codeVerifier); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\"); } catch (NoSuchAlgorithmException e) { additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier); } }\n\n    ### Response:", "ground_truth": "Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests\n\n@param attributes where {@link PkceParameterNames#CODE_VERIFIER} is stored for the token request\n@param additionalParameters where {@link PkceParameterNames#CODE_CHALLENGE} and, usually,\n{@link PkceParameterNames#CODE_CHALLENGE_METHOD} are added to be used in the authorization request.\n\n@since 5.2\n@see 1.1.  Protocol Flow\n@see 4.1.  Client Creates a Code Verifier\n@see 4.2.  Client Creates the Code Challenge", "predict": "/**\n     * Adds PKCE parameters to the provided attributes map and additional parameters map.\n     *\n     * @param attributes the attributes map to add the PKCE parameters to\n     * @param additionalParameters the additional parameters map to add the PKCE parameters to\n     */\n    private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) {\n        String codeVerifier = this.codeVerifierGenerator.generateKey();\n        attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier);\n        try {\n            String codeChallenge = createCodeChallenge(codeVerifier);\n            additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge);\n            additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\");\n        } catch (NoSuchAlgorithmException e) {\n            additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier);\n        }\n    }"}, {"ID": 126, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { final boolean serviceTicketRequest = serviceTicketRequest(request, response); final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request)); if (logger.isDebugEnabled()) { logger.debug(\"requiresAuthentication = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Overridden to provide proxying capabilities.", "predict": "/**\r\n     * Determines whether the request requires authentication based on the request parameters.\r\n     * \r\n     * @param request\r\n     *            the HTTP request\r\n     * @param response\r\n     *            the HTTP response\r\n     * @return true if the request requires authentication, false otherwise\r\n     */\r\n    protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\r\n        final boolean serviceTicketRequest = serviceTicketRequest(request, response);\r\n        final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request));\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"requiresAuthentication = \" + result);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 127, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to process a service ticket. This method exists\nfor readability.\n@param request\n@param response\n@return", "predict": "/**\r\n     * This method is used to check if the request requires authentication or not.\r\n     * \r\n     * @param request\r\n     *            The HTTP request object.\r\n     * @param response\r\n     *            The HTTP response object.\r\n     * @return True if the request requires authentication, false otherwise.\r\n     */\r\n    private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) {\r\n        boolean result = super.requiresAuthentication(request, response);\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"serviceTicketRequest = \" + result);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 128, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { if (serviceTicketRequest) { return false; } final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated(); if (logger.isDebugEnabled()) { logger.debug(\"proxyTicketRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to process a proxy ticket.\n@param request\n@return", "predict": "/**\r\n     * This method is responsible for handling the proxy ticket request.\r\n     * \r\n     * @param serviceTicketRequest\r\n     *            - boolean indicating whether the request is for service ticket or not.\r\n     * @param request\r\n     *            - the http request object.\r\n     * @return boolean indicating whether the proxy ticket request is successful or not.\r\n     */\r\n    private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) {\r\n        if (serviceTicketRequest) {\r\n            return false;\r\n        }\r\n        final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated();\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"proxyTicketRequest = \" + result);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 129, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean authenticated() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken); }\n\n    ### Response:", "ground_truth": "Determines if a user is already authenticated.\n@return", "predict": "/**\r\n     * Checks if the user is authenticated.\r\n     *\r\n     * @return true if the user is authenticated, false otherwise.\r\n     */\r\n    private boolean authenticated() {\r\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\r\n        return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken);\r\n    }"}, {"ID": 130, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; }\n\n    ### Response:", "ground_truth": "Indicates if the request is elgible to be processed as the proxy receptor.\n@param request\n@return", "predict": "/**\r\n     * Checks if the request matches the configured proxy receptor.\r\n     * \r\n     * @param request\r\n     *            the HTTP request\r\n     * @return true if the request matches the configured proxy receptor, false otherwise\r\n     */\r\n    private boolean proxyReceptorRequest(final HttpServletRequest request) {\r\n        final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request);\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"proxyReceptorRequest = \" + result);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 131, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MethodSecurityExpressionOperations createSecurityExpressionRoot( Authentication authentication, MethodInvocation invocation) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot( authentication); root.setThis(invocation.getThis()); root.setPermissionEvaluator(getPermissionEvaluator()); root.setTrustResolver(getTrustResolver()); root.setRoleHierarchy(getRoleHierarchy()); root.setDefaultRolePrefix(getDefaultRolePrefix()); return root; }\n\n    ### Response:", "ground_truth": "Creates the root object for expression evaluation.", "predict": "/**\r\n     * Creates a new instance of the {@link MethodSecurityExpressionRoot} for the given {@link Authentication} and {@link MethodInvocation}.\r\n     *\r\n     * @param authentication the current authentication object.\r\n     * @param invocation the current method invocation.\r\n     * @return a new instance of the {@link MethodSecurityExpressionRoot}.\r\n     */\r\n    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, MethodInvocation invocation) {\r\n        MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot(authentication);\r\n        root.setThis(invocation.getThis());\r\n        root.setPermissionEvaluator(getPermissionEvaluator());\r\n        root.setTrustResolver(getTrustResolver());\r\n        root.setRoleHierarchy(getRoleHierarchy());\r\n        root.setDefaultRolePrefix(getDefaultRolePrefix());\r\n        return root;\r\n    }"}, {"ID": 132, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Mono<JWKSet> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); }\n\n    ### Response:", "ground_truth": "Updates the cached JWK set from the configured URL.\n\n@return The updated JWK set.\n\n@throws RemoteKeySourceException If JWK retrieval failed.", "predict": "/**\n     * Retrieves the JWK Set from the configured URL and caches it for future use.\n     *\n     * @return A Mono that emits the JWK Set.\n     */\n    private Mono<JWKSet> getJWKSet() {\n        return this.webClient.get()\n                .uri(this.jwkSetURL)\n                .retrieve()\n                .bodyToMono(String.class)\n                .map(this::parse)\n                .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet)))\n                .cache();\n    }"}, {"ID": 133, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String utf8UrlEncode(String value) { try { return URLEncoder.encode(value, \"UTF-8\"); } catch (UnsupportedEncodingException e) { Error err = new AssertionError( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\"); err.initCause(e); throw err; } }\n\n    ### Response:", "ground_truth": "Performs URL encoding with UTF-8\n\n@param value the value to URL encode\n@return the encoded value", "predict": "/**\r\n     * Encodes the given string as a URL using the UTF-8 encoding scheme.\r\n     *\r\n     * @param value the string to encode\r\n     * @return the encoded URL\r\n     * @throws AssertionError if the Java platform does not support the UTF-8 encoding scheme\r\n     */\r\n    private String utf8UrlEncode(String value) {\r\n        try {\r\n            return URLEncoder.encode(value, \"UTF-8\");\r\n        } catch (UnsupportedEncodingException e) {\r\n            Error err = new AssertionError(\"The Java platform guarantees UTF-8 support, but it seemingly is not present.\");\r\n            err.initCause(e);\r\n            throw err;\r\n        }\r\n    }"}, {"ID": 134, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() { List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser(); Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper .getGrantedAuthorities(webSphereGroups); if (logger.isDebugEnabled()) { logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas); } return userGas; }\n\n    ### Response:", "ground_truth": "Get a list of Granted Authorities based on the current user's WebSphere groups.\n\n@return authorities mapped from the user's WebSphere groups.", "predict": "/**\r\n     * This method retrieves the WebSphere groups for the current user and maps them to a collection of granted authorities using the webSphereGroups2GrantedAuthoritiesMapper.\r\n     * \r\n     * @return a collection of granted authorities based on the WebSphere groups of the current user.\r\n     */\r\n    private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() {\r\n        List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser();\r\n        Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper.getGrantedAuthorities(webSphereGroups);\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas);\r\n        }\r\n        return userGas;\r\n    }"}, {"ID": 135, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected UserDetails loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken( assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); }\n\n    ### Response:", "ground_truth": "Template method for retrieving the UserDetails based on the assertion. Default is\nto call configured userDetailsService and pass the username. Deployers can override\nthis method and retrieve the user based on any criteria they desire.\n\n@param assertion The CAS Assertion.\n@return the UserDetails.", "predict": "/**\r\n     * Loads the user details for the given assertion.\r\n     *\r\n     * @param assertion the assertion to load the user details for\r\n     * @return the user details for the given assertion\r\n     */\r\n    protected UserDetails loadUserByAssertion(final Assertion assertion) {\r\n        final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken(assertion, \"\");\r\n        return this.authenticationUserDetailsService.loadUserDetails(token);\r\n    }"}, {"ID": 136, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = wasHelper.getCurrentUserName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated WebSphere principal: \" + principal); } return principal; }\n\n    ### Response:", "ground_truth": "Return the WebSphere user name.", "predict": "/**\r\n     * Retrieves the pre-authenticated principal from the WebSphere session.\r\n     * \r\n     * @param httpRequest\r\n     *            the HTTP request object\r\n     * @return the pre-authenticated principal, or null if not found\r\n     */\r\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {\r\n        Object principal = wasHelper.getCurrentUserName();\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"PreAuthenticated WebSphere principal: \" + principal);\r\n        }\r\n        return principal;\r\n    }"}, {"ID": 137, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] concatenate(byte[]... arrays) { int length = 0; for (byte[] array : arrays) { length += array.length; } byte[] newArray = new byte[length]; int destPos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, newArray, destPos, array.length); destPos += array.length; } return newArray; }\n\n    ### Response:", "ground_truth": "Combine the individual byte arrays into one array.", "predict": "/**\r\n     * Concatenates multiple byte arrays into a single byte array.\r\n     * \r\n     * @param arrays the arrays to concatenate\r\n     * @return the concatenated byte array\r\n     */\r\n    public static byte[] concatenate(byte[]... arrays) {\r\n        int length = 0;\r\n        for (byte[] array : arrays) {\r\n            length += array.length;\r\n        }\r\n        byte[] newArray = new byte[length];\r\n        int destPos = 0;\r\n        for (byte[] array : arrays) {\r\n            System.arraycopy(array, 0, newArray, destPos, array.length);\r\n            destPos += array.length;\r\n        }\r\n        return newArray;\r\n    }"}, {"ID": 138, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] subArray(byte[] array, int beginIndex, int endIndex) { int length = endIndex - beginIndex; byte[] subarray = new byte[length]; System.arraycopy(array, beginIndex, subarray, 0, length); return subarray; }\n\n    ### Response:", "ground_truth": "Extract a sub array of bytes out of the byte array.\n@param array the byte array to extract from\n@param beginIndex the beginning index of the sub array, inclusive\n@param endIndex the ending index of the sub array, exclusive", "predict": "/**\r\n * This method takes in a byte array, a starting index, and an ending index, and returns a new byte array that is a subarray of the original array.\r\n * \r\n * @param array - the original byte array\r\n * @param beginIndex - the starting index of the subarray\r\n * @param endIndex - the ending index of the subarray\r\n * @return a new byte array that is a subarray of the original array\r\n */\r\npublic static byte[] subArray(byte[] array, int beginIndex, int endIndex) {\r\n    int length = endIndex - beginIndex;\r\n    byte[] subarray = new byte[length];\r\n    System.arraycopy(array, beginIndex, subarray, 0, length);\r\n    return subarray;\r\n}"}, {"ID": 139, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { ArrayList<GrantedAuthority> gaList = new ArrayList<>(); for (String attribute : attributes) { Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap .get(attribute); if (c != null) { gaList.addAll(c); } } gaList.trimToSize(); return gaList; }\n\n    ### Response:", "ground_truth": "Map the given array of attributes to Spring Security GrantedAuthorities.", "predict": "/**\r\n     * This method takes a collection of attributes and returns a list of granted authorities based on the mapping of attributes to granted authorities.\r\n     * \r\n     * @param attributes\r\n     *            a collection of attributes\r\n     * @return a list of granted authorities\r\n     */\r\n    public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) {\r\n        ArrayList<GrantedAuthority> gaList = new ArrayList<>();\r\n        for (String attribute : attributes) {\r\n            Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap.get(attribute);\r\n            if (c != null) {\r\n                gaList.addAll(c);\r\n            }\r\n        }\r\n        gaList.trimToSize();\r\n        return gaList;\r\n    }"}, {"ID": 140, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) { Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>( orgMap.size()); for (Map.Entry<?, ?> entry : orgMap.entrySet()) { Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\"); result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue())); } return result; }\n\n    ### Response:", "ground_truth": "Preprocess the given map to convert all the values to GrantedAuthority collections\n\n@param orgMap The map to process\n@return the processed Map", "predict": "/**\r\n     * This method pre-processes the given map of attributes to granted authorities.\r\n     * \r\n     * @param orgMap\r\n     *            the map of attributes to granted authorities to be pre-processed\r\n     * @return the pre-processed map of attributes to granted authorities\r\n     */\r\n    private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) {\r\n        Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>(orgMap.size());\r\n        for (Map.Entry<?, ?> entry : orgMap.entrySet()) {\r\n            Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\");\r\n            result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue()));\r\n        }\r\n        return result;\r\n    }"}, {"ID": 141, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) { Collection<GrantedAuthority> result = new ArrayList<>(); addGrantedAuthorityCollection(result, value); return result; }\n\n    ### Response:", "ground_truth": "Convert the given value to a collection of Granted Authorities\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": "/**\r\n     * This method is used to get the granted authority collection from the given value.\r\n     * \r\n     * @param value\r\n     *            The value from which the granted authority collection is to be obtained.\r\n     * @return The granted authority collection obtained from the given value.\r\n     */\r\n    private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) {\r\n        Collection<GrantedAuthority> result = new ArrayList<>();\r\n        addGrantedAuthorityCollection(result, value);\r\n        return result;\r\n    }"}, {"ID": 142, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) { if (value == null) { return; } if (value instanceof Collection<?>) { addGrantedAuthorityCollection(result, (Collection<?>) value); } else if (value instanceof Object[]) { addGrantedAuthorityCollection(result, (Object[]) value); } else if (value instanceof String) { addGrantedAuthorityCollection(result, (String) value); } else if (value instanceof GrantedAuthority) { result.add((GrantedAuthority) value); } else { throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Convert the given value to a collection of Granted Authorities, adding the result\nto the given result collection.\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": "/**\r\n     * Adds the given value to the result collection if it is a granted authority.\r\n     *\r\n     * @param result the collection to add the granted authority to\r\n     * @param value the value to check and add to the collection\r\n     */\r\n    private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) {\r\n        if (value == null) {\r\n            return;\r\n        }\r\n        if (value instanceof Collection<?>) {\r\n            addGrantedAuthorityCollection(result, (Collection<?>) value);\r\n        } else if (value instanceof Object[]) {\r\n            addGrantedAuthorityCollection(result, (Object[]) value);\r\n        } else if (value instanceof String) {\r\n            addGrantedAuthorityCollection(result, (String) value);\r\n        } else if (value instanceof GrantedAuthority) {\r\n            result.add((GrantedAuthority) value);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName());\r\n        }\r\n    }"}, {"ID": 143, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest .getUserPrincipal().getName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated J2EE principal: \" + principal); } return principal; }\n\n    ### Response:", "ground_truth": "Return the J2EE user name.", "predict": "/**\r\n     * Retrieves the pre-authenticated J2EE principal from the given HTTP request.\r\n     * \r\n     * @param httpRequest the HTTP request\r\n     * @return the pre-authenticated J2EE principal, or null if not available\r\n     */\r\n    protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {\r\n        Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest.getUserPrincipal().getName();\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"PreAuthenticated J2EE principal: \" + principal);\r\n        }\r\n        return principal;\r\n    }"}, {"ID": 144, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); }\n\n    ### Response:", "ground_truth": "Gets a shared Object. Note that object heirarchies are not considered.\n\n@param sharedType the type of the shared Object\n@return the shared Object or null if it is not found", "predict": "/**\r\n     * Returns a shared object of the specified type.\r\n     * \r\n     * @param sharedType the type of the shared object to retrieve\r\n     * @return the shared object of the specified type, or null if no such object exists\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <C> C getSharedObject(Class<C> sharedType) {\r\n        return (C) this.sharedObjects.get(sharedType);\r\n    }"}, {"ID": 145, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException { int serverPort = portResolver.getServerPort(request); Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort)); if (httpsPort != null) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder(); urlBuilder.setScheme(\"https\"); urlBuilder.setServerName(request.getServerName()); urlBuilder.setPort(httpsPort.intValue()); urlBuilder.setContextPath(request.getContextPath()); urlBuilder.setServletPath(request.getServletPath()); urlBuilder.setPathInfo(request.getPathInfo()); urlBuilder.setQuery(request.getQueryString()); return urlBuilder.getUrl(); } // Fall through to server-side forward with warning message logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort); return null; }\n\n    ### Response:", "ground_truth": "Builds a URL to redirect the supplied request to HTTPS. Used to redirect the\ncurrent request to HTTPS, before doing a forward to the login page.", "predict": "/**\r\n     * Builds the HTTPS redirect URL for the given request.\r\n     * \r\n     * @param request\r\n     *            the HTTP request\r\n     * @return the HTTPS redirect URL, or null if no HTTPS port mapping was found\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     * @throws ServletException\r\n     *             if a servlet error occurs\r\n     */\r\n    protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException {\r\n        int serverPort = portResolver.getServerPort(request);\r\n        Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort));\r\n        if (httpsPort != null) {\r\n            RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder();\r\n            urlBuilder.setScheme(\"https\");\r\n            urlBuilder.setServerName(request.getServerName());\r\n            urlBuilder.setPort(httpsPort.intValue());\r\n            urlBuilder.setContextPath(request.getContextPath());\r\n            urlBuilder.setServletPath(request.getServletPath());\r\n            urlBuilder.setPathInfo(request.getPath"}, {"ID": 146, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); }\n\n    ### Response:", "ground_truth": "Method that is suitable for user with traditional AspectJ-code aspects.\n\n@param jp The AspectJ joint point being invoked which requires a security decision\n@param advisorProceed the advice-defined anonymous class that implements\n{@code AspectJCallback} containing a simple {@code return proceed();} statement\n\n@return The returned value from the method invocation", "predict": "/**\r\n     * This method is used to invoke the interceptors and the target method.\r\n     * \r\n     * @param jp - JoinPoint object representing the method invocation.\r\n     * @param advisorProceed - AspectJCallback object representing the proceed method of the aspect.\r\n     * @return - Object representing the result of the method invocation.\r\n     */\r\n    public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) {\r\n        InterceptorStatusToken token = super.beforeInvocation(new MethodInvocationAdapter(jp));\r\n        Object result;\r\n        try {\r\n            result = advisorProceed.proceedWithObject();\r\n        } finally {\r\n            super.finallyInvocation(token);\r\n        }\r\n        return super.afterInvocation(token, result);\r\n    }"}, {"ID": 147, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String hasRole(String role) { Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\"); return \"ROLE_\" + role; }\n\n    ### Response:", "ground_truth": "Creates a String for specifying a user requires a role.\n\n@param role the role that should be required which is prepended with ROLE_\nautomatically (i.e. USER, ADMIN, etc). It should not start with ROLE_\n@return the {@link ConfigAttribute} expressed as a String", "predict": "/**\r\n     * This method is used to check if a given role is present in the current user's authorities.\r\n     * \r\n     * @param role The role to check for.\r\n     * @return The role with \"ROLE_\" prepended if it is not already present.\r\n     * @throws IllegalArgumentException if the role starts with \"ROLE_\"\r\n     */\r\n    private static String hasRole(String role) {\r\n        Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\");\r\n        return \"ROLE_\" + role;\r\n    }"}, {"ID": 148, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String[] hasAnyRole(String... roles) { for (int i = 0; i < roles.length; i++) { roles[i] = \"ROLE_\" + roles[i]; } return roles; }\n\n    ### Response:", "ground_truth": "Creates a String for specifying that a user requires one of many roles.\n\n@param roles the roles that the user should have at least one of (i.e. ADMIN, USER,\netc). Each role should not start with ROLE_ since it is automatically prepended\nalready.\n@return the {@link ConfigAttribute} expressed as a String", "predict": "/**\r\n     * This method takes an array of roles as input and returns an array of roles with the prefix \"ROLE_\" added to each role.\r\n     * \r\n     * @param roles an array of roles\r\n     * @return an array of roles with the prefix \"ROLE_\" added to each role\r\n     */\r\n    private static String[] hasAnyRole(String... roles) {\r\n        for (int i = 0; i < roles.length; i++) {\r\n            roles[i] = \"ROLE_\" + roles[i];\r\n        }\r\n        return roles;\r\n    }"}, {"ID": 149, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { if (cookieTokens.length != 2) { throw new InvalidCookieException(\"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\"); } final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException( \"No persistent token found for series id: \" + presentedSeries); } // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( \"PersistentTokenBasedRememberMeServices.cookieStolen\", \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\")); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System .currentTimeMillis()) { throw new RememberMeAuthenticationException(\"Remember-me login has expired\"); } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) { logger.debug(\"Refreshing persistent login token for user '\" + token.getUsername() + \"', series '\" + token.getSeries() + \"'\"); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try { tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); } catch (Exception e) { logger.error(\"Failed to update token: \", e); throw new RememberMeAuthenticationException( \"Autologin failed due to data access problem\"); } return getUserDetailsService().loadUserByUsername(token.getUsername()); }\n\n    ### Response:", "ground_truth": "Locates the presented cookie data in the token repository, using the series id. If\nthe data compares successfully with that in the persistent store, a new token is\ngenerated and stored with the same series. The corresponding cookie value is set on\nthe response.\n\n@param cookieTokens the series and token values\n\n@throws RememberMeAuthenticationException if there is no stored token corresponding\nto the submitted cookie, or if the token in the persistent store has expired.\n@throws InvalidCookieException if the cookie doesn't have two tokens as expected.\n@throws CookieTheftException if a presented series value is found, but the stored\ntoken is different from the one presented.", "predict": "/**\r\n     * Processes an auto-login cookie and returns the corresponding user details.\r\n     *\r\n     * @param cookieTokens the cookie tokens\r\n     * @param request the HTTP request\r\n     * @param response the HTTP response\r\n     * @return the user details\r\n     * @throws RememberMeAuthenticationException if the cookie is invalid or expired\r\n     * @throws InvalidCookieException if the cookie token is invalid\r\n     * @throws CookieTheftException if the cookie has been stolen\r\n     */\r\n    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 150, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); logger.debug(\"Creating new persistent login for user \" + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try { tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } catch (Exception e) { logger.error(\"Failed to save persistent token \", e); } }\n\n    ### Response:", "ground_truth": "Creates a new persistent login token with a new series number, stores the data in\nthe persistent token repository and adds the corresponding cookie to the response.", "predict": "/**\r\n     * This method is called when a user successfully logs in. It creates a new persistent login for the user and saves it in the database.\r\n     * \r\n     * @param request The HTTP request.\r\n     * @param response The HTTP response.\r\n     * @param successfulAuthentication The authentication object representing the user's successful login.\r\n     */\r\n    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) {\r\n        String username = successfulAuthentication.getName();\r\n        logger.debug(\"Creating new persistent login for user \" + username);\r\n        PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(username, generateSeriesData(), generateTokenData(), new Date());\r\n        try {\r\n            tokenRepository.createNewToken(persistentToken);\r\n            addCookie(persistentToken, request, response);\r\n        } catch (Exception e) {\r\n            logger.error(\"Failed to save persistent token \", e);\r\n        }\r\n    }"}, {"ID": 151, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest; String username = request.getParameter(this.usernameParameter); if (username == null) { username = \"\"; } if (this.logger.isDebugEnabled()) { this.logger.debug(\"Attempt to switch to user [\" + username + \"]\"); } UserDetails targetUser = this.userDetailsService.loadUserByUsername(username); this.userDetailsChecker.check(targetUser); // OK, create the switch user token targetUserRequest = createSwitchUserToken(request, targetUser); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\"); } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser)); } return targetUserRequest; }\n\n    ### Response:", "ground_truth": "Attempt to switch to another user. If the user does not exist or is not active,\nreturn null.\n\n@return The new Authentication request if successfully switched to\nanother user, null otherwise.\n\n@throws UsernameNotFoundException If the target user is not found.\n@throws LockedException if the account is locked.\n@throws DisabledException If the target user is disabled.\n@throws AccountExpiredException If the target user account is expired.\n@throws CredentialsExpiredException If the target user credentials are expired.", "predict": "/**\r\n     * Attempts to switch the current user to the specified user.\r\n     *\r\n     * @param request the current HTTP request\r\n     * @return the authentication token for the new user, or null if the switch is not allowed\r\n     * @throws AuthenticationException if the switch is not allowed or the new user cannot be loaded\r\n     */\r\n    protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 152, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder.getContext().getAuthentication(); if (null == current) { throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noCurrentUser\", \"No current user associated with this request\")); } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication(current); if (original == null) { this.logger.debug(\"Could not find original user Authentication object!\"); throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noOriginalAuthentication\", \"Could not find original Authentication object\")); } // get the source user details UserDetails originalUser = null; Object obj = original.getPrincipal(); if ((obj != null) && obj instanceof UserDetails) { originalUser = (UserDetails) obj; } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent( new AuthenticationSwitchUserEvent(current, originalUser)); } return original; }\n\n    ### Response:", "ground_truth": "Authentication object or null\notherwise.\n\n@throws AuthenticationCredentialsNotFoundException If no\nAuthentication associated with this request.", "predict": "/**\r\n     * Attempt to exit the current user by returning the original user Authentication object.\r\n     * <p>\r\n     * This method is intended to be called by a {@link SwitchUserFilter} when a user has requested to exit the current user.\r\n     * The method first checks to see if the current user has a {@link SwitchUserGrantedAuthority} and then retrieves the original\r\n     * source user Authentication object. If the original source user Authentication object cannot be found, an exception is thrown.\r\n     * Finally, the method publishes an {@link AuthenticationSwitchUserEvent} if an {@link ApplicationEventPublisher} is available.\r\n     *\r\n     * @param request the current HTTP request\r\n     * @return the original user Authentication object\r\n     * @throws AuthenticationCredentialsNotFoundException if the original user Authentication object cannot be found\r\n     */\r\n    protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException;"}, {"ID": 153, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setExitUserUrl(String exitUserUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\"); this.exitUserMatcher = createMatcher(exitUserUrl); }\n\n    ### Response:", "ground_truth": "Set the URL to respond to exit user processing.\n\n@param exitUserUrl The exit user URL.", "predict": "/**\r\n     * Sets the exit user URL for the application.\r\n     * \r\n     * @param exitUserUrl the URL to redirect the user to when they exit the application.\r\n     * @throws IllegalArgumentException if the exitUserUrl is empty or not a valid redirect URL.\r\n     */\r\n    public void setExitUserUrl(String exitUserUrl) {\r\n        Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\");\r\n        this.exitUserMatcher = createMatcher(exitUserUrl);\r\n    }"}, {"ID": 154, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); }\n\n    ### Response:", "ground_truth": "The public index page, used for unauthenticated users.", "predict": "/**\r\n     * This method is used to display the public index page of the website.\r\n     * \r\n     * @return A model and view object containing the random contact object.\r\n     */\r\n    @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET)\r\n    public ModelAndView displayPublicIndex() {\r\n        Contact rnd = contactManager.getRandomContact();\r\n        return new ModelAndView(\"hello\", \"contact\", rnd);\r\n    }"}, {"ID": 155, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); }\n\n    ### Response:", "ground_truth": "Creates the Spring Security Filter Chain\n@return the {@link Filter} that represents the security filter chain\n@throws Exception", "predict": "/**\r\n     * This method is responsible for creating the Spring Security Filter Chain.\r\n     * \r\n     * @return the Spring Security Filter Chain\r\n     * @throws Exception\r\n     */\r\n    @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)\r\n    public Filter springSecurityFilterChain() throws Exception {\r\n        boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty();\r\n        if (!hasConfigurers) {\r\n            WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor.postProcess(new WebSecurityConfigurerAdapter() {\r\n            });\r\n            webSecurity.apply(adapter);\r\n        }\r\n        return webSecurity.build();\r\n    }"}, {"ID": 156, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); }\n\n    ### Response:", "ground_truth": "Decode and validate the JWT from its compact claims representation format\n\n@param token the JWT value\n@return a validated {@link Jwt}\n@throws JwtException", "predict": "/**\n     * Decodes the given JWT token and returns a Jwt object.\n     *\n     * @param token the JWT token to be decoded\n     * @return a Jwt object representing the decoded JWT token\n     * @throws JwtException if the JWT token is invalid or cannot be decoded\n     */\n    @Override\n    public Jwt decode(String token) throws JwtException {\n        JWT jwt = parse(token);\n        if (jwt instanceof SignedJWT) {\n            Jwt createdJwt = createJwt(token, jwt);\n            return validateJwt(createdJwt);\n        }\n        throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm());\n    }"}, {"ID": 157, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean authorizeUsingAccessExpression() throws IOException { if (SecurityContextHolder.getContext().getAuthentication() == null) { return false; } SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler(); Expression accessExpression; try { accessExpression = handler.getExpressionParser().parseExpression(getAccess()); } catch (ParseException e) { IOException ioException = new IOException(); ioException.initCause(e); throw ioException; } return ExpressionUtils.evaluateAsBoolean(accessExpression, createExpressionEvaluationContext(handler)); }\n\n    ### Response:", "ground_truth": "Make an authorization decision based on a Spring EL expression. See the\n\"Expression-Based Access Control\" chapter in Spring Security for details on what\nexpressions can be used.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "/**\r\n     * This method is used to check if the user is authorized to access the resource based on the access expression provided.\r\n     *\r\n     * @return boolean value indicating whether the user is authorized to access the resource or not.\r\n     * @throws IOException if there is an error while parsing the access expression.\r\n     */\r\n    public boolean authorizeUsingAccessExpression() throws IOException {\r\n        // code goes here\r\n    }"}, {"ID": 158, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean authorizeUsingUrlCheck() throws IOException { String contextPath = ((HttpServletRequest) getRequest()).getContextPath(); Authentication currentUser = SecurityContextHolder.getContext() .getAuthentication(); return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser); }\n\n    ### Response:", "ground_truth": "Make an authorization decision based on the URL and HTTP method attributes. True is\nreturned if the user is allowed to access the given URL as defined.\n\n@return the result of the authorization decision\n@throws IOException", "predict": "/**\r\n     * This method checks if the user is authorized to access the URL using the URL check method.\r\n     *\r\n     * @return true if the user is authorized to access the URL, false otherwise.\r\n     * @throws IOException if an error occurs while checking the URL.\r\n     */\r\n    public boolean authorizeUsingUrlCheck() throws IOException {\r\n        // Code goes here\r\n    }"}, {"ID": 159, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Collection<GrantedAuthority> convert(Jwt jwt) { return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); }\n\n    ### Response:", "ground_truth": "Extracts the authorities\n@param jwt The {@link Jwt} token\n@return The {@link GrantedAuthority authorities} read from the token scopes", "predict": "/**\n     * Converts a JWT into a collection of granted authorities.\n     *\n     * @param jwt the JWT to convert\n     * @return the collection of granted authorities\n     */\n    @Override\n    public Collection<GrantedAuthority> convert(Jwt jwt) {\n        return getScopes(jwt)\n                .stream()\n                .map(authority -> SCOPE_AUTHORITY_PREFIX + authority)\n                .map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n    }"}, {"ID": 160, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); }\n\n    ### Response:", "ground_truth": "Generates a new token\n@param request the {@link HttpServletRequest} to use. The\n{@link HttpServletRequest} must have the {@link HttpServletResponse} as an\nattribute with the name of HttpServletResponse.class.getName()", "predict": "/**\n     * Generates a CSRF token for the given request.\n     *\n     * @param request the current HTTP request\n     * @return the generated CSRF token\n     */\n    @Override\n    public CsrfToken generateToken(HttpServletRequest request) {\n        return wrap(request, this.delegate.generateToken(request));\n    }"}, {"ID": 161, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); }\n\n    ### Response:", "ground_truth": "Displays the permission admin page for a particular contact.", "predict": "/**\r\n     * This method is used to display the admin permission page for a given contact.\r\n     * \r\n     * @param contactId The id of the contact whose admin permission needs to be displayed.\r\n     * @return A model and view object that contains the contact and its corresponding ACL.\r\n     */\r\n    @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET)\r\n    public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) {\r\n        Contact contact = contactManager.getById(Long.valueOf(contactId));\r\n        Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact));\r\n        Map<String, Object> model = new HashMap<>();\r\n        model.put(\"contact\", contact);\r\n        model.put(\"acl\", acl);\r\n        return new ModelAndView(\"adminPermission\", \"model\", model);\r\n    }"}, {"ID": 162, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); }\n\n    ### Response:", "ground_truth": "Displays the \"add permission\" page for a contact.", "predict": "/**\r\n     * This method is used to display the add permission page for a contact.\r\n     * \r\n     * @param contactId\r\n     *            The id of the contact for which the permission needs to be added.\r\n     * @return A model and view object which is used to render the add permission page.\r\n     */\r\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET)\r\n    public ModelAndView displayAddPermissionPageForContact(\r\n            @RequestParam(\"contactId\") long contactId) {\r\n        Contact contact = contactManager.getById(contactId);\r\n        AddPermission addPermission = new AddPermission();\r\n        addPermission.setContact(contact);\r\n        Map<String, Object> model = new HashMap<>();\r\n        model.put(\"addPermission\", addPermission);\r\n        model.put(\"recipients\", listRecipients());\r\n        model.put(\"permissions\", listPermissions());\r\n        return new ModelAndView(\"addPermission\", model);\r\n    }"}, {"ID": 163, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } return \"redirect:/secure/index.htm\"; }\n\n    ### Response:", "ground_truth": "Handles submission of the \"add permission\" form.", "predict": "/**\r\n     * This method is used to add a permission to a contact.\r\n     * \r\n     * @param addPermission\r\n     *            The AddPermission object containing the contact, recipient, and permission to be added.\r\n     * @param result\r\n     *            The BindingResult object containing any validation errors.\r\n     * @param model\r\n     *            The ModelMap object containing any additional data to be passed to the view.\r\n     * @return The name of the view to be rendered.\r\n     */\r\n    @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST)\r\n    public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) {\r\n        // TODO: Add method-level comments.\r\n    }"}, {"ID": 164, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); }\n\n    ### Response:", "ground_truth": "Deletes a permission", "predict": "/**\r\n     * This method is responsible for deleting a permission from a contact.\r\n     * \r\n     * @param contactId The id of the contact from which the permission needs to be deleted.\r\n     * @param sid The sid of the principal for which the permission needs to be deleted.\r\n     * @param mask The mask of the permission that needs to be deleted.\r\n     * @return A model and view object that contains the updated contact, sid and permission objects.\r\n     */\r\n    @RequestMapping(value = \"/secure/deletePermission.htm\")\r\n    public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) {\r\n        Contact contact = contactManager.getById(contactId);\r\n        Sid sidObject = new PrincipalSid(sid);\r\n        Permission permission = permissionFactory.buildFromMask(mask);\r\n        contactManager.deletePermission(contact, sidObject, permission);\r\n        Map<String, Object> model = new HashMap<>();\r\n        model.put(\"contact\", contact);\r\n        model.put"}, {"ID": 165, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) { if (role == null) { return role; } if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) { return role; } if (role.startsWith(defaultRolePrefix)) { return role; } return defaultRolePrefix + role; }\n\n    ### Response:", "ground_truth": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if role\ndoes not already start with defaultRolePrefix.\n\n@param defaultRolePrefix\n@param role\n@return", "predict": "/**\r\n     * This method takes two parameters, defaultRolePrefix and role. It returns the role with the default prefix if the role is null or empty, or if the role already starts with the default prefix. Otherwise, it returns the role with the default prefix added to the beginning.\r\n     * \r\n     * @param defaultRolePrefix the default prefix to add to the role if it doesn't already have it\r\n     * @param role the role to check and possibly modify\r\n     * @return the modified role with the default prefix added if necessary\r\n     */\r\n    private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) {\r\n        if (role == null) {\r\n            return role;\r\n        }\r\n        if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) {\r\n            return role;\r\n        }\r\n        if (role.startsWith(defaultRolePrefix)) {\r\n            return role;\r\n        }\r\n        return defaultRolePrefix + role;\r\n    }"}, {"ID": 166, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UserDetailsResourceFactoryBean fromString(String users) { InMemoryResource resource = new InMemoryResource(users); return fromResource(resource); }\n\n    ### Response:", "ground_truth": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean", "predict": "/**\r\n     * Creates a new UserDetailsResourceFactoryBean from a string of users.\r\n     *\r\n     * @param users the string of users\r\n     * @return a new UserDetailsResourceFactoryBean\r\n     */\r\n    public static UserDetailsResourceFactoryBean fromString(String users) {\r\n        InMemoryResource resource = new InMemoryResource(users);\r\n        return fromResource(resource);\r\n    }"}, {"ID": 167, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; }\n\n    ### Response:", "ground_truth": "Returns the values for a specific attribute\n\n@param name the attribute name\n@return a String array, never null but may be zero length", "predict": "/**\r\n     * This method retrieves the attribute values for a given attribute name.\r\n     * \r\n     * @param name The name of the attribute for which the values are to be retrieved.\r\n     * @return A list of attribute values for the given attribute name. If no attribute values are found, an empty list is returned.\r\n     */\r\n    public List<String> getAttributeValues(String name) {\r\n        List<String> result = null;\r\n        if (attributes != null) {\r\n            result = attributes.get(name);\r\n        }\r\n        if (result == null) {\r\n            result = Collections.emptyList();\r\n        }\r\n        return result;\r\n    }"}, {"ID": 168, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getFirstAttributeValue(String name) { List<String> result = getAttributeValues(name); if (result.isEmpty()) { return null; } else { return result.get(0); } }\n\n    ### Response:", "ground_truth": "Returns the first attribute value for a specified attribute\n\n@param name\n@return the first attribute value for a specified attribute, may be null", "predict": "/**\r\n     * This method retrieves the first attribute value for a given attribute name.\r\n     * \r\n     * @param name The name of the attribute for which the value is to be retrieved.\r\n     * @return The first attribute value for the given attribute name.\r\n     */\r\n    public String getFirstAttributeValue(String name) {\r\n        List<String> result = getAttributeValues(name);\r\n        if (result.isEmpty()) {\r\n            return null;\r\n        } else {\r\n            return result.get(0);\r\n        }\r\n    }"}, {"ID": 169, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] encode(CharSequence string) { try { ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string)); byte[] bytesCopy = new byte[bytes.limit()]; System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit()); return bytesCopy; } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } }\n\n    ### Response:", "ground_truth": "Get the bytes of the String in UTF-8 encoded form.", "predict": "/**\r\n     * Encodes the given string into a byte array using the default character set.\r\n     *\r\n     * @param string the string to encode\r\n     * @return the encoded byte array\r\n     * @throws IllegalArgumentException if the encoding fails\r\n     */\r\n    public static byte[] encode(CharSequence string) {\r\n        try {\r\n            ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string));\r\n            byte[] bytesCopy = new byte[bytes.limit()];\r\n            System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit());\r\n            return bytesCopy;\r\n        } catch (CharacterCodingException e) {\r\n            throw new IllegalArgumentException(\"Encoding failed\", e);\r\n        }\r\n    }"}, {"ID": 170, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(byte[] bytes) { try { return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString(); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Decoding failed\", e); } }\n\n    ### Response:", "ground_truth": "Decode the bytes in UTF-8 form into a String.", "predict": "/**\r\n     * Decodes the given byte array into a string using the default character set.\r\n     *\r\n     * @param bytes the byte array to decode\r\n     * @return the decoded string\r\n     * @throws IllegalArgumentException if decoding fails\r\n     */\r\n    public static String decode(byte[] bytes) {\r\n        try {\r\n            return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString();\r\n        } catch (CharacterCodingException e) {\r\n            throw new IllegalArgumentException(\"Decoding failed\", e);\r\n        }\r\n    }"}, {"ID": 171, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T extends AccessibleObject> String[] lookupParameterNames( ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; }\n\n    ### Response:", "ground_truth": "Gets the parameter names or null if not found.\n\n@param parameterNameFactory the {@link ParameterNameFactory} to use\n@param t the {@link AccessibleObject} to find the parameter names on (i.e. Method\nor Constructor)\n@return the parameter names or null", "predict": "/**\r\n     * Looks up the parameter names for the given accessible object using the given parameter name factory.\r\n     * \r\n     * @param <T> the type of the accessible object\r\n     * @param parameterNameFactory the parameter name factory to use\r\n     * @param t the accessible object to look up parameter names for\r\n     * @return the parameter names, or null if none were found\r\n     */\r\n    private <T extends AccessibleObject> String[] lookupParameterNames(ParameterNameFactory<T> parameterNameFactory, T t) {\r\n        Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t);\r\n        int parameterCount = parameterAnnotations.length;\r\n        String[] paramNames = new String[parameterCount];\r\n        boolean found = false;\r\n        for (int i = 0; i < parameterCount; i++) {\r\n            Annotation[] annotations = parameterAnnotations[i];\r\n            String parameterName = findParameterName(annotations);\r\n            if (parameterName != null) {\r\n                found = true;\r\n                paramNames[i] = parameterName;\r\n            }\r\n        }\r\n       "}, {"ID": 172, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; }\n\n    ### Response:", "ground_truth": "Handles the submission of the contact form, creating a new instance if the username\nand email are valid.", "predict": "/**\r\n     * This method handles the HTTP POST request for adding a new contact.\r\n     * \r\n     * @param form\r\n     *            the form object that contains the contact details\r\n     * @param result\r\n     *            the binding result object that contains the validation errors\r\n     * @return the name of the view to redirect to after processing the request\r\n     */\r\n    @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST)\r\n    public String addContact(WebContact form, BindingResult result) {\r\n        validator.validate(form, result);\r\n        if (result.hasErrors()) {\r\n            return \"add\";\r\n        }\r\n        Contact contact = new Contact(form.getName(), form.getEmail());\r\n        contactManager.create(contact);\r\n        return \"redirect:/secure/index.htm\";\r\n    }"}, {"ID": 173, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) { if (targetClass == null) { return null; } return findAttributesSpecifiedAgainst(method, targetClass); }\n\n    ### Response:", "ground_truth": "Will walk the method inheritance tree to find the most specific declaration\napplicable.", "predict": "/**\r\n     * This method is used to find the attributes specified against the given method and target class.\r\n     * \r\n     * @param method The method for which the attributes are to be found.\r\n     * @param targetClass The target class for which the attributes are to be found.\r\n     * @return The collection of attributes specified against the given method and target class.\r\n     */\r\n    protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) {\r\n        if (targetClass == null) {\r\n            return null;\r\n        }\r\n        return findAttributesSpecifiedAgainst(method, targetClass);\r\n    }"}, {"ID": 174, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) { Assert.notNull(method, \"RegisteredMethod required\"); Assert.notNull(attr, \"Configuration attribute required\"); if (logger.isInfoEnabled()) { logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\"); } this.methodMap.put(method, attr); }\n\n    ### Response:", "ground_truth": "Add configuration attributes for a secure method.\n\n@param method the method to be secured\n@param attr required authorities associated with the method", "predict": "/**\r\n     * Adds a secure method to the registry with the given configuration attributes.\r\n     *\r\n     * @param method the registered method to add\r\n     * @param attr the configuration attributes to associate with the method\r\n     * @throws IllegalArgumentException if the method or attributes are null\r\n     */\r\n    private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) {\r\n        Assert.notNull(method, \"RegisteredMethod required\");\r\n        Assert.notNull(attr, \"Configuration attribute required\");\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\");\r\n        }\r\n        this.methodMap.put(method, attr);\r\n    }"}, {"ID": 175, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; }\n\n    ### Response:", "ground_truth": "Obtains the configuration attributes explicitly defined against this bean.\n\n@return the attributes explicitly defined against this bean", "predict": "/**\r\n     * This method returns all the ConfigAttributes that are associated with the methods in the methodMap.\r\n     * \r\n     * @return a Collection of ConfigAttributes\r\n     */\r\n    @Override\r\n    public Collection<ConfigAttribute> getAllConfigAttributes() {\r\n        Set<ConfigAttribute> allAttributes = new HashSet<>();\r\n        for (List<ConfigAttribute> attributeList : methodMap.values()) {\r\n            allAttributes.addAll(attributeList);\r\n        }\r\n        return allAttributes;\r\n    }"}, {"ID": 176, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isMatch(String methodName, String mappedName) { return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length()))); }\n\n    ### Response:", "ground_truth": "Return if the given method name matches the mapped name. The default implementation\nchecks for \"xxx\" and \"xxx\" matches.\n\n@param methodName the method name of the class\n@param mappedName the name in the descriptor\n\n@return if the names match", "predict": "/**\r\n     * This method checks if the given method name matches the mapped name.\r\n     * \r\n     * @param methodName - The name of the method to be checked.\r\n     * @param mappedName - The mapped name to be checked against.\r\n     * @return true if the method name matches the mapped name, false otherwise.\r\n     */\r\n    private boolean isMatch(String methodName, String mappedName) {\r\n        return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length())));\r\n    }"}, {"ID": 177, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; }\n\n    ### Response:", "ground_truth": "Maps any request.\n\n@return the object that is chained after creating the {@link RequestMatcher}", "predict": "/**\r\n     * Configures the matcher to match any request.\r\n     * \r\n     * @return the matcher that matches any request\r\n     */\r\n    public C anyRequest() {\r\n        Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\");\r\n        C configurer = requestMatchers(ANY_REQUEST);\r\n        this.anyRequestConfigured = true;\r\n        return configurer;\r\n    }"}, {"ID": 178, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void handleBindException(String userDn, String username, Throwable cause) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to bind as \" + userDn + \": \" + cause); } }\n\n    ### Response:", "ground_truth": "Allows subclasses to inspect the exception thrown by an attempt to bind with a\nparticular DN. The default implementation just reports the failure to the debug\nlogger.", "predict": "/**\n     * Handles a bind exception that occurred during authentication.\n     *\n     * @param userDn the user DN that was attempted to bind with\n     * @param username the username that was attempted to bind with\n     * @param cause the exception that occurred during bind\n     */\n    protected void handleBindException(String userDn, String username, Throwable cause) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Failed to bind as \" + userDn + \": \" + cause);\n        }\n    }"}, {"ID": 179, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); }\n\n    ### Response:", "ground_truth": "This is a public method.", "predict": "/**\r\n     * This method retrieves a random contact from the database.\r\n     * \r\n     * @return A random contact from the database.\r\n     */\r\n    @Transactional(readOnly = true)\r\n    public Contact getRandomContact() {\r\n        logger.debug(\"Returning random contact\");\r\n        Random rnd = new Random();\r\n        List<Contact> contacts = contactDao.findAll();\r\n        int getNumber = rnd.nextInt(contacts.size());\r\n        return contacts.get(getNumber);\r\n    }"}, {"ID": 180, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final void clearAuthenticationAttributes(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); }\n\n    ### Response:", "ground_truth": "Removes temporary authentication-related data which may have been stored in the\nsession during the authentication process.", "predict": "/**\r\n     * Clears the authentication attributes from the session of the given request.\r\n     *\r\n     * @param request the request to clear the authentication attributes from\r\n     */\r\n    protected final void clearAuthenticationAttributes(HttpServletRequest request) {\r\n        HttpSession session = request.getSession(false);\r\n        if (session == null) {\r\n            return;\r\n        }\r\n        session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);\r\n    }"}, {"ID": 181, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException { Assert.notNull(clazz, \"Class required\"); Assert.hasText(fieldName, \"Field name required\"); try { return clazz.getDeclaredField(fieldName); } catch (NoSuchFieldException nsf) { // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName); } throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz); } }\n\n    ### Response:", "ground_truth": "Attempts to locate the specified field on the class.\n\n@param clazz the class definition containing the field\n@param fieldName the name of the field to locate\n\n@return the Field (never null)\n\n@throws IllegalStateException if field could not be found", "predict": "/**\r\n     * Gets the specified field from the specified class.\r\n     * \r\n     * @param clazz the class to search for the field\r\n     * @param fieldName the name of the field to find\r\n     * @return the Field object representing the specified field\r\n     * @throws IllegalStateException if the field cannot be found\r\n     */\r\n    public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException {\r\n        Assert.notNull(clazz, \"Class required\");\r\n        Assert.hasText(fieldName, \"Field name required\");\r\n        try {\r\n            return clazz.getDeclaredField(fieldName);\r\n        } catch (NoSuchFieldException nsf) {\r\n            // Try superclass if (clazz.getSuperclass() != null) {\r\n            return getField(clazz.getSuperclass(), fieldName);\r\n            // }\r\n            // throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz);\r\n        }\r\n    }"}, {"ID": 182, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) { return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId); }\n\n    ### Response:", "ground_truth": "Constructs a new Service Url. The default implementation relies on the CAS client\nto do the bulk of the work.\n@param request the HttpServletRequest\n@param response the HttpServlet Response\n@return the constructed service url. CANNOT be NULL.", "predict": "/**\r\n     * This method creates the service URL based on the request and response objects.\r\n     * \r\n     * @param request\r\n     *            The HTTP request object.\r\n     * @param response\r\n     *            The HTTP response object.\r\n     * @return The constructed service URL.\r\n     */\r\n    protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) {\r\n        return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId);\r\n    }"}, {"ID": 183, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createRedirectUrl(final String serviceUrl) { return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false); }\n\n    ### Response:", "ground_truth": "Constructs the Url for Redirection to the CAS server. Default implementation relies\non the CAS client to do the bulk of the work.\n\n@param serviceUrl the service url that should be included.\n@return the redirect url. CANNOT be NULL.", "predict": "/**\r\n     * This method creates the redirect URL for the given service URL.\r\n     *\r\n     * @param serviceUrl the service URL to which the user should be redirected after successful authentication\r\n     * @return the redirect URL\r\n     */\r\n    protected String createRedirectUrl(final String serviceUrl) {\r\n        return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false);\r\n    }"}, {"ID": 184, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String extractPrefix(String encPass) { if (!encPass.startsWith(\"{\")) { return null; } int secondBrace = encPass.lastIndexOf('}'); if (secondBrace < 0) { throw new IllegalArgumentException( \"Couldn't find closing brace for SHA prefix\"); } return encPass.substring(0, secondBrace + 1); }\n\n    ### Response:", "ground_truth": "Returns the hash prefix or null if there isn't one.", "predict": "/**\r\n     * Extracts the SHA prefix from the encrypted password.\r\n     * \r\n     * @param encPass the encrypted password\r\n     * @return the SHA prefix, or null if the prefix is not present\r\n     * @throws IllegalArgumentException if the prefix is present but the closing brace is not found\r\n     */\r\n    private String extractPrefix(String encPass) {\r\n        if (!encPass.startsWith(\"{\")) {\r\n            return null;\r\n        }\r\n        int secondBrace = encPass.lastIndexOf('}');\r\n        if (secondBrace < 0) {\r\n            throw new IllegalArgumentException(\"Couldn't find closing brace for SHA prefix\");\r\n        }\r\n        return encPass.substring(0, secondBrace + 1);\r\n    }"}, {"ID": 185, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); }\n\n    ### Response:", "ground_truth": "Always returns a 403 error code to the client.", "predict": "/**\n     * This method is called when the user is not authenticated but tries to access a protected resource.\n     * It sends an HTTP error response with a 403 Forbidden status code.\n     *\n     * @param request the HTTP request\n     * @param response the HTTP response\n     * @param arg2 the exception that caused the authentication failure\n     * @throws IOException if an I/O error occurs during the request processing\n     * @throws ServletException if a servlet error occurs during the request processing\n     */\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Pre-authenticated entry point called. Rejecting access\");\n        }\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n    }"}, {"ID": 186, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkFilterStack(List<Filter> filters) { checkForDuplicates(SecurityContextPersistenceFilter.class, filters); checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters); checkForDuplicates(SessionManagementFilter.class, filters); checkForDuplicates(BasicAuthenticationFilter.class, filters); checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters); checkForDuplicates(JaasApiIntegrationFilter.class, filters); checkForDuplicates(ExceptionTranslationFilter.class, filters); checkForDuplicates(FilterSecurityInterceptor.class, filters); }\n\n    ### Response:", "ground_truth": "Checks the filter list for possible errors and logs them", "predict": "/**\n     * This method checks for duplicate instances of the specified filter class in the given list of filters.\n     * \n     * @param filterClass the filter class to check for duplicates of\n     * @param filters the list of filters to check for duplicates in\n     */\n    private void checkForDuplicates(Class<? extends Filter> filterClass, List<Filter> filters) {\n        int count = 0;\n        for (Filter filter : filters) {\n            if (filterClass.isAssignableFrom(filter.getClass())) {\n                count++;\n            }\n        }\n        if (count > 1) {\n            throw new IllegalStateException(\"Duplicate instances of \" + filterClass.getName() + \" found in filter chain\");\n        }\n    }"}, {"ID": 187, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") final Class<? extends Throwable>[] getRegisteredTypes() { Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet(); return typeList.toArray(new Class[typeList.size()]); }\n\n    ### Response:", "ground_truth": "Returns an array containing the classes for which extractors are registered. The\norder of the classes is the order in which comparisons will occur for resolving a\nmatching extractor.\n\n@return the types for which extractors are registered", "predict": "/**\r\n     * Returns an array of all the registered types of exceptions that can be extracted from the log files.\r\n     * \r\n     * @return an array of all the registered types of exceptions that can be extracted from the log files.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    final Class<? extends Throwable>[] getRegisteredTypes() {\r\n        Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet();\r\n        return typeList.toArray(new Class[typeList.size()]);\r\n    }"}, {"ID": 188, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Throwable extractCause(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractCause(throwable); } } return null; }\n\n    ### Response:", "ground_truth": "Extracts the cause of the given throwable using an appropriate extractor.\n\n@param throwable the Throwable (not null\n@return the cause, may be null if none could be resolved", "predict": "/**\r\n     * Extracts the cause of the given throwable by iterating over the registered extractors and invoking the first one that matches the type of the given throwable.\r\n     * \r\n     * @param throwable the throwable to extract the cause from\r\n     * @return the cause of the given throwable, or null if no extractor matched the type of the given throwable\r\n     */\r\n    private Throwable extractCause(Throwable throwable) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 189, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder .rootBeanDefinition(AffirmativeBased.class); ManagedList voters = new ManagedList(4); if (expressionVoter != null) { voters.add(expressionVoter); } voters.add(new RootBeanDefinition(RoleVoter.class)); voters.add(new RootBeanDefinition(AuthenticatedVoter.class)); if (jsr250Enabled) { voters.add(new RootBeanDefinition(Jsr250Voter.class)); } accessMgrBuilder.addConstructorArgValue(voters); BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition(); String id = pc.getReaderContext().generateBeanName(accessManager); pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id)); return id; }\n\n    ### Response:", "ground_truth": "Register the default AccessDecisionManager. Adds the special JSR 250 voter jsr-250\nis enabled and an expression voter if expression-based access control is enabled.\n@return", "predict": "/**\r\n     * Registers the AccessManager bean with the given context.\r\n     * \r\n     * @param pc\r\n     *            the ParserContext to use for registering the bean\r\n     * @param jsr250Enabled\r\n     *            whether JSR-250 annotations should be considered for access control decisions\r\n     * @param expressionVoter\r\n     *            a BeanDefinition for a custom ExpressionVoter to use for access control decisions\r\n     * @return the generated id for the AccessManager bean\r\n     */\r\n    private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) {\r\n        BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder.rootBeanDefinition(AffirmativeBased.class);\r\n        ManagedList voters = new ManagedList(4);\r\n        if (expressionVoter != null) {\r\n            voters.add(expressionVoter);\r\n        }\r\n        voters.add(new RootBeanDefinition(RoleVoter.class));\r\n        voters.add(new RootBeanDefinition(AuthenticatedVoter.class));\r\n       "}, {"ID": 190, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) { Assert.notNull(userAuthorities, \"userAuthorities cannot be null\"); Set<String> set = new HashSet<>(userAuthorities.size()); for (GrantedAuthority authority : userAuthorities) { set.add(authority.getAuthority()); } return set; }\n\n    ### Response:", "ground_truth": "Converts an array of GrantedAuthority objects to a Set.\n@return a Set of the Strings obtained from each call to\nGrantedAuthority.getAuthority()", "predict": "/**\r\n     * Converts a collection of GrantedAuthority objects to a set of strings representing the authorities.\r\n     *\r\n     * @param userAuthorities the collection of GrantedAuthority objects to convert\r\n     * @return a set of strings representing the authorities\r\n     * @throws IllegalArgumentException if userAuthorities is null\r\n     */\r\n    public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) {\r\n        Assert.notNull(userAuthorities, \"userAuthorities cannot be null\");\r\n        Set<String> set = new HashSet<>(userAuthorities.size());\r\n        for (GrantedAuthority authority : userAuthorities) {\r\n            set.add(authority.getAuthority());\r\n        }\r\n        return set;\r\n    }"}, {"ID": 191, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean matches(byte[] expected, byte[] actual) { if (expected.length != actual.length) { return false; } int result = 0; for (int i = 0; i < expected.length; i++) { result |= expected[i] ^ actual[i]; } return result == 0; }\n\n    ### Response:", "ground_truth": "Constant time comparison to prevent against timing attacks.", "predict": "/**\r\n     * Compares two byte arrays for equality.\r\n     * \r\n     * @param expected the expected byte array\r\n     * @param actual the actual byte array\r\n     * @return true if the byte arrays are equal, false otherwise\r\n     */\r\n    private boolean matches(byte[] expected, byte[] actual) {\r\n        if (expected.length != actual.length) {\r\n            return false;\r\n        }\r\n        int result = 0;\r\n        for (int i = 0; i < expected.length; i++) {\r\n            result |= expected[i] ^ actual[i];\r\n        }\r\n        return result == 0;\r\n    }"}, {"ID": 192, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setDefaultFailureUrl(String defaultFailureUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\"); this.defaultFailureUrl = defaultFailureUrl; }\n\n    ### Response:", "ground_truth": "The URL which will be used as the failure destination.\n\n@param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".", "predict": "/**\n     * Sets the default failure URL to which the user will be redirected if authentication fails.\n     *\n     * @param defaultFailureUrl the default failure URL to set\n     * @throws IllegalArgumentException if the default failure URL is not a valid redirect URL\n     */\n    public void setDefaultFailureUrl(String defaultFailureUrl) {\n        Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\");\n        this.defaultFailureUrl = defaultFailureUrl;\n    }"}, {"ID": 193, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; }\n\n    ### Response:", "ground_truth": "Sets a Function used to resolve a Map of the hidden inputs where the key is the\nname of the input and the value is the value of the input. Typically this is used\nto resolve the CSRF token.\n@param resolveHiddenInputs the function to resolve the inputs", "predict": "/**\r\n     * Sets the function to resolve hidden inputs in the request.\r\n     * \r\n     * @param resolveHiddenInputs the function to resolve hidden inputs in the request\r\n     */\r\n    public void setResolveHiddenInputs(Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) {\r\n        Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\");\r\n        this.resolveHiddenInputs = resolveHiddenInputs;\r\n    }"}, {"ID": 194, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String buildRequestUrl(String servletPath, String requestURI, String contextPath, String pathInfo, String queryString) { StringBuilder url = new StringBuilder(); if (servletPath != null) { url.append(servletPath); if (pathInfo != null) { url.append(pathInfo); } } else { url.append(requestURI.substring(contextPath.length())); } if (queryString != null) { url.append(\"?\").append(queryString); } return url.toString(); }\n\n    ### Response:", "ground_truth": "Obtains the web application-specific fragment of the URL.", "predict": "/**\r\n     * Builds a URL string based on the given parameters.\r\n     * \r\n     * @param servletPath\r\n     *            The value of the \"javax.servlet.include.servlet_path\" request attribute, or null if not included in the request.\r\n     * @param requestURI\r\n     *            The value of the \"javax.servlet.include.request_uri\" request attribute, or null if not included in the request.\r\n     * @param contextPath\r\n     *            The value of the \"javax.servlet.include.context_path\" request attribute, or null if not included in the request.\r\n     * @param pathInfo\r\n     *            The value of the \"javax.servlet.include.path_info\" request attribute, or null if not included in the request.\r\n     * @param queryString\r\n     *            The value of the \"javax.servlet.include.query_string\" request attribute, or null if not included in the request.\r\n     * @return The URL string.\r\n     */\r\n    private static String buildRequestUrl(String servletPath,"}, {"ID": 195, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAbsoluteUrl(String url) { if (url == null) { return false; } final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE); return ABSOLUTE_URL.matcher(url).matches(); }\n\n    ### Response:", "ground_truth": "Decides if a URL is absolute based on whether it contains a valid scheme name, as\ndefined in RFC 1738.", "predict": "/**\r\n     * Checks if the given URL is absolute or not.\r\n     *\r\n     * @param url the URL to check\r\n     * @return true if the URL is absolute, false otherwise\r\n     */\r\n    public static boolean isAbsoluteUrl(String url) {\r\n        if (url == null) {\r\n            return false;\r\n        }\r\n        final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE);\r\n        return ABSOLUTE_URL.matcher(url).matches();\r\n    }"}, {"ID": 196, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<OpenIDAttribute> createAttributeList(String identifier) { for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) { if (entry.getKey().matcher(identifier).matches()) { return entry.getValue(); } } return Collections.emptyList(); }\n\n    ### Response:", "ground_truth": "Iterates through the patterns stored in the map and returns the list of attributes\ndefined for the first match. If no match is found, returns an empty list.", "predict": "/**\r\n     * This method takes an identifier as input and returns a list of OpenIDAttributes based on the identifier.\r\n     * \r\n     * @param identifier The identifier to search for in the idToAttributes map.\r\n     * @return A list of OpenIDAttributes that match the identifier.\r\n     */\r\n    public List<OpenIDAttribute> createAttributeList(String identifier) {\r\n        // TODO: Implement logic to return a list of OpenIDAttributes based on the identifier.\r\n    }"}, {"ID": 197, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; }\n\n    ### Response:", "ground_truth": "Converts the raw type from the database into the right Java type. For most applications the 'raw type' will be Long, for some applications\nit could be String.\n@param identifier The identifier from the database\n@param resultSet  Result set of the query\n@return The identifier in the appropriate target Java type. Typically Long or UUID.\n@throws SQLException", "predict": "/**\r\n     * This method takes in a Serializable identifier and a ResultSet object and returns a Serializable identifier.\r\n     * \r\n     * @param identifier - A Serializable identifier that can be a String or a Long.\r\n     * @param resultSet - A ResultSet object that contains metadata about the database table.\r\n     * @return A Serializable identifier that is either a String or a Long.\r\n     * @throws SQLException - If there is an error accessing the database.\r\n     */\r\n    public Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException {\r\n        if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) {\r\n            identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet));\r\n        } else {\r\n            // Assume it should be a Long type identifier\r\n            identifier = convertToLong(identifier);\r\n        }\r\n        return identifier;\r\n    }"}, {"ID": 198, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createEntries(final MutableAcl acl) { if (acl.getEntries().isEmpty()) { return; } jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() { public int getBatchSize() { return acl.getEntries().size(); } public void setValues(PreparedStatement stmt, int i) throws SQLException { AccessControlEntry entry_ = acl.getEntries().get(i); Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\"); AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_; stmt.setLong(1, ((Long) acl.getId()).longValue()); stmt.setInt(2, i); stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true) .longValue()); stmt.setInt(4, entry.getPermission().getMask()); stmt.setBoolean(5, entry.isGranting()); stmt.setBoolean(6, entry.isAuditSuccess()); stmt.setBoolean(7, entry.isAuditFailure()); } }); }\n\n    ### Response:", "ground_truth": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl\nobject.\n\n@param acl containing the ACEs to insert", "predict": "/**\r\n     * Creates the entries in the database for the given ACL.\r\n     *\r\n     * @param acl the ACL to create entries for\r\n     */\r\n    protected void createEntries(final MutableAcl acl) {\r\n        if (acl.getEntries().isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() {\r\n            public int getBatchSize() {\r\n                return acl.getEntries().size();\r\n            }\r\n\r\n            public void setValues(PreparedStatement stmt, int i) throws SQLException {\r\n                AccessControlEntry entry_ = acl.getEntries().get(i);\r\n                Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\");\r\n                AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_;\r\n\r\n                stmt.setLong(1, ((Long) acl.getId()).longValue());\r\n                stmt.setInt(2, i);\r\n                stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true).longValue());\r\n                stmt.setInt(4, entry.getPermission()."}, {"ID": 199, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createObjectIdentity(ObjectIdentity object, Sid owner) { Long sidId = createOrRetrieveSidPrimaryKey(owner, true); Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass()); jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId, Boolean.TRUE); }\n\n    ### Response:", "ground_truth": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity.\nThe Sid is also necessary, as acl_object_identity has defined the sid column as\nnon-null.\n\n@param object to represent an acl_object_identity for\n@param owner for the SID column (will be created if there is no acl_sid entry for\nthis particular Sid already)", "predict": "/**\r\n     * Creates an object identity in the database.\r\n     * \r\n     * @param object the object to create an identity for\r\n     * @param owner the owner of the object\r\n     */\r\n    protected void createObjectIdentity(ObjectIdentity object, Sid owner) { }"}, {"ID": 200, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void updateObjectIdentity(MutableAcl acl) { Long parentId = null; if (acl.getParentAcl() != null) { Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl() .getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\"); ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl() .getObjectIdentity(); parentId = retrieveObjectIdentityPrimaryKey(oii); } Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\"); Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true); int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId()); if (count != 1) { throw new NotFoundException(\"Unable to locate ACL to update\"); } }\n\n    ### Response:", "ground_truth": "Updates an existing acl_object_identity row, with new information presented in the\npassed MutableAcl object. Also will create an acl_sid entry if needed for the Sid\nthat owns the MutableAcl.\n\n@param acl to modify (a row must already exist in acl_object_identity)\n\n@throws NotFoundException if the ACL could not be found to update.", "predict": "/**\n     * Updates the object identity of the given ACL.\n     *\n     * @param acl the ACL to update\n     */\n    protected void updateObjectIdentity(MutableAcl acl) {\n        Long parentId = null;\n        if (acl.getParentAcl() != null) {\n            Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl().getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\");\n            ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl().getObjectIdentity();\n            parentId = retrieveObjectIdentityPrimaryKey(oii);\n        }\n        Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\");\n        Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true);\n        int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId());\n        if (count != 1) {\n            throw new NotFoundException(\"Unable to locate ACL to update\");\n        }\n    }"}, {"ID": 201, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (requestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); if (createSessionAllowed || request.getSession(false) != null) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request.getSession().setAttribute(this.sessionAttrName, savedRequest); logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest); } } else { logger.debug(\"Request not saved as configured RequestMatcher did not match\"); } }\n\n    ### Response:", "ground_truth": "Stores the current request, provided the configuration properties allow it.", "predict": "/**\r\n     * Saves the HTTP request to the session, if the request matches the configured RequestMatcher.\r\n     *\r\n     * @param request the current HTTP request\r\n     * @param response the current HTTP response\r\n     */\r\n    public void saveRequest(HttpServletRequest request, HttpServletResponse response) {\r\n        if (requestMatcher.matches(request)) {\r\n            DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver);\r\n            if (createSessionAllowed || request.getSession(false) != null) {\r\n                // Store the HTTP request itself. Used by\r\n                // AbstractAuthenticationProcessingFilter\r\n                // for redirection after successful authentication (SEC-29)\r\n                request.getSession().setAttribute(this.sessionAttrName, savedRequest);\r\n                logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest);\r\n            }\r\n        } else {\r\n            logger.debug(\"Request not saved as configured RequestMatcher did not match\");\r\n        }\r\n    }"}, {"ID": 202, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); }\n\n    ### Response:", "ground_truth": "Creates a matcher that matches on the specific method and any of the provided patterns.\n@param method the method to match on. If null, any method will be matched\n@param patterns the patterns to match on\n@return the matcher to use", "predict": "/**\r\n * Creates a matcher that matches the given HTTP method and any of the given patterns.\r\n *\r\n * @param method the HTTP method to match\r\n * @param patterns the patterns to match\r\n * @return a matcher that matches the given HTTP method and any of the given patterns\r\n */\r\npublic static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) {\r\n    List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length);\r\n    for (String pattern : patterns) {\r\n        matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method));\r\n    }\r\n    return new OrServerWebExchangeMatcher(matchers);\r\n}"}, {"ID": 203, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; }\n\n    ### Response:", "ground_truth": "Matches any exchange\n@return the matcher to use", "predict": "/**\r\n     * Returns a matcher that matches any exchange.\r\n     *\r\n     * @return a matcher that matches any exchange\r\n     */\r\n    public static ServerWebExchangeMatcher anyExchange() {\r\n        return new ServerWebExchangeMatcher() {\r\n            @Override\r\n            public Mono<MatchResult> matches(ServerWebExchange exchange) {\r\n                return ServerWebExchangeMatcher.MatchResult.match();\r\n            }\r\n        };\r\n    }"}, {"ID": 204, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); }\n\n    ### Response:", "ground_truth": "Creates a text encryptor that uses \"stronger\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#stronger(CharSequence, CharSequence)", "predict": "/**\r\n     * This method takes in a password and a salt and returns a TextEncryptor that uses a stronger encryption algorithm.\r\n     * \r\n     * @param password the password to use for encryption\r\n     * @param salt the salt to use for encryption\r\n     * @return a TextEncryptor that uses a stronger encryption algorithm\r\n     */\r\n    public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); }"}, {"ID": 205, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); }\n\n    ### Response:", "ground_truth": "Creates a text encryptor that uses \"standard\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#standard(CharSequence, CharSequence)", "predict": "/**\r\n     * Returns a TextEncryptor that uses the standard algorithm with the given password and salt.\r\n     *\r\n     * @param password the password to use for encryption/decryption\r\n     * @param salt the salt to use for encryption/decryption\r\n     * @return a TextEncryptor that uses the standard algorithm with the given password and salt\r\n     */\r\n    public static TextEncryptor text(CharSequence password, CharSequence salt) {\r\n        return new HexEncodingTextEncryptor(standard(password, salt));\r\n    }"}, {"ID": 206, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt)); }\n\n    ### Response:", "ground_truth": "Creates an encryptor for queryable text strings that uses standard password-based\nencryption. Uses a 16-byte all-zero initialization vector so encrypting the same\ndata results in the same encryption result. This is done to allow encrypted data to\nbe queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the\nsecret key", "predict": "/**\r\n     * Returns a TextEncryptor that can be used to encrypt and decrypt text using the AES encryption algorithm.\r\n     *\r\n     * @param password the password to use for encryption and decryption\r\n     * @param salt the salt to use for encryption and decryption\r\n     * @return a TextEncryptor that can be used to encrypt and decrypt text using the AES encryption algorithm\r\n     */\r\n    public static TextEncryptor queryableText(CharSequence password, CharSequence salt) {\r\n        return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt));\r\n    }"}, {"ID": 207, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeHeaders(HttpServletRequest request, HttpServletResponse response) { if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) { String allowFromValue = this.allowFromStrategy.getAllowFromValue(request); if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode()); } } else if (allowFromValue != null) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFromValue); } } } else { response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode()); } }\n\n    ### Response:", "ground_truth": "Writes the X-Frame-Options header value, overwritting any previous value.\n\n@param request the servlet request\n@param response the servlet response", "predict": "/**\r\n     * Writes the appropriate X-Frame-Options header to the response based on the configured mode and the allow-from value.\r\n     * \r\n     * @param request the current request\r\n     * @param response the current response\r\n     */\r\n    public void writeHeaders(HttpServletRequest request, HttpServletResponse response) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 208, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); }\n\n    ### Response:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc\n\n@since 5.2", "predict": "/**\r\n     * Determines the target URL for the given request, response, and authentication.\r\n     *\r\n     * @param request the current HTTP request\r\n     * @param response the current HTTP response\r\n     * @param authentication the current authentication\r\n     * @return the target URL for the request\r\n     */\r\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\r\n        return determineTargetUrl(request, response);\r\n    }"}, {"ID": 209, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available String targetUrl = null; if (targetUrlParameter != null) { targetUrl = request.getParameter(targetUrlParameter); if (StringUtils.hasText(targetUrl)) { logger.debug(\"Found targetUrlParameter in request: \" + targetUrl); return targetUrl; } } if (useReferer && !StringUtils.hasLength(targetUrl)) { targetUrl = request.getHeader(\"Referer\"); logger.debug(\"Using Referer header: \" + targetUrl); } if (!StringUtils.hasText(targetUrl)) { targetUrl = defaultTargetUrl; logger.debug(\"Using default Url: \" + targetUrl); } return targetUrl; }\n\n    ### Response:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc.", "predict": "/**\r\n     * Determines the target URL for the request.\r\n     * <p>\r\n     * The default implementation checks for a target URL parameter in the request,\r\n     * and if available, uses that. If the parameter is not available, it checks for a\r\n     * \"Referer\" header and uses that if available. If neither parameter nor header is\r\n     * available, it uses the default target URL.\r\n     * </p>\r\n     * \r\n     * @param request\r\n     *            the current HTTP request\r\n     * @param response\r\n     *            the current HTTP response\r\n     * @return the target URL for the request\r\n     */\r\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 210, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; }\n\n    ### Response:", "ground_truth": "If this property is set, the current request will be checked for this a parameter\nwith this name and the value used as the target URL if present.\n\n@param targetUrlParameter the name of the parameter containing the encoded target\nURL. Defaults to null.", "predict": "/**\r\n     * Sets the target URL parameter for the redirect.\r\n     * \r\n     * @param targetUrlParameter the target URL parameter to set\r\n     */\r\n    public void setTargetUrlParameter(String targetUrlParameter) {\r\n        if (targetUrlParameter != null) {\r\n            Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\");\r\n        }\r\n        this.targetUrlParameter = targetUrlParameter;\r\n    }"}, {"ID": 211, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Directory getDirectoryWithImmediateParentPopulated(final Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory); FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\"))); return directory; } }); }\n\n    ### Response:", "ground_truth": "Executes recursive SQL as needed to build a full Directory hierarchy of objects", "predict": "/**\r\n     * Retrieves a directory with its immediate parent directory populated.\r\n     * \r\n     * @param id the ID of the directory to retrieve\r\n     * @return the directory with its immediate parent directory populated\r\n     */\r\n    private Directory getDirectoryWithImmediateParentPopulated(final Long id) {\r\n        return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() {\r\n            public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException {\r\n                Long parentDirectoryId = new Long(rs.getLong(\"parent_directory_id\"));\r\n                Directory parentDirectory = Directory.ROOT_DIRECTORY;\r\n                if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) {\r\n                    // Need to go and lookup the parent, so do that first\r\n                    parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId);\r\n                }\r\n                Directory directory = new Directory(rs.getString(\"directory_name\"), parentDirectory);\r\n                FieldUtils.setProtectedFieldValue(\"id\","}, {"ID": 212, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DistinguishedName buildDn(String username) { DistinguishedName dn = new DistinguishedName(userDnBase); dn.add(usernameAttribute, username); return dn; }\n\n    ### Response:", "ground_truth": "Assembles the Distinguished Name that should be used the given username.", "predict": "/**\r\n     * This method builds a Distinguished Name object with the provided username.\r\n     * \r\n     * @param username The username to be added to the Distinguished Name object.\r\n     * @return A Distinguished Name object with the provided username.\r\n     */\r\n    public DistinguishedName buildDn(String username) {\r\n        DistinguishedName dn = new DistinguishedName(userDnBase);\r\n        dn.add(usernameAttribute, username);\r\n        return dn;\r\n    }"}, {"ID": 213, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Map<Class<? extends Object>, Object> createSharedObjects() { Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>(); sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects()); sharedObjects.put(UserDetailsService.class, userDetailsService()); sharedObjects.put(ApplicationContext.class, context); sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy); sharedObjects.put(AuthenticationTrustResolver.class, trustResolver); return sharedObjects; }\n\n    ### Response:", "ground_truth": "Creates the shared objects\n\n@return the shared Objects", "predict": "/**\r\n     * This method creates a map of shared objects that can be used by the Spring Security framework.\r\n     *\r\n     * @return A map of shared objects.\r\n     */\r\n    private Map<Class<? extends Object>, Object> createSharedObjects() {\r\n        Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>();\r\n        sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects());\r\n        sharedObjects.put(UserDetailsService.class, userDetailsService());\r\n        sharedObjects.put(ApplicationContext.class, context);\r\n        sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy);\r\n        sharedObjects.put(AuthenticationTrustResolver.class, trustResolver);\r\n        return sharedObjects;\r\n    }"}, {"ID": 214, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void configureJaasUsingLoop() throws IOException { String loginConfigUrl = convertLoginConfigToUrl(); boolean alreadySet = false; int n = 1; final String prefix = \"login.config.url.\"; String existing; while ((existing = Security.getProperty(prefix + n)) != null) { alreadySet = existing.equals(loginConfigUrl); if (alreadySet) { break; } n++; } if (!alreadySet) { String key = prefix + n; log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl); Security.setProperty(key, loginConfigUrl); } }\n\n    ### Response:", "ground_truth": "Loops through the login.config.url.1,login.config.url.2 properties looking for the\nlogin configuration. If it is not set, it will be set to the last available\nlogin.config.url.X property.", "predict": "/**\r\n     * Configures JAAS using a loop to avoid overwriting existing login configuration properties.\r\n     * \r\n     * @throws IOException\r\n     */\r\n    private void configureJaasUsingLoop() throws IOException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 215, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getCurrentDate() { long now = System.currentTimeMillis(); if ((now - currentDateGenerated) > 1000) { synchronized (format) { if ((now - currentDateGenerated) > 1000) { currentDateGenerated = now; currentDate = format.format(new Date(now)); } } } return currentDate; }\n\n    ### Response:", "ground_truth": "Gets the current date in HTTP format.\n\n@return Current date in HTTP format", "predict": "/**\r\n     * This method generates the current date and time and returns it as a string.\r\n     * It also caches the generated date and time for 1 second to reduce the number of calls to the system clock.\r\n     * \r\n     * @return the current date and time as a string\r\n     */\r\n    public static String getCurrentDate() {\r\n        long now = System.currentTimeMillis();\r\n        if ((now - currentDateGenerated) > 1000) {\r\n            synchronized (format) {\r\n                if ((now - currentDateGenerated) > 1000) {\r\n                    currentDateGenerated = now;\r\n                    currentDate = format.format(new Date(now));\r\n                }\r\n            }\r\n        }\r\n        return currentDate;\r\n    }"}, {"ID": 216, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Long internalParseDate(String value, DateFormat[] formats) { Date date = null; for (int i = 0; (date == null) && (i < formats.length); i++) { try { date = formats[i].parse(value); } catch (ParseException ignored) { } } if (date == null) { return null; } return new Long(date.getTime()); }\n\n    ### Response:", "ground_truth": "Parses date with given formatters.\n\n@param value The string to parse\n@param formats Array of formats to use\n\n@return Parsed date (or null if no formatter mached)", "predict": "/**\r\n     * Parses a date string using a list of date formats.\r\n     *\r\n     * @param value the date string to parse\r\n     * @param formats an array of date formats to try\r\n     * @return the parsed date as a long value, or null if the string could not be parsed\r\n     */\r\n    private static Long internalParseDate(String value, DateFormat[] formats) {\r\n        Date date = null;\r\n        for (int i = 0; (date == null) && (i < formats.length); i++) {\r\n            try {\r\n                date = formats[i].parse(value);\r\n            } catch (ParseException ignored) {\r\n            }\r\n        }\r\n        if (date == null) {\r\n            return null;\r\n        }\r\n        return new Long(date.getTime());\r\n    }"}, {"ID": 217, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private static void updateCache(HashMap cache, Object key, Object value) { if (value == null) { return; } if (cache.size() > 1000) { cache.clear(); } cache.put(key, value); }\n\n    ### Response:", "ground_truth": "Updates cache.\n\n@param cache Cache to be updated\n@param key Key to be updated\n@param value New value", "predict": "/**\r\n     * Updates the cache with the given key-value pair.\r\n     * \r\n     * @param cache the cache to be updated\r\n     * @param key the key to be used for the cache update\r\n     * @param value the value to be stored in the cache\r\n     */\r\n    private static void updateCache(HashMap cache, Object key, Object value) {\r\n        if (value == null) {\r\n            return;\r\n        }\r\n        if (cache.size() > 1000) {\r\n            cache.clear();\r\n        }\r\n        cache.put(key, value);\r\n    }"}, {"ID": 218, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); }\n\n    ### Response:", "ground_truth": "Provided so that subclasses may configure what is put into the authentication\nrequest's details property.\n\n@param request that an authentication request is being created for\n@param authRequest the authentication request object that should have its details\nset", "predict": "/**\r\n     * Sets the details of the authentication request.\r\n     * \r\n     * @param request the HTTP request\r\n     * @param authRequest the authentication request\r\n     */\r\n    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {\r\n        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));\r\n    }"}, {"ID": 219, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String getSecurityName(final Subject subject) { if (logger.isDebugEnabled()) { logger.debug(\"Determining Websphere security name for subject \" + subject); } String userSecurityName = null; if (subject != null) { // SEC-803 Object credential = subject.getPublicCredentials(getWSCredentialClass()) .iterator().next(); if (credential != null) { userSecurityName = (String) invokeMethod(getSecurityNameMethod(), credential); } } if (logger.isDebugEnabled()) { logger.debug(\"Websphere security name is \" + userSecurityName + \" for subject \" + subject); } return userSecurityName; }\n\n    ### Response:", "ground_truth": "Get the security name for the given subject.\n\n@param subject The subject for which to retrieve the security name\n@return String the security name for the given subject", "predict": "/**\r\n     * Retrieves the Websphere security name for the given subject.\r\n     * \r\n     * @param subject\r\n     *            the subject to retrieve the security name for\r\n     * @return the Websphere security name for the subject, or null if not found\r\n     */\r\n    private static String getSecurityName(final Subject subject) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 220, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception e) { logger.error(\"Exception occured while looking up groups for user\", e); throw new RuntimeException( \"Exception occured while looking up groups for user\", e); } finally { try { if (ic != null) { ic.close(); } } catch (NamingException e) { logger.debug(\"Exception occured while closing context\", e); } } }\n\n    ### Response:", "ground_truth": "Get the WebSphere group names for the given security name.\n\n@param securityName The security name for which to retrieve the WebSphere group\nnames\n@return the WebSphere group names for the given security name", "predict": "/**\r\n     * This method is used to retrieve the WebSphere groups for a given user.\r\n     * \r\n     * @param securityName\r\n     *            The name of the user for which the groups need to be retrieved.\r\n     * @return A list of groups for the given user.\r\n     */\r\n    private static List<String> getWebSphereGroups(final String securityName) {\r\n        // TODO: Implement method logic\r\n    }"}, {"ID": 221, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void changePassword(final String oldPassword, final String newPassword) { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); Assert.notNull( authentication, \"No authentication object found in security context. Can't change current user's password!\"); String username = authentication.getName(); logger.debug(\"Changing password for user '\" + username); DistinguishedName userDn = usernameMapper.buildDn(username); if (usePasswordModifyExtensionOperation) { changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword); } else { changePasswordUsingAttributeModification(userDn, oldPassword, newPassword); } }\n\n    ### Response:", "ground_truth": "Changes the password for the current user. The username is obtained from the\nsecurity context.\n\nThere are two supported strategies for modifying the user's password depending on\nthe capabilities of the corresponding LDAP server.\n\n\nConfigured one way, this method will modify the user's password via the\n\nLDAP Password Modify Extended Operation\n.\n\nSee {@link LdapUserDetailsManager#setUsePasswordModifyExtensionOperation(boolean)} for details.\n\n\nBy default, though, if the old password is supplied, the update will be made by rebinding as the user,\nthus modifying the password using the user's permissions. If\noldPassword is null, the update will be attempted using a standard\nread/write context supplied by the context source.\n\n\n@param oldPassword the old password\n@param newPassword the new value of the password.", "predict": "/**\n     * Changes the password for the current user.\n     *\n     * @param oldPassword the old password of the user.\n     * @param newPassword the new password of the user.\n     * @throws IllegalArgumentException if the old password is null or empty.\n     * @throws IllegalArgumentException if the new password is null or empty.\n     * @throws IllegalArgumentException if the old password and new password are the same.\n     * @throws ChangePasswordException if there is an error changing the password.\n     */\n    public void changePassword(final String oldPassword, final String newPassword) {\n        // TODO: Implement method\n    }"}, {"ID": 222, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DistinguishedName buildGroupDn(String group) { DistinguishedName dn = new DistinguishedName(groupSearchBase); dn.add(groupRoleAttributeName, group.toLowerCase()); return dn; }\n\n    ### Response:", "ground_truth": "Creates a DN from a group name.\n\n@param group the name of the group\n@return the DN of the corresponding group, including the groupSearchBase", "predict": "/**\r\n     * Builds a DistinguishedName object for the specified group.\r\n     * \r\n     * @param group the name of the group to build the DistinguishedName for\r\n     * @return a DistinguishedName object for the specified group\r\n     */\r\n    protected DistinguishedName buildGroupDn(String group) {\r\n        DistinguishedName dn = new DistinguishedName(groupSearchBase);\r\n        dn.add(groupRoleAttributeName, group.toLowerCase());\r\n        return dn;\r\n    }"}, {"ID": 223, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\")); } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null; for (SessionInformation session : sessions) { if ((leastRecentlyUsed == null) || session.getLastRequest() .before(leastRecentlyUsed.getLastRequest())) { leastRecentlyUsed = session; } } leastRecentlyUsed.expireNow(); }\n\n    ### Response:", "ground_truth": "Allows subclasses to customise behaviour when too many sessions are detected.\n\n@param sessions either null or all unexpired sessions associated with\nthe principal\n@param allowableSessions the number of concurrent sessions the user is allowed to\nhave\n@param registry an instance of the SessionRegistry for subclass use", "predict": "/**\r\n     * This method is called when the maximum number of allowable sessions has been exceeded.\r\n     * \r\n     * @param sessions\r\n     *            The list of sessions for the principal.\r\n     * @param allowableSessions\r\n     *            The maximum number of allowable sessions.\r\n     * @param registry\r\n     *            The session registry.\r\n     * @throws SessionAuthenticationException\r\n     *             If the maximum number of allowable sessions has been exceeded.\r\n     */\r\n    protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException {\r\n        if (exceptionIfMaximumExceeded || (sessions == null)) {\r\n            throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\"));\r\n        }\r\n        // Determine least recently used session, and mark it for invalidation\r\n        SessionInformation leastRecentlyUsed = null;\r\n        for (SessionInformation session : sessions)"}, {"ID": 224, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void copyDetails(Authentication source, Authentication dest) { if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) { AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest; token.setDetails(source.getDetails()); } }\n\n    ### Response:", "ground_truth": "Copies the authentication details from a source Authentication object to a\ndestination one, provided the latter does not already have one set.\n\n@param source source authentication\n@param dest the destination authentication object", "predict": "/**\r\n     * Copies the details from the source authentication object to the destination authentication object.\r\n     *\r\n     * @param source the source authentication object\r\n     * @param dest the destination authentication object\r\n     */\r\n    private void copyDetails(Authentication source, Authentication dest) {\r\n        if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) {\r\n            AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;\r\n            token.setDetails(source.getDetails());\r\n        }\r\n    }"}, {"ID": 225, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Filter> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; }\n\n    ### Response:", "ground_truth": "Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain", "predict": "/**\r\n     * Returns the list of filters that match the given request.\r\n     * \r\n     * @param request the HTTP request\r\n     * @return the list of filters that match the request, or null if no match is found\r\n     */\r\n    private List<Filter> getFilters(HttpServletRequest request) {\r\n        for (SecurityFilterChain chain : filterChains) {\r\n            if (chain.matches(request)) {\r\n                return chain.getFilters();\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 226, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Filter> getFilters(String url) { return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest()))); }\n\n    ### Response:", "ground_truth": "Convenience method, mainly for testing.\n\n@param url the URL\n@return matching filter list", "predict": "/**\r\n     * This method returns a list of filters based on the given URL.\r\n     * \r\n     * @param url The URL for which the filters need to be returned.\r\n     * @return A list of filters.\r\n     */\r\n    public List<Filter> getFilters(String url) {\r\n        return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest())));\r\n    }"}, {"ID": 227, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ApplicationContext getContext(PageContext pageContext) { ServletContext servletContext = pageContext.getServletContext(); return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext); }\n\n    ### Response:", "ground_truth": "Allows test cases to override where application context obtained from.\n\n@param pageContext so the ServletContext can be accessed as required\nby Spring's WebApplicationContextUtils\n\n@return the Spring application context (never null)", "predict": "/**\r\n     * Returns the ApplicationContext for the given PageContext.\r\n     * \r\n     * @param pageContext the PageContext to retrieve the ApplicationContext for\r\n     * @return the ApplicationContext for the given PageContext\r\n     */\r\n    protected ApplicationContext getContext(PageContext pageContext) {\r\n        // Get the ServletContext from the PageContext\r\n        ServletContext servletContext = pageContext.getServletContext();\r\n        \r\n        // Find the required WebApplicationContext using the SecurityWebApplicationContextUtils\r\n        return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext);\r\n    }"}, {"ID": 228, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException { DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace()); if (dn.contains(baseDn)) { return dn; } baseDn.append(dn); return baseDn; }\n\n    ### Response:", "ground_truth": "Gets the full dn of a name by prepending the name of the context it is relative to.\nIf the name already contains the base name, it is returned unaltered.", "predict": "/**\r\n     * This method takes a DistinguishedName object and a Context object as input and returns a new DistinguishedName object that is the full DistinguishedName of the input DistinguishedName object.\r\n     * \r\n     * @param dn - The DistinguishedName object to be processed.\r\n     * @param baseCtx - The Context object that provides the base DistinguishedName.\r\n     * @return A new DistinguishedName object that is the full DistinguishedName of the input DistinguishedName object.\r\n     * @throws NamingException - If an error occurs while processing the DistinguishedName.\r\n     */\r\n    public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException {\r\n        DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace());\r\n        if (dn.contains(baseDn)) {\r\n            return dn;\r\n        }\r\n        baseDn.append(dn);"}, {"ID": 229, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) { notNull(sessionAttributes, \"sessionAttributes\"); parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes); return this; }\n\n    ### Response:", "ground_truth": "Set session attributes.\n\n@param sessionAttributes the session attributes", "predict": "/**\n     * Adds session attributes to the request specification.\n     *\n     * @param sessionAttributes the session attributes to add to the request specification\n     * @return the updated request specification\n     */\n    public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) {\n        notNull(sessionAttributes, \"sessionAttributes\");\n        parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes);\n        return this;\n    }"}, {"ID": 230, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AuthenticationScheme basic(String userName, String password) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme(); preemptiveBasicAuthScheme.setUserName(userName); preemptiveBasicAuthScheme.setPassword(password); return preemptiveBasicAuthScheme; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Creates a new PreemptiveBasicAuthScheme object with the given user name and password.\r\n     *\r\n     * @param userName the user name for the authentication scheme\r\n     * @param password the password for the authentication scheme\r\n     * @return a new PreemptiveBasicAuthScheme object with the given user name and password\r\n     */\r\n    public AuthenticationScheme basic(String userName, String password) {\r\n        final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme();\r\n        preemptiveBasicAuthScheme.setUserName(userName);\r\n        preemptiveBasicAuthScheme.setPassword(password);\r\n        return preemptiveBasicAuthScheme;\r\n    }"}, {"ID": 231, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void filters(List<Filter> filters) { Validate.notNull(filters, \"Filter list cannot be null\"); RestAssured.filters.addAll(filters); }\n\n    ### Response:", "ground_truth": "Add default filters that will be applied to each request.\n\n@param filters The filter list", "predict": "/**\r\n     * Adds the given filters to the RestAssured filter list.\r\n     *\r\n     * @param filters the filters to add\r\n     * @throws IllegalArgumentException if the filter list is null\r\n     */\r\n    public static void filters(List<Filter> filters) {\r\n        Validate.notNull(filters, \"Filter list cannot be null\");\r\n        RestAssured.filters.addAll(filters);\r\n    }"}, {"ID": 232, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void filters(Filter filter, Filter... additionalFilters) { Validate.notNull(filter, \"Filter cannot be null\"); RestAssured.filters.add(filter); if (additionalFilters != null) { Collections.addAll(RestAssured.filters, additionalFilters); } }\n\n    ### Response:", "ground_truth": "Add default filters to apply to each request.\n\n@param filter            The filter to add\n@param additionalFilters An optional array of additional filters to add", "predict": "/**\r\n     * Adds the given filter(s) to the list of registered filters.\r\n     *\r\n     * @param filter the filter to add\r\n     * @param additionalFilters additional filters to add\r\n     * @throws IllegalArgumentException if the filter is null\r\n     */\r\n    public static void filters(Filter filter, Filter... additionalFilters) {\r\n        Validate.notNull(filter, \"Filter cannot be null\");\r\n        RestAssured.filters.add(filter);\r\n        if (additionalFilters != null) {\r\n            Collections.addAll(RestAssured.filters, additionalFilters);\r\n        }\r\n    }"}, {"ID": 233, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme basic(String userName, String password) { final BasicAuthScheme scheme = new BasicAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); return scheme; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Creates a new Basic authentication scheme with the given user name and password.\r\n     * \r\n     * @param userName the user name\r\n     * @param password the password\r\n     * @return the Basic authentication scheme\r\n     */\r\n    public static AuthenticationScheme basic(String userName, String password) {\r\n        final BasicAuthScheme scheme = new BasicAuthScheme();\r\n        scheme.setUserName(userName);\r\n        scheme.setPassword(password);\r\n        return scheme;\r\n    }"}, {"ID": 234, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) { final NTLMAuthScheme scheme = new NTLMAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setWorkstation(workstation); scheme.setDomain(domain); return scheme; }\n\n    ### Response:", "ground_truth": "Create a NTLM authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@param workstation The NTLM workstation.\n@param domain The NTLM workstation.\n@return The authentication scheme", "predict": "/**\r\n     * Creates a new NTLM authentication scheme with the specified user name, password, workstation, and domain.\r\n     * \r\n     * @param userName The user name to use for authentication.\r\n     * @param password The password to use for authentication.\r\n     * @param workstation The workstation to use for authentication.\r\n     * @param domain The domain to use for authentication.\r\n     * @return A new NTLM authentication scheme.\r\n     */\r\n    public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) {\r\n        final NTLMAuthScheme scheme = new NTLMAuthScheme();\r\n        scheme.setUserName(userName);\r\n        scheme.setPassword(password);\r\n        scheme.setWorkstation(workstation);\r\n        scheme.setDomain(domain);\r\n        return scheme;\r\n    }"}, {"ID": 235, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; }\n\n    ### Response:", "ground_truth": "Use form authentication with the supplied configuration.\n\n@param userName The user name.\n@param password The password.\n@param config   The form authentication config\n@return The authentication scheme", "predict": "/**\r\n     * Creates a new FormAuthScheme object with the given username, password, and configuration.\r\n     *\r\n     * @param userName the username to use for authentication\r\n     * @param password the password to use for authentication\r\n     * @param config the configuration to use for authentication\r\n     * @return a new FormAuthScheme object with the given username, password, and configuration\r\n     * @throws IllegalArgumentException if either the username or password is null\r\n     */\r\n    public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) {\r\n        if (userName == null) {\r\n            throw new IllegalArgumentException(\"Username cannot be null\");\r\n        }\r\n        if (password == null) {\r\n            throw new IllegalArgumentException(\"Password cannot be null\");\r\n        }\r\n        final FormAuthScheme scheme = new FormAuthScheme();\r\n        scheme.setUserName(userName);\r\n        scheme.setPassword(password);\r\n        scheme.setConfig(config);\r\n        return scheme;\r\n    }"}, {"ID": 236, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void proxy(URI uri) { if (uri == null) { throw new IllegalArgumentException(\"Proxy URI cannot be null\"); } proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme())); }\n\n    ### Response:", "ground_truth": "Instruct REST Assured to connect to a proxy using a URI.\n\n@param uri The URI of the proxy", "predict": "/**\r\n     * Sets the proxy for the current JVM.\r\n     * \r\n     * @param uri the URI of the proxy server to use, in the format http[s]://host:port\r\n     * @throws IllegalArgumentException if the URI is null or invalid\r\n     */\r\n    public static void proxy(URI uri) {\r\n        if (uri == null) {\r\n            throw new IllegalArgumentException(\"Proxy URI cannot be null\");\r\n        }\r\n        proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme()));\r\n    }"}, {"ID": 237, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if (shouldPrettyPrint) { responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody); } else { responseBodyToAppend = responseBody.asString(); } if (logDetail == ALL && !isBlank(responseBodyToAppend)) { builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR); } builder.append(responseBodyToAppend); } String response = builder.toString(); stream.println(response); return response; }\n\n    ### Response:", "ground_truth": "Prints the response to the print stream\n\n@return A string of representing the response", "predict": "/**\n     * Prints the given response to the given stream.\n     *\n     * @param responseOptions the response options\n     * @param responseBody the response body\n     * @param stream the stream to print to\n     * @param logDetail the log detail level\n     * @param shouldPrettyPrint whether to pretty print the response body\n     * @return the response as a string\n     */\n    public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) {\n        // TODO: Implement method\n    }"}, {"ID": 238, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredConfig redirect(RedirectConfig redirectConfig) { notNull(redirectConfig, \"Redirect config\"); return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); }\n\n    ### Response:", "ground_truth": "Set the redirect config.\n\n@param redirectConfig The {@link RedirectConfig} to set\n@return An updated RestAssuredConfiguration", "predict": "/**\n     * Sets the redirect configuration for the RestAssured client.\n     *\n     * @param redirectConfig the redirect configuration to use\n     * @return the updated RestAssuredConfig object\n     */\n    public RestAssuredConfig redirect(RedirectConfig redirectConfig) {\n        notNull(redirectConfig, \"Redirect config\");\n        return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class));\n    }"}, {"ID": 239, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EncoderConfig defaultQueryParameterCharset(String charset) { return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true); }\n\n    ### Response:", "ground_truth": "Specify the default charset for query parameters\n\n@param charset The charset to use.\n@return A new instance of {@link EncoderConfig}", "predict": "/**\n     * Sets the default query parameter charset.\n     * \n     * @param charset the charset to set\n     * @return the updated EncoderConfig object\n     */\n    public EncoderConfig defaultQueryParameterCharset(String charset) {\n        return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true);\n    }"}, {"ID": 240, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); }\n\n    ### Response:", "ground_truth": "Creates an object mapper configuration that uses the specified object mapper as default.\n\n@param defaultObjectMapperType The object mapper to use. If null then classpath scanning will be used.", "predict": "/**\n     * Sets the default ObjectMapperType to be used by the ObjectMapperConfig.\n     * \n     * @param defaultObjectMapperType the default ObjectMapperType to be used by the ObjectMapperConfig.\n     * @return the updated ObjectMapperConfig object.\n     */\n    public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) {\n        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true);\n    }"}, {"ID": 241, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); }\n\n    ### Response:", "ground_truth": "Specify a custom JAXB object mapper factory.\n\n@param jaxbObjectMapperFactory The object mapper factory", "predict": "/**\r\n     * Configures the ObjectMapper for JAX-B.\r\n     * \r\n     * @param jaxbObjectMapperFactory the factory for creating the ObjectMapper for JAX-B\r\n     * @return the ObjectMapperConfig object with the configured ObjectMapper for JAX-B\r\n     */\r\n    public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) {\r\n        return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true);\r\n    }"}, {"ID": 242, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) { notNull(logConfig, \"Log config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Log config.\n\n@param logConfig The {@link LogConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the log configuration for the Rest Assured MockMvc instance.\n     *\n     * @param logConfig the log configuration to use\n     * @return this RestAssuredMockMvcConfig instance\n     * @throws IllegalArgumentException if logConfig is null\n     */\n    public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) {\n        notNull(logConfig, \"Log config\");\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 243, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) { notNull(sessionConfig, \"Session config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the session config.\n\n@param sessionConfig The {@link SessionConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\r\n     * Sets the session configuration to use for the mockMvc.\r\n     *\r\n     * @param sessionConfig the session configuration to use for the mockMvc.\r\n     * @return this object.\r\n     * @throws IllegalArgumentException if sessionConfig is null.\r\n     */\r\n    public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) {\r\n        notNull(sessionConfig, \"Session config\");\r\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig);\r\n    }"}, {"ID": 244, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) { notNull(objectMapperConfig, \"Object mapper config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the object mapper config.\n\n@param objectMapperConfig The {@link ObjectMapperConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\r\n     * Sets the object mapper config.\r\n     *\r\n     * @param objectMapperConfig the object mapper config\r\n     * @return the rest assured mock mvc config\r\n     */\r\n    public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) {\r\n        notNull(objectMapperConfig, \"Object mapper config\");\r\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\r\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\r\n                mockMvcConfig, paramConfig, matcherConfig);\r\n    }"}, {"ID": 245, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) { notNull(jsonConfig, \"JsonConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Json config.\n\n@param jsonConfig The {@link JsonConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\r\n     * Sets the {@link JsonConfig} to use for JSON serialization and deserialization.\r\n     *\r\n     * @param jsonConfig the {@link JsonConfig} to use for JSON serialization and deserialization.\r\n     * @return this {@link RestAssuredMockMvcConfig} instance.\r\n     * @throws IllegalArgumentException if {@code jsonConfig} is {@code null}.\r\n     */\r\n    public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) {\r\n        notNull(jsonConfig, \"JsonConfig\");\r\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\r\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\r\n                mockMvcConfig, paramConfig, matcherConfig);\r\n    }"}, {"ID": 246, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) { notNull(xmlConfig, \"XmlConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the Xml config.\n\n@param xmlConfig The {@link XmlConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\r\n     * Sets the {@link XmlConfig} to use for configuring XML support.\r\n     *\r\n     * @param xmlConfig the {@link XmlConfig} to use for configuring XML support.\r\n     * @return this {@link RestAssuredMockMvcConfig} instance.\r\n     * @throws IllegalArgumentException if {@code xmlConfig} is {@code null}.\r\n     */\r\n    public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) {\r\n        notNull(xmlConfig, \"XmlConfig\");\r\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\r\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\r\n                mockMvcConfig, paramConfig, matcherConfig);\r\n    }"}, {"ID": 247, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) { notNull(encoderConfig, \"EncoderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the encoder config\n\n@param encoderConfig The {@link EncoderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the {@link EncoderConfig} to use for encoding and decoding request and response bodies.\n     *\n     * @param encoderConfig the {@link EncoderConfig} to use\n     * @return this {@link RestAssuredMockMvcConfig} instance\n     * @throws IllegalArgumentException if {@code encoderConfig} is {@code null}\n     */\n    public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) {\n        notNull(encoderConfig, \"EncoderConfig\");\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 248, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) { notNull(headerConfig, \"HeaderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the header config\n\n@param headerConfig The {@link HeaderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\r\n     * Sets the {@link HeaderConfig} to use.\r\n     *\r\n     * @param headerConfig the {@link HeaderConfig} to use\r\n     * @return this {@link RestAssuredMockMvcConfig} instance\r\n     * @throws IllegalArgumentException if {@code headerConfig} is {@code null}\r\n     */\r\n    public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) {\r\n        notNull(headerConfig, \"HeaderConfig\");\r\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\r\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\r\n                mockMvcConfig, paramConfig, matcherConfig);\r\n    }"}, {"ID": 249, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) { notNull(asyncConfig, AsyncConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the async config\n\n@param asyncConfig The {@link AsyncConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the {@link AsyncConfig} to use for configuring async behavior.\n     *\n     * @param asyncConfig the {@link AsyncConfig} to use\n     * @return this {@link RestAssuredMockMvcConfig} instance\n     */\n    public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) {\n        notNull(asyncConfig, AsyncConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 250, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) { notNull(mockMvcConfig, MockMvcConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the MockMVC config\n\n@param mockMvcConfig The {@link MockMvcConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Creates a new RestAssuredMockMvcConfig instance with the given MockMvcConfig instance.\n     *\n     * @param mockMvcConfig the MockMvcConfig instance to use\n     * @return a new RestAssuredMockMvcConfig instance\n     */\n    public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) {\n        notNull(mockMvcConfig, MockMvcConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 251, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) { notNull(multiPartConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the multi-part config\n\n@param multiPartConfig The {@link MultiPartConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the {@link MultiPartConfig} to use for multipart requests.\n     *\n     * @param multiPartConfig the {@link MultiPartConfig} to use for multipart requests.\n     * @return this {@link RestAssuredMockMvcConfig} instance.\n     * @throws IllegalArgumentException if {@code multiPartConfig} is {@code null}.\n     */\n    public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) {\n        notNull(multiPartConfig, MultiPartConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 252, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) { notNull(paramConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the parameter config\n\n@param paramConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the {@link MockMvcParamConfig} to use for configuring the {@link MockMvc} instance.\n     *\n     * @param paramConfig the {@link MockMvcParamConfig} to use for configuring the {@link MockMvc} instance.\n     * @return this {@link RestAssuredMockMvcConfig} instance.\n     * @throws IllegalArgumentException if {@code paramConfig} is {@code null}.\n     */\n    public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) {\n        notNull(paramConfig, MultiPartConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 253, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) { notNull(matcherConfig, MatcherConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); }\n\n    ### Response:", "ground_truth": "Set the matcher config\n\n@param matcherConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": "/**\n     * Sets the {@link MatcherConfig} to use for matching request and response content.\n     *\n     * @param matcherConfig the {@link MatcherConfig} to use for matching request and response content.\n     * @return this {@link RestAssuredMockMvcConfig} instance.\n     */\n    public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) {\n        notNull(matcherConfig, MatcherConfig.class);\n        return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig,\n                objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig,\n                mockMvcConfig, paramConfig, matcherConfig);\n    }"}, {"ID": 254, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CertificateAuthSettings allowAllHostnames() { return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Sets the hostname verifier to allow all hostnames.\r\n     * \r\n     * @return the updated CertificateAuthSettings object\r\n     */\r\n    public CertificateAuthSettings allowAllHostnames() {\r\n        return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory);\r\n    }"}, {"ID": 255, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); }\n\n    ### Response:", "ground_truth": "Specify declared namespaces that will be used when parsing XML.\n\n@param namespacesToDeclare A map containing features that will be used by the underlying {@link groovy.util.XmlSlurper}.\n@return A new instance of XmlPathConfig\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": "/**\n     * Declare the given namespaces to be used during XML parsing.\n     * \n     * @param namespacesToDeclare a map of namespace prefixes to namespace URIs\n     * @return the updated XmlPathConfig object\n     */\n    public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) {\n        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration);\n    }"}, {"ID": 256, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) { Validate.notEmpty(prefix, \"Prefix cannot be empty\"); Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\"); Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces); updatedNamespaces.put(prefix, namespaceURI); return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration); }\n\n    ### Response:", "ground_truth": "Declares a namespace.\n\n@param prefix       The feature name, which is a fully-qualified URI.\n@param namespaceURI The requested value of the feature (true or false).\n@return A new XmlPathConfig instance\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": "/**\r\n     * Sets the namespace URI for the specified prefix.\r\n     * \r\n     * @param prefix the prefix for the namespace URI\r\n     * @param namespaceURI the namespace URI to set\r\n     * @return the updated XmlPathConfig object\r\n     * @throws IllegalArgumentException if prefix or namespaceURI is empty\r\n     */\r\n    public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) {\r\n        Validate.notEmpty(prefix, \"Prefix cannot be empty\");\r\n        Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\");\r\n        Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces);\r\n        updatedNamespaces.put(prefix, namespaceURI);\r\n        return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration);\r\n    }"}, {"ID": 257, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); }\n\n    ### Response:", "ground_truth": "Make an HTTP request to the default URI, and parse using the default\ncontent-type.\n\n@param method        {@link HttpRequestFactory HTTP method}\n@param configClosure request configuration options\n@return whatever value was returned by the executed response handler.\n@throws ClientProtocolException\n@throws IOException\n@see #request(Object, HttpRequestFactory, Object, Closure)", "predict": "/**\n     * Sends an HTTP request to the server using the specified method, content type, and optional request body.\n     *\n     * @param method the HTTP method to use (e.g. GET, POST, PUT, DELETE)\n     * @param hasBody true if the request should include a request body, false otherwise\n     * @param configClosure a closure that can be used to configure the request before it is sent (e.g. set headers, timeouts, etc.)\n     * @return the response object\n     * @throws ClientProtocolException if an error occurs in the HTTP client\n     * @throws IOException if an error occurs while reading or writing data to the connection\n     */\n    public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException {\n        return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure);\n    }"}, {"ID": 258, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setHeaders(Map<?, ?> headers) { this.defaultRequestHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultRequestHeaders.put(key.toString(), val.toString()); } }\n\n    ### Response:", "ground_truth": "Set the default headers to add to all requests made by this builder\ninstance.  These values will replace any previously set default headers.\n\n@param headers map of header names & values.", "predict": "/**\r\n     * Sets the headers for the HTTP request.\r\n     *\r\n     * @param headers the headers to set, may be null to remove all headers\r\n     */\r\n    public void setHeaders(Map<?, ?> headers) {\r\n        this.defaultRequestHeaders.clear();\r\n        if (headers == null) {\r\n            return;\r\n        }\r\n        for (Object key : headers.keySet()) {\r\n            Object val = headers.get(key);\r\n            if (val == null) {\r\n                continue;\r\n            }\r\n            this.defaultRequestHeaders.put(key.toString(), val.toString());\r\n        }\r\n    }"}, {"ID": 259, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); }\n\n    ### Response:", "ground_truth": "null for the default\n@see HttpHost#HttpHost(String, int, String)", "predict": "/**\r\n     * Sets the proxy for the HTTP client.\r\n     * \r\n     * @param host The host of the proxy.\r\n     * @param port The port of the proxy.\r\n     * @param scheme The scheme of the proxy (e.g. \"http\" or \"https\").\r\n     */\r\n    public void setProxy(String host, int port, String scheme) {\r\n        getClient().getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme));\r\n    }"}, {"ID": 260, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartSpecBuilder controlName(String controlName) { Validate.notEmpty(controlName, \"Control name cannot be empty\"); this.controlName = controlName; this.isControlNameExplicit = true; return this; }\n\n    ### Response:", "ground_truth": "Specify the control name of this multi-part.\n\n@param controlName The control name to use. Default is file.\n@return An instance of MultiPartSpecBuilder", "predict": "/**\r\n     * Sets the control name for the multi-part request.\r\n     * \r\n     * @param controlName the control name for the multi-part request.\r\n     * @return the updated MultiPartSpecBuilder instance.\r\n     * @throws IllegalArgumentException if the control name is empty or null.\r\n     */\r\n    public MultiPartSpecBuilder controlName(String controlName) {\r\n        Validate.notEmpty(controlName, \"Control name cannot be empty\");\r\n        this.controlName = controlName;\r\n        this.isControlNameExplicit = true;\r\n        return this;\r\n    }"}, {"ID": 261, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartSpecBuilder header(String name, String value) { Validate.notEmpty(name, \"Header name cannot be empty\"); Validate.notEmpty(value, \"Header value cannot be empty\"); // Replace previous header if exists final Set<String> headerNames = headers.keySet(); final String trimmedName = name.trim(); for (String headerName : headerNames) { if (headerName.equalsIgnoreCase(trimmedName)) { headers.remove(headerName); } } // Put the name header in the header list headers.put(name, value); return this; }\n\n    ### Response:", "ground_truth": "Add a header to this multipart specification.\n\n@param name The name of the header\n@param value The value of the header\n@return An instance of MultiPartSpecBuilder", "predict": "/**\r\n     * Adds a header to the request.\r\n     * \r\n     * @param name the name of the header\r\n     * @param value the value of the header\r\n     * @return the updated MultiPartSpecBuilder instance\r\n     * @throws IllegalArgumentException if the header name or value is empty\r\n     */\r\n    public MultiPartSpecBuilder header(String name, String value) {\r\n        Validate.notEmpty(name, \"Header name cannot be empty\");\r\n        Validate.notEmpty(value, \"Header value cannot be empty\");\r\n        // Replace previous header if exists\r\n        final Set<String> headerNames = headers.keySet();\r\n        final String trimmedName = name.trim();\r\n        for (String headerName : headerNames) {\r\n            if (headerName.equalsIgnoreCase(trimmedName)) {\r\n                headers.remove(headerName);\r\n            }\r\n        }\r\n        // Put the name header in the header list\r\n        headers.put(name, value);\r\n        return this;\r\n    }"}, {"ID": 262, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void basic(String host, int port, String user, String pass) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new UsernamePasswordCredentials(user, pass) ); }\n\n    ### Response:", "ground_truth": "Set authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass", "predict": "/**\r\n     * This method sets the credentials for the HTTP client.\r\n     * \r\n     * @param host The host for the HTTP client.\r\n     * @param port The port for the HTTP client.\r\n     * @param user The username for the HTTP client.\r\n     * @param pass The password for the HTTP client.\r\n     */\r\n    public void basic(String host, int port, String user, String pass) {\r\n        builder.getClient().getCredentialsProvider().setCredentials(new AuthScope(host, port), new UsernamePasswordCredentials(user, pass));\r\n    }"}, {"ID": 263, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void ntlm(String host, int port, String user, String pass, String workstation, String domain) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain) ); }\n\n    ### Response:", "ground_truth": "Set NTLM authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass\n@param workstation\n@param domain", "predict": "/**\r\n     * This method sets the NTLM credentials for the HTTP client.\r\n     * \r\n     * @param host The host name of the server.\r\n     * @param port The port number of the server.\r\n     * @param user The user name for authentication.\r\n     * @param pass The password for authentication.\r\n     * @param workstation The workstation name for authentication.\r\n     * @param domain The domain name for authentication.\r\n     */\r\n    public void ntlm(String host, int port, String user, String pass, String workstation, String domain) {\r\n        builder.getClient().getCredentialsProvider().setCredentials(new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain));\r\n    }"}, {"ID": 264, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Headers headers(Header header, Header... additionalHeaders) { notNull(header, \"Header\"); final List<Header> headerList = new LinkedList<Header>(); headerList.add(header); if (additionalHeaders != null) { Collections.addAll(headerList, additionalHeaders); } return new Headers(headerList); }\n\n    ### Response:", "ground_truth": "An alternative way to create a Headers object from the constructor.\n\n@param header            The header to be included\n@param additionalHeaders Additional headers to be included (optional)\n@return A new headers object containing the specified headers", "predict": "/**\r\n     * Creates a new {@link Headers} instance with the given {@link Header} and additional headers.\r\n     *\r\n     * @param header the first header to add\r\n     * @param additionalHeaders additional headers to add\r\n     * @return a new {@link Headers} instance with the given headers\r\n     * @throws NullPointerException if the given header is null\r\n     */\r\n    public static Headers headers(Header header, Header... additionalHeaders) {\r\n        notNull(header, \"Header\");\r\n        final List<Header> headerList = new LinkedList<Header>();\r\n        headerList.add(header);\r\n        if (additionalHeaders != null) {\r\n            Collections.addAll(headerList, additionalHeaders);\r\n        }\r\n        return new Headers(headerList);\r\n    }"}, {"ID": 265, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; }\n\n    ### Response:", "ground_truth": "Reset all static configurations to their default values.", "predict": "/**\r\n     * Resets the MockMvcFactory, Config, Base Path, Result Handlers, Request Post Processors, Response Specification, Request Specification, and Authentication to their default values.\r\n     */\r\n    public static void reset() {\r\n        mockMvcFactory = null;\r\n        config = null;\r\n        basePath = \"/\";\r\n        resultHandlers.clear();\r\n        requestPostProcessors.clear();\r\n        responseSpecification = null;\r\n        requestSpecification = null;\r\n        authentication = null;\r\n    }"}, {"ID": 266, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; }\n\n    ### Response:", "ground_truth": "Set a specific header\n\n@return The builder", "predict": "/**\r\n     * Sets a header with the given name and value.\r\n     *\r\n     * @param name the name of the header\r\n     * @param value the value of the header\r\n     * @return the response builder instance\r\n     * @throws IllegalArgumentException if the name or value is null\r\n     */\r\n    public ResponseBuilder setHeader(String name, String value) {\r\n        notNull(name, \"Header name\");\r\n        notNull(value, \"Header value\");\r\n        List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList());\r\n        newHeaders.add(new Header(name, value));\r\n        restAssuredResponse.setResponseHeaders(new Headers(newHeaders));\r\n        if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) {\r\n            restAssuredResponse.setContentType(value);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 267, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; }\n\n    ### Response:", "ground_truth": "Build the actual response\n\n@return The response object", "predict": "/**\r\n     * Builds the response object.\r\n     * \r\n     * @return the response object\r\n     */\r\n    public Response build() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 268, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether value of cookie satisfies specified matcher.\n@param valueMatcher value assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed value property assertion", "predict": "/**\r\n     * Matches a cookie by its value.\r\n     *\r\n     * @param valueMatcher the matcher to apply to the cookie value\r\n     * @return a matcher that matches cookies with a value that satisfies the given matcher\r\n     */\r\n    public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) {\r\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher)));\r\n    }"}, {"ID": 269, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether comment of cookie satisfies specified matcher.\n@param commentMatcher comment assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed comment property assertion", "predict": "/**\r\n     * Creates a new matcher that matches cookies with a specific comment.\r\n     *\r\n     * @param commentMatcher the matcher to use for the comment\r\n     * @return a new matcher that matches cookies with a specific comment\r\n     */\r\n    public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) {\r\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher)));\r\n    }"}, {"ID": 270, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether expiry date of cookie satisfies specified matcher.\n@param expiryDateMatcher expiry date assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed expiry date property assertion", "predict": "/**\n     * Matches a cookie with a specific expiry date.\n     *\n     * @param expiryDateMatcher the matcher to use for the expiry date\n     * @return a matcher that matches cookies with the specified expiry date\n     */\n    public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher)));\n    }"}, {"ID": 271, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether domain of cookie satisfies specified matcher.\n@param domainMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed domain property assertion", "predict": "/**\n     * Matches cookies with a specific domain.\n     *\n     * @param domainMatcher the matcher to use for the domain property\n     * @return a new matcher that matches cookies with the specified domain\n     */\n    public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher)));\n    }"}, {"ID": 272, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether path of cookie satisfies specified matcher.\n@param pathMatcher assertion for path property\n@return A {@link DetailedCookieMatcher} instance with and-composed path property assertion", "predict": "/**\n     * Matches a cookie by its path.\n     *\n     * @param pathMatcher the matcher to apply to the path of the cookie\n     * @return a matcher that matches cookies with the specified path\n     */\n    public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher)));\n    }"}, {"ID": 273, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether secured property of cookie satisfies specified matcher.\n@param securedMatcher assertion for secured property\n@return A {@link DetailedCookieMatcher} instance with and-composed secured property assertion", "predict": "/**\n     * Matches cookies that are secured according to the given matcher.\n     *\n     * @param securedMatcher the matcher to use to match the secured property of the cookie\n     * @return a matcher that matches cookies that are secured according to the given matcher\n     */\n    public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher)));\n    }"}, {"ID": 274, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\n     * Matches a cookie with the specified httpOnly property.\n     *\n     * @param httpOnlyMatcher the matcher to apply to the httpOnly property\n     * @return a matcher that matches cookies with the specified httpOnly property\n     */\n    public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher)));\n    }"}, {"ID": 275, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether version of cookie satisfies specified matcher.\n@param versionMatcher assertion for version property\n@return A {@link DetailedCookieMatcher} instance with and-composed version property assertion", "predict": "/**\n     * Matches a cookie with a specific version.\n     *\n     * @param versionMatcher the matcher to use for the version property\n     * @return a matcher that matches cookies with the specified version\n     */\n    public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher)));\n    }"}, {"ID": 276, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); }\n\n    ### Response:", "ground_truth": "Verifies whether max age of cookie satisfies specified matcher.\n@param maxAgeMatcher assertion for max age property\n@return A {@link DetailedCookieMatcher} instance with and-composed max age property assertion", "predict": "/**\n     * Matches cookies with a maximum age that matches the given matcher.\n     *\n     * @param maxAgeMatcher the matcher to use to match the maximum age of the cookie\n     * @return a matcher that matches cookies with a maximum age that matches the given matcher\n     */\n    public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) {\n        return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher)));\n    }"}, {"ID": 277, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) { spec.header(headerName, expectedValueMatcher); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response header matches the supplied header name and hamcrest matcher.\n\n@param headerName           The name of the expected header\n@param expectedValueMatcher The Hamcrest matcher that must conform to the value\n@return The builder", "predict": "/**\n     * Adds an expected header to the response specification.\n     *\n     * @param headerName the name of the header to expect\n     * @param expectedValueMatcher a matcher that will be used to match the value of the header\n     * @return the response specification builder\n     */\n    public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) {\n        spec.header(headerName, expectedValueMatcher);\n        return this;\n    }"}, {"ID": 278, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) { spec.header(headerName, expectedValue); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response header matches the supplied name and value.\n\n@param headerName    The name of the expected header\n@param expectedValue The value of the expected header\n@return The builder", "predict": "/**\n     * Adds an expected header to the response specification.\n     *\n     * @param headerName the name of the header to expect\n     * @param expectedValue the expected value of the header\n     * @return the response specification builder\n     */\n    public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) {\n        spec.header(headerName, expectedValue);\n        return this;\n    }"}, {"ID": 279, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) { spec.cookie(cookieName, expectedValue); return this; }\n\n    ### Response:", "ground_truth": "Expect that a response cookie matches the supplied name and value.\n\n@param cookieName    The name of the expected cookie\n@param expectedValue The value of the expected cookie\n@return The builder", "predict": "/**\n     * Adds a cookie expectation to the response specification.\n     *\n     * @param cookieName the name of the cookie to expect\n     * @param expectedValue the expected value of the cookie\n     * @return the response specification builder\n     */\n    public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) {\n        spec.cookie(cookieName, expectedValue);\n        return this;\n    }"}, {"ID": 280, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProxySpecification withHost(String host) { return new ProxySpecification(host, port, scheme, username, password); }\n\n    ### Response:", "ground_truth": "Specify the hostname of the proxy.\n\n@param host The hostname of the proxy.\n@return A new ProxySpecification instance", "predict": "/**\r\n     * Sets the host for the proxy.\r\n     * \r\n     * @param host the host for the proxy\r\n     * @return a new ProxySpecification object with the updated host\r\n     */\r\n    public ProxySpecification withHost(String host) {\r\n        return new ProxySpecification(host, port, scheme, username, password);\r\n    }"}, {"ID": 281, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); }\n\n    ### Response:", "ground_truth": "Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.\n\n@param numberReturnType The choice.\n@return A new instance of JsonPathConfig with the given configuration", "predict": "/**\n     * Sets the numberReturnType for the JsonPathConfig object.\n     *\n     * @param numberReturnType the numberReturnType to set\n     * @return the updated JsonPathConfig object\n     */\n    public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) {\n        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset);\n    }"}, {"ID": 282, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonPathConfig defaultParserType(JsonParserType defaultParserType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); }\n\n    ### Response:", "ground_truth": "Creates an json path configuration that uses the specified parser type as default.\n\n@param defaultParserType The parser type to use. If null then classpath scanning will be used.", "predict": "/**\n     * Sets the default parser type for the JsonPathConfig object.\n     *\n     * @param defaultParserType the default parser type to set\n     * @return the updated JsonPathConfig object\n     */\n    public JsonPathConfig defaultParserType(JsonParserType defaultParserType) {\n        return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset);\n    }"}, {"ID": 283, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LogConfig defaultStream(PrintStream printStream) { return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true); }\n\n    ### Response:", "ground_truth": "Specify a new default stream to the print to.\n\n@param printStream The stream\n@return A new LogConfig instance", "predict": "/**\r\n     * Sets the default stream for the logger.\r\n     * \r\n     * @param printStream the print stream to set as the default stream for the logger.\r\n     * @return the updated LogConfig object.\r\n     */\r\n    public LogConfig defaultStream(PrintStream printStream) {\r\n        return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true);\r\n    }"}, {"ID": 284, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); }\n\n    ### Response:", "ground_truth": "Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail\n\n@param logDetail The log detail to show in the log\n@return A new LogConfig instance", "predict": "/**\r\n     * Enables logging of request and response if validation fails.\r\n     * \r\n     * @param logDetail the log detail to be used for logging\r\n     * @return the updated LogConfig object\r\n     */\r\n    public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) {\r\n        return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true);\r\n    }"}, {"ID": 285, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) { String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\"); Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method); final HttpRequestBase httpRequest; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) { httpRequest = new CustomHttpMethod(method, uri); } else { try { httpRequest = type.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } httpRequest.setURI(uri); } return httpRequest; }\n\n    ### Response:", "ground_truth": "Get the HttpRequest class that represents this request type.\n\n@return a non-abstract class that implements {@link HttpRequest}", "predict": "/**\r\n     * Creates an instance of {@link HttpRequestBase} based on the given URI, HTTP method and whether it has a body.\r\n     *\r\n     * @param uri the URI of the request\r\n     * @param httpMethod the HTTP method of the request\r\n     * @param hasBody whether the request has a body\r\n     * @return an instance of {@link HttpRequestBase} based on the given URI, HTTP method and whether it has a body\r\n     */\r\n    static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) {\r\n        String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\");\r\n        Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method);\r\n        final HttpRequestBase httpRequest;\r\n        // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents\r\n        // us from including it, however we chose to allow deviations from standard if user wants so,\r\n        // so it needs custom handling - hence the second condition"}, {"ID": 286, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MultiPartConfig defaultBoundary(String defaultBoundary) { return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true); }\n\n    ### Response:", "ground_truth": "Specify an explicit default multipart boundary to use when sending multi-part data.\n\n@param defaultBoundary The boundary to set\n@return An updated MultiPartConfig", "predict": "/**\r\n     * Sets the default boundary for the multipart request.\r\n     * \r\n     * @param defaultBoundary the default boundary to set\r\n     * @return the updated MultiPartConfig object\r\n     */\r\n    public MultiPartConfig defaultBoundary(String defaultBoundary) {\r\n        return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true);\r\n    }"}, {"ID": 287, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) { spec.attribute(attributeName, attributeValue); return this; }\n\n    ### Response:", "ground_truth": "Add request attribute\n\n@param attributeName  The attribute name\n@param attributeValue The attribute value\n@return The request specification builder", "predict": "/**\n     * Adds an attribute to the request specification.\n     *\n     * @param attributeName the name of the attribute to add\n     * @param attributeValue the value of the attribute to add\n     * @return the updated request specification builder\n     */\n    public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) {\n        spec.attribute(attributeName, attributeValue);\n        return this;\n    }"}, {"ID": 288, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) { spec.header(headerName, headerValue); return this; }\n\n    ### Response:", "ground_truth": "Add a header to be sent with the request\n\n@param headerName  The header name\n@param headerValue The header value\n@return The request specification builder", "predict": "/**\n     * Adds a header to the request specification.\n     *\n     * @param headerName the name of the header to add\n     * @param headerValue the value of the header to add\n     * @return the updated request specification builder\n     */\n    public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) {\n        spec.header(headerName, headerValue);\n        return this;\n    }"}, {"ID": 289, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) { spec.multiPart(controlName, mimeType); return this; }\n\n    ### Response:", "ground_truth": "Specify a string to send to the server using multi-part form data with a specific mime-type.\n\n@param controlName Defines the control name of the body part. In HTML this is the attribute name of the input tag.\n@param contentBody The string to send\n@param mimeType    The mime-type\n@return The request specification", "predict": "/**\n     * Adds a multi-part file to the request specification.\n     *\n     * @param controlName the name of the control\n     * @param contentBody the content of the file\n     * @param mimeType the MIME type of the file\n     * @return the updated request specification builder\n     */\n    public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) {\n        spec.multiPart(controlName, mimeType);\n        return this;\n    }"}, {"ID": 290, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.resultHandlers(resultHandler, additionalResultHandlers); return this; }\n\n    ### Response:", "ground_truth": "Add a result handler\n\n@param resultHandler The result handler\n@return MockMvcRequestSpecBuilder", "predict": "/**\n     * Adds the given result handlers to the list of result handlers to be applied to the request.\n     *\n     * @param resultHandler the result handler to add\n     * @param additionalResultHandlers additional result handlers to add\n     * @return the updated MockMvcRequestSpecBuilder\n     */\n    public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) {\n        spec.resultHandlers(resultHandler, additionalResultHandlers);\n        return this;\n    }"}, {"ID": 291, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> HttpClientConfig setParam(String parameterName, T parameterValue) { notNull(parameterName, \"Parameter name\"); final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams); newParams.put(parameterName, parameterValue); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "            The parameter type\n@return An updated HttpClientConfig", "predict": "/**\r\n     * Sets a parameter for the HttpClient.\r\n     * \r\n     * @param parameterName the name of the parameter to set\r\n     * @param parameterValue the value of the parameter to set\r\n     * @return a new HttpClientConfig object with the updated parameter\r\n     * @throws IllegalArgumentException if the parameter name is null or empty\r\n     */\r\n    public <T> HttpClientConfig setParam(String parameterName, T parameterValue) {\r\n        notNull(parameterName, \"Parameter name\");\r\n        final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams);\r\n        newParams.put(parameterName, parameterValue);\r\n        return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);\r\n    }"}, {"ID": 292, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Adds the given parameters to the existing parameters of the HttpClientConfig.\r\n     *\r\n     * @param httpClientParams the parameters to be added\r\n     * @return a new HttpClientConfig with the added parameters\r\n     * @throws IllegalArgumentException if the given parameters are null\r\n     */\r\n    public HttpClientConfig addParams(Map<String, ?> httpClientParams) {\r\n        notNull(httpClientParams, \"httpClientParams\");\r\n        final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams);\r\n        newParams.putAll(httpClientParams);\r\n        return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);\r\n    }"}, {"ID": 293, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * This method is used to create an instance of HttpClientConfig class.\r\n     * \r\n     * @param httpClientFactory - An instance of HttpClientFactory class.\r\n     * @return An instance of HttpClientConfig class.\r\n     */\r\n    public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) {\r\n        return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true);\r\n    }"}, {"ID": 294, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Sets the HTTP Multipart mode for the HttpClient.\r\n     * \r\n     * @param httpMultipartMode the HTTP Multipart mode to be used for the HttpClient.\r\n     * @return the updated HttpClientConfig object.\r\n     */\r\n    public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) {\r\n        return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true);\r\n    }"}, {"ID": 295, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T get(String path) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a boolean.\n\n@param path The Object path.\n@return The object matching the Object path. This may be any primitive type, a List or a Map.  A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * This method takes a path as input and returns the corresponding JSON object.\r\n     *\r\n     * @param <T> The type of the JSON object to be returned.\r\n     * @param path The path of the JSON object to be returned.\r\n     * @return The JSON object corresponding to the given path.\r\n     */\r\n    public <T> T get(String path) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 296, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as an int.\n\n@param path The Object path.\n@return The int matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Returns the integer value of the property specified by the given path.\r\n     *\r\n     * @param path the path of the property to retrieve\r\n     * @return the integer value of the property specified by the given path\r\n     */\r\n    public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } }"}, {"ID": 297, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte getByte(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Byte) { return (Byte) value; } else if (value instanceof Long) { return ((Long) value).byteValue(); } else if (value instanceof Integer) { return ((Integer) value).byteValue(); } else { return ObjectConverter.convertObjectTo(value, Byte.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a byte.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Returns the byte value of the property specified by the given path.\r\n     *\r\n     * @param path the path of the property to retrieve\r\n     * @return the byte value of the property specified by the given path\r\n     */\r\n    public byte getByte(String path) {\r\n        // implementation goes here\r\n    }"}, {"ID": 298, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a short.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Retrieves the value at the specified path as a short.\r\n     *\r\n     * @param path the path to the value to retrieve\r\n     * @return the value at the specified path as a short\r\n     */\r\n    public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } }"}, {"ID": 299, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public float getFloat(String path) { final Object value = get(path); //Groovy will always return a Double for floating point values. if (value instanceof Double) { return ((Double) value).floatValue(); } else { return ObjectConverter.convertObjectTo(value, Float.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a float.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Retrieves a float value from the configuration at the specified path.\r\n     *\r\n     * @param path the path to the value\r\n     * @return the float value at the specified path, or null if the value is not found or cannot be converted to a float\r\n     */\r\n    public float getFloat(String path) {\r\n        final Object value = get(path);\r\n        //Groovy will always return a Double for floating point values.\r\n        if (value instanceof Double) {\r\n            return ((Double) value).floatValue();\r\n        } else {\r\n            return ObjectConverter.convertObjectTo(value, Float.class);\r\n        }\r\n    }"}, {"ID": 300, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public double getDouble(String path) { final Object value = get(path); if (value instanceof Double) { return (Double) value; } return ObjectConverter.convertObjectTo(value, Double.class); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a double.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * This method retrieves a Double value from the configuration at the specified path.\r\n     * \r\n     * @param path the path to the configuration value\r\n     * @return the Double value at the specified path, or null if the value is not found or cannot be converted to a Double\r\n     */\r\n    public double getDouble(String path) {\r\n        final Object value = get(path);\r\n        if (value instanceof Double) {\r\n            return (Double) value;\r\n        }\r\n        return ObjectConverter.convertObjectTo(value, Double.class);\r\n    }"}, {"ID": 301, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a long.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Returns the value at the specified path as a long.\r\n     *\r\n     * @param path the path to the value to retrieve\r\n     * @return the value at the specified path as a long\r\n     */\r\n    public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } }"}, {"ID": 302, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> List<T> getList(String path, Class<T> genericType) { if (genericType == null) { throw new IllegalArgumentException(\"Generic type cannot be null\"); } final List<T> original = get(path); final List<T> newList = new LinkedList<T>(); if (original != null) { for (T t : original) { T e; if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) { // TODO Avoid double parsing String str = objectToString(t); //noinspection unchecked e = (T) jsonStringToObject(str, genericType); } else { e = ObjectConverter.convertObjectTo(t, genericType); } newList.add(e); } } return Collections.unmodifiableList(newList); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a list.\n\n@param path        The Object path.\n@param genericType The generic list type\n@param          The type\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Returns a list of objects of the specified generic type from the specified path in the JSON object.\r\n     *\r\n     * @param path the path to the list in the JSON object\r\n     * @param genericType the type of the objects in the list\r\n     * @return a list of objects of the specified generic type\r\n     * @throws IllegalArgumentException if the generic type is null\r\n     */\r\n    public <T> List<T> getList(String path, Class<T> genericType) {\r\n        // TODO Implement method\r\n    }"}, {"ID": 303, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> Map<K, V> getMap(String path) { return get(path); }\n\n    ### Response:", "ground_truth": "Get the result of an Object path expression as a map.\n\n@param path The Object path.\n@param   The type of the expected key\n@param   The type of the expected value\n@return The map matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": "/**\r\n     * Returns a map from the given path.\r\n     *\r\n     * @param path the path to the map\r\n     * @return the map at the given path\r\n     */\r\n    public <K, V> Map<K, V> getMap(String path) { return get(path); }"}, {"ID": 304, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); }\n\n    ### Response:", "ground_truth": "Get an XML document as a Java Object.\n\n@param objectType The type of the java object.\n@param         The type of the java object\n@return A Java object representation of the XML document", "predict": "/**\r\n     * This method retrieves an object from a given path and returns it as an instance of the specified type.\r\n     * \r\n     * @param path The path to the object to be retrieved.\r\n     * @param objectType The type of the object to be returned.\r\n     * @return An instance of the specified type representing the object at the specified path.\r\n     */\r\n    public <T> T getObject(String path, Class<T> objectType) {\r\n        Object object = getFromPath(path, false);\r\n        return getObjectAsType(object, objectType);\r\n    }"}, {"ID": 305, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\n     * Sets the body of the request using the given object and the given ObjectMapper.\n     * \n     * @param object the object to use as the request body\n     * @param mapper the ObjectMapper to use for serialization\n     * @return the updated RequestSpecBuilder object\n     */\n    public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) {\n        spec.body(object, mapper);\n        return this;\n    }"}, {"ID": 306, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { spec.cookie(key, value, cookieNameValuePairs); return this; }\n\n    ### Response:", "ground_truth": "Add a cookie to be sent with the request.\n\n@param key                  The cookie key\n@param value                The cookie value\n@param cookieNameValuePairs Additional cookies values. This will actually create two cookies with the same name but with different values.\n@return The request specification builder", "predict": "/**\n     * Adds a cookie to the request specification.\n     *\n     * @param key the name of the cookie\n     * @param value the value of the cookie\n     * @param cookieNameValuePairs additional name-value pairs to include in the cookie\n     * @return the updated request specification builder\n     */\n    public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) {\n        spec.cookie(key, value, cookieNameValuePairs);\n        return this;\n    }"}, {"ID": 307, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) { spec.param(parameterName, parameterValues); return this; }\n\n    ### Response:", "ground_truth": "Add a parameter to be sent with the request.\n\n@param parameterName   The parameter name\n@param parameterValues Zero to many parameter values for this parameter name.\n@return The request specification builder", "predict": "/**\n     * Adds a parameter to the request specification.\n     * \n     * @param parameterName the name of the parameter to add\n     * @param parameterValues the values of the parameter to add\n     * @return the updated RequestSpecBuilder object\n     */\n    public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) {\n        spec.param(parameterName, parameterValues);\n        return this;\n    }"}, {"ID": 308, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) { spec.param(parameterName, parameterValues); return this; }\n\n    ### Response:", "ground_truth": "Add a multi-value parameter to be sent with the request.\n\n@param parameterName   The parameter key\n@param parameterValues The parameter values\n@return The request specification builder", "predict": "/**\r\n     * Adds a parameter to the request specification.\r\n     * \r\n     * @param parameterName the name of the parameter to add\r\n     * @param parameterValues the values of the parameter to add\r\n     * @return the updated RequestSpecBuilder instance\r\n     */\r\n    public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) {\r\n        spec.param(parameterName, parameterValues);\r\n        return this;\r\n    }"}, {"ID": 309, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) { return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true); }\n\n    ### Response:", "ground_truth": "Set form parameter update strategy to the given value.\n\n@param updateStrategy The update strategy to use for form parameters\n@return A new instance of {@link MockMvcParamConfig}", "predict": "/**\r\n     * Sets the update strategy for form parameters.\r\n     *\r\n     * @param updateStrategy the update strategy to use for form parameters\r\n     * @return the updated MockMvcParamConfig object\r\n     */\r\n    public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) {\r\n        return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true);\r\n    }"}, {"ID": 310, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); }\n\n    ### Response:", "ground_truth": "Create a new logging filter without using the \"new\" operator.\nWill make the DSL look nicer.\n\n@param stream The print stream to log to\n@param matcher The matcher that must be fulfilled in order for logging to occur\n@return a new instance of the filter", "predict": "/**\r\n     * Creates a new instance of ResponseLoggingFilter with the given output stream and matcher.\r\n     *\r\n     * @param stream the output stream to log to\r\n     * @param matcher the matcher to use to determine which responses to log\r\n     * @return a new instance of ResponseLoggingFilter\r\n     */\r\n    public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) {\r\n        return new ResponseLoggingFilter(stream, matcher);\r\n    }"}, {"ID": 311, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Cookies(cookieList); }\n\n    ### Response:", "ground_truth": "An alternative way to create a Cookies object from the constructor.\n\n@param cookie            The cookie to be included\n@param additionalCookies Additional cookies to be included (optional)\n@return A new cookies object containing the specified cookies", "predict": "/**\r\n     * Creates a new instance of Cookies with the specified cookie and additional cookies.\r\n     * \r\n     * @param cookie the first cookie to add to the list\r\n     * @param additionalCookies additional cookies to add to the list\r\n     * @return a new instance of Cookies with the specified cookie and additional cookies\r\n     * @throws IllegalArgumentException if the cookie parameter is null\r\n     */\r\n    public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) {\r\n        AssertParameter.notNull(cookie, \"Cookie\");\r\n        final List<Cookie> cookieList = new LinkedList<Cookie>();\r\n        cookieList.add(cookie);\r\n        Collections.addAll(cookieList, additionalCookies);\r\n        return new Cookies(cookieList);\r\n    }"}, {"ID": 312, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) { synchronized (lock) { for (KeyAndSource keyAndSource : keysAndSources) { Multiset<Object> set = backingMap.get(keyAndSource.key); if (set != null) { set.remove(keyAndSource.source); if (set.isEmpty()) { backingMap.remove(keyAndSource.key); } } } } }\n\n    ### Response:", "ground_truth": "There may be multiple child injectors blacklisting a certain key so only remove the source\nthat's relevant.", "predict": "/**\r\n     * Removes the given keys and sources from the backing map if they are present and have no more sources.\r\n     *\r\n     * @param keysAndSources the keys and sources to remove\r\n     */\r\n    private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) {\r\n        synchronized (lock) {\r\n            for (KeyAndSource keyAndSource : keysAndSources) {\r\n                Multiset<Object> set = backingMap.get(keyAndSource.key);\r\n                if (set != null) {\r\n                    set.remove(keyAndSource.source);\r\n                    if (set.isEmpty()) {\r\n                        backingMap.remove(keyAndSource.key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 313, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } }\n\n    ### Response:", "ground_truth": "Indexes bindings by type.", "predict": "/**\r\n     * This method is responsible for indexing all the explicit bindings present in the current level of the state.\r\n     */\r\n    void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } }"}, {"ID": 314, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); }\n\n    ### Response:", "ground_truth": "Gets a binding implementation. First, it check to see if the parent has a binding. If the\nparent has a binding and the binding is scoped, it will use that binding. Otherwise, this\nchecks for an explicit binding. If no explicit binding is found, it looks for a just-in-time\nbinding.", "predict": "/**\n     * Returns the binding for the given key, or throws an exception if none is found.\n     *\n     * @param key the key for which to find a binding\n     * @param errors the errors object to use for error reporting\n     * @param jitType the type of just-in-time binding to create if none is found\n     * @return the binding for the given key\n     * @throws ErrorsException if no binding is found\n     */\n    public BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); }"}, {"ID": 315, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException { // Find a constant string binding. Key<String> stringKey = key.ofType(STRING_TYPE); BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey); if (stringBinding == null || !stringBinding.isConstant()) { return null; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @SuppressWarnings(\"unchecked\") String stringValue = ((InstanceBinding<String>) stringBinding).getInstance(); Object source = stringBinding.getSource(); // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type); if (converted == null) { throw errors .converterReturnedNull(stringValue, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(stringValue, source, type, typeConverterBinding, converted) .toException(); } return new ConvertedConstantBindingImpl<T>( this, key, converted, stringBinding, typeConverterBinding); } catch (ErrorsException e) { throw e; } catch (RuntimeException e) { throw errors .conversionError(stringValue, source, type, typeConverterBinding, e) .toException(); } }\n\n    ### Response:", "ground_truth": "Converts a constant string binding to the required type.\n\n@return the binding if it could be resolved, or null if the binding doesn't exist\n@throws com.google.inject.internal.ErrorsException if there was an error resolving the binding", "predict": "/**\n     * Converts a constant string binding to a constant binding of the desired type using a type converter.\n     *\n     * @param key the key for the desired type\n     * @param errors the error reporter\n     * @return the converted constant binding, or null if no matching type converter was found or the conversion failed\n     * @throws ErrorsException if an error occurs during conversion\n     */\n    private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException {"}, {"ID": 316, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if (failed) { removeFailedJitBinding(depBinding, ip); bindingFailed = true; } } else if (state.getExplicitBinding(depKey) == null) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true; } } } return bindingFailed; }\n\n    ### Response:", "ground_truth": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "predict": "/**\r\n     * Cleans up the given binding and its dependencies recursively.\r\n     * \r\n     * @param binding the binding to clean up\r\n     * @param encountered the set of keys that have already been encountered\r\n     * @return true if the binding or any of its dependencies failed to initialize\r\n     */\r\n    private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) {\r\n        boolean bindingFailed = false;\r\n        Set<Dependency<?>> deps = getInternalDependencies(binding);\r\n        for (Dependency dep : deps) {\r\n            Key<?> depKey = dep.getKey();\r\n            InjectionPoint ip = dep.getInjectionPoint();\r\n            if (encountered.add(depKey)) { // only check if we haven't looked at this key yet\r\n                BindingImpl<?> depBinding = jitBindings.get(depKey);\r\n                if (depBinding != null) { // if the binding still exists, validate\r\n                    boolean failed = cleanup(depBinding, encountered); // if children fail, we fail\r\n                    if (failed) {\r\n                        removeFailedJitBinding(depBinding"}, {"ID": 317, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) { failedJitBindings.add(binding.getKey()); jitBindings.remove(binding.getKey()); membersInjectorStore.remove(binding.getKey().getTypeLiteral()); provisionListenerStore.remove(binding); if (ip != null) { constructors.remove(ip); } }\n\n    ### Response:", "ground_truth": "Cleans up any state that may have been cached when constructing the JIT binding.", "predict": "/**\r\n     * Removes a failed JIT binding from the JIT bindings map, the members injector store, and the provision listener store.\r\n     * \r\n     * @param binding the binding to remove\r\n     * @param ip the injection point associated with the binding, or null if not known\r\n     */\r\n    private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) {\r\n        failedJitBindings.add(binding.getKey());\r\n        jitBindings.remove(binding.getKey());\r\n        membersInjectorStore.remove(binding.getKey().getTypeLiteral());\r\n        provisionListenerStore.remove(binding);\r\n        if (ip != null) {\r\n            constructors.remove(ip);\r\n        }\r\n    }"}, {"ID": 318, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) { if (binding instanceof ConstructorBindingImpl) { return ((ConstructorBindingImpl) binding).getInternalDependencies(); } else if (binding instanceof HasDependencies) { return ((HasDependencies) binding).getDependencies(); } else { return ImmutableSet.of(); } }\n\n    ### Response:", "ground_truth": "Safely gets the dependencies of possibly not initialized bindings.", "predict": "/**\r\n     * Returns the internal dependencies of the given binding.\r\n     * \r\n     * @param binding the binding to get the dependencies for\r\n     * @return the internal dependencies of the given binding\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) {\r\n        if (binding instanceof ConstructorBindingImpl) {\r\n            return ((ConstructorBindingImpl) binding).getInternalDependencies();\r\n        } else if (binding instanceof HasDependencies) {\r\n            return ((HasDependencies) binding).getDependencies();\r\n        } else {\r\n            return ImmutableSet.of();\r\n        }\r\n    }"}, {"ID": 319, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException { Class<?> rawType = key.getTypeLiteral().getRawType(); ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class); // Don't try to inject arrays or enums annotated with @ImplementedBy. if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) { throw errors.missingImplementationWithHint(key, this).toException(); } // Handle TypeLiteral<T> by binding the inner type if (rawType == TypeLiteral.class) { @SuppressWarnings(\"unchecked\") // we have to fudge the inner type as Object BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors); return binding; } // Handle @ImplementedBy if (implementedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createImplementedByBinding(key, scoping, implementedBy, errors); } // Handle @ProvidedBy. ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class); if (providedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createProvidedByBinding(key, scoping, providedBy, errors); } return ConstructorBindingImpl.create( this, key, null, /* use default constructor */ source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired); }\n\n    ### Response:", "ground_truth": "Creates a binding for an injectable type with the given scope. Looks for a scope on the type if\nnone is specified.", "predict": "/**\n     * Creates a new uninitialized binding for the given key, scoping, source, and errors.\n     *\n     * @param key the key for the binding\n     * @param scoping the scoping for the binding\n     * @param source the source of the binding\n     * @param errors the errors object to use for error reporting\n     * @param jitBinding whether to enable just-in-time binding\n     * @param <T> the type of the binding\n     * @return a new uninitialized binding for the given key, scoping, source, and errors\n     * @throws ErrorsException if there are errors during binding creation\n     */\n    public <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException {\n        // implementation omitted for brevity\n    }"}, {"ID": 320, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException { if (parameterInjectors == null) { return NO_ARGUMENTS; } int size = parameterInjectors.length; Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) { parameters[i] = parameterInjectors[i].inject(context); } return parameters; }\n\n    ### Response:", "ground_truth": "Returns an array of parameter values.", "predict": "/**\n     * Returns an array of all the parameters that can be injected for the given parameter injectors.\n     *\n     * @param context the context to use for injection\n     * @param parameterInjectors the parameter injectors to use for injection\n     * @return an array of all the parameters that can be injected for the given parameter injectors\n     * @throws InternalProvisionException if there is an error during injection\n     */\n    static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException {\n        if (parameterInjectors == null) {\n            return NO_ARGUMENTS;\n        }\n        int size = parameterInjectors.length;\n        Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) {\n            parameters[i] = parameterInjectors[i].inject(context);\n        }\n        return parameters;\n    }"}, {"ID": 321, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindInjector(InjectorImpl injector) { Key<Injector> key = Key.get(Injector.class); InjectorFactory injectorFactory = new InjectorFactory(injector); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Injector>( injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of())); }\n\n    ### Response:", "ground_truth": "The Injector is a special case because we allow both parent and child injectors to both have a\nbinding for that key.", "predict": "/**\n     * Binds the given injector to the InjectorImpl class.\n     *\n     * @param injector the injector to bind\n     */\n    private static void bindInjector(InjectorImpl injector) {\n        Key<Injector> key = Key.get(Injector.class);\n        InjectorFactory injectorFactory = new InjectorFactory(injector);\n        injector.state.putBinding(key, new ProviderInstanceBindingImpl<Injector>(injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of()));\n    }"}, {"ID": 322, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); }\n\n    ### Response:", "ground_truth": "The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this.", "predict": "/**\n     * Binds a logger instance to the injector.\n     * \n     * @param injector the injector to bind the logger to\n     */\n    private static void bindLogger(InjectorImpl injector) {\n        Key<Logger> key = Key.get(Logger.class);\n        LoggerFactory loggerFactory = new LoggerFactory();\n        injector.state.putBinding(key, new ProviderInstanceBindingImpl<Logger>(injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of()));\n    }"}, {"ID": 323, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) { Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation( errors, member, ((AnnotatedElement) member).getAnnotations()); if (misplacedBindingAnnotation == null) { return false; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if (member instanceof Method) { try { if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) { return false; } } catch (NoSuchFieldException ignore) { } } errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation); return true; }\n\n    ### Response:", "ground_truth": "Returns true if the binding annotation is in the wrong place.", "predict": "/**\n     * Checks if a member has a misplaced binding annotation.\n     *\n     * @param member the member to check\n     * @param errors the error reporter to use\n     * @return true if the member has a misplaced binding annotation, false otherwise\n     */\n    private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) {\n        Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation(errors, member, ((AnnotatedElement) member).getAnnotations());\n        if (misplacedBindingAnnotation == null) {\n            return false;\n        }\n        // don't warn about misplaced binding annotations on methods when there's a field with the same name.\n        // In Scala, fields always get accessor methods (that we need to ignore). See bug 242.\n        if (member instanceof Method) {\n            try {\n                if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) {\n                    return false;\n                }\n            } catch (NoSuchFieldException ignore) {\n            }\n        }\n        errors"}, {"ID": 324, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean overrides(Method a, Method b) { // See JLS section 8.4.8.1 int modifiers = b.getModifiers(); if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) { return true; } if (Modifier.isPrivate(modifiers)) { return false; } // b must be package-private return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage()); }\n\n    ### Response:", "ground_truth": "Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\nclass is a subclass of b's declaring class.", "predict": "/**\r\n     * Determines if method a overrides method b.\r\n     * \r\n     * @param a the method to be checked for overriding\r\n     * @param b the method to be checked for being overridden\r\n     * @return true if a overrides b, false otherwise\r\n     */\r\n    private static boolean overrides(Method a, Method b) {\r\n        // See JLS section 8.4.8.1\r\n        int modifiers = b.getModifiers();\r\n        if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\r\n            return true;\r\n        }\r\n        if (Modifier.isPrivate(modifiers)) {\r\n            return false;\r\n        }\r\n        // b must be package-private\r\n        return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage());\r\n    }"}, {"ID": 325, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initializeDelegate(MembersInjector<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); }\n\n    ### Response:", "ground_truth": "Sets the actual members injector.\n\n@throws IllegalStateException if the delegate is already set", "predict": "/**\n     * Initializes the delegate {@link MembersInjector} for the {@link Injector} to use.\n     *\n     * @param delegate the {@link MembersInjector} to use for injecting members\n     * @throws IllegalStateException if the delegate has already been initialized\n     */\n    public void initializeDelegate(MembersInjector<T> delegate) {\n        checkState(this.delegate == null, \"delegate already initialized\");\n        this.delegate = checkNotNull(delegate, \"delegate\");\n    }"}, {"ID": 326, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") final TypeLiteral<Provider<T>> providerType() { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())); }\n\n    ### Response:", "ground_truth": "Gets the type of this type's provider.", "predict": "/**\n     * Returns a TypeLiteral for a Provider of the type of this TypeLiteral.\n     *\n     * @return a TypeLiteral for a Provider of the type of this TypeLiteral\n     */\n    @SuppressWarnings(\"unchecked\")\n    final TypeLiteral<Provider<T>> providerType() {\n        return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType()));\n    }"}, {"ID": 327, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<TypeLiteral<?>> resolveAll(Type[] types) { TypeLiteral<?>[] result = new TypeLiteral<?>[types.length]; for (int t = 0; t < types.length; t++) { result[t] = resolve(types[t]); } return ImmutableList.copyOf(result); }\n\n    ### Response:", "ground_truth": "Returns an immutable list of the resolved types.", "predict": "/**\n     * Resolves all the given types to their corresponding TypeLiteral objects.\n     * \n     * @param types the types to resolve\n     * @return a list of TypeLiteral objects corresponding to the given types\n     */\n    private List<TypeLiteral<?>> resolveAll(Type[] types) {\n        TypeLiteral<?>[] result = new TypeLiteral<?>[types.length];\n        for (int t = 0; t < types.length; t++) {\n            result[t] = resolve(types[t]);\n        }\n        return ImmutableList.copyOf(result);\n    }"}, {"ID": 328, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { Type type = typeLiteral.getType(); if (!isFullySpecified(type)) { Errors errors = new Errors().keyNotFullySpecified(typeLiteral); throw new ConfigurationException(errors.getMessages()); } if (typeLiteral.getRawType() == javax.inject.Provider.class) { ParameterizedType parameterizedType = (ParameterizedType) type; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @SuppressWarnings(\"unchecked\") TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0])); return guiceProviderType; } @SuppressWarnings(\"unchecked\") TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral); if (wrappedPrimitives != null) { return wrappedPrimitives; } // If we know this isn't a subclass, return as-is. if (typeLiteral.getClass() == TypeLiteral.class) { return typeLiteral; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @SuppressWarnings(\"unchecked\") TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType()); return recreated; }\n\n    ### Response:", "ground_truth": "Returns an type that's appropriate for use in a key.\n\nIf the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a\n{@code com.google.inject.Provider} with the same type parameters.\n\nIf the type is a primitive, the corresponding wrapper type will be returned.\n\n@throws ConfigurationException if {@code type} contains a type variable", "predict": "/**\n     * Returns a canonical TypeLiteral for the given type, or throws a ConfigurationException if the type is not fully specified.\n     *\n     * @param typeLiteral the TypeLiteral to canonicalize\n     * @return a canonical TypeLiteral for the given type\n     * @throws ConfigurationException if the type is not fully specified\n     */\n    public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) {\n        Type type = typeLiteral.getType();\n        if (!isFullySpecified(type)) {\n            Errors errors = new Errors().keyNotFullySpecified(typeLiteral);\n            throw new ConfigurationException(errors.getMessages());\n        }\n        if (typeLiteral.getRawType() == javax.inject.Provider.class) {\n            ParameterizedType parameterizedType = (ParameterizedType) type;\n            // the following casts are generally unsafe, but com.google.inject.Provider extends\n            // javax.inject.Provider and is covariant\n            @SuppressWarnings(\"unchecked\")\n            TypeLiteral<T> guiceProvider"}, {"ID": 329, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \"TypeConverter<Character>\"; } }); convertToClasses( injector, Matchers.subclassesOf(Enum.class), new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { return Enum.valueOf((Class) toType.getRawType(), value); } @Override public String toString() { return \"TypeConverter<E extends Enum<E>>\"; } }); internalConvertToTypes( injector, new AbstractMatcher<TypeLiteral<?>>() { @Override public boolean matches(TypeLiteral<?> typeLiteral) { return typeLiteral.getRawType() == Class.class; } @Override public String toString() { return \"Class<?>\"; } }, new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new RuntimeException(e.getMessage()); } } @Override public String toString() { return \"TypeConverter<Class<?>>\"; } }); }\n\n    ### Response:", "ground_truth": "Installs default converters for primitives, enums, and class literals.", "predict": "/**\n     * Configure type converters for built-in types.\n     * \n     * @param injector the injector to configure\n     */\n    static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \""}, {"ID": 330, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static ClassLoader canonicalize(ClassLoader classLoader) { return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent(); }\n\n    ### Response:", "ground_truth": "Attempts to canonicalize null references to the system class loader. May return null if for\nsome reason the system loader is unavailable.", "predict": "/**\n     * Returns the canonical class loader for the specified class loader. If the specified class loader is null, the system class loader is returned.\n     *\n     * @param classLoader the class loader to be canonicalized, may be null\n     * @return the canonical class loader, never null\n     */\n    private static ClassLoader canonicalize(ClassLoader classLoader) {\n        return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent();\n    }"}, {"ID": 331, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasSameVersionOfCglib(ClassLoader classLoader) { Class<?> fc = net.sf.cglib.reflect.FastClass.class; try { return classLoader.loadClass(fc.getName()) == fc; } catch (ClassNotFoundException e) { return false; } }\n\n    ### Response:", "ground_truth": "Returns true if the types classloader has the same version of cglib that BytecodeGen has. This\nonly returns false in strange OSGI situations, but it prevents us from using FastClass for non\npublic members.", "predict": "/**\r\n     * Checks if the given class loader has the same version of Cglib as the current class loader.\r\n     *\r\n     * @param classLoader the class loader to check\r\n     * @return true if the class loader has the same version of Cglib as the current class loader, false otherwise\r\n     */\r\n    private static boolean hasSameVersionOfCglib(ClassLoader classLoader) {\r\n        Class<?> fc = net.sf.cglib.reflect.FastClass.class;\r\n        try {\r\n            return classLoader.loadClass(fc.getName()) == fc;\r\n        } catch (ClassNotFoundException e) {\r\n            return false;\r\n        }\r\n    }"}, {"ID": 332, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean isPubliclyCallable(Member member) { if (!Modifier.isPublic(member.getModifiers())) { return false; } Class<?>[] parameterTypes; if (member instanceof Constructor) { parameterTypes = ((Constructor) member).getParameterTypes(); } else { Method method = (Method) member; if (!Modifier.isPublic(method.getReturnType().getModifiers())) { return false; } parameterTypes = method.getParameterTypes(); } for (Class<?> type : parameterTypes) { if (!Modifier.isPublic(type.getModifiers())) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Returns true if the member can be called by a fast class generated in a different classloader.", "predict": "/**\r\n     * Checks if a given member is publicly callable.\r\n     * \r\n     * @param member the member to check\r\n     * @return true if the member is publicly callable, false otherwise\r\n     */\r\n    private static boolean isPubliclyCallable(Member member) {\r\n        // implementation goes here\r\n    }"}, {"ID": 333, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); }\n\n    ### Response:", "ground_truth": "Replace annotation instances with annotation types, this is only appropriate for testing if a\nkey is bound and not for injecting.\n\n", "predict": "/**\r\n     * This method takes a Key object and returns a new Key object with the same type but with the annotation fixed.\r\n     * \r\n     * @param key The Key object to be fixed.\r\n     * @return A new Key object with the same type as the input Key object but with the annotation fixed.\r\n     */\r\n    public Key<?> fixAnnotations(Key<?> key) {\r\n        return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType());\r\n    }"}, {"ID": 334, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> Initializable<T> requestInjection( InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Member injection could not be requested after validation is started\"); ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding); // short circuit if the object has no injections or listeners. if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return Initializables.of(instance); } if (initializablesCache.containsKey(instance)) { @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T> Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance); return cached; } InjectableReference<T> injectableReference = new InjectableReference<T>( injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass())); initializablesCache.put(instance, injectableReference); pendingInjections.add(injectableReference); return injectableReference; }\n\n    ### Response:", "ground_truth": "Registers an instance for member injection when that step is performed.\n\n@param instance an instance that optionally has members to be injected (each annotated\nwith @Inject).\n@param binding the binding that caused this initializable to be created, if it exists.\n@param source the source location that this injection was requested", "predict": "/**\n     * Requests injection for the given instance, binding, source, and injection points.\n     *\n     * @param injector the injector to use for injection\n     * @param instance the instance to inject\n     * @param binding the binding to use for injection, or null if the instance is not bound\n     * @param source the source of the injection request\n     * @param injectionPoints the injection points to use for injection\n     * @return an initializable reference that can be used to inject the instance\n     */\n    public Initializable<T> requestInjection(InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) {\n        // implementation omitted for brevity\n    }"}, {"ID": 335, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } }\n\n    ### Response:", "ground_truth": "Prepares member injectors for all injected instances. This prompts Guice to do static analysis\non the injected instances.", "predict": "/**\n     * Validates all pending injections and merges any validation errors into the given errors object.\n     * \n     * @param errors the errors object to merge validation errors into\n     */\n    void validateOustandingInjections(Errors errors) {\n        // implementation details elided\n    }"}, {"ID": 336, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T newInstance(Object[] args) throws Throwable { constructor.setAccessible(true); try { return constructor.newInstance(args); } catch (InvocationTargetException e) { throw e.getCause(); } }\n\n    ### Response:", "ground_truth": "Returns an instance of T, constructed using this constructor, with the supplied arguments.", "predict": "/**\r\n     * Creates a new instance of the class represented by this {@code Constructor} object.\r\n     * The class is instantiated as if by calling the constructor represented by this object,\r\n     * with the specified array of object arguments.\r\n     *\r\n     * @param args an array of objects that are the arguments to the constructor call\r\n     * @return a new instance of the class represented by this object\r\n     * @throws Throwable if the class or constructor throws an exception\r\n     */\r\n    public T newInstance(Object[] args) throws Throwable {\r\n        constructor.setAccessible(true);\r\n        try {\r\n            return constructor.newInstance(args);\r\n        } catch (InvocationTargetException e) {\r\n            throw e.getCause();\r\n        }\r\n    }"}, {"ID": 337, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"JavaDoc\", \"deprecation\"}) private ServletRequest withDispatcher( ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if (!servletPipeline.hasServletsMapped()) { return servletRequest; } HttpServletRequest request = (HttpServletRequest) servletRequest; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper(request) { @Override public RequestDispatcher getRequestDispatcher(String path) { final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path); return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path); } }; }\n\n    ### Response:", "ground_truth": "Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular\npipeline based on uri-path match. This proxy also provides minimal forwarding support.\n\nWe cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline\nis not called again). However, we can wrap requests with our own dispatcher to forward the\n*other* way. web.xml Servlets/JSPs can forward to themselves as per normal.\n\nThis is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,\nincrementally, but not the other way around (which, we should actively discourage).", "predict": "/**\r\n     * This method is responsible for wrapping the incoming request with a custom implementation of the {@link javax.servlet.ServletRequest} interface.\r\n     * \r\n     * @param servletRequest the incoming request object\r\n     * @param servletPipeline the {@link ManagedServletPipeline} object that manages the mapping of servlets to requests\r\n     * @return the wrapped request object\r\n     */\r\n    private ServletRequest withDispatcher(ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) {\r\n        // don't wrap the request if there are no servlets mapped. This prevents us from inserting our wrapper unless it's actually going to be used. This is necessary for compatibility for apps that downcast their HttpServletRequests to a concrete implementation.\r\n        if (!servletPipeline.hasServletsMapped()) {\r\n            return servletRequest;\r\n        }\r\n\r\n        //noinspection OverlyComplexAnonymousInnerClass\r\n        return new HttpServletRequestWrapper((HttpServletRequest) servletRequest) {\r\n            @Override\r\n            public RequestDispatcher getRequestDispatcher(String path) {\r\n                final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path);\r\n                return ("}, {"ID": 338, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> InternalFactory<? extends T> scope( Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) { if (scoping.isNoScope()) { return creator; } Scope scope = scoping.getScopeInstance(); // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here. If you change the type make sure to update // SingletonScope as well. Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)); return new InternalFactoryToProviderAdapter<T>(scoped, source); }\n\n    ### Response:", "ground_truth": "Scopes an internal factory.", "predict": "/**\n     * Creates a scoped provider for the given key and creator.\n     *\n     * @param key the key for which to create a scoped provider\n     * @param injector the injector to use for creating the scoped provider\n     * @param creator the creator for the key\n     * @param source the source of the binding\n     * @param scoping the scoping strategy to use for the provider\n     * @param <T> the type of the instance provided by the provider\n     * @return a scoped provider for the given key and creator\n     */\n    public static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) {\n        if (scoping.isNoScope()) {\n            return creator;\n        }\n        Scope scope = scoping.getScopeInstance();\n        // NOTE: SingletonScope relies on the fact that we are passing a\n        // ProviderToInternalFactoryAdapter here. If you change the type make sure\n        // to update"}, {"ID": 339, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) { Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation(); if (scopeAnnotation == null) { return scoping; } ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation); if (scope != null) { return forInstance(scope.getScope()); } errors.scopeNotFound(scopeAnnotation); return UNSCOPED; }\n\n    ### Response:", "ground_truth": "Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance\nmap. If the scope annotation has no corresponding instance, an error will be added and unscoped\nwill be retuned.", "predict": "/**\n     * Creates a new {@link Scoping} instance that wraps the given instance in the specified scope.\n     *\n     * @param scoping the {@link Scoping} instance to wrap the instance in\n     * @param injector the {@link InjectorImpl} instance to use for creating the scope\n     * @param errors the {@link Errors} instance to use for error reporting\n     * @return a new {@link Scoping} instance that wraps the given instance in the specified scope, or the original {@link Scoping} instance if the scope is not found\n     */\n    static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) {\n        // implementation omitted for brevity\n    }"}, {"ID": 340, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static String normalizePath(String path) { StringBuilder sb = new StringBuilder(path.length()); int queryStart = path.indexOf('?'); String query = null; if (queryStart != -1) { query = path.substring(queryStart); path = path.substring(0, queryStart); } // Normalize the path. we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List<String> segments = new ArrayList<>(); for (String segment : SLASH_SPLITTER.split(path)) { // This decodes all non-special characters from the path segment. so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false)); if (\".\".equals(normalized)) { // skip } else if (\"..\".equals(normalized)) { if (segments.size() > 1) { segments.remove(segments.size() - 1); } } else { segments.add(normalized); } } SLASH_JOINER.appendTo(sb, segments); if (query != null) { sb.append(query); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Normalizes a path by unescaping all safe, percent encoded characters.", "predict": "/**\n     * Normalizes a path by decoding percent-encoded characters, interpreting dangerous character sequences, and preserving encoded characters.\n     *\n     * @param path the path to normalize\n     * @return the normalized path\n     */\n    static String normalizePath(String path) {\n        // TODO: implement method\n    }"}, {"ID": 341, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); }\n\n    ### Response:", "ground_truth": "Generates an Annotation for the annotation class. Requires that the annotation is all\noptionals.", "predict": "/**\r\n     * Generates an annotation of the specified type.\r\n     *\r\n     * @param annotationType the type of the annotation to generate\r\n     * @param <T> the type of the annotation to generate\r\n     * @return the generated annotation\r\n     * @throws IllegalStateException if the annotation type is not all default methods\r\n     */\r\n    public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) {\r\n        Preconditions.checkState(isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType);\r\n        return (T) cache.getUnchecked(annotationType);\r\n    }"}, {"ID": 342, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) { Retention retention = annotationType.getAnnotation(Retention.class); return retention != null && retention.value() == RetentionPolicy.RUNTIME; }\n\n    ### Response:", "ground_truth": "Returns true if the given annotation is retained at runtime.", "predict": "/**\r\n     * Determines if the given annotation type is retained at runtime.\r\n     * \r\n     * @param annotationType the annotation type to check\r\n     * @return true if the annotation is retained at runtime, false otherwise\r\n     */\r\n    public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) {\r\n        Retention retention = annotationType.getAnnotation(Retention.class);\r\n        return retention != null && retention.value() == RetentionPolicy.RUNTIME;\r\n    }"}, {"ID": 343, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<? extends Annotation> findScopeAnnotation( Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; }\n\n    ### Response:", "ground_truth": "Returns the scoping annotation, or null if there isn't one.", "predict": "/**\r\n     * Finds the first annotation in the given array that is a scope annotation.\r\n     *\r\n     * @param errors the errors object to use for error reporting\r\n     * @param annotations the array of annotations to search\r\n     * @return the annotation type of the first scope annotation found, or null if none were found\r\n     */\r\n    public static Class<? extends Annotation> findScopeAnnotation(Errors errors, Annotation[] annotations) {\r\n        Class<? extends Annotation> found = null;\r\n        for (Annotation annotation : annotations) {\r\n            Class<? extends Annotation> annotationType = annotation.annotationType();\r\n            if (isScopeAnnotation(annotationType)) {\r\n                if (found != null) {\r\n                    errors.duplicateScopeAnnotations(found, annotationType);\r\n                } else {\r\n                    found = annotationType;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    }"}, {"ID": 344, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); }\n\n    ### Response:", "ground_truth": "Gets a key for the given type, member and annotations.", "predict": "/**\r\n     * Returns a key for the given type, member, and annotations.\r\n     * \r\n     * @param type the type literal for which to get a key\r\n     * @param member the member for which to get a key\r\n     * @param annotations the annotations to use for binding\r\n     * @param errors the errors object to use for error reporting\r\n     * @return a key for the given type, member, and annotations\r\n     * @throws ErrorsException if there are errors during key creation\r\n     */\r\n    public static Key<?> getKey(TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException {\r\n        int numErrorsBefore = errors.size();\r\n        Annotation found = findBindingAnnotation(errors, member, annotations);\r\n        errors.throwIfNewErrors(numErrorsBefore);\r\n        return found == null ? Key.get(type) : Key.get(type, found);\r\n    }"}, {"ID": 345, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } }\n\n    ### Response:", "ground_truth": "Returns the name the binding should use. This is based on the annotation. If the annotation has\nan instance and is not a marker annotation, we ask the annotation for its toString. If it was a\nmarker annotation or just an annotation type, we use the annotation's name. Otherwise, the name\nis the empty string.", "predict": "/**\r\n     * Returns the name of the annotation associated with the given key.\r\n     * \r\n     * @param key the key to get the annotation name for\r\n     * @return the name of the annotation associated with the given key, or an empty string if no annotation is associated or the annotation is a marker annotation\r\n     */\r\n    public static String nameOf(Key<?> key) {\r\n        Annotation annotation = key.getAnnotation();\r\n        Class<? extends Annotation> annotationType = key.getAnnotationType();\r\n        if (annotation != null && !isMarker(annotationType)) {\r\n            return key.getAnnotation().toString();\r\n        } else if (key.getAnnotationType() != null) {\r\n            return \"@\" + key.getAnnotationType().getName();\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }"}, {"ID": 346, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); }\n\n    ### Response:", "ground_truth": "Sets the actual provider.\n\n@throws IllegalStateException if the delegate is already set", "predict": "/**\n     * Initializes the delegate provider.\n     *\n     * @param delegate the delegate provider\n     * @throws IllegalStateException if the delegate is already initialized\n     * @throws NullPointerException if the delegate is null\n     */\n    public void initializeDelegate(Provider<T> delegate) {\n        checkState(this.delegate == null, \"delegate already initialized\");\n        this.delegate = checkNotNull(delegate, \"delegate\");\n    }"}, {"ID": 347, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); }\n\n    ### Response:", "ground_truth": "Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate\nbindings.", "predict": "/**\r\n     * Binds a direct type binding to the specified key using the specified provider.\r\n     *\r\n     * @param binder the binder to use for binding\r\n     */\r\n    private void addDirectTypeBinding(Binder binder) {\r\n        binder.bind(bindingSelection.getDirectKey())\r\n                .toProvider(new RealDirectTypeProvider<T>(bindingSelection));\r\n    }"}, {"ID": 348, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); }\n\n    ### Response:", "ground_truth": "Returns a new complete constructor injector with injection listeners registered.", "predict": "/**\n     * Returns the cached instance of the {@link ConstructorInjector} for the given {@link InjectionPoint} and {@link Errors}.\n     *\n     * @param constructorInjector the {@link InjectionPoint} for which to retrieve the cached {@link ConstructorInjector}\n     * @param errors the {@link Errors} object to use for error reporting\n     * @return the cached instance of the {@link ConstructorInjector} for the given {@link InjectionPoint} and {@link Errors}\n     * @throws ErrorsException if there are any errors during the retrieval of the cached {@link ConstructorInjector}\n     */\n    public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException;"}, {"ID": 349, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasScope(Class<? extends Interceptor> interceptorClass) { for (Annotation annotation : interceptorClass.getAnnotations()) { if (Annotations.isScopeAnnotation(annotation.annotationType())) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Returns true if the given class has a scope annotation.", "predict": "/**\r\n     * Checks if the given interceptor class has a scope annotation.\r\n     * \r\n     * @param interceptorClass the interceptor class to check\r\n     * @return true if the interceptor class has a scope annotation, false otherwise\r\n     */\r\n    private static boolean hasScope(Class<? extends Interceptor> interceptorClass) {\r\n        for (Annotation annotation : interceptorClass.getAnnotations()) {\r\n            if (Annotations.isScopeAnnotation(annotation.annotationType())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 350, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <K, V> RealMapBinder<K, V> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) { binder = binder.skipSources(RealMapBinder.class); TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral(); return newRealMapBinder( binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder( binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType)))); }\n\n    ### Response:", "ground_truth": "since it's an easy way to group a type and an optional annotation type or instance.", "predict": "/**\n     * Creates a new {@link RealMapBinder} that collects implementations of a map with the specified key and value types.\n     *\n     * @param binder the binder to which the new map binder will be added\n     * @param keyType the type of the keys in the map\n     * @param valueTypeAndAnnotation the type of the values in the map and the annotation used to identify the value type\n     * @return a new {@link RealMapBinder}\n     */\n    public static <K, V> RealMapBinder<K, V> newRealMapBinder(Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) {\n        binder = binder.skipSources(RealMapBinder.class);\n        TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral();\n        return newRealMapBinder(binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)),\n                RealMultibinder.newRealSetBinder(binder,"}, {"ID": 351, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Key<V> getKeyForNewValue(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey)); return valueKey; }\n\n    ### Response:", "ground_truth": "Adds a binding to the map for the given key.", "predict": "/**\n     * Returns a new key for a new value that will be bound to the given key.\n     *\n     * @param key the key for which a new value will be bound\n     * @return a new key for the new value\n     * @throws NullPointerException if key is null\n     * @throws IllegalStateException if the MapBinder has already been initialized\n     */\n    public Key<V> getKeyForNewValue(K key) {\n        // implementation omitted for brevity\n    }"}, {"ID": 352, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return t; } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor(cause) .addSource(constructionProxy.getInjectionPoint()); } finally { constructionContext.removeCurrentReference(); } }\n\n    ### Response:", "ground_truth": "Provisions a new T.", "predict": "/**\n     * Provisions an instance of {@code T} using the given {@code context} and {@code constructionContext}.\n     *\n     * @param context the context to use for provision\n     * @param constructionContext the construction context to use for provision\n     * @return the provisioned instance\n     * @throws InternalProvisionException if an error occurs during provision\n     */\n    private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException {\n        try {\n            T t;\n            try {\n                Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors);\n                t = constructionProxy.newInstance(parameters);\n                constructionContext.setProxyDelegates(t);\n            } finally {\n                constructionContext.finishConstruction();\n            }\n            // Store reference. If an injector re-enters this factory, they'll get the same reference.\n            constructionContext.setCurrentReference(t);\n            MembersInjectorImpl<T> localMembersInjector = membersInjector;\n            localMembersInjector.injectMembers(t, context, false"}, {"ID": 353, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object writeReplace() throws ObjectStreamException { Object[] sourcesAsStrings = sources.toArray(); for (int i = 0; i < sourcesAsStrings.length; i++) { sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString(); } return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause); }\n\n    ### Response:", "ground_truth": "When serialized, we eagerly convert sources to strings. This hurts our formatting, but it\nguarantees that the receiving end will be able to read the message.", "predict": "/**\r\n     * Returns a replacement object for the current object.\r\n     *\r\n     * This method is called when an object is written to an ObjectOutputStream.\r\n     * It returns a replacement object that will be written to the stream instead of the original object.\r\n     *\r\n     * @return a replacement object for the current object.\r\n     * @throws ObjectStreamException if an error occurs while creating the replacement object.\r\n     */\r\n    private Object writeReplace() throws ObjectStreamException {\r\n        Object[] sourcesAsStrings = sources.toArray();\r\n        for (int i = 0; i < sourcesAsStrings.length; i++) {\r\n            sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString();\r\n        }\r\n        return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause);\r\n    }"}, {"ID": 354, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Module forModule(Module module) { // avoid infinite recursion, since installing a module always installs itself if (module instanceof CheckedProviderMethodsModule) { return Modules.EMPTY_MODULE; } return new CheckedProviderMethodsModule(module); }\n\n    ### Response:", "ground_truth": "Returns a module which creates bindings for provider methods from the given module.", "predict": "/**\n     * Returns a module that wraps the given module, but only if it is not already a CheckedProviderMethodsModule. This is to avoid infinite recursion, since installing a module always installs itself.\n     */\n    static Module forModule(Module module) {\n        if (module instanceof CheckedProviderMethodsModule) {\n            return Modules.EMPTY_MODULE;\n        }\n        return new CheckedProviderMethodsModule(module);\n    }"}, {"ID": 355, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings(\"unchecked\") public Collection<AssistedMethod> getAssistedMethods() { return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values(); }\n\n    ### Response:", "ground_truth": "the collection is immutable.", "predict": "/**\r\n     * Returns a collection of all the AssistedMethods in this object.\r\n     *\r\n     * @return a collection of all the AssistedMethods in this object\r\n     */\r\n    @Override\r\n    @SuppressWarnings(\"unchecked\")\r\n    public Collection<AssistedMethod> getAssistedMethods() {\r\n        return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values();\r\n    }"}, {"ID": 356, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) { Collection<Message> messages = ce.getErrorMessages(); if (messages.size() == 1) { Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages()); return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage()); } else { return false; } }\n\n    ### Response:", "ground_truth": "Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully\nspecified.", "predict": "/**\r\n     * Checks if the given type literal is not specified in the given configuration exception.\r\n     * \r\n     * @param typeLiteral the type literal to check\r\n     * @param ce the configuration exception to check\r\n     * @return true if the type literal is not specified in the configuration exception, false otherwise\r\n     */\r\n    private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) {\r\n        Collection<Message> messages = ce.getErrorMessages();\r\n        if (messages.size() == 1) {\r\n            Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages());\r\n            return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage());\r\n        } else {\r\n            return false;\r\n        }\r\n    }"}, {"ID": 357, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean constructorHasMatchingParams( TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException { List<TypeLiteral<?>> params = type.getParameterTypes(constructor); Annotation[][] paramAnnotations = constructor.getParameterAnnotations(); int p = 0; List<Key<?>> constructorKeys = Lists.newArrayList(); for (TypeLiteral<?> param : params) { Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors); constructorKeys.add(paramKey); } // Require that every key exist in the constructor to match up exactly. for (Key<?> key : paramList) { // If it didn't exist in the constructor set, we can't use it. if (!constructorKeys.remove(key)) { return false; } } // If any keys remain and their annotation is Assisted, we can't use it. for (Key<?> key : constructorKeys) { if (key.getAnnotationType() == Assisted.class) { return false; } } // All @Assisted params match up to the method's parameters. return true; }\n\n    ### Response:", "ground_truth": "Matching logic for constructors annotated with AssistedInject. This returns true if and only if\nall @Assisted parameters in the constructor exactly match (in any order) all @Assisted\nparameters the method's parameter.", "predict": "/**\n     * Checks if the given constructor has a matching set of parameters to the given list of keys.\n     *\n     * @param type the type that the constructor belongs to\n     * @param constructor the constructor to check\n     * @param paramList the list of keys to match up to the constructor's parameters\n     * @param errors the errors object to use for error reporting\n     * @return true if the constructor has a matching set of parameters, false otherwise\n     * @throws ErrorsException if there are errors during annotation processing\n     */\n    private boolean constructorHasMatchingParams(TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException {\n        List<TypeLiteral<?>> params = type.getParameterTypes(constructor);\n        Annotation[][] paramAnnotations = constructor.getParameterAnnotations();\n        int p = 0;\n        List<Key<?>> constructorKeys = Lists.newArrayList();\n        for (TypeLiteral<?> param : params) {\n            Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors"}, {"ID": 358, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); builder.addAll(ctorPoint.getDependencies()); if (!implementation.getRawType().isInterface()) { for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) { builder.addAll(ip.getDependencies()); } } return builder.build(); }\n\n    ### Response:", "ground_truth": "Calculates all dependencies required by the implementation and constructor.", "predict": "/**\r\n     * Returns the dependencies of the constructor and all instance methods and fields of the implementation type.\r\n     * \r\n     * @param ctorPoint the constructor injection point\r\n     * @param implementation the implementation type\r\n     * @return the set of dependencies\r\n     */\r\n    private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) {\r\n        ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();\r\n        builder.addAll(ctorPoint.getDependencies());\r\n        if (!implementation.getRawType().isInterface()) {\r\n            for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) {\r\n                builder.addAll(ip.getDependencies());\r\n            }\r\n        }\r\n        return builder.build();\r\n    }"}, {"ID": 359, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); for (Dependency<?> dep : deps) { Class<?> annotationType = dep.getKey().getAnnotationType(); if (annotationType == null || !annotationType.equals(Assisted.class)) { builder.add(dep); } } return builder.build(); }\n\n    ### Response:", "ground_truth": "Return all non-assisted dependencies.", "predict": "/**\r\n     * Removes any dependencies that are annotated with Assisted.\r\n     * \r\n     * @param deps the set of dependencies to filter\r\n     * @return the filtered set of dependencies\r\n     */\r\n    private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) {\r\n        ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder();\r\n        for (Dependency<?> dep : deps) {\r\n            Class<?> annotationType = dep.getKey().getAnnotationType();\r\n            if (annotationType == null || !annotationType.equals(Assisted.class)) {\r\n                builder.add(dep);\r\n            }\r\n        }\r\n        return builder.build();\r\n    }"}, {"ID": 360, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { Set<Dependency<?>> badDeps = null; // optimization: create lazily for (Dependency<?> dep : dependencies) { if (isInjectorOrAssistedProvider(dep)) { if (badDeps == null) { badDeps = Sets.newHashSet(); } badDeps.add(dep); } } if (badDeps != null && !badDeps.isEmpty()) { logger.log( Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!) \" + \"The exact offending deps are: {2}\", new Object[] {factoryType, implementation, badDeps}); return false; } return true; }\n\n    ### Response:", "ground_truth": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "predict": "/**\n     * Checks if the given set of dependencies is valid for optimized assisted inject.\n     *\n     * @param dependencies the set of dependencies to check\n     * @param implementation the implementation class for the factory\n     * @param factoryType the type of the factory\n     * @return true if the dependencies are valid, false otherwise\n     */\n    private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { }"}, {"ID": 361, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey).toProvider(Providers.of(args[p++])); } } else { for (Key<?> paramKey : data.paramTypes) { // Bind to our ThreadLocalProviders. binder.bind((Key) paramKey).toProvider(data.providers.get(p++)); } } Constructor constructor = data.constructor; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if (constructor != null) { binder .bind(returnKey) .toConstructor(constructor, (TypeLiteral) data.implementationType) .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type } } }; Injector forCreate = injector.createChildInjector(assistedModule); Binding<?> binding = forCreate.getBinding(returnKey); // If we have providers cached in data, cache the binding for future optimizations. if (data.optimized) { data.cachedBinding = binding; } return binding; }\n\n    ### Response:", "ground_truth": "Creates a child injector that binds the args, and returns the binding for the method's result.", "predict": "/**\n     * Returns a binding for the given method and arguments, using a new injector created with the given data.\n     *\n     * @param method the method to bind\n     * @param args the arguments to bind\n     * @param data the AssistData to use for binding\n     * @return the binding for the given method and arguments\n     */\n    public Binding<?> getBindingFromNewInjector(final Method method, final Object[] args, final AssistData data) {\n        checkState(injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\");\n        final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation.\n        final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION);\n        Module assistedModule = new AbstractModule() {\n            @Override\n            @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // raw keys are necessary for the args array and return value\n            protected void configure() {\n                Binder binder = binder().withSource(method"}, {"ID": 362, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if (methodHandleByMethod.containsKey(method)) { return methodHandleByMethod.get(method).invokeWithArguments(args); } if (method.getDeclaringClass().equals(Object.class)) { if (\"equals\".equals(method.getName())) { return proxy == args[0]; } else if (\"hashCode\".equals(method.getName())) { return System.identityHashCode(proxy); } else { return method.invoke(this, args); } } AssistData data = assistDataByMethod.get(method); checkState(data != null, \"No data for method: %s\", method); Provider<?> provider; if (data.cachedBinding != null) { // Try to get optimized form... provider = data.cachedBinding.getProvider(); } else { provider = getBindingFromNewInjector(method, args, data).getProvider(); } try { int p = 0; for (ThreadLocalProvider tlp : data.providers) { tlp.set(args[p++]); } return provider.get(); } catch (ProvisionException e) { // if this is an exception declared by the factory method, throw it as-is if (e.getErrorMessages().size() == 1) { Message onlyError = getOnlyElement(e.getErrorMessages()); Throwable cause = onlyError.getCause(); if (cause != null && canRethrow(method, cause)) { throw cause; } } throw e; } finally { for (ThreadLocalProvider tlp : data.providers) { tlp.remove(); } } }\n\n    ### Response:", "ground_truth": "When a factory method is invoked, we create a child injector that binds all parameters, then\nuse that to get an instance of the return type.", "predict": "/**\r\n * This method is invoked by the java runtime when a method is called on a proxy instance.\r\n * \r\n * @param proxy the proxy instance that the method was called on\r\n * @param method the method that was called\r\n * @param args the arguments passed to the method\r\n * @return the result of the method call\r\n * @throws Throwable if an exception occurs during the method call\r\n */\r\n@Override\r\npublic Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\r\n    // If we setup a method handle earlier for this method, call it.\r\n    // This is necessary for default methods that java8 creates, so we\r\n    // can call the default method implementation (and not our proxied version of it).\r\n    if (methodHandleByMethod.containsKey(method)) {\r\n        return methodHandleByMethod.get(method).invokeWithArguments(args);\r\n    }\r\n\r\n    // If the method is declared by Object, handle some special cases\r\n    if (method.getDeclaringClass().equals(Object"}, {"ID": 363, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb.append(format(\"%n * %s\", sameTypes.get(i).getKey())); } int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED; if (remaining > 0) { String plural = (remaining == 1) ? \"\" : \"s\"; sb.append(format(\"%n %d more binding%s with other annotations.\", remaining, plural)); } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type.toString(); Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings(); for (Key<?> bindingKey : bindingMap.keySet()) { String have = bindingKey.getTypeLiteral().toString(); if (have.contains(want) || want.contains(have)) { Formatter fmt = new Formatter(); Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource()); String match = String.format(\"%s bound%s\", convert(bindingKey), fmt.toString()); possibleMatches.add(match); // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) { // Early exit if we have found more than we need. break; } } } if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) { sb.append(format(\"%n Did you mean?\")); for (String possibleMatch : possibleMatches) { sb.append(format(\"%n %s\", possibleMatch)); } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotation() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) { // We don't recommend using such simple types without annotations. sb.append(format(\"%nThe key seems very generic, did you forget an annotation?\")); } return addMessage(sb.toString()); }\n\n    ### Response:", "ground_truth": "Within guice's core, allow for better missing binding messages", "predict": "/**\n     * This method is responsible for generating an error message when an implementation is missing for a given key. It first checks for other keys that may have the same type, but not the same annotation. If it finds any, it suggests them as possible solutions. If it doesn't find any, it then checks for other keys that have similar strings as the desired key. If it finds any, it suggests them as possible solutions. If it doesn't find any, it checks if the key is missing an annotation and suggests that as a possible solution. If it doesn't find any, it suggests that the key is very generic and suggests that an annotation may be missing.\n     * \n     * @param key The key for which an implementation is missing.\n     * @param injector The injector that is being used to find the implementation.\n     * @return An error message that can be used to indicate that an implementation is missing for the given key.\n     */\n    public static <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) {\n       "}, {"ID": 364, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); RealMultibinder<T> result = new RealMultibinder<>(binder, key); binder.install(result); return result; }\n\n    ### Response:", "ground_truth": "Implementation of newSetBinder.", "predict": "/**\r\n     * Creates a new {@link RealMultibinder} for the given key and installs it in the given binder.\r\n     *\r\n     * @param binder the binder to install the new multibinder in\r\n     * @param key the key to bind the multibinder to\r\n     * @param <T> the type of the set elements\r\n     * @return the new multibinder\r\n     */\r\n    public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) {\r\n        binder = binder.skipSources(RealMultibinder.class);\r\n        RealMultibinder<T> result = new RealMultibinder<>(binder, key);\r\n        binder.install(result);\r\n        return result;\r\n    }"}, {"ID": 365, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Key<T> getKeyForNewItem() { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Key.get( bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\")); }\n\n    ### Response:", "ground_truth": "Adds a new entry to the set and returns the key for it.", "predict": "/**\r\n     * Returns a new key for a new item in the multibinder.\r\n     *\r\n     * @return a new key for a new item in the multibinder\r\n     */\r\n    public Key<T> getKeyForNewItem() {\r\n        checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\");\r\n        return Key.get(bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\"));\r\n    }"}, {"ID": 366, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Filter findNextFilter(HttpServletRequest request) { while (++index < filterDefinitions.length) { Filter filter = filterDefinitions[index].getFilterIfMatching(request); if (filter != null) { return filter; } } return null; }\n\n    ### Response:", "ground_truth": "Iterates over the remaining filter definitions. Returns the first applicable filter, or null if\nnone apply.", "predict": "/**\r\n     * Finds the next filter in the filter chain that matches the given request.\r\n     * \r\n     * @param request\r\n     *            the current request\r\n     * @return the next filter in the chain that matches the request, or null if no match is found\r\n     */\r\n    private Filter findNextFilter(HttpServletRequest request) {\r\n        while (++index < filterDefinitions.length) {\r\n            Filter filter = filterDefinitions[index].getFilterIfMatching(request);\r\n            if (filter != null) {\r\n                return filter;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 367, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean hasAtInject(Constructor cxtor) { return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class); }\n\n    ### Response:", "ground_truth": "Returns true if the inject annotation is on the constructor.", "predict": "/**\n     * Checks if the given constructor has the @Inject or javax.inject.Inject annotation.\n     * \n     * @param cxtor the constructor to check\n     * @return true if the constructor has the annotation, false otherwise\n     */\n    private static boolean hasAtInject(Constructor cxtor) {\n        return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class);\n    }"}, {"ID": 368, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    InjectionPoint getInternalConstructor() { if (factory.constructorInjector != null) { return factory.constructorInjector.getConstructionProxy().getInjectionPoint(); } else { return constructorInjectionPoint; } }\n\n    ### Response:", "ground_truth": "Returns an injection point that can be used to clean up the constructor store.", "predict": "/**\r\n     * Returns the internal constructor injection point.\r\n     * \r\n     * @return the internal constructor injection point\r\n     */\r\n    public InjectionPoint getInternalConstructor() {\r\n        if (factory.constructorInjector != null) {\r\n            return factory.constructorInjector.getConstructionProxy().getInjectionPoint();\r\n        } else {\r\n            return constructorInjectionPoint;\r\n        }\r\n    }"}, {"ID": 369, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Set<Dependency<?>> getInternalDependencies() { ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder(); if (factory.constructorInjector == null) { builder.add(constructorInjectionPoint); // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder.addAll( InjectionPoint.forInstanceMethodsAndFields( constructorInjectionPoint.getDeclaringType())); } catch (ConfigurationException ignored) { } } else { builder.add(getConstructor()).addAll(getInjectableMembers()); } return Dependency.forInjectionPoints(builder.build()); }\n\n    ### Response:", "ground_truth": "Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.", "predict": "/**\r\n     * Returns the internal dependencies of this component. Internal dependencies are dependencies that are declared within the component's implementation, and are not provided by any external dependencies.\r\n     * \r\n     * @return the internal dependencies of this component\r\n     */\r\n    Set<Dependency<?>> getInternalDependencies();"}, {"ID": 370, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) { return forObject(module, false, scanner); }\n\n    ### Response:", "ground_truth": "Returns a module which creates bindings methods in the module that match the scanner.", "predict": "/**\n     * Returns a Module object for the given module object.\n     * \n     * @param module the module object to create a Module for\n     * @param scanner the ModuleAnnotatedMethodScanner to use for scanning the module\n     * @return a Module object for the given module object\n     */\n    public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) {\n        return forObject(module, false, scanner);\n    }"}, {"ID": 371, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; }\n\n    ### Response:", "ground_truth": "Returns the annotation that is claimed by the scanner, or null if there is none.", "predict": "/**\r\n     * Retrieves the annotation of the given method that is claimed by the given scanner.\r\n     *\r\n     * @param binder the binder to use for error reporting\r\n     * @param method the method to search for annotations on\r\n     * @return the annotation that is claimed by the scanner, or null if none is found\r\n     */\r\n    private Annotation getAnnotation(Binder binder, Method method) {\r\n        if (method.isBridge() || method.isSynthetic()) {\r\n            return null;\r\n        }\r\n        Annotation annotation = null;\r\n        for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) {\r\n            Annotation foundAnnotation = method.getAnnotation(annotationClass);\r\n            if (foundAnnotation != null) {\r\n                if (annotation != null) {\r\n                    binder.addError(\r\n                            \"More than one annotation claimed by %s on method %s.\"\r\n                                    + \" Methods can only have one annotation claimed per scanner.\",\r\n                            scanner, method);\r\n                    return null;\r\n                }\r\n                annotation = foundAnnotation;\r\n            }\r\n        }\r\n        return annotation;\r\n    }"}, {"ID": 372, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Integer getLineNumber(Member member) { Preconditions.checkArgument( type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type); return lines.get(memberKey(member)); }\n\n    ### Response:", "ground_truth": "Get the line number associated with the given member.\n\n@param member a field, constructor, or method belonging to the class used during construction\n@return the wrapped line number, or null if not available\n@throws IllegalArgumentException if the member does not belong to the class used during\nconstruction", "predict": "/**\r\n     * Returns the line number of the given member in the source code.\r\n     *\r\n     * @param member the member to get the line number for\r\n     * @return the line number of the given member in the source code\r\n     * @throws IllegalArgumentException if the given member does not belong to the given type\r\n     */\r\n    public Integer getLineNumber(Member member) {\r\n        Preconditions.checkArgument(type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type);\r\n        return lines.get(memberKey(member));\r\n    }"}, {"ID": 373, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void initialize(Errors errors) { injector.lookups = injector; new LookupProcessor(errors).process(injector, lookups); }\n\n    ### Response:", "ground_truth": "Initialize the specified lookups, either immediately or when the injector is created.", "predict": "/**\r\n     * Initializes the injector by setting the lookups to itself and processing the lookups.\r\n     * \r\n     * @param errors the errors object to use for error reporting\r\n     */\r\n    void initialize(Errors errors) {\r\n        injector.lookups = injector;\r\n        new LookupProcessor(errors).process(injector, lookups);\r\n    }"}, {"ID": 374, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); }\n\n    ### Response:", "ground_truth": "Wraps the given callable in a contextual callable that \"continues\" the HTTP request in another\nthread. This acts as a way of transporting request context data from the request processing\nthread to to worker threads.\n\nThere are some limitations:\n\n\nDerived objects (i.e. anything marked @RequestScoped will not be transported.\nState changes to the HttpServletRequest after this method is called will not be seen in the\ncontinued thread.\nOnly the HttpServletRequest, ServletContext and request parameter map are available in the\ncontinued thread. The response and session are not available.\n\nThe returned callable will throw a {@link ScopingException} when called if the HTTP request\nscope is still active on the current thread.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@param seedMap the initial set of scoped instances for Guice to seed the request scope with. To\nseed a key with null, use {@code null} as the value.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 3.0\n@deprecated You probably want to use {@code transferRequest} instead", "predict": "/**\r\n     * @deprecated Use {@link #continueRequest(Map)} instead.\r\n     */\r\n    public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) {\r\n        return wrap(callable, continueRequest(seedMap));\r\n    }"}, {"ID": 375, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); }\n\n    ### Response:", "ground_truth": "Wraps the given callable in a contextual callable that \"transfers\" the request to another\nthread. This acts as a way of transporting request context data from the current thread to a\nfuture thread.\n\nAs opposed to {@link #continueRequest}, this method propagates all existing scoped objects.\nThe primary use case is in server implementations where you can detach the request processing\nthread while waiting for data, and reattach to a different thread to finish processing at a\nlater time.\n\nBecause request-scoped objects are not typically thread-safe, the callable returned by this\nmethod must not be run on a different thread until the current request scope has terminated.\nThe returned callable will block until the current thread has released the request scope.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 4.0", "predict": "/**\r\n     * This method takes a Callable object and returns a new Callable object that wraps the original Callable object with a transfer request.\r\n     * \r\n     * @param <T> The type of the return value of the Callable object.\r\n     * @param callable The Callable object to be wrapped with a transfer request.\r\n     * @return A new Callable object that wraps the original Callable object with a transfer request.\r\n     */\r\n    public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); }"}, {"ID": 376, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; }\n\n    ### Response:", "ground_truth": "Validates the key and object, ensuring the value matches the key type, and canonicalizing null\nobjects to the null sentinel.", "predict": "/**\r\n     * Validates and canonicalizes the given value for the given key.\r\n     * \r\n     * @param key the key to validate and canonicalize the value for\r\n     * @param object the value to validate and canonicalize\r\n     * @return the canonicalized value, or NullObject.INSTANCE if the value is null or NullObject.INSTANCE\r\n     * @throws IllegalArgumentException if the value is not compatible with the key\r\n     */\r\n    private static Object validateAndCanonicalizeValue(Key<?> key, Object object) {\r\n        if (object == null || object == NullObject.INSTANCE) {\r\n            return NullObject.INSTANCE;\r\n        }\r\n        if (!key.getTypeLiteral().getRawType().isInstance(object)) {\r\n            throw new IllegalArgumentException(\"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\");\r\n        }\r\n        return object;\r\n    }"}, {"ID": 377, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") // the MembersInjector type always agrees with the passed type public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException { return (MembersInjectorImpl<T>) cache.get(key, errors); }\n\n    ### Response:", "ground_truth": "Returns a new complete members injector with injection listeners registered.", "predict": "/**\n     * Returns a MembersInjector for the given type.\n     *\n     * @param key the type for which to return a MembersInjector\n     * @param errors errors object to collect errors and warnings\n     * @return a MembersInjector for the given type\n     * @throws ErrorsException if there are errors in the key or the implementation of the MembersInjector\n     */\n    public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException;"}, {"ID": 378, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Set<InjectionPoint> injectionPoints; try { injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type); } catch (ConfigurationException e) { errors.merge(e.getErrorMessages()); injectionPoints = e.getPartialValue(); } ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors); errors.throwIfNewErrors(numErrorsBefore); EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups); Set<TypeListener> alreadySeenListeners = Sets.newHashSet(); for (TypeListenerBinding binding : typeListenerBindings) { TypeListener typeListener = binding.getListener(); if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) { alreadySeenListeners.add(typeListener); try { typeListener.hear(type, encounter); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } encounter.invalidate(); errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(injector, type, encounter, injectors); }\n\n    ### Response:", "ground_truth": "Creates a new members injector and attaches both injection listeners and method aspects.", "predict": "/**\n     * Creates a new MembersInjectorImpl with the given type and errors.\n     *\n     * @param type the type to create the MembersInjector for\n     * @param errors the errors object to use for error reporting\n     * @return a new MembersInjectorImpl\n     * @throws ErrorsException if there are errors during creation\n     */\n    private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException {\n        // TODO: Implement method\n    }"}, {"ID": 379, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); }\n\n    ### Response:", "ground_truth": "Returns the injectors for the specified injection points.", "predict": "/**\n     * Returns a list of injectors for the given injection points.\n     *\n     * @param injectionPoints the set of injection points to generate injectors for\n     * @param errors the errors object to use for error reporting\n     * @return a list of injectors for the given injection points\n     */\n    ImmutableList<SingleMemberInjector> getInjectors(Set<InjectionPoint> injectionPoints, Errors errors);"}, {"ID": 380, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); }\n\n    ### Response:", "ground_truth": "Gets a key for an injection type and an annotation strategy.", "predict": "/**\r\n     * Returns a new Key instance for the given type and annotation strategy.\r\n     * \r\n     * @param type the type of the key\r\n     * @param annotationStrategy the annotation strategy to use for the key\r\n     * @return a new Key instance for the given type and annotation strategy\r\n     */\r\n    static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); }"}, {"ID": 381, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static AnnotationStrategy strategyFor(Annotation annotation) { checkNotNull(annotation, \"annotation\"); Class<? extends Annotation> annotationType = annotation.annotationType(); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); if (Annotations.isMarker(annotationType)) { return new AnnotationTypeStrategy(annotationType, annotation); } return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation)); }\n\n    ### Response:", "ground_truth": "Gets the strategy for an annotation.", "predict": "/**\n     * Returns a strategy for the given annotation.\n     *\n     * @param annotation the annotation to create a strategy for\n     * @return a strategy for the given annotation\n     * @throws NullPointerException if the annotation is null\n     * @throws IllegalArgumentException if the annotation is not retained at runtime or is not a binding annotation\n     */\n    public static AnnotationStrategy strategyFor(Annotation annotation) {\n        // implementation omitted for brevity\n    }"}, {"ID": 382, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, null); }\n\n    ### Response:", "ground_truth": "Gets the strategy for an annotation type.", "predict": "/**\n     * Returns a strategy for the given annotation type.\n     *\n     * @param annotationType the annotation type\n     * @return the strategy for the annotation type\n     * @throws NullPointerException if the annotation type is null\n     * @throws IllegalArgumentException if the annotation type is not retained at runtime or is not a binding annotation\n     */\n    public static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) {\n        annotationType = Annotations.canonicalizeIfNamed(annotationType);\n        if (isAllDefaultMethods(annotationType)) {\n            return strategyFor(generateAnnotation(annotationType));\n        }\n        checkNotNull(annotationType, \"annotation type\");\n        ensureRetainedAtRuntime(annotationType);\n        ensureIsBindingAnnotation(annotationType);\n        return new AnnotationTypeStrategy(annotationType, null);\n    }"}, {"ID": 383, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pruneStacktrace(Throwable throwable) { for (Throwable t = throwable; t != null; t = t.getCause()) { StackTraceElement[] stackTrace = t.getStackTrace(); List<StackTraceElement> pruned = Lists.newArrayList(); for (StackTraceElement element : stackTrace) { String className = element.getClassName(); if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) { pruned.add(element); } } t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()])); } }\n\n    ### Response:", "ground_truth": "Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace\nand any causes it may have.", "predict": "/**\r\n     * Removes AOP-related stack trace elements from the given Throwable's stack trace.\r\n     *\r\n     * @param throwable the Throwable to prune\r\n     */\r\n    private void pruneStacktrace(Throwable throwable) {\r\n        for (Throwable t = throwable; t != null; t = t.getCause()) {\r\n            StackTraceElement[] stackTrace = t.getStackTrace();\r\n            List<StackTraceElement> pruned = Lists.newArrayList();\r\n            for (StackTraceElement element : stackTrace) {\r\n                String className = element.getClassName();\r\n                if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) {\r\n                    pruned.add(element);\r\n                }\r\n            }\r\n            t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()]));\r\n        }\r\n    }"}, {"ID": 384, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getBindingSource() { if (source instanceof Class) { return StackTraceElements.forType((Class) source).toString(); } else if (source instanceof Member) { return StackTraceElements.forMember((Member) source).toString(); } else { return source.toString(); } }\n\n    ### Response:", "ground_truth": "Returns a string describing where this dependency was bound. If the binding was just-in-time,\nthere is no valid binding source, so this describes the class in question.", "predict": "/**\r\n     * Returns the binding source of the object.\r\n     * \r\n     * @return the binding source of the object.\r\n     */\r\n    public String getBindingSource() {\r\n        if (source instanceof Class) {\r\n            return StackTraceElements.forType((Class) source).toString();\r\n        } else if (source instanceof Member) {\r\n            return StackTraceElements.forMember((Member) source).toString();\r\n        } else {\r\n            return source.toString();\r\n        }\r\n    }"}, {"ID": 385, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause); if (!causes.containsKey(causeEquivalence)) { causes.put(causeEquivalence, thisIdx); fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause)); } else { int causeIdx = causes.get(causeEquivalence); fmt.format( \"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx); } } fmt.format(\"%n\"); } if (errorMessages.size() == 1) { fmt.format(\"1 error\"); } else { fmt.format(\"%s errors\", errorMessages.size()); } return fmt.toString(); }\n\n    ### Response:", "ground_truth": "Returns the formatted message for an exception with the specified messages.", "predict": "/**\n     * Formats a collection of error messages into a human-readable string.\n     *\n     * @param heading the heading to display at the beginning of the message\n     * @param errorMessages the collection of error messages to format\n     * @return the formatted string\n     */\n    public static String formatMessages(String heading, Collection<Message> errorMessages) {\n        // TODO: Implement method\n    }"}, {"ID": 386, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); }\n\n    ### Response:", "ground_truth": "Creates a new Message without a cause.\n\n@param messageFormat Format string\n@param arguments format string arguments", "predict": "/**\r\n     * Creates a new Message object with the specified message format and arguments.\r\n     * \r\n     * @param messageFormat the message format string\r\n     * @param arguments the arguments to be inserted into the message format string\r\n     * @return the new Message object\r\n     */\r\n    public static Message create(String messageFormat, Object... arguments) {\r\n        return create(null, messageFormat, arguments);\r\n    }"}, {"ID": 387, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create(Throwable cause, String messageFormat, Object... arguments) { return create(cause, ImmutableList.of(), messageFormat, arguments); }\n\n    ### Response:", "ground_truth": "Creates a new Message with the given cause.\n\n@param cause The exception that caused the error\n@param messageFormat Format string\n@param arguments format string arguments", "predict": "/**\r\n     * Creates a new message with the given cause, message format, and arguments.\r\n     *\r\n     * @param cause the cause of the error\r\n     * @param messageFormat the message format string\r\n     * @param arguments the arguments to be inserted into the message format string\r\n     * @return the new message\r\n     */\r\n    public static Message create(Throwable cause, String messageFormat, Object... arguments) {\r\n        return create(cause, ImmutableList.of(), messageFormat, arguments);\r\n    }"}, {"ID": 388, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Message(sources, message, cause); }\n\n    ### Response:", "ground_truth": "Creates a new Message with the given cause and a binding source stack.\n\n@param cause The exception that caused the error\n@param sources The binding sources for the source stack\n@param messageFormat Format string\n@param arguments format string arguments", "predict": "/**\r\n     * Creates a new Message object with the given cause, sources, message format, and arguments.\r\n     * \r\n     * @param cause the cause of the error\r\n     * @param sources the list of sources of the error\r\n     * @param messageFormat the message format string\r\n     * @param arguments the arguments to be used in the message format string\r\n     * @return the new Message object\r\n     */\r\n    public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) {\r\n        String message = format(messageFormat, arguments);\r\n        return new Message(sources, message, cause);\r\n    }"}, {"ID": 389, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Object convert(Object o) { ElementSource source = null; if (o instanceof ElementSource) { source = (ElementSource) o; o = source.getDeclaringSource(); } return convert(o, source); }\n\n    ### Response:", "ground_truth": "Formats an object in a user friendly way.", "predict": "/**\r\n     * Converts the given object to a {@link ElementSource} object.\r\n     * \r\n     * @param o the object to convert\r\n     * @return the converted object\r\n     */\r\n    static Object convert(Object o) {\r\n        ElementSource source = null;\r\n        if (o instanceof ElementSource) {\r\n            source = (ElementSource) o;\r\n            o = source.getDeclaringSource();\r\n        }\r\n        return convert(o, source);\r\n    }"}, {"ID": 390, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean shouldBeSkipped(String className) { return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className); }\n\n    ### Response:", "ground_truth": "Returns true if the className should be skipped.", "predict": "/**\r\n     * Checks if the given class name should be skipped based on the parent class and the list of class names to skip.\r\n     * \r\n     * @param className the name of the class to check\r\n     * @return true if the class should be skipped, false otherwise\r\n     */\r\n    private boolean shouldBeSkipped(String className) {\r\n        return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className);\r\n    }"}, {"ID": 391, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; }\n\n    ### Response:", "ground_truth": "Returns the non-skipped module class name.", "predict": "/**\r\n     * Retrieves the source information for the given list of module class names.\r\n     *\r\n     * @param moduleClassNames the list of module class names to retrieve the source information for\r\n     * @return the source information for the given list of module class names, or UNKNOWN_SOURCE if no source information is found\r\n     */\r\n    public Object getFromClassNames(List<String> moduleClassNames) {\r\n        Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\");\r\n        for (final String moduleClassName : moduleClassNames) {\r\n            if (!shouldBeSkipped(moduleClassName)) {\r\n                return new StackTraceElement(moduleClassName, \"configure\", null, -1);\r\n            }\r\n        }\r\n        return UNKNOWN_SOURCE;\r\n    }"}, {"ID": 392, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\"); System.err.println(\"Then run 'jconsole' to connect.\"); System.exit(1); } Module module = (Module) Class.forName(args[0]).newInstance(); Injector injector = Guice.createInjector(module); manage(args[0], injector); System.out.println(\"Press Ctrl+C to exit...\"); // Sleep forever. Thread.sleep(Long.MAX_VALUE); }\n\n    ### Response:", "ground_truth": "Run with no arguments for usage instructions.", "predict": "/**\r\n * The main method of the Manager class.\r\n *\r\n * @param args the command line arguments\r\n * @throws Exception if an error occurs during execution\r\n */\r\npublic static void main(String[] args) throws Exception {\r\n    if (args.length != 1) {\r\n        System.err.println(\"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\");\r\n        System.err.println(\"Then run 'jconsole' to connect.\");\r\n        System.exit(1);\r\n    }\r\n\r\n    Module module = (Module) Class.forName(args[0]).newInstance();\r\n    Injector injector = Guice.createInjector(module);\r\n    manage(args[0], injector);\r\n\r\n    System.out.println(\"Press Ctrl+C to exit...\");\r\n    // Sleep forever.\r\n    Thread.sleep(Long.MAX_VALUE);\r\n}"}, {"ID": 393, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Dependency<?> pushDependency(Dependency<?> dependency, Object source) { Dependency<?> previous = this.dependency; this.dependency = dependency; doPushState(dependency, source); return previous; }\n\n    ### Response:", "ground_truth": "Sets the new current dependency & adds it to the state.", "predict": "/**\r\n     * Pushes a new dependency onto the stack and updates the state of the current dependency.\r\n     * \r\n     * @param dependency the new dependency to push onto the stack\r\n     * @param source the source of the dependency\r\n     * @return the previous dependency on the stack\r\n     */\r\n    public Dependency<?> pushDependency(Dependency<?> dependency, Object source) {\r\n        Dependency<?> previous = this.dependency;\r\n        this.dependency = dependency;\r\n        doPushState(dependency, source);\r\n        return previous;\r\n    }"}, {"ID": 394, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); }\n\n    ### Response:", "ground_truth": "Adds to the state without setting the dependency.", "predict": "/**\n     * Pushes the state of the given source object for the given key.\n     * \n     * @param key the key for which to push the state\n     * @param source the source object for which to push the state\n     */\n    void doPushState(com.google.inject.Key<?> key, Object source);"}, {"ID": 395, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static <T> Initializable<T> of(final T instance) { return new Initializable<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; }\n\n    ### Response:", "ground_truth": "Returns an initializable for an instance that requires no initialization.", "predict": "/**\r\n     * Creates a new Initializable instance that wraps the given instance.\r\n     *\r\n     * @param <T> the type of the instance\r\n     * @param instance the instance to wrap\r\n     * @return a new Initializable instance that wraps the given instance\r\n     */\r\n    public static <T> Initializable<T> of(final T instance) {\r\n        return new Initializable<T>() {\r\n            @Override\r\n            public T get() {\r\n                return instance;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return String.valueOf(instance);\r\n            }\r\n        };\r\n    }"}, {"ID": 396, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T provision( Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { T t = provider.get(); if (t == null && !dependency.isNullable()) { InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency); } constructionContext.setProxyDelegates(t); return t; }\n\n    ### Response:", "ground_truth": "Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as\nErrorsExceptions.", "predict": "/**\n     * Provisions an instance of type {@code T} using the given {@link Provider} and {@link Dependency}.\n     *\n     * @param provider the provider to use for provision\n     * @param dependency the dependency to provision\n     * @param constructionContext the construction context to use for provision\n     * @return the provisioned instance\n     * @throws InternalProvisionException if an error occurs during provision\n     */\n    protected T provision(Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException;"}, {"ID": 397, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } }\n\n    ### Response:", "ground_truth": "Dispatch events.\n\n@param type\n@param remoteAddr\n@param conn", "predict": "/**\r\n     * This method is called when a connection event occurs.\r\n     * \r\n     * @param type The type of connection event that occurred.\r\n     * @param remoteAddr The remote address of the connection.\r\n     * @param conn The connection object.\r\n     */\r\n    public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) {\r\n        List<ConnectionEventProcessor> processorList = this.processors.get(type);\r\n        if (processorList != null) {\r\n            for (ConnectionEventProcessor processor : processorList) {\r\n                processor.onEvent(remoteAddr, conn);\r\n            }\r\n        }\r\n    }"}, {"ID": 398, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList == null) { this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1)); processorList = this.processors.get(type); } processorList.add(processor); }\n\n    ### Response:", "ground_truth": "Add event processor.\n\n@param type\n@param processor", "predict": "/**\r\n     * Adds a connection event processor for a specific connection event type.\r\n     * \r\n     * @param type the connection event type\r\n     * @param processor the connection event processor to add\r\n     */\r\n    public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) {\r\n        List<ConnectionEventProcessor> processorList = this.processors.get(type);\r\n        if (processorList == null) {\r\n            this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1));\r\n            processorList = this.processors.get(type);\r\n        }\r\n        processorList.add(processor);\r\n    }"}, {"ID": 399, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) { T t = null; if (null != task) { try { t = task.getAfterRun(); } catch (InterruptedException e) { logger.error(\"Future task interrupted!\", e); } catch (ExecutionException e) { logger.error(\"Future task execute failed!\", e); } catch (FutureTaskNotRunYetException e) { logger.error(\"Future task has not run yet!\", e); } catch (FutureTaskNotCompleted e) { logger.error(\"Future task has not completed!\", e); } } return t; }\n\n    ### Response:", "ground_truth": "get the result of a future task\n\nNotice: the run method of this task should have been called at first.\n\n@param task\n@param \n@return", "predict": "/**\r\n     * Get the result of a future task.\r\n     *\r\n     * @param task the future task to get the result from\r\n     * @param logger the logger to log any errors\r\n     * @param <T> the type of the result\r\n     * @return the result of the future task, or null if the task has not completed yet\r\n     */\r\n    public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) {\r\n        T t = null;\r\n        if (null != task) {\r\n            try {\r\n                t = task.getAfterRun();\r\n            } catch (InterruptedException e) {\r\n                logger.error(\"Future task interrupted!\", e);\r\n            } catch (ExecutionException e) {\r\n                logger.error(\"Future task execute failed!\", e);\r\n            } catch (FutureTaskNotRunYetException e) {\r\n                logger.error(\"Future task has not run yet!\", e);\r\n            } catch (FutureTaskNotCompleted e) {\r\n                logger.error(\"Future task has not completed!\", e);\r\n           "}, {"ID": 400, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void launderThrowable(Throwable t) { if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new IllegalStateException(\"Not unchecked!\", t); } }\n\n    ### Response:", "ground_truth": "launder the throwable\n\n@param t", "predict": "/**\r\n     * Launder a Throwable to a RuntimeException or Error, depending on its type.\r\n     *\r\n     * @param t the Throwable to launder\r\n     * @throws RuntimeException if the input is a RuntimeException\r\n     * @throws Error if the input is an Error\r\n     * @throws IllegalStateException if the input is not a RuntimeException or an Error\r\n     */\r\n    public static void launderThrowable(Throwable t) {\r\n        if (t instanceof RuntimeException) {\r\n            throw (RuntimeException) t;\r\n        } else if (t instanceof Error) {\r\n            throw (Error) t;\r\n        } else {\r\n            throw new IllegalStateException(\"Not unchecked!\", t);\r\n        }\r\n    }"}, {"ID": 401, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); }\n\n    ### Response:", "ground_truth": "Register processor to process command that has the command code of cmdCode.\n\n@param cmdCode\n@param processor", "predict": "/**\r\n     * Registers a processor for a given command code.\r\n     * \r\n     * @param cmdCode the command code for which the processor is being registered.\r\n     * @param processor the processor to be registered.\r\n     */\r\n    public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) {\r\n        if (this.cmd2processors.containsKey(cmdCode)) {\r\n            logger.warn(\"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass().getName());\r\n        }\r\n        this.cmd2processors.put(cmdCode, processor);\r\n    }"}, {"ID": 402, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerDefaultProcessor(RemotingProcessor<?> processor) { if (this.defaultProcessor == null) { this.defaultProcessor = processor; } else { throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass()); } }\n\n    ### Response:", "ground_truth": "Register the default processor to process command with no specific processor registered.\n\n@param processor", "predict": "/**\r\n     * Registers the given {@link RemotingProcessor} as the default processor for this client.\r\n     *\r\n     * @param processor the processor to register as the default\r\n     * @throws IllegalStateException if the default processor has already been registered\r\n     */\r\n    public void registerDefaultProcessor(RemotingProcessor<?> processor) {\r\n        if (this.defaultProcessor == null) {\r\n            this.defaultProcessor = processor;\r\n        } else {\r\n            throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass());\r\n        }\r\n    }"}, {"ID": 403, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RemotingProcessor<?> getProcessor(CommandCode cmdCode) { RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode); if (processor != null) { return processor; } return this.defaultProcessor; }\n\n    ### Response:", "ground_truth": "Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.\n\n@param cmdCode\n@return", "predict": "/**\r\n     * Returns the processor for the given command code.\r\n     * \r\n     * @param cmdCode the command code\r\n     * @return the processor for the given command code, or the default processor if no processor is found for the given command code\r\n     */\r\n    public RemotingProcessor<?> getProcessor(CommandCode cmdCode) {\r\n        RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode);\r\n        if (processor != null) {\r\n            return processor;\r\n        }\r\n        return this.defaultProcessor;\r\n    }"}, {"ID": 404, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); }\n\n    ### Response:", "ground_truth": "try get from cache\n\n@param url\n@return", "predict": "/**\r\n     * Tries to get the URL object for the given URL string.\r\n     *\r\n     * @param url the URL string to get the URL object for\r\n     * @return the URL object for the given URL string, or null if it doesn't exist\r\n     */\r\n    private Url tryGet(String url) {\r\n        SoftReference<Url> softRef = Url.parsedUrls.get(url);\r\n        return (null == softRef) ? null : softRef.get();\r\n    }"}, {"ID": 405, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ProtocolCode decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; }\n\n    ### Response:", "ground_truth": "decode the protocol code\n\n@param in input byte buf\n@return an instance of ProtocolCode", "predict": "/**\r\n     * Decodes the protocol code from the input buffer.\r\n     * \r\n     * @param in the input buffer\r\n     * @return the decoded protocol code or null if the input buffer does not contain enough bytes\r\n     */\r\n    protected ProtocolCode decodeProtocolCode(ByteBuf in) {\r\n        if (in.readableBytes() >= protocolCodeLength) {\r\n            byte[] protocolCodeBytes = new byte[protocolCodeLength];\r\n            in.readBytes(protocolCodeBytes);\r\n            return ProtocolCode.fromBytes(protocolCodeBytes);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 406, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Map<String, List<Connection>> getAll() { Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>(); Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this .getConnPools().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); if (null != pool) { allConnections.put(entry.getKey(), pool.getAll()); } } return allConnections; }\n\n    ### Response:", "ground_truth": "Get all connections of all poolKey.\n\n@return a map with poolKey as key and a list of connections in ConnectionPool as value", "predict": "/**\r\n     * This method retrieves all the connections from all the connection pools.\r\n     * \r\n     * @return A map containing all the connections from all the connection pools.\r\n     */\r\n    @Override public Map<String, List<Connection>> getAll() {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 407, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void scan() { if (null != this.connTasks && !this.connTasks.isEmpty()) { Iterator<String> iter = this.connTasks.keySet().iterator(); while (iter.hasNext()) { String poolKey = iter.next(); ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey)); if (null != pool) { pool.scan(); if (pool.isEmpty()) { if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) { iter.remove(); logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey); } } } } } }\n\n    ### Response:", "ground_truth": "in case of cache pollution and connection leak, to do schedule scan\n\n@see com.alipay.remoting.Scannable#scan()", "predict": "/**\r\n     * This method is used to scan all the connection pools and remove the expired pools.\r\n     */\r\n    @Override public void scan() {\r\n        // TODO: Implement the logic to scan all the connection pools and remove the expired pools.\r\n    }"}, {"ID": 408, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; } }\n\n    ### Response:", "ground_truth": "If no task cached, create one and initialize the connections.\n\n@see ConnectionManager#getAndCreateIfAbsent(Url)", "predict": "/**\r\n     * This method overrides the getAndCreateIfAbsent method of the ConnectionPoolManager class.\r\n     * It gets a connection pool with initialized connections from the connection pool manager.\r\n     * If the pool is null, it means that the connection pool has not been created yet.\r\n     * In this case, it creates a new connection pool with initialized connections using the ConnectionPoolCall class.\r\n     * If the pool is not null, it returns a connection from the pool.\r\n     * If there is an error, it logs an error message.\r\n     * @param url the URL of the connection pool to be retrieved or created.\r\n     * @return a connection from the pool or null if there is an error.\r\n     * @throws InterruptedException if the thread is interrupted while waiting for the connection pool to be created.\r\n     * @throws RemotingException if there is an error while creating the connection pool.\r\n     */\r\n    @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException {"}, {"ID": 409, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); } }\n\n    ### Response:", "ground_truth": "If no task cached, create one and initialize the connections.\nIf task cached, check whether the number of connections adequate, if not then heal it.\n\n@param url\n@return\n@throws InterruptedException\n@throws RemotingException", "predict": "/**\r\n     * This method overrides the createConnectionAndHealIfNeed method of the parent class and is responsible for creating a connection pool with initialized connections.\r\n     * If the connection pool is not null, it will be checked for any stale connections and if found, they will be closed and removed from the pool.\r\n     * If the connection pool is null, an error message will be logged.\r\n     *\r\n     * @param url - The URL object that contains the connection details.\r\n     * @throws InterruptedException - If the thread is interrupted while waiting for a connection to be released.\r\n     * @throws RemotingException - If there is an error while creating the connection pool.\r\n     */\r\n    @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else {"}, {"ID": 410, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeTask(String poolKey) { RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey); if (null != task) { ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger); if (null != pool) { pool.removeAllAndTryClose(); } } }\n\n    ### Response:", "ground_truth": "remove task and remove all connections\n\n@param poolKey", "predict": "/**\r\n     * Removes the task for the specified pool key and attempts to close the associated connection pool.\r\n     * \r\n     * @param poolKey the key of the pool to remove\r\n     */\r\n    private void removeTask(String poolKey) {\r\n        RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey);\r\n        if (null != task) {\r\n            ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger);\r\n            if (null != pool) {\r\n                pool.removeAllAndTryClose();\r\n            }\r\n        }\r\n    }"}, {"ID": 411, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException { String poolKey = url.getUniqueKey(); // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) { FutureTask<Integer> task = this.healTasks.get(poolKey); if (null == task) { task = new FutureTask<Integer>(new HealConnectionCall(url, pool)); task = this.healTasks.putIfAbsent(poolKey, task); if (null == task) { task = this.healTasks.get(poolKey); task.run(); } } try { int numAfterHeal = task.get(); if (logger.isDebugEnabled()) { logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup()); } } catch (InterruptedException e) { this.healTasks.remove(poolKey); throw e; } catch (ExecutionException e) { this.healTasks.remove(poolKey); Throwable cause = e.getCause(); if (cause instanceof RemotingException) { throw (RemotingException) cause; } else { FutureTaskUtil.launderThrowable(cause); } } // heal task is one-off, remove from cache directly after run this.healTasks.remove(poolKey); } }\n\n    ### Response:", "ground_truth": "execute heal connection tasks if the actual number of connections in pool is less than expected\n\n@param pool\n@param url", "predict": "/**\r\n     * This method is responsible for checking if the connection pool needs to be healed.\r\n     * If the async creation of connections is done and the actual size of connections is less than expected,\r\n     * the healing task can be run.\r\n     *\r\n     * @param pool the connection pool to be checked\r\n     * @param url the URL of the service to be checked\r\n     * @throws RemotingException if any error occurs during healing\r\n     * @throws InterruptedException if the current thread is interrupted while waiting for the healing task to complete\r\n     */\r\n    private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException {\r\n        String poolKey = url.getUniqueKey();\r\n        // only when async creating connections done\r\n        // and the actual size of connections less than expected, the healing task can be run.\r\n        if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) {\r\n            FutureTask<Integer> task = this.healTasks.get(poolKey);\r\n           "}, {"ID": 412, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException { final int actualNum = pool.size(); final int expectNum = url.getConnNum(); if (actualNum < expectNum) { if (logger.isDebugEnabled()) { logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName); } if (url.isConnWarmup()) { for (int i = actualNum; i < expectNum; ++i) { Connection connection = create(url); pool.add(connection); } } else { if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) { throw new IllegalArgumentException( \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\"); } // create connection in sync way if (syncCreateNumWhenNotWarmup > 0) { for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) { Connection connection = create(url); pool.add(connection); } if (syncCreateNumWhenNotWarmup == url.getConnNum()) { return; } } // initialize executor in lazy way initializeExecutor(); pool.markAsyncCreationStart();// mark the start of async try { this.asyncCreateConnectionExecutor.execute(new Runnable() { @Override public void run() { try { for (int i = pool.size(); i < url.getConnNum(); ++i) { Connection conn = null; try { conn = create(url); } catch (RemotingException e) { logger .error( \"Exception occurred in async create connection thread for {}, taskName {}\", url.getUniqueKey(), taskName, e); } pool.add(conn); } } finally { pool.markAsyncCreationDone();// mark the end of async } } }); } catch (RejectedExecutionException e) { pool.markAsyncCreationDone();// mark the end of async when reject throw e; } } // end of NOT warm up } // end of if }\n\n    ### Response:", "ground_truth": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "predict": "/**\n     * Creates connections to the specified URL.\n     *\n     * @param url the URL to create connections to\n     * @param pool the connection pool to add connections to\n     * @param taskName the name of the task that creates connections\n     * @param syncCreateNumWhenNotWarmup the number of connections to create synchronously when not warmup\n     * @throws RemotingException if any exception occurs during connection creation\n     */\n    private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException {\n        final int actualNum = pool.size();\n        final int expectNum = url.getConnNum();\n        if (actualNum < expectNum) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName);\n            }\n            if (url.isConnWarmup()) {\n                for (int i = actualNum; i < expectNum;"}, {"ID": 413, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void closeConnection(String addr) { Url url = this.addressParser.parse(addr); this.connectionManager.remove(url.getUniqueKey()); }\n\n    ### Response:", "ground_truth": "Close all connections of a address\n\n@param addr", "predict": "/**\r\n     * This method is used to close the connection to a given address.\r\n     * \r\n     * @param addr - The address to close the connection to.\r\n     */\r\n    public void closeConnection(String addr) {\r\n        Url url = this.addressParser.parse(addr);\r\n        this.connectionManager.remove(url.getUniqueKey());\r\n    }"}, {"ID": 414, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }\n\n    ### Response:", "ground_truth": "Do something when closing.", "predict": "/**\r\n     * This method is called when the connection is closed. It removes all the pending invoke futures from the map and sets the response for each future to CONNECTION_CLOSED. It also cancels the timeout for each future and tries to execute the callback for each future with an exception.\r\n     */"}, {"ID": 415, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } }\n\n    ### Response:", "ground_truth": "Close the connection.", "predict": "/**\r\n     * Close the connection.\r\n     *\r\n     * @throws IOException If any I/O error occurs.\r\n     */\r\n    public void close() throws IOException {\r\n        if (closed.compareAndSet(false, true)) {\r\n            try {\r\n                if (this.getChannel() != null) {\r\n                    this.getChannel().close().addListener(new ChannelFutureListener() {\r\n                        @Override\r\n                        public void operationComplete(ChannelFuture future) throws Exception {\r\n                            if (logger.isInfoEnabled()) {\r\n                                logger.info(\"Close the connection to remote address={}, result={}, cause={}\",\r\n                                        RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), future.isSuccess(), future.cause());\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            } catch (Exception e) {\r\n                logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e);\r\n            }\r\n        }\r\n    }"}, {"ID": 416, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); }\n\n    ### Response:", "ground_truth": "set attribute if key absent.\n\n@param key\n@param value\n@return", "predict": "/**\r\n     * If the specified key is not already associated with a value (or is mapped to null),\r\n     * attempts to associate it with the given value.\r\n     *\r\n     * If the value is already present, the existing value is returned,\r\n     * and the operation is not performed.\r\n     *\r\n     * @param key key with which the specified value is to be associated\r\n     * @param value value to be associated with the specified key\r\n     * @return the previous value associated with key, or null if there was no mapping for key.\r\n     *         (A null return can also indicate that the map previously associated null with key,\r\n     *         if the implementation supports null values.)\r\n     */\r\n    public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); }"}, {"ID": 417, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (processor instanceof MultiInterestUserProcessor) { registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors); } else { if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } }\n\n    ### Response:", "ground_truth": "Help register single-interest user processor.\n\n@param processor  the processor need to be registered\n@param userProcessors   the map of user processors", "predict": "/**\r\n     * Registers the given user processor with the given user processors map.\r\n     *\r\n     * @param processor the user processor to register\r\n     * @param userProcessors the map of user processors\r\n     */\r\n    public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) {\r\n        if (null == processor) {\r\n            throw new RuntimeException(\"User processor should not be null!\");\r\n        }\r\n        if (processor instanceof MultiInterestUserProcessor) {\r\n            registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors);\r\n        } else {\r\n            if (StringUtils.isBlank(processor.interest())) {\r\n                throw new RuntimeException(\"Processor interest should not be blank!\");\r\n            }\r\n            UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor);\r\n            if (preProcessor != null) {\r\n                String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\";\r\n                throw new RuntimeException(errMsg);\r\n            }\r\n        }\r\n    }"}, {"ID": 418, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) { throw new RuntimeException(\"Processor interest should not be blank!\"); } for (String interest : processor.multiInterest()) { UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } }\n\n    ### Response:", "ground_truth": "Help register multi-interest user processor.\n\n@param processor  the processor with multi-interest need to be registered\n@param userProcessors    the map of user processors", "predict": "/**\r\n     * Registers a user processor with the given interests.\r\n     *\r\n     * @param processor the user processor to register\r\n     * @param userProcessors the map of user processors keyed by their interests\r\n     * @throws RuntimeException if the processor interest is blank or if a processor with the same interest has already been registered\r\n     */\r\n    private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) {\r\n        if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) {\r\n            throw new RuntimeException(\"Processor interest should not be blank!\");\r\n        }\r\n        for (String interest : processor.multiInterest()) {\r\n            UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor);\r\n            if (preProcessor != null) {\r\n                String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\";\r\n                throw new RuntimeException(errMsg);\r\n            }\r\n        }\r\n    }"}, {"ID": 419, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) { final int id = cmd.getId(); final byte type = cmd.getType(); // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass()); if (processor instanceof AsyncUserProcessor) { try { processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject()); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } else { try { Object responseObject = processor .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), cmd.getRequestObject()); sendResponseIfNecessary(ctx, type, this.getCommandFactory().createResponse(responseObject, cmd)); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } }\n\n    ### Response:", "ground_truth": "dispatch request command to user processor\n@param ctx remoting context\n@param cmd rpc request command", "predict": "/**\n     * This method is used to dispatch the received request to the corresponding user processor.\n     *\n     * @param ctx the remoting context\n     * @param cmd the rpc request command\n     */\n    private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) {\n        final int id = cmd.getId();\n        final byte type = cmd.getType();\n        // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass());\n        if (processor instanceof AsyncUserProcessor) {\n            try {\n                processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject());\n            } catch (RejectedExecutionException e) {\n                logger.warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\");\n                sendResponseIfNecessary(ctx, type, this.getCommandFactory().createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY));\n            }"}, {"ID": 420, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) { boolean result; try { cmd.deserialize(level); result = true; } catch (DeserializationException e) { logger .error( \"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e)); result = false; } catch (Throwable t) { String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" + cmd.getId() + \", deserializeLevel=\" + level; logger.error(errMsg, t); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), t, errMsg)); result = false; } return result; }\n\n    ### Response:", "ground_truth": "deserialize request command\n\n@return true if deserialize success; false if exception catched", "predict": "/**\n     * Deserializes the RpcRequestCommand with the given level.\n     *\n     * @param ctx the remoting context\n     * @param cmd the RpcRequestCommand to be deserialized\n     * @param level the level of deserialization\n     * @return true if the deserialization is successful, false otherwise\n     */\n    private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) {\n        boolean result;\n        try {\n            cmd.deserialize(level);\n            result = true;\n        } catch (DeserializationException e) {\n            logger.error(\"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e);\n            sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory().createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e));\n            result = false;\n        } catch (Throwable t) {\n            String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" +"}, {"ID": 421, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); }\n\n    ### Response:", "ground_truth": "pre process remoting context, initial some useful infos and pass to biz\n\n@param ctx remoting context\n@param cmd rpc request command\n@param currentTimestamp current timestamp", "predict": "/**\n     * This method pre-processes the RemotingContext object by setting the arrive timestamp, timeout, rpc command type, and bolt process wait time in the invoke context.\n     *\n     * @param ctx the RemotingContext object to be pre-processed\n     * @param cmd the RpcRequestCommand object that contains the arrive time, timeout, and rpc command type\n     * @param currentTimestamp the current timestamp in milliseconds\n     */\n    private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) {\n        ctx.setArriveTimestamp(cmd.getArriveTime());\n        ctx.setTimeout(cmd.getTimeout());\n        ctx.setRpcCommandType(cmd.getType());\n        ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime());\n    }"}, {"ID": 422, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); }\n\n    ### Response:", "ground_truth": "print some log when request timeout and discarded in io thread.", "predict": "/**\r\n     * timeoutLog method is used to log the timeout message when the client request is timeout.\r\n     *\r\n     * @param cmd RpcRequestCommand object\r\n     * @param currentTimestamp current timestamp\r\n     * @param ctx RemotingContext object\r\n     */\r\n    private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\",\r\n                    cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());\r\n        }\r\n        String remoteAddr = \"UNKNOWN\";\r\n        if (null != ctx) {\r\n            ChannelHandlerContext channelCtx = ctx.getChannelContext();\r\n            Channel channel = channelCtx.channel();\r\n            if (null != channel) {\r\n                remoteAddr = RemotingUtil.parseRemoteAddress(channel);\r\n            }\r\n        }\r\n        logger.warn(\"Rpc request id["}, {"ID": 423, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } }\n\n    ### Response:", "ground_truth": "print some debug log when receive request", "predict": "/**\r\n     * Logs debug information about an RPC request.\r\n     *\r\n     * @param ctx the remoting context\r\n     * @param cmd the RPC request command\r\n     * @param currentTimestamp the current timestamp\r\n     */\r\n    private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel()));\r\n            logger.debug(\"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout());\r\n        }\r\n    }"}, {"ID": 424, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } }\n\n    ### Response:", "ground_truth": "Process the remoting command with its own executor or with the defaultExecutor if its own if null.\n\n@param ctx\n@param msg\n@param defaultExecutor\n@throws Exception", "predict": "/**\r\n     * Processes the message using the executor provided or the default executor if none is provided.\r\n     * \r\n     * @param ctx the remoting context\r\n     * @param msg the message to process\r\n     * @param defaultExecutor the default executor to use if none is provided\r\n     * @throws Exception if an error occurs during processing\r\n     */\r\n    @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception;"}, {"ID": 425, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), invokeCallback); conn.addInvokeFuture(future); final int requestId = request.getId(); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(requestId); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn .getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture cf) throws Exception { if (!cf.isSuccess()) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse( conn.getRemoteAddress(), cf.cause())); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause()); } } }); } catch (Exception e) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e)); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } }\n\n    ### Response:", "ground_truth": "Invocation with callback.\n\n@param conn\n@param request\n@param invokeCallback\n@param timeoutMillis\n@throws InterruptedException", "predict": "/**\n     * This method is used to invoke a request and register a callback to handle the response.\n     *\n     * @param conn the connection to send the request\n     * @param request the request to send\n     * @param invokeCallback the callback to handle the response\n     * @param timeoutMillis the timeout in milliseconds\n     */\n    protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { }"}, {"ID": 426, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } }\n\n    ### Response:", "ground_truth": "Oneway invocation.\n\n@param conn\n@param request\n@throws InterruptedException", "predict": "/**\r\n     * Send a one-way request to the server.\r\n     *\r\n     * @param conn the connection to send the request\r\n     * @param request the request to send\r\n     */\r\n    protected void oneway(final Connection conn, final RemotingCommand request) {\r\n        try {\r\n            conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() {\r\n                @Override\r\n                public void operationComplete(ChannelFuture f) throws Exception {\r\n                    if (!f.isSuccess()) {\r\n                        logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause());\r\n                    }\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            if (null == conn) {\r\n                logger.error(\"Conn is null\");\r\n            } else {\r\n                logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e);\r\n            }\r\n        }\r\n    }"}, {"ID": 427, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; }\n\n    ### Response:", "ground_truth": "from bit set to byte\n@param bs\n@return byte represent the bit set", "predict": "/**\r\n     * Converts a BitSet to a byte value.\r\n     * \r\n     * @param bs the BitSet to convert\r\n     * @return the byte value\r\n     * @throws IllegalArgumentException if the byte value generated according to bit set is out of range\r\n     */\r\n    public static byte toByte(BitSet bs) {\r\n        int value = 0;\r\n        for (int i = 0; i < bs.length(); ++i) {\r\n            if (bs.get(i)) {\r\n                value += 1 << i;\r\n            }\r\n        }\r\n        if (bs.length() > 7) {\r\n            throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\");\r\n        }\r\n        return (byte) value;\r\n    }"}, {"ID": 428, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; }\n\n    ### Response:", "ground_truth": "from byte to bit set\n@param value\n@return bit set represent the byte", "predict": "/**\r\n     * Converts an integer value to a BitSet.\r\n     * \r\n     * @param value the integer value to be converted to a BitSet.\r\n     * @return a BitSet representation of the integer value.\r\n     * @throws IllegalArgumentException if the value is out of byte range, should be limited between [Byte.MIN_VALUE] to [Byte.MAX_VALUE].\r\n     */\r\n    public static BitSet toBitSet(int value) {\r\n        if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) {\r\n            throw new IllegalArgumentException(\"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\");\r\n        }\r\n        BitSet bs = new BitSet();\r\n        int index = 0;\r\n        while (value != 0) {\r\n            if (value % 2 != 0) {\r\n                bs.set(index);\r\n            }\r\n            ++index;\r\n            value = (byte) (value >> 1"}, {"ID": 429, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); }\n\n    ### Response:", "ground_truth": "add reconnect task\n\n@param url", "predict": "/**\r\n     * Adds a reconnect task to the list of tasks.\r\n     * \r\n     * @param url The URL to reconnect to.\r\n     */\r\n    public void addReconnectTask(Url url) {\r\n        ReconnectTask task = new ReconnectTask();\r\n        task.url = url;\r\n        tasks.add(task);\r\n    }"}, {"ID": 430, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop() { if (!this.started) { return; } this.started = false; healConnectionThreads.interrupt(); this.tasks.clear(); this.canceled.clear(); }\n\n    ### Response:", "ground_truth": "stop reconnect thread", "predict": "/**\r\n     * Stops the server.\r\n     * \r\n     * This method sets the started flag to false, interrupts all connection threads, clears the task queue, and clears the canceled tasks list.\r\n     */"}, {"ID": 431, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException { RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request); if (null != invokeContext) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER); if (null != clientCustomSerializer) { try { command.setSerializer((Byte) clientCustomSerializer); } catch (ClassCastException e) { throw new IllegalArgumentException( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\"); } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE); if (null != crcSwitch && crcSwitch) { command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } } else { // enable crc by default, if there is no invoke context. command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } command.setTimeout(timeoutMillis); command.setRequestClass(request.getClass().getName()); command.setInvokeContext(invokeContext); command.serialize(); logDebugInfo(command); return command; }\n\n    ### Response:", "ground_truth": "Convert application request object to remoting request command.\n\n@param request\n@param conn\n@param timeoutMillis\n@return\n@throws CodecException", "predict": "/**\n     * Convert the request object to a RemotingCommand object.\n     *\n     * @param request the request object\n     * @param conn the connection object\n     * @param invokeContext the invoke context\n     * @param timeoutMillis the timeout in milliseconds\n     * @return the RemotingCommand object\n     * @throws SerializationException if the request object cannot be serialized\n     */\n    protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException {\n        RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request);\n        if (null != invokeContext) {\n            // set client custom serializer for request command if not null\n            Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER);\n            if (null != clientCustomSerializer) {\n                try {\n                    command.setSerializer((Byte) clientCustomSerializer);\n                } catch (ClassCastException e) {\n                    throw new IllegalArgumentException(\"Illegal custom serializer [\" + clientCustomSerializer + \"], the"}, {"ID": 432, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Map<String, List<Connection>> filter(List<Connection> connections) { List<Connection> serviceOnConnections = new ArrayList<Connection>(); List<Connection> serviceOffConnections = new ArrayList<Connection>(); Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>(); for (Connection connection : connections) { String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS); if (serviceStatus != null) { if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) { serviceOffConnections.add(connection); } } else { serviceOnConnections.add(connection); } } filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections); filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections); return filteredConnections; }\n\n    ### Response:", "ground_truth": "Filter connections to monitor\n\n@param connections", "predict": "/**\r\n     * This method filters the list of connections based on the service status attribute.\r\n     *\r\n     * @param connections the list of connections to filter\r\n     * @return a map containing two lists of connections, one for connections with service status ON and the other for connections with service status OFF\r\n     */\r\n    @Override public Map<String, List<Connection>> filter(List<Connection> connections) {\r\n        List<Connection> serviceOnConnections = new ArrayList<Connection>();\r\n        List<Connection> serviceOffConnections = new ArrayList<Connection>();\r\n        Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>();\r\n        for (Connection connection : connections) {\r\n            String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS);\r\n            if (serviceStatus != null) {\r\n                if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) {\r\n                    serviceOffConnections.add(connection);\r\n                }\r\n            } else {\r\n                serviceOnConnections.add(connection);"}, {"ID": 433, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) { try { if (null != connPools && !connPools.isEmpty()) { Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools .entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter .next(); String poolKey = entry.getKey(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); List<Connection> connections = pool.getAll(); Map<String, List<Connection>> filteredConnectons = this.filter(connections); List<Connection> serviceOnConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_ON); List<Connection> serviceOffConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_OFF); if (serviceOnConnections.size() > CONNECTION_THRESHOLD) { Connection freshSelectConnect = serviceOnConnections.get(random .nextInt(serviceOnConnections.size())); freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF); Connection lastSelectConnect = freshSelectConnections.remove(poolKey); freshSelectConnections.put(poolKey, freshSelectConnect); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } else { if (freshSelectConnections.containsKey(poolKey)) { Connection lastSelectConnect = freshSelectConnections.remove(poolKey); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } if (logger.isInfoEnabled()) { logger .info( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD); } } for (Connection offConn : serviceOffConnections) { if (offConn.isFine()) { offConn.close(); } } } } } catch (Exception e) { logger.error(\"ScheduledDisconnectStrategy monitor error\", e); } }\n\n    ### Response:", "ground_truth": "Monitor connections and close connections with status is off\n\n@param connPools", "predict": "/**\r\n     * This method is used to monitor the connection pool and select the connections based on the service status.\r\n     *\r\n     * @param connPools the connection pool map\r\n     */\r\n    @Override\r\n    public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) {\r\n        try {\r\n            if (null != connPools && !connPools.isEmpty()) {\r\n                Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools.entrySet().iterator();\r\n                while (iter.hasNext()) {\r\n                    Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter.next();\r\n                    String poolKey = entry.getKey();\r\n                    ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger);\r\n                    List<Connection> connections = pool.getAll();\r\n                    Map<String, List<Connection>> filteredConnectons = this.filter(connections);\r\n                    List<Connection> serviceOnConnections = filteredConnectons.get(Configs.CONN"}, {"ID": 434, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException { if (null != lastSelectConnect) { if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { Thread.sleep(RETRY_DETECT_PERIOD); if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { if (logger.isInfoEnabled()) { logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel())); } } } } }\n\n    ### Response:", "ground_truth": "close the connection of the fresh select connections\n\n@param lastSelectConnect\n@param serviceOffConnections\n@throws InterruptedException", "predict": "/**\r\n     * Close the fresh select connections and add them to the service off connections list.\r\n     *\r\n     * @param lastSelectConnect the last select connection\r\n     * @param serviceOffConnections the service off connections list\r\n     * @throws InterruptedException if interrupted while waiting for the connection to be closed\r\n     */\r\n    private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException {\r\n        if (null != lastSelectConnect) {\r\n            if (lastSelectConnect.isInvokeFutureMapFinish()) {\r\n                serviceOffConnections.add(lastSelectConnect);\r\n            } else {\r\n                Thread.sleep(RETRY_DETECT_PERIOD);\r\n                if (lastSelectConnect.isInvokeFutureMapFinish()) {\r\n                    serviceOffConnections.add(lastSelectConnect);\r\n                } else {\r\n                    if (logger.isInfoEnabled()) {\r\n                        logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 435, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean getBool(String key, String defaultValue) { return Boolean.parseBoolean(System.getProperty(key, defaultValue)); }\n\n    ### Response:", "ground_truth": "~~~ public helper methods to retrieve system property", "predict": "/**\r\n     * This method retrieves a boolean value from the system properties using the specified key.\r\n     * If the key is not found in the system properties, the default value is returned.\r\n     * \r\n     * @param key the key to look up in the system properties\r\n     * @param defaultValue the default value to return if the key is not found in the system properties\r\n     * @return the boolean value associated with the key in the system properties, or the default value if the key is not found\r\n     */\r\n    public static boolean getBool(String key, String defaultValue) {\r\n        return Boolean.parseBoolean(System.getProperty(key, defaultValue));\r\n    }"}, {"ID": 436, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void infoLog(String format, String addr) { if (logger.isInfoEnabled()) { if (StringUtils.isNotEmpty(addr)) { logger.info(format, addr); } else { logger.info(format, \"UNKNOWN-ADDR\"); } } }\n\n    ### Response:", "ground_truth": "print info log\n@param format\n@param addr", "predict": "/**\r\n     * Logs the given message with the given address in the INFO level.\r\n     * \r\n     * @param format the message format\r\n     * @param addr the address to log\r\n     */\r\n    private void infoLog(String format, String addr) {\r\n        if (logger.isInfoEnabled()) {\r\n            if (StringUtils.isNotEmpty(addr)) {\r\n                logger.info(format, addr);\r\n            } else {\r\n                logger.info(format, \"UNKNOWN-ADDR\");\r\n            }\r\n        }\r\n    }"}, {"ID": 437, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isRequestTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; }\n\n    ### Response:", "ground_truth": "whether this request already timeout\n\n@return", "predict": "/**\r\n     * This method checks if the request has timed out based on the timeout value set in the request.\r\n     *\r\n     * @return true if the request has timed out, false otherwise.\r\n     */\r\n    public boolean isRequestTimeout() {\r\n        if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }"}, {"ID": 438, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public UserProcessor<?> getUserProcessor(String className) { return StringUtils.isBlank(className) ? null : this.userProcessors.get(className); }\n\n    ### Response:", "ground_truth": "Get user processor for class name.\n\n@param className\n@return", "predict": "/**\r\n     * Returns the UserProcessor instance for the given class name.\r\n     * \r\n     * @param className the class name of the UserProcessor to retrieve\r\n     * @return the UserProcessor instance for the given class name, or null if no such processor exists\r\n     */\r\n    public UserProcessor<?> getUserProcessor(String className) {\r\n        return StringUtils.isBlank(className) ? null : this.userProcessors.get(className);\r\n    }"}, {"ID": 439, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; }\n\n    ### Response:", "ground_truth": "get one connection randomly\n\n@param conns\n@return", "predict": "/**\r\n     * This method randomly selects a connection from the given list of connections.\r\n     * It will keep trying to select a connection until it finds one that is fine or reaches the maximum number of tries.\r\n     * If it reaches the maximum number of tries and still hasn't found a fine connection, it will return null.\r\n     * \r\n     * @param conns the list of connections to select from\r\n     * @return a randomly selected connection that is fine or null if no such connection is found\r\n     */\r\n    private Connection randomGet(List<Connection> conns) {\r\n        // code goes here\r\n    }"}, {"ID": 440, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; }\n\n    ### Response:", "ground_truth": "get and use default if not found\n\n@param key\n@param defaultIfNotFound\n@param \n@return", "predict": "/**\r\n     * Retrieves the value associated with the given key from the context. If the key is not found, the default value is returned.\r\n     * \r\n     * @param key the key to retrieve the value for\r\n     * @param defaultIfNotFound the default value to return if the key is not found\r\n     * @return the value associated with the key, or the default value if the key is not found\r\n     */\r\n    @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; }"}, {"ID": 441, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getProperty(String key) { if (properties == null) { return null; } return properties.getProperty(key); }\n\n    ### Response:", "ground_truth": "Get property value according to property key\n\n@param key\n@return property value", "predict": "/**\r\n     * This method retrieves the value of a property with the given key from the properties file.\r\n     * \r\n     * @param key The key of the property to retrieve.\r\n     * @return The value of the property with the given key, or null if the property does not exist.\r\n     */\r\n    public String getProperty(String key) {\r\n        if (properties == null) {\r\n            return null;\r\n        }\r\n        return properties.getProperty(key);\r\n    }"}, {"ID": 442, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException { preProcess(responseCommand, addr); if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return toResponseObject(responseCommand); } else { String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId()); logger.warn(msg); if (responseCommand.getCause() != null) { throw new InvokeException(msg, responseCommand.getCause()); } else { throw new InvokeException(msg + \", please check the server log for more.\"); } } }\n\n    ### Response:", "ground_truth": "Analyze the response command and generate the response object.\n\n@param responseCommand response command\n@param addr response address\n@return response object", "predict": "/**\r\n     * Resolve the response object based on the response command and the address.\r\n     *\r\n     * @param responseCommand the response command\r\n     * @param addr the address\r\n     * @return the response object\r\n     * @throws RemotingException if any error occurs during the process\r\n     */\r\n    public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException {\r\n        preProcess(responseCommand, addr);\r\n        if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) {\r\n            return toResponseObject(responseCommand);\r\n        } else {\r\n            String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId());\r\n            logger.warn(msg);\r\n            if (responseCommand.getCause() != null) {\r\n                throw new InvokeException(msg, responseCommand.getCause());\r\n            } else {\r\n                throw new InvokeException(msg + \", please check the server log for more.\");\r\n            }\r\n        }\r\n    }"}, {"ID": 443, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); }\n\n    ### Response:", "ground_truth": "Convert remoting response command to application response object.", "predict": "/**\r\n     * Converts a ResponseCommand to a response object.\r\n     *\r\n     * @param responseCommand the ResponseCommand to convert\r\n     * @return the response object\r\n     * @throws CodecException if the response cannot be deserialized\r\n     */\r\n    private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException {\r\n        RpcResponseCommand response = (RpcResponseCommand) responseCommand;\r\n        response.deserialize();\r\n        return response.getResponseObject();\r\n    }"}, {"ID": 444, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; }\n\n    ### Response:", "ground_truth": "Convert remoting response command to throwable if it is a throwable, otherwise return null.", "predict": "/**\r\n     * Converts a ResponseCommand to a Throwable object.\r\n     *\r\n     * @param responseCommand the ResponseCommand to convert\r\n     * @return the Throwable object, or null if the response does not contain an exception\r\n     * @throws CodecException if the response cannot be deserialized\r\n     */\r\n    private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException {\r\n        RpcResponseCommand resp = (RpcResponseCommand) responseCommand;\r\n        resp.deserialize();\r\n        Object ex = resp.getResponseObject();\r\n        if (ex != null && ex instanceof Throwable) {\r\n            return (Throwable) ex;\r\n        }\r\n        return null;\r\n    }"}, {"ID": 445, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } }\n\n    ### Response:", "ground_truth": "Detail your error msg with the error msg returned from response command", "predict": "/**\r\n     * Generate the detailed error message based on the client error message and server error message.\r\n     *\r\n     * @param clientErrMsg the client error message.\r\n     * @param responseCommand the response command.\r\n     * @return the detailed error message.\r\n     */\r\n    private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) {\r\n        RpcResponseCommand resp = (RpcResponseCommand) responseCommand;\r\n        if (StringUtils.isNotBlank(resp.getErrorMsg())) {\r\n            return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg());\r\n        } else {\r\n            return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg);\r\n        }\r\n    }"}, {"ID": 446, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; }\n\n    ### Response:", "ground_truth": "create server exception using error msg and fill the stack trace using the stack trace of throwable.\n\n@param t the origin throwable to fill the stack trace of rpc server exception\n@param errMsg additional error msg, null is allowed\n@return an instance of RpcServerException", "predict": "/**\r\n     * Creates a new RpcServerException with the given error message and the stack trace of the given Throwable.\r\n     *\r\n     * @param t the Throwable whose stack trace will be used to create the RpcServerException\r\n     * @param errMsg the error message to be included in the RpcServerException\r\n     * @return a new RpcServerException with the given error message and the stack trace of the given Throwable\r\n     */\r\n    private RpcServerException createServerException(Throwable t, String errMsg) {\r\n        String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg);\r\n        RpcServerException e = new RpcServerException(formattedErrMsg);\r\n        e.setStackTrace(t.getStackTrace());\r\n        return e;\r\n    }"}, {"ID": 447, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } }\n\n    ### Response:", "ground_truth": "print trace log\n@param traceId\n@param invokeContext", "predict": "/**\r\n     * This method is used to print the connection trace log.\r\n     * \r\n     * @param logger\r\n     *            The logger object to log the connection trace log.\r\n     * @param traceId\r\n     *            The trace id of the connection.\r\n     * @param invokeContext\r\n     *            The invoke context of the connection.\r\n     */\r\n    public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) {\r\n        // TODO: Implement the method logic.\r\n    }"}, {"ID": 448, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) { return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory); }\n\n    ### Response:", "ground_truth": "Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.\n\n@param nThreads\n@param threadFactory\n@return an EventLoopGroup suitable for the current platform", "predict": "/**\r\n * Creates a new {@link EventLoopGroup} based on the available transport types.\r\n *\r\n * @param nThreads the number of threads to use in the event loop group\r\n * @param threadFactory the factory to use when creating new threads in the event loop group\r\n * @return a new {@link EventLoopGroup} based on the available transport types\r\n */\r\npublic static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) {\r\n    return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory);\r\n}"}, {"ID": 449, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); }\n\n    ### Response:", "ground_truth": "Parse the remote address of the channel.\n\n@param channel\n@return", "predict": "/**\r\n     * Parses the remote address of the given channel.\r\n     * \r\n     * @param channel the channel to parse the remote address from\r\n     * @return the parsed remote address or an empty string if the channel is null or the remote address is null or empty\r\n     */\r\n    public static String parseRemoteAddress(final Channel channel) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 450, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); }\n\n    ### Response:", "ground_truth": "Parse the local address of the channel.\n\n@param channel\n@return", "predict": "/**\r\n     * Parses the local address of the given channel.\r\n     * \r\n     * @param channel the channel to parse the local address from\r\n     * @return the parsed local address or an empty string if the channel is null or the local address is null or empty\r\n     */\r\n    public static String parseLocalAddress(final Channel channel) {\r\n        // implementation goes here\r\n    }"}, {"ID": 451, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the remote host ip of the channel.\n\n@param channel\n@return", "predict": "/**\r\n     * Parses the remote IP address from the given channel.\r\n     * \r\n     * @param channel the channel to parse the remote IP address from\r\n     * @return the remote IP address as a string, or an empty string if the channel is null or the remote address is null\r\n     */\r\n    public static String parseRemoteIP(final Channel channel) {\r\n        // implementation goes here\r\n    }"}, {"ID": 452, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the remote hostname of the channel.\n\nNote: take care to use this method, for a reverse name lookup takes uncertain time in {@link InetAddress#getHostName}.\n\n@param channel\n@return", "predict": "/**\r\n     * Parses the remote hostname from the given channel.\r\n     * \r\n     * @param channel the channel to parse the remote hostname from\r\n     * @return the remote hostname or an empty string if the channel is null or the remote address is null\r\n     */\r\n    public static String parseRemoteHostName(final Channel channel) {\r\n        // implementation goes here\r\n    }"}, {"ID": 453, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the local host ip of the channel.\n\n@param channel\n@return", "predict": "/**\r\n     * Parses the local IP address from the given channel.\r\n     * \r\n     * @param channel the channel to parse the local IP address from\r\n     * @return the local IP address as a string, or an empty string if the channel is null or the local address is null\r\n     */\r\n    public static String parseLocalIP(final Channel channel) {\r\n        // implementation goes here\r\n    }"}, {"ID": 454, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; }\n\n    ### Response:", "ground_truth": "Parse the remote host port of the channel.\n\n@param channel\n@return int", "predict": "/**\r\n     * Parses the remote port from the given channel.\r\n     * \r\n     * @param channel the channel to parse the remote port from\r\n     * @return the remote port, or -1 if the channel is null or the remote address is null\r\n     */\r\n    public static int parseRemotePort(final Channel channel) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 455, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; }\n\n    ### Response:", "ground_truth": "Parse the local host port of the channel.\n\n@param channel\n@return int", "predict": "/**\r\n     * Parses the local port from the given channel's local address.\r\n     * \r\n     * @param channel the channel to parse the local port from\r\n     * @return the local port, or -1 if the channel is null or the local address is null\r\n     */\r\n    public static int parseLocalPort(final Channel channel) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 456, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String parseSocketAddressToHostIp(SocketAddress socketAddress) { final InetSocketAddress addrs = (InetSocketAddress) socketAddress; if (addrs != null) { InetAddress addr = addrs.getAddress(); if (null != addr) { return addr.getHostAddress(); } } return StringUtils.EMPTY; }\n\n    ### Response:", "ground_truth": "Parse the host ip of socket address.\n\ne.g. /127.0.0.1:1234 -> 127.0.0.1\n\n@param socketAddress\n@return String", "predict": "/**\r\n     * This method takes a SocketAddress object and returns the IP address of the host.\r\n     * \r\n     * @param socketAddress the SocketAddress object to parse\r\n     * @return the IP address of the host as a string\r\n     */\r\n    public static String parseSocketAddressToHostIp(SocketAddress socketAddress) {\r\n        final InetSocketAddress addrs = (InetSocketAddress) socketAddress;\r\n        if (addrs != null) {\r\n            InetAddress addr = addrs.getAddress();\r\n            if (null != addr) {\r\n                return addr.getHostAddress();\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    }"}, {"ID": 457, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.addIfAbsent(connection); if (res) { connection.increaseRef(); } }\n\n    ### Response:", "ground_truth": "add a connection\n\n@param connection", "predict": "/**\r\n     * Adds a connection to the set of connections managed by this pool.\r\n     * \r\n     * @param connection the connection to add\r\n     */\r\n    public void add(Connection connection) {\r\n        markAccess();\r\n        if (null == connection) {\r\n            return;\r\n        }\r\n        boolean res = this.conns.addIfAbsent(connection);\r\n        if (res) {\r\n            connection.increaseRef();\r\n        }\r\n    }"}, {"ID": 458, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } }\n\n    ### Response:", "ground_truth": "removeAndTryClose a connection\n\n@param connection", "predict": "/**\r\n     * Removes the given connection from the list of connections and tries to close it if it has no more references.\r\n     * \r\n     * @param connection the connection to remove and try to close\r\n     */\r\n    public void removeAndTryClose(Connection connection) {\r\n        if (null == connection) {\r\n            return;\r\n        }\r\n        boolean res = this.conns.remove(connection);\r\n        if (res) {\r\n            connection.decreaseRef();\r\n        }\r\n        if (connection.noRef()) {\r\n            connection.close();\r\n        }\r\n    }"}, {"ID": 459, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Connection get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } }\n\n    ### Response:", "ground_truth": "get a connection\n\n@return", "predict": "/**\r\n     * Returns a connection from the pool.\r\n     * \r\n     * @return a connection from the pool\r\n     */\r\n    public Connection get() {\r\n        markAccess();\r\n        if (null != this.conns) {\r\n            List<Connection> snapshot = new ArrayList<Connection>(this.conns);\r\n            if (snapshot.size() > 0) {\r\n                return this.strategy.select(snapshot);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }"}, {"ID": 460, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerCustomSerializer(String className, CustomSerializer serializer) { CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Register custom serializer for class name.\n\n@param className\n@param serializer\n@return", "predict": "/**\r\n     * Registers a custom serializer for a given class.\r\n     *\r\n     * @param className the name of the class to register the serializer for.\r\n     * @param serializer the custom serializer to register.\r\n     * @throws RuntimeException if a custom serializer has already been registered for the given class.\r\n     */\r\n    public static void registerCustomSerializer(String className, CustomSerializer serializer) {\r\n        CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer);\r\n        if (prevSerializer != null) {\r\n            throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName());\r\n        }\r\n    }"}, {"ID": 461, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CustomSerializer getCustomSerializer(String className) { if (!classCustomSerializer.isEmpty()) { return classCustomSerializer.get(className); } return null; }\n\n    ### Response:", "ground_truth": "Get the custom serializer for class name.\n\n@param className\n@return", "predict": "/**\r\n     * This method returns the CustomSerializer object for the given class name.\r\n     * \r\n     * @param className\r\n     *            The name of the class for which the CustomSerializer object is required.\r\n     * @return The CustomSerializer object for the given class name, or null if no such object exists.\r\n     */\r\n    public static CustomSerializer getCustomSerializer(String className) {\r\n        if (!classCustomSerializer.isEmpty()) {\r\n            return classCustomSerializer.get(className);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 462, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) { CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } }\n\n    ### Response:", "ground_truth": "Register custom serializer for command code.\n\n@param code\n@param serializer\n@return", "predict": "/**\r\n     * Registers a custom serializer for a specific command code.\r\n     *\r\n     * @param code the command code for which the custom serializer is being registered.\r\n     * @param serializer the custom serializer to be registered.\r\n     * @throws RuntimeException if a custom serializer has already been registered for the given command code.\r\n     */\r\n    public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) {\r\n        CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer);\r\n        if (prevSerializer != null) {\r\n            throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName());\r\n        }\r\n    }"}, {"ID": 463, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CustomSerializer getCustomSerializer(CommandCode code) { if (!commandCustomSerializer.isEmpty()) { return commandCustomSerializer.get(code); } return null; }\n\n    ### Response:", "ground_truth": "Get the custom serializer for command code.\n\n@param code\n@return", "predict": "/**\r\n     * This method returns the custom serializer for the given command code.\r\n     * \r\n     * @param code The command code for which the custom serializer is required.\r\n     * @return The custom serializer for the given command code, or null if no custom serializer is found.\r\n     */\r\n    public static CustomSerializer getCustomSerializer(CommandCode code) {\r\n        if (!commandCustomSerializer.isEmpty()) {\r\n            return commandCustomSerializer.get(code);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 464, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager.conn_monitor_initial_delay(); /** period of schedule task, unit: ms*/ long period = ConfigManager.conn_monitor_period(); this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy()); MonitorTask monitorTask = new MonitorTask(); this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS); }\n\n    ### Response:", "ground_truth": "Start schedule task", "predict": "/**\r\n * This method starts the connection monitor task.\r\n * \r\n * @param initialDelay - initial delay to execute schedule task, unit: ms\r\n * @param period - period of schedule task, unit: ms\r\n */\r\npublic void start(long initialDelay, long period) {\r\n    this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy());\r\n    MonitorTask monitorTask = new MonitorTask();\r\n    this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS);\r\n}"}, {"ID": 465, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isConnected(String remoteAddr) { Url url = this.rpcRemoting.addressParser.parse(remoteAddr); return this.isConnected(url); }\n\n    ### Response:", "ground_truth": "check whether a client address connected\n\n@param remoteAddr\n@return", "predict": "/**\r\n     * Checks if the client is connected to the specified remote address.\r\n     * \r\n     * @param remoteAddr the remote address to check\r\n     * @return true if the client is connected to the remote address, false otherwise\r\n     */\r\n    public boolean isConnected(String remoteAddr) {\r\n        // TODO: implement this method\r\n    }"}, {"ID": 466, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void initWriteBufferWaterMark() { int lowWaterMark = this.netty_buffer_low_watermark(); int highWaterMark = this.netty_buffer_high_watermark(); if (lowWaterMark > highWaterMark) { throw new IllegalArgumentException( String .format( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\", highWaterMark, lowWaterMark)); } else { logger.warn( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\", lowWaterMark, highWaterMark); } this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( lowWaterMark, highWaterMark)); }\n\n    ### Response:", "ground_truth": "init netty write buffer water mark", "predict": "/**\r\n     * Initializes the write buffer watermark for the Netty channel.\r\n     * \r\n     * @throws IllegalArgumentException if the high water mark is smaller than the low water mark\r\n     */\r\n    private void initWriteBufferWaterMark() {\r\n        int lowWaterMark = this.netty_buffer_low_watermark();\r\n        int highWaterMark = this.netty_buffer_high_watermark();\r\n        if (lowWaterMark > highWaterMark) {\r\n            throw new IllegalArgumentException(\r\n                    String.format(\r\n                            \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\",\r\n                            highWaterMark, lowWaterMark));\r\n        } else {\r\n            logger.warn(\r\n                    \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\",\r\n                    lowWaterMark, highWaterMark);\r\n        }\r\n        this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(lowWaterMark, highWaterMark));\r\n    }"}, {"ID": 467, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } }\n\n    ### Response:", "ground_truth": "Get a frame with a specific opcode\n\n@param opcode the opcode representing the frame\n@return the frame with a specific opcode", "predict": "/**\r\n * Returns a FramedataImpl1 object based on the supplied opcode.\r\n * \r\n * @param opcode the opcode for the FramedataImpl1 object to be returned\r\n * @return a FramedataImpl1 object based on the supplied opcode\r\n * @throws IllegalArgumentException if the supplied opcode is null or invalid\r\n */\r\npublic static FramedataImpl1 get(Opcode opcode) {\r\n    if (opcode == null) {\r\n        throw new IllegalArgumentException(\"Supplied opcode cannot be null\");\r\n    }\r\n    switch (opcode) {\r\n        case PING:\r\n            return new PingFrame();\r\n        case PONG:\r\n            return new PongFrame();\r\n        case TEXT:\r\n            return new TextFrame();\r\n        case BINARY:\r\n            return new BinaryFrame();\r\n        case CLOSING:\r\n            return new CloseFrame();\r\n        case CONTINUOUS:\r\n            return new ContinuousFrame();\r\n        default:\r\n            throw new IllegalArgumentException(\"Supplied opcode is invalid\");\r\n    }\r\n}"}, {"ID": 468, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if( buffer == null ) { if( sockchannel instanceof WrappedByteChannel ) { c = (WrappedByteChannel) sockchannel; if( c.isNeedWrite() ) { c.writeMore(); } } } else { do {// FIXME writing as much as possible is unfair!! /*int written = */sockchannel.write( buffer ); if( buffer.remaining() > 0 ) { return false; } else { ws.outQueue.poll(); // Buffer finished. Remove it. buffer = ws.outQueue.peek(); } } while ( buffer != null ); } if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {// ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); }\n\n    ### Response:", "ground_truth": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "predict": "/**\r\n     * This method is used to write data to the socket channel.\r\n     * \r\n     * @param ws\r\n     *            The WebSocketImpl object.\r\n     * @param sockchannel\r\n     *            The socket channel to write to.\r\n     * @return True if the write was successful, false otherwise.\r\n     * @throws IOException\r\n     *             If an I/O error occurs.\r\n     */\r\n    public static boolean batch(WebSocketImpl ws, ByteChannel sockchannel) throws IOException {\r\n        if (ws == null) {\r\n            return false;\r\n        }\r\n        ByteBuffer buffer = ws.outQueue.peek();\r\n        WrappedByteChannel c = null;\r\n        if (buffer == null) {\r\n            if (sockchannel instanceof WrappedByteChannel) {\r\n                c = (WrappedByteChannel) sockchannel;\r\n                if (c.isNeedWrite()) {\r\n                    c.writeMore();\r\n                }\r\n            }\r\n        } else {\r\n            do {\r\n                // FIXME writing as much as possible is unfair!!\r\n                int written = sockchannel.write(buffer);\r\n                if (buffer."}, {"ID": 469, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setCode(int code) { this.code = code; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = \"\"; } updatePayload(); }\n\n    ### Response:", "ground_truth": "Set the close code for this close frame\n@param code the close code", "predict": "/**\r\n     * Sets the code of the close frame.\r\n     *\r\n     * @param code the code of the close frame.\r\n     */\r\n    public void setCode(int code) {\r\n        // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) {\r\n            this.code = CloseFrame.NOCODE;\r\n            this.reason = \"\";\r\n        }\r\n        updatePayload();\r\n    }"}, {"ID": 470, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position( payload.position() + 2 ); reason = Charsetfunctions.stringUtf8( payload ); } catch ( IllegalArgumentException e ) { throw new InvalidDataException( CloseFrame.NO_UTF8 ); } finally { payload.position( mark ); } }\n\n    ### Response:", "ground_truth": "Validate the payload to valid utf8\n@param mark the current mark\n@param payload the current payload\n@throws InvalidDataException the current payload is not a valid utf8", "predict": "/**\r\n     * Validates the UTF-8 encoding of the payload.\r\n     * \r\n     * @param payload\r\n     *            the payload to validate\r\n     * @param mark\r\n     *            the position to reset the buffer to after validation\r\n     * @throws InvalidDataException\r\n     *             if the payload is not valid UTF-8\r\n     */\r\n    private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException {\r\n        try {\r\n            payload.position(payload.position() + 2);\r\n            reason = Charsetfunctions.stringUtf8(payload);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new InvalidDataException(CloseFrame.NO_UTF8);\r\n        } finally {\r\n            payload.position(mark);\r\n        }\r\n    }"}, {"ID": 471, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); }\n\n    ### Response:", "ground_truth": "Update the payload to represent the close code and the reason", "predict": "/**\r\n     * Updates the payload of the message with the given reason and code.\r\n     * \r\n     * @param reason the reason for the update\r\n     * @param code the code for the update\r\n     */\r\n    private void updatePayload(String reason, int code) {\r\n        byte[] by = Charsetfunctions.utf8Bytes(reason);\r\n        ByteBuffer buf = ByteBuffer.allocate(4);\r\n        buf.putInt(code);\r\n        buf.position(2);\r\n        ByteBuffer pay = ByteBuffer.allocate(2 + by.length);\r\n        pay.put(buf);\r\n        pay.put(by);\r\n        pay.rewind();\r\n        super.setPayload(pay);\r\n    }"}, {"ID": 472, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; }\n\n    ### Response:", "ground_truth": "Check if the requested protocol is part of this draft\n@param requestedProtocol the requested protocol\n@return MATCHED if it is matched, otherwise NOT_MATCHED", "predict": "/**\r\n     * Checks if the provided protocol is supported by any of the known protocols.\r\n     * \r\n     * @param requestedProtocol the protocol provided by the peer\r\n     * @return the handshake state\r\n     */\r\n    private HandshakeState containsRequestedProtocol(String requestedProtocol) {\r\n        for( IProtocol knownProtocol : knownProtocols ) {\r\n            if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) {\r\n                protocol = knownProtocol;\r\n                log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol);\r\n                return HandshakeState.MATCHED;\r\n            }\r\n        }\r\n        return HandshakeState.NOT_MATCHED;\r\n    }"}, {"ID": 473, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if( length > Integer.MAX_VALUE ) { log.trace(\"Limit exedeed: Payloadsize is to big...\"); throw new LimitExceededException(\"Payloadsize is to big...\"); } if( length > maxFrameSize) { log.trace( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize, length); throw new LimitExceededException( \"Payload limit reached.\", maxFrameSize ); } if( length < 0 ) { log.trace(\"Limit underflow: Payloadsize is to little...\"); throw new LimitExceededException(\"Payloadsize is to little...\"); } }\n\n    ### Response:", "ground_truth": "Check if the frame size exceeds the allowed limit\n@param length the current payload length\n@throws LimitExceededException if the payload length is to big", "predict": "/**\r\n     * This method checks the length of the payload and throws an exception if it exceeds the maximum allowed frame size or is negative.\r\n     * \r\n     * @param length the length of the payload to be checked\r\n     * @throws LimitExceededException if the length exceeds the maximum allowed frame size or is negative\r\n     */\r\n    private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException;"}, {"ID": 474, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } }\n\n    ### Response:", "ground_truth": "Check if the max packet size is smaller than the real packet size\n@param maxpacketsize the max packet size\n@param realpacketsize the real packet size\n@throws IncompleteException if the maxpacketsize is smaller than the realpackagesize", "predict": "/**\r\n     * Translates the maximum packet size and the real packet size into a single frame check packet size.\r\n     * \r\n     * @param maxpacketsize the maximum packet size\r\n     * @param realpacketsize the real packet size\r\n     * @throws IncompleteException if the real packet size is greater than the maximum packet size\r\n     */\r\n    private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException {\r\n        if( maxpacketsize < realpacketsize ) {\r\n            log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" );\r\n            throw new IncompleteException( realpacketsize );\r\n        }\r\n    }"}, {"ID": 475, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String generateFinalKey( String in ) { String seckey = in.trim(); String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance( \"SHA1\" ); } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException( e ); } return Base64.encodeBytes( sh1.digest( acc.getBytes() ) ); }\n\n    ### Response:", "ground_truth": "Generate a final key from a input string\n@param in the input string\n@return a final key", "predict": "/**\r\n     * This method generates the final key for the WebSocket connection.\r\n     * \r\n     * @param in The input string to generate the final key from.\r\n     * @return The final key as a Base64 encoded string.\r\n     */\r\n    private String generateFinalKey( String in ) {\r\n        // Trim the input string\r\n        String seckey = in.trim();\r\n        // Concatenate the input string with the magic GUID\r\n        String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\r\n        // Get a SHA1 MessageDigest instance\r\n        MessageDigest sh1;\r\n        try {\r\n            sh1 = MessageDigest.getInstance( \"SHA1\" );\r\n        } catch ( NoSuchAlgorithmException e ) {\r\n            throw new IllegalStateException( e );\r\n        }\r\n        // Generate the final key as a Base64 encoded string\r\n        return Base64.encodeBytes( sh1.digest( acc.getBytes() ) );\r\n    }"}, {"ID": 476, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if( curop != Opcode.CONTINUOUS ) { processFrameIsNotFin(frame); } else if( frame.isFin() ) { processFrameIsFin(webSocketImpl, frame); } else if( currentContinuousFrame == null ) { log.error( \"Protocol error: Continuous frame sequence was not started.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } //Check if the whole payload is valid utf8, when the opcode indicates a text if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) { log.error( \"Protocol error: Payload is not UTF8\" ); throw new InvalidDataException( CloseFrame.NO_UTF8 ); } //Checking if the current continuous frame contains a correct payload with the other frames combined if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) { addToBufferList(frame.getPayloadData()); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a continuous frame or the fin bit is not set\n@param webSocketImpl the websocket implementation to use\n@param frame the current frame\n@param curop the current Opcode\n@throws InvalidDataException if there is a protocol error", "predict": "/**\r\n     * This method processes a frame that is not a continuous frame and is not the final frame of a continuous frame sequence.\r\n     * \r\n     * @param frame The frame to be processed.\r\n     * @throws InvalidDataException If the frame is invalid.\r\n     */\r\n    private void processFrameIsNotFin(Framedata frame) throws InvalidDataException {\r\n        //TODO: Implement logic for processing non-final frames\r\n    }\r\n\r\n    /**\r\n     * This method processes a frame that is the final frame of a continuous frame sequence.\r\n     * \r\n     * @param webSocketImpl The WebSocketImpl instance that received the frame.\r\n     * @param frame The frame to be processed.\r\n     * @throws InvalidDataException If the frame is invalid.\r\n     */\r\n    private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException {\r\n        //TODO: Implement logic for processing final frames\r\n    }\r\n\r\n    /**\r\n     * This method adds a frame to the buffer list of the current continuous frame sequence.\r\n     * \r\n     * @param payload The payload of the frame to be added."}, {"ID": 477, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a binary frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "/**\r\n     * Processes a binary frame received from the WebSocket.\r\n     *\r\n     * @param webSocketImpl\r\n     *            The WebSocketImpl instance that received the frame.\r\n     * @param frame\r\n     *            The binary frame to process.\r\n     */\r\n    private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) {\r\n        try {\r\n            webSocketImpl.getWebSocketListener().onWebsocketMessage(webSocketImpl, frame.getPayloadData());\r\n        } catch (RuntimeException e) {\r\n            logRuntimeException(webSocketImpl, e);\r\n        }\r\n    }"}, {"ID": 478, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { log.error( \"Runtime exception during onWebsocketMessage\", e ); webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e ); }\n\n    ### Response:", "ground_truth": "Log the runtime exception to the specific WebSocketImpl\n@param webSocketImpl the implementation of the websocket\n@param e the runtime exception", "predict": "/**\r\n     * Logs a runtime exception that occurred during the onWebsocketMessage method of a WebSocketImpl object.\r\n     * \r\n     * @param webSocketImpl the WebSocketImpl object that generated the exception\r\n     * @param e the runtime exception that occurred\r\n     */\r\n    private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) {\r\n        log.error(\"Runtime exception during onWebsocketMessage\", e);\r\n        webSocketImpl.getWebSocketListener().onWebsocketError(webSocketImpl, e);\r\n    }"}, {"ID": 479, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a text frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "/**\r\n     * Processes the text frame received from the WebSocket client.\r\n     *\r\n     * @param webSocketImpl The WebSocketImpl instance that received the frame.\r\n     * @param frame The received frame.\r\n     * @throws InvalidDataException If the frame is not a text frame.\r\n     */\r\n    private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException {\r\n        try {\r\n            webSocketImpl.getWebSocketListener().onWebsocketMessage(webSocketImpl, Charsetfunctions.stringUtf8(frame.getPayloadData()));\r\n        } catch (RuntimeException e) {\r\n            logRuntimeException(webSocketImpl, e);\r\n        }\r\n    }"}, {"ID": 480, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if( currentContinuousFrame == null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); }\n\n    ### Response:", "ground_truth": "Process the frame if it is the last frame\n@param webSocketImpl the websocket impl\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "/**\n     * Processes a received frame as part of a continuous frame sequence.\n     *\n     * @param webSocketImpl\n     *            The WebSocketImpl instance.\n     * @param frame\n     *            The received frame.\n     * @throws InvalidDataException\n     *             If the received frame is invalid.\n     */\n    private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException {\n        // TODO: Implement method\n    }"}, {"ID": 481, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if( currentContinuousFrame != null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" ); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); }\n\n    ### Response:", "ground_truth": "Process the frame if it is not the last frame\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": "/**\r\n     * Processes a frame that is not a final frame of a continuous fragmented message.\r\n     * \r\n     * @param frame The frame to process.\r\n     * @throws InvalidDataException If the frame is invalid.\r\n     */\r\n    private void processFrameIsNotFin(Framedata frame) throws InvalidDataException {\r\n        if( currentContinuousFrame != null ) {\r\n            log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" );\r\n            throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" );\r\n        }\r\n        currentContinuousFrame = frame;\r\n        addToBufferList(frame.getPayloadData());\r\n        checkBufferLimit();\r\n    }"}, {"ID": 482, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = \"\"; if( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) { // complete the close handshake by disconnecting webSocketImpl.closeConnection( code, reason, true ); } else { // echo close handshake if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY ) webSocketImpl.close( code, reason, true ); else webSocketImpl.flushAndClose( code, reason, false ); } }\n\n    ### Response:", "ground_truth": "Process the frame if it is a closing frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": "/**\r\n     * Processes a frame that is received after the WebSocket connection has been closed.\r\n     * \r\n     * @param webSocketImpl\r\n     *            the WebSocketImpl instance that received the frame\r\n     * @param frame\r\n     *            the frame that was received\r\n     */\r\n    private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) {\r\n        int code = CloseFrame.NOCODE;\r\n        String reason = \"\";\r\n        if (frame instanceof CloseFrame) {\r\n            CloseFrame cf = (CloseFrame) frame;\r\n            code = cf.getCloseCode();\r\n            reason = cf.getMessage();\r\n        }\r\n        if (webSocketImpl.getReadyState() == ReadyState.CLOSING) {\r\n            // complete the close handshake by disconnecting webSocketImpl.closeConnection(code, reason, true);\r\n        } else {\r\n            // echo close handshake if(getCloseHandshakeType() == CloseHandshakeType.TWOWAY) webSocketImpl.close(code, reason, true);\r\n            // else webSocketImpl.flushAndClose(code, reason,"}, {"ID": 483, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if( totalSize > maxFrameSize ) { clearBufferList(); log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize); throw new LimitExceededException(maxFrameSize); } }\n\n    ### Response:", "ground_truth": "Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size\n@throws LimitExceededException if the current size is bigger than the allowed size", "predict": "/**\r\n     * Checks the buffer limit and throws a LimitExceededException if the limit is exceeded.\r\n     * \r\n     * @throws LimitExceededException if the limit is exceeded.\r\n     */\r\n    private void checkBufferLimit() throws LimitExceededException {\r\n        long totalSize = getByteBufferListSize();\r\n        if (totalSize > maxFrameSize) {\r\n            clearBufferList();\r\n            log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize);\r\n            throw new LimitExceededException(maxFrameSize);\r\n        }\r\n    }"}, {"ID": 484, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate( (int) totalSize ); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put( buffer ); } } resultingByteBuffer.flip(); return resultingByteBuffer; }\n\n    ### Response:", "ground_truth": "Method to generate a full bytebuffer out of all the fragmented frame payload\n@return a bytebuffer containing all the data\n@throws LimitExceededException will be thrown when the totalSize is bigger then Integer.MAX_VALUE due to not being able to allocate more", "predict": "/**\r\n     * This method is used to get the payload from the list of ByteBuffers.\r\n     * It first calculates the total size of all the ByteBuffers in the list.\r\n     * It then creates a new ByteBuffer with the total size and copies all the ByteBuffers into it.\r\n     * Finally, it flips the resulting ByteBuffer and returns it.\r\n     *\r\n     * @return the resulting ByteBuffer with the payload.\r\n     * @throws LimitExceededException if the resulting ByteBuffer exceeds the maximum allowed size.\r\n     */\r\n    private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException {\r\n        // code goes here\r\n    }"}, {"ID": 485, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; }\n\n    ### Response:", "ground_truth": "Get the current size of the resulting bytebuffer in the bytebuffer list\n@return the size as long (to not get an integer overflow)", "predict": "/**\r\n     * This method calculates the total size of all the ByteBuffers in the list.\r\n     * \r\n     * @return the total size of all the ByteBuffers in the list\r\n     */\r\n    private long getByteBufferListSize() {\r\n        long totalSize = 0;\r\n        synchronized (byteBufferList) {\r\n            for (ByteBuffer buffer : byteBufferList) {\r\n                totalSize += buffer.limit();\r\n            }\r\n        }\r\n        return totalSize;\r\n    }"}, {"ID": 486, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return clienthandshake; }\n\n    ### Response:", "ground_truth": "Checking the handshake for the role as server\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": "/**\r\n     * This method is responsible for translating/parsing the request from the CLIENT.\r\n     * \r\n     * @param firstLineTokens - the tokens obtained from the first line of the HTTP request.\r\n     * @param line - the complete HTTP request line.\r\n     * @return - the HandshakeBuilder object containing the translated/parsed request.\r\n     * @throws InvalidHandshakeException - if the request is invalid.\r\n     */\r\n    private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException {\r\n        if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) {\r\n            throw new InvalidHandshakeException(String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0], line));\r\n        }\r\n        if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) {\r\n            throw new InvalidHandshakeException(String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line));\r\n        }\r\n        ClientHandshakeBuilder client"}, {"ID": 487, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] ); return handshake; }\n\n    ### Response:", "ground_truth": "Checking the handshake for the role as client\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": "/**\r\n * Translates the HTTP response from the server into a Handshake object.\r\n *\r\n * @param firstLineTokens the tokens from the first line of the HTTP response\r\n * @param line the entire HTTP response line\r\n * @return the Handshake object representing the HTTP response from the server\r\n * @throws InvalidHandshakeException if the HTTP response is invalid\r\n */\r\nprivate static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException {\r\n    // translating/parsing the response from the SERVER\r\n    if (!\"101\".equals(firstLineTokens[1])) {\r\n        throw new InvalidHandshakeException(String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line));\r\n    }\r\n    if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) {\r\n        throw new InvalidHandshakeException(String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line));\r\n    }"}, {"ID": 488, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time if( socketBuffer.hasRemaining() ) { decodeFrames( socketBuffer ); } else if( tmpHandshakeBytes.hasRemaining() ) { decodeFrames( tmpHandshakeBytes ); } } } }\n\n    ### Response:", "ground_truth": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "predict": "/**\n     * Decodes the incoming data from the socket buffer.\n     * \n     * @param socketBuffer the buffer containing the incoming data.\n     */\n    public void decode(ByteBuffer socketBuffer) {\n        assert (socketBuffer.hasRemaining());\n        log.trace(\"process({}): ({})\", socketBuffer.remaining(),\n                (socketBuffer.remaining() > 1000 ? \"too big to display\" : new String(socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining())));\n\n        if (readyState != ReadyState.NOT_YET_CONNECTED) {\n            if (readyState == ReadyState.OPEN) {\n                decodeFrames(socketBuffer);\n            }\n        } else {\n            if (decodeHandshake(socketBuffer) && (!isClosing() && !isClosed())) {\n                assert (tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining());\n                if (socketBuffer.hasRemaining()) {\n                    decodeFrames(socketBuffer);\n                } else if (tmpHandshakeBytes.hasRemaining"}, {"ID": 489, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); }\n\n    ### Response:", "ground_truth": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem", "predict": "/**\r\n     * This method is responsible for closing the connection due to a wrong handshake.\r\n     * \r\n     * @param exception The exception that caused the wrong handshake.\r\n     */\r\n    private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) {\r\n        write( generateHttpResponseDueToError( 404 ) );\r\n        flushAndClose( exception.getCloseCode(), exception.getMessage(), false );\r\n    }"}, {"ID": 490, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void closeConnectionDueToInternalServerError( RuntimeException exception ) { write( generateHttpResponseDueToError( 500 ) ); flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false ); }\n\n    ### Response:", "ground_truth": "Close the connection if there was a server error by a RuntimeException\n\n@param exception the RuntimeException causing this problem", "predict": "/**\r\n     * This method is responsible for closing the connection due to an internal server error.\r\n     * \r\n     * @param exception The exception that caused the error.\r\n     */\r\n    private void closeConnectionDueToInternalServerError( RuntimeException exception ) {\r\n        write( generateHttpResponseDueToError( 500 ) );\r\n        flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false );\r\n    }"}, {"ID": 491, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Generates an HTTP response due to an error.\r\n     * \r\n     * @param errorCode the error code to generate the response for\r\n     * @return the HTTP response as a ByteBuffer\r\n     */\r\n    private ByteBuffer generateHttpResponseDueToError( int errorCode ) {\r\n        String errorCodeDescription;\r\n        switch(errorCode) {\r\n            case 404:\r\n                errorCodeDescription = \"404 WebSocket Upgrade Failure\";\r\n                break;\r\n            case 500:\r\n            default:\r\n                errorCodeDescription = \"500 Internal Server Error\";\r\n        }\r\n        return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) );\r\n    }"}, {"ID": 492, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); }\n\n    ### Response:", "ground_truth": "Send Text data to the other end.\n\n@throws WebsocketNotConnectedException websocket is not yet connected", "predict": "/**\n     * Sends the specified text to the WebSocket.\n     * \n     * @param text the text to send\n     * @throws IllegalArgumentException if the text is null\n     */\n    @Override\n    public void send(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Cannot send 'null' data to a WebSocketImpl.\");\n        }\n        send(draft.createFrames(text, role == Role.CLIENT));\n    }"}, {"ID": 493, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\"); } try { closeBlocking(); if( writeThread != null ) { this.writeThread.interrupt(); this.writeThread = null; } if( connectReadThread != null ) { this.connectReadThread.interrupt(); this.connectReadThread = null; } this.draft.reset(); if( this.socket != null ) { this.socket.close(); this.socket = null; } } catch ( Exception e ) { onError( e ); engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() ); return; } connectLatch = new CountDownLatch( 1 ); closeLatch = new CountDownLatch( 1 ); this.engine = new WebSocketImpl( this, this.draft ); }\n\n    ### Response:", "ground_truth": "Reset everything relevant to allow a reconnect\n@since 1.3.8", "predict": "/**\n     * Resets the WebSocket connection by closing the socket and creating a new WebSocket instance.\n     * \n     * @throws IOException\n     *             If an I/O error occurs while closing the socket.\n     */\n    private void reset() throws IOException {\n        Thread current = Thread.currentThread();\n        if (current == writeThread || current == connectReadThread) {\n            throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\");\n        }\n        closeBlocking();\n        if (writeThread != null) {\n            this.writeThread.interrupt();\n            this.writeThread = null;\n        }\n        if (connectReadThread != null) {\n            this.connectReadThread.interrupt();\n            this.connectReadThread = null;\n        }\n        this.draft.reset();\n        if (this.socket != null) {\n            this.socket.close();\n            this.socket = null;\n        }\n        connectLatch = new CountDownLatch(1);\n        closeLatch = new CountDownLatch("}, {"ID": 494, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void connect() { if( connectReadThread != null ) throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" ); connectReadThread = new Thread( this ); connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() ); connectReadThread.start(); }\n\n    ### Response:", "ground_truth": "Initiates the websocket connection. This method does not block.", "predict": "/**\r\n     * Connects to the WebSocket server.\r\n     * \r\n     * @throws IllegalStateException if the WebSocketClient object is not reuseable.\r\n     */\r\n    public void connect() {\r\n        if( connectReadThread != null ) {\r\n            throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" );\r\n        }\r\n        connectReadThread = new Thread( this );\r\n        connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() );\r\n        connectReadThread.start();\r\n    }"}, {"ID": 495, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getPort() { int port = uri.getPort(); if( port == -1 ) { String scheme = uri.getScheme(); if( \"wss\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_WSS_PORT; } else if( \"ws\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_PORT; } else { throw new IllegalArgumentException( \"unknown scheme: \" + scheme ); } } return port; }\n\n    ### Response:", "ground_truth": "Extract the specified port\n@return the specified port or the default port for the specific scheme", "predict": "/**\r\n     * Returns the port number of the WebSocket URI.\r\n     * \r\n     * @return the port number of the WebSocket URI\r\n     * @throws IllegalArgumentException if the scheme of the WebSocket URI is not \"ws\" or \"wss\"\r\n     */\r\n    private int getPort() {\r\n        int port = uri.getPort();\r\n        if( port == -1 ) {\r\n            String scheme = uri.getScheme();\r\n            if( \"wss\".equals( scheme ) ) {\r\n                return WebSocketImpl.DEFAULT_WSS_PORT;\r\n            } else if( \"ws\".equals( scheme ) ) {\r\n                return WebSocketImpl.DEFAULT_PORT;\r\n            } else {\r\n                throw new IllegalArgumentException( \"unknown scheme: \" + scheme );\r\n            }\r\n        }\r\n        return port;\r\n    }"}, {"ID": 496, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if( part1 == null || part1.length() == 0 ) path = \"/\"; else path = part1; if( part2 != null ) path += '?' + part2; int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? \":\" + port : \"\" ); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor( path ); handshake.put( \"Host\", host ); if( headers != null ) { for( Map.Entry<String,String> kv : headers.entrySet() ) { handshake.put( kv.getKey(), kv.getValue() ); } } engine.startHandshake( handshake ); }\n\n    ### Response:", "ground_truth": "Create and send the handshake to the other endpoint\n@throws InvalidHandshakeException  a invalid handshake was created", "predict": "/**\n     * Sends the WebSocket handshake to the server.\n     *\n     * @throws InvalidHandshakeException\n     *             if the handshake fails.\n     */\n    private void sendHandshake() throws InvalidHandshakeException {\n        // TODO: Implement method\n    }"}, {"ID": 497, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setConnectionLostTimeout( int connectionLostTimeout ) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); return; } if (this.websocketRunning) { log.trace(\"Connection lost timer restarted\"); //Reset all the pings try { ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { log.error(\"Exception during connection lost restart\", e); } restartConnectionLostTimer(); } } }\n\n    ### Response:", "ground_truth": "Setter for the interval checking for lost connections\nA value lower or equal 0 results in the check to be deactivated\n\n@param connectionLostTimeout the interval in seconds\n@since 1.3.4", "predict": "/**\r\n     * Sets the connection lost timeout in seconds.\r\n     * \r\n     * @param connectionLostTimeout\r\n     *            the connection lost timeout in seconds.\r\n     */\r\n    public void setConnectionLostTimeout(int connectionLostTimeout) {\r\n        synchronized (syncConnectionLost) {\r\n            this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout);\r\n            if (this.connectionLostTimeout <= 0) {\r\n                log.trace(\"Connection lost timer stopped\");\r\n                cancelConnectionLostTimer();\r\n                return;\r\n            }\r\n            if (this.websocketRunning) {\r\n                log.trace(\"Connection lost timer restarted\");\r\n                //Reset all the pings\r\n                try {\r\n                    ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections());\r\n                    WebSocketImpl webSocketImpl;\r\n                    for (WebSocket conn : connections) {\r\n                        if (conn instanceof WebSocketImpl) {\r\n                            webSocketImpl = (WebSocketImpl) conn;\r\n                            webSocketImpl.updateLastPong();\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    log.error(\"Exception during"}, {"ID": 498, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); } } }\n\n    ### Response:", "ground_truth": "Stop the connection lost timer\n@since 1.3.4", "predict": "/**\r\n     * Stops the connection lost timer.\r\n     */\r\n    protected void stopConnectionLostTimer() {\r\n        synchronized (syncConnectionLost) {\r\n            if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) {\r\n                this.websocketRunning = false;\r\n                log.trace(\"Connection lost timer stopped\");\r\n                cancelConnectionLostTimer();\r\n            }\r\n        }\r\n    }"}, {"ID": 499, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } }\n\n    ### Response:", "ground_truth": "Start the connection lost timer\n@since 1.3.4", "predict": "/**\r\n     * This method starts the connection lost timer.\r\n     */\r\n    protected void startConnectionLostTimer() {\r\n        synchronized (syncConnectionLost) {\r\n            if (this.connectionLostTimeout <= 0) {\r\n                log.trace(\"Connection lost timer deactivated\");\r\n                return;\r\n            }\r\n            log.trace(\"Connection lost timer started\");\r\n            this.websocketRunning = true;\r\n            restartConnectionLostTimer();\r\n        }\r\n    }"}, {"ID": 500, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"connectionLostChecker\")); Runnable connectionLostChecker = new Runnable() { /** * Keep the connections in a separate list to not cause deadlocks */ private ArrayList<WebSocket> connections = new ArrayList<WebSocket>( ); @Override public void run() { connections.clear(); try { connections.addAll( getConnections() ); long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 )); for( WebSocket conn : connections ) { executeConnectionLostDetection(conn, minimumPongTime); } } catch ( Exception e ) { //Ignore this exception } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); }\n\n    ### Response:", "ground_truth": "This methods allows the reset of the connection lost timer in case of a changed parameter\n@since 1.3.4", "predict": "/** * This method is used to restart the connection lost timer. * It cancels the previous timer and creates a new one with the same parameters. * It also creates a new thread pool executor to run the connection lost detection task. * The task is a runnable that keeps the connections in a separate list to not cause deadlocks. * It then iterates over the list of connections and executes the connection lost detection task for each connection. * The connection lost detection task checks if the connection has received a pong message within the specified timeout. * If the connection has not received a pong message within the specified timeout, it is considered lost and is removed from the list of connections. * The list of connections is cleared after the connection lost detection task is executed. */"}, {"ID": 501, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if( webSocketImpl.getLastPong() < minimumPongTime ) { log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl); webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ); } else { if( webSocketImpl.isOpen() ) { webSocketImpl.sendPing(); } else { log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl); } } }\n\n    ### Response:", "ground_truth": "Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping\n@param webSocket the websocket instance\n@param minimumPongTime the lowest/oldest allowable last pong time (in nanoTime) before we consider the connection to be lost", "predict": "/**\r\n     * This method is responsible for detecting and handling connection lost events.\r\n     * \r\n     * @param webSocket The WebSocket instance that lost connection.\r\n     * @param minimumPongTime The minimum time in milliseconds that the endpoint should respond with a pong message.\r\n     */\r\n    private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) {\r\n        if (!(webSocket instanceof WebSocketImpl)) {\r\n            return;\r\n        }\r\n        WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket;\r\n        if (webSocketImpl.getLastPong() < minimumPongTime) {\r\n            log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl);\r\n            webSocketImpl.closeConnection(CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\");\r\n        } else {\r\n            if (webSocketImpl"}, {"ID": 502, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void cancelConnectionLostTimer() { if( connectionLostCheckerService != null ) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } }\n\n    ### Response:", "ground_truth": "Cancel any running timer for the connection lost detection\n@since 1.3.4", "predict": "/**\r\n     * This method is used to cancel the connection lost timer.\r\n     */\r\n    private void cancelConnectionLostTimer() {\r\n        if( connectionLostCheckerService != null ) {\r\n            connectionLostCheckerService.shutdownNow();\r\n            connectionLostCheckerService = null;\r\n        }\r\n        if( connectionLostCheckerFuture != null ) {\r\n            connectionLostCheckerFuture.cancel(false);\r\n            connectionLostCheckerFuture = null;\r\n        }\r\n    }"}, {"ID": 503, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); }\n\n    ### Response:", "ground_truth": "This default implementation does not do anything. Go ahead and overwrite it.\n\n@see org.java_websocket.WebSocketListener#onWebsocketHandshakeReceivedAsServer(WebSocket, Draft, ClientHandshake)", "predict": "/**\n     * This method is called when a WebSocket handshake is received as a server.\n     * \n     * @param conn The WebSocket connection.\n     * @param draft The WebSocket draft.\n     * @param request The client handshake request.\n     * @return A ServerHandshakeBuilder object that can be used to build the server handshake response.\n     * @throws InvalidDataException If the handshake request is invalid.\n     */\n    @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); }"}, {"ID": 504, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void onWebsocketPing( WebSocket conn, Framedata f ) { conn.sendFrame( new PongFrame( (PingFrame)f ) ); }\n\n    ### Response:", "ground_truth": "This default implementation will send a pong in response to the received ping.\nThe pong frame will have the same payload as the ping frame.\n\n@see org.java_websocket.WebSocketListener#onWebsocketPing(WebSocket, Framedata)", "predict": "/**\r\n     * This method is called when a WebSocket ping frame is received.\r\n     * \r\n     * @param conn\r\n     *            The WebSocket connection.\r\n     * @param f\r\n     *            The ping frame.\r\n     */\r\n    @Override\r\n    public void onWebsocketPing(WebSocket conn, Framedata f) {\r\n        conn.sendFrame(new PongFrame((PingFrame) f));\r\n    }"}, {"ID": 505, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop( int timeout ) throws InterruptedException { if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections return; } List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList<WebSocket>( connections ); } for( WebSocket ws : socketsToClose ) { ws.close( CloseFrame.GOING_AWAY ); } wsf.close(); synchronized ( this ) { if( selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join( timeout ); } } }\n\n    ### Response:", "ground_truth": "Closes all connected clients sockets, then closes the underlying\nServerSocketChannel, effectively killing the server socket selectorthread,\nfreeing the port the server was bound to and stops all internal workerthreads.\n\nIf this method is called before the server is started it will never start.\n\n@param timeout\nSpecifies how many milliseconds the overall close handshaking may take altogether before the connections are closed without proper close handshaking.\n\n@throws InterruptedException Interrupt", "predict": "/**\r\n     * Stops the WebSocket server and closes all connections.\r\n     * \r\n     * @param timeout\r\n     *            The maximum time to wait for the selector thread to exit.\r\n     * @throws InterruptedException\r\n     *             If the selector thread is interrupted while waiting.\r\n     */\r\n    public void stop(int timeout) throws InterruptedException {\r\n        if (!isclosed.compareAndSet(false, true)) {\r\n            // this also makes sure that no further connections will be added to this.connections\r\n            return;\r\n        }\r\n\r\n        List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks)\r\n        synchronized (connections) {\r\n            socketsToClose = new ArrayList<WebSocket>(connections);\r\n        }\r\n\r\n        for (WebSocket ws : socketsToClose) {\r\n            ws.close(CloseFrame.GOING_AWAY);\r\n        }\r\n\r\n        wsf.close();\r\n\r\n        synchronized (this) {\r\n            if (selectorthread != null && selector != null) {\r\n                selector.wakeup();\r\n                selectorthread.join(timeout);\r\n            }\r\n        }\r\n    }"}, {"ID": 506, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getPort() { int port = getAddress().getPort(); if( port == 0 && server != null ) { port = server.socket().getLocalPort(); } return port; }\n\n    ### Response:", "ground_truth": "Gets the port number that this server listens on.\n\n@return The port number.", "predict": "/**\r\n     * Returns the port number of the server socket.\r\n     * \r\n     * @return the port number of the server socket.\r\n     */\r\n    public int getPort() {\r\n        int port = getAddress().getPort();\r\n        if( port == 0 && server != null ) {\r\n            port = server.socket().getLocalPort();\r\n        }\r\n        return port;\r\n    }"}, {"ID": 507, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while ( !iqueue.isEmpty() ) { conn = iqueue.remove( 0 ); WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() ); ByteBuffer buf = takeBuffer(); try { if( SocketChannelIOHelper.readMore( buf, conn, c ) ) iqueue.add( conn ); if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } } }\n\n    ### Response:", "ground_truth": "Do an additional read\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": "/**\r\n     * This method is responsible for reading additional data from the WebSocket connection.\r\n     * \r\n     * @throws InterruptedException\r\n     *             if the thread is interrupted while waiting for the connection to be available\r\n     * @throws IOException\r\n     *             if an I/O error occurs while reading from the connection\r\n     */\r\n    private void doAdditionalRead() throws InterruptedException, IOException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 508, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if( !onConnect( key ) ) { key.cancel(); return; } SocketChannel channel = server.accept(); if(channel==null){ return; } channel.configureBlocking( false ); Socket socket = channel.socket(); socket.setTcpNoDelay( isTcpNoDelay() ); socket.setKeepAlive( true ); WebSocketImpl w = wsf.createWebSocket( this, drafts ); w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w )); try { w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() )); i.remove(); allocateBuffers( w ); } catch (IOException ex) { if( w.getSelectionKey() != null ) w.getSelectionKey().cancel(); handleIOException( w.getSelectionKey(), null, ex ); } }\n\n    ### Response:", "ground_truth": "Execute a accept operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@throws InterruptedException  thrown by taking a buffer\n@throws IOException if an error happened during accept", "predict": "/**\r\n     * This method is called when a new connection is accepted by the server socket.\r\n     * \r\n     * @param key The SelectionKey associated with the server socket.\r\n     * @param i An iterator over the set of keys for the Selector.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @throws InterruptedException If the thread is interrupted while waiting for a socket to be accepted.\r\n     */\r\n    private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 509, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if(conn.getChannel() == null){ key.cancel(); handleIOException( key, conn, new IOException() ); return false; } try { if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) { if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); i.remove(); if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) { iqueue.add( conn ); } } else { pushBuffer(buf); } } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } return true; }\n\n    ### Response:", "ground_truth": "Execute a read operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@return true, if the read was successful, or false if there was an error\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": "/**\r\n     * This method is responsible for reading data from the socket channel and processing it.\r\n     * \r\n     * @param key The selection key associated with the socket channel.\r\n     * @param i The iterator associated with the selector.\r\n     * @return True if the read operation was successful, false otherwise.\r\n     * @throws InterruptedException If the thread is interrupted while waiting for the socket channel to become ready.\r\n     * @throws IOException If an I/O error occurs while reading from the socket channel.\r\n     */\r\n    private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException {\r\n        WebSocketImpl conn = (WebSocketImpl) key.attachment();\r\n        ByteBuffer buf = takeBuffer();\r\n        if(conn.getChannel() == null){\r\n            key.cancel();\r\n            handleIOException( key, conn, new IOException() );\r\n            return false;\r\n        }\r\n        try {\r\n            if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) {\r\n                if( buf.hasRemaining() ) {\r\n                    conn.inQueue"}, {"ID": 510, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doWrite(SelectionKey key) throws IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) { if( key.isValid() ) { key.interestOps(SelectionKey.OP_READ); } } }\n\n    ### Response:", "ground_truth": "Execute a write operation\n@param key the selectionkey to write on\n@throws IOException if an error happened during batch", "predict": "/**\r\n     * This method is called when a write operation is ready to be performed on the socket channel.\r\n     * \r\n     * @param key The SelectionKey object associated with the socket channel.\r\n     * @throws IOException If an I/O error occurs.\r\n     */\r\n    private void doWrite(SelectionKey key) throws IOException {\r\n        WebSocketImpl conn = (WebSocketImpl) key.attachment();\r\n        if (SocketChannelIOHelper.batch(conn, conn.getChannel())) {\r\n            if (key.isValid()) {\r\n                key.interestOps(SelectionKey.OP_READ);\r\n            }\r\n        }\r\n    }"}, {"ID": 511, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doSetupSelectorAndServerThread() { selectorthread.setName( \"WebSocketSelector-\" + selectorthread.getId() ); try { server = ServerSocketChannel.open(); server.configureBlocking( false ); ServerSocket socket = server.socket(); socket.setReceiveBufferSize( WebSocketImpl.RCVBUF ); socket.setReuseAddress( isReuseAddr() ); socket.bind( address ); selector = Selector.open(); server.register( selector, server.validOps() ); startConnectionLostTimer(); for( WebSocketWorker ex : decoders ){ ex.start(); } onStart(); } catch ( IOException ex ) { handleFatal( null, ex ); return false; } return true; }\n\n    ### Response:", "ground_truth": "Setup the selector thread as well as basic server settings\n@return true, if everything was successful, false if some error happened", "predict": "/**\r\n     * This method sets up the selector and server thread for the WebSocket.\r\n     * \r\n     * @return true if the setup was successful, false otherwise.\r\n     */\r\n    private boolean doSetupSelectorAndServerThread() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 512, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean doEnsureSingleThread() { synchronized ( this ) { if( selectorthread != null ) throw new IllegalStateException( getClass().getName() + \" can only be started once.\" ); selectorthread = Thread.currentThread(); if( isclosed.get() ) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "The websocket server can only be started once\n@return true, if the server can be started, false if already a thread is running", "predict": "/**\r\n     * Ensures that the selector thread is only started once.\r\n     * \r\n     * @return true if the selector thread was started, false if it was already running.\r\n     * @throws IllegalStateException if the selector thread has already been started.\r\n     */\r\n    private boolean doEnsureSingleThread() {\r\n        synchronized (this) {\r\n            if (selectorthread != null) {\r\n                throw new IllegalStateException(getClass().getName() + \" can only be started once.\");\r\n            }\r\n            selectorthread = Thread.currentThread();\r\n            if (isclosed.get()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 513, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doServerShutdown() { stopConnectionLostTimer(); if( decoders != null ) { for( WebSocketWorker w : decoders ) { w.interrupt(); } } if( selector != null ) { try { selector.close(); } catch ( IOException e ) { log.error( \"IOException during selector.close\", e ); onError( null, e ); } } if( server != null ) { try { server.close(); } catch ( IOException e ) { log.error( \"IOException during server.close\", e ); onError( null, e ); } } }\n\n    ### Response:", "ground_truth": "Clean up everything after a shutdown", "predict": "/**\r\n     * This method is responsible for shutting down the server.\r\n     * It stops the connection lost timer, interrupts the decoders, closes the selector and server sockets.\r\n     * It also logs any exceptions that occur during the process.\r\n     */"}, {"ID": 514, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Socket getSocket( WebSocket conn ) { WebSocketImpl impl = (WebSocketImpl) conn; return ( (SocketChannel) impl.getSelectionKey().channel() ).socket(); }\n\n    ### Response:", "ground_truth": "Getter to return the socket used by this specific connection\n@param conn The specific connection\n@return The socket used by this connection", "predict": "/**\r\n     * Returns the Socket object associated with the given WebSocket connection.\r\n     * \r\n     * @param conn the WebSocket connection\r\n     * @return the Socket object associated with the given WebSocket connection\r\n     */\r\n    private Socket getSocket( WebSocket conn ) {\r\n        WebSocketImpl impl = (WebSocketImpl) conn;\r\n        return ( (SocketChannel) impl.getSelectionKey().channel() ).socket();\r\n    }"}, {"ID": 515, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); }\n\n    ### Response:", "ground_truth": "Send a byte array to a specific collection of websocket connections\n@param data the data to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": "/**\r\n     * Broadcasts the given data to all the given clients.\r\n     * \r\n     * @param data the data to broadcast\r\n     * @param clients the clients to broadcast to\r\n     * @throws IllegalArgumentException if data or clients is null\r\n     */\r\n    public void broadcast(byte[] data, Collection<WebSocket> clients) {\r\n        if (data == null || clients == null) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        broadcast(ByteBuffer.wrap(data), clients);\r\n    }"}, {"ID": 516, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); }\n\n    ### Response:", "ground_truth": "Send a text to a specific collection of websocket connections\n@param text the text to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": "/**\r\n     * Broadcasts a message to all the given clients.\r\n     * \r\n     * @param text the message to broadcast\r\n     * @param clients the collection of WebSocket clients to broadcast to\r\n     * @throws IllegalArgumentException if either text or clients is null\r\n     */\r\n    public void broadcast(String text, Collection<WebSocket> clients) {\r\n        if (text == null || clients == null) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        doBroadcast(text, clients);\r\n    }"}, {"ID": 517, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void doBroadcast(Object data, Collection<WebSocket> clients) { String sData = null; if (data instanceof String) { sData = (String)data; } ByteBuffer bData = null; if (data instanceof ByteBuffer) { bData = (ByteBuffer)data; } if (sData == null && bData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>(); for( WebSocket client : clients ) { if( client != null ) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, sData, bData); try { client.sendFrame( draftFrames.get( draft ) ); } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } }\n\n    ### Response:", "ground_truth": "Private method to cache all the frames to improve memory footprint and conversion time\n@param data the data to broadcast\n@param clients the clients to send the message to", "predict": "/**\r\n     * This method is responsible for sending data to all the clients connected to the server.\r\n     * \r\n     * @param data - The data to be sent to the clients.\r\n     * @param clients - The collection of clients to which the data needs to be sent.\r\n     */\r\n    private void doBroadcast(Object data, Collection<WebSocket> clients) {\r\n        // TODO: Implement the logic for sending data to all the clients connected to the server.\r\n    }"}, {"ID": 518, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { if( !draftFrames.containsKey( draft ) ) { List<Framedata> frames = null; if (sData != null) { frames = draft.createFrames( sData, false ); } if (bData != null) { frames = draft.createFrames( bData, false ); } if (frames != null) { draftFrames.put(draft, frames); } } }\n\n    ### Response:", "ground_truth": "Fills the draftFrames with new data for the broadcast\n@param draft The draft to use\n@param draftFrames The list of frames per draft to fill\n@param sData the string data, can be null\n@param bData the bytebuffer data, can be null", "predict": "/**\r\n     * This method is used to fill the frames for a given draft.\r\n     * \r\n     * @param draft - The draft for which the frames are to be filled.\r\n     * @param draftFrames - A map containing the frames for each draft.\r\n     * @param sData - The string data to be used to create the frames.\r\n     * @param bData - The byte data to be used to create the frames.\r\n     */\r\n    private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { }"}, {"ID": 519, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } }\n\n    ### Response:", "ground_truth": "Transfer from one ByteBuffer to another ByteBuffer\n\n@param source the ByteBuffer to copy from\n@param dest   the ByteBuffer to copy to\n@return the number of transferred bytes", "predict": "/**\r\n     * Transfers bytes from the source ByteBuffer to the destination ByteBuffer.\r\n     * \r\n     * @param source the source ByteBuffer\r\n     * @param dest the destination ByteBuffer\r\n     * @return the number of bytes transferred\r\n     * @throws IllegalArgumentException if either ByteBuffer is null\r\n     */\r\n    public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) {\r\n        if( source == null || dest == null ) {\r\n            throw new IllegalArgumentException();\r\n        }\r\n        int fremain = source.remaining();\r\n        int toremain = dest.remaining();\r\n        if( fremain > toremain ) {\r\n            int limit = Math.min( fremain, toremain );\r\n            source.limit( limit );\r\n            dest.put( source );\r\n            return limit;\r\n        } else {\r\n            dest.put( source );\r\n            return fremain;\r\n        }\r\n    }"}, {"ID": 520, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JPAApi start() { jpaConfig .persistenceUnits() .forEach( persistenceUnit -> emfs.put( persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName))); return this; }\n\n    ### Response:", "ground_truth": "Initialise JPA entity manager factories.", "predict": "/**\r\n     * This method starts the JPA API by creating EntityManagerFactory for each persistence unit and adding it to a map.\r\n     * @return JPAApi object\r\n     */\r\n    public JPAApi start() {\r\n        jpaConfig.persistenceUnits().forEach(persistenceUnit -> emfs.put(persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName)));\r\n        return this;\r\n    }"}, {"ID": 521, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EntityManager em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return emf.createEntityManager(); }\n\n    ### Response:", "ground_truth": "Get a newly created EntityManager for the specified persistence unit name.\n\n@param name The persistence unit name", "predict": "/**\r\n     * Returns an EntityManager for the given persistence unit name.\r\n     * \r\n     * @param name the name of the persistence unit\r\n     * @return an EntityManager for the given persistence unit name, or null if none exists\r\n     */\r\n    public EntityManager em(String name) {\r\n        EntityManagerFactory emf = emfs.get(name);\r\n        if (emf == null) {\r\n            return null;\r\n        }\r\n        return emf.createEntityManager();\r\n    }"}, {"ID": 522, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void withTransaction(Consumer<EntityManager> block) { withTransaction( em -> { block.accept(em); return null; }); }\n\n    ### Response:", "ground_truth": "Run a block of code with a newly created EntityManager for the default Persistence Unit.\n\n@param block Block of code to execute", "predict": "/**\r\n     * Executes the given block of code within a transaction.\r\n     * \r\n     * @param block the code to execute within the transaction\r\n     */\r\n    public void withTransaction(Consumer<EntityManager> block) {\r\n        withTransaction(em -> {\r\n            block.accept(em);\r\n            return null;\r\n        });\r\n    }"}, {"ID": 523, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Seq<Object> convertArgsToScalaBuffer(final Object... args) { return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args)) .asScala() .toList(); }\n\n    ### Response:", "ground_truth": "Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate list\nif necessary\n\n@param args the message arguments\n@return scala type for message processing", "predict": "/**\r\n     * Converts the given arguments to a Scala Buffer.\r\n     *\r\n     * @param args the arguments to convert\r\n     * @return the Scala Buffer containing the arguments\r\n     */\r\n    private static Seq<Object> convertArgsToScalaBuffer(final Object... args) {\r\n        return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args))\r\n                .asScala()\r\n                .toList();\r\n    }"}, {"ID": 524, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; }\n\n    ### Response:", "ground_truth": "Wraps arguments passed into a list if necessary.\n\nReturns the first value as is if it is the only argument and a subtype of `java.util.List`\nOtherwise, it calls Arrays.asList on args\n\n@param args arguments as a List", "predict": "/**\r\n     * Wraps the given arguments into a list if they are not already a list.\r\n     *\r\n     * @param <T> the type of the elements in the list\r\n     * @param args the arguments to wrap\r\n     * @return a list containing the arguments\r\n     */\r\n    @SafeVarargs\r\n    private static <T> List<T> wrapArgsToListIfNeeded(final T... args) {\r\n        List<T> out;\r\n        if (args != null && args.length == 1 && args[0] instanceof List) {\r\n            out = (List<T>) args[0];\r\n        } else {\r\n            out = Arrays.asList(args);\r\n        }\r\n        return out;\r\n    }"}, {"ID": 525, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(play.api.i18n.Lang lang, String key, Object... args) { Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(key, scalaArgs, lang); }\n\n    ### Response:", "ground_truth": "Translates a message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "/**\r\n     * Retrieves a message for the specified key in the specified language, with optional arguments.\r\n     *\r\n     * @param lang the language in which to retrieve the message\r\n     * @param key the key of the message to retrieve\r\n     * @param args optional arguments to substitute into the message\r\n     * @return the retrieved message\r\n     */\r\n    public String get(play.api.i18n.Lang lang, String key, Object... args) {\r\n        Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);\r\n        return messages.apply(key, scalaArgs, lang);\r\n    }"}, {"ID": 526, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) { Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala(); Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(keyArgs.toSeq(), scalaArgs, lang); }\n\n    ### Response:", "ground_truth": "Translates the first defined message.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "/**\r\n     * Retrieves a message for the specified language, with the specified arguments.\r\n     *\r\n     * @param lang the language for which the message should be retrieved\r\n     * @param keys the keys to use to retrieve the message\r\n     * @param args the arguments to use to format the message\r\n     * @return the formatted message\r\n     */\r\n    public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) {\r\n        Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala();\r\n        Seq<Object> scalaArgs = convertArgsToScalaBuffer(args);\r\n        return messages.apply(keyArgs.toSeq(), scalaArgs, lang);\r\n    }"}, {"ID": 527, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); }\n\n    ### Response:", "ground_truth": "Check if a message key is defined.\n\n@param lang the message lang\n@param key the message key\n@return a Boolean", "predict": "/**\r\n     * Checks if a message is defined for a given key and language.\r\n     *\r\n     * @param lang the language to check for the message\r\n     * @param key the key to check for the message\r\n     * @return true if the message is defined, false otherwise\r\n     */\r\n    public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) {\r\n        return messages.isDefinedAt(key, lang);\r\n    }"}, {"ID": 528, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); }\n\n    ### Response:", "ground_truth": "Get a messages context appropriate for the given candidates.\n\nWill select a language from the candidates, based on the languages available, and fallback\nto the default language if none of the candidates are available.\n\n@param candidates the candidate languages\n@return the most appropriate Messages instance given the candidate languages", "predict": "/**\r\n     * Returns the preferred language from the given candidates.\r\n     *\r\n     * @param candidates the collection of languages to choose from\r\n     * @return the preferred language\r\n     */\r\n    public Messages preferred(Collection<Lang> candidates) {\r\n        Seq<Lang> cs = Scala.asScala(candidates);\r\n        play.api.i18n.Messages msgs = messages.preferred((Seq) cs);\r\n        return new MessagesImpl(new Lang(msgs.lang()), this);\r\n    }"}, {"ID": 529, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); }\n\n    ### Response:", "ground_truth": "Get a messages context appropriate for the given request.\n\nWill select a language from the request, based on the languages available, and fallback to\nthe default language if none of the candidates are available.\n\n@param request the incoming request\n@return the preferred messages context for the request", "predict": "/**\r\n     * Returns the preferred messages for the given request.\r\n     *\r\n     * @param request the HTTP request header\r\n     * @return the preferred messages for the given request\r\n     */\r\n    public Messages preferred(Http.RequestHeader request) {\r\n        play.api.i18n.Messages msgs = messages.preferred(request);\r\n        return new MessagesImpl(new Lang(msgs.lang()), this);\r\n    }"}, {"ID": 530, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); }\n\n    ### Response:", "ground_truth": "Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.\n\n@param result the result where the lang will be set.\n@param lang the lang to set on the result\n@return a new result with the lang.", "predict": "/**\r\n     * Sets the language of the given result object.\r\n     *\r\n     * @param result the result object to set the language for\r\n     * @param lang the language to set\r\n     * @return the updated result object with the new language set\r\n     */\r\n    public Result setLang(Result result, Lang lang) {\r\n        return messages.setLang(result.asScala(), lang).asJava();\r\n    }"}, {"ID": 531, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Add bindings from guiceable modules.\n\n@param modules the set of modules to bind\n@return a copy of this builder configured with those modules", "predict": "/**\n     * Returns a new builder that includes the specified GuiceableModule instances.\n     *\n     * @param modules the GuiceableModule instances to include in the new builder\n     * @return a new builder that includes the specified GuiceableModule instances\n     */\n    public Self bindings(GuiceableModule... modules);"}, {"ID": 532, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Add bindings from Play modules.\n\n@param modules the set of Guice modules whose bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": "/**\n     * Configures the Guice injector with the given modules.\n     *\n     * @param modules the modules to be added to the injector\n     * @return the current instance of Self\n     */\n    public final Self bindings(play.api.inject.Module... modules) {\n        return bindings(Guiceable.modules(modules));\n    }"}, {"ID": 533, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Add Play bindings.\n\n@param bindings the set of play bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": "/**\n     * Binds the specified bindings to the current Guiceable instance.\n     *\n     * @param bindings the bindings to bind\n     * @return the current Guiceable instance with the specified bindings bound\n     */\n    public final Self bindings(play.api.inject.Binding<?>... bindings) {\n        return bindings(Guiceable.bindings(bindings));\n    }"}, {"ID": 534, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(GuiceableModule... modules) { return newBuilder(delegate.overrides(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Override bindings using guiceable modules.\n\n@param modules the set of Guice modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": "/**\n     * Returns a new builder that overrides the bindings in the given modules.\n     *\n     * @param modules the modules whose bindings should be overridden\n     * @return a new builder that overrides the bindings in the given modules\n     */\n    public Self overrides(GuiceableModule... modules);"}, {"ID": 535, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override bindings using Play modules.\n\n@param modules the set of Play modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": "/**\n     * Configures the Guice injector to use the specified modules to provide bindings for this application.\n     *\n     * @param modules the modules to use for binding\n     * @return a new instance of Self with the specified modules applied\n     */\n    public final Self overrides(play.api.inject.Module... modules) {\n        return overrides(Guiceable.modules(modules));\n    }"}, {"ID": 536, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Override bindings using Play bindings.\n\n@param bindings a set of Play bindings that override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": "/**\n     * Returns a new Guiceable that overrides the current bindings with the given bindings.\n     *\n     * @param bindings the bindings to override with\n     * @return a new Guiceable that overrides the current bindings with the given bindings\n     */\n    public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); }"}, {"ID": 537, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); }\n\n    ### Response:", "ground_truth": "Disable modules by class.\n\n@param moduleClasses the module classes whose bindings should be disabled\n@return a copy of this builder configured to ignore the provided module classes", "predict": "/**\n     * Disables the specified modules.\n     *\n     * @param moduleClasses the modules to disable\n     * @return a new instance of the same type with the specified modules disabled\n     */\n    public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); }"}, {"ID": 538, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); }\n\n    ### Response:", "ground_truth": "the\nmigration guide for more details.", "predict": "/**\r\n     * @deprecated TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); }\r\n     * \r\n     * This method is deprecated and will be removed in a future release. It is recommended to use the call(Request) method instead.\r\n     * \r\n     * This method is used to handle incoming requests. It takes a Context object as input and returns a CompletionStage of a Result object.\r\n     * \r\n     * The Context object contains information about the incoming request, such as the request headers, query parameters, and body. It also contains a reference to the Play application and other useful objects, such as the current user, the session, and the flash scope.\r\n     * \r\n     * The call(Request) method is a more flexible way to handle incoming requests, as it allows you to pass in a pre-built Request object"}, {"ID": 539, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CompletionStage<Result> call( Request req) { // TODO: Make this method abstract after removing call(Context) return Context.safeCurrent() .map( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS)); Context.setCurrent(newCtx); return call(newCtx); }) .orElseGet( () -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents); ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>()); return call(ctx); }); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * This method is responsible for handling the incoming request and returning a response.\r\n     * \r\n     * @param req The incoming request.\r\n     * @return A CompletionStage that will eventually contain the response.\r\n     */\r\n    public abstract CompletionStage<Result> call(Request req);"}, {"ID": 540, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); }\n\n    ### Response:", "ground_truth": "Retrieves a file relative to the application root path. This method returns an Optional, using\nempty if the file was not found.\n\n@param relativePath relative path of the file to fetch\n@return an existing file", "predict": "/**\r\n     * Returns an Optional containing the existing file at the given relative path, or an empty Optional if no such file exists.\r\n     *\r\n     * @param relativePath the relative path to the file\r\n     * @return an Optional containing the existing file at the given relative path, or an empty Optional if no such file exists\r\n     */\r\n    public Optional<File> getExistingFile(String relativePath) {\r\n        return OptionConverters.toJava(env.getExistingFile(relativePath));\r\n    }"}, {"ID": 541, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> Binding<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); }\n\n    ### Response:", "ground_truth": "Configure the scope for this binding.", "predict": "/**\r\n     * Binds the underlying {@link Binding} to a specific scope.\r\n     * \r\n     * @param scope the scope to bind to\r\n     * @param <A> the annotation type\r\n     * @return the bound {@link Binding}\r\n     */\r\n    public <A extends Annotation> Binding<T> in(final Class<A> scope) {\r\n        return underlying.in(scope).asJava();\r\n    }"}, {"ID": 542, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); }\n\n    ### Response:", "ground_truth": "Constructs a tuple of A,B\n\n@param a The a value\n@param b The b value\n@param  a's type\n@param  b's type\n@return The tuple", "predict": "/**\r\n     * Creates a new Tuple object with the given values.\r\n     * \r\n     * @param <A> the type of the first value\r\n     * @param <B> the type of the second value\r\n     * @param a the first value\r\n     * @param b the second value\r\n     * @return a new Tuple object with the given values\r\n     */\r\n    public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); }"}, {"ID": 543, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); }\n\n    ### Response:", "ground_truth": "Constructs a tuple of A,B,C,D,E\n\n@param a The a value\n@param b The b value\n@param c The c value\n@param d The d value\n@param e The e value\n@param  a's type\n@param  b's type\n@param  c's type\n@param  d's type\n@param  e's type\n@return The tuple", "predict": "/**\r\n     * Creates a new Tuple5 object with the given values.\r\n     * \r\n     * @param <A> the type of the first value\r\n     * @param <B> the type of the second value\r\n     * @param <C> the type of the third value\r\n     * @param <D> the type of the fourth value\r\n     * @param <E> the type of the fifth value\r\n     * @param a the first value\r\n     * @param b the second value\r\n     * @param c the third value\r\n     * @param d the fourth value\r\n     * @param e the fifth value\r\n     * @return a new Tuple5 object with the given values\r\n     */\r\n    public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) {\r\n        return new Tuple5<A, B, C, D, E>(a, b, c, d, e);\r\n    }"}, {"ID": 544, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static Executor toExecutor(ExecutionContext ec) { ExecutionContext prepared = ec.prepare(); if (prepared instanceof Executor) { return (Executor) prepared; } else { return prepared::execute; } }\n\n    ### Response:", "ground_truth": "Converts the execution context to an executor, preparing it first.\n\n@param ec the execution context.\n@return the Java Executor.", "predict": "/**\r\n     * Converts an ExecutionContext to an Executor.\r\n     *\r\n     * @param ec the ExecutionContext to convert\r\n     * @return an Executor that executes tasks in the context of the provided ExecutionContext\r\n     */\r\n    private static Executor toExecutor(ExecutionContext ec) {\r\n        ExecutionContext prepared = ec.prepare();\r\n        if (prepared instanceof Executor) {\r\n            return (Executor) prepared;\r\n        } else {\r\n            return prepared::execute;\r\n        }\r\n    }"}, {"ID": 545, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig of(String name, String unitName) { return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName)); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration with the given name and unit name.\n\n@param name the name for the entity manager factory\n@param unitName the persistence unit name as used in `persistence.xml`\n@return a default JPA configuration", "predict": "/**\r\n     * Creates a new instance of the JPAConfig with the given name and unit name.\r\n     *\r\n     * @param name the name of the persistence unit\r\n     * @param unitName the name of the persistence unit\r\n     * @return a new instance of the JPAConfig\r\n     */\r\n    public static JPAConfig of(String name, String unitName) {\r\n        return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName));\r\n    }"}, {"ID": 546, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig of(String n1, String u1, String n2, String u2) { return new DefaultJPAConfig( new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2)); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration with the given names and unit names.\n\n@param n1 Name of the first entity manager factory\n@param u1 Name of the first unit\n@param n2 Name of the second entity manager factory\n@param u2 Name of the second unit\n@return a default JPA configuration with the provided persistence units.", "predict": "/**\r\n     * Creates a new instance of JPAConfig with two persistence units.\r\n     * \r\n     * @param n1 the name of the first persistence unit\r\n     * @param u1 the URL of the first persistence unit\r\n     * @param n2 the name of the second persistence unit\r\n     * @param u2 the URL of the second persistence unit\r\n     * @return a new instance of JPAConfig with two persistence units\r\n     */\r\n    public static JPAConfig of(String n1, String u1, String n2, String u2) {\r\n        return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2));\r\n    }"}, {"ID": 547, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JPAConfig from(Map<String, String> map) { ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>(); for (Map.Entry<String, String> entry : map.entrySet()) { persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue())); } return new DefaultJPAConfig(persistenceUnits.build()); }\n\n    ### Response:", "ground_truth": "Create a default JPA configuration from a map of names to unit names.\n\n@param map Map of entity manager factory names to unit names\n@return a JPAConfig configured with the provided mapping", "predict": "/**\r\n     * Creates a new JPAConfig object from a map of persistence unit names and properties.\r\n     *\r\n     * @param map the map of persistence unit names and properties\r\n     * @return a new JPAConfig object\r\n     */\r\n    public static JPAConfig from(Map<String, String> map) {\r\n        ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>();\r\n        for (Map.Entry<String, String> entry : map.entrySet()) {\r\n            persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue()));\r\n        }\r\n        return new DefaultJPAConfig(persistenceUnits.build());\r\n    }"}, {"ID": 548, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Flow<String, ByteString, NotUsed> string(String callbackName) { return Flow.of(String.class) .map( str -> { return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\"); }) .via(flow(callbackName)); }\n\n    ### Response:", "ground_truth": "Produces a Flow of escaped ByteString from a series of String elements. Calls out to Comet.flow\ninternally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": "/**\r\n     * Creates a Flow that converts a String to a ByteString using the specified callback function.\r\n     *\r\n     * @param callbackName the name of the callback function to use for conversion\r\n     * @return a Flow that converts a String to a ByteString using the specified callback function\r\n     */\r\n    public static Flow<String, ByteString, NotUsed> string(String callbackName) {\r\n        return Flow.of(String.class)\r\n                .map(str -> {\r\n                    return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\");\r\n                })\r\n                .via(flow(callbackName));\r\n    }"}, {"ID": 549, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) { return Flow.of(JsonNode.class) .map( json -> { return ByteString.fromString(Json.stringify(json)); }) .via(flow(callbackName)); }\n\n    ### Response:", "ground_truth": "Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode. Calls out to\nComet.flow internally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": "/**\r\n     * Returns a Flow that converts a JSON object to a ByteString and then sends it to the specified callback function.\r\n     *\r\n     * @param callbackName the name of the callback function to be called with the ByteString\r\n     * @return a Flow that converts a JSON object to a ByteString and then sends it to the specified callback function\r\n     */\r\n    public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) {\r\n        return Flow.of(JsonNode.class)\r\n                .map(json -> {\r\n                    return ByteString.fromString(Json.stringify(json));\r\n                })\r\n                .via(flow(callbackName));\r\n    }"}, {"ID": 550, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) { validators.put(key, () -> constraintValidator); return this; }\n\n    ### Response:", "ground_truth": "Adds validator as a singleton.\n\n@param key the constraint validator type\n@param constraintValidator the constraint validator instance\n@param  the type of constraint validator implementation\n@return {@link MappedConstraintValidatorFactory} with the given constraint validator added.", "predict": "/**\n     * Adds a constraint validator to the factory.\n     *\n     * @param key the key for the constraint validator\n     * @param constraintValidator the constraint validator to add\n     * @param <T> the type of the constraint validator\n     * @return the updated factory\n     */\n    public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) {\n        validators.put(key, () -> constraintValidator);\n        return this;\n    }"}, {"ID": 551, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) { try { return key.getDeclaredConstructor().newInstance(); } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) { throw new RuntimeException(ex); } }\n\n    ### Response:", "ground_truth": "need to do so.", "predict": "/**\r\n     * Creates a new instance of the specified constraint validator class.\r\n     *\r\n     * @param key the constraint validator class to create an instance of\r\n     * @param <T> the type of the constraint validator class\r\n     * @return a new instance of the specified constraint validator class\r\n     */\r\n    private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) {\r\n        try {\r\n            return key.getDeclaredConstructor().newInstance();\r\n        } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }"}, {"ID": 552, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method getMatchingAccessibleMethod( final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { try { final Method method = cls.getMethod(methodName, parameterTypes); MemberUtils.setAccessibleWorkaround(method); return method; } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null; final Method[] methods = cls.getMethods(); for (final Method method : methods) { // compare name and parameters if (method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod(method); if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) { bestMatch = accessibleMethod; } } } if (bestMatch != null) { MemberUtils.setAccessibleWorkaround(bestMatch); } if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) { final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes(); final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType(); final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName(); final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName(); final String parameterTypeSuperClassName = parameterTypes[parameterTypes.length - 1].getSuperclass().getName(); if (!methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) { return null; } } return bestMatch; }\n\n    ### Response:", "ground_truth": "Finds an accessible method that matches the given name and has compatible parameters.\nCompatible parameters mean that every method parameter is assignable from the given parameters.\nIn other words, it finds a method with the given name that will take the parameters given.\n\nThis method can match primitive parameter by passing in wrapper classes. For example, a\n{@code Boolean} will match a primitive {@code boolean} parameter.\n\n@param cls find method in this class\n@param methodName find method with this name\n@param parameterTypes find method with most compatible parameters\n@return The accessible method", "predict": "/**\n     * Gets a matching accessible method with the specified name and parameter types for the given class.\n     * <p>\n     * This method traverses the class hierarchy upwards, starting from the specified class, and returns the first matching accessible method.\n     * <p>\n     * If no matching method is found, this method returns {@code null}.\n     * <p>\n     * This method handles varargs methods correctly, i.e. it checks whether the varargs parameter type matches the corresponding argument type(s).\n     * <p>\n     * This method uses a workaround to make non-public methods accessible, which may result in a security exception if the calling code does not have appropriate permissions.\n     * \n     * @param cls the class to introspect\n     * @param methodName the name of the method to find\n     * @param parameterTypes the parameter types of the method to find (varargs are supported)\n     * @return the first matching accessible method, or {@code null} if none found\n     */\n    public static Method getMatchingAccessible"}, {"ID": 553, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } }\n\n    ### Response:", "ground_truth": "Invoked when a client error occurs, that is, an error in the 4xx series.\n\nThe base implementation calls onBadRequest, onForbidden, onNotFound, or onOtherClientError\ndepending on the HTTP status code.\n\n@param request The request that caused the client error.\n@param statusCode The error status code. Must be greater or equal to 400, and less than 500.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method is invoked when the client sends a request with an error status code.\r\n     *\r\n     * @param request The request header.\r\n     * @param statusCode The status code of the error.\r\n     * @param message The error message.\r\n     * @return A CompletionStage of Result.\r\n     */\r\n    @Override\r\n    public CompletionStage<Result> onClientError(RequestHeader request, int statusCode, String message) {\r\n        if (statusCode == 400) {\r\n            return onBadRequest(request, message);\r\n        } else if (statusCode == 403) {\r\n            return onForbidden(request, message);\r\n        } else if (statusCode == 404) {\r\n            return onNotFound(request, message);\r\n        } else if (statusCode >= 400 && statusCode < 500) {\r\n            return onOtherClientError(request, statusCode, message);\r\n        } else {\r\n            throw new IllegalArgumentException(\"onClientError invoked with non client error status code \" + statusCode + \": \" + message);\r\n        }\r\n   "}, {"ID": 554, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.badRequest( views.html.defaultpages.badRequest.render( request.method(), request.uri(), message, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked when a client makes a bad request.\n\nReturns Results.badRequest (400) with the included template from {@code\nviews.html.defaultpages.badRequest} as the content.\n\n@param request The request that was bad.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method handles the case when the request is invalid.\r\n     * \r\n     * @param request The request header.\r\n     * @param message The error message.\r\n     * @return A completion stage of the result.\r\n     */\r\n    protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) {\r\n        return CompletableFuture.completedFuture(Results.badRequest(views.html.defaultpages.badRequest.render(request.method(), request.uri(), message, request.asScala())));\r\n    }"}, {"ID": 555, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onForbidden(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked when a client makes a request that was forbidden.\n\nReturns Results.forbidden (401) with the included template from {@code\nviews.html.defaultpages.unauthorized} as the content.\n\n@param request The forbidden request.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method is called when a user is forbidden from accessing a resource.\r\n     * \r\n     * @param request The request header.\r\n     * @param message The message to display to the user.\r\n     * @return A completion stage of a forbidden result.\r\n     */\r\n    protected CompletionStage<Result> onForbidden(RequestHeader request, String message) {\r\n        return CompletableFuture.completedFuture(Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala())));\r\n    }"}, {"ID": 556, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onNotFound(RequestHeader request, String message) { if (environment.isProd()) { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.notFound.render( request.method(), request.uri(), request.asScala()))); } else { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.devNotFound.render( request.method(), request.uri(), Some.apply(routes.get()), request.asScala()))); } }\n\n    ### Response:", "ground_truth": "Invoked when a handler or resource is not found.\n\nIf the environment's mode is production, then returns Results.notFound (404) with the\nincluded template from `views.html.defaultpages.notFound` as the content.\n\nOtherwise, Results.notFound (404) is rendered with {@code\nviews.html.defaultpages.devNotFound} template.\n\n@param request The request that no handler was found to handle.\n@param message A message, which is not used by the default implementation.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method handles the case when a resource is not found.\r\n     *\r\n     * @param request The request header.\r\n     * @param message The error message.\r\n     * @return A CompletionStage of Result.\r\n     */\r\n    protected CompletionStage<Result> onNotFound(RequestHeader request, String message) {\r\n        if (environment.isProd()) {\r\n            return CompletableFuture.completedFuture(\r\n                    Results.notFound(\r\n                            views.html.defaultpages.notFound.render(\r\n                                    request.method(),\r\n                                    request.uri(),\r\n                                    request.asScala()\r\n                            )\r\n                    )\r\n            );\r\n        } else {\r\n            return CompletableFuture.completedFuture(\r\n                    Results.notFound(\r\n                            views.html.defaultpages.devNotFound.render(\r\n                                    request.method(),\r\n                                    request.uri(),\r\n                                    Some.apply(routes.get()),\r\n                                    request.asScala()\r\n                            )\r\n                    )\r\n            );\r\n        }\r\n    }"}, {"ID": 557, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return CompletableFuture.completedFuture(Results.internalServerError()); } }\n\n    ### Response:", "ground_truth": "Invoked when a server error occurs.\n\nBy default, the implementation of this method delegates to [[onProdServerError()]] when in\nprod mode, and [[onDevServerError()]] in dev mode. It is recommended, if you want Play's debug\ninfo on the error page in dev mode, that you override [[onProdServerError()]] instead of this\nmethod.\n\n@param request The request that triggered the server error.\n@param exception The server error.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method is called when there is an error in the server. It logs the error, converts the exception to a useful exception, and then calls the appropriate method based on the environment mode.\r\n     * \r\n     * @param request The request header.\r\n     * @param exception The exception that occurred.\r\n     * @return A CompletionStage of a Result.\r\n     */\r\n    @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) {\r\n        try {\r\n            UsefulException usefulException = throwableToUsefulException(exception);\r\n            logServerError(request, usefulException);\r\n            switch (environment.mode()) {\r\n                case PROD:\r\n                    return onProdServerError(request, usefulException);\r\n                default:\r\n                    return onDevServerError(request, usefulException);\r\n            }\r\n        } catch (Exception e) {\r\n            logger.error(\"Error while handling error\", e);\r\n            return CompletableFuture.completedFuture(Results.internalServerError());\r\n        }\r\n    }"}, {"ID": 558, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void logServerError(RequestHeader request, UsefulException usefulException) { logger.error( String.format( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException); }\n\n    ### Response:", "ground_truth": "Responsible for logging server errors.\n\nThe base implementation uses a SLF4J Logger. If a special annotation is desired for internal\nserver errors, you may want to use SLF4J directly with the Marker API to distinguish server\nerrors from application errors.\n\nThis can also be overridden to add additional logging information, eg. the id of the\nauthenticated user.\n\n@param request The request that triggered the server error.\n@param usefulException The server error.", "predict": "/**\r\n     * Logs an error message for a server error.\r\n     * \r\n     * @param request the request header\r\n     * @param usefulException the exception that caused the error\r\n     */\r\n    protected void logServerError(RequestHeader request, UsefulException usefulException) {\r\n        logger.error(String.format(\"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException);\r\n    }"}, {"ID": 559, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final UsefulException throwableToUsefulException(final Throwable throwable) { return HttpErrorHandlerExceptions.throwableToUsefulException( sourceMapper.sourceMapper(), environment.isProd(), throwable); }\n\n    ### Response:", "ground_truth": "Convert the given exception to an exception that Play can report more information about.\n\nThis will generate an id for the exception, and in dev mode, will load the source code for\nthe code that threw the exception, making it possible to report on the location that the\nexception was thrown from.", "predict": "/**\r\n     * Converts a Throwable to a UsefulException.\r\n     *\r\n     * @param throwable the Throwable to convert\r\n     * @return a UsefulException representing the given Throwable\r\n     */\r\n    protected final UsefulException throwableToUsefulException(final Throwable throwable) {\r\n        return HttpErrorHandlerExceptions.throwableToUsefulException(sourceMapper.sourceMapper(), environment.isProd(), throwable);\r\n    }"}, {"ID": 560, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked in dev mode when a server error occurs. Note that this method is where the URL set by\nplay.editor is used.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.devError}.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method is called when a server error occurs in the development environment.\r\n     * It returns a CompletionStage of a Result object, which is an internal server error page with the details of the exception.\r\n     * \r\n     * @param request The request header object\r\n     * @param exception The exception object that caused the server error\r\n     * @return A CompletionStage of a Result object\r\n     */\r\n    protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) {\r\n        return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala())));\r\n    }"}, {"ID": 561, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala()))); }\n\n    ### Response:", "ground_truth": "Invoked in prod mode when a server error occurs.\n\nThe base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.error} template.\n\nOverride this rather than [[onServerError()]] if you don't want to change Play's debug\noutput when logging errors in dev mode.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": "/**\r\n     * This method handles production server errors by rendering the default error page with the exception message and request details.\r\n     * @param request The request header object\r\n     * @param exception The exception object that caused the error\r\n     * @return A CompletionStage object that completes with a Result object containing the default error page\r\n     */\r\n    protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) {\r\n        return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala())));\r\n    }"}, {"ID": 562, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); }\n\n    ### Response:", "ground_truth": "Create a BuildDocHandler that serves documentation from the given files, which could either be\ndirectories or jar files. The baseDir array must be the same length as the files array, and the\ncorresponding entry in there for jar files is used as a base directory to use resources from in\nthe jar.\n\n@param files The directories or jar files to serve documentation from.\n@param baseDirs The base directories for the jar files. Entries may be null.\n@return a BuildDocHandler.", "predict": "/**\r\n     * Creates a new BuildDocHandler instance from the given resources.\r\n     *\r\n     * @param files an array of files or directories to load resources from\r\n     * @param baseDirs an array of base directories to use for loading resources from directories\r\n     * @return a new BuildDocHandler instance\r\n     * @throws IOException if an error occurs while loading resources\r\n     */\r\n    public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {\r\n        assert (files.length == baseDirs.length);\r\n        FileRepository[] repositories = new FileRepository[files.length];\r\n        List<JarFile> jarFiles = new ArrayList<>();\r\n        for (int i = 0; i < files.length; i++) {\r\n            File file = files[i];\r\n            String baseDir = baseDirs[i];\r\n            if (file.isDirectory()) {\r\n                repositories[i] = new FilesystemRepository(file);\r\n            } else {\r\n                // Assume it's a jar file\r\n                JarFile jarFile = new JarFile(file);\r\n                jar"}, {"ID": 563, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectory(File directory) { FileRepository repo = new FilesystemRepository(directory); return new DocumentationHandler(repo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given directory by wrapping a\nFilesystemRepository.\n\n@param directory The directory to serve the documentation from.", "predict": "/**\r\n     * Creates a new BuildDocHandler instance that reads documentation from the specified directory.\r\n     *\r\n     * @param directory the directory to read documentation from\r\n     * @return a new BuildDocHandler instance\r\n     */\r\n    public static BuildDocHandler fromDirectory(File directory) {\r\n        FileRepository repo = new FilesystemRepository(directory);\r\n        return new DocumentationHandler(repo);\r\n    }"}, {"ID": 564, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) { return fromDirectoryAndJar(directory, jarFile, base, false); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": "/**\r\n     * Creates a new BuildDocHandler instance from the specified directory and jar file.\r\n     *\r\n     * @param directory the directory containing the documentation files\r\n     * @param jarFile the jar file containing the documentation files\r\n     * @param base the base URL for the documentation files\r\n     * @return a new BuildDocHandler instance\r\n     */\r\n    public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) {\r\n        return fromDirectoryAndJar(directory, jarFile, base, false);\r\n    }"}, {"ID": 565, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.\n@param fallbackToJar Whether the doc handler should fall back to the jar repo for docs.", "predict": "/**\r\n     * Creates a new BuildDocHandler instance that will search for documentation in the specified directory and jar file.\r\n     *\r\n     * @param directory the directory to search for documentation files\r\n     * @param jarFile the jar file to search for documentation files\r\n     * @param base the base directory within the jar file to search for documentation files\r\n     * @param fallbackToJar if true, documentation will be searched for in the jar file first, followed by the directory\r\n     * @return a new BuildDocHandler instance\r\n     */\r\n    public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base, boolean fallbackToJar) {\r\n        FileRepository fileRepo = new FilesystemRepository(directory);\r\n        FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base));\r\n        FileRepository manualRepo;\r\n        if (fallbackToJar) {\r\n            manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo});\r\n        } else {\r\n            manualRepo = fileRepo;\r\n        }\r\n        return new Documentation"}, {"ID": 566, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BuildDocHandler fromJar(JarFile jarFile, String base) { FileRepository repo = new JarRepository(jarFile, Option.apply(base)); return new DocumentationHandler(repo); }\n\n    ### Response:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a\nJarRepository.\n\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": "/**\r\n     * Creates a new BuildDocHandler instance from a JarFile and a base directory.\r\n     *\r\n     * @param jarFile the JarFile to read documentation from\r\n     * @param base the base directory to use for resolving relative paths\r\n     * @return a new BuildDocHandler instance\r\n     */\r\n    public static BuildDocHandler fromJar(JarFile jarFile, String base) {\r\n        FileRepository repo = new JarRepository(jarFile, Option.apply(base));\r\n        return new DocumentationHandler(repo);\r\n    }"}, {"ID": 567, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); }\n\n    ### Response:", "ground_truth": "Consumes the data.\n\nThis method should be used carefully, since if the source represents an ephemeral stream,\nthen the entity may not be usable after this method is invoked.\n\n@param mat the application's materializer.\n@return a CompletionStage holding the data", "predict": "/**\r\n     * Consumes the data stream and returns a CompletionStage of the concatenated ByteString.\r\n     *\r\n     * @param mat The Materializer to be used for running the stream.\r\n     * @return A CompletionStage of the concatenated ByteString.\r\n     */\r\n    public CompletionStage<ByteString> consumeData(Materializer mat);"}, {"ID": 568, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); }\n\n    ### Response:", "ground_truth": "Create an entity from the given content.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": "/**\r\n     * Creates a new HttpEntity from the given content.\r\n     *\r\n     * @param content the content to create the entity from\r\n     * @param charset the charset to use for the entity\r\n     * @return the HttpEntity\r\n     */\r\n    public static final HttpEntity fromContent(Content content, String charset) {\r\n        String body;\r\n        if (content instanceof Xml) {\r\n            // See https://github.com/playframework/playframework/issues/2770\r\n            body = content.body().trim();\r\n        } else {\r\n            body = content.body();\r\n        }\r\n        return new Strict(ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset));\r\n    }"}, {"ID": 569, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity fromString(String content, String charset) { return new Strict( ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset)); }\n\n    ### Response:", "ground_truth": "Create an entity from the given String.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": "/**\r\n     * Creates a new HttpEntity from the given string content and charset.\r\n     * \r\n     * @param content the string content to use for the entity\r\n     * @param charset the charset to use for the entity\r\n     * @return a new HttpEntity with the given content and charset\r\n     */\r\n    public static final HttpEntity fromString(String content, String charset) {\r\n        return new Strict(ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset));\r\n    }"}, {"ID": 570, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); }\n\n    ### Response:", "ground_truth": "Convert the given source of ByteStrings to a chunked entity.\n\n@param data The source.\n@param contentType The optional content type.\n@return The ByteStrings.", "predict": "/**\r\n     * Creates a new chunked entity with the given data source and content type.\r\n     *\r\n     * @param data the data source\r\n     * @param contentType the content type, or an empty optional to use the default content type\r\n     * @return the chunked entity\r\n     */\r\n    public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); }"}, {"ID": 571, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, JsonNode content) { return status(status, content, JsonEncoding.UTF8); }\n\n    ### Response:", "ground_truth": "Generates a simple result with json content and UTF8 encoding.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content as a play-json object\n@return the result", "predict": "/**\r\n     * Returns a Result object with the given status and content.\r\n     *\r\n     * @param status the HTTP status code\r\n     * @param content the content to include in the response\r\n     * @return a Result object with the given status and content\r\n     */\r\n    public static Result status(int status, JsonNode content) {\r\n        return status(status, content, JsonEncoding.UTF8);\r\n    }"}, {"ID": 572, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, JsonNode content, JsonEncoding encoding) { if (content == null) { throw new NullPointerException(\"Null content\"); } return status(status).sendJson(content, encoding); }\n\n    ### Response:", "ground_truth": "Generates a simple result with json content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a play-json object\n@param encoding the encoding into which the json should be encoded\n@return the result", "predict": "/**\r\n     * Returns a Result object with the given status code and the content as JSON.\r\n     *\r\n     * @param status the HTTP status code\r\n     * @param content the JSON content to send\r\n     * @param encoding the encoding to use for the JSON content\r\n     * @return a Result object with the given status code and the content as JSON\r\n     * @throws NullPointerException if the content is null\r\n     */\r\n    public static Result status(int status, JsonNode content, JsonEncoding encoding) {\r\n        if (content == null) {\r\n            throw new NullPointerException(\"Null content\");\r\n        }\r\n        return status(status).sendJson(content, encoding);\r\n    }"}, {"ID": 573, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, byte[] content) { if (content == null) { throw new NullPointerException(\"Null content\"); } return new Result( status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty())); }\n\n    ### Response:", "ground_truth": "Generates a simple result with byte-array content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a byte array\n@return the result", "predict": "/**\r\n     * This method takes in an integer status code and a byte array content and returns a Result object.\r\n     * \r\n     * @param status - an integer status code\r\n     * @param content - a byte array content\r\n     * @return a Result object\r\n     * @throws NullPointerException if the content is null\r\n     */\r\n    public static Result status(int status, byte[] content) {\r\n        if (content == null) {\r\n            throw new NullPointerException(\"Null content\");\r\n        }\r\n        return new Result(status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty()));\r\n    }"}, {"ID": 574, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, InputStream content, long contentLength) { return status(status).sendInputStream(content, contentLength); }\n\n    ### Response:", "ground_truth": "Generates a chunked result.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the input stream containing data to chunk over\n@param contentLength the length of the provided content in bytes.\n@return the result", "predict": "/**\r\n     * This method is used to set the status code and send the input stream to the client.\r\n     * \r\n     * @param status The HTTP status code to set.\r\n     * @param content The input stream to send to the client.\r\n     * @param contentLength The length of the input stream.\r\n     * @return The Result object with the status code set and the input stream sent to the client.\r\n     */\r\n    public static Result status(int status, InputStream content, long contentLength) {\r\n        return status(status).sendInputStream(content, contentLength);\r\n    }"}, {"ID": 575, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result status(int status, File content) { return status(status, content, StaticFileMimeTypes.fileMimeTypes()); }\n\n    ### Response:", "ground_truth": "Generates a result with file contents.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the file to send\n@return the result", "predict": "/**\r\n     * Returns a Result object with the given status code and content.\r\n     *\r\n     * @param status the HTTP status code\r\n     * @param content the content to be returned\r\n     * @return a Result object with the given status code and content\r\n     */\r\n    public static Result status(int status, File content) {\r\n        return status(status, content, StaticFileMimeTypes.fileMimeTypes());\r\n    }"}, {"ID": 576, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private User findById(Long id) { if (id > 3) return null; User user = new User(); user.id = id; user.name = \"User \" + String.valueOf(id); return user; }\n\n    ### Response:", "ground_truth": "designed to be lightweight operation", "predict": "/**\r\n     * This method finds a user by their id.\r\n     * \r\n     * @param id the id of the user to find\r\n     * @return the user with the given id, or null if no user is found\r\n     */\r\n    private User findById(Long id) {\r\n        if (id > 3) {\r\n            return null;\r\n        }\r\n        User user = new User();\r\n        user.id = id;\r\n        user.name = \"User \" + String.valueOf(id);\r\n        return user;\r\n    }"}, {"ID": 577, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); }\n\n    ### Response:", "ground_truth": "Select a preferred language, given the list of candidates.\n\nWill select the preferred language, based on what languages are available, or return the\ndefault language if none of the candidates are available.\n\n@param candidates The candidate languages\n@return The preferred language", "predict": "/**\r\n     * Returns the preferred language from a collection of languages.\r\n     *\r\n     * @param candidates A collection of languages.\r\n     * @return The preferred language.\r\n     */\r\n    public Lang preferred(Collection<Lang> candidates) {\r\n        return new Lang(langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq()));\r\n    }"}, {"ID": 578, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); }\n\n    ### Response:", "ground_truth": "Append a unique identifier to the URL.\n\n@return a copy if this call with a unique identifier to this url", "predict": "/**\r\n     * Returns a new Call object with the same method, URL, and fragment as this one, but with a unique name.\r\n     *\r\n     * @return A new Call object with a unique name.\r\n     */\r\n    public Call unique() {\r\n        return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment());\r\n    }"}, {"ID": 579, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); }\n\n    ### Response:", "ground_truth": "Returns a new Call with the given fragment.\n\n@param fragment the URL fragment\n@return a copy of this call that contains the fragment", "predict": "/**\n     * Adds a fragment to the URL of the call.\n     *\n     * @param fragment the fragment to add to the URL\n     * @return a new call with the fragment added to the URL\n     */\n    public Call withFragment(String fragment) {\n        return new play.api.mvc.Call(method(), url(), fragment);\n    }"}, {"ID": 580, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String absoluteURL(Http.Request request) { return absoluteURL(request.secure(), request.host()); }\n\n    ### Response:", "ground_truth": "Transform this call to an absolute URL.\n\n@param request used to identify the host and protocol that should base this absolute URL\n@return the absolute URL string", "predict": "/**\r\n     * This method takes in an Http.Request object and returns the absolute URL of the request.\r\n     * @param request An Http.Request object.\r\n     * @return The absolute URL of the request.\r\n     */\r\n    public String absoluteURL(Http.Request request) {\r\n        return absoluteURL(request.secure(), request.host());\r\n    }"}, {"ID": 581, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String webSocketURL(Http.Request request) { return webSocketURL(request.secure(), request.host()); }\n\n    ### Response:", "ground_truth": "Transform this call to an WebSocket URL.\n\n@param request used as the base for forming the WS url\n@return the websocket url string", "predict": "/**\r\n     * Returns the WebSocket URL for the given request.\r\n     *\r\n     * @param request The HTTP request.\r\n     * @return The WebSocket URL.\r\n     */\r\n    public String webSocketURL(Http.Request request) {\r\n        return webSocketURL(request.secure(), request.host());\r\n    }"}, {"ID": 582, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new AbstractFunction1<Connection, BoxedUnit>() { public BoxedUnit apply(Connection connection) { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; }\n\n    ### Response:", "ground_truth": "Create a Scala function wrapper for ConnectionRunnable.\n\n@param block a Java functional interface instance to wrap\n@return a scala function that wraps the given block", "predict": "/**\r\n     * Creates a new connection function that executes the given block of code on the given connection.\r\n     *\r\n     * @param block the code to execute on the connection\r\n     * @return a new connection function that executes the given block of code on the given connection\r\n     */\r\n    public static AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) {\r\n        return new AbstractFunction1<Connection, BoxedUnit>() {\r\n            public BoxedUnit apply(Connection connection) {\r\n                try {\r\n                    block.run(connection);\r\n                    return BoxedUnit.UNIT;\r\n                } catch (java.sql.SQLException e) {\r\n                    throw new RuntimeException(\"Connection runnable failed\", e);\r\n                }\r\n            }\r\n        };\r\n    }"}, {"ID": 583, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) { return new AbstractFunction1<Connection, A>() { public A apply(Connection connection) { try { return block.call(connection); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; }\n\n    ### Response:", "ground_truth": "Create a Scala function wrapper for ConnectionCallable.\n\n@param block a Java functional interface instance to wrap\n@param  the provided block's return type\n@return a scala function wrapping the given block", "predict": "/**\r\n     * Creates a new connection function that takes a connection and returns a value of type A.\r\n     *\r\n     * @param block the block to execute with the connection\r\n     * @return a new connection function\r\n     */\r\n    public static <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) {\r\n        return new AbstractFunction1<Connection, A>() {\r\n            public A apply(Connection connection) {\r\n                try {\r\n                    return block.call(connection);\r\n                } catch (java.sql.SQLException e) {\r\n                    throw new RuntimeException(\"Connection callable failed\", e);\r\n                }\r\n            }\r\n        };\r\n    }"}, {"ID": 584, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) { return new Builder().mode(mode).http(port).build(block); }\n\n    ### Response:", "ground_truth": "Create a server for the router returned by the given block.\n\n@param block The block which creates a router.\n@param mode The mode the server will run on.\n@param port The port the server will run on.\n@return The running server.", "predict": "/**\r\n     * Creates a new server instance with the given mode, port, and router block.\r\n     *\r\n     * @param mode the server mode\r\n     * @param port the server port\r\n     * @param block the router block to use for creating the router\r\n     * @return the server instance\r\n     */\r\n    public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) {\r\n        return new Builder().mode(mode).http(port).build(block);\r\n    }"}, {"ID": 585, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Converts an object to JsonNode.\n\n@param data Value to convert in Json.\n@return the JSON node.", "predict": "/**\r\n * Converts the given object to a JSON string using the default ObjectMapper.\r\n *\r\n * @param data the object to convert to JSON\r\n * @return the JSON string representation of the object\r\n * @throws RuntimeException if an error occurs during conversion\r\n */\r\npublic static JsonNode toJson(final Object data) {\r\n    try {\r\n        return mapper().valueToTree(data);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"}, {"ID": 586, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Converts a JsonNode to a Java value\n\n@param  the type of the return value.\n@param json Json value to convert.\n@param clazz Expected Java value type.\n@return the return value.", "predict": "/**\r\n     * Converts a JSON node to an instance of the specified class using the Jackson library.\r\n     *\r\n     * @param json the JSON node to convert\r\n     * @param clazz the class to convert the JSON node to\r\n     * @param <A> the type of the class\r\n     * @return an instance of the specified class\r\n     */\r\n    public static <A> A fromJson(JsonNode json, Class<A> clazz) {\r\n        try {\r\n            return mapper().treeToValue(json, clazz);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }"}, {"ID": 587, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode parse(String src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } }\n\n    ### Response:", "ground_truth": "Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON string.\n@return the JSON node.", "predict": "/**\r\n     * Parses the given JSON string into a JsonNode object.\r\n     * \r\n     * @param src the JSON string to parse\r\n     * @return the JsonNode object representing the parsed JSON string\r\n     * @throws RuntimeException if an error occurs during parsing\r\n     */\r\n    public static JsonNode parse(String src) {\r\n        try {\r\n            return mapper().readTree(src);\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(t);\r\n        }\r\n    }"}, {"ID": 588, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } }\n\n    ### Response:", "ground_truth": "Parses a InputStream representing a json, and return it as a JsonNode.\n\n@param src the JSON input stream.\n@return the JSON node.", "predict": "/**\r\n     * Parses the given input stream into a JSON node using the Jackson library.\r\n     *\r\n     * @param src the input stream to parse\r\n     * @return the parsed JSON node\r\n     * @throws RuntimeException if an error occurs during parsing\r\n     */\r\n    public static JsonNode parse(java.io.InputStream src) {\r\n        try {\r\n            return mapper().readTree(src);\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(t);\r\n        }\r\n    }"}, {"ID": 589, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String relative(String startPath, String targetPath) { // If the start and target path's are the same then link to the current directory if (startPath.equals(targetPath)) { return CURRENT_DIR; } String[] start = toSegments(canonical(startPath)); String[] target = toSegments(canonical(targetPath)); // If start path has no trailing separator (a \"file\" path), then drop file segment if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1); // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = \"\"; if (!targetPath.endsWith(SEPARATOR)) { targetFile = target[target.length - 1]; target = Arrays.copyOfRange(target, 0, target.length - 1); } // Work out how much of the filepath is shared by start and path. String[] common = commonPrefix(start, target); String[] parents = toParentDirs(start.length - common.length); int relativeStartIdx = common.length; String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length); String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length); System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length); // If this is not a sibling reference append a trailing / to path String trailingSep = \"\"; if (relativePath.length > 0) trailingSep = SEPARATOR; return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR)) + trailingSep + targetFile; }\n\n    ### Response:", "ground_truth": "Create a path to targetPath that's relative to the given startPath.", "predict": "/**\r\n     * Generates a relative path from the start path to the target path.\r\n     * \r\n     * @param startPath the starting path\r\n     * @param targetPath the target path\r\n     * @return the relative path\r\n     */\r\n    public static String relative(String startPath, String targetPath) {\r\n        // If the start and target path's are the same then link to the current directory\r\n        if (startPath.equals(targetPath)) {\r\n            return CURRENT_DIR;\r\n        }\r\n        \r\n        // Convert paths to segments and canonicalize them\r\n        String[] start = toSegments(canonical(startPath));\r\n        String[] target = toSegments(canonical(targetPath));\r\n        \r\n        // If start path has no trailing separator (a \"file\" path), then drop file segment\r\n        if (!startPath.endsWith(SEPARATOR)) {\r\n            start = Arrays.copyOfRange(start, 0, start.length - 1);\r\n        }\r\n        \r\n        // If target path has no trailing separator, then drop file segment, but keep a reference to add it later\r\n        String targetFile = \"\";"}, {"ID": 590, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String canonical(String url) { String[] urlPath = toSegments(url); Stack<String> canonical = new Stack<>(); for (String comp : urlPath) { if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue; if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp); else canonical.pop(); } String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\"; String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\"; return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep; }\n\n    ### Response:", "ground_truth": "Create a canonical path that does not contain parent directories, current directories, or\nsuperfluous directory separators.", "predict": "/**\r\n     * Converts a URL to its canonical form.\r\n     *\r\n     * @param url the URL to convert\r\n     * @return the canonical form of the URL\r\n     */\r\n    public static String canonical(String url) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 591, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); }\n\n    ### Response:", "ground_truth": "Converts a set of constraints to human-readable values. Does not guarantee the order of the\nreturned constraints.\n\nThis method calls {@code displayableConstraint} under the hood.\n\n@param constraints the set of constraint descriptors.\n@return a list of pairs of tuples assembled from displayableConstraint.", "predict": "/**\r\n     * This method takes a set of constraint descriptors and returns a list of tuples containing the constraint name and a list of objects that can be displayed.\r\n     * @param constraints A set of constraint descriptors.\r\n     * @return A list of tuples containing the constraint name and a list of objects that can be displayed.\r\n     */\r\n    public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); }"}, {"ID": 592, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Tuple<String, List<Object>> displayableConstraint( ConstraintDescriptor<?> constraint) { final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class); return Tuple( displayAnnotation.name(), Collections.unmodifiableList( Stream.of(displayAnnotation.attributes()) .map(attr -> constraint.getAttributes().get(attr)) .collect(Collectors.toList()))); }\n\n    ### Response:", "ground_truth": "Converts a constraint to a human-readable value.\n\n@param constraint the constraint descriptor.\n@return A tuple containing the constraint's display name and the constraint attributes.", "predict": "/**\r\n     * This method takes a constraint descriptor and returns a tuple containing the display name and a list of displayable attributes.\r\n     * @param constraint the constraint descriptor to be processed\r\n     * @return a tuple containing the display name and a list of displayable attributes\r\n     */\r\n    public static Tuple<String, List<Object>> displayableConstraint(ConstraintDescriptor<?> constraint) {\r\n        final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class);\r\n        return Tuple(displayAnnotation.name(), Collections.unmodifiableList(Stream.of(displayAnnotation.attributes())\r\n                .map(attr -> constraint.getAttributes().get(attr))\r\n                .collect(Collectors.toList())));\r\n    }"}, {"ID": 593, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); }\n\n    ### Response:", "ground_truth": "Creates a CompletionStage that returns either the input stage, or a futures.\n\nNote that timeout is not the same as cancellation. Even in case of futures, the given\ncompletion stage will still complete, even though that completed value is not returned.\n\n@param stage the input completion stage that may time out.\n@param amount The amount (expressed with the corresponding unit).\n@param unit The time Unit.\n@param  the completion's result type.\n@return either the completed future, or a completion stage that failed with futures.", "predict": "/**\n     * This method overrides the timeout method of the CompletionStage interface and returns a CompletionStage with the specified timeout duration.\n     * @param stage the CompletionStage to apply the timeout to\n     * @param amount the timeout duration\n     * @param unit the time unit of the timeout duration\n     * @return a CompletionStage with the specified timeout duration\n     */\n    @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); }"}, {"ID": 594, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAssignable( Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) { return false; } if (classArray == null) { classArray = EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Checks if an array of Classes can be assigned to another array of Classes.\n\nThis method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in\nthe input arrays. It can be used to check if a set of arguments (the first parameter) are\nsuitably compatible with a set of method parameter types (the second parameter).\n\nUnlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into\naccount widenings of primitive classes and {@code null}s.\n\nPrimitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code\ndouble}. This method returns the correct result for these cases.\n\n{@code Null} may be assigned to any reference type. This method will return {@code true} if\n{@code null} is passed in and the toClass is non-primitive.\n\nSpecifically, this method tests whether the type represented by the specified {@code Class}\nparameter can be converted to the type represented by this {@code Class} object via an identity\nconversion widening primitive or widening reference conversion. See The Java Language Specification, sections\n5.1.1, 5.1.2 and 5.1.4 for details.\n\n@param classArray the array of Classes to check, may be {@code null}\n@param toClassArray the array of Classes to try to assign into, may be {@code null}\n@param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n@return {@code true} if assignment possible", "predict": "/**\r\n     * Checks if an array of classes is assignable to another array of classes.\r\n     * \r\n     * @param classArray\r\n     *            the array of classes to be assigned to\r\n     * @param toClassArray\r\n     *            the array of classes to be assigned\r\n     * @param autoboxing\r\n     *            whether to apply autoboxing rules\r\n     * @return true if the classArray is assignable to the toClassArray, false otherwise\r\n     */\r\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\r\n        if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) {\r\n            return false;\r\n        }\r\n        if (classArray == null) {\r\n            classArray = EMPTY_CLASS_ARRAY;\r\n        }\r\n        if (toClassArray == null) {\r\n            toClassArray = EMPTY_CLASS_ARRAY;\r\n        }\r\n        for (int i = 0; i < classArray.length; i++) {\r\n            if (isAssignable(classArray[i], to"}, {"ID": 595, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Date parseCRONExpression(String cron) { try { return new CronExpression(cron).getNextValidTimeAfter(new Date()); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } }\n\n    ### Response:", "ground_truth": "Parses a CRON expression.\n\n@param cron the CRON String\n@return the next Date that satisfies the expression", "predict": "/**\r\n     * Parses the given CRON expression and returns the next valid date after the current date.\r\n     *\r\n     * @param cron the CRON expression to be parsed\r\n     * @return the next valid date after the current date\r\n     * @throws IllegalArgumentException if the given CRON expression is invalid\r\n     */\r\n    public static Date parseCRONExpression(String cron) {\r\n        try {\r\n            return new CronExpression(cron).getNextValidTimeAfter(new Date());\r\n        } catch (Exception e) {\r\n            throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e);\r\n        }\r\n    }"}, {"ID": 596, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long cronInterval(String cron, Date date) { try { return new CronExpression(cron).getNextInterval(date); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } }\n\n    ### Response:", "ground_truth": "Compute the number of milliseconds between the next valid date and the one after.\n\n@param cron the CRON String\n@param date the date to start search\n@return the number of milliseconds between the next valid date and the one after, with an\ninvalid interval between", "predict": "/**\r\n     * This method takes in a CRON expression and a date and returns the next interval of time that the CRON expression will occur.\r\n     * \r\n     * @param cron - A string representing the CRON expression.\r\n     * @param date - A date object representing the current date and time.\r\n     * @return A long representing the number of milliseconds until the next CRON expression occurs.\r\n     * @throws IllegalArgumentException - If the CRON expression is invalid.\r\n     */\r\n    public static long cronInterval(String cron, Date date) {\r\n        try {\r\n            return new CronExpression(cron).getNextInterval(date);\r\n        } catch (Exception e) {\r\n            throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e);\r\n        }\r\n    }"}, {"ID": 597, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); }\n\n    ### Response:", "ground_truth": "Creates WS client manually from configuration, internally creating a new instance of\nAsyncHttpClient and managing its own thread pool.\n\nThis client is not managed as part of Play's lifecycle, and must be closed by calling\nws.close(), otherwise you will run into memory leaks.\n\n@param config a config object, usually from AhcWSClientConfigFactory\n@param cache if not null, provides HTTP caching.\n@param materializer an Akka materializer\n@return a new instance of AhcWSClient.", "predict": "/**\r\n     * Creates a new AhcWSClient instance using the specified configuration, cache, and materializer.\r\n     *\r\n     * @param config the AhcWSClientConfig to use for configuring the client\r\n     * @param cache the AhcHttpCache to use for caching responses\r\n     * @param materializer the Materializer to use for materializing responses\r\n     * @return a new AhcWSClient instance\r\n     */\r\n    public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) {\r\n        final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer);\r\n        return new AhcWSClient(client, materializer);\r\n    }"}, {"ID": 598, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder builder(ApplicationLoader.Context context) { return initialBuilder .in(context.environment()) .loadConfig(context.initialConfig()) .overrides(overrides(context)); }\n\n    ### Response:", "ground_truth": "Construct a builder to use for loading the given context.\n\n@param context the context the returned builder will load\n@return the builder", "predict": "/**\r\n     * Creates a new GuiceApplicationBuilder with the given context.\r\n     *\r\n     * @param context the application context\r\n     * @return a new GuiceApplicationBuilder\r\n     */\r\n    public GuiceApplicationBuilder builder(ApplicationLoader.Context context) {\r\n        return initialBuilder.in(context.environment())\r\n                .loadConfig(context.initialConfig())\r\n                .overrides(overrides(context));\r\n    }"}, {"ID": 599, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); }\n\n    ### Response:", "ground_truth": "Generates a 501 NOT_IMPLEMENTED simple result.", "predict": "/**\r\n     * TODO: This method is responsible for handling the TODO requests.\r\n     * \r\n     * @param request - The HTTP request object.\r\n     * @return - The HTTP response object.\r\n     */\r\n    public static Result TODO(Request request) {\r\n        return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala()));\r\n    }"}, {"ID": 600, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static void session(String key, String value) { session().put(key, value); }\n\n    ### Response:", "ground_truth": "Puts a new value into the current session.\n\n@param key the key to set into the session\n@param value the value to set for key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": "/**\r\n     * @deprecated\r\n     * @param key\r\n     * @param value\r\n     */\r\n    public static void session(String key, String value) {\r\n        session().put(key, value);\r\n    }"}, {"ID": 601, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static void flash(String key, String value) { flash().put(key, value); }\n\n    ### Response:", "ground_truth": "Puts a new value into the flash scope.\n\n@param key the key to put into the flash scope\n@param value the value corresponding to key\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": "/**\r\n     * This method is deprecated and should not be used.\r\n     * \r\n     * @param key   The key to be flashed.\r\n     * @param value The value to be flashed.\r\n     */\r\n    @Deprecated public static void flash(String key, String value) { flash().put(key, value); }"}, {"ID": 602, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); }\n\n    ### Response:", "ground_truth": "Qualify this binding key with the given instance of an annotation.\n\nThis can be used to specify bindings with annotations that have particular values.", "predict": "/**\n     * Returns a new BindingKey with the specified annotation instance added to the qualifiers.\n     *\n     * @param instance the annotation instance to add to the qualifiers\n     * @param <A> the type of the annotation\n     * @return a new BindingKey with the specified annotation instance added to the qualifiers\n     */\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) {\n        return underlying.qualifiedWith(instance).asJava();\n    }"}, {"ID": 603, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation).asJava(); }\n\n    ### Response:", "ground_truth": "Qualify this binding key with the given annotation.\n\nFor example, you may have both a cached implementation, and a direct implementation of a\nservice. To differentiate between them, you may define a Cached annotation:\n\n{@code\nbindClass(Foo.class).qualifiedWith(Cached.class).to(FooCached.class),\nbindClass(Foo.class).to(FooImpl.class)\n\n...\n\nclass MyController {\n{@literal @}Inject\nMyController({@literal @}Cached Foo foo) {\n...\n}\n...\n}\n}\n\nIn the above example, the controller will get the cached {@code Foo} service.", "predict": "/**\n     * Returns a new BindingKey with the specified annotation type added to the qualifiers.\n     *\n     * @param annotation the annotation type to add to the qualifiers\n     * @param <A> the annotation type\n     * @return a new BindingKey with the specified annotation type added to the qualifiers\n     */\n    public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) {\n        return underlying.qualifiedWith(annotation).asJava();\n    }"}, {"ID": 604, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given implementation class.\n\nThis class will be instantiated and injected by the injection framework.", "predict": "/**\r\n     * Binds the underlying {@link Provider} to the specified implementation type.\r\n     *\r\n     * @param implementation the implementation type to bind to\r\n     * @param <T> the type of the implementation\r\n     * @return a new {@link Binding} instance\r\n     */\r\n    public <T> Binding<T> to(final Class<? extends T> implementation) {\r\n        return underlying.to(implementation).asJava();\r\n    }"}, {"ID": 605, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given provider instance.\n\nThis provider instance will be invoked to obtain the implementation for the key.", "predict": "/**\n     * Binds the underlying {@link Binding} to a new provider.\n     *\n     * @param provider the new provider\n     * @return the new {@link Binding}\n     */\n    public Binding<T> to(final Provider<? extends T> provider) {\n        return underlying.to(provider).asJava();\n    }"}, {"ID": 606, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given instance.", "predict": "/**\r\n     * Binds the given instance to the underlying {@link Binding} as a Java type.\r\n     *\r\n     * @param instance the instance to bind\r\n     * @param <A> the type of the instance\r\n     * @return the bound instance as a Java type\r\n     */\r\n    public <A extends T> Binding<T> to(final Supplier<A> instance) {\r\n        return underlying.to(new FromJavaSupplier<>(instance)).asJava();\r\n    }"}, {"ID": 607, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Binding<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to another binding key.", "predict": "/**\n     * Binds the specified key to the underlying binding.\n     *\n     * @param key the key to bind to\n     * @return the bound binding\n     */\n    public Binding<T> to(final BindingKey<? extends T> key) {\n        return underlying.to(key.asScala()).asJava();\n    }"}, {"ID": 608, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) { return underlying.toProvider(provider).asJava(); }\n\n    ### Response:", "ground_truth": "Bind this binding key to the given provider class.\n\nThe dependency injection framework will instantiate and inject this provider, and then\ninvoke its `get` method whenever an instance of the class is needed.", "predict": "/**\r\n     * Returns a new binding that uses the specified provider to provide instances of the bound type.\r\n     *\r\n     * @param provider the provider class\r\n     * @param <P> the provider type\r\n     * @param <T> the bound type\r\n     * @return a new binding that uses the specified provider to provide instances of the bound type\r\n     */\r\n    public <P extends Provider<? extends T>, T> Binding<T> toProvider(final Class<P> provider) {\r\n        return underlying.toProvider(provider).asJava();\r\n    }"}, {"ID": 609, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<Lang> availables(Application app) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables()); return availableLangs.stream().map(Lang::new).collect(toList()); }\n\n    ### Response:", "ground_truth": "Retrieve Lang availables from the application configuration.\n\n@param app the current application.\n@return the list of available Lang.", "predict": "/**\r\n     * Returns a list of available languages for the given application.\r\n     *\r\n     * @param app the application to retrieve the available languages from\r\n     * @return a list of available languages\r\n     */\r\n    public static List<Lang> availables(Application app) {\r\n        play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class);\r\n        List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables());\r\n        return availableLangs.stream().map(Lang::new).collect(toList());\r\n    }"}, {"ID": 610, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); }\n\n    ### Response:", "ground_truth": "Guess the preferred lang in the langs set passed as argument. The first Lang that matches an\navailable Lang wins, otherwise returns the first Lang available in this application.\n\n@param app the currept application\n@param availableLangs the set of langs from which to guess the preferred\n@return the preferred lang.", "predict": "/**\r\n     * Returns the preferred language for the given application and available languages.\r\n     *\r\n     * @param app the application\r\n     * @param availableLangs the available languages\r\n     * @return the preferred language\r\n     */\r\n    public static Lang preferred(Application app, List<Lang> availableLangs) {\r\n        play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class);\r\n        Stream<Lang> stream = availableLangs.stream();\r\n        List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList());\r\n        return new Lang(langs.preferred(Scala.toSeq(langSeq)));\r\n    }"}, {"ID": 611, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); }\n\n    ### Response:", "ground_truth": "Create an evolutions reader based on a simple map of database names to evolutions.\n\n@param evolutions The map of database names to evolutions.\n@return the evolutions reader.", "predict": "/**\r\n     * Creates a new instance of SimpleEvolutionsReader with the given evolutions map.\r\n     *\r\n     * @param evolutions the map of evolutions to use\r\n     * @return a new instance of SimpleEvolutionsReader\r\n     */\r\n    public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); }"}, {"ID": 612, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); }\n\n    ### Response:", "ground_truth": "Create an evolutions reader for the default database from a list of evolutions.\n\n@param evolutions The list of evolutions.\n@return the evolutions reader.", "predict": "/**\r\n * Returns an EvolutionsReader that reads the evolutions from the given list of evolutions.\r\n *\r\n * @param evolutions the list of evolutions to read\r\n * @return an EvolutionsReader that reads the evolutions from the given list of evolutions\r\n */\r\npublic static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) {\r\n    Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>();\r\n    map.put(\"default\", Arrays.asList(evolutions));\r\n    return fromMap(map);\r\n}"}, {"ID": 613, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cleanupEvolutions(Database database, boolean autocommit, String schema) { DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema); evolutions.evolve(evolutions.resetScripts(), autocommit); }\n\n    ### Response:", "ground_truth": "Cleanup evolutions for the given database.\n\nThis will run the down scripts for all the applied evolutions.\n\n@param database The database to apply the evolutions to.\n@param autocommit Whether autocommit should be used.\n@param schema The schema where all the play evolution tables are saved in", "predict": "/**\r\n     * This method is used to clean up the evolutions applied to the database.\r\n     * \r\n     * @param database - The database object to clean up evolutions for.\r\n     * @param autocommit - Whether to commit the changes automatically or not.\r\n     * @param schema - The schema to clean up evolutions for.\r\n     */\r\n    public static void cleanupEvolutions(Database database, boolean autocommit, String schema) {\r\n        DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema);\r\n        evolutions.evolve(evolutions.resetScripts(), autocommit);\r\n    }"}, {"ID": 614, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); }\n\n    ### Response:", "ground_truth": "Set the initial configuration loader. Overrides the default or any previously configured\nvalues.\n\n@param load the configuration loader\n@return the configured application builder", "predict": "/**\n     * Sets the config loader for the GuiceApplicationBuilder.\n     *\n     * @param load a function that takes an Environment and returns a Config object.\n     * @return the updated GuiceApplicationBuilder.\n     */\n    public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) {\n        return newBuilder(delegate.loadConfig(func((play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env))))));\n    }"}, {"ID": 615, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); }\n\n    ### Response:", "ground_truth": "Set the module loader. Overrides the default or any previously configured values.\n\n@param loader the configuration\n@return the configured application builder", "predict": "/**\n     * Sets the module loader for the application.\n     *\n     * @param loader a function that takes an Environment and a Config and returns a list of GuiceableModule instances\n     * @return a new GuiceApplicationBuilder with the specified module loader\n     */\n    public GuiceApplicationBuilder withModuleLoader(BiFunction<Environment, Config, List<GuiceableModule>> loader) {\n        return newBuilder(delegate.load(func((play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying())))));\n    }"}, {"ID": 616, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given guiceable modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "/**\n     * Loads the given GuiceableModule instances into the current GuiceApplicationBuilder.\n     *\n     * @param modules the GuiceableModule instances to load\n     * @return the current GuiceApplicationBuilder instance\n     */\n    public GuiceApplicationBuilder load(GuiceableModule... modules) {\n        return newBuilder(delegate.load(Scala.varargs(modules)));\n    }"}, {"ID": 617, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(com.google.inject.Module... modules) { return load(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Guice modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "/**\n     * Loads the given modules into the application.\n     *\n     * @param modules the modules to load\n     * @return the updated builder\n     */\n    public GuiceApplicationBuilder load(com.google.inject.Module... modules) {\n        return load(Guiceable.modules(modules));\n    }"}, {"ID": 618, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(play.api.inject.Module... modules) { return load(Guiceable.modules(modules)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Play modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": "/**\n     * Loads the given modules into the Guice application builder.\n     *\n     * @param modules the modules to load\n     * @return the Guice application builder\n     */\n    public GuiceApplicationBuilder load(play.api.inject.Module... modules) {\n        return load(Guiceable.modules(modules));\n    }"}, {"ID": 619, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); }\n\n    ### Response:", "ground_truth": "Override the module loader with the given Play bindings.\n\n@param bindings the set of binding override\n@return an application builder that incorporates the overrides", "predict": "/**\n     * Loads the given bindings into the Guice injector.\n     *\n     * @param bindings the bindings to load\n     * @return the updated GuiceApplicationBuilder\n     */\n    public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) {\n        return load(Guiceable.bindings(bindings));\n    }"}, {"ID": 620, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); }\n\n    ### Response:", "ground_truth": "Implementation of Self creation for GuiceBuilder.\n\n@return the application builder", "predict": "/**\n     * Creates a new GuiceApplicationBuilder with the given GuiceApplicationBuilder as its parent.\n     *\n     * @param builder the parent GuiceApplicationBuilder\n     * @return a new GuiceApplicationBuilder with the given GuiceApplicationBuilder as its parent\n     */\n    protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) {\n        return new GuiceApplicationBuilder(builder);\n    }"}, {"ID": 621, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); encode(buf, cookie); return stripTrailingSeparator(buf); }\n\n    ### Response:", "ground_truth": "Encodes the specified cookie into a Cookie header value.\n\n@param cookie specified the cookie\n@return a Rfc6265 style Cookie header value", "predict": "/**\r\n     * Encodes the specified cookie into a string suitable for use in a URL.\r\n     *\r\n     * @param cookie the cookie to encode\r\n     * @return the encoded cookie string\r\n     * @throws NullPointerException if the cookie is null\r\n     */\r\n    public String encode(Cookie cookie) {\r\n        if (cookie == null) {\r\n            throw new NullPointerException(\"cookie\");\r\n        }\r\n        StringBuilder buf = new StringBuilder();\r\n        encode(buf, cookie);\r\n        return stripTrailingSeparator(buf);\r\n    }"}, {"ID": 622, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EntityManager em() { Deque<EntityManager> ems = this.emStack(true); if (ems.isEmpty()) { Http.Context.safeCurrent() .map( ctx -> { throw new RuntimeException( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\"); }) .orElseGet( () -> { throw new RuntimeException( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\"); }); } return ems.peekFirst(); }\n\n    ### Response:", "ground_truth": "Get the default EntityManager for this thread.\n\n@throws RuntimeException if no EntityManager is bound to the current Http.Context or the\ncurrent Thread.\n@return the EntityManager", "predict": "/**\r\n     * Returns the EntityManager for the current HTTP request.\r\n     *\r\n     * @return the EntityManager for the current HTTP request.\r\n     * @throws RuntimeException if no EntityManager is found in the context or if no EntityManager is bound to this thread.\r\n     */\r\n    public EntityManager em() {\r\n        Deque<EntityManager> ems = this.emStack(true);\r\n        if (ems.isEmpty()) {\r\n            Http.Context.safeCurrent()\r\n                    .map(ctx -> {\r\n                        throw new RuntimeException(\"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\");\r\n                    })\r\n                    .orElseGet(() -> {\r\n                        throw new RuntimeException(\"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\");\r\n                    });\r\n        }\r\n        return ems.peekFirst();\r\n    }"}, {"ID": 623, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Deque<EntityManager> emStack(boolean threadLocalFallback) { return Http.Context.safeCurrent() .map( context -> { Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER); if (emsObject != null) { return (Deque<EntityManager>) emsObject; } else { Deque<EntityManager> ems = new ArrayDeque<>(); context.args.put(CURRENT_ENTITY_MANAGER, ems); return ems; } }) .orElseGet( () -> { // Not a web request if (threadLocalFallback) { return this.get(); } else { throw new RuntimeException( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\"); } }); }\n\n    ### Response:", "ground_truth": "Get the EntityManager stack.\n\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.\n@return the queue of entity managers.", "predict": "/**\r\n     * Returns the thread-local entity manager stack for the current HTTP request.\r\n     *\r\n     * @param threadLocalFallback if true, returns the thread-local entity manager stack if no HTTP request is present.\r\n     * @return the thread-local entity manager stack for the current HTTP request.\r\n     */\r\n    public Deque<EntityManager> emStack(boolean threadLocalFallback);"}, {"ID": 624, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } }\n\n    ### Response:", "ground_truth": "Pushes or pops the EntityManager stack depending on the value of the em argument. If em is\nnull, then the current EntityManager is popped. If em is non-null, then em is pushed onto the\nstack and becomes the current EntityManager.\n\n@param em the entity manager to push, if null then will pop one off the stack.\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.", "predict": "/**\r\n     * Pushes or pops an EntityManager from the thread-local stack of EntityManagers.\r\n     * \r\n     * @param em the EntityManager to push or null to pop\r\n     * @param threadLocalFallback whether to fall back to the thread-local EntityManager if the stack is empty\r\n     */\r\n    void pushOrPopEm(EntityManager em, boolean threadLocalFallback);"}, {"ID": 625, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) { return bypassWith( Flow.<In>create().map(splitter::apply), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), flow); }\n\n    ### Response:", "ground_truth": "Bypass the given flow using the given splitter function.\n\nIf the splitter function returns Left, they will go through the flow. If it returns Right,\nthey will bypass the flow.\n\nUses onlyFirstCanFinishMerge(2) by default.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow\n@param flow the original flow\n@param splitter the splitter function to use\n@return the flow with a bypass.", "predict": "/**\n     * Bypasses the input flow by splitting it into two flows based on the given splitter function.\n     * The first flow will receive the elements that are Left values of the splitter function, and the second flow will receive the elements that are Right values of the splitter function.\n     * The second flow will be created using the AkkaStreams.onlyFirstCanFinishMerge(2) merge strategy, which ensures that only one of the two flows can finish before the merge completes.\n     * The resulting flow will have the same type parameters as the input flow.\n     *\n     * @param splitter the function that splits the input flow into two flows based on the Left and Right values of the Either returned by the function.\n     * @param flow the input flow to bypass.\n     * @param <In> the type of the input elements.\n     * @param <FlowIn> the type of the elements that will be received by the first flow.\n     * @param <Out> the type of the output elements.\n     * @return the"}, {"ID": 626, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) { return splitter.via( Flow.fromGraph( GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true)); UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy); Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.left.isPresent()) { return x.left.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, Out, ?> collectOut = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.right.isPresent()) { return x.right.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel = play.api.libs.streams.AkkaStreams .<F.Either<FlowIn, Out>>ignoreAfterCancellation() .asJava(); // Normal flow builder .from(broadcast.out(0)) .via(builder.add(collectIn)) .via(builder.add(flow)) .toInlet(merge.in(0)); // Bypass flow, need to ignore downstream finish builder .from(broadcast.out(1)) .via(builder.add(blockCancel)) .via(builder.add(collectOut)) .toInlet(merge.in(1)); return new FlowShape<>(broadcast.in(), merge.out()); }))); }\n\n    ### Response:", "ground_truth": "Using the given splitter flow, allow messages to bypass a flow.\n\nIf the splitter flow produces Left, they will be fed into the flow. If it produces Right,\nthey will bypass the flow.\n\n@param  the In type parameter for Flow\n@param  the FlowIn type parameter for the left branch in Either.\n@param  the Out type parameter for Flow.\n@param flow the original flow.\n@param splitter the splitter function.\n@param mergeStrategy the merge strategy (onlyFirstCanFinishMerge, ignoreAfterFinish,\nignoreAfterCancellation)\n@return the flow with a bypass.", "predict": "/**\n * Bypasses the splitter flow and merges the output with the given flow using the given merge strategy.\n *\n * The splitter flow must have a shape of F.Either[FlowIn, Out], where FlowIn is the input type of the flow to be merged, and Out is the output type of the flow to be merged.\n *\n * The bypasser will ignore downstream finish events, and will propagate cancellation events upstream.\n *\n * @param splitter the splitter flow\n * @param mergeStrategy the merge strategy to use\n * @param flow the flow to merge with the splitter\n * @return the merged flow\n */"}, {"ID": 627, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); }\n\n    ### Response:", "ground_truth": "Create a flow that is handled by an actor.\n\nMessages can be sent downstream by sending them to the actor passed into the props function.\nThis actor meets the contract of the actor returned by {@link\nakka.stream.javadsl.Source#actorRef}.\n\nThe props function should return the props for an actor to handle the flow. This actor will\nbe created using the passed in {@link akka.actor.ActorRefFactory}. Each message received will\nbe sent to the actor - there is no back pressure, if the actor is unable to process the\nmessages, they will queue up in the actors mailbox. The upstream can be cancelled by the actor\nterminating itself.\n\n@param  the In type parameter for a Flow\n@param  the Out type parameter for a Flow\n@param props A function that creates the props for actor to handle the flow.\n@param bufferSize The maximum number of elements to buffer.\n@param overflowStrategy The strategy for how to handle a buffer overflow.\n@param factory The Actor Factory used to create the actor to handle the flow - for example, an\nActorSystem.\n@param mat The materializer to materialize the flow.\n@return the flow itself.", "predict": "/**\n     * Creates a Flow that wraps an ActorRef, using the given function to create the Props for the Actor.\n     *\n     * @param props A function that takes an ActorRef and returns the Props for the Actor.\n     * @param bufferSize The size of the buffer to use for the Actor.\n     * @param overflowStrategy The strategy to use when the buffer is full.\n     * @param factory The ActorRefFactory to use to create the ActorRef.\n     * @param mat The Materializer to use to materialize the Flow.\n     * @param <In> The type of input elements.\n     * @param <Out> The type of output elements.\n     * @return A Flow that wraps an ActorRef.\n     */\n    public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new"}, {"ID": 628, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private List<Object> convertErrorArguments(Object[] arguments) { if (arguments == null) { return Collections.emptyList(); } List<Object> converted = Arrays.stream(arguments) .filter( arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable)) .collect(Collectors.toList()); return Collections.unmodifiableList(converted); }\n\n    ### Response:", "ground_truth": "Convert the error arguments.\n\n@param arguments The arguments to convert.\n@return The converted arguments.", "predict": "/**\r\n     * Converts the given arguments to a list of objects that are not of type {@link org.springframework.context.support.DefaultMessageSourceResolvable}.\r\n     *\r\n     * @param arguments the arguments to convert\r\n     * @return a list of objects that are not of type {@link org.springframework.context.support.DefaultMessageSourceResolvable}\r\n     */\r\n    private List<Object> convertErrorArguments(Object[] arguments) {\r\n        if (arguments == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        List<Object> converted = Arrays.stream(arguments)\r\n                .filter(arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable))\r\n                .collect(Collectors.toList());\r\n        return Collections.unmodifiableList(converted);\r\n    }"}, {"ID": 629, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Form<T> fill(T value) { if (value == null) { throw new RuntimeException(\"Cannot fill a form with a null value\"); } return new Form<>( rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess); }\n\n    ### Response:", "ground_truth": "Populates this form with an existing value, used for edit forms.\n\n@param value existing value of type T used to fill this form\n@return a copy of this form filled with the new data", "predict": "/**\n     * Fills the form with the given value.\n     *\n     * @param value the value to fill the form with\n     * @return the filled form\n     * @throws RuntimeException if the value is null\n     */\n    public Form<T> fill(T value) {\n        if (value == null) {\n            throw new RuntimeException(\"Cannot fill a form with a null value\");\n        }\n        return new Form<>(rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess);\n    }"}, {"ID": 630, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<ValidationError> globalErrors() { return Collections.unmodifiableList( errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList())); }\n\n    ### Response:", "ground_truth": "Retrieve all global errors - errors without a key.\n\n@return All global errors.", "predict": "/**\r\n     * Returns a list of global errors.\r\n     * \r\n     * @return a list of global errors\r\n     */\r\n    public List<ValidationError> globalErrors() {\r\n        return Collections.unmodifiableList(errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList()));\r\n    }"}, {"ID": 631, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); }\n\n    ### Response:", "ground_truth": "Returns the form errors serialized as Json using the given Lang.\n\n@param lang the language to use.\n@return the JSON node containing the errors.", "predict": "/**\r\n     * Converts a list of errors to a JSON object.\r\n     *\r\n     * @param lang the language to use for translating error messages\r\n     * @return a JSON object representing the errors\r\n     */\r\n    public JsonNode errorsAsJson(Lang lang) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 632, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Optional<Object> value(String key) { return super.value().map(v -> v.getData().get(asNormalKey(key))); }\n\n    ### Response:", "ground_truth": "Gets the concrete value\n\n@param key the string key.\n@return the value", "predict": "/**\r\n     * Returns the value associated with the given key, if present, as an Optional.\r\n     *\r\n     * @param key the key whose associated value is to be returned\r\n     * @return an Optional containing the value associated with the given key, if present\r\n     */\r\n    public Optional<Object> value(String key) {\r\n        return super.value().map(v -> v.getData().get(asNormalKey(key)));\r\n    }"}, {"ID": 633, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DynamicForm fill(Map<String, Object> value) { Form<Dynamic> form = super.fill(new Dynamic(value)); return new DynamicForm( form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null)); }\n\n    ### Response:", "ground_truth": "Fills the form with existing data.\n\n@param value the map of values to fill in the form.\n@return the modified form.", "predict": "/**\n     * Fills the dynamic form with the given value map.\n     *\n     * @param value the value map to fill the form with\n     * @return the filled dynamic form\n     */\n    public DynamicForm fill(Map<String, Object> value) {\n        Form<Dynamic> form = super.fill(new Dynamic(value));\n        return new DynamicForm(form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null));\n    }"}, {"ID": 634, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); }\n\n    ### Response:", "ground_truth": "Parses this string as instance of the given class.\n\n@param text the text to parse\n@param clazz class representing the required type\n@param  the type to parse out of the text\n@return the parsed value", "predict": "/**\r\n     * Parses the given text into an object of the given class.\r\n     * \r\n     * @param text the text to parse\r\n     * @param clazz the class of the object to create\r\n     * @return the parsed object\r\n     */\r\n    public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); }"}, {"ID": 635, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T parse(Field field, String text) { return (T) conversion.convert(text, new TypeDescriptor(field)); }\n\n    ### Response:", "ground_truth": "Parses this string as instance of a specific field\n\n@param field the related field (custom formatters are extracted from this field annotation)\n@param text the text to parse\n@param  the type to parse out of the text\n@return the parsed value", "predict": "/**\r\n     * Parses the given text into the type of the given field using the registered conversion service.\r\n     * \r\n     * @param field the field to parse the text into\r\n     * @param text the text to parse\r\n     * @return the parsed value\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <T> T parse(Field field, String text) {\r\n        return (T) conversion.convert(text, new TypeDescriptor(field));\r\n    }"}, {"ID": 636, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(T t) { if (t == null) { return \"\"; } if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } }\n\n    ### Response:", "ground_truth": "Computes the display string for any value.\n\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "/**\r\n     * This method takes an object of type T and returns a string representation of the object.\r\n     * \r\n     * @param t The object to be converted to a string.\r\n     * @return A string representation of the object.\r\n     */\r\n    public <T> String print(T t) {\r\n        if (t == null) {\r\n            return \"\";\r\n        }\r\n        if (conversion.canConvert(t.getClass(), String.class)) {\r\n            return conversion.convert(t, String.class);\r\n        } else {\r\n            return t.toString();\r\n        }\r\n    }"}, {"ID": 637, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); }\n\n    ### Response:", "ground_truth": "Computes the display string for any value, for a specific field.\n\n@param field the related field - custom formatters are extracted from this field annotation\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "/**\r\n     * Prints the value of the given object to the console using the specified field's type descriptor.\r\n     * \r\n     * @param field the field to use for type information\r\n     * @param t the object to print\r\n     * @return the string representation of the object\r\n     */\r\n    public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); }"}, {"ID": 638, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> String print(TypeDescriptor desc, T t) { if (t == null) { return \"\"; } if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) { return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class)); } else if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } }\n\n    ### Response:", "ground_truth": "Computes the display string for any value, for a specific type.\n\n@param desc the field descriptor - custom formatters are extracted from this descriptor.\n@param t the value to print\n@param  the type to print\n@return the formatted string", "predict": "/**\r\n     * Prints the given object as a string using the specified conversion service.\r\n     * \r\n     * @param desc the type descriptor of the object to be printed\r\n     * @param t the object to be printed\r\n     * @return the string representation of the object\r\n     */\r\n    public <T> String print(TypeDescriptor desc, T t) {\r\n        if (t == null) {\r\n            return \"\";\r\n        }\r\n        if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) {\r\n            return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class));\r\n        } else if (conversion.canConvert(t.getClass(), String.class)) {\r\n            return conversion.convert(t, String.class);\r\n        } else {\r\n            return t.toString();\r\n        }\r\n    }"}, {"ID": 639, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Formatters registerOptional() { conversion.addConverter( new GenericConverter() { public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map( o -> conversion.convert( source, sourceType.getElementTypeDescriptor(), targetType)) .orElse(\"\"); } return null; } public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<ConvertiblePair> result = new HashSet<>(); result.add(new ConvertiblePair(Optional.class, String.class)); result.add(new ConvertiblePair(String.class, Optional.class)); return result; } }); return this; }\n\n    ### Response:", "ground_truth": "Converter for String -> Optional and Optional -> String", "predict": "/**\r\n     * Registers a custom converter to convert between Optional and String.\r\n     * \r\n     * @return the updated Formatters object\r\n     */\r\n    private Formatters registerOptional() {\r\n        conversion.addConverter(new GenericConverter() {\r\n            public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\r\n                if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map(o -> conversion.convert(source, sourceType.getElementTypeDescriptor(), targetType)).orElse(\"\"); } return null; }\r\n            public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {\r\n                Set<ConvertiblePair> result = new HashSet<>();\r\n                result.add("}, {"ID": 640, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; }\n\n    ### Response:", "ground_truth": "Registers a simple formatter.\n\n@param clazz class handled by this formatter\n@param  the type that this formatter will parse and print\n@param formatter the formatter to register\n@return the modified Formatters object.", "predict": "/**\r\n     * Registers a formatter for a specific class.\r\n     * \r\n     * @param <T> the type of the class to register the formatter for\r\n     * @param clazz the class to register the formatter for\r\n     * @param formatter the formatter to register\r\n     * @return this instance for chaining\r\n     */\r\n    public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) {\r\n        conversion.addFormatterForFieldType(clazz, new org.springframework.format.Formatter<T>() {\r\n            public T parse(String text, Locale locale) throws java.text.ParseException {\r\n                return formatter.parse(text, locale);\r\n            }\r\n\r\n            public String print(T t, Locale locale) {\r\n                return formatter.print(t, locale);\r\n            }\r\n\r\n            public String toString() {\r\n                return formatter.toString();\r\n            }\r\n        });\r\n        return this;\r\n    }"}, {"ID": 641, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) sourceType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.print(a, (T) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return \"@\" + annotationType.getName() + \" \" + clazz.getName() + \" -> \" + String.class.getName() + \": \" + formatter; } }); conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(String.class, clazz)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (targetType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) targetType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.parse(a, (String) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return String.class.getName() + \" -> @\" + annotationType.getName() + \" \" + clazz.getName() + \": \" + formatter; } }); return this; }\n\n    ### Response:", "ground_truth": "Registers an annotation-based formatter.\n\n@param clazz class handled by this formatter\n@param formatter the formatter to register\n@param  the annotation type\n@param  the type that will be parsed or printed\n@return the modified Formatters object.", "predict": "/**\n     * Registers a custom formatter for the given annotation type and class.\n     * \n     * @param <A> the annotation type\n     * @param <T> the class type\n     * @param clazz the class to register the formatter for\n     * @param formatter the formatter to register\n     * @return this object to allow for method chaining\n     */\n    public <A extends Annotation, T> Formatters register(final Class<T> clazz, final AnnotationFormatter<A, T> formatter) {\n        final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments(formatter.getClass(), AnnotationFormatter.class)[0];\n        conversion.addConverter(new ConditionalGenericConverter() {\n            public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() {\n                Set<GenericConverter.ConvertiblePair> types = new HashSet<>();\n                types.add(new GenericConverter.ConvertiblePair(clazz, String.class));\n                return types;\n            }\n\n            public boolean matches(TypeDescriptor sourceType, Type"}, {"ID": 642, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } final String name = cookie.name(); final String value = cookie.value() != null ? cookie.value() : \"\"; validateCookie(name, value); StringBuilder buf = new StringBuilder(); if (cookie.wrap()) { addQuoted(buf, name, value); } else { add(buf, name, value); } if (cookie.maxAge() != Integer.MIN_VALUE) { add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge()); Date expires = cookie.maxAge() <= 0 ? new Date(0) // Set expires to the Unix epoch : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis()); add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires)); } if (cookie.sameSite() != null) { add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite()); } if (cookie.path() != null) { add(buf, CookieHeaderNames.PATH, cookie.path()); } if (cookie.domain() != null) { add(buf, CookieHeaderNames.DOMAIN, cookie.domain()); } if (cookie.isSecure()) { add(buf, CookieHeaderNames.SECURE); } if (cookie.isHttpOnly()) { add(buf, CookieHeaderNames.HTTPONLY); } return stripTrailingSeparator(buf); }\n\n    ### Response:", "ground_truth": "Encodes the specified cookie into a Set-Cookie header value.\n\n@param cookie the cookie\n@return a single Set-Cookie header value", "predict": "/**\n     * Encodes the specified cookie into a string suitable for use in a Cookie header.\n     *\n     * @param cookie the cookie to encode\n     * @return the encoded cookie string\n     * @throws NullPointerException if the cookie is null\n     * @throws IllegalArgumentException if the cookie is invalid\n     */\n    public String encode(Cookie cookie) {\n        // TODO: Implement method\n    }"}, {"ID": 643, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static NodeList selectNodes(String path, Object node) { return selectNodes(path, node, null); }\n\n    ### Response:", "ground_truth": "Select all nodes that are selected by this XPath expression. If multiple nodes match, multiple\nnodes will be returned. Nodes will be returned in document-order,\n\n@param path the xpath expression\n@param node the starting node\n@return result of evaluating the xpath expression against node", "predict": "/**\r\n     * Selects a list of nodes from the given node using the given XPath expression.\r\n     * \r\n     * @param path the XPath expression to use for selecting nodes\r\n     * @param node the node to select nodes from\r\n     * @param contextNode the context node for the XPath expression (optional)\r\n     * @return a NodeList containing the selected nodes\r\n     */\r\n    public static NodeList selectNodes(String path, Object node, Object contextNode) {\r\n        // implementation code here\r\n    }"}, {"ID": 644, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) { return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList(); }\n\n    ### Response:", "ground_truth": "Converts a Java List to Scala Seq.\n\n@param list    the java list.\n@return the converted Seq.\n@param  the element type.", "predict": "/**\r\n     * Converts a Java List to a Scala immutable Seq.\r\n     *\r\n     * @param list the Java List to convert\r\n     * @param <T> the type of elements in the List\r\n     * @return the Scala immutable Seq\r\n     */\r\n    public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) {\r\n        return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList();\r\n    }"}, {"ID": 645, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) { return toSeq(java.util.Arrays.asList(array)); }\n\n    ### Response:", "ground_truth": "Converts a Java Array to Scala Seq.\n\n@param array    the java array.\n@return the converted Seq.\n@param  the element type.", "predict": "/**\n     * Converts an array of type T to a Scala immutable sequence of type T.\n     *\n     * @param array the array to convert\n     * @param <T> the type of the elements in the array and the sequence\n     * @return the Scala immutable sequence of type T\n     */\n    public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) {\n        return toSeq(java.util.Arrays.asList(array));\n    }"}, {"ID": 646, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SafeVarargs public static <T> scala.collection.immutable.Seq<T> varargs(T... array) { return toSeq(array); }\n\n    ### Response:", "ground_truth": "Converts a Java varargs to Scala varargs.\n\n@param array    the java array.\n@return the Scala varargs\n@param  the element type.", "predict": "/**\r\n     * Converts an array of elements to a Scala immutable sequence.\r\n     *\r\n     * @param array the array of elements to convert\r\n     * @param <T> the type of elements in the array\r\n     * @return a Scala immutable sequence containing the elements of the array\r\n     */\r\n    @SafeVarargs\r\n    public static <T> scala.collection.immutable.Seq<T> varargs(T... array) {\r\n        return toSeq(array);\r\n    }"}, {"ID": 647, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); } catch (Exception e) { throw new RuntimeException(e); } }); }\n\n    ### Response:", "ground_truth": "Acceptor for JSON WebSockets.\n\n@param in The class of the incoming messages, used to decode them from the JSON.\n@param  The websocket's input type (what it receives from clients)\n@param  The websocket's output type (what it writes to clients)\n@return The WebSocket acceptor.", "predict": "/**\r\n     * Creates a WebSocket acceptor that maps incoming messages to the specified type using JSON serialization.\r\n     *\r\n     * @param in the type to map incoming messages to\r\n     * @param <In> the type of incoming messages\r\n     * @param <Out> the type of outgoing messages\r\n     * @return a WebSocket acceptor that maps incoming messages to the specified type using JSON serialization\r\n     */\r\n    public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) {\r\n        return new MappedWebSocketAcceptor<>(Scala.partialFunction(message -> {\r\n            try {\r\n                if (message instanceof Message.Binary) {\r\n                    return F.Either.Left(play.libs.Json.mapper().readValue(((Message.Binary) message).data().iterator().asInputStream(), in));\r\n                } else if (message instanceof Message.Text) {\r\n                    return F.Either.Left(play.libs.Json.mapper().readValue(((Message.Text) message).data(), in));\r\n                }\r\n            } catch (Exception"}, {"ID": 648, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get().map(outMapper::apply)); return F.Either.Right(flow); } }); } }; }\n\n    ### Response:", "ground_truth": "Helper to create handlers for WebSockets.\n\n@param inMapper Function to map input messages. If it produces left, the message will be passed\nto the WebSocket flow, if it produces right, the message will be sent back out to the\nclient - this can be used to send errors directly to the client.\n@param f The function to handle the WebSocket.\n@param outMapper Function to map output messages.\n@return The WebSocket handler.", "predict": "/**\r\n     * Accepts a WebSocket connection and returns a WebSocket object that can be used to handle incoming messages.\r\n     *\r\n     * @param inMapper A partial function that maps incoming messages to either an input value or a message to be sent back to the client.\r\n     * @param f A function that takes the request header and returns a completion stage that either contains a result or a flow of input values and output values.\r\n     * @param outMapper A function that maps output values to messages to be sent back to the client.\r\n     * @param <In> The type of input values.\r\n     * @param <Out> The type of output values.\r\n     * @return A WebSocket object that can be used to handle incoming messages.\r\n     */\r\n    private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) {"}, {"ID": 649, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static boolean setAccessibleWorkaround(final AccessibleObject o) { if (o == null || o.isAccessible()) { return false; } final Member m = (Member) o; if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { try { o.setAccessible(true); return true; } catch (final SecurityException e) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false; }\n\n    ### Response:", "ground_truth": "XXX Default access superclass workaround.\n\nWhen a {@code public} class has a default access superclass with {@code public} members,\nthese members are accessible. Calling them from compiled code works fine. Unfortunately, on\nsome JVMs, using reflection to invoke these members seems to (wrongly) prevent access even when\nthe modifier is {@code public}. Calling {@code setAccessible(true)} solves the problem but will\nonly work from sufficiently privileged code. Better workarounds would be gratefully accepted.\n\n@param o the AccessibleObject to set as accessible\n@return a boolean indicating whether the accessibility of the object was set to true.", "predict": "/**\n     * This method is a workaround for the AccessibleObject.setAccessible(boolean flag) method, which is not always working as expected.\n     * \n     * @param o the AccessibleObject to set accessible\n     * @return true if the object was made accessible, false otherwise\n     */\n    public static boolean setAccessibleWorkaround(final AccessibleObject o) {\n        if (o == null || o.isAccessible()) {\n            return false;\n        }\n        final Member m = (Member) o;\n        if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n            try {\n                o.setAccessible(true);\n                return true;\n            } catch (final SecurityException e) {\n                // NOPMD // ignore in favor of subsequent IllegalAccessException\n            }\n        }\n        return false;\n    }"}, {"ID": 650, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getPrimitivePromotionCost( final Class<?> srcClass, final Class<?> destClass) { float cost = 0.0f; Class<?> cls = srcClass; if (!cls.isPrimitive()) { // slight unwrapping penalty cost += 0.1f; cls = ClassUtils.wrapperToPrimitive(cls); } for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { if (cls == ORDERED_PRIMITIVE_TYPES[i]) { cost += 0.1f; if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { cls = ORDERED_PRIMITIVE_TYPES[i + 1]; } } } return cost; }\n\n    ### Response:", "ground_truth": "Gets the number of steps required to promote a primitive number to another type.\n\n@param srcClass the (primitive) source class\n@param destClass the (primitive) destination class\n@return The cost of promoting the primitive", "predict": "/**\r\n     * Calculates the cost of promoting a primitive value to another primitive type.\r\n     * \r\n     * @param srcClass\r\n     *            the source class of the primitive value\r\n     * @param destClass\r\n     *            the destination class of the primitive value\r\n     * @return the cost of promoting the primitive value to the destination class\r\n     */\r\n    private static float getPrimitivePromotionCost(final Class<?> srcClass, final Class<?> destClass) {\r\n        float cost = 0.0f;\r\n        Class<?> cls = srcClass;\r\n        if (!cls.isPrimitive()) {\r\n            // slight unwrapping penalty cost += 0.1f;\r\n            cls = ClassUtils.wrapperToPrimitive(cls);\r\n        }\r\n        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\r\n            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\r\n                cost += 0.1f;\r\n                if (i < ORDERED_PRIMITIVE_TYPES."}, {"ID": 651, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getTotalTransformationCost( final Class<?>[] srcArgs, final Executable executable) { final Class<?>[] destArgs = executable.getParameterTypes(); final boolean isVarArgs = executable.isVarArgs(); // \"source\" and \"destination\" are the actual and declared args respectively. float totalCost = 0.0f; final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length; if (srcArgs.length < normalArgsLen) { return Float.MAX_VALUE; } for (int i = 0; i < normalArgsLen; i++) { totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]); } if (isVarArgs) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs.length < destArgs.length; final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray(); final float varArgsCost = 0.001f; final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType(); if (noVarArgsPassed) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost; } else if (explicitArrayForVarags) { final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType(); totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost; } else { // This is typical varargs case. for (int i = destArgs.length - 1; i < srcArgs.length; i++) { final Class<?> srcClass = srcArgs[i]; totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost; } } } return totalCost; }\n\n    ### Response:", "ground_truth": "Returns the sum of the object transformation cost for each class in the source argument list.\n\n@param srcArgs The source arguments\n@param executable The executable to calculate transformation costs for\n@return The total transformation cost", "predict": "/**\r\n     * Calculates the total transformation cost between the source and destination arguments of an executable.\r\n     * \r\n     * @param srcArgs the actual arguments passed to the executable\r\n     * @param executable the executable to be invoked\r\n     * @return the total transformation cost between the source and destination arguments of the executable\r\n     */\r\n    private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Executable executable) {\r\n        final Class<?>[] destArgs = executable.getParameterTypes();\r\n        final boolean isVarArgs = executable.isVarArgs();\r\n        // \"source\" and \"destination\" are the actual and declared args respectively.\r\n        float totalCost = 0.0f;\r\n        final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length;\r\n        if (srcArgs.length < normalArgsLen) {\r\n            return Float.MAX_VALUE;\r\n        }\r\n        for (int i = 0; i < normalArgsLen; i++) {\r\n            totalCost += getObjectTransformationCost(srcArgs[i], dest"}, {"ID": 652, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { if (destClass.isPrimitive()) { return getPrimitivePromotionCost(srcClass, destClass); } float cost = 0.0f; while (srcClass != null && !destClass.equals(srcClass)) { if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f; break; } cost++; srcClass = srcClass.getSuperclass(); } /* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if (srcClass == null) { cost += 1.5f; } return cost; }\n\n    ### Response:", "ground_truth": "Gets the number of steps required needed to turn the source class into the destination class.\nThis represents the number of steps in the object hierarchy graph.\n\n@param srcClass The source class\n@param destClass The destination class\n@return The cost of transforming an object", "predict": "/**\r\n     * Calculates the cost of transforming an object of the given source class to the given destination class.\r\n     * \r\n     * @param srcClass\r\n     *            the source class of the object to be transformed\r\n     * @param destClass\r\n     *            the destination class to which the object should be transformed\r\n     * @return the cost of transforming the object, as a float\r\n     */\r\n    private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {\r\n        if (destClass.isPrimitive()) {\r\n            return getPrimitivePromotionCost(srcClass, destClass);\r\n        }\r\n        float cost = 0.0f;\r\n        while (srcClass != null && !destClass.equals(srcClass)) {\r\n            if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) {\r\n                // slight penalty for interface match.\r\n                // we still want an exact match to override an interface match,\r\n                // but an interface match should override anything where we have to\r\n                // get a superclass.\r\n               "}, {"ID": 653, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String at(String key, Object... args) { return messagesApi.get(lang, key, args); }\n\n    ### Response:", "ground_truth": "Get the message at the given key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "/**\r\n     * Returns the message for the given key and arguments in the current language.\r\n     *\r\n     * @param key the message key\r\n     * @param args the message arguments\r\n     * @return the message for the given key and arguments in the current language\r\n     */\r\n    public String at(String key, Object... args) {\r\n        return messagesApi.get(lang, key, args);\r\n    }"}, {"ID": 654, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String at(List<String> keys, Object... args) { return messagesApi.get(lang, keys, args); }\n\n    ### Response:", "ground_truth": "Get the message at the first defined key.\n\nUses `java.text.MessageFormat` internally to format the message.\n\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": "/**\r\n     * Returns the message for the given key and arguments in the specified language.\r\n     *\r\n     * @param keys the keys to look up the message\r\n     * @param args the arguments to use for message formatting\r\n     * @return the message for the given key and arguments in the specified language\r\n     */\r\n    public String at(List<String> keys, Object... args) {\r\n        return messagesApi.get(lang, keys, args);\r\n    }"}, {"ID": 655, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Database createFrom( String driver, String url, Map<String, ? extends Object> config) { return createFrom(\"default\", driver, url, config); }\n\n    ### Response:", "ground_truth": "Create a pooled database named \"default\" with the given configuration.\n\n@param driver the database driver class\n@param url the database url\n@param config a map of extra database configuration\n@return a configured database", "predict": "/**\r\n     * Creates a new Database instance using the specified driver, URL, and configuration properties.\r\n     *\r\n     * @param driver the name of the JDBC driver class\r\n     * @param url the URL of the database to connect to\r\n     * @param config a map of configuration properties to set on the Database instance\r\n     * @return a new Database instance\r\n     */\r\n    public static Database createFrom(String driver, String url, Map<String, ? extends Object> config) {\r\n        return createFrom(\"default\", driver, url, config);\r\n    }"}, {"ID": 656, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ParallelSorter create(Object[] arrays) { Generator gen = new Generator(); gen.setArrays(arrays); return gen.create(); }\n\n    ### Response:", "ground_truth": "Create a new ParallelSorter object for a set of arrays. You may\nsort the arrays multiple times via the same ParallelSorter object.\n@param arrays An array of arrays to sort. The arrays may be a mix\nof primitive and non-primitive types, but should all be the same\nlength.\n@param loader ClassLoader for generated class, uses \"current\" if null", "predict": "/**\r\n     * Creates a new ParallelSorter object with the given arrays.\r\n     * \r\n     * @param arrays the arrays to be sorted in parallel\r\n     * @return a new ParallelSorter object\r\n     */\r\n    public static ParallelSorter create(Object[] arrays) {\r\n        Generator gen = new Generator();\r\n        gen.setArrays(arrays);\r\n        return gen.create();\r\n    }"}, {"ID": 657, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void quickSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.quickSort(lo, hi - 1); }\n\n    ### Response:", "ground_truth": "Sort the arrays using the quicksort algorithm.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "/**\r\n     * Sorts the specified range of the array using the specified comparator.\r\n     *\r\n     * @param index the index of the element to be sorted\r\n     * @param lo the index of the first element (inclusive) to be sorted\r\n     * @param hi the index of the last element (exclusive) to be sorted\r\n     * @param cmp the comparator to determine the order of the elements\r\n     */\r\n    public void quickSort(int index, int lo, int hi, Comparator cmp) {\r\n        chooseComparer(index, cmp);\r\n        super.quickSort(lo, hi - 1);\r\n    }"}, {"ID": 658, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void mergeSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.mergeSort(lo, hi - 1); }\n\n    ### Response:", "ground_truth": "Sort the arrays using an in-place merge sort.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": "/**\r\n     * Sorts the specified range of the array using the specified comparator.\r\n     *\r\n     * @param index the index of the array to be sorted\r\n     * @param lo the index of the first element in the range to be sorted\r\n     * @param hi the index of the last element in the range to be sorted\r\n     * @param cmp the comparator to determine the order of the elements\r\n     */\r\n    public void mergeSort(int index, int lo, int hi, Comparator cmp) {\r\n        chooseComparer(index, cmp);\r\n        super.mergeSort(lo, hi - 1);\r\n    }"}, {"ID": 659, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } }\n\n    ### Response:", "ground_truth": "Invoke the original method, on a different object of the same type.\n@param obj the compatible object; recursion will result if you use the object passed as the first\nargument to the MethodInterceptor (usually not what you want)\n@param args the arguments passed to the intercepted method; you may substitute a different\nargument array as long as the types are compatible\n@see MethodInterceptor#intercept\n@throws Throwable the bare exceptions thrown by the called method are passed through\nwithout wrapping in an InvocationTargetException", "predict": "/**\r\n     * Invokes the method represented by this object on the specified object with the specified parameters.\r\n     *\r\n     * @param obj the object the method is invoked from\r\n     * @param args the parameters to the method\r\n     * @return the result of the method invocation\r\n     * @throws Throwable if an exception occurs while invoking the method\r\n     */\r\n    public Object invoke(Object obj, Object[] args) throws Throwable {\r\n        try {\r\n            init();\r\n            FastClassInfo fci = fastClassInfo;\r\n            return fci.f1.invoke(fci.i1, obj, args);\r\n        } catch (InvocationTargetException e) {\r\n            throw e.getTargetException();\r\n        } catch (IllegalArgumentException e) {\r\n            if (fastClassInfo.i1 < 0) {\r\n                throw new IllegalArgumentException(\"Protected method: \" + sig1);\r\n            }\r\n            throw e;\r\n        }\r\n    }"}, {"ID": 660, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.LONG_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.L2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.L2F); } else { mv.visitInsn(Constants.L2I); cast_numeric(Type.INT_TYPE, to); } } else { if (to == Type.BYTE_TYPE) { mv.visitInsn(Constants.I2B); } else if (to == Type.CHAR_TYPE) { mv.visitInsn(Constants.I2C); } else if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.I2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.I2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.I2L); } else if (to == Type.SHORT_TYPE) { mv.visitInsn(Constants.I2S); } } } }\n\n    ### Response:", "ground_truth": "Casts from one primitive numeric type to another", "predict": "/**\n     * Casts a numeric value from one type to another.\n     * \n     * @param from the type of the value to be cast\n     * @param to the type to which the value should be cast\n     */\n    public void cast_numeric(Type from, Type to) {\n        if (from != to) {\n            if (from == Type.DOUBLE_TYPE) {\n                if (to == Type.FLOAT_TYPE) {\n                    mv.visitInsn(Constants.D2F);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visitInsn(Constants.D2L);\n                } else {\n                    mv.visitInsn(Constants.D2I);\n                    cast_numeric(Type.INT_TYPE, to);\n                }\n            } else if (from == Type.FLOAT_TYPE) {\n                if (to == Type.DOUBLE_TYPE) {\n                    mv.visitInsn(Constants.F2D);\n                } else if (to == Type.LONG_TYPE) {\n                    mv.visit"}, {"ID": 661, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); }\n\n    ### Response:", "ground_truth": "Pushes the specified argument of the current method onto the stack.\n@param index the zero-based index into the argument list", "predict": "/**\r\n     * Loads the argument at the given index onto the operand stack.\r\n     * \r\n     * @param index the index of the argument to load\r\n     */\r\n    public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); }"}, {"ID": 662, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); }\n\n    ### Response:", "ground_truth": "package-protected for EmitUtils, try to fix", "predict": "/**\n     * Emits a field instruction with the given opcode, class type, field name, and field type.\n     * \n     * @param opcode the opcode of the instruction to be emitted\n     * @param ctype the class type of the field being accessed\n     * @param name the name of the field being accessed\n     * @param ftype the type of the field being accessed\n     */\n    void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); }"}, {"ID": 663, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } }\n\n    ### Response:", "ground_truth": "Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.", "predict": "/**\n     * This method takes a Type object as input and returns a default value for that type.\n     * If the type is a primitive type, it returns 0 for double, long, float, and void types, and null for all other types.\n     * If the type is not a primitive type, it returns null.\n     * @param type the Type object to get the default value for\n     */\n    public void zero_or_null(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            switch (type.getSort()) {\n                case Type.DOUBLE:\n                    push(0d);\n                    break;\n                case Type.LONG:\n                    push(0L);\n                    break;\n                case Type.FLOAT:\n                    push(0f);\n                    break;\n                case Type.VOID:\n                    aconst_null();\n                    break;\n                default:\n                    push(0);\n                    break;\n            }\n        } else {\n            aconst_null();\n        }\n    }"}, {"ID": 664, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } }\n\n    ### Response:", "ground_truth": "Unboxes the object on the top of the stack. If the object is null, the\nunboxed primitive value becomes zero.", "predict": "/**\r\n     * Unboxes the given type if it is a primitive type, otherwise casts it to the given type.\r\n     * If the type is a primitive type, and the value is null, returns 0 or null depending on the type.\r\n     * \r\n     * @param type the type to unbox or cast to\r\n     */\r\n    public void unbox_or_zero(Type type) {\r\n        // code here\r\n    }"}, {"ID": 665, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) { Type componentType = TypeUtils.getComponentType(type); Local array = e.make_local(); Local loopvar = e.make_local(Type.INT_TYPE); Label loopbody = e.make_label(); Label checkloop = e.make_label(); e.store_local(array); e.push(0); e.store_local(loopvar); e.goTo(checkloop); e.mark(loopbody); e.load_local(array); e.load_local(loopvar); e.array_load(componentType); callback.processElement(componentType); e.iinc(loopvar, 1); e.mark(checkloop); e.load_local(loopvar); e.load_local(array); e.arraylength(); e.if_icmp(e.LT, loopbody); }\n\n    ### Response:", "ground_truth": "Process an array on the stack. Assumes the top item on the stack\nis an array of the specified type. For each element in the array,\nputs the element on the stack and triggers the callback.\n@param type the type of the array (type.isArray() must be true)\n@param callback the callback triggered for each element", "predict": "/**\r\n     * Processes an array of elements using the given callback.\r\n     * \r\n     * @param e the code emitter to use for generating code\r\n     * @param type the type of the array to process\r\n     * @param callback the callback to use for processing each element of the array\r\n     */\r\n    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 666, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) { e.dup2(); Label nonNull = e.make_label(); Label oneNullHelper = e.make_label(); Label end = e.make_label(); e.ifnonnull(nonNull); e.ifnonnull(oneNullHelper); e.pop2(); e.goTo(bothNull); e.mark(nonNull); e.ifnull(oneNullHelper); e.goTo(end); e.mark(oneNullHelper); e.pop2(); e.goTo(oneNull); e.mark(end); }\n\n    ### Response:", "ground_truth": "If both objects on the top of the stack are non-null, does nothing.\nIf one is null, or both are null, both are popped off and execution\nbranches to the respective label.\n@param oneNull label to branch to if only one of the objects is null\n@param bothNull label to branch to if both of the objects are null", "predict": "/**\n     * Compares two objects for nullity and sets the appropriate label depending on the result.\n     * \n     * @param e - the CodeEmitter object used to generate the code\n     * @param oneNull - the label to jump to if only one of the objects is null\n     * @param bothNull - the label to jump to if both objects are null\n     */\n    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n        e.dup2();\n        Label nonNull = e.make_label();\n        Label oneNullHelper = e.make_label();\n        Label end = e.make_label();\n        e.ifnonnull(nonNull);\n        e.ifnonnull(oneNullHelper);\n        e.pop2();\n        e.goTo(bothNull);\n        e.mark(nonNull);\n        e.ifnull(oneNullHelper);\n        e.goTo(end);\n        e.mark(oneNullHelper);\n        e.pop2();\n        e.goTo(oneNull);"}, {"ID": 667, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; }\n\n    ### Response:", "ground_truth": "Finds all bridge methods that are being called with invokespecial &\nreturns them.", "predict": "/**\n     * Resolves all the bridges in the class loader and returns a map of the resolved bridges.\n     *\n     * @return a map of the resolved bridges\n     */\n    public Map<Signature, Signature> resolveAll() {\n        Map<Signature, Signature> resolved = new HashMap<>();\n        for (Iterator<Map.Entry<Class, Set<Signature>>> entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) {\n            Map.Entry<Class, Set<Signature>> entry = entryIter.next();\n            Class owner = entry.getKey();\n            Set<Signature> bridges = entry.getValue();\n            try {\n                InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\");\n                if (is == null) {\n                    return resolved;\n                }\n                try {\n                    new ClassReader(is)\n                            .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);\n               "}, {"ID": 668, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void getMethods(Class superclass, Class[] interfaces, List methods) { getMethods(superclass, interfaces, methods, null, null); }\n\n    ### Response:", "ground_truth": "Finds all of the methods that will be extended by an\nEnhancer-generated class using the specified superclass and\ninterfaces. This can be useful in building a list of Callback\nobjects. The methods are added to the end of the given list.  Due\nto the subclassing nature of the classes generated by Enhancer,\nthe methods are guaranteed to be non-static, non-final, and\nnon-private. Each method signature will only occur once, even if\nit occurs in multiple classes.\n@param superclass the class that will be extended, or null\n@param interfaces the list of interfaces that will be implemented, or null\n@param methods the list into which to copy the applicable methods", "predict": "/**\r\n     * This method is used to get all the methods of a class and its superclasses and interfaces.\r\n     * \r\n     * @param superclass - The class whose methods are to be retrieved.\r\n     * @param interfaces - The interfaces whose methods are to be retrieved.\r\n     * @param methods - A list to which the methods will be added.\r\n     * @param visited - A set to keep track of visited classes to avoid infinite recursion.\r\n     * @param prefix - A string to be prepended to the method name.\r\n     */\r\n    public static void getMethods(Class superclass, Class[] interfaces, List methods, Set visited, String prefix) {\r\n        if (visited == null) {\r\n            visited = new HashSet();\r\n        }\r\n        if (prefix == null) {\r\n            prefix = \"\";\r\n        }\r\n        if (superclass != null && !visited.contains(superclass)) {\r\n            visited.add(superclass);\r\n            Method[] superMethods = superclass.getDeclaredMethods();\r\n            for (Method method : superMethods) {\r\n                methods.add(prefix + method"}, {"ID": 669, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void filterConstructors(Class sc, List constructors) { CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true)); if (constructors.size() == 0) throw new IllegalArgumentException(\"No visible constructors in \" + sc); }\n\n    ### Response:", "ground_truth": "Filter the list of constructors from the superclass. The\nconstructors which remain will be included in the generated\nclass. The default implementation is to filter out all private\nconstructors, but subclasses may extend Enhancer to override this\nbehavior.\n@param sc the superclass\n@param constructors the list of all declared constructors from the superclass\n@throws IllegalArgumentException if there are no non-private constructors", "predict": "/**\r\n     * Filters the given list of constructors to only include those that are visible from the given class.\r\n     *\r\n     * @param sc the class from which visibility is being checked\r\n     * @param constructors the list of constructors to filter\r\n     * @throws IllegalArgumentException if no visible constructors are found\r\n     */\r\n    protected void filterConstructors(Class sc, List constructors) {\r\n        CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));\r\n        if (constructors.size() == 0) {\r\n            throw new IllegalArgumentException(\"No visible constructors in \" + sc);\r\n        }\r\n    }"}, {"ID": 670, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setSuperclass(Class superclass) { if (superclass != null && superclass.equals(Object.class)) { superclass = null; } this.superclass = superclass; }\n\n    ### Response:", "ground_truth": "Set the class which the generated class will extend. The class\nmust not be declared as final, and must have a non-private\nno-argument constructor.\n@param superclass class to extend, or null to extend Object", "predict": "/**\r\n     * Sets the superclass of the class.\r\n     * \r\n     * @param superclass the new superclass of the class.\r\n     */\r\n    public void setSuperclass(Class superclass) {\r\n        if (superclass != null && superclass.equals(Object.class)) {\r\n            superclass = null;\r\n        }\r\n        this.superclass = superclass;\r\n    }"}, {"ID": 671, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void getField(String[] names) throws Exception { final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null); e.load_this(); e.load_arg(0); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label end) { Type type = (Type)fields.get(key); e.getfield((String)key); e.box(type); e.return_value(); } public void processDefault() { e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\"); } }); e.end_method(); }\n\n    ### Response:", "ground_truth": "to avoid JVM hashcode implementation incompatibilities", "predict": "/**\n     * Gets the value of a field with the given name.\n     *\n     * @param names the names of the fields to get\n     * @throws Exception if the field name is unknown\n     */\n    private void getField(String[] names) throws Exception {\n        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);\n        e.load_this();\n        e.load_arg(0);\n        EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n            public void processCase(Object key, Label end) {\n                Type type = (Type)fields.get(key);\n                e.getfield((String)key);\n                e.box(type);\n                e.return_value();\n            }\n            public void processDefault() {\n                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\n            }\n        });\n        e.end_method();\n    }"}, {"ID": 672, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Method method) { add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method)); }\n\n    ### Response:", "ground_truth": "Add a method signature to the interface. The method modifiers are ignored,\nsince interface methods are by definition abstract and public.\n@param method the method to add to the interface", "predict": "/**\r\n     * Adds a method to the list of methods to be invoked.\r\n     * \r\n     * @param method the method to be added\r\n     */\r\n    public void add(Method method) {\r\n        add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method));\r\n    }"}, {"ID": 673, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; }\n\n    ### Response:", "ground_truth": "If bit 31 is set then this method results in an infinite loop.\n\n@return the number of bits set to true in this TinyBitSet.", "predict": "/**\r\n     * Returns the number of bits set in the binary representation of the integer value.\r\n     *\r\n     * @return the number of bits set in the binary representation of the integer value.\r\n     */\r\n    public int cardinality() {\r\n        int w = value;\r\n        int c = 0;\r\n        while (w != 0) {\r\n            c += T[w & 255];\r\n            w >>= 8;\r\n        }\r\n        return c;\r\n    }"}, {"ID": 674, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setNamingPolicy(NamingPolicy namingPolicy) { if (namingPolicy == null) namingPolicy = DefaultNamingPolicy.INSTANCE; this.namingPolicy = namingPolicy; }\n\n    ### Response:", "ground_truth": "Override the default naming policy.\n@see DefaultNamingPolicy\n@param namingPolicy the custom policy, or null to use the default", "predict": "/**\r\n     * Sets the naming policy for this object.\r\n     * \r\n     * @param namingPolicy the naming policy to set, or null to use the default naming policy\r\n     */\r\n    public void setNamingPolicy(NamingPolicy namingPolicy) {\r\n        if (namingPolicy == null) {\r\n            namingPolicy = DefaultNamingPolicy.INSTANCE;\r\n        }\r\n        this.namingPolicy = namingPolicy;\r\n    }"}, {"ID": 675, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) { Map map = new HashMap(); for (int i = 0; i < methods.length; i++) { Method method = methods[i]; map.put(method.getName() + Type.getMethodDescriptor(method), method); } Method[] result = new Method[namesAndDescriptors.length / 2]; for (int i = 0; i < result.length; i++) { result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]); if (result[i] == null) { // TODO: error? } } return result; }\n\n    ### Response:", "ground_truth": "used by MethodInterceptorGenerated generated code", "predict": "/**\r\n     * Finds the methods with the given names and descriptors in the given array of methods.\r\n     *\r\n     * @param namesAndDescriptors an array of strings containing the names and descriptors of the methods to find, in the format \"name1 descriptor1 name2 descriptor2 ...\"\r\n     * @param methods an array of methods to search in\r\n     * @return an array of methods with the given names and descriptors, in the same order as the input array\r\n     */\r\n    public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) {\r\n        Map<String, Method> map = new HashMap<>();\r\n        for (Method method : methods) {\r\n            map.put(method.getName() + Type.getMethodDescriptor(method), method);\r\n        }\r\n        Method[] result = new Method[namesAndDescriptors.length / 2];\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * "}, {"ID": 676, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Path resolve(final Path base, String child) { if (StringUtil.startsWithChar(child, File.separatorChar)) { child = child.substring(1); } return base.resolve(child); }\n\n    ### Response:", "ground_truth": "Resolves subpath in safer way. For some reason, if child starts with\na separator it gets resolved as a full path, ignoring the base.\nThis method acts different.", "predict": "/**\r\n     * Resolves a child path against a base path.\r\n     * \r\n     * @param base the base path\r\n     * @param child the child path to resolve\r\n     * @return the resolved path\r\n     */\r\n    public static Path resolve(final Path base, String child) {\r\n        if (StringUtil.startsWithChar(child, File.separatorChar)) {\r\n            child = child.substring(1);\r\n        }\r\n        return base.resolve(child);\r\n    }"}, {"ID": 677, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer); return writer.toString(); } }\n\n    ### Response:", "ground_truth": "Reads path content.", "predict": "/**\r\n     * Reads the contents of a file into a string.\r\n     * \r\n     * @param path the path to the file to read\r\n     * @return the contents of the file as a string\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static String readString(final Path path) throws IOException {\r\n        try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\r\n            StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer);\r\n            return writer.toString();\r\n        }\r\n    }"}, {"ID": 678, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; }\n\n    ### Response:", "ground_truth": "Sets request host name.", "predict": "/**\n     * Sets the host for the request. If a host header already exists, it will be overwritten.\n     *\n     * @param host the host to set\n     * @return the updated request object\n     */\n    public HttpRequest host(final String host) {\n        this.host = host;\n        if (headers.contains(HEADER_HOST)) {\n            headerOverwrite(HEADER_HOST, host);\n        }\n        return this;\n    }"}, {"ID": 679, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest create(final String method, final String destination) { return new HttpRequest() .method(method.toUpperCase()) .set(destination); }\n\n    ### Response:", "ground_truth": "Generic request builder, usually used when method is a variable.\nOtherwise, use one of the other static request builder methods.", "predict": "/**\r\n     * Creates a new HttpRequest with the given method and destination.\r\n     * \r\n     * @param method the HTTP method (e.g. GET, POST, PUT, DELETE)\r\n     * @param destination the URL to send the request to\r\n     * @return a new HttpRequest object\r\n     */\r\n    public static HttpRequest create(final String method, final String destination) {\r\n        return new HttpRequest().method(method.toUpperCase()).set(destination);\r\n    }"}, {"ID": 680, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest connect(final String destination) { return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a CONNECT request.", "predict": "/**\r\n     * Creates a new HTTP CONNECT request with the specified destination.\r\n     *\r\n     * @param destination the destination to connect to\r\n     * @return a new HTTP CONNECT request\r\n     */\r\n    public static HttpRequest connect(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.CONNECT).set(destination);\r\n    }"}, {"ID": 681, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest get(final String destination) { return new HttpRequest() .method(HttpMethod.GET) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a GET request.", "predict": "/**\r\n     * Creates a new HttpRequest object with the GET method and sets the destination URL.\r\n     *\r\n     * @param destination The URL to which the request should be sent.\r\n     * @return A new HttpRequest object with the GET method and destination URL set.\r\n     */\r\n    public static HttpRequest get(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.GET).set(destination);\r\n    }"}, {"ID": 682, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest post(final String destination) { return new HttpRequest() .method(HttpMethod.POST) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a POST request.", "predict": "/**\r\n     * Creates a new HTTP POST request with the specified destination.\r\n     *\r\n     * @param destination the destination URL for the request\r\n     * @return a new HttpRequest object with the POST method set and the destination URL set\r\n     */\r\n    public static HttpRequest post(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.POST).set(destination);\r\n    }"}, {"ID": 683, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest put(final String destination) { return new HttpRequest() .method(HttpMethod.PUT) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a PUT request.", "predict": "/**\r\n     * Creates a new HTTP PUT request with the specified destination.\r\n     *\r\n     * @param destination the destination URL for the request\r\n     * @return the new HTTP PUT request\r\n     */\r\n    public static HttpRequest put(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.PUT).set(destination);\r\n    }"}, {"ID": 684, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest patch(final String destination) { return new HttpRequest() .method(HttpMethod.PATCH) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a PATCH request.", "predict": "/**\r\n     * Creates a new HttpRequest object with the PATCH method and sets the destination URL.\r\n     *\r\n     * @param destination The destination URL for the request.\r\n     * @return A new HttpRequest object with the PATCH method and destination URL set.\r\n     */\r\n    public static HttpRequest patch(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.PATCH).set(destination);\r\n    }"}, {"ID": 685, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest delete(final String destination) { return new HttpRequest() .method(HttpMethod.DELETE) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a DELETE request.", "predict": "/**\r\n     * Deletes the resource at the specified destination.\r\n     * \r\n     * @param destination the destination of the resource to delete\r\n     * @return the HTTP request object with the DELETE method set and the destination set as the request URI\r\n     */\r\n    public static HttpRequest delete(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.DELETE).set(destination);\r\n    }"}, {"ID": 686, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest head(final String destination) { return new HttpRequest() .method(HttpMethod.HEAD) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a HEAD request.", "predict": "/**\r\n     * Sends a HEAD request to the specified destination.\r\n     *\r\n     * @param destination the destination URL\r\n     * @return the HTTP request object\r\n     */\r\n    public static HttpRequest head(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.HEAD).set(destination);\r\n    }"}, {"ID": 687, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest trace(final String destination) { return new HttpRequest() .method(HttpMethod.TRACE) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds a TRACE request.", "predict": "/**\r\n     * Sends a TRACE request to the specified destination.\r\n     *\r\n     * @param destination The destination to send the request to.\r\n     * @return The HttpRequest object.\r\n     */\r\n    public static HttpRequest trace(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.TRACE).set(destination);\r\n    }"}, {"ID": 688, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpRequest options(final String destination) { return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination); }\n\n    ### Response:", "ground_truth": "Builds an OPTIONS request.", "predict": "/**\r\n     * Sends an HTTP OPTIONS request to the specified destination.\r\n     * \r\n     * @param destination the destination URL for the request\r\n     * @return the HTTP request object\r\n     */\r\n    public static HttpRequest options(final String destination) {\r\n        return new HttpRequest().method(HttpMethod.OPTIONS).set(destination);\r\n    }"}, {"ID": 689, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest path(String path) { // this must be the only place that sets the path if (!path.startsWith(StringPool.SLASH)) { path = StringPool.SLASH + path; } int ndx = path.indexOf('?'); if (ndx != -1) { String queryString = path.substring(ndx + 1); path = path.substring(0, ndx); query = HttpUtil.parseQuery(queryString, true); } else { query = HttpMultiMap.newCaseInsensitiveMap(); } this.path = path; return this; }\n\n    ### Response:", "ground_truth": "Sets request path. Query string is allowed.\nAdds a slash if path doesn't start with one.\nQuery will be stripped out from the path.\nPrevious query is discarded.\n@see #query()", "predict": "/**\n     * Sets the path for the request. If the path does not start with a slash, it will be added.\n     *\n     * @param path the path to set\n     * @return the request object\n     */\n    public HttpRequest path(String path) {\n        if (!path.startsWith(StringPool.SLASH)) {\n            path = StringPool.SLASH + path;\n        }\n        int ndx = path.indexOf('?');\n        if (ndx != -1) {\n            String queryString = path.substring(ndx + 1);\n            path = path.substring(0, ndx);\n            query = HttpUtil.parseQuery(queryString, true);\n        } else {\n            query = HttpMultiMap.newCaseInsensitiveMap();\n        }\n        this.path = path;\n        return this;\n    }"}, {"ID": 690, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; }\n\n    ### Response:", "ground_truth": "Sets cookies to the request.", "predict": "/**\r\n     * Adds the specified cookies to the request.\r\n     *\r\n     * @param cookies the cookies to add\r\n     * @return the updated request\r\n     */\r\n    public HttpRequest cookies(final Cookie... cookies) {\r\n        if (cookies.length == 0) {\r\n            return this;\r\n        }\r\n        StringBuilder cookieString = new StringBuilder();\r\n        boolean first = true;\r\n        for (Cookie cookie : cookies) {\r\n            Integer maxAge = cookie.getMaxAge();\r\n            if (maxAge != null && maxAge.intValue() == 0) {\r\n                continue;\r\n            }\r\n            if (!first) {\r\n                cookieString.append(\"; \");\r\n            }\r\n            first = false;\r\n            cookieString.append(cookie.getName());\r\n            cookieString.append('=');\r\n            cookieString.append(cookie.getValue());\r\n        }\r\n        headerOverwrite(\"cookie\", cookieString.toString());\r\n        return this;\r\n    }"}, {"ID": 691, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; }\n\n    ### Response:", "ground_truth": "Adds many query parameters at once. Although it accepts objects,\neach value will be converted to string.", "predict": "/**\r\n     * Adds a query parameter to the request.\r\n     * \r\n     * @param name the name of the parameter\r\n     * @param value the value of the parameter\r\n     * @return the updated request object\r\n     */\r\n    public HttpRequest query(final String name, final Object value) {\r\n        query.add(name, value == null ? null : value.toString());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds multiple query parameters to the request.\r\n     * \r\n     * @param parameters the query parameters to add\r\n     * @return the updated request object\r\n     */\r\n    public HttpRequest query(final Object... parameters) {\r\n        for (int i = 0; i < parameters.length; i += 2) {\r\n            String name = parameters[i].toString();\r\n            String value = parameters[i + 1].toString();\r\n            query.add(name, value);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 692, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest query(final Map<String, String> queryMap) { for (Map.Entry<String, String> entry : queryMap.entrySet()) { query.add(entry.getKey(), entry.getValue()); } return this; }\n\n    ### Response:", "ground_truth": "Adds all parameters from the provided map.", "predict": "/**\r\n     * Adds the query parameters to the request.\r\n     * \r\n     * @param queryMap the query parameters to add to the request\r\n     * @return the updated request object\r\n     */\r\n    public HttpRequest query(final Map<String, String> queryMap) {\r\n        for (Map.Entry<String, String> entry : queryMap.entrySet()) {\r\n            query.add(entry.getKey(), entry.getValue());\r\n        }\r\n        return this;\r\n    }"}, {"ID": 693, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; }\n\n    ### Response:", "ground_truth": "Sets query from provided query string. Previous query values\nare discarded.", "predict": "/**\r\n     * Sets the query string for the request.\r\n     *\r\n     * @param queryString the query string to set\r\n     * @param decode whether to decode the query string or not\r\n     * @return the updated HttpRequest object\r\n     */\r\n    public HttpRequest queryString(final String queryString, final boolean decode) {\r\n        this.query = HttpUtil.parseQuery(queryString, decode);\r\n        return this;\r\n    }"}, {"ID": 694, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String queryString() { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); }\n\n    ### Response:", "ground_truth": "Generates query string. All values are URL encoded.", "predict": "/**\r\n     * Returns the query string for the current request.\r\n     *\r\n     * @return the query string for the current request, or an empty string if there is no query string\r\n     */\r\n    public String queryString() {\r\n        if (query == null) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        return HttpUtil.buildQuery(query, queryEncoding);\r\n    }"}, {"ID": 695, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); }\n\n    ### Response:", "ground_truth": "Returns just host url, without path and query.", "predict": "/**\r\n     * Returns the host URL for the current request.\r\n     * \r\n     * @return the host URL for the current request\r\n     */\r\n    public String hostUrl() {\r\n        StringBand url = new StringBand(8);\r\n        if (protocol != null) {\r\n            url.append(protocol);\r\n            url.append(\"://\");\r\n        }\r\n        if (host != null) {\r\n            url.append(host);\r\n        }\r\n        if (port != Defaults.DEFAULT_PORT) {\r\n            url.append(':');\r\n            url.append(port);\r\n        }\r\n        return url.toString();\r\n    }"}, {"ID": 696, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest basicAuthentication(final String username, final String password) { if (username != null && password != null) { String data = username.concat(StringPool.COLON).concat(password); String base64 = Base64.encodeToString(data); headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64); } return this; }\n\n    ### Response:", "ground_truth": "Enables basic authentication by adding required header.", "predict": "/**\r\n     * Adds Basic Authentication header to the request.\r\n     *\r\n     * @param username the username for authentication\r\n     * @param password the password for authentication\r\n     * @return the updated request object\r\n     */\r\n    public HttpRequest basicAuthentication(final String username, final String password) {\r\n        if (username != null && password != null) {\r\n            String data = username.concat(StringPool.COLON).concat(password);\r\n            String base64 = Base64.encodeToString(data);\r\n            headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 697, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpRequest setHostHeader() { String hostPort = this.host; if (port != Defaults.DEFAULT_PORT) { hostPort += StringPool.COLON + port; } headerOverwrite(HEADER_HOST, hostPort); return this; }\n\n    ### Response:", "ground_truth": "Sets 'Host' header from current host and port.", "predict": "/**\r\n     * Sets the Host header for the request.\r\n     *\r\n     * @return the updated HttpRequest object.\r\n     */\r\n    public HttpRequest setHostHeader() {\r\n        String hostPort = this.host;\r\n        if (port != Defaults.DEFAULT_PORT) {\r\n            hostPort += StringPool.COLON + port;\r\n        }\r\n        headerOverwrite(HEADER_HOST, hostPort);\r\n        return this;\r\n    }"}, {"ID": 698, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected Buffer buffer(final boolean fullRequest) { // INITIALIZATION // host port if (header(HEADER_HOST) == null) { setHostHeader(); } // form Buffer formBuffer = formBuffer(); // query string String queryString = queryString(); // user-agent if (header(\"User-Agent\") == null) { header(\"User-Agent\", Defaults.userAgent); } // POST method requires Content-Type to be set if (method.equals(\"POST\") && (contentLength() == null)) { contentLength(0); } // BUILD OUT Buffer request = new Buffer(); request.append(method) .append(SPACE) .append(path); if (query != null && !query.isEmpty()) { request.append('?'); request.append(queryString); } request.append(SPACE) .append(httpVersion) .append(CRLF); populateHeaderAndBody(request, formBuffer, fullRequest); return request; }\n\n    ### Response:", "ground_truth": "Prepares the request buffer.", "predict": "/**\r\n     * Initializes the request buffer with the given method, path, and HTTP version.\r\n     * \r\n     * @param method the HTTP method (e.g. GET, POST, etc.)\r\n     * @param path the HTTP path (e.g. /path/to/resource)\r\n     * @param httpVersion the HTTP version (e.g. HTTP/1.1)\r\n     * @param query the query string (e.g. ?key=value)\r\n     * @param form the form data (e.g. key=value)\r\n     * @param fullRequest whether or not to include the full request (headers and body)\r\n     * @return the initialized request buffer\r\n     */\r\n    protected Buffer buffer(final String method, final String path, final String httpVersion, final String query, final String form, final boolean fullRequest) {\r\n        // host port\r\n        if (header(HEADER_HOST) == null) {\r\n            setHostHeader();\r\n        }\r\n\r\n        // form Buffer\r\n        Buffer formBuffer = formBuffer(form);\r\n\r\n        // query"}, {"ID": 699, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); }\n\n    ### Response:", "ground_truth": "Syntax sugar.", "predict": "/**\r\n     * Sends a request and receives a response using the provided response handler.\r\n     * \r\n     * @param responseHandler a function that takes an HTTP response and returns a value of type R\r\n     * @return the value returned by the response handler\r\n     */\r\n    public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) {\r\n        return responseHandler.apply(send());\r\n    }"}, {"ID": 700, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static Handler removeRange(final Handler firstHandler, final Label start, final Label end) { if (firstHandler == null) { return null; } else { firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end); } int handlerStart = firstHandler.startPc.bytecodeOffset; int handlerEnd = firstHandler.endPc.bytecodeOffset; int rangeStart = start.bytecodeOffset; int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) { return firstHandler; } if (rangeStart <= handlerStart) { if (rangeEnd >= handlerEnd) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler.nextHandler; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler(firstHandler, end, firstHandler.endPc); } } else if (rangeEnd >= handlerEnd) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler(firstHandler, firstHandler.startPc, start); } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = // [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc); return new Handler(firstHandler, firstHandler.startPc, start); } }\n\n    ### Response:", "ground_truth": "Removes the range between start and end from the Handler list that begins with the given\nelement.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@param start the start of the range to be removed.\n@param end the end of the range to be removed. Maybe {@literal null}.\n@return the exception handler list with the start-end range removed.", "predict": "/**\n     * Removes the range of bytecode from the given handler, starting from the given start label and ending at the given end label.\n     * \n     * @param firstHandler the first handler in the chain to remove the range from\n     * @param start the start label of the range to remove\n     * @param end the end label of the range to remove, or null to remove the range up to the end of the handler\n     * @return the new first handler in the chain, or null if the entire chain was removed\n     */\n    static Handler removeRange(final Handler firstHandler, final Label start, final Label end) {\n        if (firstHandler == null) {\n            return null;\n        } else {\n            firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end);\n        }\n        int handlerStart = firstHandler.startPc.bytecodeOffset;\n        int handlerEnd = firstHandler.endPc.bytecodeOffset;\n        int rangeStart = start.bytecodeOffset;\n        int rangeEnd = end == null"}, {"ID": 701, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; }\n\n    ### Response:", "ground_truth": "Returns the number of elements of the Handler list that begins with the given element.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@return the number of elements of the Handler list that begins with 'handler'.", "predict": "/**\r\n     * This method returns the number of exception handlers in the linked list of exception handlers.\r\n     * \r\n     * @param firstHandler the first handler in the linked list of exception handlers\r\n     * @return the number of exception handlers in the linked list of exception handlers\r\n     */\r\n    static int getExceptionTableLength(final Handler firstHandler) {\r\n        int length = 0;\r\n        Handler handler = firstHandler;\r\n        while (handler != null) {\r\n            length++;\r\n            handler = handler.nextHandler;\r\n        }\r\n        return length;\r\n    }"}, {"ID": 702, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionInterceptors() { final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors(); interceptors = new ArrayList<>(); interceptors.addAll(interceptorValues); interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all interceptors.", "predict": "/**\r\n     * Collects all the action interceptors from the interceptors manager and stores them in a list.\r\n     * The interceptors are sorted based on their class name.\r\n     */\r\n    protected void collectActionInterceptors() {\r\n        final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors();\r\n        interceptors = new ArrayList<>();\r\n        interceptors.addAll(interceptorValues);\r\n        interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));\r\n    }"}, {"ID": 703, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionFilters() { final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters(); filters = new ArrayList<>(); filters.addAll(filterValues); filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all filters.", "predict": "/**\r\n     * Collects all the action filters from the filters manager and stores them in a list.\r\n     * The list is sorted based on the class name of the action filters.\r\n     */\r\n    protected void collectActionFilters() {\r\n        final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters();\r\n        filters = new ArrayList<>();\r\n        filters.addAll(filterValues);\r\n        filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));\r\n    }"}, {"ID": 704, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); }\n\n    ### Response:", "ground_truth": "Collects all action results.", "predict": "/**\r\n     * Collects all the action results from the results manager and stores them in a list.\r\n     * The list is sorted in ascending order based on the class name of the action result.\r\n     */\r\n    protected void collectActionResults() {\r\n        final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults();\r\n        results = new ArrayList<>();\r\n        results.addAll(resultsValues);\r\n        results.sort(Comparator.comparing(a -> a.getClass().getSimpleName()));\r\n    }"}, {"ID": 705, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); }\n\n    ### Response:", "ground_truth": "Collects all action runtime configurations.", "predict": "/**\r\n     * Collects all the action runtimes from the actions manager and sorts them based on their action path.\r\n     */\r\n    protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); }"}, {"ID": 706, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected void setSimpleProperty(final BeanProperty bp, final Object value) { Setter setter = bp.getSetter(isDeclared); // try: setter if (setter != null) { invokeSetter(setter, bp, value); return; } // try: put(\"property\", value) if (bp.isMap()) { ((Map) bp.bean).put(bp.name, value); return; } if (isSilent) { return; } throw new BeanException(\"Simple property not found: \" + bp.name, bp); }\n\n    ### Response:", "ground_truth": "Sets a value of simple property.", "predict": "/**\r\n     * Sets a simple property on the bean.\r\n     * \r\n     * @param bp\r\n     *            the property to set\r\n     * @param value\r\n     *            the value to set it to\r\n     */\r\n    protected void setSimpleProperty(final BeanProperty bp, final Object value) {\r\n        Setter setter = bp.getSetter(isDeclared); // try: setter\r\n        if (setter != null) {\r\n            invokeSetter(setter, bp, value);\r\n            return;\r\n        }\r\n        // try: put(\"property\", value)\r\n        if (bp.isMap()) {\r\n            ((Map) bp.bean).put(bp.name, value);\r\n            return;\r\n        }\r\n        if (isSilent) {\r\n            return;\r\n        }\r\n        throw new BeanException(\"Simple property not found: \" + bp.name, bp);\r\n    }"}, {"ID": 707, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public <T> T getProperty(final Object bean, final String name) { BeanProperty beanProperty = new BeanProperty(this, bean, name); if (!isSilent) { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } else { try { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } catch (Exception ignore) { return null; } } }\n\n    ### Response:", "ground_truth": "Returns value of bean's property.", "predict": "/**\r\n     * Gets the value of a property of a JavaBean object.\r\n     *\r\n     * @param bean the JavaBean object\r\n     * @param name the name of the property to get\r\n     * @return the value of the property\r\n     */\r\n    @Override\r\n    public <T> T getProperty(final Object bean, final String name) {\r\n        BeanProperty beanProperty = new BeanProperty(this, bean, name);\r\n        if (!isSilent) {\r\n            resolveNestedProperties(beanProperty);\r\n            return (T) getIndexProperty(beanProperty);\r\n        } else {\r\n            try {\r\n                resolveNestedProperties(beanProperty);\r\n                return (T) getIndexProperty(beanProperty);\r\n            } catch (Exception ignore) {\r\n                return null;\r\n            }\r\n        }\r\n    }"}, {"ID": 708, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); }\n\n    ### Response:", "ground_truth": "Extract the first name of this reference.", "predict": "/**\r\n     * Extracts the \"this\" reference from the given property name.\r\n     * \r\n     * @param propertyName the property name to extract the \"this\" reference from\r\n     * @return the extracted \"this\" reference, or the original property name if no \"this\" reference was found\r\n     */\r\n    @Override\r\n    public String extractThisReference(final String propertyName) {\r\n        int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS);\r\n        if (ndx == -1) {\r\n            return propertyName;\r\n        }\r\n        return propertyName.substring(0, ndx);\r\n    }"}, {"ID": 709, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; }\n\n    ### Response:", "ground_truth": "Returns buffered writer. Buffer will be created if not already used.", "predict": "/**\r\n     * Returns a PrintWriter object that can be used to print output to the client.\r\n     *\r\n     * @return a PrintWriter object that can be used to print output to the client.\r\n     */\r\n    @Override\r\n    public PrintWriter getWriter() {\r\n        if (writer == null) {\r\n            writer = new FastCharArrayWriter();\r\n            printWriter = new PrintWriter(writer);\r\n        }\r\n        return printWriter;\r\n    }"}, {"ID": 710, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setObjectReference(final String name, final Object object) { if (objectRefs == null) { objectRefs = new HashMap<>(); } objectRefs.put(name, object); }\n\n    ### Response:", "ground_truth": "Saves object reference.", "predict": "/**\r\n     * Sets the object reference for the given name.\r\n     * \r\n     * @param name the name of the object reference\r\n     * @param object the object reference to be set\r\n     */\r\n    public void setObjectReference(final String name, final Object object) {\r\n        if (objectRefs == null) {\r\n            objectRefs = new HashMap<>();\r\n        }\r\n        objectRefs.put(name, object);\r\n    }"}, {"ID": 711, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); }\n\n    ### Response:", "ground_truth": "Returns object reference.", "predict": "/**\r\n     * This method retrieves the object reference for the given name from the object reference map.\r\n     * \r\n     * @param name The name of the object reference to retrieve.\r\n     * @return The object reference for the given name, or null if no such object reference exists.\r\n     */\r\n    public Object getObjectReference(final String name) {\r\n        if (objectRefs == null) {\r\n            return null;\r\n        }\r\n        return objectRefs.get(name);\r\n    }"}, {"ID": 712, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; }\n\n    ### Response:", "ground_truth": "Lookups for object reference and throws an exception if reference doesn't exist.", "predict": "/**\r\n     * Retrieves the object reference for the given reference string.\r\n     * \r\n     * @param ref the reference string\r\n     * @return the object reference\r\n     * @throws DbSqlBuilderException if the object reference is invalid\r\n     */\r\n    private Object getObjectReference(final String ref) {\r\n        // implementation details\r\n    }"}, {"ID": 713, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityDescriptor getTableDescriptor(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.desc; }\n\n    ### Response:", "ground_truth": "Returns entity descriptor for provided table reference.", "predict": "/**\r\n     * Retrieves the descriptor for the specified table reference.\r\n     * \r\n     * @param tableRef the table reference to retrieve the descriptor for\r\n     * @return the descriptor for the specified table reference, or null if the table reference is not found or the descriptor is null\r\n     */\r\n    public DbEntityDescriptor getTableDescriptor(final String tableRef) {\r\n        if (tableRefs == null) {\r\n            return null;\r\n        }\r\n        TableRefData t = tableRefs.get(tableRef);\r\n        return t == null ? null : t.desc;\r\n    }"}, {"ID": 714, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) { for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) { DbEntityDescriptor ded = entry.getValue().desc; if (ded.findByPropertyName(columnRef) != null) { return ded; } } return null; }\n\n    ### Response:", "ground_truth": "Finds entity descriptor of a table that contains provided column reference.", "predict": "/**\r\n     * Finds the table descriptor by the given column reference.\r\n     * \r\n     * @param columnRef the column reference\r\n     * @return the table descriptor or null if not found\r\n     */\r\n    public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) {\r\n        // TODO: implement logic\r\n    }"}, {"ID": 715, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTableAlias(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.alias; }\n\n    ### Response:", "ground_truth": "Returns table alias for provided table reference.", "predict": "/**\r\n     * Returns the alias for the given table reference.\r\n     * \r\n     * @param tableRef the table reference\r\n     * @return the alias for the table reference, or null if not found\r\n     */\r\n    public String getTableAlias(final String tableRef) {\r\n        if (tableRefs == null) {\r\n            return null;\r\n        }\r\n        TableRefData t = tableRefs.get(tableRef);\r\n        return t == null ? null : t.alias;\r\n    }"}, {"ID": 716, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) { if (tableRefs == null) { tableRefs = new HashMap<>(); } TableRefData t = new TableRefData(ded, tableAlias); if (tableRefs.put(tableReference, t) != null) { throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference); } }\n\n    ### Response:", "ground_truth": "Registers table reference for provided entity.", "predict": "/**\r\n     * Registers a table reference with the SQL builder.\r\n     * \r\n     * @param tableReference the name of the table reference\r\n     * @param ded the descriptor of the entity associated with the table\r\n     * @param tableAlias the alias of the table in the SQL statement\r\n     * @throws DbSqlBuilderException if the table reference is already registered\r\n     */\r\n    public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) {\r\n        if (tableRefs == null) {\r\n            tableRefs = new HashMap<>();\r\n        }\r\n        TableRefData t = new TableRefData(ded, tableAlias);\r\n        if (tableRefs.put(tableReference, t) != null) {\r\n            throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference);\r\n        }\r\n    }"}, {"ID": 717, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor lookupTableRef(final String tableRef) { DbEntityDescriptor ded = getTableDescriptor(tableRef); if (ded == null) { throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef); } return ded; }\n\n    ### Response:", "ground_truth": "Lookups for table reference and throws an exception if table reference not found.", "predict": "/**\r\n     * Looks up the table descriptor for the given table reference.\r\n     * \r\n     * @param tableRef the table reference to lookup\r\n     * @return the table descriptor for the given table reference\r\n     * @throws DbSqlBuilderException if the table reference is not used in this query\r\n     */\r\n    protected DbEntityDescriptor lookupTableRef(final String tableRef) {\r\n        DbEntityDescriptor ded = getTableDescriptor(tableRef);\r\n        if (ded == null) {\r\n            throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef);\r\n        }\r\n        return ded;\r\n    }"}, {"ID": 718, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); }\n\n    ### Response:", "ground_truth": "Registers a hint.", "predict": "/**\r\n     * Registers a hint for the user to complete the registration process.\r\n     * \r\n     * @param hint The hint to be registered.\r\n     */\r\n    public void registerHint(final String hint) {\r\n        if (hints == null) {\r\n            hints = new ArrayList<>(hintCount);\r\n        }\r\n        hints.add(hint);\r\n    }"}, {"ID": 719, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public final boolean serialize(final JsonContext jsonContext, final T value) { if (jsonContext.pushValue(value)) { // prevent circular dependencies return false; } serializeValue(jsonContext, value); jsonContext.popValue(); return true; }\n\n    ### Response:", "ground_truth": "Detects circular dependencies and pushes value as current\ntype context.", "predict": "/**\r\n     * Serializes the given value to JSON using the given context.\r\n     * \r\n     * @param jsonContext the JSON context to use for serialization\r\n     * @param value the value to serialize\r\n     * @return true if the value was successfully serialized, false otherwise\r\n     */\r\n    @Override\r\n    public final boolean serialize(final JsonContext jsonContext, final T value) {\r\n        if (jsonContext.pushValue(value)) { // prevent circular dependencies\r\n            return false;\r\n        }\r\n        serializeValue(jsonContext, value);\r\n        jsonContext.popValue();\r\n        return true;\r\n    }"}, {"ID": 720, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) { final Enumeration<String> attributeNames = servletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attrName = attributeNames.nextElement(); targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(attrName); if (name != null) { final Object attrValue = servletRequest.getAttribute(attrName); target.writeValue(name, attrValue, true); } }); } }\n\n    ### Response:", "ground_truth": "Injects request attributes.", "predict": "/**\r\n     * Injects attributes from the servlet request into the specified targets.\r\n     * \r\n     * @param servletRequest the servlet request to extract attributes from\r\n     * @param targets the targets to inject attributes into\r\n     */\r\n    protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) {\r\n        final Enumeration<String> attributeNames = servletRequest.getAttributeNames();\r\n        while (attributeNames.hasMoreElements()) {\r\n            final String attrName = attributeNames.nextElement();\r\n            targets.forEachTargetAndIn(this, (target, in) -> {\r\n                final String name = in.matchedName(attrName);\r\n                if (name != null) {\r\n                    final Object attrValue = servletRequest.getAttribute(attrName);\r\n                    target.writeValue(name, attrValue, true);\r\n                }\r\n            });\r\n        }\r\n    }"}, {"ID": 721, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) { final boolean encode = encodeGetParams && servletRequest.getMethod().equals(\"GET\"); final Enumeration<String> paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = ServletUtil.prepareParameters( paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues != null) { if (encode) { for (int j = 0; j < paramValues.length; j++) { final String p = paramValues[j]; if (p != null) { final String encoding = madvocEncoding.getEncoding(); paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding); } } } final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]); target.writeValue(name, value, true); } } }); } }\n\n    ### Response:", "ground_truth": "Inject request parameters.", "predict": "/**\n     * Injects parameters into the targets.\n     *\n     * @param servletRequest the servlet request\n     * @param targets the targets\n     */\n    protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) {\n        // implementation details\n    }"}, {"ID": 722, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) { if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } final Enumeration<String> paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { final FileUpload[] paramValues = multipartRequest.getFiles(paramName); if (ignoreInvalidUploadFiles) { for (int j = 0; j < paramValues.length; j++) { final FileUpload paramValue = paramValues[j]; if ((!paramValue.isValid()) || (!paramValue.isUploaded())) { paramValues[j] = null; } } } final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues); target.writeValue(name, value, true); } }); } }\n\n    ### Response:", "ground_truth": "Inject uploaded files from multipart request parameters.", "predict": "/**\r\n     * Injects uploaded files into the specified targets.\r\n     * \r\n     * @param servletRequest the servlet request\r\n     * @param targets the targets to inject the uploaded files into\r\n     */\r\n    protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 723, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String convertPropertyNameToColumnName(final String propertyName) { StringBuilder tableName = new StringBuilder(propertyName.length() * 2); if (splitCamelCase) { String convertedTableName = Format.fromCamelCase(propertyName, separatorChar); tableName.append(convertedTableName); } else { tableName.append(propertyName); } if (!changeCase) { return tableName.toString(); } return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString(); }\n\n    ### Response:", "ground_truth": "Converts property name to column name.", "predict": "/**\r\n     * Converts a property name to a column name.\r\n     * \r\n     * @param propertyName The property name to convert.\r\n     * @return The column name.\r\n     */\r\n    public String convertPropertyNameToColumnName(final String propertyName) {\r\n        StringBuilder tableName = new StringBuilder(propertyName.length() * 2);\r\n        if (splitCamelCase) {\r\n            String convertedTableName = Format.fromCamelCase(propertyName, separatorChar);\r\n            tableName.append(convertedTableName);\r\n        } else {\r\n            tableName.append(propertyName);\r\n        }\r\n        if (!changeCase) {\r\n            return tableName.toString();\r\n        }\r\n        return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString();\r\n    }"}, {"ID": 724, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String convertColumnNameToPropertyName(final String columnName) { StringBuilder propertyName = new StringBuilder(columnName.length()); int len = columnName.length(); if (splitCamelCase) { boolean toUpper = false; for (int i = 0; i < len; i++) { char c = columnName.charAt(i); if (c == separatorChar) { toUpper = true; continue; } if (toUpper) { propertyName.append(Character.toUpperCase(c)); toUpper = false; } else { propertyName.append(Character.toLowerCase(c)); } } return propertyName.toString(); } return columnName; }\n\n    ### Response:", "ground_truth": "Converts column name to property name.", "predict": "/**\r\n     * Converts a column name to a property name by splitting camel case words and converting them to lower case.\r\n     * \r\n     * @param columnName the column name to convert\r\n     * @return the property name\r\n     */\r\n    public String convertColumnNameToPropertyName(final String columnName) {\r\n        StringBuilder propertyName = new StringBuilder(columnName.length());\r\n        int len = columnName.length();\r\n        if (splitCamelCase) {\r\n            boolean toUpper = false;\r\n            for (int i = 0; i < len; i++) {\r\n                char c = columnName.charAt(i);\r\n                if (c == separatorChar) {\r\n                    toUpper = true;\r\n                    continue;\r\n                }\r\n                if (toUpper) {\r\n                    propertyName.append(Character.toUpperCase(c));\r\n                    toUpper = false;\r\n                } else {\r\n                    propertyName.append(Character.toLowerCase(c));\r\n                }\r\n            }\r\n            return propertyName.toString();\r\n        }\r\n        return columnName;\r\n    }"}, {"ID": 725, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String applyToColumnName(final String columnName) { String propertyName = convertColumnNameToPropertyName(columnName); return convertPropertyNameToColumnName(propertyName); }\n\n    ### Response:", "ground_truth": "Applies column naming strategy to given column name hint.\nReturns full column name.", "predict": "/**\r\n     * Converts a column name to a property name.\r\n     * \r\n     * @param columnName the column name to convert\r\n     * @return the property name\r\n     */\r\n    public String convertColumnNameToPropertyName(final String columnName) {\r\n        // implementation details\r\n    }\r\n\r\n    /**\r\n     * Converts a property name to a column name.\r\n     * \r\n     * @param propertyName the property name to convert\r\n     * @return the column name\r\n     */\r\n    public String convertPropertyNameToColumnName(final String propertyName) {\r\n        // implementation details\r\n    }"}, {"ID": 726, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException { T t = TypeConverterManager.get().convertType(value, sqlType); set(st, index, t, dbSqlType); }\n\n    ### Response:", "ground_truth": "Stores value in database. Value is casted to sql type.", "predict": "/**\r\n     * Stores the given value in the prepared statement at the given index.\r\n     * \r\n     * @param st the prepared statement to store the value in\r\n     * @param index the index of the parameter to store the value in\r\n     * @param value the value to store in the prepared statement\r\n     * @param dbSqlType the SQL type of the value to store in the database\r\n     * @throws SQLException if an error occurs while storing the value in the prepared statement\r\n     */\r\n    public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException;"}, {"ID": 727, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected <E> E prepareGetValue(final T t, final Class<E> destinationType) { if (t == null) { return null; } if (destinationType == null) { return (E) t; } return TypeConverterManager.get().convertType(t, destinationType); }\n\n    ### Response:", "ground_truth": "Once when value is read from result set, prepare it to match destination type.\n@param t get value\n@param destinationType destination type", "predict": "/**\r\n     * This method prepares the value of the given object to be returned as the specified type.\r\n     * \r\n     * @param t the object to be prepared\r\n     * @param destinationType the type to which the object should be converted\r\n     * @return the prepared value\r\n     */\r\n    @SuppressWarnings({\"unchecked\"})\r\n    protected <E> E prepareGetValue(final T t, final Class<E> destinationType) {\r\n        if (t == null) {\r\n            return null;\r\n        }\r\n        if (destinationType == null) {\r\n            return (E) t;\r\n        }\r\n        return TypeConverterManager.get().convertType(t, destinationType);\r\n    }"}, {"ID": 728, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Set<T> getAll() { final Set<T> set = new HashSet<>(wrappers.size()); set.addAll(wrappers.values()); return set; }\n\n    ### Response:", "ground_truth": "Returns all action wrappers. Returns a copy in new set.", "predict": "/**\r\n     * Returns a set of all the objects in the cache.\r\n     *\r\n     * @return a set of all the objects in the cache\r\n     */\r\n    protected Set<T> getAll() {\r\n        final Set<T> set = new HashSet<>(wrappers.size());\r\n        set.addAll(wrappers.values());\r\n        return set;\r\n    }"}, {"ID": 729, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; }\n\n    ### Response:", "ground_truth": "Resolves single wrapper. Creates new wrapper instance if not already registered.\nDoes not expand the wrappers.", "predict": "/**\r\n     * Resolves the wrapper instance for the given wrapper class.\r\n     * \r\n     * @param wrapperClass the wrapper class to resolve\r\n     * @return the wrapper instance\r\n     */\r\n    public T resolve(final Class<? extends T> wrapperClass) {\r\n        String wrapperClassName = wrapperClass.getName();\r\n        T wrapper = lookup(wrapperClassName);\r\n        if (wrapper == null) {\r\n            wrapper = createWrapper(wrapperClass);\r\n            initializeWrapper(wrapper);\r\n            wrappers.put(wrapperClassName, wrapper);\r\n        }\r\n        return wrapper;\r\n    }"}, {"ID": 730, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } }\n\n    ### Response:", "ground_truth": "Creates new wrapper.", "predict": "/**\r\n     * Creates a new instance of the specified wrapper class.\r\n     * \r\n     * @param <R> the type of the wrapper class\r\n     * @param wrapperClass the wrapper class to create an instance of\r\n     * @return a new instance of the specified wrapper class\r\n     * @throws MadvocException if an error occurs while creating the instance\r\n     */\r\n    protected <R extends T> R createWrapper(final Class<R> wrapperClass) {\r\n        try {\r\n            return ClassUtil.newInstance(wrapperClass);\r\n        } catch (Exception ex) {\r\n            throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex);\r\n        }\r\n    }"}, {"ID": 731, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } }\n\n    ### Response:", "ground_truth": "Converts all separators to the system separator.\n\n@param path  the path to be changed, null ignored\n@return the updated path", "predict": "/**\r\n     * Converts the path separators in the given path to the system separator.\r\n     *\r\n     * @param path the path to convert\r\n     * @return the converted path\r\n     */\r\n    public static String separatorsToSystem(final String path) {\r\n        if (path == null) {\r\n            return null;\r\n        }\r\n        if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) {\r\n            return separatorsToWindows(path);\r\n        } else {\r\n            return separatorsToUnix(path);\r\n        }\r\n    }"}, {"ID": 732, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String doGetPath(final String filename, final int separatorAdd) { if (filename == null) { return null; } int prefix = getPrefixLength(filename); if (prefix < 0) { return null; } int index = indexOfLastSeparator(filename); int endIndex = index + separatorAdd; if (prefix >= filename.length() || index < 0 || prefix >= endIndex) { return StringPool.EMPTY; } return filename.substring(prefix, endIndex); }\n\n    ### Response:", "ground_truth": "Does the work of getting the path.\n\n@param filename  the filename\n@param separatorAdd  0 to omit the end separator, 1 to return it\n@return the path", "predict": "/**\r\n     * Returns the path of the given filename, starting from the root directory.\r\n     *\r\n     * @param filename the filename to find the path for\r\n     * @param separatorAdd the number of additional separators to add to the end of the path\r\n     * @return the path of the given filename, starting from the root directory, or null if the filename is null\r\n     */\r\n    private static String doGetPath(final String filename, final int separatorAdd) {\r\n        // implementation code here\r\n    }"}, {"ID": 733, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } return new String[] {prefix, path, baseName, extension}; }\n\n    ### Response:", "ground_truth": "Splits filename into a array of four Strings containing prefix, path, basename and extension.\nPath will contain ending separator.", "predict": "/**\r\n     * Splits a filename into its prefix, path, base name, and extension components.\r\n     *\r\n     * @param filename the filename to split\r\n     * @return an array of four strings containing the prefix, path, base name, and extension components of the filename\r\n     */\r\n    public static String[] split(final String filename) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 734, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String relativePath(final String targetPath, final String basePath) { return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString(); }\n\n    ### Response:", "ground_truth": "Calculates relative path of target path on base path.", "predict": "/**\r\n     * This method takes in two strings representing a target path and a base path, and returns a string representing the relative path from the base path to the target path.\r\n     * \r\n     * @param targetPath the path to which the relative path is to be calculated\r\n     * @param basePath the path from which the relative path is to be calculated\r\n     * @return a string representing the relative path from the base path to the target path\r\n     */\r\n    public static String relativePath(final String targetPath, final String basePath) {\r\n        return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString();\r\n    }"}, {"ID": 735, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; }\n\n    ### Response:", "ground_truth": "Registers additional Madvoc components after the registration of default components.", "predict": "/**\n     * Registers a Madvoc component.\n     *\n     * @param madvocComponent the Madvoc component to register\n     * @return this WebApp instance\n     * @throws NullPointerException if the component is null\n     */\n    public WebApp registerComponent(final Class<?> madvocComponent) {\n        Objects.requireNonNull(madvocComponent);\n        madvocComponents.add(ClassConsumer.of(madvocComponent));\n        return this;\n    }"}, {"ID": 736, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; }\n\n    ### Response:", "ground_truth": "Configures the action configurations.", "predict": "/**\r\n     * Registers an action configuration with the application.\r\n     *\r\n     * @param actionConfigType the type of the action configuration to register\r\n     * @param actionConfigConsumer a consumer that will be used to configure the action configuration\r\n     * @param <A> the type of the action configuration\r\n     * @return the web application instance\r\n     */\r\n    public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) {\r\n        withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer));\r\n        return this;\r\n    }"}, {"ID": 737, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WebApp start() { log = LoggerFactory.getLogger(WebApp.class); log.debug(\"Initializing Madvoc WebApp\"); //// params & props for (final Map<String, Object> params : paramsList) { madvocContainer.defineParams(params); } for (final Props props : propsList) { madvocContainer.defineParams(props); } propsList = null; //// components registerMadvocComponents(); madvocComponents.forEach( madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer())); madvocComponents = null; madvocComponentInstances.forEach(madvocContainer::registerComponentInstance); madvocComponentInstances = null; configureDefaults(); //// listeners madvocContainer.fireEvent(Init.class); //// component configuration componentConfigs.accept(madvocContainer); componentConfigs = null; initialized(); madvocContainer.fireEvent(Start.class); if (!madvocRouterConsumers.isEmpty()) { final MadvocRouter madvocRouter = MadvocRouter.create(); madvocContainer.registerComponentInstance(madvocRouter); madvocRouterConsumers.accept(madvocRouter); } madvocRouterConsumers = null; started(); madvocContainer.fireEvent(Ready.class); ready(); return this; }\n\n    ### Response:", "ground_truth": "Initializes and starts web application.", "predict": "/**\n     * Starts the web application.\n     *\n     * @return the web application instance\n     */\n    public WebApp start() {\n        // TODO: Implement method\n    }"}, {"ID": 738, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void configureDefaults() { final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class); actionConfigManager.registerAnnotation(Action.class); actionConfigManager.registerAnnotation(RestAction.class); }\n\n    ### Response:", "ground_truth": "Configure defaults.", "predict": "/**\r\n     * Configures the default annotations for the action configuration manager.\r\n     */\r\n    protected void configureDefaults() {\r\n        final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class);\r\n        actionConfigManager.registerAnnotation(Action.class);\r\n        actionConfigManager.registerAnnotation(RestAction.class);\r\n    }"}, {"ID": 739, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerMadvocComponents() { if (madvocContainer == null) { throw new MadvocException(\"Madvoc WebApp not initialized.\"); } log.debug(\"Registering Madvoc WebApp components\"); madvocContainer.registerComponent(MadvocEncoding.class); madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext)); madvocContainer.registerComponent(ActionConfigManager.class); madvocContainer.registerComponent(ActionMethodParamNameResolver.class); madvocContainer.registerComponent(ActionMethodParser.class); madvocContainer.registerComponent(ActionPathRewriter.class); madvocContainer.registerComponent(ActionsManager.class); madvocContainer.registerComponent(ContextInjectorComponent.class); madvocContainer.registerComponent(InterceptorsManager.class); madvocContainer.registerComponent(FiltersManager.class); madvocContainer.registerComponent(MadvocController.class); madvocContainer.registerComponent(RootPackages.class); madvocContainer.registerComponent(ResultsManager.class); madvocContainer.registerComponent(ResultMapper.class); madvocContainer.registerComponent(ScopeResolver.class); madvocContainer.registerComponent(ScopeDataInspector.class); madvocContainer.registerComponent(AsyncActionExecutor.class); madvocContainer.registerComponent(FileUploader.class); }\n\n    ### Response:", "ground_truth": "Registers default Madvoc components.", "predict": "/**\n     * Registers Madvoc components in the container.\n     *\n     * @throws MadvocException if Madvoc WebApp not initialized.\n     */\n    protected void registerMadvocComponents() {\n        if (madvocContainer == null) {\n            throw new MadvocException(\"Madvoc WebApp not initialized.\");\n        }\n        log.debug(\"Registering Madvoc WebApp components\");\n        madvocContainer.registerComponent(MadvocEncoding.class);\n        madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext));\n        madvocContainer.registerComponent(ActionConfigManager.class);\n        madvocContainer.registerComponent(ActionMethodParamNameResolver.class);\n        madvocContainer.registerComponent(ActionMethodParser.class);\n        madvocContainer.registerComponent(ActionPathRewriter.class);\n        madvocContainer.registerComponent(ActionsManager.class);\n        madvocContainer.registerComponent(ContextInjectorComponent.class);\n        madvocContainer"}, {"ID": 740, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner excludeJars(final String... excludedJars) { for (final String excludedJar : excludedJars) { rulesJars.exclude(excludedJar); } return this; }\n\n    ### Response:", "ground_truth": "Specify excluded jars.", "predict": "/**\r\n     * Excludes the specified jars from the list of jars to be scanned.\r\n     * \r\n     * @param excludedJars the jars to exclude\r\n     * @return the updated scanner\r\n     */\r\n    public ClassScanner excludeJars(final String... excludedJars) {\r\n        for (final String excludedJar : excludedJars) {\r\n            rulesJars.exclude(excludedJar);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 741, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner includeJars(final String... includedJars) { for (final String includedJar : includedJars) { rulesJars.include(includedJar); } return this; }\n\n    ### Response:", "ground_truth": "Specify included jars.", "predict": "/**\r\n     * Adds the specified jars to the list of jars to be included in the class scanner.\r\n     * \r\n     * @param includedJars the jars to be included in the class scanner\r\n     * @return the updated class scanner\r\n     */\r\n    public ClassScanner includeJars(final String... includedJars) {\r\n        for (final String includedJar : includedJars) {\r\n            rulesJars.include(includedJar);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 742, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; }\n\n    ### Response:", "ground_truth": "Sets included set of names that will be considered during configuration.\n@see InExRules", "predict": "/**\r\n     * Adds the specified entries to the list of included entries.\r\n     * \r\n     * @param includedEntries the entries to be included\r\n     * @return the updated scanner\r\n     */\r\n    public ClassScanner includeEntries(final String... includedEntries) {\r\n        for (final String includedEntry : includedEntries) {\r\n            rulesEntries.include(includedEntry);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 743, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner excludeEntries(final String... excludedEntries) { for (final String excludedEntry : excludedEntries) { rulesEntries.exclude(excludedEntry); } return this; }\n\n    ### Response:", "ground_truth": "Sets excluded names that narrows included set of packages.\n@see InExRules", "predict": "/**\r\n     * Excludes the specified entries from the scanner's rules.\r\n     * \r\n     * @param excludedEntries the entries to exclude\r\n     * @return the updated scanner\r\n     */\r\n    public ClassScanner excludeEntries(final String... excludedEntries) {\r\n        for (final String excludedEntry : excludedEntries) {\r\n            rulesEntries.exclude(excludedEntry);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 744, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void scanJarFile(final File file) { final ZipFile zipFile; try { zipFile = new ZipFile(file); } catch (IOException ioex) { if (!ignoreException) { throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex); } return; } final Enumeration entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry zipEntry = (ZipEntry) entries.nextElement(); final String zipEntryName = zipEntry.getName(); try { if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) { final String entryName = prepareEntryName(zipEntryName, true); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } else if (includeResources) { final String entryName = prepareEntryName(zipEntryName, false); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } } catch (RuntimeException rex) { if (!ignoreException) { ZipUtil.close(zipFile); throw rex; } } } ZipUtil.close(zipFile); }\n\n    ### Response:", "ground_truth": "Scans classes inside single JAR archive. Archive is scanned as a zip file.\n@see #onEntry(ClassPathEntry)", "predict": "/**\r\n     * Scans the given jar file for class files and resource files.\r\n     * \r\n     * @param file the jar file to scan\r\n     */\r\n    protected void scanJarFile(final File file) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 745, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void scanClassPath(final File root) { String rootPath = root.getAbsolutePath(); if (!rootPath.endsWith(File.separator)) { rootPath += File.separatorChar; } final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath); File file; while ((file = ff.nextFile()) != null) { final String filePath = file.getAbsolutePath(); try { if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) { scanClassFile(filePath, rootPath, file, true); } else if (includeResources) { scanClassFile(filePath, rootPath, file, false); } } catch (RuntimeException rex) { if (!ignoreException) { throw rex; } } } }\n\n    ### Response:", "ground_truth": "Scans single classpath directory.\n@see #onEntry(ClassPathEntry)", "predict": "/**\r\n     * Scans the class path for classes and resources.\r\n     * \r\n     * @param root the root directory to scan\r\n     */\r\n    protected void scanClassPath(final File root) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 746, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] bytecodeSignatureOfType(final Class type) { final String name = 'L' + type.getName().replace('.', '/') + ';'; return name.getBytes(); }\n\n    ### Response:", "ground_truth": "Returns type signature bytes used for searching in class file.", "predict": "/**\r\n     * Returns the bytecode signature of the given type.\r\n     * \r\n     * @param type the type to get the signature for\r\n     * @return the bytecode signature of the type\r\n     */\r\n    public static byte[] bytecodeSignatureOfType(final Class type) {\r\n        final String name = 'L' + type.getName().replace('.', '/') + ';';\r\n        return name.getBytes();\r\n    }"}, {"ID": 747, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ClassScanner scan(final String... paths) { for (final String path : paths) { filesToScan.add(new File(path)); } return this; }\n\n    ### Response:", "ground_truth": "Scans provided paths.", "predict": "/**\r\n     * Scans the given paths for classes and adds them to the list of files to be scanned.\r\n     * \r\n     * @param paths the paths to scan for classes\r\n     * @return the updated scanner object\r\n     */\r\n    public ClassScanner scan(final String... paths) {\r\n        for (final String path : paths) {\r\n            filesToScan.add(new File(path));\r\n        }\r\n        return this;\r\n    }"}, {"ID": 748, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() { if (detectEntriesMode) { rulesEntries.detectMode(); } filesToScan.forEach(file -> { final String path = file.getAbsolutePath(); if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) { if (!acceptJar(file)) { return; } scanJarFile(file); } else if (file.isDirectory()) { scanClassPath(file); } }); }\n\n    ### Response:", "ground_truth": "Starts with the scanner.", "predict": "/**\r\n     * This method starts the scanning process by detecting the mode of entries and scanning the files to be scanned.\r\n     */\r\n    public void start() {\r\n        // code goes here\r\n    }"}, {"ID": 749, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) { return new DbJtxTransaction(this, tm, scope, active); }\n\n    ### Response:", "ground_truth": "Builds new transaction instance.", "predict": "/**\n     * Creates a new transaction object with the specified transaction mode, scope, and active status.\n     * \n     * @param tm the transaction mode\n     * @param scope the transaction scope\n     * @param active whether the transaction is active or not\n     * @return the new transaction object\n     */\n    @Override protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) { return new DbJtxTransaction(this, tm, scope, active); }"}, {"ID": 750, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass); }\n\n    ### Response:", "ground_truth": "Lookups the scope instance of given scope annotation.\nIf instance does not exist, it will be created, cached and returned.", "predict": "/**\r\n     * Returns the default or specified scope type.\r\n     * \r\n     * @param scopeClass the scope class to retrieve or null to retrieve the default scope\r\n     * @return the scope instance\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) {\r\n        if (scopeClass == null) {\r\n            return (S) getOrInitScope(RequestScope.class);\r\n        }\r\n        return (S) getOrInitScope(scopeClass);\r\n    }"}, {"ID": 751, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) { for (final MadvocScope s : allScopes) { if (s.getClass().equals(madvocScopeType)) { return s; } } // new scope detected final MadvocScope newScope; try { newScope = madpc.createBean(madvocScopeType); } catch (Exception ex) { throw new MadvocException(\"Unable to create scope: \" + madvocScopeType, ex); } allScopes.add(newScope); return newScope; }\n\n    ### Response:", "ground_truth": "Performs search for the scope class and returns it's instance.", "predict": "/**\r\n     * Gets or initializes a scope of the given type.\r\n     *\r\n     * @param madvocScopeType the type of the scope to get or initialize\r\n     * @return the scope of the given type\r\n     */\r\n    protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) {\r\n        for (final MadvocScope s : allScopes) {\r\n            if (s.getClass().equals(madvocScopeType)) {\r\n                return s;\r\n            }\r\n        }\r\n        // new scope detected\r\n        final MadvocScope newScope;\r\n        try {\r\n            newScope = madpc.createBean(madvocScopeType);\r\n        } catch (Exception ex) {\r\n            throw new MadvocException(\"Unable to create scope: \" + madvocScopeType, ex);\r\n        }\r\n        allScopes.add(newScope);\r\n        return newScope;\r\n    }"}, {"ID": 752, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) { final MadvocScope scope = getOrInitScope(scopeType); madvocScopeConsumer.accept(scope); }\n\n    ### Response:", "ground_truth": "Finds a given scope and consumes it.", "predict": "/**\r\n     * This method initializes or retrieves a MadvocScope of the specified type and passes it to the specified consumer.\r\n     *\r\n     * @param scopeType the type of MadvocScope to initialize or retrieve\r\n     * @param madvocScopeConsumer the consumer that will receive the MadvocScope\r\n     */\r\n    public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) {\r\n        final MadvocScope scope = getOrInitScope(scopeType);\r\n        madvocScopeConsumer.accept(scope);\r\n    }"}, {"ID": 753, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] decode(final char[] arr) { int length = arr.length; if (length == 0) { return new byte[0]; } int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0; int len = ((cnt - sepCnt) * 6 >> 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) { int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx++]] << 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i >> 16); dest[d++] = (byte) (i >> 8); dest[d++] = (byte) i; if (sepCnt > 0 && ++cc == 19) { sndx += 2; cc = 0; } } if (d < len) { int i = 0; for (int j = 0; sndx <= endx - pad; j++) { i |= INV[arr[sndx++]] << (18 - j * 6); } for (int r = 16; d < len; r -= 8) { dest[d++] = (byte) (i >> r); } } return dest; }\n\n    ### Response:", "ground_truth": "Decodes a BASE64 encoded char array.", "predict": "/**\r\n * Decodes a BASE64 encoded char array into a byte array.\r\n *\r\n * @param arr the char array to decode\r\n * @return the decoded byte array\r\n */\r\npublic static byte[] decode(final char[] arr) {\r\n    int length = arr.length;\r\n    if (length == 0) {\r\n        return new byte[0];\r\n    }\r\n    int sndx = 0, endx = length - 1;\r\n    int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0;\r\n    int cnt = endx - sndx + 1;\r\n    int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0;\r\n    int len = ((cnt - sepCnt) * 6 >> 3) - pad;\r\n    byte[] dest = new byte[len];\r\n    int d = 0"}, {"ID": 754, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static String prepareCsrfToken(final HttpSession session, final int timeToLive) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if (tokenSet == null) { tokenSet = new HashSet<>(); session.setAttribute(CSRF_TOKEN_SET, tokenSet); } String value; boolean unique; do { value = RandomString.get().randomAlphaNumeric(32); assureSize(tokenSet); unique = tokenSet.add(new Token(value, timeToLive)); } while (!unique); return value; }\n\n    ### Response:", "ground_truth": "Generates new CSRF token and puts it in the session. Returns generated token value.", "predict": "/**\r\n     * Generates a unique CSRF token and stores it in the session.\r\n     *\r\n     * @param session the HTTP session\r\n     * @param timeToLive the time to live for the token in seconds\r\n     * @return the generated CSRF token\r\n     */\r\n    public static String prepareCsrfToken(final HttpSession session, final int timeToLive) {\r\n        Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET);\r\n        if (tokenSet == null) {\r\n            tokenSet = new HashSet<>();\r\n            session.setAttribute(CSRF_TOKEN_SET, tokenSet);\r\n        }\r\n        String value;\r\n        boolean unique;\r\n        do {\r\n            value = RandomString.get().randomAlphaNumeric(32);\r\n            assureSize(tokenSet);\r\n            unique = tokenSet.add(new Token(value, timeToLive));\r\n        } while (!unique);\r\n        return value;\r\n    }"}, {"ID": 755, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static void assureSize(final Set<Token> tokenSet) { if (tokenSet.size() < maxTokensPerSession) { return; } long validUntilMin = Long.MAX_VALUE; Token tokenToRemove = null; Iterator<Token> iterator = tokenSet.iterator(); while (iterator.hasNext()) { Token token = iterator.next(); if (token.isExpired()) { iterator.remove(); continue; } if (token.validUntil < validUntilMin) { validUntilMin = token.validUntil; tokenToRemove = token; } } if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) { tokenSet.remove(tokenToRemove); } }\n\n    ### Response:", "ground_truth": "Removes expired tokens if token set is full.\n@see #setMaxTokensPerSession(int)", "predict": "/**\r\n     * This method is responsible for ensuring that the token set does not exceed the maximum number of tokens per session.\r\n     * \r\n     * @param tokenSet the set of tokens to check\r\n     */\r\n    protected static void assureSize(final Set<Token> tokenSet) {\r\n        if (tokenSet.size() < maxTokensPerSession) {\r\n            return;\r\n        }\r\n        long validUntilMin = Long.MAX_VALUE;\r\n        Token tokenToRemove = null;\r\n        Iterator<Token> iterator = tokenSet.iterator();\r\n        while (iterator.hasNext()) {\r\n            Token token = iterator.next();\r\n            if (token.isExpired()) {\r\n                iterator.remove();\r\n                continue;\r\n            }\r\n            if (token.validUntil < validUntilMin) {\r\n                validUntilMin = token.validUntil;\r\n                tokenToRemove = token;\r\n            }\r\n        }\r\n        if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) {\r\n            tokenSet.remove(tokenToRemove);\r\n        }\r\n    }"}, {"ID": 756, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if ((tokenSet == null) && (tokenValue == null)) { return true; } if ((tokenSet == null) || (tokenValue == null)) { return false; } boolean found = false; Iterator<Token> it = tokenSet.iterator(); while (it.hasNext()) { Token t = it.next(); if (t.isExpired()) { it.remove(); continue; } if (t.getValue().equals(tokenValue)) { it.remove(); found = true; } } return found; }\n\n    ### Response:", "ground_truth": "Checks token value.\nC", "predict": "/**\r\n     * This method checks the CSRF token value against the set of tokens stored in the session.\r\n     * \r\n     * @param session\r\n     *            The HttpSession object\r\n     * @param tokenValue\r\n     *            The CSRF token value to be checked\r\n     * @return true if the token value is valid, false otherwise\r\n     */\r\n    public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) {\r\n        Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET);\r\n        if ((tokenSet == null) && (tokenValue == null)) {\r\n            return true;\r\n        }\r\n        if ((tokenSet == null) || (tokenValue == null)) {\r\n            return false;\r\n        }\r\n        boolean found = false;\r\n        Iterator<Token> it = tokenSet.iterator();\r\n        while (it.hasNext()) {\r\n            Token t = it.next();\r\n            if (t.isExpired()) {\r\n                it.remove();\r\n                continue;\r\n            }\r\n            if (t.getValue().equals(token"}, {"ID": 757, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static BeanCopy from(final Object source) { BeanCopy beanCopy = new BeanCopy(source); beanCopy.isSourceMap = source instanceof Map; return beanCopy; }\n\n    ### Response:", "ground_truth": "Defines source, detects a map.", "predict": "/**\r\n     * Creates a new instance of BeanCopy with the given source object.\r\n     * \r\n     * @param source the source object to copy from\r\n     * @return a new instance of BeanCopy\r\n     */\r\n    public static BeanCopy from(final Object source) {\r\n        BeanCopy beanCopy = new BeanCopy(source);\r\n        beanCopy.isSourceMap = source instanceof Map;\r\n        return beanCopy;\r\n    }"}, {"ID": 758, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void copy() { beanUtil = new BeanUtilBean() .declared(declared) .forced(forced) .silent(true); visit(); }\n\n    ### Response:", "ground_truth": "Performs the copying.", "predict": "/**\r\n     * Copies the current object to a new object of the same type.\r\n     */\r\n    public void copy() {\r\n        // Create a new instance of the same type\r\n        BeanUtilBean newBeanUtil = new BeanUtilBean();\r\n        \r\n        // Set the declared fields\r\n        newBeanUtil.setDeclared(declared);\r\n        \r\n        // Set the forced fields\r\n        newBeanUtil.setForced(forced);\r\n        \r\n        // Set the silent flag\r\n        newBeanUtil.setSilent(true);\r\n        \r\n        // Visit the new object\r\n        newBeanUtil.visit();\r\n    }"}, {"ID": 759, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected boolean visitProperty(String name, final Object value) { if (isTargetMap) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } beanUtil.setProperty(destination, name, value); return true; }\n\n    ### Response:", "ground_truth": "Copies single property to the destination.\nExceptions are ignored, so copying continues if\ndestination does not have some of the sources properties.", "predict": "/**\r\n     * Sets the property with the given name to the given value on the destination object.\r\n     * \r\n     * @param name the name of the property to set\r\n     * @param value the value to set the property to\r\n     * @return true to continue visiting properties, false to stop\r\n     */\r\n    @Override\r\n    protected boolean visitProperty(String name, final Object value) {\r\n        if (isTargetMap) {\r\n            name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET;\r\n        }\r\n        beanUtil.setProperty(destination, name, value);\r\n        return true;\r\n    }"}, {"ID": 760, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final TemplateData templateData) { super.init(templateData); if (entity != null) { ded = lookupType(entity); } else { Object object = templateData.getObjectReference(entityName); if (object != null) { ded = lookupType(resolveClass(object)); } else { ded = lookupName(entityName); } } String tableReference = this.tableReference; if (tableReference == null) { tableReference = tableAlias; } if (tableReference == null) { tableReference = entityName; } if (tableReference == null) { tableReference = ded.getEntityName(); } templateData.registerTableReference(tableReference, ded, tableAlias); }\n\n    ### Response:", "ground_truth": "Resolves and registers table references.", "predict": "/**\n     * Initializes the component with the given template data.\n     * \n     * @param templateData the template data to use for initialization\n     */\n    @Override\n    public void init(final TemplateData templateData) {\n        super.init(templateData);\n        if (entity != null) {\n            ded = lookupType(entity);\n        } else {\n            Object object = templateData.getObjectReference(entityName);\n            if (object != null) {\n                ded = lookupType(resolveClass(object));\n            } else {\n                ded = lookupName(entityName);\n            }\n        }\n        String tableReference = this.tableReference;\n        if (tableReference == null) {\n            tableReference = tableAlias;\n        }\n        if (tableReference == null) {\n            tableReference = entityName;\n        }\n        if (tableReference == null) {\n            tableReference = ded.getEntityName();\n        }\n        templateData.registerTableReference(tableReference, ded, tableAlias);\n    }"}, {"ID": 761, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <S extends Scope> S resolveScope(final Class<S> scopeType) { S scope = (S) scopes.get(scopeType); if (scope == null) { try { scope = newInternalInstance(scopeType, (PetiteContainer) this); } catch (Exception ex) { throw new PetiteException(\"Invalid Petite scope: \" + scopeType.getName(), ex); } registerScope(scopeType, scope); scopes.put(scopeType, scope); } return scope; }\n\n    ### Response:", "ground_truth": "Resolves and registers scope from a scope type.", "predict": "/**\n     * Resolves the specified scope type. If the scope has not been resolved before, a new instance of the scope is created using the internal constructor.\n     * \n     * @param scopeType the type of the scope to resolve\n     * @return the resolved scope instance\n     */\n    public <S extends Scope> S resolveScope(final Class<S> scopeType) {\n        S scope = (S) scopes.get(scopeType);\n        if (scope == null) {\n            try {\n                scope = newInternalInstance(scopeType, (PetiteContainer) this);\n            } catch (Exception ex) {\n                throw new PetiteException(\"Invalid Petite scope: \" + scopeType.getName(), ex);\n            }\n            registerScope(scopeType, scope);\n            scopes.put(scopeType, scope);\n        }\n        return scope;\n    }"}, {"ID": 762, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> BeanDefinition<T> registerPetiteBean( final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer ) { if (name == null) { name = resolveBeanName(type); } if (wiringMode == null) { wiringMode = annotationResolver.resolveBeanWiringMode(type); } if (wiringMode == WiringMode.DEFAULT) { wiringMode = petiteConfig.getDefaultWiringMode(); } if (scopeType == null) { scopeType = annotationResolver.resolveBeanScopeType(type); } if (scopeType == null) { scopeType = SingletonScope.class; } // remove existing bean BeanDefinition existing = removeBean(name); if (existing != null) { if (petiteConfig.getDetectDuplicatedBeanNames()) { throw new PetiteException( \"Duplicated bean name detected while registering class '\" + type.getName() + \"'. Petite bean class '\" + existing.type.getName() + \"' is already registered with the name: \" + name); } } // check if type is valid if (type.isInterface()) { throw new PetiteException(\"PetiteBean can not be an interface: \" + type.getName()); } // registration if (log.isDebugEnabled()) { log.info(\"Petite bean: [\" + name + \"] --> \" + type.getName() + \" @ \" + scopeType.getSimpleName() + \":\" + wiringMode.toString()); } // register Scope scope = resolveScope(scopeType); BeanDefinition<T> beanDefinition = createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); registerBean(name, beanDefinition); // providers ProviderDefinition[] providerDefinitions = petiteResolvers.resolveProviderDefinitions(type, name); if (providerDefinitions != null) { for (ProviderDefinition providerDefinition : providerDefinitions) { providers.put(providerDefinition.name, providerDefinition); } } // define if (define) { beanDefinition.ctor = petiteResolvers.resolveCtorInjectionPoint(beanDefinition.type()); beanDefinition.properties = PropertyInjectionPoint.EMPTY; beanDefinition.methods = MethodInjectionPoint.EMPTY; beanDefinition.initMethods = InitMethodPoint.EMPTY; beanDefinition.destroyMethods = DestroyMethodPoint.EMPTY; } // return return beanDefinition; }\n\n    ### Response:", "ground_truth": "Registers or defines a bean.\n\n@param type bean type, must be specified\n@param name bean name, if null it will be resolved from the class (name or annotation)\n@param scopeType bean scope, if null it will be resolved from the class (annotation or default one)\n@param wiringMode wiring mode, if null it will be resolved from the class (annotation or default one)\n@param define when set to true bean will be defined - all injection points will be set to none", "predict": "/**\n     * Registers a new petite bean with the given name, type, scope, wiring mode, and consumer.\n     *\n     * @param type the bean type\n     * @param name the bean name (optional)\n     * @param scopeType the bean scope type (optional)\n     * @param wiringMode the bean wiring mode (optional)\n     * @param define whether to define the bean (optional)\n     * @param consumer the bean consumer (optional)\n     * @return the registered bean definition\n     */\n    public <T> BeanDefinition<T> registerPetiteBean(final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer) {\n        // implementation omitted for brevity\n    }"}, {"ID": 763, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerBean(final String name, final BeanDefinition beanDefinition) { beans.put(name, beanDefinition); if (!petiteConfig.isUseAltBeanNames()) { return; } Class type = beanDefinition.type(); if (annotationResolver.beanHasAnnotationName(type)) { return; } Class[] interfaces = ClassUtil.resolveAllInterfaces(type); for (Class anInterface : interfaces) { String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames()); if (name.equals(altName)) { continue; } if (beans.containsKey(altName)) { continue; } if (beansAlt.containsKey(altName)) { BeanDefinition existing = beansAlt.get(altName); if (existing != null) { beansAlt.put(altName, null); // store null as value to mark that alt name is duplicate } } else { beansAlt.put(altName, beanDefinition); } } }\n\n    ### Response:", "ground_truth": "Registers bean definition by putting it in the beans map. If bean does\nnot have petite name explicitly defined, alternative bean names\nwill be registered.", "predict": "/**\r\n     * Registers a new bean definition with the given name and definition.\r\n     *\r\n     * @param name the name of the bean to register\r\n     * @param beanDefinition the bean definition to register\r\n     */\r\n    protected void registerBean(final String name, final BeanDefinition beanDefinition) {\r\n        beans.put(name, beanDefinition);\r\n        if (!petiteConfig.isUseAltBeanNames()) {\r\n            return;\r\n        }\r\n\r\n        Class type = beanDefinition.type();\r\n        if (annotationResolver.beanHasAnnotationName(type)) {\r\n            return;\r\n        }\r\n\r\n        Class[] interfaces = ClassUtil.resolveAllInterfaces(type);\r\n        for (Class anInterface : interfaces) {\r\n            String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames());\r\n            if (name.equals(altName)) {\r\n                continue;\r\n            }\r\n\r\n            if (beans.containsKey(altName)) {\r\n                continue;\r\n            }\r\n\r\n            if (beansAlt.containsKey(altName)) {\r\n                BeanDefinition existing = be"}, {"ID": 764, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeBean(final Class type) { // collect bean names Set<String> beanNames = new HashSet<>(); for (BeanDefinition def : beans.values()) { if (def.type.equals(type)) { beanNames.add(def.name); } } // remove collected bean names for (String beanName : beanNames) { removeBean(beanName); } }\n\n    ### Response:", "ground_truth": "Removes all petite beans of provided type. Bean name is not resolved from a type!\nInstead, all beans are iterated and only beans with equal types are removed.\n@see #removeBean(String)", "predict": "/**\r\n     * Removes all beans of the specified type from the application context.\r\n     *\r\n     * @param type the type of beans to remove\r\n     */\r\n    public void removeBean(final Class type) {\r\n        // collect bean names\r\n        Set<String> beanNames = new HashSet<>();\r\n        for (BeanDefinition def : beans.values()) {\r\n            if (def.type.equals(type)) {\r\n                beanNames.add(def.name);\r\n            }\r\n        }\r\n\r\n        // remove collected bean names\r\n        for (String beanName : beanNames) {\r\n            removeBean(beanName);\r\n        }\r\n    }"}, {"ID": 765, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] resolveBeanNamesForType(final Class type) { String[] beanNames = beanCollections.get(type); if (beanNames != null) { return beanNames; } ArrayList<String> list = new ArrayList<>(); for (Map.Entry<String, BeanDefinition> entry : beans.entrySet()) { BeanDefinition beanDefinition = entry.getValue(); if (ClassUtil.isTypeOf(beanDefinition.type, type)) { String beanName = entry.getKey(); list.add(beanName); } } if (list.isEmpty()) { beanNames = StringPool.EMPTY_ARRAY; } else { beanNames = list.toArray(new String[0]); } beanCollections.put(type, beanNames); return beanNames; }\n\n    ### Response:", "ground_truth": "Resolves bean names for give type.", "predict": "/**\n     * Resolve the names of beans that match the given type.\n     * <p>\n     * This method is used by the Spring container to find candidate bean names for a given type.\n     * The default implementation delegates to the {@link #getBeansOfType(Class)} method, but subclasses can override it to provide custom resolution logic.\n     * <p>\n     * Note that this method is designed to return bean names only, not actual instances of the corresponding beans.\n     * For a list of actual bean instances, use the {@link #getBeansOfType(Class)} method instead.\n     *\n     * @param type the type of the beans to match\n     * @return the names of the matching beans, or an empty array if none found\n     * @see #getBeansOfType(Class)\n     */\n    protected String[] resolveBeanNamesForType(final Class type) {\n        // ...\n    }"}, {"ID": 766, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Constructor constructor = null; if (paramTypes == null) { CtorDescriptor[] ctors = cd.getAllCtorDescriptors(); if (ctors != null && ctors.length > 0) { if (ctors.length > 1) { throw new PetiteException(ctors.length + \" suitable constructor found as injection point for: \" + beanDefinition.type.getName()); } constructor = ctors[0].getConstructor(); } } else { CtorDescriptor ctorDescriptor = cd.getCtorDescriptor(paramTypes, true); if (ctorDescriptor != null) { constructor = ctorDescriptor.getConstructor(); } } if (constructor == null) { throw new PetiteException(\"Constructor not found: \" + beanDefinition.type.getName()); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(constructor, references); beanDefinition.ctor = new CtorInjectionPoint(constructor, ref); }\n\n    ### Response:", "ground_truth": "Registers constructor injection point.\n\n@param beanName bean name\n@param paramTypes constructor parameter types, may be null\n@param references references for arguments", "predict": "/**\n     * Registers a new petite constructor injection point for the given bean name, parameter types, and references.\n     *\n     * @param beanName the name of the bean to register the injection point for\n     * @param paramTypes the parameter types of the constructor to inject, or null to inject all constructors\n     * @param references the references to inject into the constructor parameters, or null to use the default references\n     */\n    public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) {\n        // implementation omitted for brevity\n    }"}, {"ID": 767, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference); PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref); beanDefinition.addPropertyInjectionPoint(pip); }\n\n    ### Response:", "ground_truth": "Registers property injection point.\n\n@param beanName bean name\n@param property property name\n@param reference explicit injection reference, may be null", "predict": "/**\n     * Registers a new property injection point for the specified bean.\n     *\n     * @param beanName the name of the bean\n     * @param property the name of the property to inject\n     * @param reference the reference to inject\n     */\n    public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) {\n        // Implementation omitted for brevity\n    }"}, {"ID": 768, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteSetInjectionPoint(final String beanName, final String property) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor); beanDefinition.addSetInjectionPoint(sip); }\n\n    ### Response:", "ground_truth": "Registers set injection point.\n\n@param beanName bean name\n@param property set property name", "predict": "/**\r\n     * Registers a set injection point for the specified property of the specified bean.\r\n     *\r\n     * @param beanName the name of the bean\r\n     * @param property the name of the property\r\n     */\r\n    public void registerPetiteSetInjectionPoint(final String beanName, final String property) {\r\n        // Implementation omitted for brevity.\r\n    }"}, {"ID": 769, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Method method = null; if (arguments == null) { MethodDescriptor[] methods = cd.getAllMethodDescriptors(methodName); if (methods != null && methods.length > 0) { if (methods.length > 1) { throw new PetiteException(methods.length + \" suitable methods found as injection points for: \" + beanDefinition.type.getName() + '#' + methodName); } method = methods[0].getMethod(); } } else { MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md != null) { method = md.getMethod(); } } if (method == null) { throw new PetiteException(\"Method not found: \" + beanDefinition.type.getName() + '#' + methodName); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(method, references); MethodInjectionPoint mip = new MethodInjectionPoint(method, ref); beanDefinition.addMethodInjectionPoint(mip); }\n\n    ### Response:", "ground_truth": "Registers method injection point.\n\n@param beanName bean name\n@param methodName method name\n@param arguments method arguments, may be null\n@param references injection references", "predict": "/**\n     * Registers a new method-level injection point for the specified bean.\n     *\n     * @param beanName the name of the bean to register the injection point for\n     * @param methodName the name of the method to inject\n     * @param arguments the argument types of the method to inject (can be null)\n     * @param references the reference names to inject (can be null)\n     */\n    public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) {\n        // implementation omitted for brevity\n    }"}, {"ID": 770, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (initMethodNames == null) { initMethodNames = StringPool.EMPTY_ARRAY; } int total = initMethodNames.length; InitMethodPoint[] initMethodPoints = new InitMethodPoint[total]; int i; for (i = 0; i < initMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Init method not found: \" + beanDefinition.type.getName() + '#' + initMethodNames[i]); } initMethodPoints[i] = new InitMethodPoint(md.getMethod(), i, invocationStrategy); } beanDefinition.addInitMethodPoints(initMethodPoints); }\n\n    ### Response:", "ground_truth": "Registers init method.\n\n@param beanName bean name\n@param invocationStrategy moment of invocation\n@param initMethodNames init method names", "predict": "/**\n     * Registers the specified init methods with the given bean definition.\n     *\n     * @param beanName the name of the bean definition to register the init methods with\n     * @param invocationStrategy the invocation strategy to use for the init methods\n     * @param initMethodNames the names of the init methods to register\n     */\n    public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) {\n        BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);\n        ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);\n        if (initMethodNames == null) {\n            initMethodNames = StringPool.EMPTY_ARRAY;\n        }\n        int total = initMethodNames.length;\n        InitMethodPoint[] initMethodPoints = new InitMethodPoint[total];\n        int i;\n        for (i = 0; i < initMethodNames.length; i++) {\n            MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i"}, {"ID": 771, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (destroyMethodNames == null) { destroyMethodNames = StringPool.EMPTY_ARRAY; } int total = destroyMethodNames.length; DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total]; int i; for (i = 0; i < destroyMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Destroy method not found: \" + beanDefinition.type.getName() + '#' + destroyMethodNames[i]); } destroyMethodPoints[i] = new DestroyMethodPoint(md.getMethod()); } beanDefinition.addDestroyMethodPoints(destroyMethodPoints); }\n\n    ### Response:", "ground_truth": "Registers destroy method.\n\n@param beanName bean name\n@param destroyMethodNames destroy method names", "predict": "/**\n     * Registers the specified destroy methods with the given bean definition.\n     *\n     * @param beanName the name of the bean definition to register the destroy methods with\n     * @param destroyMethodNames the names of the destroy methods to register\n     */\n    public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) {\n        BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName);\n        ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type);\n        if (destroyMethodNames == null) {\n            destroyMethodNames = StringPool.EMPTY_ARRAY;\n        }\n        int total = destroyMethodNames.length;\n        DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total];\n        int i;\n        for (i = 0; i < destroyMethodNames.length; i++) {\n            MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true);\n            if (md == null) {\n                throw new"}, {"ID": 772, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) { BeanDefinition beanDefinition = lookupBeanDefinition(beanName); if (beanDefinition == null) { throw new PetiteException(\"Bean not found: \" + beanName); } Class beanType = beanDefinition.type; ClassDescriptor cd = ClassIntrospector.get().lookup(beanType); MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + methodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod()); providers.put(providerName, providerDefinition); }\n\n    ### Response:", "ground_truth": "Registers instance method provider.\n\n@param providerName provider name\n@param beanName bean name\n@param methodName instance method name\n@param arguments method argument types", "predict": "/**\r\n     * Registers a new petite provider for the specified bean.\r\n     * \r\n     * @param providerName the name of the provider\r\n     * @param beanName the name of the bean to provide\r\n     * @param methodName the name of the method to call on the bean\r\n     * @param arguments the argument types of the method\r\n     */\r\n    public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) {\r\n        BeanDefinition beanDefinition = lookupBeanDefinition(beanName);\r\n        if (beanDefinition == null) {\r\n            throw new PetiteException(\"Bean not found: \" + beanName);\r\n        }\r\n        Class beanType = beanDefinition.type;\r\n        ClassDescriptor cd = ClassIntrospector.get().lookup(beanType);\r\n        MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true);\r\n        if (md == null) {\r\n            throw new PetiteException(\"Provider method not found: \" + methodName);\r\n        }\r\n        ProviderDefinition providerDefinition = new ProviderDefinition(provider"}, {"ID": 773, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + staticMethodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod()); providers.put(providerName, providerDefinition); }\n\n    ### Response:", "ground_truth": "Registers static method provider.\n\n@param providerName provider name\n@param type class type\n@param staticMethodName static method name\n@param arguments method argument types", "predict": "/**\r\n     * Registers a provider method for a given type.\r\n     * \r\n     * @param providerName the name of the provider\r\n     * @param type the type of the provider\r\n     * @param staticMethodName the name of the static method to be used as a provider\r\n     * @param arguments the arguments of the provider method\r\n     */\r\n    public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) {\r\n        // Implementation omitted for brevity\r\n    }"}, {"ID": 774, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) { forEachBean(bd -> { if (ClassUtil.isTypeOf(bd.type, type)) { beanNameConsumer.accept(bd.name); } }); }\n\n    ### Response:", "ground_truth": "Iterates all beans that are of given type.", "predict": "/**\r\n     * Iterates over all beans of the specified type and calls the given consumer for each bean name.\r\n     *\r\n     * @param type the type of beans to iterate over\r\n     * @param beanNameConsumer the consumer to call for each bean name\r\n     */\r\n    public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) {\r\n        forEachBean(bd -> {\r\n            if (ClassUtil.isTypeOf(bd.type, type)) {\r\n                beanNameConsumer.accept(bd.name);\r\n            }\r\n        });\r\n    }"}, {"ID": 775, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void defineParameters(final Map<?, ?> properties) { for (Map.Entry<?, ?> entry : properties.entrySet()) { defineParameter(entry.getKey().toString(), entry.getValue()); } }\n\n    ### Response:", "ground_truth": "Defines many parameters at once.", "predict": "/**\r\n     * This method takes a map of properties and defines each property as a parameter in the current context.\r\n     * \r\n     * @param properties A map of properties to define as parameters.\r\n     */\r\n    public void defineParameters(final Map<?, ?> properties) {\r\n        for (Map.Entry<?, ?> entry : properties.entrySet()) {\r\n            defineParameter(entry.getKey().toString(), entry.getValue());\r\n        }\r\n    }"}, {"ID": 776, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object intercept(final ActionRequest actionRequest) throws Exception { printBefore(actionRequest); long startTime = System.currentTimeMillis(); Object result = null; try { result = actionRequest.invoke(); } catch (Exception ex) { result = \"<exception>\"; throw ex; } catch (Throwable th) { result = \"<throwable>\"; throw new Exception(th); } finally { long executionTime = System.currentTimeMillis() - startTime; printAfter(actionRequest, executionTime, result); } return result; }\n\n    ### Response:", "ground_truth": "Measure action invocation time.", "predict": "/**\r\n     * This method is used to intercept the action request and print the before and after information.\r\n     * \r\n     * @param actionRequest - The action request object.\r\n     * @return - The result of the action request.\r\n     * @throws Exception - If any exception occurs during the action request.\r\n     */\r\n    public Object intercept(final ActionRequest actionRequest) throws Exception {\r\n        printBefore(actionRequest);\r\n        long startTime = System.currentTimeMillis();\r\n        Object result = null;\r\n        try {\r\n            result = actionRequest.invoke();\r\n        } catch (Exception ex) {\r\n            result = \"<exception>\";\r\n            throw ex;\r\n        } catch (Throwable th) {\r\n            result = \"<throwable>\";\r\n            throw new Exception(th);\r\n        } finally {\r\n            long executionTime = System.currentTimeMillis() - startTime;\r\n            printAfter(actionRequest, executionTime, result);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 777, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int resolveJavaVersion(final int version) { final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber(); final int platformVersion = javaVersionNumber - 8 + 52; return version > platformVersion ? version : platformVersion; }\n\n    ### Response:", "ground_truth": "Resolves Java version from current version.", "predict": "/**\r\n     * This method takes in a Java version number and returns the corresponding platform version number.\r\n     * \r\n     * @param version The Java version number to be resolved.\r\n     * @return The corresponding platform version number.\r\n     */\r\n    public static int resolveJavaVersion(final int version) {\r\n        final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber();\r\n        final int platformVersion = javaVersionNumber - 8 + 52;\r\n        return version > platformVersion ? version : platformVersion;\r\n    }"}, {"ID": 778, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void pushInt(final MethodVisitor mv, final int value) { if (value <= 5) { mv.visitInsn(ICONST_0 + value); } else if (value <= Byte.MAX_VALUE) { mv.visitIntInsn(BIPUSH, value); } else { mv.visitIntInsn(SIPUSH, value); } }\n\n    ### Response:", "ground_truth": "Pushes int value in an optimal way.", "predict": "/**\r\n     * Pushes an integer value onto the operand stack.\r\n     * \r\n     * @param mv\r\n     *            The current method visitor.\r\n     * @param value\r\n     *            The integer value to push.\r\n     */\r\n    public static void pushInt(final MethodVisitor mv, final int value) {\r\n        if (value <= 5) {\r\n            mv.visitInsn(ICONST_0 + value);\r\n        } else if (value <= Byte.MAX_VALUE) {\r\n            mv.visitIntInsn(BIPUSH, value);\r\n        } else {\r\n            mv.visitIntInsn(SIPUSH, value);\r\n        }\r\n    }"}, {"ID": 779, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) { if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) { throw new ProxettaException(\"Invalid argument index: \" + argIndex); } }\n\n    ### Response:", "ground_truth": "Validates argument index.", "predict": "/**\r\n     * Checks if the given argument index is valid for the given method.\r\n     *\r\n     * @param methodInfo the method to check\r\n     * @param argIndex the argument index to check\r\n     * @throws ProxettaException if the argument index is invalid\r\n     */\r\n    public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) {\r\n        if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) {\r\n            throw new ProxettaException(\"Invalid argument index: \" + argIndex);\r\n        }\r\n    }"}, {"ID": 780, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String adviceFieldName(final String name, final int index) { return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index; }\n\n    ### Response:", "ground_truth": "Builds advice field name.", "predict": "/**\r\n     * Generates a field name for a proxied field based on the original field name and index.\r\n     *\r\n     * @param name the original field name\r\n     * @param index the index of the proxied field\r\n     * @return the generated field name\r\n     */\r\n    public static String adviceFieldName(final String name, final int index) {\r\n        return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index;\r\n    }"}, {"ID": 781, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String adviceMethodName(final String name, final int index) { return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index; }\n\n    ### Response:", "ground_truth": "Builds advice method name.", "predict": "/**\r\n     * This method generates a unique method name for a proxied method.\r\n     * \r\n     * @param name The name of the original method.\r\n     * @param index The index of the method in the class.\r\n     * @return A unique method name for the proxied method.\r\n     */\r\n    public static String adviceMethodName(final String name, final int index) {\r\n        return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index;\r\n    }"}, {"ID": 782, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { mv.visitVarInsn(ALOAD, 0); for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKESPECIAL call.", "predict": "/**\r\n     * Loads the arguments of a method onto the operand stack.\r\n     * \r\n     * @param mv\r\n     *            the method visitor\r\n     * @param methodInfo\r\n     *            the method info object\r\n     */\r\n    public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {\r\n        mv.visitVarInsn(ALOAD, 0);\r\n        for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) {\r\n            loadMethodArgument(mv, methodInfo, i);\r\n        }\r\n    }"}, {"ID": 783, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 0; i < methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKESTATIC call.", "predict": "/**\r\n     * Loads the arguments of a static method onto the operand stack.\r\n     * \r\n     * @param mv\r\n     *            the method visitor\r\n     * @param methodInfo\r\n     *            the method info object\r\n     */\r\n    public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {\r\n        for (int i = 0; i < methodInfo.getArgumentsCount(); i++) {\r\n            loadMethodArgument(mv, methodInfo, i);\r\n        }\r\n    }"}, {"ID": 784, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } }\n\n    ### Response:", "ground_truth": "Loads all method arguments before INVOKEVIRTUAL call.", "predict": "/**\r\n     * Loads the arguments of a virtual method onto the operand stack.\r\n     * \r\n     * @param mv\r\n     *            the method visitor\r\n     * @param methodInfo\r\n     *            the method info object\r\n     */\r\n    public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) {\r\n        for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) {\r\n            loadMethodArgument(mv, methodInfo, i);\r\n        }\r\n    }"}, {"ID": 785, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ILOAD, offset); break; case 'J': mv.visitVarInsn(LLOAD, offset); break; case 'F': mv.visitVarInsn(FLOAD, offset); break; case 'D': mv.visitVarInsn(DLOAD, offset); break; default: mv.visitVarInsn(ALOAD, offset); } }\n\n    ### Response:", "ground_truth": "Loads one argument. Index is 1-based. No conversion occurs.", "predict": "/**\r\n     * Loads the argument at the given index onto the stack using the appropriate load instruction based on the argument type.\r\n     *\r\n     * @param mv the method visitor to use for loading the argument\r\n     * @param methodInfo the method info object containing information about the method being visited\r\n     * @param index the index of the argument to load\r\n     */\r\n    public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) {\r\n        int offset = methodInfo.getArgumentOffset(index);\r\n        int type = methodInfo.getArgument(index).getOpcode();\r\n        switch (type) {\r\n            case 'V':\r\n                break;\r\n            case 'B':\r\n            case 'C':\r\n            case 'S':\r\n            case 'I':\r\n            case 'Z':\r\n                mv.visitVarInsn(ILOAD, offset);\r\n                break;\r\n            case 'J':\r\n                mv.visitVarInsn(LLOAD, offset);\r\n                break;\r\n            case 'F':\r\n                mv.visitVarInsn(FLOAD, offset);\r\n                break;"}, {"ID": 786, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ISTORE, offset); break; case 'J': mv.visitVarInsn(LSTORE, offset); break; case 'F': mv.visitVarInsn(FSTORE, offset); break; case 'D': mv.visitVarInsn(DSTORE, offset); break; default: mv.visitVarInsn(ASTORE, offset); } }\n\n    ### Response:", "ground_truth": "Stores one argument. Index is 1-based. No conversion occurs.", "predict": "/**\r\n     * Stores the value of a method argument on the stack.\r\n     * \r\n     * @param mv\r\n     *            the method visitor\r\n     * @param methodInfo\r\n     *            the method info object\r\n     * @param index\r\n     *            the index of the argument to store\r\n     */\r\n    public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) {\r\n        int offset = methodInfo.getArgumentOffset(index);\r\n        int type = methodInfo.getArgument(index).getOpcode();\r\n        switch (type) {\r\n            case 'V':\r\n                break;\r\n            case 'B':\r\n            case 'C':\r\n            case 'S':\r\n            case 'I':\r\n            case 'Z':\r\n                mv.visitVarInsn(ISTORE, offset);\r\n                break;\r\n            case 'J':\r\n                mv.visitVarInsn(LSTORE, offset);\r\n                break;\r\n            case 'F':\r\n                mv.visitVarInsn(FSTORE, offset);\r\n                break;\r\n            case 'D':\r\n                mv.visitVarInsn(DSTORE"}, {"ID": 787, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) { varOffset += methodInfo.getAllArgumentsSize(); switch (methodInfo.getReturnType().getOpcode()) { case 'V': mv.visitInsn(ACONST_NULL); break; case 'B': AsmUtil.valueOfByte(mv); break; case 'C': AsmUtil.valueOfCharacter(mv); break; case 'S': AsmUtil.valueOfShort(mv); break; case 'I': AsmUtil.valueOfInteger(mv); break; case 'Z': AsmUtil.valueOfBoolean(mv); break; case 'J': AsmUtil.valueOfLong(mv); break; case 'F': AsmUtil.valueOfFloat(mv); break; case 'D': AsmUtil.valueOfDouble(mv); break; } }\n\n    ### Response:", "ground_truth": "Prepares return value.", "predict": "/**\n     * Generates the code to prepare the return value of a method.\n     *\n     * @param mv the method visitor\n     * @param methodInfo the method info object\n     * @param varOffset the offset of the first local variable\n     */\n    public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) {\n        varOffset += methodInfo.getAllArgumentsSize();\n        switch (methodInfo.getReturnType().getOpcode()) {\n            case 'V':\n                mv.visitInsn(ACONST_NULL);\n                break;\n            case 'B':\n                AsmUtil.valueOfByte(mv);\n                break;\n            case 'C':\n                AsmUtil.valueOfCharacter(mv);\n                break;\n            case 'S':\n                AsmUtil.valueOfShort(mv);\n                break;\n            case 'I':\n                AsmUtil.valueOfInteger(mv);\n                break;\n            case 'Z':\n                AsmUtil.valueOfBoolean(mv);\n                break;\n            case 'J':\n                AsmUtil."}, {"ID": 788, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) { return new StringBand(7) .append(access) .append(COLON) .append(description) .append(StringPool.UNDERSCORE) .append(className) .append(StringPool.HASH) .append(methodName) .toString(); }\n\n    ### Response:", "ground_truth": "Creates unique key for method signatures map.", "predict": "/**\r\n     * Generates a unique key for a method signature.\r\n     *\r\n     * @param access the access level of the method (e.g. public, private, protected)\r\n     * @param methodName the name of the method\r\n     * @param description the method signature description (e.g. (int, String)void)\r\n     * @param className the name of the class the method belongs to\r\n     * @return a unique key for the method signature\r\n     */\r\n    public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) {\r\n        return new StringBand(7)\r\n                .append(access)\r\n                .append(COLON)\r\n                .append(description)\r\n                .append(StringPool.UNDERSCORE)\r\n                .append(className)\r\n                .append(StringPool.HASH)\r\n                .append(methodName)\r\n                .toString();\r\n    }"}, {"ID": 789, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void newArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitIntInsn(NEWARRAY, T_INT); return; } if (componentType == long.class) { mv.visitIntInsn(NEWARRAY, T_LONG); return; } if (componentType == float.class) { mv.visitIntInsn(NEWARRAY, T_FLOAT); return; } if (componentType == double.class) { mv.visitIntInsn(NEWARRAY, T_DOUBLE); return; } if (componentType == byte.class) { mv.visitIntInsn(NEWARRAY, T_BYTE); return; } if (componentType == short.class) { mv.visitIntInsn(NEWARRAY, T_SHORT); return; } if (componentType == boolean.class) { mv.visitIntInsn(NEWARRAY, T_BOOLEAN); return; } if (componentType == char.class) { mv.visitIntInsn(NEWARRAY, T_CHAR); return; } mv.visitTypeInsn(ANEWARRAY, AsmUtil.typeToSignature(componentType)); }\n\n    ### Response:", "ground_truth": "Creates new array.", "predict": "/**\n     * Generates the appropriate bytecode instructions to create a new array of the given component type.\n     *\n     * @param mv the method visitor to which the instructions should be added\n     * @param componentType the type of the array elements\n     */\n    public static void newArray(final MethodVisitor mv, final Class componentType) {\n        if (componentType == int.class) {\n            mv.visitIntInsn(NEWARRAY, T_INT);\n            return;\n        }\n        if (componentType == long.class) {\n            mv.visitIntInsn(NEWARRAY, T_LONG);\n            return;\n        }\n        if (componentType == float.class) {\n            mv.visitIntInsn(NEWARRAY, T_FLOAT);\n            return;\n        }\n        if (componentType == double.class) {\n            mv.visitIntInsn(NEWARRAY, T_DOUBLE);\n            return;\n        }\n        if (componentType == byte.class) {\n            mv.visitIntInsn(NEWAR"}, {"ID": 790, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeIntoArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitInsn(IASTORE); return; } if (componentType == long.class) { mv.visitInsn(LASTORE); return; } if (componentType == float.class) { mv.visitInsn(FASTORE); return; } if (componentType == double.class) { mv.visitInsn(DASTORE); return; } if (componentType == byte.class) { mv.visitInsn(BASTORE); return; } if (componentType == short.class) { mv.visitInsn(SASTORE); return; } if (componentType == boolean.class) { mv.visitInsn(BASTORE); return; } if (componentType == char.class) { mv.visitInsn(CASTORE); return; } mv.visitInsn(AASTORE); }\n\n    ### Response:", "ground_truth": "Stores element on stack into an array.", "predict": "/**\r\n * Stores the value on the top of the stack into an array of the specified component type.\r\n *\r\n * @param mv the method visitor\r\n * @param componentType the component type of the array\r\n */\r\npublic static void storeIntoArray(final MethodVisitor mv, final Class componentType) {\r\n    if (componentType == int.class) {\r\n        mv.visitInsn(IASTORE);\r\n        return;\r\n    }\r\n    if (componentType == long.class) {\r\n        mv.visitInsn(LASTORE);\r\n        return;\r\n    }\r\n    if (componentType == float.class) {\r\n        mv.visitInsn(FASTORE);\r\n        return;\r\n    }\r\n    if (componentType == double.class) {\r\n        mv.visitInsn(DASTORE);\r\n        return;\r\n    }\r\n    if (componentType == byte.class) {\r\n        mv.visitInsn(BASTORE);\r\n        return;\r\n    }\r\n    if (componentType == short.class) {\r\n        mv.visitInsn(SASTORE);\r\n        return;"}, {"ID": 791, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String extractEncoding(final String contentType, String defaultEncoding) { String encoding = extractEncoding(contentType); if (encoding == null) { if (defaultEncoding == null) { defaultEncoding = JoddCore.encoding; } encoding = defaultEncoding; } return encoding; }\n\n    ### Response:", "ground_truth": "Extracts encoding from a given content type.\n\n@param contentType     content type.\n@param defaultEncoding Default encoding to be used if extract returns {@code null}.\nIf defaultEncoding is {@code null}, {@link JoddCore#encoding} will be used.\n@return Encoding from the content type.\n@see #extractEncoding(String)", "predict": "/**\r\n     * Extracts the encoding from the content type header. If the encoding is not found, it returns the default encoding.\r\n     *\r\n     * @param contentType the content type header\r\n     * @param defaultEncoding the default encoding to use if the encoding is not found in the content type header\r\n     * @return the encoding found in the content type header or the default encoding\r\n     */\r\n    public static String extractEncoding(final String contentType, String defaultEncoding) {\r\n        String encoding = extractEncoding(contentType);\r\n        if (encoding == null) {\r\n            if (defaultEncoding == null) {\r\n                defaultEncoding = JoddCore.encoding;\r\n            }\r\n            encoding = defaultEncoding;\r\n        }\r\n        return encoding;\r\n    }"}, {"ID": 792, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isEmptyFlags(Flags flags) { if (flags == null) return true; Flags.Flag[] systemFlags = flags.getSystemFlags(); if (systemFlags != null && systemFlags.length > 0) { return false; } String[] userFlags = flags.getUserFlags(); if (userFlags != null && userFlags.length > 0) { return false; } return true; }\n\n    ### Response:", "ground_truth": "Check whether flags is a empty flags\n@param flags a flags of message to check\n@return whether the flags is empty", "predict": "/**\r\n     * Checks if the given flags object is empty or not.\r\n     *\r\n     * @param flags the flags object to check\r\n     * @return true if the flags object is empty, false otherwise\r\n     */\r\n    public static boolean isEmptyFlags(Flags flags) {\r\n        if (flags == null) {\r\n            return true;\r\n        }\r\n        Flags.Flag[] systemFlags = flags.getSystemFlags();\r\n        if (systemFlags != null && systemFlags.length > 0) {\r\n            return false;\r\n        }\r\n        String[] userFlags = flags.getUserFlags();\r\n        if (userFlags != null && userFlags.length > 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }"}, {"ID": 793, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveAuthBearerToken(final HttpServletRequest request) { String header = request.getHeader(HEADER_AUTHORIZATION); if (header == null) { return null; } int ndx = header.indexOf(\"Bearer \"); if (ndx == -1) { return null; } return header.substring(ndx + 7).trim(); }\n\n    ### Response:", "ground_truth": "Returns Bearer token.", "predict": "/**\r\n     * This method is used to resolve the bearer token from the authorization header of the request.\r\n     * \r\n     * @param request\r\n     *            The HTTP request object.\r\n     * @return The resolved bearer token.\r\n     */\r\n    public static String resolveAuthBearerToken(final HttpServletRequest request) {\r\n        String header = request.getHeader(HEADER_AUTHORIZATION);\r\n        if (header == null) {\r\n            return null;\r\n        }\r\n        int ndx = header.indexOf(\"Bearer \");\r\n        if (ndx == -1) {\r\n            return null;\r\n        }\r\n        return header.substring(ndx + 7).trim();\r\n    }"}, {"ID": 794, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException { resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"'); resp.sendError(HttpServletResponse.SC_UNAUTHORIZED); }\n\n    ### Response:", "ground_truth": "Sends correct headers to require basic authentication for the given realm.", "predict": "/**\r\n     * Sets the WWW-Authenticate header to prompt the user for authentication.\r\n     *\r\n     * @param resp the response object\r\n     * @param realm the authentication realm\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException {\r\n        resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"');\r\n        resp.sendError(HttpServletResponse.SC_UNAUTHORIZED);\r\n    }"}, {"ID": 795, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); } prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length()); }\n\n    ### Response:", "ground_truth": "Prepares response for file download with provided mime type.", "predict": "/**\r\n     * Prepares the response for downloading a file.\r\n     * \r\n     * @param response\r\n     *            the HTTP response object\r\n     * @param file\r\n     *            the file to be downloaded\r\n     * @param mimeType\r\n     *            the MIME type of the file\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) throws IOException {\r\n        if (!file.exists()) {\r\n            throw new IllegalArgumentException(\"File not found: \" + file);\r\n        }\r\n        if (file.length() > Integer.MAX_VALUE) {\r\n            throw new IllegalArgumentException(\"File too big: \" + file);\r\n        }\r\n        prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length());\r\n    }"}, {"ID": 796, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) { if ((mimeType == null) && (fileName != null)) { String extension = FileNameUtil.getExtension(fileName); mimeType = MimeTypes.getMimeType(extension); } if (mimeType != null) { response.setContentType(mimeType); } if (fileSize >= 0) { response.setContentLength(fileSize); } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if (fileName != null) { String name = FileNameUtil.getName(fileName); String encodedFileName = URLCoder.encode(name); response.setHeader(CONTENT_DISPOSITION, \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName); } }\n\n    ### Response:", "ground_truth": "null\n@param fileSize if less then 0 it will be ignored", "predict": "/**\r\n     * Prepares the response for downloading a file.\r\n     * \r\n     * @param response\r\n     *            the HTTP response object\r\n     * @param fileName\r\n     *            the name of the file to be downloaded\r\n     * @param mimeType\r\n     *            the MIME type of the file to be downloaded\r\n     * @param fileSize\r\n     *            the size of the file to be downloaded\r\n     */\r\n    public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 797, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) { Cookie[] cookies = request.getCookies(); if (cookies == null) { return null; } ArrayList<Cookie> list = new ArrayList<>(cookies.length); for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { list.add(cookie); } } if (list.isEmpty()) { return null; } return list.toArray(new Cookie[0]); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * This method retrieves all cookies with the given name from the given HTTP request.\r\n     * \r\n     * @param request\r\n     *            The HTTP request from which to retrieve the cookies.\r\n     * @param cookieName\r\n     *            The name of the cookie to retrieve.\r\n     * @return An array of cookies with the given name, or null if no cookies with that name were found.\r\n     */\r\n    public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) {\r\n        Cookie[] cookies = request.getCookies();\r\n        if (cookies == null) {\r\n            return null;\r\n        }\r\n        ArrayList<Cookie> list = new ArrayList<>(cookies.length);\r\n        for (Cookie cookie : cookies) {\r\n            if (cookie.getName().equals(cookieName)) {\r\n                list.add(cookie);\r\n            }\r\n        }\r\n        if (list.isEmpty()) {\r\n            return null;\r\n        }\r\n        return list.toArray(new Cookie[0]);\r\n    }"}, {"ID": 798, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException { BufferedReader buff = request.getReader(); StringWriter out = new StringWriter(); StreamUtil.copy(buff, out); return out.toString(); }\n\n    ### Response:", "ground_truth": "Reads HTTP request body using the request reader. Once body is read,\nit cannot be read again!", "predict": "/**\r\n     * Reads the request body from the input stream of the given request and returns it as a string.\r\n     *\r\n     * @param request the HTTP request\r\n     * @return the request body as a string\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException {\r\n        BufferedReader buff = request.getReader();\r\n        StringWriter out = new StringWriter();\r\n        StreamUtil.copy(buff, out);\r\n        return out.toString();\r\n    }"}, {"ID": 799, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException { String charEncoding = request.getCharacterEncoding(); if (charEncoding == null) { charEncoding = JoddCore.encoding; } CharArrayWriter charArrayWriter = new CharArrayWriter(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding)); StreamUtil.copy(bufferedReader, charArrayWriter); } else { return StringPool.EMPTY; } } finally { StreamUtil.close(bufferedReader); } return charArrayWriter.toString(); }\n\n    ### Response:", "ground_truth": "Reads HTTP request body using the request stream. Once body is read,\nit cannot be read again!", "predict": "/**\r\n     * Reads the request body from the input stream of the given request.\r\n     *\r\n     * @param request the HTTP request\r\n     * @return the request body as a string\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException {\r\n        String charEncoding = request.getCharacterEncoding();\r\n        if (charEncoding == null) {\r\n            charEncoding = JoddCore.encoding;\r\n        }\r\n        CharArrayWriter charArrayWriter = new CharArrayWriter();\r\n        BufferedReader bufferedReader = null;\r\n        try {\r\n            InputStream inputStream = request.getInputStream();\r\n            if (inputStream != null) {\r\n                bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding));\r\n                StreamUtil.copy(bufferedReader, charArrayWriter);\r\n            } else {\r\n                return StringPool.EMPTY;\r\n            }\r\n        } finally {\r\n            StreamUtil.close(bufferedReader);\r\n        }\r\n        return charArrayWriter.toString();\r\n    }"}, {"ID": 800, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) { String ctxPath = getContextPath(pageContext); HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); request.setAttribute(contextPathVariableName, ctxPath); ServletContext servletContext = pageContext.getServletContext(); servletContext.setAttribute(contextPathVariableName, ctxPath); }\n\n    ### Response:", "ground_truth": "Stores context path in server context and request scope.", "predict": "/**\r\n     * Stores the context path of the current web application in the specified request attribute and servlet context attribute.\r\n     * \r\n     * @param pageContext the page context\r\n     * @param contextPathVariableName the name of the request attribute and servlet context attribute to store the context path in\r\n     */\r\n    public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) {\r\n        String ctxPath = getContextPath(pageContext);\r\n        HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\r\n        request.setAttribute(contextPathVariableName, ctxPath);\r\n        ServletContext servletContext = pageContext.getServletContext();\r\n        servletContext.setAttribute(contextPathVariableName, ctxPath);\r\n    }"}, {"ID": 801, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) { String ctxPath = getContextPath(servletContext); servletContext.setAttribute(contextPathVariableName, ctxPath); }\n\n    ### Response:", "ground_truth": "Stores context path in page context and request scope.", "predict": "/**\r\n     * Stores the context path of the given {@link ServletContext} in the attribute with the given name.\r\n     * \r\n     * @param servletContext the {@link ServletContext} to retrieve the context path from\r\n     * @param contextPathVariableName the name of the attribute to store the context path in\r\n     */\r\n    public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) {\r\n        String ctxPath = getContextPath(servletContext);\r\n        servletContext.setAttribute(contextPathVariableName, ctxPath);\r\n    }"}, {"ID": 802, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isGetParameter(final HttpServletRequest request, String name) { name = URLCoder.encodeQueryParam(name) + '='; String query = request.getQueryString(); String[] nameValuePairs = StringUtil.splitc(query, '&'); for (String nameValuePair : nameValuePairs) { if (nameValuePair.startsWith(name)) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Checks if some parameter is in GET parameters.", "predict": "/**\r\n     * This method checks if the given parameter name is present in the request's query string.\r\n     * \r\n     * @param request\r\n     *            The HTTP request object.\r\n     * @param name\r\n     *            The parameter name to check for.\r\n     * @return True if the parameter name is present in the query string, false otherwise.\r\n     */\r\n    public boolean isGetParameter(final HttpServletRequest request, String name) {\r\n        name = URLCoder.encodeQueryParam(name) + '=';\r\n        String query = request.getQueryString();\r\n        String[] nameValuePairs = StringUtil.splitc(query, '&');\r\n        for (String nameValuePair : nameValuePairs) {\r\n            if (nameValuePair.startsWith(name)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 803, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] prepareParameters( final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) { int emptyCount = 0; int total = paramValues.length; for (int i = 0; i < paramValues.length; i++) { String paramValue = paramValues[i]; if (paramValue == null) { emptyCount++; continue; } if (paramValue.length() == 0) { emptyCount++; if (treatEmptyParamsAsNull) { paramValue = null; } } paramValues[i] = paramValue; } if ((ignoreEmptyRequestParams) && (emptyCount == total)) { return null; } } return paramValues; }\n\n    ### Response:", "ground_truth": "Prepares parameters for further processing.\n@param paramValues\tstring array of param values\n@param treatEmptyParamsAsNull\tempty parameters should be treated as null\n@param ignoreEmptyRequestParams\tif all parameters are empty, return null", "predict": "/**\r\n     * This method prepares the parameter values for a request.\r\n     * \r\n     * @param paramValues\r\n     *            The parameter values to be prepared.\r\n     * @param treatEmptyParamsAsNull\r\n     *            A boolean flag indicating whether to treat empty parameter values as null.\r\n     * @param ignoreEmptyRequestParams\r\n     *            A boolean flag indicating whether to ignore empty request parameters.\r\n     * @return The prepared parameter values.\r\n     */\r\n    public static String[] prepareParameters(final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) {\r\n        if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) {\r\n            int emptyCount = 0;\r\n            int total = paramValues.length;\r\n            for (int i = 0; i < paramValues.length; i++) {\r\n                String paramValue = paramValues[i];\r\n                if (paramValue == null) {\r\n                    emptyCount++;\r\n                    continue;\r\n                }\r\n                if (paramValue.length() == 0) {\r\n                    empty"}, {"ID": 804, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyParamsToAttributes( final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { Enumeration paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues == null) { continue; } servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } // multipart if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } FileUpload[] paramValues = multipartRequest.getFiles(paramName); servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } }\n\n    ### Response:", "ground_truth": "Copies all request parameters to attributes.", "predict": "/**\r\n     * Copies request parameters to attributes of the given request object.\r\n     * \r\n     * @param servletRequest\r\n     *            the request object to copy parameters to\r\n     * @param treatEmptyParamsAsNull\r\n     *            whether to treat empty parameters as null\r\n     * @param ignoreEmptyRequestParams\r\n     *            whether to ignore empty request parameters\r\n     */\r\n    public static void copyParamsToAttributes(final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) {\r\n        Enumeration paramNames = servletRequest.getParameterNames();\r\n        while (paramNames.hasMoreElements()) {\r\n            String paramName = (String) paramNames.nextElement();\r\n            if (servletRequest.getAttribute(paramName) != null) {\r\n                continue;\r\n            }\r\n            String[] paramValues = servletRequest.getParameterValues(paramName);\r\n            paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams);\r\n            if (paramValues == null) {\r\n                continue;\r\n            }\r\n            servletRequest.setAttribute(paramName, paramValues"}, {"ID": 805, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void invokeBody(final JspFragment body) throws JspException { if (body == null) { return; } try { body.invoke(null); } catch (IOException ioex) { throw new JspException(\"Tag body failed\", ioex); } }\n\n    ### Response:", "ground_truth": "Invokes tag body.", "predict": "/**\r\n     * Invokes the body of the tag.\r\n     * \r\n     * @param body the JspFragment to be invoked\r\n     * @throws JspException if the body invocation fails\r\n     */\r\n    public static void invokeBody(final JspFragment body) throws JspException;"}, {"ID": 806, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] renderBody(final JspFragment body) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter(); invokeBody(body, writer); return writer.toCharArray(); }\n\n    ### Response:", "ground_truth": "Renders tag body to char array.", "predict": "/**\r\n     * Renders the body of the JSP element and returns the result as a character array.\r\n     * \r\n     * @param body the JSP fragment to be rendered\r\n     * @return the rendered body as a character array\r\n     * @throws JspException if an error occurs during rendering\r\n     */\r\n    public static char[] renderBody(final JspFragment body) throws JspException {\r\n        FastCharArrayWriter writer = new FastCharArrayWriter();\r\n        invokeBody(body, writer);\r\n        return writer.toCharArray();\r\n    }"}, {"ID": 807, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String renderBodyToString(final JspFragment body) throws JspException { char[] result = renderBody(body); return new String(result); }\n\n    ### Response:", "ground_truth": "Renders tag body to string.\n@see #renderBody(javax.servlet.jsp.tagext.JspFragment)", "predict": "/**\r\n     * Renders the body of the JSP fragment to a character array and returns the resulting string.\r\n     * \r\n     * @param body the JSP fragment to render\r\n     * @return the resulting string\r\n     * @throws JspException if an error occurs during rendering\r\n     */\r\n    public static String renderBodyToString(final JspFragment body) throws JspException {\r\n        char[] result = renderBody(body);\r\n        return new String(result);\r\n    }"}, {"ID": 808, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) { for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) { if (invocationStrategy != initMethod.invocationStrategy) { continue; } try { initMethod.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid init method: \" + initMethod, ex); } } }\n\n    ### Response:", "ground_truth": "Invokes init methods.", "predict": "/**\r\n     * Invokes the init methods of the bean using the given invocation strategy.\r\n     *\r\n     * @param invocationStrategy the invocation strategy to use\r\n     */\r\n    public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) {\r\n        for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) {\r\n            if (invocationStrategy != initMethod.invocationStrategy) {\r\n                continue;\r\n            }\r\n            try {\r\n                initMethod.method.invoke(bean);\r\n            } catch (Exception ex) {\r\n                throw new PetiteException(\"Invalid init method: \" + initMethod, ex);\r\n            }\r\n        }\r\n    }"}, {"ID": 809, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void callDestroyMethods() { for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) { try { destroyMethodPoint.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex); } } }\n\n    ### Response:", "ground_truth": "Calls destroy methods on given BeanData. Destroy methods are called\nwithout any order.", "predict": "/**\r\n     * Calls the destroy methods of the bean.\r\n     */\r\n    public void callDestroyMethods() {\r\n        for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) {\r\n            try {\r\n                destroyMethodPoint.method.invoke(bean);\r\n            } catch (Exception ex) {\r\n                throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex);\r\n            }\r\n        }\r\n    }"}, {"ID": 810, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object newBeanInstance() { if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) { throw new PetiteException(\"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition.type.getName()); } int paramNo = beanDefinition.ctor.references.length; Object[] args = new Object[paramNo]; // wiring if (beanDefinition.wiringMode != WiringMode.NONE) { for (int i = 0; i < paramNo; i++) { args[i] = pc.getBean(beanDefinition.ctor.references[i]); if (args[i] == null) { if ((beanDefinition.wiringMode == WiringMode.STRICT)) { throw new PetiteException( \"Wiring constructor failed. References '\" + beanDefinition.ctor.references[i] + \"' not found for constructor: \" + beanDefinition.ctor.constructor); } } } } // create instance final Object bean; try { bean = beanDefinition.ctor.constructor.newInstance(args); } catch (Exception ex) { throw new PetiteException(\"Failed to create new bean instance '\" + beanDefinition.type.getName() + \"' using constructor: \" + beanDefinition.ctor.constructor, ex); } return bean; }\n\n    ### Response:", "ground_truth": "Creates a new instance.", "predict": "/**\n     * Creates a new instance of the bean based on the constructor injection point.\n     * If wiring is enabled, it will inject the dependencies into the constructor.\n     *\n     * @return the new instance of the bean\n     * @throws PetiteException if the bean cannot be created or wired\n     */\n    public Object newBeanInstance() {\n        // implementation goes here\n    }"}, {"ID": 811, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) { if (beanDefinition.name == null) { return; } if (implicitParamInjection) { // implicit final int len = beanDefinition.name.length() + 1; for (final String param : beanDefinition.params) { final Object value = paramManager.get(param); final String destination = param.substring(len); try { BeanUtil.declared.setProperty(bean, destination, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition.name, ex); } } } // explicit for (final ValueInjectionPoint pip : beanDefinition.values) { final String value = paramManager.parseKeyTemplate(pip.valueTemplate); try { BeanUtil.declared.setProperty(bean, pip.property, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set value for: '\" + pip.valueTemplate + \"' to bean: \" + beanDefinition.name, ex); } } }\n\n    ### Response:", "ground_truth": "Injects all parameters.", "predict": "/**\n     * Injects parameters and values into the given bean instance.\n     *\n     * @param paramManager the parameter manager to use for resolving parameter values\n     * @param implicitParamInjection whether to use implicit parameter injection or explicit value injection\n     */\n    public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) {\n        // implementation omitted for brevity\n    }"}, {"ID": 812, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"UnusedDeclaration\"}) public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) { return actionPath; }\n\n    ### Response:", "ground_truth": "Rewrites action path.", "predict": "/**\r\n     * This method rewrites the action path based on the HTTP method.\r\n     * \r\n     * @param servletRequest\r\n     *            The HTTP request object.\r\n     * @param actionPath\r\n     *            The original action path.\r\n     * @param httpMethod\r\n     *            The HTTP method used for the request.\r\n     * @return The rewritten action path.\r\n     */\r\n    public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) {\r\n        return actionPath;\r\n    }"}, {"ID": 813, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addHeader(final String name, final String value) { List<String> valuesList = super.getAll(name); if (valuesList.isEmpty()) { super.add(name, value); return; } super.remove(name); valuesList.add(value); super.addAll(name, valuesList); }\n\n    ### Response:", "ground_truth": "Adds new header value. If existing value exist, it will be removed\nso the store the new key value.", "predict": "/**\r\n     * Adds a new header with the specified name and value to the request. If a header with the same name already exists, the new value is added to the existing header.\r\n     * \r\n     * @param name the name of the header to add\r\n     * @param value the value of the header to add\r\n     */\r\n    public void addHeader(final String name, final String value) {\r\n        List<String> valuesList = super.getAll(name);\r\n        if (valuesList.isEmpty()) {\r\n            super.add(name, value);\r\n            return;\r\n        }\r\n        super.remove(name);\r\n        valuesList.add(value);\r\n        super.addAll(name, valuesList);\r\n    }"}, {"ID": 814, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) { String realValue = value; if (append || appendDuplicateProps) { PropsEntry pv = map.get(key); if (pv != null) { realValue = pv.value + APPEND_SEPARATOR + realValue; } } PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); }\n\n    ### Response:", "ground_truth": "Puts key-value pair into the map, with respect of appending duplicate properties", "predict": "/**\r\n     * Adds a new property to the map.\r\n     * \r\n     * @param profile the profile name\r\n     * @param map the map to add the property to\r\n     * @param key the property key\r\n     * @param value the property value\r\n     * @param append whether to append to existing values\r\n     */\r\n    protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) {\r\n        String realValue = value;\r\n        if (append || appendDuplicateProps) {\r\n            PropsEntry pv = map.get(key);\r\n            if (pv != null) {\r\n                realValue = pv.value + APPEND_SEPARATOR + realValue;\r\n            }\r\n        }\r\n        PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); }"}, {"ID": 815, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void putBaseProperty(final String key, final String value, final boolean append) { put(null, baseProperties, key, value, append); }\n\n    ### Response:", "ground_truth": "Adds base property.", "predict": "/**\r\n     * Adds or updates a property in the base properties of the resource.\r\n     * \r\n     * @param key the key of the property to add or update\r\n     * @param value the value of the property to add or update\r\n     * @param append true to append the value to any existing value for the property, false to overwrite any existing value\r\n     */\r\n    public void putBaseProperty(final String key, final String value, final boolean append) {\r\n        put(null, baseProperties, key, value, append);\r\n    }"}, {"ID": 816, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void putProfileProperty(final String key, final String value, final String profile, final boolean append) { Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>()); put(profile, map, key, value, append); }\n\n    ### Response:", "ground_truth": "Adds profile property.", "predict": "/**\r\n     * Adds or updates a property for a given profile.\r\n     * \r\n     * @param key the key of the property to add or update\r\n     * @param value the value of the property to add or update\r\n     * @param profile the profile to add or update the property for\r\n     * @param append whether to append the value to an existing property or overwrite it\r\n     */\r\n    public void putProfileProperty(final String key, final String value, final String profile, final boolean append) {\r\n        Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>());\r\n        put(profile, map, key, value, append);\r\n    }"}, {"ID": 817, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropsEntry getProfileProperty(final String profile, final String key) { final Map<String, PropsEntry> profileMap = profileProperties.get(profile); if (profileMap == null) { return null; } return profileMap.get(key); }\n\n    ### Response:", "ground_truth": "Returns profile property.", "predict": "/**\r\n     * Retrieves the value of a property for a given profile.\r\n     * \r\n     * @param profile the name of the profile\r\n     * @param key the key of the property\r\n     * @return the value of the property, or null if the profile or property does not exist\r\n     */\r\n    public PropsEntry getProfileProperty(final String profile, final String key) {\r\n        final Map<String, PropsEntry> profileMap = profileProperties.get(profile);\r\n        if (profileMap == null) {\r\n            return null;\r\n        }\r\n        return profileMap.get(key);\r\n    }"}, {"ID": 818, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveMacros(String value, final String... profiles) { // create string template parser that will be used internally StringTemplateParser stringTemplateParser = new StringTemplateParser(); stringTemplateParser.setResolveEscapes(false); if (!ignoreMissingMacros) { stringTemplateParser.setReplaceMissingKey(false); } else { stringTemplateParser.setReplaceMissingKey(true); stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY); } final Function<String, String> macroResolver = macroName -> { String[] lookupProfiles = profiles; int leftIndex = macroName.indexOf('<'); if (leftIndex != -1) { int rightIndex = macroName.indexOf('>'); String profiles1 = macroName.substring(leftIndex + 1, rightIndex); macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(profiles1, ','); StringUtil.trimAll(lookupProfiles); } return lookupValue(macroName, lookupProfiles); }; // start parsing int loopCount = 0; while (loopCount++ < MAX_INNER_MACROS) { final String newValue = stringTemplateParser.parse(value, macroResolver); if (newValue.equals(value)) { break; } if (skipEmptyProps) { if (newValue.length() == 0) { return null; } } value = newValue; } return value; }\n\n    ### Response:", "ground_truth": "Resolves all macros in this props set. Called on property lookup.", "predict": "/**\n     * Resolves macros in the given value using the given profiles.\n     *\n     * @param value the value to resolve macros in\n     * @param profiles the profiles to use for resolving macros\n     * @return the resolved value\n     */\n    public String resolveMacros(String value, final String... profiles) {\n        // implementation details elided\n    }"}, {"ID": 819, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) { if (target == null) { target = new HashMap(); } // make sure prefix ends with a dot if (prefix != null) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } } if (profiles != null) { for (String profile : profiles) { while (true) { final Map<String, PropsEntry> map = this.profileProperties.get(profile); if (map != null) { extractMap(target, map, profiles, wildcardPatterns, prefix); } final int ndx = profile.lastIndexOf('.'); if (ndx == -1) { break; } profile = profile.substring(0, ndx); } } } extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix); return target; }\n\n    ### Response:", "ground_truth": "Extracts props to target map. This is all-in-one method, that does many things at once.", "predict": "/**\n     * Extracts properties from the specified profiles and wildcard patterns into the target map.\n     *\n     * @param target the map to extract properties into\n     * @param profiles the profiles to extract properties from\n     * @param wildcardPatterns the wildcard patterns to extract properties from\n     * @param prefix the prefix to add to each property name\n     * @return the target map\n     */\n    public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) {\n        // implementation omitted for brevity\n    }"}, {"ID": 820, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int streamtoword(byte[] data, int[] offp) { int i; int word = 0; int off = offp[0]; for (i = 0; i < 4; i++) { word = (word << 8) | (data[off] & 0xff); off = (off + 1) % data.length; } offp[0] = off; return word; }\n\n    ### Response:", "ground_truth": "Cycically extract a word of key material.\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data", "predict": "/**\r\n     * Converts 4 bytes from the given byte array starting at the given offset to an integer.\r\n     * \r\n     * @param data the byte array to read from\r\n     * @param offp an array containing the offset to start reading from\r\n     * @return the integer value of the 4 bytes read\r\n     */\r\n    private static int streamtoword(byte[] data, int[] offp) {\r\n        int i;\r\n        int word = 0;\r\n        int off = offp[0];\r\n        for (i = 0; i < 4; i++) {\r\n            word = (word << 8) | (data[off] & 0xff);\r\n            off = (off + 1) % data.length;\r\n        }\r\n        offp[0] = off;\r\n        return word;\r\n    }"}, {"ID": 821, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String hashpw(String password, String salt) { BCrypt B; String real_salt; byte[] passwordb, saltb, hashed; char minor = (char) 0; int rounds, off; StringBuffer rs = new StringBuffer(); if (salt.charAt(0) != '$' || salt.charAt(1) != '2') { throw new IllegalArgumentException(\"Invalid salt version\"); } if (salt.charAt(2) == '$') { off = 3; } else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') { throw new IllegalArgumentException(\"Invalid salt revision\"); } off = 4; } // Extract number of rounds if (salt.charAt(off + 2) > '$') { throw new IllegalArgumentException(\"Missing salt rounds\"); } rounds = Integer.parseInt(salt.substring(off, off + 2)); real_salt = salt.substring(off + 3, off + 25); try { passwordb = (password + (minor >= 'a' ? \"\\000\" : \"\")).getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { throw new AssertionError(\"UTF-8 is not supported\"); } saltb = decode_base64(real_salt, BCRYPT_SALT_LEN); B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, (int[]) bf_crypt_ciphertext.clone()); rs.append(\"$2\"); if (minor >= 'a') { rs.append(minor); } rs.append('$'); if (rounds < 10) { rs.append('0'); } if (rounds > 30) { throw new IllegalArgumentException( \"rounds exceeds maximum (30)\"); } rs.append(rounds) .append('$') .append(encode_base64(saltb, saltb.length)) .append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); }\n\n    ### Response:", "ground_truth": "Hash a password using the OpenBSD bcrypt scheme.\n\n@param password the password to hash\n@param salt the salt to hash with (perhaps generated\nusing BCrypt.gensalt)\n@return the hashed password", "predict": "/**\r\n * Generates a hashed password using the bcrypt algorithm.\r\n * \r\n * @param password The password to hash.\r\n * @param salt The salt to use for the hash.\r\n * @return The hashed password.\r\n * @throws IllegalArgumentException If the salt is invalid or the rounds are too high.\r\n */\r\npublic static String hashpw(String password, String salt) {\r\n    // TODO: Implement method\r\n}"}, {"ID": 822, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean checkpw(String plaintext, String hashed) { byte[] hashed_bytes; byte[] try_bytes; try { String try_pw = hashpw(plaintext, hashed); hashed_bytes = hashed.getBytes(\"UTF-8\"); try_bytes = try_pw.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { return false; } if (hashed_bytes.length != try_bytes.length) { return false; } byte ret = 0; for (int i = 0; i < try_bytes.length; i++) { ret |= hashed_bytes[i] ^ try_bytes[i]; } return ret == 0; }\n\n    ### Response:", "ground_truth": "Check that a plaintext password matches a previously hashed\none.\n\n@param plaintext the plaintext password to verify\n@param hashed the previously-hashed password\n@return true if the passwords match, false otherwise", "predict": "/**\r\n     * This method takes in a plaintext password and a hashed password and compares them to see if they match.\r\n     * \r\n     * @param plaintext The plaintext password to be checked.\r\n     * @param hashed The hashed password to be checked against.\r\n     * @return True if the passwords match, false otherwise.\r\n     */\r\n    public static boolean checkpw(String plaintext, String hashed) {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 823, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int copyAll(final OutputStream out) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; } return count; }\n\n    ### Response:", "ground_truth": "Copies bytes from this stream to some output until boundary is\nreached. Returns number of copied bytes. It will throw an exception\nfor any irregular behaviour.", "predict": "/**\r\n     * Copies all bytes from the input stream to the output stream until a boundary is reached.\r\n     *\r\n     * @param out the output stream to write to\r\n     * @return the number of bytes copied\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public int copyAll(final OutputStream out) throws IOException {\r\n        int count = 0;\r\n        while (true) {\r\n            byte b = readByte();\r\n            if (isBoundary(b)) {\r\n                break;\r\n            }\r\n            out.write(b);\r\n            count++;\r\n        }\r\n        return count;\r\n    }"}, {"ID": 824, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; }\n\n    ### Response:", "ground_truth": "Copies max or less number of bytes to output stream. Useful for determining\nif uploaded file is larger then expected.", "predict": "/**\r\n     * Copies up to maxBytes bytes from the input stream to the output stream.\r\n     *\r\n     * @param out the output stream to write to\r\n     * @param maxBytes the maximum number of bytes to copy\r\n     * @return the number of bytes copied\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public int copyMax(final OutputStream out, final int maxBytes) throws IOException {\r\n        int count = 0;\r\n        while (true) {\r\n            byte b = readByte();\r\n            if (isBoundary(b)) {\r\n                break;\r\n            }\r\n            out.write(b);\r\n            count++;\r\n            if (count == maxBytes) {\r\n                return count;\r\n            }\r\n        }\r\n        return count;\r\n    }"}, {"ID": 825, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod); final ActionConfig actionConfig = resolveActionConfig(annotationValues); // interceptors ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig); // filters ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig); // build action definition when not provided if (actionDefinition == null) { actionDefinition = parseActionDefinition(actionClass, actionMethod); } detectAndRegisterAlias(annotationValues, actionDefinition); final boolean async = parseMethodAsyncFlag(actionMethod); final boolean auth = parseMethodAuthFlag(actionMethod); final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod); final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult(); return createActionRuntime( null, actionClass, actionMethod, actionResult, defaultActionResult, actionFilters, actionInterceptors, actionDefinition, async, auth); }\n\n    ### Response:", "ground_truth": "Parses java action method annotation and returns its action runtime.\n\n@param actionClass action class\n@param actionMethod action method\n@param actionDefinition optional action def, usually null so to be parsed", "predict": "/**\r\n     * Parses the given action method and returns an instance of {@link ActionRuntime}.\r\n     *\r\n     * @param actionClass the action class\r\n     * @param actionMethod the action method\r\n     * @param actionDefinition the action definition, can be null\r\n     * @return the action runtime instance\r\n     */\r\n    public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) {\r\n        // ...\r\n    }"}, {"ID": 826, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) { final Class<? extends Annotation> annotationType; if (annotationValues == null) { annotationType = Action.class; } else { annotationType = annotationValues.annotationType(); } return actionConfigManager.lookup(annotationType); }\n\n    ### Response:", "ground_truth": "Resolves action config.", "predict": "/**\r\n     * Resolves the action configuration based on the given annotation values.\r\n     * \r\n     * @param annotationValues the annotation values to resolve the action configuration for\r\n     * @return the resolved action configuration\r\n     */\r\n    protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) {\r\n        final Class<? extends Annotation> annotationType;\r\n        if (annotationValues == null) {\r\n            annotationType = Action.class;\r\n        } else {\r\n            annotationType = annotationValues.annotationType();\r\n        }\r\n        return actionConfigManager.lookup(annotationType);\r\n    }"}, {"ID": 827, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) { final String alias = parseMethodAlias(annotationValues); if (alias != null) { String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH); actionsManager.registerPathAlias(alias, aliasPath); } }\n\n    ### Response:", "ground_truth": "Detects if alias is defined in annotation and registers it if so.", "predict": "/**\r\n     * Detects and registers an alias for the action method.\r\n     *\r\n     * @param annotationValues the annotation values\r\n     * @param actionDefinition the action definition\r\n     */\r\n    protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) {\r\n        final String alias = parseMethodAlias(annotationValues);\r\n        if (alias != null) {\r\n            String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH);\r\n            actionsManager.registerPathAlias(alias, aliasPath);\r\n        }\r\n    }"}, {"ID": 828, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionInterceptor>[] result = null; InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class); if (interceptedBy != null) { result = interceptedBy.value(); if (result.length == 0) { result = null; } } return result; }\n\n    ### Response:", "ground_truth": "Reads class or method annotation for action interceptors.", "predict": "/**\r\n     * Reads the {@link InterceptedBy} annotation on the given action class or method and returns the list of action interceptors specified in the annotation.\r\n     * \r\n     * @param actionClassOrMethod the action class or method to read the annotation from\r\n     * @return the list of action interceptors specified in the annotation, or null if the annotation is not present or specifies no interceptors\r\n     */\r\n    protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 829, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionFilter>[] result = null; FilteredBy filteredBy = actionClassOrMethod.getAnnotation(FilteredBy.class); if (filteredBy != null) { result = filteredBy.value(); if (result.length == 0) { result = null; } } return result; }\n\n    ### Response:", "ground_truth": "Reads class or method annotation for action filters.", "predict": "/**\r\n     * Reads the {@link FilteredBy} annotation on the given action class or method and returns the specified action filters.\r\n     * \r\n     * @param actionClassOrMethod the action class or method to read the annotation from\r\n     * @return the specified action filters, or null if none were specified\r\n     */\r\n    protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 830, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] readPackageActionPath(final Class actionClass) { Package actionPackage = actionClass.getPackage(); final String actionPackageName = actionPackage.getName(); // 1 - read annotations first String packageActionPathFromAnnotation; mainloop: while (true) { MadvocAction madvocActionAnnotation = actionPackage.getAnnotation(MadvocAction.class); packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null; if (StringUtil.isEmpty(packageActionPathFromAnnotation)) { packageActionPathFromAnnotation = null; } if (packageActionPathFromAnnotation == null) { // next package String newPackage = actionPackage.getName(); actionPackage = null; while (actionPackage == null) { final int ndx = newPackage.lastIndexOf('.'); if (ndx == -1) { // end of hierarchy, nothing found break mainloop; } newPackage = newPackage.substring(0, ndx); actionPackage = Packages.of(actionClass.getClassLoader(), newPackage); } } else { // annotation found, register root rootPackages.addRootPackage(actionPackage.getName(), packageActionPathFromAnnotation); break; } } // 2 - read root package String packagePath = rootPackages.findPackagePathForActionPackage(actionPackageName); if (packagePath == null) { return ArraysUtil.array(null, null); } return ArraysUtil.array( StringUtil.stripChar(packagePath, '/'), StringUtil.surround(packagePath, StringPool.SLASH) ); }\n\n    ### Response:", "ground_truth": "Reads action path for package.\nIf annotation is not set on package-level, class package will be used for\npackage action path part.", "predict": "/**\n     * Reads the package action path for the given action class.\n     * <p>\n     * This method first reads the package-level {@link MadvocAction} annotation, if present. If the annotation is not present, it then searches for the package in the root packages list. If the package is found, the action path is registered in the root packages list and returned. If the package is not found, an empty array is returned.\n     * <p>\n     * The package action path is the path relative to the root package where the action class is located. For example, if the action class is located in the package \"com.example.myapp.actions.admin\", and the root package is \"com.example.myapp\", the package action path is \"actions/admin\".\n     * <p>\n     * The method returns an array of two strings: the package action path and the package action path with a leading and trailing slash. The first string is the package action path without the leading and trailing slashes, while the second string is"}, {"ID": 831, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) { // read annotation String methodActionPath = annotationValues != null ? annotationValues.value() : null; if (methodActionPath == null) { methodActionPath = methodName; } else { if (methodActionPath.equals(Action.NONE)) { return ArraysUtil.array(null, null); } } // check for defaults for (String path : actionConfig.getActionMethodNames()) { if (methodActionPath.equals(path)) { methodActionPath = null; break; } } return ArraysUtil.array(methodName, methodActionPath); }\n\n    ### Response:", "ground_truth": "Reads action path from the action method.", "predict": "/**\r\n     * Reads the action path for the given method name and annotation values.\r\n     * \r\n     * @param methodName the name of the method to read the action path for\r\n     * @param annotationValues the annotation values to read the action path from\r\n     * @param actionConfig the action configuration to check for default action paths\r\n     * @return an array containing the method name and action path, or null if no action path was found\r\n     */\r\n    protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) {"}, {"ID": 832, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseMethodAlias(final ActionAnnotationValues annotationValues) { String alias = null; if (annotationValues != null) { alias = annotationValues.alias(); } return alias; }\n\n    ### Response:", "ground_truth": "Reads method's alias value.", "predict": "/**\r\n     * Parses the alias from the given annotation values.\r\n     * \r\n     * @param annotationValues the annotation values to parse the alias from\r\n     * @return the parsed alias or null if no alias was found\r\n     */\r\n    protected String parseMethodAlias(final ActionAnnotationValues annotationValues) {\r\n        String alias = null;\r\n        if (annotationValues != null) {\r\n            alias = annotationValues.alias();\r\n        }\r\n        return alias;\r\n    }"}, {"ID": 833, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime createActionRuntime( final ActionHandler actionHandler, final Class actionClass, final Method actionClassMethod, final Class<? extends ActionResult> actionResult, final Class<? extends ActionResult> defaultActionResult, final ActionFilter[] filters, final ActionInterceptor[] interceptors, final ActionDefinition actionDefinition, final boolean async, final boolean auth) { if (actionHandler != null) { return new ActionRuntime( actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, NoneActionResult.class, NoneActionResult.class, async, auth, null, null); } final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass); // find ins and outs final Class[] paramTypes = actionClassMethod.getParameterTypes(); final MethodParam[] params = new MethodParam[paramTypes.length]; final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations(); String[] methodParamNames = null; // for all elements: action and method arguments... for (int ndx = 0; ndx < paramTypes.length; ndx++) { Class paramType = paramTypes[ndx]; // lazy init to postpone bytecode usage, when method has no arguments if (methodParamNames == null) { methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod); } final String paramName = methodParamNames[ndx]; final Annotation[] parameterAnnotations = paramAnns[ndx]; final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations); MapperFunction mapperFunction = null; for (final Annotation annotation : parameterAnnotations) { if (annotation instanceof Mapper) { mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value()); break; } } params[ndx] = new MethodParam( paramTypes[ndx], paramName, scopeDataInspector.detectAnnotationType(parameterAnnotations), paramsScopeData, mapperFunction ); } return new ActionRuntime( null, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params); }\n\n    ### Response:", "ground_truth": "Creates new instance of action runtime configuration.\nInitialize caches.", "predict": "/**\r\n     * Creates a new instance of the ActionRuntime class.\r\n     * \r\n     * @param actionHandler\r\n     *            the action handler to use for executing the action\r\n     * @param actionClass\r\n     *            the class of the action to execute\r\n     * @param actionClassMethod\r\n     *            the method of the action to execute\r\n     * @param actionResult\r\n     *            the action result class to use for the action\r\n     * @param defaultActionResult\r\n     *            the default action result class to use for the action\r\n     * @param filters\r\n     *            the filters to use for the action\r\n     * @param interceptors\r\n     *            the interceptors to use for the action\r\n     * @param actionDefinition\r\n     *            the action definition to use for the action\r\n     * @param async\r\n     *            whether the action should be executed asynchronously\r\n     * @param auth\r\n     *            whether the action requires authentication\r\n     * @return a new instance of the ActionRuntime class\r\n     */\r\n    public ActionRuntime createActionRuntime(final ActionHandler actionHandler, final Class actionClass, final Method action"}, {"ID": 834, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void preResponseCommit() { long lastModified = lastModifiedData.getLastModified(); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); if (lastModified > -1 && !response.containsHeader(\"Last-Modified\")) { if (ifModifiedSince < (lastModified / 1000 * 1000)) { response.setDateHeader(\"Last-Modified\", lastModified); } else { response.reset(); response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } }\n\n    ### Response:", "ground_truth": "todo move to BufferResponseWrapper ?", "predict": "/**\r\n     * This method is called before the response is committed. It checks if the response contains a Last-Modified header and if it is older than the last modified date of the data. If it is, it sets the Last-Modified header to the current date. If the If-Modified-Since header is present and is newer than the Last-Modified header, it sets the response status to 304 (Not Modified).\r\n     */"}, {"ID": 835, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T applyAdvice(final Class<T> targetClass) { Class adviceClass = cache.get(targetClass); if (adviceClass == null) { // advice not yet created adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define(); cache.put(targetClass, adviceClass); } // create new advice instance and injects target instance to it try { Object advice = ClassUtil.newInstance(adviceClass); Field field = adviceClass.getField(\"$___target$0\"); field.set(advice, targetClass); return (T) advice; } catch (Exception ex) { throw new ProxettaException(ex); } }\n\n    ### Response:", "ground_truth": "Applies advice on given target class and returns proxy instance.", "predict": "/**\r\n     * Applies the advice to the target class.\r\n     *\r\n     * @param targetClass the target class to apply the advice to\r\n     * @param <T> the type of the target class\r\n     * @return the target class with the applied advice\r\n     * @throws ProxettaException if there is an error creating the advice instance or injecting the target instance\r\n     */\r\n    public static <T> T applyAdvice(final Class<T> targetClass) {\r\n        Class adviceClass = cache.get(targetClass);\r\n        if (adviceClass == null) {\r\n            // advice not yet created\r\n            adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define();\r\n            cache.put(targetClass, adviceClass);\r\n        }\r\n        // create new advice instance and injects target instance to it\r\n        try {\r\n            Object advice = ClassUtil.newInstance(adviceClass);\r\n            Field field = adviceClass.getField(\"$___target$0\");\r\n            field.set(advice, targetClass);\r\n            return ("}, {"ID": 836, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void injectTargetIntoProxy(final Object proxy, final Object target) { Class proxyClass = proxy.getClass(); try { Field field = proxyClass.getField(\"$___target$0\"); field.set(proxy, target); } catch (Exception ex) { throw new ProxettaException(ex); } }\n\n    ### Response:", "ground_truth": "Injects target into proxy.", "predict": "/**\r\n     * Injects the target object into the proxy object.\r\n     * \r\n     * @param proxy the proxy object\r\n     * @param target the target object to be injected\r\n     * @throws ProxettaException if there is an error injecting the target object\r\n     */\r\n    public static void injectTargetIntoProxy(final Object proxy, final Object target) {\r\n        Class proxyClass = proxy.getClass();\r\n        try {\r\n            Field field = proxyClass.getField(\"$___target$0\");\r\n            field.set(proxy, target);\r\n        } catch (Exception ex) {\r\n            throw new ProxettaException(ex);\r\n        }\r\n    }"}, {"ID": 837, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (fv != null) { return fv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of the field.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "/**\r\n     * Visits an annotation of the method. The annotation values are passed in an array of objects. The array elements are of type AnnotationVisitor.\r\n     * \r\n     * @param descriptor the class descriptor of the annotation class.\r\n     * @param visible true if the annotation is visible at runtime.\r\n     * @return a visitor to visit the individual annotation values, or null if this visitor is not interested in visiting this annotation.\r\n     */\r\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n        if (fv != null) {\r\n            return fv.visitAnnotation(descriptor, visible);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 838, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveRealName(final String jsonName) { if (jsonNames == null) { return jsonName; } int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName); if (jsonIndex == -1) { return jsonName; } return realNames[jsonIndex]; }\n\n    ### Response:", "ground_truth": "Resolves real name from JSON name.", "predict": "/**\r\n     * Resolves the real name of a JSON name by looking it up in a list of JSON names and their corresponding real names.\r\n     * \r\n     * @param jsonName The JSON name to resolve.\r\n     * @return The real name of the JSON name, or the original JSON name if it was not found in the list.\r\n     */\r\n    public String resolveRealName(final String jsonName) {\r\n        if (jsonNames == null) {\r\n            return jsonName;\r\n        }\r\n        int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName);\r\n        if (jsonIndex == -1) {\r\n            return jsonName;\r\n        }\r\n        return realNames[jsonIndex];\r\n    }"}, {"ID": 839, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveJsonName(final String realName) { if (realNames == null) { return realName; } int realIndex = ArraysUtil.indexOf(realNames, realName); if (realIndex == -1) { return realName; } return jsonNames[realIndex]; }\n\n    ### Response:", "ground_truth": "Resolves JSON name from real name.", "predict": "/**\r\n     * Resolves the JSON name for a given real name.\r\n     * \r\n     * @param realName the real name to resolve\r\n     * @return the JSON name for the given real name, or the real name if it cannot be resolved\r\n     */\r\n    public String resolveJsonName(final String realName) {\r\n        // TODO: implement logic to resolve JSON name from real name\r\n    }"}, {"ID": 840, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public TypeData lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { if (serializationSubclassAware) { typeData = findSubclassTypeData(type); } if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } } return typeData; }\n\n    ### Response:", "ground_truth": "Returns all includes for given type. Returns an empty array\nwhen no includes are defined.", "predict": "/**\r\n     * Looks up the TypeData for the given type. If the TypeData is not found, it will be created and cached.\r\n     * \r\n     * @param type the type to lookup\r\n     * @return the TypeData for the given type\r\n     */\r\n    public TypeData lookupTypeData(final Class type) {\r\n        TypeData typeData = typeDataMap.get(type);\r\n        if (typeData == null) {\r\n            if (serializationSubclassAware) {\r\n                typeData = findSubclassTypeData(type);\r\n            }\r\n            if (typeData == null) {\r\n                typeData = scanClassForAnnotations(type);\r\n                typeDataMap.put(type, typeData);\r\n            }\r\n        }\r\n        return typeData;\r\n    }"}, {"ID": 841, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeData _lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } return typeData; }\n\n    ### Response:", "ground_truth": "Lookups type data and creates one if missing.", "predict": "/**\r\n     * Looks up the TypeData for the given type. If it doesn't exist, it scans the class for annotations and creates a new TypeData object.\r\n     *\r\n     * @param type the type to lookup\r\n     * @return the TypeData for the given type\r\n     */\r\n    protected TypeData _lookupTypeData(final Class type) {\r\n        TypeData typeData = typeDataMap.get(type);\r\n        if (typeData == null) {\r\n            typeData = scanClassForAnnotations(type);\r\n            typeDataMap.put(type, typeData);\r\n        }\r\n        return typeData;\r\n    }"}, {"ID": 842, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeData findSubclassTypeData(final Class type) { final Class<? extends Annotation> defaultAnnotation = jsonAnnotation; if (type.getAnnotation(defaultAnnotation) != null) { // current type has annotation, don't find anything, let type data be created return null; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); // lookup superclasses Class[] superClasses = cd.getAllSuperclasses(); for (Class superClass : superClasses) { if (superClass.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(superClass); } } Class[] interfaces = cd.getAllInterfaces(); for (Class interfaze : interfaces) { if (interfaze.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(interfaze); } } return null; }\n\n    ### Response:", "ground_truth": "Finds type data of first annotated superclass or interface.", "predict": "/**\r\n     * Finds the type data for the given type, by looking up the type hierarchy for the first annotated subclass.\r\n     * \r\n     * @param type the type to find the type data for\r\n     * @return the type data for the given type, or null if no annotated subclass was found\r\n     */\r\n    protected TypeData findSubclassTypeData(final Class type) {\r\n        final Class<? extends Annotation> defaultAnnotation = jsonAnnotation;\r\n        if (type.getAnnotation(defaultAnnotation) != null) {\r\n            // current type has annotation, don't find anything, let type data be created\r\n            return null;\r\n        }\r\n        ClassDescriptor cd = ClassIntrospector.get().lookup(type);\r\n        // lookup superclasses\r\n        Class[] superClasses = cd.getAllSuperclasses();\r\n        for (Class superClass : superClasses) {\r\n            if (superClass.getAnnotation(defaultAnnotation) != null) {\r\n                // annotated subclass founded!\r\n                return _lookupTypeData(superClass);\r\n            }\r\n        }\r\n        // lookup interfaces\r\n        Class[] interfaces = cd.getAll"}, {"ID": 843, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveJsonName(final Class type, final String name) { TypeData typeData = lookupTypeData(type); return typeData.resolveJsonName(name); }\n\n    ### Response:", "ground_truth": "Returns different name of a property if set by annotation.", "predict": "/**\r\n     * Resolves the JSON name for the given property name and type.\r\n     * \r\n     * @param type the type of the property\r\n     * @param name the name of the property\r\n     * @return the resolved JSON name\r\n     */\r\n    public String resolveJsonName(final Class type, final String name) {\r\n        TypeData typeData = lookupTypeData(type);\r\n        return typeData.resolveJsonName(name);\r\n    }"}, {"ID": 844, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveRealName(final Class type, final String jsonName) { TypeData typeData = lookupTypeData(type); return typeData.resolveRealName(jsonName); }\n\n    ### Response:", "ground_truth": "Returns real property name for given JSON property.", "predict": "/**\r\n     * Resolves the real name of a JSON property name based on the type of the object and the mapping defined in the TypeData object.\r\n     * \r\n     * @param type The type of the object.\r\n     * @param jsonName The JSON property name to resolve.\r\n     * @return The resolved real name of the JSON property name.\r\n     */\r\n    public String resolveRealName(final Class type, final String jsonName) {\r\n        TypeData typeData = lookupTypeData(type);\r\n        return typeData.resolveRealName(jsonName);\r\n    }"}, {"ID": 845, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public byte[] getFileContent() throws IOException { if (data != null) { return data; } if (tempFile != null) { return FileUtil.readBytes(tempFile); } return null; }\n\n    ### Response:", "ground_truth": "Returns the content of file upload item.", "predict": "/**\r\n     * This method returns the content of the file as a byte array.\r\n     * \r\n     * @return the content of the file as a byte array.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    @Override public byte[] getFileContent() throws IOException {\r\n        if (data != null) {\r\n            return data;\r\n        }\r\n        if (tempFile != null) {\r\n            return FileUtil.readBytes(tempFile);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 846, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) { // Find attributOffset of the 'bootstrap_methods' array. byte[] inputBytes = classReader.b; int currentAttributeOffset = classReader.getFirstAttributeOffset(); for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer); if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6); break; } currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2); } if (bootstrapMethodCount > 0) { // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array. int bootstrapMethodsOffset = currentAttributeOffset + 8; int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2; bootstrapMethods = new ByteVector(bootstrapMethodsLength); bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength); // Add each bootstrap method in the symbol table entries. int currentOffset = bootstrapMethodsOffset; for (int i = 0; i < bootstrapMethodCount; i++) { int offset = currentOffset - bootstrapMethodsOffset; int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int numBootstrapArguments = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode(); while (numBootstrapArguments-- > 0) { int bootstrapArgument = classReader.readUnsignedShort(currentOffset); currentOffset += 2; hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode(); } add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF)); } } }\n\n    ### Response:", "ground_truth": "Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\nthe SymbolTable.\n\n@param classReader the ClassReader whose bootstrap methods must be copied to initialize the\nSymbolTable.\n@param charBuffer a buffer used to read strings in the constant pool.", "predict": "/**\n     * Copies the bootstrap methods from the given class reader to the symbol table of the given class writer.\n     *\n     * @param classReader the class reader from which to copy the bootstrap methods\n     * @param charBuffer the character buffer to use for reading strings\n     * @param classWriter the class writer to which to add the bootstrap methods as symbol table entries\n     */\n    private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer, final ClassWriter classWriter) {\n        // Find attributOffset of the 'bootstrap_methods' array.\n        byte[] inputBytes = classReader.b;\n        int currentAttributeOffset = classReader.getFirstAttributeOffset();\n        for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer);\n            if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {\n                bootstrapMethodCount = classReader.read"}, {"ID": 847, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int setMajorVersionAndClassName(final int majorVersion, final String className) { this.majorVersion = majorVersion; this.className = className; return addConstantClass(className).index; }\n\n    ### Response:", "ground_truth": "Sets the major version and the name of the class to which this symbol table belongs. Also adds\nthe class name to the constant pool.\n\n@param majorVersion a major ClassFile version number.\n@param className an internal class name.\n@return the constant pool index of a new or already existing Symbol with the given class name.", "predict": "/**\r\n     * Sets the major version and class name of the constant pool and returns the index of the class constant.\r\n     * \r\n     * @param majorVersion the major version of the class\r\n     * @param className the name of the class\r\n     * @return the index of the class constant in the constant pool\r\n     */\r\n    public int setMajorVersionAndClassName(final int majorVersion, final String className) {\r\n        this.majorVersion = majorVersion;\r\n        this.className = className;\r\n        return addConstantClass(className).index;\r\n    }"}, {"ID": 848, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putConstantPool(final ByteVector output) { output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length); }\n\n    ### Response:", "ground_truth": "Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\nconstant_pool_count value.\n\n@param output where the JVMS ClassFile's constant_pool array must be put.", "predict": "/**\r\n     * Writes the constant pool to the given output stream.\r\n     *\r\n     * @param output the output stream to write to\r\n     */\r\n    void putConstantPool(final ByteVector output);"}, {"ID": 849, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putBootstrapMethods(final ByteVector output) { if (bootstrapMethods != null) { output .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)) .putInt(bootstrapMethods.length + 2) .putShort(bootstrapMethodCount) .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length); } }\n\n    ### Response:", "ground_truth": "Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n6 attribute header bytes and the num_bootstrap_methods value.\n\n@param output where the JVMS BootstrapMethods attribute must be put.", "predict": "/**\n     * Adds the bootstrap methods to the constant pool of the given {@link ByteVector}.\n     * \n     * @param output the {@link ByteVector} to add the bootstrap methods to.\n     */\n    public void putBootstrapMethods(final ByteVector output) {\n        if (bootstrapMethods != null) {\n            output.putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS));\n            output.putInt(bootstrapMethods.length + 2);\n            output.putShort(bootstrapMethodCount);\n            output.putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\n        }\n    }"}, {"ID": 850, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantFieldref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a field name.\n@param descriptor a field descriptor.\n@return a new or already existing Symbol with the given value.", "predict": "/**\n     * Adds a constant field reference to the constant pool.\n     * \n     * @param owner\n     *            the class name of the field's owner\n     * @param name\n     *            the name of the field\n     * @param descriptor\n     *            the descriptor of the field\n     * @return the index of the added field reference in the constant pool\n     */\n    private int addConstantFieldref(final String owner, final String name, final String descriptor) {\n        return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);\n    }"}, {"ID": 851, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\nsymbol table. Does nothing if the constant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a method name.\n@param descriptor a method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a new CONSTANT_Methodref or CONSTANT_InterfaceMethodref constant to the constant pool.\r\n     *\r\n     * @param tag the tag for the constant pool entry (either CONSTANT_Methodref or CONSTANT_InterfaceMethodref)\r\n     * @param owner the internal name of the class that owns the method\r\n     * @param name the name of the method\r\n     * @param descriptor the descriptor of the method\r\n     * @return the index of the new constant pool entry\r\n     */\r\n    private int addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 852, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Entry addConstantMemberReference( final int tag, final String owner, final String name, final String descriptor) { int hashCode = hash(tag, owner, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122( tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor)); return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\nthe constant pool of this symbol table. Does nothing if the constant pool already contains a\nsimilar item.\n\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a new constant member reference to the constant pool.\r\n     * \r\n     * @param tag the tag of the constant pool entry\r\n     * @param owner the class name of the member\r\n     * @param name the name of the member\r\n     * @param descriptor the descriptor of the member\r\n     * @return the new constant pool entry\r\n     */\r\n    private Entry addConstantMemberReference(final int tag, final String owner, final String name, final String descriptor) {\r\n        int hashCode = hash(tag, owner, name, descriptor);\r\n        Entry entry = get(hashCode);\r\n        while (entry != null) {\r\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) {\r\n                return entry;\r\n            }\r\n            entry = entry.next;\r\n        }\r\n        constantPool.put122(tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor));\r\n        return put(new"}, {"ID": 853, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantMemberReference( final int index, final int tag, final String owner, final String name, final String descriptor) { add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\nto the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "/**\n     * Adds a new constant member reference to the constant pool.\n     * \n     * @param index the index of the constant pool entry to be added\n     * @param tag the tag of the constant pool entry to be added\n     * @param owner the owner of the constant pool entry to be added\n     * @param name the name of the constant pool entry to be added\n     * @param descriptor the descriptor of the constant pool entry to be added\n     */\n    private void addConstantMemberReference(final int index, final int tag, final String owner, final String name, final String descriptor) {\n        add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor)));\n    }"}, {"ID": 854, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } constantPool.putByte(tag).putInt(value); return put(new Entry(constantPoolCount++, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.\n@return a constant pool constant with the given tag and primitive values.", "predict": "/**\r\n     * Adds a constant integer or float to the constant pool.\r\n     * \r\n     * @param tag the tag of the constant (CONSTANT_Integer or CONSTANT_Float)\r\n     * @param value the integer or float value of the constant\r\n     * @return the Symbol object representing the constant\r\n     */\r\n    private Symbol addConstantIntegerOrFloat(final int tag, final int value) {\r\n        int hashCode = hash(tag, value);\r\n        Entry entry = get(hashCode);\r\n        while (entry != null) {\r\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n                return entry;\r\n            }\r\n            entry = entry.next;\r\n        }\r\n        constantPool.putByte(tag).putInt(value);\r\n        return put(new Entry(constantPoolCount++, tag, value, hashCode));\r\n    }"}, {"ID": 855, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.", "predict": "/**\n     * Adds a constant integer or float to the constant pool.\n     * \n     * @param index the index of the constant pool entry to add the constant to\n     * @param tag the tag of the constant (either 3 or 4 for integer or float, respectively)\n     * @param value the value of the constant\n     */\n    private void addConstantIntegerOrFloat(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); }"}, {"ID": 856, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantLongOrDouble(final int tag, final long value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } int index = constantPoolCount; constantPool.putByte(tag).putLong(value); constantPoolCount += 2; return put(new Entry(index, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.\n@return a constant pool constant with the given tag and primitive values.", "predict": "/**\r\n     * Adds a constant long or double to the constant pool and returns the corresponding symbol.\r\n     *\r\n     * @param tag the tag of the constant (CONSTANT_Long or CONSTANT_Double)\r\n     * @param value the value of the constant\r\n     * @return the symbol corresponding to the constant\r\n     */\r\n    private Symbol addConstantLongOrDouble(final int tag, final long value) {\r\n        int hashCode = hash(tag, value);\r\n        Entry entry = get(hashCode);\r\n        while (entry != null) {\r\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) {\r\n                return entry;\r\n            }\r\n            entry = entry.next;\r\n        }\r\n        int index = constantPoolCount;\r\n        constantPool.putByte(tag).putLong(value);\r\n        constantPoolCount += 2;\r\n        return put(new Entry(index, tag, value, hashCode));\r\n    }"}, {"ID": 857, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.", "predict": "/**\n     * Adds a constant long or double value to the constant pool.\n     * \n     * @param index the index of the constant pool entry to add the value to\n     * @param tag the tag of the constant pool entry to add the value to\n     * @param value the value to add to the constant pool\n     */\n    private void addConstantLongOrDouble(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); }"}, {"ID": 858, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addConstantNameAndType(final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; int hashCode = hash(tag, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry.index; } entry = entry.next; } constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor)); return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index; }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": "/**\n     * Adds a new CONSTANT_NameAndType_info entry to the constant pool and returns its index.\n     * \n     * @param name the name of the field or method\n     * @param descriptor the descriptor of the field or method\n     * @return the index of the new entry in the constant pool\n     */\n    public int addConstantNameAndType(final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        int hashCode = hash(tag, name, descriptor);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor));\n        return put(new Entry(constantPoolCount++, tag,"}, {"ID": 859, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "/**\n     * Adds a constant name and type entry to the constant pool.\n     * \n     * @param index the index of the constant pool entry to be added\n     * @param name the name of the constant\n     * @param descriptor the descriptor of the constant\n     */\n    private void addConstantNameAndType(final int index, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG;\n        add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor)));\n    }"}, {"ID": 860, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addConstantUtf8(final String value) { int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value); return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index; }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param value a string.\n@return a new or already existing Symbol with the given value.", "predict": "/**\n     * Adds a new CONSTANT_UTF8 entry to the constant pool and returns its index.\n     * \n     * @param value the value of the CONSTANT_UTF8 entry to be added\n     * @return the index of the newly added CONSTANT_UTF8 entry\n     */\n    public int addConstantUtf8(final String value) {\n        int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) {\n                return entry.index;\n            }\n            entry = entry.next;\n        }\n        constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n        return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n    }"}, {"ID": 861, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantUtf8(final int index, final String value) { add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param value a string.", "predict": "/**\n     * Adds a constant UTF-8 entry to the constant pool.\n     * \n     * @param index the index of the constant pool entry to add\n     * @param value the value of the constant pool entry to add\n     */\n    private void addConstantUtf8(final int index, final String value) { add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value))); }"}, {"ID": 862, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantMethodHandle( final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; // Note that we don't need to include isInterface in the hash computation, because it is // redundant with owner (we can't have the same owner with different isInterface values). int hashCode = hash(tag, owner, name, descriptor, referenceKind); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } if (referenceKind <= Opcodes.H_PUTSTATIC) { constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index); } else { constantPool.put112( tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index); } return put( new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\nthe constant pool already contains a similar item.\n\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": "/**\n     * Adds a new method handle constant to the constant pool and returns its index.\n     * \n     * @param referenceKind\n     *            the kind of reference, either {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},\n     *            {@link Opcodes#H_PUTFIELD}, or {@link Opcodes#H_PUTSTATIC}\n     * @param owner\n     *            the internal name of the class that owns the field or method this handle references\n     * @param name\n     *            the name of the field or method this handle references\n     * @param descriptor\n     *            the descriptor of the field or method this handle references\n     * @param isInterface\n     *            true if the owner class is an interface, false otherwise\n     * @return the index of the new method handle constant in the constant pool\n     */\n    public int addConstantMethodHandle(final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) {\n        final int tag = Symbol.CONSTANT_"}, {"ID": 863, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantMethodHandle( final int index, final int referenceKind, final String owner, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; int hashCode = hash(tag, owner, name, descriptor, referenceKind); add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": "/**\n     * Adds a constant method handle to the constant pool.\n     * \n     * @param index the index of the constant pool entry to be added\n     * @param referenceKind the reference kind of the method handle\n     * @param owner the internal name of the class that owns the method\n     * @param name the name of the method\n     * @param descriptor the descriptor of the method\n     */\n    private void addConstantMethodHandle(final int index, final int referenceKind, final String owner, final String name, final String descriptor) {\n        final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG;\n        int hashCode = hash(tag, owner, name, descriptor, referenceKind);\n        add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode));\n    }"}, {"ID": 864, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\nbootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\npool already contains a similar item.\n\n@param name a method name.\n@param descriptor a field descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a CONSTANT_Dynamic or InvokeDynamic reference to the constant pool.\r\n     *\r\n     * @param tag the tag of the reference (CONSTANT_Dynamic or InvokeDynamic)\r\n     * @param name the name of the reference\r\n     * @param descriptor the descriptor of the reference\r\n     * @param bootstrapMethodIndex the index of the bootstrap method in the constant pool\r\n     * @return the new Symbol object representing the reference\r\n     */\r\n    private Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n        int index = addConstant(tag, name, descriptor, bootstrapMethodIndex);\r\n        return new Symbol(index, tag, name, descriptor);\r\n    }"}, {"ID": 865, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addConstantInvokeDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\nrelated bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a method name.\n@param descriptor a method descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a CONSTANT_InvokeDynamic_info to the constant pool and returns the index of the new entry.\r\n     *\r\n     * @param name the name of the method being invoked\r\n     * @param descriptor the descriptor of the method being invoked\r\n     * @param bootstrapMethodHandle the bootstrap method to be invoked\r\n     * @param bootstrapMethodArguments the arguments to be passed to the bootstrap method\r\n     * @return the index of the new CONSTANT_InvokeDynamic_info in the constant pool\r\n     */\r\n    public int addConstantInvokeDynamic(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n        Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments);\r\n        return addConstantDynamicOrInvokeDynamicReference(Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index);\r\n    }"}, {"ID": 866, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantDynamicOrInvokeDynamicReference( final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor)); return put( new Entry( constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\ntable. Does nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n@return a new or already existing Symbol with the given value.", "predict": "/**\n     * Adds a new constant dynamic or invoke dynamic reference to the constant pool.\n     * \n     * @param tag the tag of the constant pool entry (CONSTANT_Dynamic or CONSTANT_InvokeDynamic)\n     * @param name the name of the method or field being referred to\n     * @param descriptor the descriptor of the method or field being referred to\n     * @param bootstrapMethodIndex the index of the bootstrap method in the bootstrap methods array\n     * @return the new or existing constant pool entry for the given tag, name, descriptor, and bootstrap method index\n     */\n    private Symbol addConstantDynamicOrInvokeDynamicReference(final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) {\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\n        Entry entry = get(hashCode);\n        while (entry != null) {\n            if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor"}, {"ID": 867, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantDynamicOrInvokeDynamicReference( final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\nsymbol table.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param index the constant pool index of the new Symbol.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.", "predict": "/**\r\n     * Adds a new constant dynamic or invoke dynamic reference to the constant pool.\r\n     *\r\n     * @param tag the type of the reference (CONSTANT_Dynamic or CONSTANT_InvokeDynamic)\r\n     * @param index the index of the new reference in the constant pool\r\n     * @param name the name of the method or field being referred to\r\n     * @param descriptor the descriptor of the method or field being referred to\r\n     * @param bootstrapMethodIndex the index of the bootstrap method in the constant pool\r\n     */\r\n    private void addConstantDynamicOrInvokeDynamicReference(final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) {\r\n        int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex);\r\n        add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode));\r\n    }"}, {"ID": 868, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Symbol addConstantUtf8Reference(final int tag, final String value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) { return entry; } entry = entry.next; } constantPool.put12(tag, addConstantUtf8(value)); return put(new Entry(constantPoolCount++, tag, value, hashCode)); }\n\n    ### Response:", "ground_truth": "Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\nnothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a new constant UTF-8 entry to the constant pool and returns the index of the new entry.\r\n     * \r\n     * @param tag the tag of the constant pool entry (must be CONSTANT_Utf8)\r\n     * @param value the value of the constant pool entry\r\n     * @return the index of the new constant pool entry\r\n     */\r\n    private int addConstantUtf8(final String value) {\r\n        int index = constantPool.indexOf(value);\r\n        if (index == -1) {\r\n            index = constantPoolCount++;\r\n            constantPool.put12(CONSTANT_Utf8, index);\r\n            constantPool.putUTF8(value);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Adds a new constant UTF-8 reference entry to the constant pool and returns the index of the new entry.\r\n     * \r\n     * @param tag the tag of the constant pool entry (must be CONSTANT_Utf8)\r\n     * @param value the value of the constant pool entry\r\n     * @return the index of the new constant pool"}, {"ID": 869, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); }\n\n    ### Response:", "ground_truth": "Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.", "predict": "/**\n     * Adds a constant UTF-8 entry to the constant pool.\n     * \n     * @param index the index of the entry in the constant pool\n     * @param tag the tag of the entry (must be CONSTANT_Utf8)\n     * @param value the value of the entry (must be a valid UTF-8 string)\n     */\n    private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); }"}, {"ID": 870, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    Symbol addBootstrapMethod( final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { ByteVector bootstrapMethodsAttribute = bootstrapMethods; if (bootstrapMethodsAttribute == null) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector(); } // The bootstrap method arguments can be Constant_Dynamic values, which reference other // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified // while adding the given bootstrap method to it, in the rest of this method. for (Object bootstrapMethodArgument : bootstrapMethodArguments) { addConstant(bootstrapMethodArgument); } // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to // compare it with existing ones, and will be reverted below if there is already a similar // bootstrap method. int bootstrapMethodOffset = bootstrapMethodsAttribute.length; bootstrapMethodsAttribute.putShort( addConstantMethodHandle( bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()) .index); int numBootstrapArguments = bootstrapMethodArguments.length; bootstrapMethodsAttribute.putShort(numBootstrapArguments); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index); } // Compute the length and the hash code of the bootstrap method. int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset; int hashCode = bootstrapMethodHandle.hashCode(); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { hashCode ^= bootstrapMethodArgument.hashCode(); } hashCode &= 0x7FFFFFFF; // Add the bootstrap method to the symbol table or revert the above changes. return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode); }\n\n    ### Response:", "ground_truth": "Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\nthe BootstrapMethods already contains a similar bootstrap method.\n\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": "/**\r\n     * Adds a bootstrap method to the BootstrapMethods attribute of this class.\r\n     * \r\n     * @param bootstrapMethodHandle the handle of the bootstrap method to be added\r\n     * @param bootstrapMethodArguments the arguments of the bootstrap method to be added\r\n     * @return the symbol of the added bootstrap method\r\n     */\r\n    public Symbol addBootstrapMethod(final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n        ByteVector bootstrapMethodsAttribute = bootstrapMethods;\r\n        if (bootstrapMethodsAttribute == null) {\r\n            bootstrapMethodsAttribute = bootstrapMethods = new ByteVector();\r\n        }\r\n        // The bootstrap method arguments can be Constant_Dynamic values, which reference other\r\n        // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool\r\n        // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified\r\n        // while adding the given bootstrap method to it, in the rest of this method.\r\n        for (Object bootstrapMethodArgument : bootstrapMethodArguments) {\r\n            addConstant(bootstrapMethodArgument);\r\n        }\r\n        // Write the bootstrap method in"}, {"ID": 871, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info; } entry = entry.next; } String type1 = typeTable[typeTableIndex1].value; String type2 = typeTable[typeTableIndex2].value; int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2)); put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex; return commonSuperTypeIndex; }\n\n    ### Response:", "ground_truth": "Adds a merged type in the type table of this symbol table. Does nothing if the type table\nalready contains a similar type.\n\n@param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\ncorresponding to the common super class of the given types.", "predict": "/**\n     * Adds a merged type to the type table. The merged type is the common super type of the two types represented by the given type table indices.\n     * \n     * @param typeTableIndex1 the index of the first type in the type table\n     * @param typeTableIndex2 the index of the second type in the type table\n     * @return the index of the merged type in the type table\n     */\n    public int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info;"}, {"ID": 872, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int hash(final String name) { int h = 0; for (int i = name.length() - 1; i >= 0; i--) { char c = name.charAt(i); if (!caseSensitive) { if (c >= 'A' && c <= 'Z') { c += 32; } } h = 31 * h + c; } if (h > 0) { return h; } if (h == Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return -h; }\n\n    ### Response:", "ground_truth": "Calculates hash value of the input string.", "predict": "/**\r\n     * Generates a hash code for a string.\r\n     *\r\n     * @param name the string to generate the hash code for\r\n     * @return the hash code for the string\r\n     */\r\n    private int hash(final String name) {\r\n        int h = 0;\r\n        for (int i = name.length() - 1; i >= 0; i--) {\r\n            char c = name.charAt(i);\r\n            if (!caseSensitive) {\r\n                if (c >= 'A' && c <= 'Z') {\r\n                    c += 32;\r\n                }\r\n            }\r\n            h = 31 * h + c;\r\n        }\r\n        if (h > 0) {\r\n            return h;\r\n        }\r\n        if (h == Integer.MIN_VALUE) {\r\n            return Integer.MAX_VALUE;\r\n        }\r\n        return -h;\r\n    }"}, {"ID": 873, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpMultiMap<V> clear() { for (int i = 0; i < entries.length; i++) { entries[i] = null; } head.before = head.after = head; return this; }\n\n    ### Response:", "ground_truth": "Clears the map.", "predict": "/**\r\n     * Removes all entries from this multi-map.\r\n     *\r\n     * @return this multi-map, after clearing all entries\r\n     */\r\n    public HttpMultiMap<V> clear() {\r\n        for (int i = 0; i < entries.length; i++) {\r\n            entries[i] = null;\r\n        }\r\n        head.before = head.after = head;\r\n        return this;\r\n    }"}, {"ID": 874, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<V> getAll(final String name) { LinkedList<V> values = new LinkedList<>(); int h = hash(name); int i = index(h); MapEntry<V> e = entries[i]; while (e != null) { if (e.hash == h && eq(name, e.key)) { values.addFirst(e.getValue()); } e = e.next; } return values; }\n\n    ### Response:", "ground_truth": "Returns all values associated with the name.", "predict": "/**\r\n     * Returns a list of all values with the given name.\r\n     * \r\n     * @param name the name of the values to retrieve\r\n     * @return a list of all values with the given name\r\n     */\r\n    public List<V> getAll(final String name) {\r\n        LinkedList<V> values = new LinkedList<>();\r\n        int h = hash(name);\r\n        int i = index(h);\r\n        MapEntry<V> e = entries[i];\r\n        while (e != null) {\r\n            if (e.hash == h && eq(name, e.key)) {\r\n                values.addFirst(e.getValue());\r\n            }\r\n            e = e.next;\r\n        }\r\n        return values;\r\n    }"}, {"ID": 875, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<Map.Entry<String, V>> iterator() { final MapEntry[] e = {head.after}; return new Iterator<Map.Entry<String, V>>() { @Override public boolean hasNext() { return e[0] != head; } @Override @SuppressWarnings(\"unchecked\") public Map.Entry<String, V> next() { if (!hasNext()) { throw new NoSuchElementException(\"No next() entry in the iteration\"); } MapEntry<V> next = e[0]; e[0] = e[0].after; return next; } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response:", "ground_truth": "Returns iterator of all entries.", "predict": "/**\r\n     * Returns an iterator over the entries in this map.\r\n     *\r\n     * @return an iterator over the entries in this map\r\n     */\r\n    @Override\r\n    public Iterator<Map.Entry<String, V>> iterator() {\r\n        final MapEntry[] e = {head.after};\r\n        return new Iterator<Map.Entry<String, V>>() {\r\n            @Override\r\n            public boolean hasNext() {\r\n                return e[0] != head;\r\n            }\r\n\r\n            @Override\r\n            @SuppressWarnings(\"unchecked\")\r\n            public Map.Entry<String, V> next() {\r\n                if (!hasNext()) {\r\n                    throw new NoSuchElementException(\"No next() entry in the iteration\");\r\n                }\r\n                MapEntry<V> next = e[0];\r\n                e[0] = e[0].after;\r\n                return next;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }"}, {"ID": 876, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Map.Entry<String, V>> entries() { List<Map.Entry<String, V>> all = new LinkedList<>(); MapEntry<V> e = head.after; while (e != head) { all.add(e); e = e.after; } return all; }\n\n    ### Response:", "ground_truth": "Returns all the entries of this map. Case sensitivity does not influence\nthe returned list, it always contains all of the values.", "predict": "/**\r\n     * Returns a list of all key-value mappings in this map.\r\n     * The list is backed by the map, so changes to the map are reflected in the list, and vice versa.\r\n     * The order of the entries in the list is not guaranteed to be consistent with the order maintained by the map.\r\n     *\r\n     * @return a list of all key-value mappings in this map\r\n     */\r\n    public List<Map.Entry<String, V>> entries() {\r\n        List<Map.Entry<String, V>> all = new LinkedList<>();\r\n        MapEntry<V> e = head.after;\r\n        while (e != head) {\r\n            all.add(e);\r\n            e = e.after;\r\n        }\r\n        return all;\r\n    }"}, {"ID": 877, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void grow(final int minCapacity) { final int oldCapacity = buffer.length; int newCapacity = oldCapacity << 1; if (newCapacity - minCapacity < 0) { // special case, min capacity is larger then a grow newCapacity = minCapacity + 512; } buffer = Arrays.copyOf(buffer, newCapacity); }\n\n    ### Response:", "ground_truth": "Grows the buffer.", "predict": "/**\r\n     * Increases the capacity of this buffer by a specified amount.\r\n     *\r\n     * @param minCapacity the desired minimum capacity\r\n     */\r\n    private void grow(final int minCapacity) {\r\n        final int oldCapacity = buffer.length;\r\n        int newCapacity = oldCapacity << 1;\r\n        if (newCapacity - minCapacity < 0) {\r\n            // special case, min capacity is larger then a grow newCapacity = minCapacity + 512;\r\n        }\r\n        buffer = Arrays.copyOf(buffer, newCapacity);\r\n    }"}, {"ID": 878, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public FastCharBuffer append(final CharSequence csq, final int start, final int end) { for (int i = start; i < end; i++) { append(csq.charAt(i)); } return this; }\n\n    ### Response:", "ground_truth": "Appends character sequence to buffer.", "predict": "/**\r\n     * Appends the specified character sequence to this buffer.\r\n     *\r\n     * @param csq the character sequence to append.\r\n     * @param start the start index, inclusive.\r\n     * @param end the end index, exclusive.\r\n     * @return this buffer.\r\n     * @throws IndexOutOfBoundsException if {@code start} is negative, or {@code end} is greater than the length of the character sequence, or {@code start} is greater than {@code end}.\r\n     */\r\n    @Override public FastCharBuffer append(final CharSequence csq, final int start, final int end) {\r\n        for (int i = start; i < end; i++) {\r\n            append(csq.charAt(i));\r\n        }\r\n        return this;\r\n    }"}, {"ID": 879, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4] return new AnnotationVisitorAdapter(destAnn); }\n\n    ### Response:", "ground_truth": "Copies target method annotations.", "predict": "/**\r\n     * This method is used to visit a method annotation.\r\n     * \r\n     * @param desc the descriptor of the annotation class.\r\n     * @param visible whether or not the annotation is visible at runtime.\r\n     * @return a visitor to visit the annotation values.\r\n     */\r\n    @Override\r\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\r\n        AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4] return new AnnotationVisitorAdapter(destAnn);\r\n    }"}, {"ID": 880, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { createFirstChainDelegate_Continue(tmd); for (int p = 0; p < tmd.proxyData.length; p++) { tmd.selectCurrentProxy(p); createProxyMethod(tmd); } }\n\n    ### Response:", "ground_truth": "Finally, builds proxy methods if applied to current method.", "predict": "/**\r\n     * This method is called after all the methods have been visited. It creates a chain of delegates to handle the method calls.\r\n     * \r\n     * @param tmd\r\n     *            The TypeMetadata object for the current type.\r\n     */\r\n    @Override\r\n    public void visitEnd() {\r\n        createFirstChainDelegate_Continue(tmd);\r\n        for (int p = 0; p < tmd.proxyData.length; p++) {\r\n            tmd.selectCurrentProxy(p);\r\n            createProxyMethod(tmd);\r\n        }\r\n    }"}, {"ID": 881, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createFirstChainDelegate_Start() { // check invalid access flags int access = msign.getAccessFlags(); if (!wd.allowFinalMethods) { if ((access & AsmUtil.ACC_FINAL) != 0) { // detect final throw new ProxettaException( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\"); } } // create proxy methods tmd = new TargetMethodData(msign, aspectList); access &= ~ACC_NATIVE; access &= ~ACC_ABSTRACT; methodVisitor = wd.dest.visitMethod( access, tmd.msign.getMethodName(), tmd.msign.getDescription(), tmd.msign.getAsmMethodSignature(), null); }\n\n    ### Response:", "ground_truth": "Starts creation of first chain delegate.", "predict": "/**\r\n     * Creates the first chain delegate for the given method signature.\r\n     * \r\n     * @param msign the method signature to create the delegate for\r\n     * @throws ProxettaException if the method is final and final methods are not allowed\r\n     */\r\n    protected void createFirstChainDelegate_Start(MethodSignature msign) throws ProxettaException {\r\n        int access = msign.getAccessFlags();\r\n        if (!wd.allowFinalMethods) {\r\n            if ((access & AsmUtil.ACC_FINAL) != 0) {\r\n                // detect final\r\n                throw new ProxettaException(\"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\");\r\n            }\r\n        }\r\n        // create proxy methods\r\n        TargetMethodData tmd = new TargetMethodData(msign, aspectList);\r\n        access &= ~AsmUtil.ACC_NATIVE;\r\n        access &= ~AsmUtil.ACC_ABSTRACT;\r\n        methodVisitor = wd.dest.visitMethod(access, tmd"}, {"ID": 882, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) { methodVisitor.visitCode(); if (tmd.msign.isStatic) { loadStaticMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } else { loadSpecialMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } visitReturn(methodVisitor, tmd.msign, false); methodVisitor.visitMaxs(0, 0); methodVisitor.visitEnd(); }\n\n    ### Response:", "ground_truth": "Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.\nThis method mirrors the target method.", "predict": "/**\r\n     * Creates the first chain delegate for the given method data.\r\n     * \r\n     * @param tmd the method data for the method to be delegated to\r\n     */\r\n    protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 883, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Path parse(final String path) { return path == null ? new Path() : new Path(StringUtil.splitc(path, '.')); }\n\n    ### Response:", "ground_truth": "Parses input dot-separated string that represents a path.", "predict": "/**\r\n     * Parses a string representation of a path into a Path object.\r\n     *\r\n     * @param path the string representation of the path to parse\r\n     * @return a Path object representing the parsed path\r\n     */\r\n    public static Path parse(final String path) {\r\n        return path == null ? new Path() : new Path(StringUtil.splitc(path, '.'));\r\n    }"}, {"ID": 884, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Path push(final CharSequence field) { _push(field); if (altPath != null) { altPath.push(field); } return this; }\n\n    ### Response:", "ground_truth": "Push element to the path.", "predict": "/**\r\n     * Pushes a field onto the current path.\r\n     * \r\n     * @param field the field to push\r\n     * @return the updated path\r\n     */\r\n    public Path push(final CharSequence field) {\r\n        _push(field);\r\n        if (altPath != null) {\r\n            altPath.push(field);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 885, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void configureServletContext(final ServletContext servletContext) { servletContext.addListener(jodd.servlet.RequestContextListener.class); if (decoraEnabled) { final FilterRegistration filter = servletContext.addFilter(\"decora\", jodd.decora.DecoraServletFilter.class); filter.addMappingForUrlPatterns(null, true, contextPath); } final FilterRegistration filter = servletContext.addFilter(\"madvoc\", jodd.madvoc.MadvocServletFilter.class); filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath); }\n\n    ### Response:", "ground_truth": "Configures servlet context.", "predict": "/**\r\n     * Configures the servlet context for Jodd usage.\r\n     * \r\n     * @param servletContext the servlet context to configure\r\n     */\r\n    private void configureServletContext(final ServletContext servletContext) {\r\n        servletContext.addListener(jodd.servlet.RequestContextListener.class);\r\n        if (decoraEnabled) {\r\n            final FilterRegistration filter = servletContext.addFilter(\"decora\", jodd.decora.DecoraServletFilter.class);\r\n            filter.addMappingForUrlPatterns(null, true, contextPath);\r\n        }\r\n        final FilterRegistration filter = servletContext.addFilter(\"madvoc\", jodd.madvoc.MadvocServletFilter.class);\r\n        filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath);\r\n    }"}, {"ID": 886, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object execute() { String methodName = targetMethodName(); Class returnType = returnType(); Object next = pathref.continueWith(this, methodName, returnType); return ProxyTarget.returnValue(next); }\n\n    ### Response:", "ground_truth": "Reads method name and appends it. Creates object for next call and\nreturns that value. If next object is unsupported, it will return null;", "predict": "/**\r\n     * This method executes the target method and returns the result.\r\n     * \r\n     * @return The result of the target method.\r\n     */\r\n    public Object execute() {\r\n        // TODO: Implement method logic here.\r\n    }"}, {"ID": 887, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldDescriptor[] getAllFieldDescriptors() { if (allFields == null) { FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()]; int index = 0; for (FieldDescriptor fieldDescriptor : fieldsMap.values()) { allFields[index] = fieldDescriptor; index++; } Arrays.sort(allFields, Comparator.comparing(fd -> fd.getField().getName())); this.allFields = allFields; } return allFields; }\n\n    ### Response:", "ground_truth": "Returns all fields of this collection. Returns empty array\nif no fields exist. Initialized lazy.", "predict": "/**\r\n     * Returns an array of all the field descriptors in the class.\r\n     *\r\n     * @return an array of all the field descriptors in the class.\r\n     */\r\n    public FieldDescriptor[] getAllFieldDescriptors() {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 888, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") @Override protected <T> BeanDefinition<T> createBeanDefinitionForRegistration( final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) { if (proxetta != null) { final Class originalType = type; final ProxettaFactory builder = proxetta.proxy(); builder.setTarget(type); type = builder.define(); return new ProxettaBeanDefinition( name, type, scope, wiringMode, originalType, proxetta.getAspects(new ProxyAspect[0]), consumer); } return super.createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); }\n\n    ### Response:", "ground_truth": "Applies proxetta on bean class before bean registration.", "predict": "/**\r\n     * This method creates a {@link BeanDefinition} for the given registration.\r\n     * \r\n     * @param name the name of the bean\r\n     * @param type the type of the bean\r\n     * @param scope the scope of the bean\r\n     * @param wiringMode the wiring mode of the bean\r\n     * @param consumer a consumer that can be used to customize the bean after creation\r\n     * @return the created {@link BeanDefinition}\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    protected <T> BeanDefinition<T> createBeanDefinitionForRegistration(final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) {\r\n        if (proxetta != null) {\r\n            final Class originalType = type;\r\n            final ProxettaFactory builder = proxetta.proxy();\r\n            builder.setTarget(type);\r\n            type = builder.define();\r\n            return new ProxettaBeanDefinition(name, type, scope, wiringMode, original"}, {"ID": 889, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) { final int isolation; switch (txMode.getIsolationLevel()) { case ISOLATION_DEFAULT: isolation = DbTransactionMode.ISOLATION_DEFAULT; break; case ISOLATION_NONE: isolation = DbTransactionMode.ISOLATION_NONE; break; case ISOLATION_READ_COMMITTED: isolation = DbTransactionMode.ISOLATION_READ_COMMITTED; break; case ISOLATION_READ_UNCOMMITTED: isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED; break; case ISOLATION_REPEATABLE_READ: isolation = DbTransactionMode.ISOLATION_REPEATABLE_READ; break; case ISOLATION_SERIALIZABLE: isolation = DbTransactionMode.ISOLATION_SERIALIZABLE; break; default: throw new IllegalArgumentException(); } return new DbTransactionMode(isolation, txMode.isReadOnly()); }\n\n    ### Response:", "ground_truth": "Converter JTX transaction mode to DB transaction mode.", "predict": "/**\n     * Converts a JTA transaction mode to a database transaction mode.\n     *\n     * @param txMode the JTA transaction mode to convert\n     * @return the corresponding database transaction mode\n     * @throws IllegalArgumentException if the JTA transaction mode is not recognized\n     */\n    public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) {\n        final int isolation;\n        switch (txMode.getIsolationLevel()) {\n            case ISOLATION_DEFAULT:\n                isolation = DbTransactionMode.ISOLATION_DEFAULT;\n                break;\n            case ISOLATION_NONE:\n                isolation = DbTransactionMode.ISOLATION_NONE;\n                break;\n            case ISOLATION_READ_COMMITTED:\n                isolation = DbTransactionMode.ISOLATION_READ_COMMITTED;\n                break;\n            case ISOLATION_READ_UNCOMMITTED:\n                isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED;\n                break;\n            case ISOLATION_REPEATABLE_READ:\n                isolation = DbTransaction"}, {"ID": 890, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { try { return getter.invokeGetter(source); } catch (Exception ex) { throw new JsonException(ex); } } return null; }\n\n    ### Response:", "ground_truth": "Reads property using property descriptor.", "predict": "/**\r\n     * Reads the value of a property from the given source object using the given property descriptor.\r\n     *\r\n     * @param source the source object to read the property from\r\n     * @param propertyDescriptor the property descriptor to use for reading the property\r\n     * @return the value of the property, or null if the property is not readable\r\n     * @throws JsonException if an error occurs while reading the property\r\n     */\r\n    private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 891, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void putAll(final Map t) { for (Object o : t.entrySet()) { Map.Entry e = (Map.Entry) o; put(e.getKey(), e.getValue()); } }\n\n    ### Response:", "ground_truth": "Copies all of the mappings from the specified map to this one.\nThese mappings replace any mappings that this map had for any of the\nkeys currently in the specified Map.\n\n@param t Mappings to be stored in this map.", "predict": "/**\r\n     * Copies all of the mappings from the specified map to this map.\r\n     *\r\n     * @param t mappings to be stored in this map\r\n     */\r\n    @Override public void putAll(final Map t) {\r\n        for (Object o : t.entrySet()) {\r\n            Map.Entry e = (Map.Entry) o;\r\n            put(e.getKey(), e.getValue());\r\n        }\r\n    }"}, {"ID": 892, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; }\n\n    ### Response:", "ground_truth": "Appends other buffer to this one.", "predict": "/**\r\n     * Appends the contents of the given buffer to the end of this buffer.\r\n     * \r\n     * @param buffer the buffer to append\r\n     * @return this buffer\r\n     */\r\n    public Buffer append(final Buffer buffer) {\r\n        if (buffer.list.isEmpty()) { // nothing to append\r\n            return buffer;\r\n        }\r\n        list.addAll(buffer.list);\r\n        last = buffer.last;\r\n        size += buffer.size;\r\n        return this;\r\n    }"}, {"ID": 893, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final Writer writer) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] array = fastByteBuffer.toArray(); writer.write(new String(array, StringPool.ISO_8859_1)); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1); } finally { StreamUtil.close(inputStream); } } } }\n\n    ### Response:", "ground_truth": "Writes content to the writer.", "predict": "/**\r\n     * Writes the contents of this buffer to the specified writer.\r\n     *\r\n     * @param writer the writer to write to\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void writeTo(final Writer writer) throws IOException {\r\n        for (Object o : list) {\r\n            if (o instanceof FastByteBuffer) {\r\n                FastByteBuffer fastByteBuffer = (FastByteBuffer) o;\r\n                byte[] array = fastByteBuffer.toArray();\r\n                writer.write(new String(array, StringPool.ISO_8859_1));\r\n            } else if (o instanceof Uploadable) {\r\n                Uploadable uploadable = (Uploadable) o;\r\n                InputStream inputStream = uploadable.openInputStream();\r\n                try {\r\n                    StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1);\r\n                } finally {\r\n                    StreamUtil.close(inputStream);\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 894, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final OutputStream out) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; out.write(fastByteBuffer.toArray()); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, out); } finally { StreamUtil.close(inputStream); } } } }\n\n    ### Response:", "ground_truth": "Writes content to the output stream.", "predict": "/**\r\n     * Writes the contents of the list to the specified output stream.\r\n     *\r\n     * @param out the output stream to write to\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void writeTo(final OutputStream out) throws IOException {\r\n        for (Object o : list) {\r\n            if (o instanceof FastByteBuffer) {\r\n                FastByteBuffer fastByteBuffer = (FastByteBuffer) o;\r\n                out.write(fastByteBuffer.toArray());\r\n            } else if (o instanceof Uploadable) {\r\n                Uploadable uploadable = (Uploadable) o;\r\n                InputStream inputStream = uploadable.openInputStream();\r\n                try {\r\n                    StreamUtil.copy(inputStream, out);\r\n                } finally {\r\n                    StreamUtil.close(inputStream);\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 895, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException { // start final int size = size(); final int callbackSize = progressListener.callbackSize(size); int count = 0; // total count int step = 0; // step is offset in current chunk progressListener.transferred(count); // loop for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] bytes = fastByteBuffer.toArray(); int offset = 0; while (offset < bytes.length) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the bytes array if (offset + chunk > bytes.length) { chunk = bytes.length - offset; } // writes the chunk out.write(bytes, offset, chunk); offset += chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); int remaining = uploadable.getSize(); try { while (remaining > 0) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the remaining size if (chunk > remaining) { chunk = remaining; } // writes remaining chunk StreamUtil.copy(inputStream, out, chunk); remaining -= chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } finally { StreamUtil.close(inputStream); } } } // end if (step != 0) { progressListener.transferred(count); } }\n\n    ### Response:", "ground_truth": "Writes content to the output stream, using progress listener to track the sending progress.", "predict": "/**\n     * Writes the content of this request to the given output stream.\n     * \n     * @param out\n     *            the output stream to write to\n     * @param progressListener\n     *            the progress listener to notify of progress\n     * @throws IOException\n     *             if an I/O error occurs\n     */\n    public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException {"}, {"ID": 896, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getString(final String key) { CharSequence cs = (CharSequence) map.get(key); return cs == null ? null : cs.toString(); }\n\n    ### Response:", "ground_truth": "Returns the string value with the specified key.", "predict": "/**\r\n     * This method retrieves the value of the given key from the map and returns it as a string.\r\n     * \r\n     * @param key The key to retrieve the value for.\r\n     * @return The value of the key as a string, or null if the key is not present in the map.\r\n     */\r\n    public String getString(final String key) {\r\n        // code to retrieve the value of the key from the map and return it as a string\r\n    }"}, {"ID": 897, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Integer getInteger(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Integer) { return (Integer) number; } return number.intValue(); }\n\n    ### Response:", "ground_truth": "returns the integer value with the specified key.", "predict": "/**\r\n     * This method retrieves an Integer value from the map based on the given key.\r\n     * \r\n     * @param key The key to retrieve the Integer value for.\r\n     * @return The Integer value associated with the given key, or null if no value is found or the value is not an Integer.\r\n     */\r\n    public Integer getInteger(final String key) {\r\n        // Code goes here\r\n    }"}, {"ID": 898, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Long getLong(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Long) { return (Long) number; } return number.longValue(); }\n\n    ### Response:", "ground_truth": "Returns the long value with the specified key.", "predict": "/**\r\n     * Retrieves the value associated with the given key as a Long.\r\n     *\r\n     * @param key the key to retrieve the value for\r\n     * @return the value associated with the given key as a Long, or null if the key is not present or the value is not a Long\r\n     */\r\n    public Long getLong(final String key) {\r\n        Number number = (Number) map.get(key);\r\n        if (number == null) {\r\n            return null;\r\n        }\r\n        if (number instanceof Long) {\r\n            return (Long) number;\r\n        }\r\n        return number.longValue();\r\n    }"}, {"ID": 899, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Double getDouble(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Double) { return (Double) number; } return number.doubleValue(); }\n\n    ### Response:", "ground_truth": "Returns the double value with the specified key.", "predict": "/**\r\n     * This method retrieves a Double value from the map based on the given key.\r\n     * \r\n     * @param key The key to retrieve the Double value for.\r\n     * @return The Double value associated with the given key, or null if no value is found.\r\n     */\r\n    public Double getDouble(final String key) {\r\n        Number number = (Number) map.get(key);\r\n        if (number == null) {\r\n            return null;\r\n        }\r\n        if (number instanceof Double) {\r\n            return (Double) number;\r\n        }\r\n        return number.doubleValue();\r\n    }"}, {"ID": 900, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Float getFloat(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Float) { return (Float) number; } return number.floatValue(); }\n\n    ### Response:", "ground_truth": "Returns the float value with the specified key.", "predict": "/**\r\n     * Returns the float value associated with the given key in the map.\r\n     * \r\n     * @param key the key to look up in the map\r\n     * @return the float value associated with the key, or null if the key is not present or the value is not a float\r\n     */\r\n    public Float getFloat(final String key) {\r\n        Number number = (Number) map.get(key);\r\n        if (number == null) {\r\n            return null;\r\n        }\r\n        if (number instanceof Float) {\r\n            return (Float) number;\r\n        }\r\n        return number.floatValue();\r\n    }"}, {"ID": 901, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T> T getValue(final String key) { T val = (T) map.get(key); if (val instanceof Map) { return (T) new JsonObject((Map) val); } if (val instanceof List) { return (T) new JsonArray((List) val); } return val; }\n\n    ### Response:", "ground_truth": "Returns the value with the specified key, as an object.", "predict": "/**\r\n     * This method retrieves the value associated with the given key from the map.\r\n     * If the value is a map, it is converted to a JsonObject. If the value is a list, it is converted to a JsonArray.\r\n     * \r\n     * @param key the key to retrieve the value for\r\n     * @return the value associated with the given key\r\n     */\r\n    public <T> T getValue(final String key) {\r\n        T val = (T) map.get(key);\r\n        if (val instanceof Map) {\r\n            return (T) new JsonObject((Map) val);\r\n        } else if (val instanceof List) {\r\n            return (T) new JsonArray((List) val);\r\n        }\r\n        return val;\r\n    }"}, {"ID": 902, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonObject put(final String key, final String value) { Objects.requireNonNull(key); map.put(key, value); return this; }\n\n    ### Response:", "ground_truth": "Puts a string into the JSON object with the specified key.", "predict": "/**\r\n     * Adds a key-value pair to the JsonObject.\r\n     *\r\n     * @param key   the key to be added\r\n     * @param value the value to be added\r\n     * @return the updated JsonObject\r\n     * @throws NullPointerException if the key is null\r\n     */\r\n    public JsonObject put(final String key, final String value) {\r\n        Objects.requireNonNull(key);\r\n        map.put(key, value);\r\n        return this;\r\n    }"}, {"ID": 903, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useFolder(final String folderName) { closeFolderIfOpened(folder); try { this.folderName = folderName; this.folder = getService().getFolder(folderName); try { folder.open(Folder.READ_WRITE); } catch (final MailException ignore) { folder.open(Folder.READ_ONLY); } } catch (final MessagingException msgexc) { throw new MailException(\"Failed to connect to folder: \" + folderName, msgexc); } }\n\n    ### Response:", "ground_truth": "Opens new folder and closes previously opened folder.\n\n@param folderName Folder to open", "predict": "/**\r\n     * This method is used to open a folder in the mail server.\r\n     * \r\n     * @param folderName The name of the folder to be opened.\r\n     * @throws MailException If there is an error while opening the folder.\r\n     */\r\n    public void useFolder(final String folderName) {\r\n        // Code to close the folder if it is already opened\r\n        closeFolderIfOpened(folder);\r\n\r\n        try {\r\n            // Assigning the folder name to the instance variable\r\n            this.folderName = folderName;\r\n\r\n            // Getting the folder object from the mail server\r\n            this.folder = getService().getFolder(folderName);\r\n\r\n            // Opening the folder in read-write mode\r\n            folder.open(Folder.READ_WRITE);\r\n        } catch (final MessagingException msgexc) {\r\n            try {\r\n                // If the folder cannot be opened in read-write mode, opening it in read-only mode\r\n                folder.open(Folder.READ_ONLY);\r\n            } catch (final MessagingException ignore) {\r\n                // If the folder cannot be"}, {"ID": 904, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    ReceivedEmail[] receiveMessages( final EmailFilter filter, final Flags flagsToSet, final Flags flagsToUnset, final boolean envelope, final Consumer<Message[]> processedMessageConsumer) { useAndOpenFolderIfNotSet(); final Message[] messages; try { if (filter == null) { messages = folder.getMessages(); } else { messages = folder.search(filter.getSearchTerm()); } if (messages.length == 0) { return ReceivedEmail.EMPTY_ARRAY; } if (envelope) { final FetchProfile fetchProfile = new FetchProfile(); fetchProfile.add(FetchProfile.Item.ENVELOPE); fetchProfile.add(FetchProfile.Item.FLAGS); folder.fetch(messages, fetchProfile); } // process messages final ReceivedEmail[] emails = new ReceivedEmail[messages.length]; for (int i = 0; i < messages.length; i++) { final Message msg = messages[i]; // we need to parse message BEFORE flags are set! emails[i] = new ReceivedEmail(msg, envelope, attachmentStorage); if (!EmailUtil.isEmptyFlags(flagsToSet)) { emails[i].flags(flagsToSet); msg.setFlags(flagsToSet, true); } if (!EmailUtil.isEmptyFlags(flagsToUnset)) { emails[i].flags().remove(flagsToUnset); msg.setFlags(flagsToUnset, false); } if (EmailUtil.isEmptyFlags(flagsToSet) && !emails[i].isSeen()) { msg.setFlag(Flags.Flag.SEEN, false); } } if (processedMessageConsumer != null) { processedMessageConsumer.accept(messages); } // if messages were marked to be deleted, we need to expunge the folder if (!EmailUtil.isEmptyFlags(flagsToSet)) { if (flagsToSet.contains(Flags.Flag.DELETED)) { folder.expunge(); } } return emails; } catch (final MessagingException msgexc) { throw new MailException(\"Failed to fetch messages\", msgexc); } }\n\n    ### Response:", "ground_truth": "The main email receiving method.", "predict": "/**\r\n     * This method receives messages from the email folder based on the provided filter, sets the provided flags on the messages, and returns an array of ReceivedEmail objects.\r\n     * \r\n     * @param filter the filter to use to search for messages\r\n     * @param flagsToSet the flags to set on the messages\r\n     * @param flagsToUnset the flags to unset on the messages\r\n     * @param envelope whether to fetch the envelope of the messages\r\n     * @param processedMessageConsumer a consumer that will be called with the array of processed messages\r\n     * @return an array of ReceivedEmail objects representing the received messages\r\n     * @throws MailException if there is an error fetching or processing the messages\r\n     */\r\n    public ReceivedEmail[] receiveMessages(final EmailFilter filter, final Flags flagsToSet, final Flags flagsToUnset, final boolean envelope, final Consumer<Message[]> processedMessageConsumer) {\r\n        useAndOpenFolderIfNotSet();\r\n        final Message[] messages;\r\n        try {\r\n            if (filter == null) {\r\n                messages = folder.getMessages();\r\n            } else"}, {"ID": 905, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateEmailFlags(final ReceivedEmail receivedEmail) { useAndOpenFolderIfNotSet(); try { folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true); } catch (MessagingException mex) { throw new MailException(\"Failed to fetch messages\", mex); } }\n\n    ### Response:", "ground_truth": "Updates the email flags on the server.", "predict": "/**\r\n     * Updates the email flags for the given email.\r\n     * \r\n     * @param receivedEmail the email to update flags for\r\n     * @throws MailException if the email flags could not be updated\r\n     */\r\n    public void updateEmailFlags(final ReceivedEmail receivedEmail) {\r\n        useAndOpenFolderIfNotSet();\r\n        try {\r\n            folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(), true);\r\n        } catch (MessagingException mex) {\r\n            throw new MailException(\"Failed to fetch messages\", mex);\r\n        }\r\n    }"}, {"ID": 906, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void closeFolderIfOpened(final Folder folder) { if (folder != null) { try { folder.close(true); } catch (final MessagingException ignore) { } } }\n\n    ### Response:", "ground_truth": "Closes folder if opened and expunge deleted messages.", "predict": "/**\r\n     * Closes the given folder if it is opened.\r\n     *\r\n     * @param folder the folder to close, may be null\r\n     */\r\n    protected void closeFolderIfOpened(final Folder folder) {\r\n        if (folder != null) {\r\n            try {\r\n                folder.close(true);\r\n            } catch (final MessagingException ignore) {\r\n            }\r\n        }\r\n    }"}, {"ID": 907, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    DbQueryNamedParameter lookupNamedParameter(final String name) { DbQueryNamedParameter p = rootNP; while (p != null) { if (p.equalsName(name)) { return p; } p = p.next; } return null; }\n\n    ### Response:", "ground_truth": "Lookup for named parameter.", "predict": "/**\r\n     * This method searches for a named parameter in the query hierarchy.\r\n     * \r\n     * @param name the name of the parameter to search for\r\n     * @return the named parameter if found, null otherwise\r\n     */\r\n    public DbQueryNamedParameter lookupNamedParameter(final String name) {\r\n        DbQueryNamedParameter p = rootNP;\r\n        while (p != null) {\r\n            if (p.equalsName(name)) {\r\n                return p;\r\n            }\r\n            p = p.next;\r\n        }\r\n        return null;\r\n    }"}, {"ID": 908, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String alias(final String target) { return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV); }\n\n    ### Response:", "ground_truth": "Creates alias.", "predict": "/**\r\n     * Generates an alias for the given target string by wrapping it with chevrons.\r\n     *\r\n     * @param target the target string to alias\r\n     * @return the aliased string\r\n     */\r\n    protected String alias(final String target) {\r\n        return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV);\r\n    }"}, {"ID": 909, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean validateAction(final String... profiles) { prepareValidator(); vtor.useProfiles(profiles); vtor.validate(this); vtor.resetProfiles(); List<Violation> violations = vtor.getViolations(); return violations == null; }\n\n    ### Response:", "ground_truth": "Validates action. Profiles are reset after the invocation.\n@return true if validation is successful, otherwise returns false", "predict": "/**\r\n     * Validates the current object against the given profiles.\r\n     * \r\n     * @param profiles the profiles to validate against\r\n     * @return true if the object is valid, false otherwise\r\n     */\r\n    protected boolean validateAction(final String... profiles) {\r\n        prepareValidator();\r\n        vtor.useProfiles(profiles);\r\n        vtor.validate(this);\r\n        vtor.resetProfiles();\r\n        List<Violation> violations = vtor.getViolations();\r\n        return violations == null;\r\n    }"}, {"ID": 910, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addViolation(final String name, final Object invalidValue) { prepareValidator(); vtor.addViolation(new Violation(name, this, invalidValue)); }\n\n    ### Response:", "ground_truth": "Adds action violation.", "predict": "/**\r\n     * Adds a violation to the validator.\r\n     * \r\n     * @param name the name of the violation\r\n     * @param invalidValue the invalid value\r\n     */\r\n    protected void addViolation(final String name, final Object invalidValue) {\r\n        prepareValidator();\r\n        vtor.addViolation(new Violation(name, this, invalidValue));\r\n    }"}, {"ID": 911, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RawData as(final String mimeOrExtension) { if (mimeOrExtension.contains(StringPool.SLASH)) { this.mimeType = mimeOrExtension; } else { this.mimeType = MimeTypes.getMimeType(mimeOrExtension); } return this; }\n\n    ### Response:", "ground_truth": "Defines mime type by providing real mime type or just extension!", "predict": "/**\r\n     * Sets the MIME type of the raw data.\r\n     *\r\n     * @param mimeOrExtension the MIME type or file extension of the raw data\r\n     * @return the updated raw data object\r\n     */\r\n    public RawData as(final String mimeOrExtension) {\r\n        if (mimeOrExtension.contains(StringPool.SLASH)) {\r\n            this.mimeType = mimeOrExtension;\r\n        } else {\r\n            this.mimeType = MimeTypes.getMimeType(mimeOrExtension);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 912, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RawData downloadableAs(final String downloadFileName) { this.downloadFileName = downloadFileName; this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName)); return this; }\n\n    ### Response:", "ground_truth": "Defines download file name and mime type from the name extension.", "predict": "/**\r\n     * Sets the downloadable file name and MIME type for the current instance of the RawData class.\r\n     * \r\n     * @param downloadFileName the downloadable file name\r\n     * @return the current instance of the RawData class\r\n     */\r\n    public RawData downloadableAs(final String downloadFileName) {\r\n        this.downloadFileName = downloadFileName;\r\n        this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName));\r\n        return this;\r\n    }"}, {"ID": 913, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T setTarget(final InputStream target) { assertTargetIsNotDefined(); targetInputStream = target; targetClass = null; targetClassName = null; return _this(); }\n\n    ### Response:", "ground_truth": "Defines class input stream as a target.", "predict": "/**\n     * Sets the input stream to be used as the target for the deserialization process.\n     * \n     * @param target the input stream to be used as the target for the deserialization process.\n     * @return the current instance of the builder.\n     * @throws IllegalStateException if the target has already been defined.\n     */\n    protected T setTarget(final InputStream target) {\n        assertTargetIsNotDefined();\n        targetInputStream = target;\n        targetClass = null;\n        targetClassName = null;\n        return _this();\n    }"}, {"ID": 914, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T setTarget(final String targetName) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(targetName); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + targetName); } targetClassName = targetName; targetClass = null; } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to get stream class name: \" + targetName, ioex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines class name as a target.\nClass will not be loaded by classloader!", "predict": "/**\r\n     * Sets the target class name for the proxy.\r\n     * \r\n     * @param targetName the fully qualified class name of the target class.\r\n     * @return the proxy instance.\r\n     * @throws ProxettaException if the target class is not found or if there is an error getting the input stream for the target class.\r\n     */\r\n    protected T setTarget(final String targetName) {\r\n        assertTargetIsNotDefined();\r\n        try {\r\n            targetInputStream = ClassLoaderUtil.getClassAsStream(targetName);\r\n            if (targetInputStream == null) {\r\n                throw new ProxettaException(\"Target class not found: \" + targetName);\r\n            }\r\n            targetClassName = targetName;\r\n            targetClass = null;\r\n        } catch (IOException ioex) {\r\n            StreamUtil.close(targetInputStream);\r\n            throw new ProxettaException(\"Unable to get stream class name: \" + targetName, ioex);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 915, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T setTarget(final Class target) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(target); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + target.getName()); } targetClass = target; targetClassName = target.getName(); } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines class as a target.", "predict": "/**\r\n     * Sets the target class for the proxy.\r\n     * \r\n     * @param target the target class for the proxy.\r\n     * @return this instance of the proxy.\r\n     * @throws ProxettaException if the target class cannot be loaded or streamed.\r\n     */\r\n    public T setTarget(final Class target) {\r\n        assertTargetIsNotDefined();\r\n        try {\r\n            targetInputStream = ClassLoaderUtil.getClassAsStream(target);\r\n            if (targetInputStream == null) {\r\n                throw new ProxettaException(\"Target class not found: \" + target.getName());\r\n            }\r\n            targetClass = target;\r\n            targetClassName = target.getName();\r\n        } catch (IOException ioex) {\r\n            StreamUtil.close(targetInputStream);\r\n            throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 916, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void process() { if (targetInputStream == null) { throw new ProxettaException(\"Target missing: \" + targetClassName); } // create class reader final ClassReader classReader; try { classReader = new ClassReader(targetInputStream); } catch (IOException ioex) { throw new ProxettaException(\"Error reading class input stream\", ioex); } // reads information final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader()); classReader.accept(targetClassInfoReader, 0); this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES); // create proxy if (log.isDebugEnabled()) { log.debug(\"processing: \" + classReader.getClassName()); } WorkData wd = process(classReader, targetClassInfoReader); // store important data proxyApplied = wd.proxyApplied; proxyClassName = wd.thisReference.replace('/', '.'); }\n\n    ### Response:", "ground_truth": "Reads the target and creates destination class.", "predict": "/**\r\n     * Processes the given class.\r\n     * \r\n     * @throws ProxettaException\r\n     *             if an error occurs during processing\r\n     */\r\n    protected WorkData process() throws ProxettaException {\r\n        if (targetInputStream == null) {\r\n            throw new ProxettaException(\"Target missing: \" + targetClassName);\r\n        }\r\n        // create class reader\r\n        ClassReader classReader;\r\n        try {\r\n            classReader = new ClassReader(targetInputStream);\r\n        } catch (IOException ioex) {\r\n            throw new ProxettaException(\"Error reading class input stream\", ioex);\r\n        }\r\n        // reads information\r\n        TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader());\r\n        classReader.accept(targetClassInfoReader, 0);\r\n        this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);\r\n        // create proxy\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"processing: \" + classReader"}, {"ID": 917, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] create() { process(); byte[] result = toByteArray(); dumpClassInDebugFolder(result); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } return null; } if (log.isDebugEnabled()) { log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName)); } return result; }\n\n    ### Response:", "ground_truth": "Returns byte array of created class.", "predict": "/**\r\n     * Creates a proxy instance of the target class.\r\n     * \r\n     * @return the proxy instance\r\n     */\r\n    public byte[] create() {\r\n        process();\r\n        byte[] result = toByteArray();\r\n        dumpClassInDebugFolder(result);\r\n        if ((!proxetta.isForced()) && (!isProxyApplied())) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName));\r\n            }\r\n            return null;\r\n        }\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName));\r\n        }\r\n        return result;\r\n    }"}, {"ID": 918, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class define() { process(); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } if (targetClass != null) { return targetClass; } if (targetClassName != null) { try { return ClassLoaderUtil.loadClass(targetClassName); } catch (ClassNotFoundException cnfex) { throw new ProxettaException(cnfex); } } } if (log.isDebugEnabled()) { log.debug(\"Proxy created: \" + StringUtil.toSafeString(targetClassName)); } try { ClassLoader classLoader = proxetta.getClassLoader(); if (classLoader == null) { classLoader = ClassLoaderUtil.getDefaultClassLoader(); if ((classLoader == null) && (targetClass != null)) { classLoader = targetClass.getClassLoader(); } } final byte[] bytes = toByteArray(); dumpClassInDebugFolder(bytes); return DefineClass.of(getProxyClassName(), bytes, classLoader); } catch (Exception ex) { throw new ProxettaException(\"Class definition failed\", ex); } }\n\n    ### Response:", "ground_truth": "Defines class.", "predict": "/**\r\n     * Defines the proxy class.\r\n     * \r\n     * @return the proxy class\r\n     * @throws ProxettaException\r\n     *             if the class definition fails\r\n     */\r\n    public Class define() throws ProxettaException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 919, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object newInstance() { Class type = define(); try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new ProxettaException(\"Invalid Proxetta class\", ex); } }\n\n    ### Response:", "ground_truth": "Creates new instance of created class.\nAssumes default no-arg constructor.", "predict": "/**\r\n     * Creates a new instance of the proxetta class.\r\n     * \r\n     * @return the new instance of the proxetta class.\r\n     * @throws ProxettaException if the proxetta class is invalid.\r\n     */\r\n    public Object newInstance() {\r\n        Class type = define();\r\n        try {\r\n            return ClassUtil.newInstance(type);\r\n        } catch (Exception ex) {\r\n            throw new ProxettaException(\"Invalid Proxetta class\", ex);\r\n        }\r\n    }"}, {"ID": 920, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void dumpClassInDebugFolder(final byte[] bytes) { File debugFolder = proxetta.getDebugFolder(); if (debugFolder == null) { return; } if (!debugFolder.exists() || !debugFolder.isDirectory()) { log.warn(\"Invalid debug folder: \" + debugFolder); } String fileName = proxyClassName; if (fileName == null) { fileName = \"proxetta-\" + System.currentTimeMillis(); } fileName += \".class\"; File file = new File(debugFolder, fileName); try { FileUtil.writeBytes(file, bytes); } catch (IOException ioex) { log.warn(\"Error writing class as \" + file, ioex); } }\n\n    ### Response:", "ground_truth": "Writes created class content to output folder for debugging purposes.", "predict": "/**\r\n     * Dumps the class bytes to a file in the debug folder.\r\n     * \r\n     * @param bytes\r\n     *            the class bytes to write to the file.\r\n     */\r\n    protected void dumpClassInDebugFolder(final byte[] bytes) {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 921, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T from(final String personalName, final String from) { return from(new EmailAddress(personalName, from)); }\n\n    ### Response:", "ground_truth": "Sets the FROM address by providing personal name and address.\n\n@param personalName personal name.\n@param from         email address.\n@return this\n@see #from(EmailAddress)", "predict": "/**\r\n     * Creates a new instance of the type T from the given personal name and from email address.\r\n     * \r\n     * @param personalName the personal name of the sender\r\n     * @param from the from email address of the message\r\n     * @return a new instance of the type T\r\n     */\r\n    public T from(final String personalName, final String from) { return from(new EmailAddress(personalName, from)); }"}, {"ID": 922, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T to(final EmailAddress to) { this.to = ArraysUtil.append(this.to, to); return _this(); }\n\n    ### Response:", "ground_truth": "Appends TO address.\n\n@param to {@link EmailAddress} to add.\n@return this", "predict": "/**\n     * Adds an email address to the \"to\" list.\n     *\n     * @param to the email address to add\n     * @return the updated Email object\n     */\n    public T to(final EmailAddress to) {\n        this.to = ArraysUtil.append(this.to, to);\n        return _this();\n    }"}, {"ID": 923, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T to(final String personalName, final String to) { return to(new EmailAddress(personalName, to)); }\n\n    ### Response:", "ground_truth": "Appends TO address by personal name and email address.\n\n@param personalName personal name.\n@param to           email address.\n@return this\n@see #to(EmailAddress)", "predict": "/**\r\n     * Converts the object to the specified type.\r\n     * \r\n     * @param <T> the type to convert to\r\n     * @param personalName the personal name of the recipient\r\n     * @param to the email address of the recipient\r\n     * @return the converted object\r\n     */\r\n    public T to(final String personalName, final String to) { return to(new EmailAddress(personalName, to)); }"}, {"ID": 924, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T replyTo(final EmailAddress... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends REPLY-TO addresses.\n\n@param replyTo vararg of {@link EmailAddress}es to set.\n@return this", "predict": "/**\n     * Sets the Reply-To email addresses for this email.\n     *\n     * @param replyTo the Reply-To email addresses for this email.\n     * @return this email object.\n     */\n    public T replyTo(final EmailAddress... replyTo) {\n        this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo));\n        return _this();\n    }"}, {"ID": 925, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T cc(final EmailAddress... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends CC addresses.\n\n@param ccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": "/**\r\n     * Adds the given email addresses to the CC list.\r\n     *\r\n     * @param ccs the email addresses to add to the CC list\r\n     * @return this instance for chaining\r\n     */\r\n    public T cc(final EmailAddress... ccs) {\r\n        this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs));\r\n        return _this();\r\n    }"}, {"ID": 926, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T textMessage(final String text, final String encoding) { return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding)); }\n\n    ### Response:", "ground_truth": "Adds plain message text.\n\n@param text     The text to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": "/**\r\n     * Sends a text message to the specified recipient using the specified encoding.\r\n     * \r\n     * @param text the text to send\r\n     * @param encoding the encoding to use for the text\r\n     * @return the message that was sent\r\n     */\r\n    public T textMessage(final String text, final String encoding) {\r\n        return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding));\r\n    }"}, {"ID": 927, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); }\n\n    ### Response:", "ground_truth": "Adds HTML message.\n\n@param html     The HTML to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": "/**\r\n     * Generates an email message with the given HTML content and encoding.\r\n     *\r\n     * @param html the HTML content of the email message\r\n     * @param encoding the encoding of the HTML content\r\n     * @return the generated email message\r\n     */\r\n    public T htmlMessage(final String html, final String encoding) {\r\n        return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding));\r\n    }"}, {"ID": 928, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T header(final String name, final String value) { headers.put(name, value); return _this(); }\n\n    ### Response:", "ground_truth": "Sets header value.\n\n@param name  The name of the header.\n@param value The value of the header.\n@return this", "predict": "/**\r\n     * Adds a header to the request.\r\n     *\r\n     * @param name the name of the header\r\n     * @param value the value of the header\r\n     * @return the current request object\r\n     */\r\n    public T header(final String name, final String value) { headers.put(name, value); return _this(); }"}, {"ID": 929, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String get(final String name, final String defaultValue) { Objects.requireNonNull(name); String value = null; try { if (System.getSecurityManager() == null) { value = System.getProperty(name); } else { value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name)); } } catch (Exception ignore) { } if (value == null) { return defaultValue; } return value; }\n\n    ### Response:", "ground_truth": "Returns system property. If key is not available, returns the default value.", "predict": "/**\r\n     * Retrieves the system property with the specified name.\r\n     *\r\n     * @param name the property name.\r\n     * @param defaultValue the default value.\r\n     * @return the property value, or the default value if the property is not found.\r\n     * @throws NullPointerException if the name is null.\r\n     */\r\n    public static String get(final String name, final String defaultValue) {\r\n        Objects.requireNonNull(name);\r\n        String value = null;\r\n        try {\r\n            if (System.getSecurityManager() == null) {\r\n                value = System.getProperty(name);\r\n            } else {\r\n                value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name));\r\n            }\r\n        } catch (Exception ignore) {\r\n        }\r\n        if (value == null) {\r\n            return defaultValue;\r\n        }\r\n        return value;\r\n    }"}, {"ID": 930, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean getBoolean(final String name, final boolean defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); switch (value) { case \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true; case \"false\": case \"no\" : case \"0\" : case \"off\" : return false; default: return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as boolean.", "predict": "/**\r\n     * Retrieves a boolean value from the system properties or environment variables.\r\n     * \r\n     * @param name the name of the property or environment variable\r\n     * @param defaultValue the default value to return if the property or environment variable is not found or cannot be parsed as a boolean\r\n     * @return the boolean value of the property or environment variable, or the default value if it is not found or cannot be parsed as a boolean\r\n     */\r\n    public static boolean getBoolean(final String name, final boolean defaultValue) {\r\n        String value = get(name);\r\n        if (value == null) {\r\n            return defaultValue;\r\n        }\r\n        value = value.trim().toLowerCase();\r\n        switch (value) {\r\n            case \"true\":\r\n            case \"yes\":\r\n            case \"1\":\r\n            case \"on\":\r\n                return true;\r\n            case \"false\":\r\n            case \"no\":\r\n            case \"0\":\r\n            case \"off\":\r\n                return false;\r\n            default:\r\n                return defaultValue;\r\n        }\r\n    }"}, {"ID": 931, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getInt(final String name, final int defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Integer.parseInt(value); } catch (NumberFormatException nfex) { return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as an int.", "predict": "/**\r\n     * Retrieves the value of a system property as an integer.\r\n     * \r\n     * @param name the name of the system property\r\n     * @param defaultValue the default value to use if the property is not set or cannot be parsed as an integer\r\n     * @return the integer value of the system property, or the default value if the property is not set or cannot be parsed as an integer\r\n     */\r\n    public static long getInt(final String name, final int defaultValue) {\r\n        String value = get(name);\r\n        if (value == null) {\r\n            return defaultValue;\r\n        }\r\n        value = value.trim().toLowerCase();\r\n        try {\r\n            return Integer.parseInt(value);\r\n        } catch (NumberFormatException nfex) {\r\n            return defaultValue;\r\n        }\r\n    }"}, {"ID": 932, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getLong(final String name, final long defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Long.parseLong(value); } catch (NumberFormatException nfex) { return defaultValue; } }\n\n    ### Response:", "ground_truth": "Returns system property as a long.", "predict": "/**\r\n     * Retrieves a long value from the system properties or returns the default value if the property is not found or cannot be parsed as a long.\r\n     * \r\n     * @param name the name of the system property to retrieve\r\n     * @param defaultValue the default value to return if the property is not found or cannot be parsed as a long\r\n     * @return the long value of the system property or the default value if the property is not found or cannot be parsed as a long\r\n     */\r\n    public static long getLong(final String name, final long defaultValue) {\r\n        String value = get(name);\r\n        if (value == null) {\r\n            return defaultValue;\r\n        }\r\n        value = value.trim().toLowerCase();\r\n        try {\r\n            return Long.parseLong(value);\r\n        } catch (NumberFormatException nfex) {\r\n            return defaultValue;\r\n        }\r\n    }"}, {"ID": 933, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    MethodParameter[] getResolvedParameters() { if (paramExtractor == null) { return MethodParameter.EMPTY_ARRAY; } if (!paramExtractor.debugInfoPresent) { throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName); } return paramExtractor.getMethodParameters(); }\n\n    ### Response:", "ground_truth": "Returns method parameters once when method is parsed.\nIf method has no parameters, an empty array is returned.", "predict": "/**\r\n     * Returns the resolved method parameters for the method.\r\n     *\r\n     * @return the resolved method parameters for the method.\r\n     * @throws ParamoException if parameter names are not available for the method.\r\n     */\r\n    public MethodParameter[] getResolvedParameters() {\r\n        if (paramExtractor == null) {\r\n            return MethodParameter.EMPTY_ARRAY;\r\n        }\r\n        if (!paramExtractor.debugInfoPresent) {\r\n            throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName);\r\n        }\r\n        return paramExtractor.getMethodParameters();\r\n    }"}, {"ID": 934, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) { if ((value == null) && jsonContext.isExcludeNulls()) { return count; } if (key != null) { currentPath.push(key.toString()); } else { currentPath.push(StringPool.NULL); } // check if we should include the field boolean include = true; if (value != null) { // + all collections are not serialized by default include = jsonContext.matchIgnoredPropertyTypes(value.getClass(), false, include); // + path queries: excludes/includes include = jsonContext.matchPathToQueries(include); } // done if (!include) { currentPath.pop(); return count; } if (key == null) { jsonContext.pushName(null, count > 0); } else { jsonContext.pushName(key.toString(), count > 0); } jsonContext.serialize(value); if (jsonContext.isNamePopped()) { count++; } currentPath.pop(); return count; }\n\n    ### Response:", "ground_truth": "Serializes key and a value.", "predict": "/**\n     * Serializes a key-value pair to the JSON output.\n     *\n     * @param jsonContext the JSON context\n     * @param currentPath the current path in the object graph\n     * @param key the key of the key-value pair\n     * @param value the value of the key-value pair\n     * @param count the current count of key-value pairs serialized\n     * @return the updated count of key-value pairs serialized\n     */\n    protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) { }"}, {"ID": 935, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String lookupAlias(final String alias) { String value = actionsManager.lookupPathAlias(alias); if (value == null) { ActionRuntime cfg = actionsManager.lookup(alias); if (cfg != null) { value = cfg.getActionPath(); } } return value; }\n\n    ### Response:", "ground_truth": "Lookups value as an alias and, if not found, as a default alias.", "predict": "/**\r\n     * This method is used to lookup the alias and return the corresponding action path.\r\n     * \r\n     * @param alias\r\n     *            The alias to be looked up.\r\n     * @return The action path corresponding to the alias.\r\n     */\r\n    protected String lookupAlias(final String alias) {\r\n        String value = actionsManager.lookupPathAlias(alias);\r\n        if (value == null) {\r\n            ActionRuntime cfg = actionsManager.lookup(alias);\r\n            if (cfg != null) {\r\n                value = cfg.getActionPath();\r\n            }\r\n        }\r\n        return value;\r\n    }"}, {"ID": 936, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveAlias(final String value) { final StringBuilder result = new StringBuilder(value.length()); int i = 0; int len = value.length(); while (i < len) { int ndx = value.indexOf('<', i); if (ndx == -1) { // alias markers not found if (i == 0) { // try whole string as an alias String alias = lookupAlias(value); return (alias != null ? alias : value); } else { result.append(value.substring(i)); } break; } // alias marked found result.append(value.substring(i, ndx)); ndx++; int ndx2 = value.indexOf('>', ndx); String aliasName = (ndx2 == -1 ? value.substring(ndx) : value.substring(ndx, ndx2)); // process alias String alias = lookupAlias(aliasName); if (alias != null) { result.append(alias); } else { // alias not found if (log.isWarnEnabled()) { log.warn(\"Alias not found: \" + aliasName); } } i = ndx2 + 1; } // fix prefix '//' - may happened when aliases are used i = 0; len = result.length(); while (i < len) { if (result.charAt(i) != '/') { break; } i++; } if (i > 1) { return result.substring(i - 1, len); } return result.toString(); }\n\n    ### Response:", "ground_truth": "Returns resolved alias result value or passed on, if alias doesn't exist.", "predict": "/**\r\n     * Resolves any alias in the given value by looking it up in the alias map.\r\n     * \r\n     * @param value the value to resolve\r\n     * @return the resolved value, or the original value if no alias was found\r\n     */\r\n    protected String resolveAlias(final String value) {\r\n        final StringBuilder result = new StringBuilder(value.length());\r\n        int i = 0;\r\n        int len = value.length();\r\n        while (i < len) {\r\n            int ndx = value.indexOf('<', i);\r\n            if (ndx == -1) {\r\n                // alias markers not found\r\n                if (i == 0) {\r\n                    // try whole string as an alias\r\n                    String alias = lookupAlias(value);\r\n                    return (alias != null ? alias : value);\r\n                } else {\r\n                    result.append(value.substring(i));\r\n                }\r\n                break;\r\n            }\r\n            // alias marked found\r\n            result.append(value.substring(i, ndx));\r\n            ndx++;\r\n            int ndx2 = value.indexOf('"}, {"ID": 937, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResultPath resolveResultPath(String path, String value) { boolean absolutePath = false; if (value != null) { // [*] resolve alias in value value = resolveAlias(value); // [*] absolute paths if (StringUtil.startsWithChar(value, '/')) { absolutePath = true; int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path = value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { path = value; value = null; } } else { // [*] resolve # in value and path int i = 0; while (i < value.length()) { if (value.charAt(i) != '#') { break; } int dotNdx = MadvocUtil.lastIndexOfSlashDot(path); if (dotNdx != -1) { // dot found path = path.substring(0, dotNdx); } i++; } if (i > 0) { // remove # from value value = value.substring(i); // [*] update path and value if (StringUtil.startsWithChar(value, '.')) { value = value.substring(1); } else { int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path += '.' + value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { if (value.length() > 0) { if (StringUtil.endsWithChar(path, '/')) { path += value; } else { path += '.' + value; } } value = null; } } } } } if (!absolutePath) { if (resultPathPrefix != null) { path = resultPathPrefix + path; } } return new ResultPath(path, value); }\n\n    ### Response:", "ground_truth": "Resolves result path.", "predict": "/**\n     * Resolves the result path for the given path and value.\n     *\n     * @param path the original path\n     * @param value the value to resolve\n     * @return the resolved result path\n     */\n    public ResultPath resolveResultPath(String path, String value) {\n        boolean absolutePath = false;\n        if (value != null) {\n            // resolve alias in value\n            value = resolveAlias(value);\n            // absolute paths\n            if (StringUtil.startsWithChar(value, '/')) {\n                absolutePath = true;\n                int dotNdx = value.indexOf(\"..\");\n                if (dotNdx != -1) {\n                    path = value.substring(0, dotNdx);\n                    value = value.substring(dotNdx + 2);\n                } else {\n                    path = value;\n                    value = null;\n                }\n            } else {\n                // resolve # in value and path\n                int i = 0;\n                while (i < value.length()) {\n                    if (value.charAt(i) !="}, {"ID": 938, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveResultPathString(final String path, final String value) { final ResultPath resultPath = resolveResultPath(path, value); final String result = resultPath.pathValue(); return resolveAlias(result); }\n\n    ### Response:", "ground_truth": "Resolves result path as a string, when parts are not important\nand when only full string matters. Additional alias resolving\non full path is done.", "predict": "/**\r\n     * This method takes in a path and a value and returns the resolved result path string.\r\n     * \r\n     * @param path The path to resolve.\r\n     * @param value The value to resolve.\r\n     * @return The resolved result path string.\r\n     */\r\n    public String resolveResultPathString(final String path, final String value) {\r\n        // TODO: Implement logic to resolve result path string.\r\n    }"}, {"ID": 939, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int lastIndexOfSlashDot(final String str) { int slashNdx = str.lastIndexOf('/'); int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); if (dotNdx == -1) { if (slashNdx == -1) { return -1; } slashNdx++; if (slashNdx < str.length() - 1) { dotNdx = slashNdx; } else { dotNdx = -1; } } return dotNdx; }\n\n    ### Response:", "ground_truth": "Locates last dot after the last slash or just slash.", "predict": "/**\r\n     * Returns the index of the last occurrence of a slash or dot in the given string, starting from the end of the string.\r\n     * If neither slash nor dot is found, returns -1.\r\n     *\r\n     * @param str the string to search in\r\n     * @return the index of the last occurrence of a slash or dot, or -1 if neither is found\r\n     */\r\n    public static int lastIndexOfSlashDot(final String str) {\r\n        int slashNdx = str.lastIndexOf('/');\r\n        int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);\r\n        if (dotNdx == -1) {\r\n            if (slashNdx == -1) {\r\n                return -1;\r\n            }\r\n            slashNdx++;\r\n            if (slashNdx < str.length() - 1) {\r\n                dotNdx = slashNdx;\r\n            } else {\r\n                dotNdx = -1;\r\n            }\r\n        }\r\n        return dotNdx;\r\n    }"}, {"ID": 940, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int lastIndexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); slashNdx++; return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); }\n\n    ### Response:", "ground_truth": "Locates last index of dot after the optional last slash.", "predict": "/**\r\n     * Returns the index of the last dot after the last slash in the given string.\r\n     * \r\n     * @param str the string to search for the last dot after the last slash\r\n     * @return the index of the last dot after the last slash, or -1 if no dot is found\r\n     */\r\n    public static int lastIndexOfDotAfterSlash(final String str) {\r\n        int slashNdx = str.lastIndexOf('/');\r\n        slashNdx++;\r\n        return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx);\r\n    }"}, {"ID": 941, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); if (slashNdx == -1) { slashNdx = 0; } return str.indexOf('.', slashNdx); }\n\n    ### Response:", "ground_truth": "Locates first dot after the last slash.", "predict": "/**\r\n     * Returns the index of the first dot after the last slash in the given string.\r\n     * If there is no slash in the string, returns the index of the first dot in the string.\r\n     * If there is no dot in the string, returns -1.\r\n     *\r\n     * @param str the string to search for a dot after a slash\r\n     * @return the index of the first dot after the last slash in the string, or -1 if there is no dot\r\n     */\r\n    public static int indexOfDotAfterSlash(final String str) {\r\n        int slashNdx = str.lastIndexOf('/');\r\n        if (slashNdx == -1) {\r\n            slashNdx = 0;\r\n        }\r\n        return str.indexOf('.', slashNdx);\r\n    }"}, {"ID": 942, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripLastCamelWord(String name) { int ndx = name.length() - 1; while (ndx >= 0) { if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) { break; } ndx--; } if (ndx >= 0) { name = name.substring(0, ndx); } return name; }\n\n    ### Response:", "ground_truth": "Removes last CamelWord", "predict": "/**\r\n     * Removes the last camel-case word from the given string.\r\n     * \r\n     * @param name the string to remove the last camel-case word from\r\n     * @return the string with the last camel-case word removed\r\n     */\r\n    public static String stripLastCamelWord(String name) {\r\n        int ndx = name.length() - 1;\r\n        while (ndx >= 0) {\r\n            if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) {\r\n                break;\r\n            }\r\n            ndx--;\r\n        }\r\n        if (ndx >= 0) {\r\n            name = name.substring(0, ndx);\r\n        }\r\n        return name;\r\n    }"}, {"ID": 943, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) { String schemaName = null; final DbTable dbTable = type.getAnnotation(DbTable.class); if (dbTable != null) { schemaName = dbTable.schema().trim(); } if ((schemaName == null) || (schemaName.length() == 0)) { schemaName = defaultSchemaName; } return schemaName; }\n\n    ### Response:", "ground_truth": "Resolves schema name from a type. Uses default schema name if not specified.", "predict": "/**\r\n     * Resolves the schema name for a given type.\r\n     * \r\n     * @param type the type to resolve the schema name for\r\n     * @param defaultSchemaName the default schema name to use if the type does not have a schema name annotation\r\n     * @return the resolved schema name\r\n     */\r\n    public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) {\r\n        String schemaName = null;\r\n        final DbTable dbTable = type.getAnnotation(DbTable.class);\r\n        if (dbTable != null) {\r\n            schemaName = dbTable.schema().trim();\r\n        }\r\n        if ((schemaName == null) || (schemaName.length() == 0)) {\r\n            schemaName = defaultSchemaName;\r\n        }\r\n        return schemaName;\r\n    }"}, {"ID": 944, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbEntityColumnDescriptor resolveColumnDescriptors( final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) { String columnName = null; boolean isId = false; Class<? extends SqlType> sqlTypeClass = null; // read ID annotation DbId dbId = null; if (property.getFieldDescriptor() != null) { dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class); } if (dbId == null && property.getReadMethodDescriptor() != null) { dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId == null && property.getWriteMethodDescriptor() != null) { dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId != null) { columnName = dbId.value().trim(); sqlTypeClass = dbId.sqlType(); isId = true; } else { DbColumn dbColumn = null; if (property.getFieldDescriptor() != null) { dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getReadMethodDescriptor() != null) { dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getWriteMethodDescriptor() != null) { dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn != null) { columnName = dbColumn.value().trim(); sqlTypeClass = dbColumn.sqlType(); } else { if (isAnnotated) { return null; } } } if (StringUtil.isEmpty(columnName)) { // default annotation value columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName()); } else { if (!columnNamingStrategy.isStrictAnnotationNames()) { columnName = columnNamingStrategy.applyToColumnName(columnName); } } if (sqlTypeClass == SqlType.class) { sqlTypeClass = null; } return new DbEntityColumnDescriptor( dbEntityDescriptor, quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()), property.getName(), property.getType(), isId, sqlTypeClass); }\n\n    ### Response:", "ground_truth": "Resolves column descriptor from property. If property is annotated value will be read\nfrom annotation. If property is not annotated, then property will be ignored\nif entity is annotated. Otherwise, column name is generated from the property name.", "predict": "/**\n     * Resolves the column descriptor for the given property.\n     * \n     * @param dbEntityDescriptor the entity descriptor\n     * @param property the property descriptor\n     * @param isAnnotated whether the property is annotated\n     * @param columnNamingStrategy the column naming strategy\n     * @return the column descriptor or null if the property is not annotated and not a database id\n     */\n    public static DbEntityColumnDescriptor resolveColumnDescriptors(final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) {\n        String columnName = null;\n        boolean isId = false;\n        Class<? extends SqlType> sqlTypeClass = null;\n\n        // read ID annotation\n        DbId dbId = null;\n        if (property.getFieldDescriptor() != null) {\n            dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class);\n        }\n        if (dbId == null && property.getReadMethodDescriptor() != null) {\n            dbId = property.getReadMethodDescriptor().getMethod()."}, {"ID": 945, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(final long[] key, final long[] tweak) { final int newNw = key.length; // only create new arrays if the value of N{w} changes (different key size) if (nw != newNw) { nw = newNw; switch (nw) { case WORDS_4: pi = PI4; rpi = RPI4; r = R4; break; case WORDS_8: pi = PI8; rpi = RPI8; r = R8; break; case WORDS_16: pi = PI16; rpi = RPI16; r = R16; break; default: throw new RuntimeException(\"Invalid threefish key\"); } this.k = new long[nw + 1]; // instantiation of these fields here for performance reasons vd = new long[nw]; // v is the intermediate value v{d} at round d ed = new long[nw]; // ed is the value of e{d} at round d fd = new long[nw]; // fd is the value of f{d} at round d ksd = new long[nw]; // ksd is the value of k{s} at round d } System.arraycopy(key, 0, this.k, 0, key.length); long knw = EXTENDED_KEY_SCHEDULE_CONST; for (int i = 0; i < nw; i++) { knw ^= this.k[i]; } this.k[nw] = knw; // set tweak values t[0] = tweak[0]; t[1] = tweak[1]; t[2] = t[0] ^ t[1]; }\n\n    ### Response:", "ground_truth": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "predict": "/**\r\n     * Initializes the Threefish cipher with the given key and tweak.\r\n     *\r\n     * @param key the key to use for encryption and decryption\r\n     * @param tweak the tweak to use for encryption and decryption\r\n     */\r\n    public void init(final long[] key, final long[] tweak) {\r\n        final int newNw = key.length; // only create new arrays if the value of N{w} changes (different key size)\r\n        if (nw != newNw) {\r\n            nw = newNw;\r\n            switch (nw) {\r\n                case WORDS_4:\r\n                    pi = PI4;\r\n                    rpi = RPI4;\r\n                    r = R4;\r\n                    break;\r\n                case WORDS_8:\r\n                    pi = PI8;\r\n                    rpi = RPI8;\r\n                    r = R8;\r\n                    break;\r\n                case WORDS_16:\r\n                    pi = PI16;\r\n                    rpi = RPI16;\r\n                    r = R16;\r\n                    break;\r\n                default:\r\n                    throw new RuntimeException(\"Invalid"}, {"ID": 946, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void mix(final int j, final int d) { y[0] = x[0] + x[1]; final long rotl = r[d % DEPTH_OF_D_IN_R][j]; // java left rotation for a long y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl)); y[1] ^= y[0]; }\n\n    ### Response:", "ground_truth": "Implementation of the MIX function.\n\n@param j the index in the rotation constants\n@param d the round", "predict": "/**\r\n     * This method takes two integers as input and mixes them using the Miyaguchi-Preneel algorithm.\r\n     * \r\n     * @param j - the index of the first integer to be mixed\r\n     * @param d - the index of the second integer to be mixed\r\n     */\r\n    private void mix(final int j, final int d) {\r\n        y[0] = x[0] + x[1];\r\n        final long rotl = r[d % DEPTH_OF_D_IN_R][j]; // java left rotation for a long\r\n        y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl));\r\n        y[1] ^= y[0];\r\n    }"}, {"ID": 947, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void demix(final int j, final int d) { y[1] ^= y[0]; final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack! // right shift x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr); x[0] = y[0] - x[1]; }\n\n    ### Response:", "ground_truth": "Implementation of the un-MIX function.", "predict": "/**\r\n     * This method demixes the input values using the provided key and the round constants.\r\n     * \r\n     * @param j the index of the round constant to use\r\n     * @param d the index of the key to use\r\n     */\r\n    private void demix(final int j, final int d) {\r\n        y[1] ^= y[0];\r\n        final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack!\r\n        // right shift x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr);\r\n        x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr);\r\n        x[0] = y[0] - x[1];\r\n    }"}, {"ID": 948, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void keySchedule(final int s) { for (int i = 0; i < nw; i++) { // just put in the main key first ksd[i] = k[(s + i) % (nw + 1)]; // don't add anything for i = 0,...,Nw - 4 if (i == nw - 3) { // second to last ksd[i] += t[s % TWEAK_VALUES]; } else if (i == nw - 2) { // first to last ksd[i] += t[(s + 1) % TWEAK_VALUES]; } else if (i == nw - 1) { // last ksd[i] += s; } } }\n\n    ### Response:", "ground_truth": "Creates the subkeys.\n\n@param s the value of the round devided by 4", "predict": "/**\r\n     * This method performs the key schedule operation on the given key.\r\n     * \r\n     * @param s the starting index of the key schedule\r\n     */\r\n    private void keySchedule(final int s) {\r\n        for (int i = 0; i < nw; i++) {\r\n            // just put in the main key first\r\n            ksd[i] = k[(s + i) % (nw + 1)];\r\n            \r\n            // don't add anything for i = 0,...,Nw - 4\r\n            if (i == nw - 3) {\r\n                // second to last\r\n                ksd[i] += t[s % TWEAK_VALUES];\r\n            } else if (i == nw - 2) {\r\n                // first to last\r\n                ksd[i] += t[(s + 1) % TWEAK_VALUES];\r\n            } else if (i == nw - 1) {\r\n                // last\r\n                ksd[i] += s;\r\n            }\r\n        }\r\n    }"}, {"ID": 949, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(final String keyMessage, final long tweak1, final long tweak2) { long[] tweak = new long[] {tweak1, tweak2}; byte[] key = new byte[blockSize / Byte.SIZE]; byte[] keyData = StringUtil.getBytes(keyMessage); System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length); init(bytesToLongs(key), tweak); }\n\n    ### Response:", "ground_truth": "Initializes cipher in a simple way.", "predict": "/**\r\n     * Initializes the cipher with the given key and tweak.\r\n     *\r\n     * @param keyMessage the key message as a string\r\n     * @param tweak1 the first tweak value\r\n     * @param tweak2 the second tweak value\r\n     */\r\n    public void init(final String keyMessage, final long tweak1, final long tweak2) {\r\n        long[] tweak = new long[] {tweak1, tweak2};\r\n        byte[] key = new byte[blockSize / Byte.SIZE];\r\n        byte[] keyData = StringUtil.getBytes(keyMessage);\r\n        System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length);\r\n        init(bytesToLongs(key), tweak);\r\n    }"}, {"ID": 950, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public byte[] encryptBlock(final byte[] content, final int offset) { long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes); long[] encryptedBlock = new long[blockSize / Long.SIZE]; blockEncrypt(contentBlock, encryptedBlock); return longsToBytes(encryptedBlock); }\n\n    ### Response:", "ground_truth": "Encrypts a block.", "predict": "/**\n     * Encrypts a block of data using the underlying block cipher algorithm.\n     *\n     * @param content the data to be encrypted.\n     * @param offset the offset in the data where the block starts.\n     * @return the encrypted data.\n     */\n    @Override\n    public byte[] encryptBlock(final byte[] content, final int offset) {\n        long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes);\n        long[] encryptedBlock = new long[blockSize / Long.SIZE];\n        blockEncrypt(contentBlock, encryptedBlock);\n        return longsToBytes(encryptedBlock);\n    }"}, {"ID": 951, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) { long[] result = new long[size >> 3]; int i8 = offset; for (int i = 0; i < result.length; i++) { result[i] = Bits.getLong(ba, i8); i8 += 8; } return result; }\n\n    ### Response:", "ground_truth": "Converts segment of byte array into long array.", "predict": "/**\r\n     * Converts a byte array to a long array.\r\n     *\r\n     * @param ba the byte array to convert\r\n     * @param offset the starting offset in the byte array\r\n     * @param size the number of bytes to convert\r\n     * @return the resulting long array\r\n     */\r\n    protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) {\r\n        long[] result = new long[size >> 3];\r\n        int i8 = offset;\r\n        for (int i = 0; i < result.length; i++) {\r\n            result[i] = Bits.getLong(ba, i8);\r\n            i8 += 8;\r\n        }\r\n        return result;\r\n    }"}, {"ID": 952, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String removeAnyBounding(final char s, final char e, final String str) { if (str == null || str.length() < 2) { return str; } if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) { return str.substring(1, str.length() - 1); } return str; }\n\n    ### Response:", "ground_truth": "If the string starts and ends with start and end char, remove them,\notherwise return the string as it was passed in.", "predict": "/**\r\n     * Removes any bounding characters (specified by the start and end characters) from the given string.\r\n     * \r\n     * @param s the start character\r\n     * @param e the end character\r\n     * @param str the input string\r\n     * @return the string with any bounding characters removed\r\n     */\r\n    private static String removeAnyBounding(final char s, final char e, final String str) {\r\n        if (str == null || str.length() < 2) {\r\n            return str;\r\n        }\r\n        if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) {\r\n            return str.substring(1, str.length() - 1);\r\n        }\r\n        return str;\r\n    }"}, {"ID": 953, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String path() { if (methref != null) { final String methodName = methref.ref(); return target.getName() + '#' + methodName; } return path; }\n\n    ### Response:", "ground_truth": "Returns path value.", "predict": "/**\r\n     * Returns the path of the method reference.\r\n     * \r\n     * @return the path of the method reference\r\n     */\r\n    public String path() {\r\n        if (methref != null) {\r\n            final String methodName = methref.ref();\r\n            return target.getName() + '#' + methodName;\r\n        }\r\n        return path;\r\n    }"}, {"ID": 954, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File zlib(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't zlib folder\"); } FileInputStream fis = new FileInputStream(file); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); String zlibFileName = file.getAbsolutePath() + ZLIB_EXT; DeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater); try { StreamUtil.copy(fis, dos); } finally { StreamUtil.close(dos); StreamUtil.close(fis); } return new File(zlibFileName); }\n\n    ### Response:", "ground_truth": "Compresses a file into zlib archive.", "predict": "/**\r\n * Compresses a file using the zlib algorithm.\r\n *\r\n * @param file the file to compress\r\n * @return the compressed file\r\n * @throws IOException if an I/O error occurs\r\n */\r\npublic static File zlib(final File file) throws IOException;"}, {"ID": 955, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File gzip(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't gzip folder\"); } FileInputStream fis = new FileInputStream(file); String gzipName = file.getAbsolutePath() + GZIP_EXT; GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(gzipName)); try { StreamUtil.copy(fis, gzos); } finally { StreamUtil.close(gzos); StreamUtil.close(fis); } return new File(gzipName); }\n\n    ### Response:", "ground_truth": "Compresses a file into gzip archive.", "predict": "/**\r\n     * Gzips a file.\r\n     * \r\n     * @param file the file to gzip\r\n     * @return the gzipped file\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static File gzip(final File file) throws IOException;"}, {"ID": 956, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File ungzip(final File file) throws IOException { String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath()); File out = new File(outFileName); out.createNewFile(); FileOutputStream fos = new FileOutputStream(out); GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file)); try { StreamUtil.copy(gzis, fos); } finally { StreamUtil.close(fos); StreamUtil.close(gzis); } return out; }\n\n    ### Response:", "ground_truth": "Decompress gzip archive.", "predict": "/**\r\n     * Unzips a gzip file to a new file with the same name as the original file, without the .gz extension.\r\n     *\r\n     * @param file the gzip file to unzip\r\n     * @return the unzipped file\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static File ungzip(final File file) throws IOException {\r\n        String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath());\r\n        File out = new File(outFileName);\r\n        out.createNewFile();\r\n        FileOutputStream fos = new FileOutputStream(out);\r\n        GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file));\r\n        try {\r\n            StreamUtil.copy(gzis, fos);\r\n        } finally {\r\n            StreamUtil.close(fos);\r\n            StreamUtil.close(gzis);\r\n        }\r\n        return out;\r\n    }"}, {"ID": 957, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static List<String> listZip(final File zipFile) throws IOException { List<String> entries = new ArrayList<>(); ZipFile zip = new ZipFile(zipFile); Enumeration zipEntries = zip.entries(); while (zipEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipEntries.nextElement(); String entryName = entry.getName(); entries.add(entryName); } return Collections.unmodifiableList(entries); }\n\n    ### Response:", "ground_truth": "Lists zip content.", "predict": "/**\r\n     * This method takes a zip file as input and returns a list of its entries.\r\n     * \r\n     * @param zipFile the zip file to be processed\r\n     * @return a list of entries in the zip file\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static List<String> listZip(final File zipFile) throws IOException {\r\n        List<String> entries = new ArrayList<>();\r\n        ZipFile zip = new ZipFile(zipFile);\r\n        Enumeration zipEntries = zip.entries();\r\n        while (zipEntries.hasMoreElements()) {\r\n            ZipEntry entry = (ZipEntry) zipEntries.nextElement();\r\n            String entryName = entry.getName();\r\n            entries.add(entryName);\r\n        }\r\n        return Collections.unmodifiableList(entries);\r\n    }"}, {"ID": 958, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException { unzip(new File(zipFile), new File(destDir), patterns); }\n\n    ### Response:", "ground_truth": "Extracts zip file content to the target directory.\n@see #unzip(java.io.File, java.io.File, String...)", "predict": "/**\r\n     * Unzips a zip file to a destination directory.\r\n     *\r\n     * @param zipFile the path to the zip file to be unzipped.\r\n     * @param destDir the path to the destination directory where the files will be unzipped.\r\n     * @param patterns an array of file name patterns to be included in the unzipping process.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException {\r\n        unzip(new File(zipFile), new File(destDir), patterns);\r\n    }"}, {"ID": 959, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException { if (!file.exists()) { throw new FileNotFoundException(file.toString()); } if (path == null) { path = file.getName(); } while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } boolean isDir = file.isDirectory(); if (isDir) { // add folder record if (!StringUtil.endsWithChar(path, '/')) { path += '/'; } } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(file.lastModified()); if (comment != null) { zipEntry.setComment(comment); } if (isDir) { zipEntry.setSize(0); zipEntry.setCrc(0); } zos.putNextEntry(zipEntry); if (!isDir) { InputStream is = new FileInputStream(file); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } } zos.closeEntry(); // continue adding if (recursive && file.isDirectory()) { boolean noRelativePath = StringUtil.isEmpty(path); final File[] children = file.listFiles(); if (children != null && children.length != 0) { for (File child : children) { String childRelativePath = (noRelativePath ? StringPool.EMPTY : path) + child.getName(); addToZip(zos, child, childRelativePath, comment, recursive); } } } }\n\n    ### Response:", "ground_truth": "Adds single entry to ZIP output stream.\n\n@param zos zip output stream\n@param file file or folder to add\n@param path relative path of file entry; if null files name will be used instead\n@param comment optional comment\n@param recursive when set to true content of added folders will be added, too", "predict": "/**\n     * Adds a file or directory to a zip output stream.\n     *\n     * @param zos the zip output stream to add to\n     * @param file the file or directory to add\n     * @param path the path to use for the file in the zip (null for the file name)\n     * @param comment the comment to add to the zip entry (null for no comment)\n     * @param recursive true to recursively add files in subdirectories, false otherwise\n     * @throws IOException if an I/O error occurs\n     */\n    public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException {\n        // implementation details elided\n    }"}, {"ID": 960, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException { while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } if (StringUtil.endsWithChar(path, '/')) { path = path.substring(0, path.length() - 1); } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(System.currentTimeMillis()); if (comment != null) { zipEntry.setComment(comment); } zos.putNextEntry(zipEntry); InputStream is = new ByteArrayInputStream(content); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } zos.closeEntry(); }\n\n    ### Response:", "ground_truth": "Adds byte content into the zip as a file.", "predict": "/**\r\n     * Adds the given content to the given zip output stream with the given path and comment.\r\n     *\r\n     * @param zos the zip output stream to add the content to\r\n     * @param content the content to add to the zip file\r\n     * @param path the path of the content in the zip file\r\n     * @param comment the comment to add to the zip entry\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException {\r\n        while (path.length() != 0 && path.charAt(0) == '/') {\r\n            path = path.substring(1);\r\n        }\r\n        if (StringUtil.endsWithChar(path, '/')) {\r\n            path = path.substring(0, path.length() - 1);\r\n        }\r\n        ZipEntry zipEntry = new ZipEntry(path);\r\n        zipEntry.setTime(System.currentTimeMillis());\r\n        if (comment != null) {\r\n            zipEntry."}, {"ID": 961, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) { final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name); if (fieldDescriptor != null) { if (!fieldDescriptor.matchDeclared(declared)) { return null; } } return fieldDescriptor; }\n\n    ### Response:", "ground_truth": "Returns field descriptor.", "predict": "/**\r\n     * Returns the {@link FieldDescriptor} for the specified field name.\r\n     * \r\n     * @param name the name of the field to retrieve the descriptor for.\r\n     * @param declared whether to retrieve the declared or the effective field descriptor.\r\n     * @return the {@link FieldDescriptor} for the specified field name, or null if no such field exists.\r\n     */\r\n    public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) {\r\n        // implementation code here\r\n    }"}, {"ID": 962, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) { PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name); if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) { return propertyDescriptor; } return null; }\n\n    ### Response:", "ground_truth": "Returns property descriptor. Declared flag is matched on both read and write\nmethods.", "predict": "/**\r\n     * Gets the property descriptor for the specified property name.\r\n     * \r\n     * @param name the name of the property to get the descriptor for\r\n     * @param declared whether to return the declared property descriptor or the default property descriptor\r\n     * @return the property descriptor for the specified property name, or null if no such property exists\r\n     */\r\n    public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) {\r\n        PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name);\r\n        if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) {\r\n            return propertyDescriptor;\r\n        }\r\n        return null;\r\n    }"}, {"ID": 963, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setRequestBundleName(final ServletRequest request, final String bundleName) { if (log.isDebugEnabled()) { log.debug(\"Bundle name for this request: \" + bundleName); } request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName); }\n\n    ### Response:", "ground_truth": "Sets bundle name for provided servlet request.", "predict": "/**\r\n     * Sets the bundle name for the given request.\r\n     * \r\n     * @param request\r\n     *            the current request\r\n     * @param bundleName\r\n     *            the bundle name to set\r\n     */\r\n    public static void setRequestBundleName(final ServletRequest request, final String bundleName) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Bundle name for this request: \" + bundleName);\r\n        }\r\n        request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName);\r\n    }"}, {"ID": 964, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void setSessionLocale(final HttpSession session, final String localeCode) { if (log.isDebugEnabled()) { log.debug(\"Locale stored to session: \" + localeCode); } Locale locale = Locale.forLanguageTag(localeCode); session.setAttribute(SESSION_LOCALE_ATTR, locale); }\n\n    ### Response:", "ground_truth": "Saves Locale to HTTP session.", "predict": "/**\r\n     * Sets the locale for the current session.\r\n     * \r\n     * @param session\r\n     *            the current session\r\n     * @param localeCode\r\n     *            the locale code to set\r\n     */\r\n    public static void setSessionLocale(final HttpSession session, final String localeCode) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Locale stored to session: \" + localeCode);\r\n        }\r\n        Locale locale = Locale.forLanguageTag(localeCode);\r\n        session.setAttribute(SESSION_LOCALE_ATTR, locale);\r\n    }"}, {"ID": 965, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Locale getSessionLocale(final HttpSession session) { Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR); return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale; }\n\n    ### Response:", "ground_truth": "Returns current locale from session.\ns", "predict": "/**\r\n     * Retrieves the locale stored in the session, or the fallback locale if the session does not contain a locale.\r\n     *\r\n     * @param session the HTTP session\r\n     * @return the locale stored in the session, or the fallback locale if the session does not contain a locale\r\n     */\r\n    public static Locale getSessionLocale(final HttpSession session) {\r\n        Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR);\r\n        return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale;\r\n    }"}, {"ID": 966, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) { beanName = beanName + '.'; List<String> list = new ArrayList<>(); for (Map.Entry<String, Object> entry : params.entrySet()) { String key = entry.getKey(); if (!key.startsWith(beanName)) { continue; } list.add(key); if (!resolveReferenceParams) { continue; } // resolve all references String value = PropertiesUtil.resolveProperty(params, key); entry.setValue(value); } if (list.isEmpty()) { return StringPool.EMPTY_ARRAY; } else { return list.toArray(new String[0]); } }\n\n    ### Response:", "ground_truth": "Returns an array of param keys that belongs to provided bean.\nOptionally resolves the value of returned parameters.", "predict": "/**\r\n     * Filters the parameters for a given bean name.\r\n     * \r\n     * @param beanName the bean name to filter for\r\n     * @param resolveReferenceParams whether to resolve reference parameters or not\r\n     * @return the filtered parameters as an array of strings\r\n     */\r\n    public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) {\r\n        beanName = beanName + '.';\r\n        List<String> list = new ArrayList<>();\r\n        for (Map.Entry<String, Object> entry : params.entrySet()) {\r\n            String key = entry.getKey();\r\n            if (!key.startsWith(beanName)) {\r\n                continue;\r\n            }\r\n            list.add(key);\r\n            if (!resolveReferenceParams) {\r\n                continue;\r\n            }\r\n            // resolve all references\r\n            String value = PropertiesUtil.resolveProperty(params, key);\r\n            entry.setValue(value);\r\n        }\r\n        if (list.isEmpty()) {\r\n            return StringPool.EMPTY_ARRAY;\r\n        } else {\r\n            return list.toArray(new String[0]);"}, {"ID": 967, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropsEntries profile(final String... profiles) { if (profiles == null) { return this; } for (String profile : profiles) { addProfiles(profile); } return this; }\n\n    ### Response:", "ground_truth": "Enables profiles to iterate.", "predict": "/**\r\n     * Adds one or more profiles to the list of profiles for this PropsEntries object.\r\n     * \r\n     * @param profiles the profiles to add\r\n     * @return this PropsEntries object\r\n     */\r\n    public PropsEntries profile(final String... profiles) {\r\n        if (profiles == null) {\r\n            return this;\r\n        }\r\n        for (String profile : profiles) {\r\n            addProfiles(profile);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 968, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getLongLittleEndian(final byte[] buf, final int offset) { return ((long) buf[offset + 7] << 56) // no mask needed | ((buf[offset + 6] & 0xffL) << 48) | ((buf[offset + 5] & 0xffL) << 40) | ((buf[offset + 4] & 0xffL) << 32) | ((buf[offset + 3] & 0xffL) << 24) | ((buf[offset + 2] & 0xffL) << 16) | ((buf[offset + 1] & 0xffL) << 8) | ((buf[offset] & 0xffL)); // no shift needed }\n\n    ### Response:", "ground_truth": "Gets a long from a byte buffer in little endian byte order.", "predict": "/**\r\n     * Gets a 64-bit long value from a byte array in little-endian byte order.\r\n     *\r\n     * @param buf the byte array to read from\r\n     * @param offset the offset in the byte array to start reading from\r\n     * @return the 64-bit long value\r\n     */\r\n    public static long getLongLittleEndian(final byte[] buf, final int offset) {\r\n        return ((long) buf[offset + 7] << 56) // no mask needed | ((buf[offset + 6] & 0xffL) << 48) | ((buf[offset + 5] & 0xffL) << 40) | ((buf[offset + 4] & 0xffL) << 32) | ((buf[offset + 3] & 0xffL) << 24) | ((buf[offset + 2] & 0xffL) << 16) | ((buf[offset + 1] & 0"}, {"ID": 969, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException { if (inputStream == null) { throw new IOException(\"Class not found\"); } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE]; int bytesRead; while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) { outputStream.write(data, 0, bytesRead); } outputStream.flush(); return outputStream.toByteArray(); } finally { if (close) { inputStream.close(); } } }\n\n    ### Response:", "ground_truth": "Reads the given input stream and returns its content as a byte array.\n\n@param inputStream an input stream.\n@param close true to close the input stream after reading.\n@return the content of the given input stream.\n@throws IOException if a problem occurs during reading.", "predict": "/**\r\n     * Reads the input stream and returns the data as a byte array.\r\n     * \r\n     * @param inputStream\r\n     *            the input stream to read from\r\n     * @param close\r\n     *            whether to close the input stream after reading\r\n     * @return the data read from the input stream as a byte array\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException {\r\n        if (inputStream == null) {\r\n            throw new IOException(\"Class not found\");\r\n        }\r\n        try {\r\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n            byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];\r\n            int bytesRead;\r\n            while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {\r\n                outputStream.write(data, 0, bytesRead);\r\n            }\r\n            outputStream.flush();\r\n            return outputStream.toByteArray();\r\n        } finally {\r\n            if (close) {\r\n                inputStream.close();"}, {"ID": 970, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) { if (labels[bytecodeOffset] == null) { labels[bytecodeOffset] = new Label(); } return labels[bytecodeOffset]; }\n\n    ### Response:", "ground_truth": "Returns the label corresponding to the given bytecode offset. The default implementation of\nthis method creates a label for the given offset if it has not been already created.\n\n@param bytecodeOffset a bytecode offset in a method.\n@param labels the already created labels, indexed by their offset. If a label already exists\nfor bytecodeOffset this method must not create a new one. Otherwise it must store the new\nlabel in this array.\n@return a non null Label, which must be equal to labels[bytecodeOffset].", "predict": "/**\r\n     * Reads the label at the given bytecode offset. If the label has not been read before, a new label is created.\r\n     * \r\n     * @param bytecodeOffset the bytecode offset of the label to read\r\n     * @param labels an array of labels to store the label at the given bytecode offset\r\n     * @return the label at the given bytecode offset\r\n     */\r\n    protected Label readLabel(final int bytecodeOffset, final Label[] labels) {\r\n        if (labels[bytecodeOffset] == null) {\r\n            labels[bytecodeOffset] = new Label();\r\n        }\r\n        return labels[bytecodeOffset];\r\n    }"}, {"ID": 971, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getTypeAnnotationBytecodeOffset( final int[] typeAnnotationOffsets, final int typeAnnotationIndex) { if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) { return -1; } return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1); }\n\n    ### Response:", "ground_truth": "Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n-1 if there is no such type_annotation of if it does not have a bytecode offset.\n\n@param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\nRuntime[In]VisibleTypeAnnotations attribute, or null.\n@param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n@return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\nif there is no such type_annotation of if it does not have a bytecode offset.", "predict": "/**\r\n     * Returns the bytecode offset of the type annotation at the given index in the given array of type annotation offsets.\r\n     * \r\n     * @param typeAnnotationOffsets the array of type annotation offsets\r\n     * @param typeAnnotationIndex the index of the type annotation to retrieve\r\n     * @return the bytecode offset of the type annotation, or -1 if the index is invalid or the type annotation is not a type reference\r\n     */\r\n    private int getTypeAnnotationBytecodeOffset(final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {\r\n        if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) {\r\n            return -1;\r\n        }\r\n        return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);\r\n    }"}, {"ID": 972, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int readElementValues( final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) { int currentOffset = annotationOffset; // Read the num_element_value_pairs field (or num_values field for an array_value). int numElementValuePairs = readUnsignedShort(currentOffset); currentOffset += 2; if (named) { // Parse the element_value_pairs array. while (numElementValuePairs-- > 0) { String elementName = readUTF8(currentOffset, charBuffer); currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer); } } else { // Parse the array_value array. while (numElementValuePairs-- > 0) { currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer); } } if (annotationVisitor != null) { annotationVisitor.visitEnd(); } return currentOffset; }\n\n    ### Response:", "ground_truth": "Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\nthem. This method can also be used to read the values of the JVMS 'array_value' field of an\nannotation's 'element_value'.\n\n@param annotationVisitor the visitor that must visit the values.\n@param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\nfield) or of an 'array_value' structure.\n@param named if the annotation values are named or not. This should be true to parse the values\nof a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\nannotation's element_value.\n@param charBuffer the buffer used to read strings in the constant pool.\n@return the end offset of the JVMS 'annotation' or 'array_value' structure.", "predict": "/**\n     * Reads the element_value_pairs or array_value array from the annotation and visits each element value using the given annotation visitor.\n     *\n     * @param annotationVisitor the annotation visitor to visit each element value with\n     * @param annotationOffset the offset in the annotation array to start reading from\n     * @param named whether the annotation has named element values or not\n     * @param charBuffer a char buffer to use for reading UTF-8 strings\n     * @return the offset in the annotation array after reading all element values\n     */\n    private int readElementValues(final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) {\n        int currentOffset = annotationOffset; // Read the num_element_value_pairs field (or num_values field for an array_value).\n        int numElementValuePairs = readUnsignedShort(currentOffset);\n        currentOffset += 2;\n        if (named) { // Parse the element_value_pairs array.\n            while (numElementValuePairs--"}, {"ID": 973, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int readVerificationTypeInfo( final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) { int currentOffset = verificationTypeInfoOffset; int tag = b[currentOffset++] & 0xFF; switch (tag) { case Frame.ITEM_TOP: frame[index] = Opcodes.TOP; break; case Frame.ITEM_INTEGER: frame[index] = Opcodes.INTEGER; break; case Frame.ITEM_FLOAT: frame[index] = Opcodes.FLOAT; break; case Frame.ITEM_DOUBLE: frame[index] = Opcodes.DOUBLE; break; case Frame.ITEM_LONG: frame[index] = Opcodes.LONG; break; case Frame.ITEM_NULL: frame[index] = Opcodes.NULL; break; case Frame.ITEM_UNINITIALIZED_THIS: frame[index] = Opcodes.UNINITIALIZED_THIS; break; case Frame.ITEM_OBJECT: frame[index] = readClass(currentOffset, charBuffer); currentOffset += 2; break; case Frame.ITEM_UNINITIALIZED: frame[index] = createLabel(readUnsignedShort(currentOffset), labels); currentOffset += 2; break; default: throw new IllegalArgumentException(); } return currentOffset; }\n\n    ### Response:", "ground_truth": "Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\narray.\n\n@param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\nread.\n@param frame the array where the parsed type must be stored.\n@param index the index in 'frame' where the parsed type must be stored.\n@param charBuffer the buffer used to read strings in the constant pool.\n@param labels the labels of the method currently being parsed, indexed by their offset. If the\nparsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\nstored in this array if it does not already exist.\n@return the end offset of the JVMS 'verification_type_info' structure.", "predict": "/**\n     * Reads the verification type information from the given bytecode array starting at the given offset, and stores it in the given frame at the given index.\n     * \n     * @param verificationTypeInfoOffset the offset in the bytecode array where the verification type information starts\n     * @param frame the frame to store the verification type information in\n     * @param index the index in the frame to store the verification type information at\n     * @param charBuffer a character buffer to use for reading strings from the bytecode array\n     * @param labels a list of labels to use for creating uninitialized labels\n     * @return the offset in the bytecode array where the next verification type information starts\n     * @throws IllegalArgumentException if the verification type information is invalid or unsupported\n     */\n    private int readVerificationTypeInfo(final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) {\n        int currentOffset = verificationTypeInfoOffset;\n        int tag = b[currentOffset++] & 0xFF;\n        switch (tag) {\n            case Frame"}, {"ID": 974, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) { char[] charBuffer = new char[maxStringLength]; int currentAttributeOffset = getFirstAttributeOffset(); int[] currentBootstrapMethodOffsets = null; for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { // Read the attribute_info's attribute_name and attribute_length fields. String attributeName = readUTF8(currentAttributeOffset, charBuffer); int attributeLength = readInt(currentAttributeOffset + 2); currentAttributeOffset += 6; if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { // Read the num_bootstrap_methods field and create an array of this size. currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)]; // Compute and store the offset of each 'bootstrap_methods' array field entry. int currentBootstrapMethodOffset = currentAttributeOffset + 2; for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) { currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset; // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each), // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2). currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2; } return currentBootstrapMethodOffsets; } currentAttributeOffset += attributeLength; } return null; }\n\n    ### Response:", "ground_truth": "Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n\n@param maxStringLength a conservative estimate of the maximum length of the strings contained\nin the constant pool of the class.\n@return the offsets of the bootstrap methods or null.", "predict": "/**\n     * Reads the 'BootstrapMethods' attribute from the class file and returns an array of offsets to the 'bootstrap_methods' array field entries.\n     *\n     * @param maxStringLength the maximum length of the 'bootstrap_method_ref' and 'bootstrap_arguments' fields in the 'BootstrapMethods' attribute.\n     * @return an array of offsets to the 'bootstrap_methods' array field entries, or null if the attribute is not found.\n     */\n    private int[] readBootstrapMethodsAttribute(final int maxStringLength) {\n        char[] charBuffer = new char[maxStringLength];\n        int currentAttributeOffset = getFirstAttributeOffset();\n        int[] currentBootstrapMethodOffsets = null;\n        for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {\n            // Read the attribute_info's attribute_name and attribute_length fields.\n            String attributeName = readUTF8(currentAttributeOffset, charBuffer);\n            int attributeLength = readInt(currentAttribute"}, {"ID": 975, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected CtorDescriptor[] inspectConstructors() { Class type = classDescriptor.getType(); Constructor[] ctors = type.getDeclaredConstructors(); CtorDescriptor[] allCtors = new CtorDescriptor[ctors.length]; for (int i = 0; i < ctors.length; i++) { Constructor ctor = ctors[i]; CtorDescriptor ctorDescriptor = createCtorDescriptor(ctor); allCtors[i] = ctorDescriptor; if (ctorDescriptor.isDefault()) { defaultCtor = ctorDescriptor; } } return allCtors; }\n\n    ### Response:", "ground_truth": "Inspects all declared constructors of a target type.", "predict": "/**\r\n     * Inspects the declared constructors of the class and creates a CtorDescriptor for each one.\r\n     * \r\n     * @return an array of CtorDescriptor objects, one for each constructor declared in the class.\r\n     */\r\n    protected CtorDescriptor[] inspectConstructors() {\r\n        // implementation details elided\r\n    }"}, {"ID": 976, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CtorDescriptor getCtorDescriptor(final Class... args) { ctors: for (CtorDescriptor ctorDescriptor : allCtors) { Class[] arg = ctorDescriptor.getParameters(); if (arg.length != args.length) { continue; } for (int j = 0; j < arg.length; j++) { if (arg[j] != args[j]) { continue ctors; } } return ctorDescriptor; } return null; }\n\n    ### Response:", "ground_truth": "Finds constructor description that matches given argument types.", "predict": "/**\r\n     * Returns the constructor descriptor that matches the given parameter types.\r\n     * \r\n     * @param args the parameter types to match\r\n     * @return the constructor descriptor that matches the given parameter types, or null if no match is found\r\n     */\r\n    public CtorDescriptor getCtorDescriptor(final Class... args) {\r\n        // implementation details elided\r\n    }"}, {"ID": 977, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) { return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Retrieves the request map from the servlet request.\r\n     * \r\n     * @param servletRequest the servlet request\r\n     * @return the request map\r\n     */\r\n    protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) {\r\n        return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME);\r\n    }"}, {"ID": 978, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) { Map<String, TransientBeanData> map = new HashMap<>(); servletRequest.setAttribute(ATTR_NAME, map); return map; }\n\n    ### Response:", "ground_truth": "Creates instance map and stores it in the request.", "predict": "/**\r\n     * This method creates a request attribute with the name ATTR_NAME and a HashMap as its value.\r\n     *\r\n     * @param servletRequest the current HTTP request\r\n     * @return the HashMap that was created and added to the request attribute\r\n     */\r\n    protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) {\r\n        Map<String, TransientBeanData> map = new HashMap<>();\r\n        servletRequest.setAttribute(ATTR_NAME, map);\r\n        return map;\r\n    }"}, {"ID": 979, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected long[] convertArrayToArray(final Object value) { final Class valueComponentType = value.getClass().getComponentType(); final long[] result; if (valueComponentType.isPrimitive()) { result = convertPrimitiveArrayToArray(value, valueComponentType); } else { // convert object array to target array final Object[] array = (Object[]) value; result = new long[array.length]; for (int i = 0; i < array.length; i++) { result[i] = convertType(array[i]); } } return result; }\n\n    ### Response:", "ground_truth": "Converts array value to array.", "predict": "/**\r\n     * Converts an array to an array of long values.\r\n     * \r\n     * @param value the array to convert\r\n     * @return the resulting array of long values\r\n     */\r\n    protected long[] convertArrayToArray(final Object value) {\r\n        final Class valueComponentType = value.getClass().getComponentType();\r\n        final long[] result;\r\n        if (valueComponentType.isPrimitive()) {\r\n            result = convertPrimitiveArrayToArray(value, valueComponentType);\r\n        } else {\r\n            // convert object array to target array\r\n            final Object[] array = (Object[]) value;\r\n            result = new long[array.length];\r\n            for (int i = 0; i < array.length; i++) {\r\n                result[i] = convertType(array[i]);\r\n            }\r\n        }\r\n        return result;\r\n    }"}, {"ID": 980, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final FilterConfig filterConfig) throws ServletException { // final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER); if (decoraManagerClass != null) { try { final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass); decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType); } catch (Exception ex) { log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex); throw new ServletException(ex); } } else { decoraManager = createDecoraManager(); } // final String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER); if (decoraParserClass != null) { try { final Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass); decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType); } catch (Exception ex) { log.error(\"Unable to load Decora parser class: \" + decoraParserClass, ex); throw new ServletException(ex); } } else { decoraParser = createDecoraParser(); } // final String decoraCache = filterConfig.getInitParameter(PARAM_DECORA_CACHE); if (decoraCache != null) { cached = Converter.get().toBoolean(decoraCache, false); } }\n\n    ### Response:", "ground_truth": "Initializes Decora filter. Loads manager and parser from init parameters.", "predict": "/**\n     * Initializes the filter.\n     *\n     * @param filterConfig the filter configuration\n     * @throws ServletException if an error occurs during initialization\n     */\n    @Override\n    public void init(final FilterConfig filterConfig) throws ServletException {\n        // final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER);\n        // if (decoraManagerClass != null) {\n        //     try {\n        //         final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass);\n        //         decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType);\n        //     } catch (Exception ex) {\n        //         log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex);\n        //         throw new ServletException(ex);\n        //     }\n        // } else {\n        //     decoraManager = createDecoraManager();\n        // }\n        // final String decoraParserClass = filterConfig.getInitParameter(PARAM"}, {"ID": 981, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile onFile(final Consumer<File> fileConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer); } else { consumers.add(fileConsumer); } return this; }\n\n    ### Response:", "ground_truth": "Registers file consumer", "predict": "/**\r\n     * Adds a consumer to the list of consumers that will be notified when a file is found.\r\n     *\r\n     * @param fileConsumer the consumer to add\r\n     * @return this object\r\n     */\r\n    public FindFile onFile(final Consumer<File> fileConsumer) {\r\n        if (consumers == null) {\r\n            consumers = Consumers.of(fileConsumer);\r\n        } else {\r\n            consumers.add(fileConsumer);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 982, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile searchPath(final URI searchPath) { File file; try { file = new File(searchPath); } catch (Exception ex) { throw new FindFileException(\"URI error: \" + searchPath, ex); } addPath(file); return this; }\n\n    ### Response:", "ground_truth": "Specifies the search path. Throws an exception if URI is invalid.", "predict": "/**\r\n     * Searches for a file in the given search path.\r\n     * \r\n     * @param searchPath the URI of the search path\r\n     * @return the FindFile object\r\n     * @throws FindFileException if there is an error in the URI or the file cannot be found\r\n     */\r\n    public FindFile searchPath(final URI searchPath) {\r\n        File file;\r\n        try {\r\n            file = new File(searchPath);\r\n        } catch (Exception ex) {\r\n            throw new FindFileException(\"URI error: \" + searchPath, ex);\r\n        }\r\n        addPath(file);\r\n        return this;\r\n    }"}, {"ID": 983, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile searchPath(final URL searchPath) { File file = FileUtil.toContainerFile(searchPath); if (file == null) { throw new FindFileException(\"URL error: \" + searchPath); } addPath(file); return this; }\n\n    ### Response:", "ground_truth": "Specifies the search path. Throws an exception if URL is invalid.", "predict": "/**\r\n     * Searches for a file in the search path.\r\n     * \r\n     * @param searchPath\r\n     *            the URL of the file to search for\r\n     * @return the FindFile object\r\n     * @throws FindFileException\r\n     *             if the file cannot be found or if there is an error with the URL\r\n     */\r\n    public FindFile searchPath(final URL searchPath) {\r\n        File file = FileUtil.toContainerFile(searchPath);\r\n        if (file == null) {\r\n            throw new FindFileException(\"URL error: \" + searchPath);\r\n        }\r\n        addPath(file);\r\n        return this;\r\n    }"}, {"ID": 984, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile include(final String... patterns) { for (String pattern : patterns) { rules.include(pattern); } return this; }\n\n    ### Response:", "ground_truth": "Defines include patterns.", "predict": "/**\r\n     * Adds the specified include patterns to the list of patterns to be matched.\r\n     *\r\n     * @param patterns the include patterns to add\r\n     * @return the updated FindFile object\r\n     */\r\n    public FindFile include(final String... patterns) {\r\n        for (String pattern : patterns) {\r\n            rules.include(pattern);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 985, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FindFile exclude(final String... patterns) { for (String pattern : patterns) { rules.exclude(pattern); } return this; }\n\n    ### Response:", "ground_truth": "Defines exclude patterns.", "predict": "/**\r\n     * Excludes the specified patterns from the search.\r\n     * \r\n     * @param patterns the patterns to exclude\r\n     * @return the FindFile object\r\n     */\r\n    public FindFile exclude(final String... patterns) {\r\n        for (String pattern : patterns) {\r\n            rules.exclude(pattern);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 986, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addPath(final File path) { if (!path.exists()) { return; } if (pathList == null) { pathList = new LinkedList<>(); } pathList.add(path); }\n\n    ### Response:", "ground_truth": "Adds existing search path to the file list.\nNon existing files are ignored.\nIf path is a folder, it will be scanned for all files.", "predict": "/**\r\n     * Adds a file path to the list of paths to be searched for files.\r\n     * \r\n     * @param path The file path to be added.\r\n     */\r\n    protected void addPath(final File path) {\r\n        if (!path.exists()) {\r\n            return;\r\n        }\r\n        if (pathList == null) {\r\n            pathList = new LinkedList<>();\r\n        }\r\n        pathList.add(path);\r\n    }"}, {"ID": 987, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<File> findAll() { List<File> allFiles = new ArrayList<>(); File file; while ((file = nextFile()) != null) { allFiles.add(file); } return allFiles; }\n\n    ### Response:", "ground_truth": "Finds all files and returns list of founded files.", "predict": "/**\r\n     * This method returns a list of all files in the directory.\r\n     * \r\n     * @return a list of all files in the directory\r\n     */\r\n    public List<File> findAll() {\r\n        List<File> allFiles = new ArrayList<>();\r\n        File file;\r\n        while ((file = nextFile()) != null) {\r\n            allFiles.add(file);\r\n        }\r\n        return allFiles;\r\n    }"}, {"ID": 988, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void init() { rules.detectMode(); todoFiles = new LinkedList<>(); todoFolders = new LinkedList<>(); if (pathList == null) { pathList = new LinkedList<>(); return; } if (pathListOriginal == null) { pathListOriginal = (LinkedList<File>) pathList.clone(); } String[] files = new String[pathList.size()]; int index = 0; Iterator<File> iterator = pathList.iterator(); while (iterator.hasNext()) { File file = iterator.next(); if (file.isFile()) { files[index++] = file.getAbsolutePath(); iterator.remove(); } } if (index != 0) { FilesIterator filesIterator = new FilesIterator(files); todoFiles.add(filesIterator); } }\n\n    ### Response:", "ground_truth": "Initializes file walking.\nSeparates input files and folders.", "predict": "/**\r\n     * Initializes the object by detecting the mode of operation, creating empty lists for files and folders, and cloning the original path list if necessary.\r\n     */\r\n    protected void init() {\r\n        rules.detectMode();\r\n        todoFiles = new LinkedList<>();\r\n        todoFolders = new LinkedList<>();\r\n        if (pathList == null) {\r\n            pathList = new LinkedList<>();\r\n            return;\r\n        }\r\n        if (pathListOriginal == null) {\r\n            pathListOriginal = (LinkedList<File>) pathList.clone();\r\n        }\r\n        String[] files = new String[pathList.size()];\r\n        int index = 0;\r\n        Iterator<File> iterator = pathList.iterator();\r\n        while (iterator.hasNext()) {\r\n            File file = iterator.next();\r\n            if (file.isFile()) {\r\n                files[index++] = file.getAbsolutePath();\r\n                iterator.remove();\r\n            }\r\n        }\r\n        if (index != 0) {\r\n            FilesIterator filesIterator = new FilesIterator(files);\r\n            todoFiles.add(filesIterator);\r\n        }\r\n    }"}, {"ID": 989, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Iterator<File> iterator() { return new Iterator<File>() { private File nextFile; @Override public boolean hasNext() { nextFile = nextFile(); return nextFile != null; } @Override public File next() { if (nextFile == null) { throw new NoSuchElementException(); } return nextFile; } @Override public void remove() { throw new UnsupportedOperationException(); } }; }\n\n    ### Response:", "ground_truth": "Returns file walking iterator.", "predict": "/**\r\n     * Returns an iterator over a set of elements of type File.\r\n     *\r\n     * @return an Iterator.\r\n     */\r\n    @Override\r\n    public Iterator<File> iterator() {\r\n        return new Iterator<File>() {\r\n            private File nextFile;\r\n\r\n            @Override\r\n            public boolean hasNext() {\r\n                nextFile = nextFile();\r\n                return nextFile != null;\r\n            }\r\n\r\n            @Override\r\n            public File next() {\r\n                if (nextFile == null) {\r\n                    throw new NoSuchElementException();\r\n                }\r\n                return nextFile;\r\n            }\r\n\r\n            @Override\r\n            public void remove() {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n        };\r\n    }"}, {"ID": 990, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WiringMode resolveBeanWiringMode(final Class type) { PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class); return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT; }\n\n    ### Response:", "ground_truth": "Resolves bean's auto-wire flag from the annotation. Returns default auto-wire if annotation doesn't exist.", "predict": "/**\n     * Resolves the wiring mode for a given bean type.\n     *\n     * @param type the type of the bean for which to resolve the wiring mode\n     * @return the wiring mode for the given bean type, or WiringMode.DEFAULT if no annotation is present on the type\n     */\n    public WiringMode resolveBeanWiringMode(final Class type) {\n        PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class);\n        return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT;\n    }"}, {"ID": 991, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveBeanName(final Class type, final boolean useLongTypeName) { PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class); String name = null; if (petiteBean != null) { name = petiteBean.value().trim(); } if ((name == null) || (name.length() == 0)) { if (useLongTypeName) { name = type.getName(); } else { name = StringUtil.uncapitalize(type.getSimpleName()); } } return name; }\n\n    ### Response:", "ground_truth": "Resolves bean's name from bean annotation or type name. May be used for resolving bean name\nof base type during registration of bean subclass.", "predict": "/**\r\n     * Resolves the bean name for the given type.\r\n     * \r\n     * @param type the type for which to resolve the bean name\r\n     * @param useLongTypeName whether to use the long type name as the bean name\r\n     * @return the resolved bean name\r\n     */\r\n    public String resolveBeanName(final Class type, final boolean useLongTypeName) {\r\n        // TODO: implement logic to resolve bean name\r\n    }"}, {"ID": 992, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PrintWriter getWriter() { if (outWriter == null) { if (outStream != null) { throw new IllegalStateException(\"Can't call getWriter() after getOutputStream()\"); } bufferedWriter = new FastCharArrayWriter(); outWriter = new PrintWriter(bufferedWriter) { @Override public void close() { // do not close the print writer after rendering // since it will remove reference to bufferedWriter } }; } return outWriter; }\n\n    ### Response:", "ground_truth": "Returns a writer.", "predict": "/**\r\n     * Returns a PrintWriter object that can be used to send character output to\r\n     * the client. The PrintWriter will use a FastCharArrayWriter to buffer the\r\n     * output and will flush the buffer to the client only when necessary.\r\n     *\r\n     * @return a PrintWriter object that can be used to send character output to\r\n     *         the client.\r\n     * @throws IllegalStateException\r\n     *             if the method is called after getOutputStream()\r\n     */\r\n    public PrintWriter getWriter() {\r\n        if (outWriter == null) {\r\n            if (outStream != null) {\r\n                throw new IllegalStateException(\"Can't call getWriter() after getOutputStream()\");\r\n            }\r\n            bufferedWriter = new FastCharArrayWriter();\r\n            outWriter = new PrintWriter(bufferedWriter) {\r\n                @Override\r\n                public void close() {\r\n                    // do not close the print writer after rendering\r\n                    // since it will remove reference to bufferedWriter\r\n                }\r\n            };\r\n        }\r\n        return outWriter;\r\n    }"}, {"ID": 993, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServletOutputStream getOutputStream() { if (outStream == null) { if (outWriter != null) { throw new IllegalStateException(\"Can't call getOutputStream() after getWriter()\"); } bufferOutputStream = new FastByteArrayServletOutputStream(); outStream = bufferOutputStream; } return outStream; }\n\n    ### Response:", "ground_truth": "Returns a servlet output stream.", "predict": "/**\r\n     * Returns a {@link ServletOutputStream} suitable for writing binary data in the response.\r\n     *\r\n     * @return a {@link ServletOutputStream} for writing binary data in the response\r\n     * @throws IllegalStateException if the method is called after the {@link #getWriter()} method has been called\r\n     */\r\n    public ServletOutputStream getOutputStream() {\r\n        if (outStream == null) {\r\n            if (outWriter != null) {\r\n                throw new IllegalStateException(\"Can't call getOutputStream() after getWriter()\");\r\n            }\r\n            bufferOutputStream = new FastByteArrayServletOutputStream();\r\n            outStream = bufferOutputStream;\r\n        }\r\n        return outStream;\r\n    }"}, {"ID": 994, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { stringBuilder.append(\"[]\"); } return stringBuilder.toString(); case OBJECT: case INTERNAL: return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.'); default: throw new AssertionError(); } }\n\n    ### Response:", "ground_truth": "Returns the binary name of the class corresponding to this type. This method must not be used\non method types.\n\n@return the binary name of the class corresponding to this type.", "predict": "/**\r\n     * Returns the class name of the type represented by this Type object.\r\n     *\r\n     * @return the class name of the type represented by this Type object.\r\n     */\r\n    public String getClassName() {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 995, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getConstructorDescriptor(final Constructor<?> constructor) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = constructor.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } return stringBuilder.append(\")V\").toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given constructor.\n\n@param constructor a {@link Constructor} object.\n@return the descriptor of the given constructor.", "predict": "/**\r\n     * Returns the descriptor string for the specified constructor.\r\n     *\r\n     * @param constructor the constructor to generate the descriptor for\r\n     * @return the descriptor string for the constructor\r\n     */\r\n    public static String getConstructorDescriptor(final Constructor<?> constructor) {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        stringBuilder.append('(');\r\n        Class<?>[] parameters = constructor.getParameterTypes();\r\n        for (Class<?> parameter : parameters) {\r\n            appendDescriptor(parameter, stringBuilder);\r\n        }\r\n        return stringBuilder.append(\")V\").toString();\r\n    }"}, {"ID": 996, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); for (Type argumentType : argumentTypes) { argumentType.appendDescriptor(stringBuilder); } stringBuilder.append(')'); returnType.appendDescriptor(stringBuilder); return stringBuilder.toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given argument and return types.\n\n@param returnType the return type of the method.\n@param argumentTypes the argument types of the method.\n@return the descriptor corresponding to the given argument and return types.", "predict": "/**\r\n     * Returns the method descriptor for the given return type and argument types.\r\n     *\r\n     * @param returnType the return type of the method\r\n     * @param argumentTypes the argument types of the method\r\n     * @return the method descriptor for the given return type and argument types\r\n     */\r\n    public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        stringBuilder.append('(');\r\n        for (Type argumentType : argumentTypes) {\r\n            argumentType.appendDescriptor(stringBuilder);\r\n        }\r\n        stringBuilder.append(')');\r\n        returnType.appendDescriptor(stringBuilder);\r\n        return stringBuilder.toString();\r\n    }"}, {"ID": 997, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getMethodDescriptor(final Method method) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = method.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } stringBuilder.append(')'); appendDescriptor(method.getReturnType(), stringBuilder); return stringBuilder.toString(); }\n\n    ### Response:", "ground_truth": "Returns the descriptor corresponding to the given method.\n\n@param method a {@link Method} object.\n@return the descriptor of the given method.", "predict": "/**\r\n     * Returns the method descriptor for the given method.\r\n     *\r\n     * @param method the method to get the descriptor for\r\n     * @return the method descriptor for the given method\r\n     */\r\n    public static String getMethodDescriptor(final Method method) {\r\n        StringBuilder stringBuilder = new StringBuilder();\r\n        stringBuilder.append('(');\r\n        Class<?>[] parameters = method.getParameterTypes();\r\n        for (Class<?> parameter : parameters) {\r\n            appendDescriptor(parameter, stringBuilder);\r\n        }\r\n        stringBuilder.append(')');\r\n        appendDescriptor(method.getReturnType(), stringBuilder);\r\n        return stringBuilder.toString();\r\n    }\r\n\r\n    /**\r\n     * Appends the descriptor for the given class to the given string builder.\r\n     *\r\n     * @param clazz the class to get the descriptor for\r\n     * @param stringBuilder the string builder to append the descriptor to\r\n     */\r\n    private static void appendDescriptor(Class<?> clazz, StringBuilder stringBuilder) {\r\n        if (clazz.isPrimitive()) {\r\n            if (clazz == boolean.class) {\r\n                stringBuilder.append('Z');\r\n            } else if (clazz =="}, {"ID": 998, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void appendDescriptor(final StringBuilder stringBuilder) { if (sort == OBJECT) { stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';'); } else { stringBuilder.append(valueBuffer, valueBegin, valueEnd); } }\n\n    ### Response:", "ground_truth": "Appends the descriptor corresponding to this type to the given string buffer.\n\n@param stringBuilder the string builder to which the descriptor must be appended.", "predict": "/**\r\n     * Appends the descriptor to the given string builder.\r\n     *\r\n     * @param stringBuilder the string builder to append to\r\n     */\r\n    private void appendDescriptor(final StringBuilder stringBuilder) {\r\n        if (sort == OBJECT) {\r\n            stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);\r\n        } else if (sort == INTERNAL) {\r\n            stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';');\r\n        } else {\r\n            stringBuilder.append(valueBuffer, valueBegin, valueEnd);\r\n        }\r\n    }"}, {"ID": 999, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int getSize() { switch (sort) { case VOID: return 0; case BOOLEAN: case CHAR: case BYTE: case SHORT: case INT: case FLOAT: case ARRAY: case OBJECT: case INTERNAL: return 1; case LONG: case DOUBLE: return 2; default: throw new AssertionError(); } }\n\n    ### Response:", "ground_truth": "Returns the size of values of this type. This method must not be used for method types.\n\n@return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n{@code void} and 1 otherwise.", "predict": "/**\r\n     * Returns the size of the object represented by this instance.\r\n     * \r\n     * @return the size of the object\r\n     */\r\n    public int getSize() {\r\n        switch (sort) {\r\n            case VOID:\r\n                return 0;\r\n            case BOOLEAN:\r\n            case CHAR:\r\n            case BYTE:\r\n            case SHORT:\r\n            case INT:\r\n            case FLOAT:\r\n            case ARRAY:\r\n            case OBJECT:\r\n            case INTERNAL:\r\n                return 1;\r\n            case LONG:\r\n            case DOUBLE:\r\n                return 2;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }"}, {"ID": 1000, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getArgumentsAndReturnSizes(final String methodDescriptor) { int argumentsSize = 1; // Skip the first character, which is always a '('. int currentOffset = 1; int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration. while (currentChar != ')') { if (currentChar == 'J' || currentChar == 'D') { currentOffset++; argumentsSize += 2; } else { while (methodDescriptor.charAt(currentOffset) == '[') { currentOffset++; } if (methodDescriptor.charAt(currentOffset++) == 'L') { // Skip the argument descriptor content. currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1; } argumentsSize += 1; } currentChar = methodDescriptor.charAt(currentOffset); } currentChar = methodDescriptor.charAt(currentOffset + 1); if (currentChar == 'V') { return argumentsSize << 2; } else { int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1; return argumentsSize << 2 | returnSize; } }\n\n    ### Response:", "ground_truth": "Computes the size of the arguments and of the return value of a method.\n\n@param methodDescriptor a method descriptor.\n@return the size of the arguments of the method (plus one for the implicit this argument),\nargumentsSize, and the size of its return value, returnSize, packed into a single int i =\n{@code (argumentsSize << 2) | returnSize} (argumentsSize is therefore equal to {@code\ni >> 2}, and returnSize to {@code i & 0x03}).", "predict": "/**\r\n     * Computes the size of the arguments and return value of a method based on its method descriptor.\r\n     * \r\n     * @param methodDescriptor the method descriptor of the method to analyze\r\n     * @return the size of the arguments (in words) and the size of the return value (in words)\r\n     */\r\n    public static int getArgumentsAndReturnSizes(final String methodDescriptor) {\r\n        int argumentsSize = 1; // Skip the first character, which is always a '('.\r\n        int currentOffset = 1;\r\n        int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration.\r\n        while (currentChar != ')') {\r\n            if (currentChar == 'J' || currentChar == 'D') {\r\n                currentOffset++;\r\n                argumentsSize += 2;\r\n            } else {\r\n                while (methodDescriptor.charAt(currentOffset) == '[') {\r\n                    currentOffset++;\r\n                }\r\n                if (methodDescriptor.charAt(currentOffset++) == 'L') { //"}, {"ID": 1001, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = th; status = STATUS_MARKED_ROLLBACK; }\n\n    ### Response:", "ground_truth": "Modify the transaction associated with the target object such that the only possible outcome\nof the transaction is to roll back the transaction.", "predict": "/**\r\n     * Sets the transaction to rollback only, with the specified cause.\r\n     *\r\n     * @param th the cause of the rollback.\r\n     * @throws JtxException if there is no active transaction or if the transaction is already marked for rollback.\r\n     */\r\n    public void setRollbackOnly(final Throwable th) {\r\n        if (!isNoTransaction()) {\r\n            if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) {\r\n                throw new JtxException(\"TNo active TX that can be marked as rollback only\");\r\n            }\r\n        }\r\n        rollbackCause = th;\r\n        status = STATUS_MARKED_ROLLBACK;\r\n    }"}, {"ID": 1002, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void commitOrRollback(boolean doCommit) { if (log.isDebugEnabled()) { if (doCommit) { log.debug(\"Commit JTX\"); } else { log.debug(\"Rollback JTX\"); } } boolean forcedRollback = false; if (!isNoTransaction()) { if (isRollbackOnly()) { if (doCommit) { doCommit = false; forcedRollback = true; } } else if (!isActive()) { if (isCompleted()) { throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\"); } throw new JtxException(\"No active TX to \" + (doCommit ? \"commit\" : \"rollback\")); } } if (doCommit) { commitAllResources(); } else { rollbackAllResources(forcedRollback); } }\n\n    ### Response:", "ground_truth": "Performs either commit or rollback on all transaction resources.", "predict": "/**\r\n     * Commits or rolls back the transaction based on the value of the doCommit parameter.\r\n     * \r\n     * @param doCommit\r\n     *            true to commit the transaction, false to rollback the transaction.\r\n     * @throws JtxException\r\n     *             if there is no active transaction or if the transaction is already completed.\r\n     */\r\n    protected void commitOrRollback(boolean doCommit) throws JtxException {\r\n        if (log.isDebugEnabled()) {\r\n            if (doCommit) {\r\n                log.debug(\"Commit JTX\");\r\n            } else {\r\n                log.debug(\"Rollback JTX\");\r\n            }\r\n        }\r\n        boolean forcedRollback = false;\r\n        if (!isNoTransaction()) {\r\n            if (isRollbackOnly()) {\r\n                if (doCommit) {\r\n                    doCommit = false;\r\n                    forcedRollback = true;\r\n                }\r\n            } else if (!isActive()) {\r\n                if (isCompleted()) {\r\n                    throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\");\r\n                }\r\n                throw new JtxException"}, {"ID": 1003, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void rollbackAllResources(final boolean wasForced) { status = STATUS_ROLLING_BACK; Exception lastException = null; Iterator<JtxResource> it = resources.iterator(); while (it.hasNext()) { JtxResource resource = it.next(); try { resource.rollbackTransaction(); } catch (Exception ex) { lastException = ex; } finally { it.remove(); } } txManager.removeTransaction(this); status = STATUS_ROLLEDBACK; if (lastException != null) { status = STATUS_UNKNOWN; throw new JtxException(\"Rollback failed: one or more TX resources couldn't rollback a TX\", lastException); } if (wasForced) { throw new JtxException(\"TX rolled back because it has been marked as rollback-only\", rollbackCause); } }\n\n    ### Response:", "ground_truth": "Rollbacks all attached resources. Resource will be closed. and detached from this transaction.\nIf exception occurs, it will be rethrown at the end.", "predict": "/**\n     * Rolls back all resources associated with this transaction.\n     * \n     * @param wasForced\n     *            true if the transaction was marked as rollback-only, false otherwise.\n     * @throws JtxException\n     *             if any of the resources couldn't rollback the transaction.\n     */\n    protected void rollbackAllResources(final boolean wasForced) {\n        // TODO: Implement method\n    }"}, {"ID": 1004, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E requestResource(final Class<E> resourceType) { if (isCompleted()) { throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\"); } if (isRollbackOnly()) { throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause); } if (!isNoTransaction() && !isActive()) { throw new JtxException(\"Resources are not available since TX is not active\"); } checkTimeout(); E resource = lookupResource(resourceType); if (resource == null) { int maxResources = txManager.getMaxResourcesPerTransaction(); if ((maxResources != -1) && (resources.size() >= maxResources)) { throw new JtxException(\"TX already has attached max. number of resources\"); } JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType); resource = resourceManager.beginTransaction(mode, isActive()); resources.add(new JtxResource<>(this, resourceManager, resource)); } return resource; }\n\n    ### Response:", "ground_truth": "Requests a resource. If resource is not found, it will be created and new transaction will be started on it.", "predict": "/**\n     * Requests a resource of the specified type from the transaction manager.\n     * \n     * @param resourceType the type of resource to request\n     * @return the requested resource\n     * @throws JtxException if the transaction is already completed, marked for rollback only, or not active, or if the transaction has reached its timeout, or if the transaction already has attached the maximum number of resources, or if there is an error creating the resource\n     */\n    public <E> E requestResource(final Class<E> resourceType) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1005, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void popName() { if (isPushed) { if (pushedComma) { writeComma(); } String name = pushedName; pushedName = null; isPushed = false; writeName(name); } }\n\n    ### Response:", "ground_truth": "Writes stored name to JSON string. Cleans storage.", "predict": "/**\r\n     * Pops the name from the stack and writes it to the output.\r\n     */\r\n    protected void popName() {\r\n        if (isPushed) {\r\n            if (pushedComma) {\r\n                writeComma();\r\n            }\r\n            String name = pushedName;\r\n            pushedName = null;\r\n            isPushed = false;\r\n            writeName(name);\r\n        }\r\n    }"}, {"ID": 1006, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeString(final String value) { popName(); write(StringPool.QUOTE); int len = value.length(); for (int i = 0; i < len; i++) { char c = value.charAt(i); switch (c) { case '\"': write(\"\\\\\\\"\"); break; case '\\\\': write(\"\\\\\\\\\"); break; case '/': if (strictStringEncoding) { write(\"\\\\/\"); } else { write(c); } break; case '\\b': write(\"\\\\b\"); break; case '\\f': write(\"\\\\f\"); break; case '\\n': write(\"\\\\n\"); break; case '\\r': write(\"\\\\r\"); break; case '\\t': write(\"\\\\t\"); break; default: if (Character.isISOControl(c)) { unicode(c); } else { write(c); } } } write(StringPool.QUOTE); }\n\n    ### Response:", "ground_truth": "Write a quoted and escaped value to the output.", "predict": "/**\r\n     * Writes a string to the output stream, escaping special characters as necessary.\r\n     *\r\n     * @param value the string to write\r\n     */\r\n    public void writeString(final String value) {\r\n        popName();\r\n        write(StringPool.QUOTE);\r\n        int len = value.length();\r\n        for (int i = 0; i < len; i++) {\r\n            char c = value.charAt(i);\r\n            switch (c) {\r\n                case '\"':\r\n                    write(\"\\\\\\\"\");\r\n                    break;\r\n                case '\\\\':\r\n                    write(\"\\\\\\\\\");\r\n                    break;\r\n                case '/':\r\n                    if (strictStringEncoding) {\r\n                        write(\"\\\\/\");\r\n                    } else {\r\n                        write(c);\r\n                    }\r\n                    break;\r\n                case '\\b':\r\n                    write(\"\\\\b\");\r\n                    break;\r\n                case '\\f':\r\n                    write(\"\\\\f\");\r\n                    break;\r\n                case '\\n':\r\n                    write(\"\\\\n\");\r\n                    break;\r\n                case '\\r':\r\n                    write(\"\\\\r\");\r\n                    break;\r\n                case '\\t':\r\n                    write(\"\\\\t\");\r\n                    break;\r\n                default:\r\n                   "}, {"ID": 1007, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void unicode(final char c) { write(\"\\\\u\"); int n = c; for (int i = 0; i < 4; ++i) { int digit = (n & 0xf000) >> 12; char hex = CharUtil.int2hex(digit); write(hex); n <<= 4; } }\n\n    ### Response:", "ground_truth": "Writes unicode representation of a character.", "predict": "/**\r\n     * Writes the Unicode representation of the given character to the output stream.\r\n     * \r\n     * @param c the character to write\r\n     */\r\n    protected void unicode(final char c) {\r\n        write(\"\\\\u\");\r\n        int n = c;\r\n        for (int i = 0; i < 4; ++i) {\r\n            int digit = (n & 0xf000) >> 12;\r\n            char hex = CharUtil.int2hex(digit);\r\n            write(hex);\r\n            n <<= 4;\r\n        }\r\n    }"}, {"ID": 1008, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void write(final CharSequence charSequence) { popName(); try { out.append(charSequence); } catch (IOException ioex) { throw new JsonException(ioex); } }\n\n    ### Response:", "ground_truth": "Appends char sequence to the buffer. Used for numbers, nulls, booleans, etc.", "predict": "/**\r\n     * Writes the specified character sequence to the output stream.\r\n     *\r\n     * @param charSequence the character sequence to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void write(final CharSequence charSequence) throws IOException {\r\n        popName();\r\n        out.append(charSequence);\r\n    }"}, {"ID": 1009, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) { logLevel = logLevel.trim().toUpperCase(); parsingErrorLogLevel = Logger.Level.valueOf(logLevel); return this; }\n\n    ### Response:", "ground_truth": "Sets parsing error log level as a name.", "predict": "/**\r\n     * Sets the log level for parsing errors.\r\n     * \r\n     * @param logLevel the log level name\r\n     * @return the updated builder configuration\r\n     */\r\n    public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) {\r\n        logLevel = logLevel.trim().toUpperCase();\r\n        parsingErrorLogLevel = Logger.Level.valueOf(logLevel);\r\n        return this;\r\n    }"}, {"ID": 1010, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startRegion(final int start, final int tagLen, final int deepLevel) { this.regionStart = start + tagLen; this.regionLength = 0; this.regionTagStart = start; this.deepLevel = deepLevel; }\n\n    ### Response:", "ground_truth": "Starts defining region by setting the start index and reset region length to zero.", "predict": "/**\r\n     * This method initializes the region start, length, tag start, and deep level of the region.\r\n     * \r\n     * @param start the start index of the region in the input string\r\n     * @param tagLen the length of the region tag\r\n     * @param deepLevel the deep level of the region in the XML hierarchy\r\n     */\r\n    public void startRegion(final int start, final int tagLen, final int deepLevel) {\r\n        this.regionStart = start + tagLen;\r\n        this.regionLength = 0;\r\n        this.regionTagStart = start;\r\n        this.deepLevel = deepLevel;\r\n    }"}, {"ID": 1011, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isContaining(final String include) { if (value == null) { return false; } if (splits == null) { splits = StringUtil.splitc(value, ' '); } for (String s: splits) { if (s.equals(include)) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Returns true if attribute is containing some value.", "predict": "/**\r\n     * This method checks if the given string is present in the value of the object.\r\n     * @param include the string to be checked for presence in the value of the object.\r\n     * @return true if the given string is present in the value of the object, false otherwise.\r\n     */\r\n    public boolean isContaining(final String include) {\r\n        if (value == null) {\r\n            return false;\r\n        }\r\n        if (splits == null) {\r\n            splits = StringUtil.splitc(value, ' ');\r\n        }\r\n        for (String s: splits) {\r\n            if (s.equals(include)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1012, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pseudoFunctionType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction); }\n\n    ### Response:", "ground_truth": "Registers pseudo function.", "predict": "/**\r\n     * Registers a pseudo-function class with the system.\r\n     * \r\n     * @param pseudoFunctionType the pseudo-function class to register\r\n     * @throws CSSellyException if there is an error creating an instance of the pseudo-function class\r\n     */\r\n    public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) {\r\n        PseudoFunction pseudoFunction;\r\n        try {\r\n            pseudoFunction = ClassUtil.newInstance(pseudoFunctionType);\r\n        } catch (Exception ex) {\r\n            throw new CSSellyException(ex);\r\n        }\r\n        PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction);\r\n    }"}, {"ID": 1013, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName); if (pseudoFunction == null) { throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName); } return pseudoFunction; }\n\n    ### Response:", "ground_truth": "Lookups pseudo function for given pseudo function name.", "predict": "/**\r\n     * Looks up a pseudo-function by name and returns it.\r\n     *\r\n     * @param pseudoFunctionName the name of the pseudo-function to look up\r\n     * @return the pseudo-function, or null if not found\r\n     * @throws CSSellyException if the pseudo-function is not supported\r\n     */\r\n    public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) {\r\n        PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName);\r\n        if (pseudoFunction == null) {\r\n            throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName);\r\n        }\r\n        return pseudoFunction;\r\n    }"}, {"ID": 1014, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) { wd.init(name, superName, this.suffix, this.reqProxyClassName); // change access of destination access &= ~AsmUtil.ACC_ABSTRACT; // write destination class final int v = ProxettaAsmUtil.resolveJavaVersion(version); wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null); wd.proxyAspects = new ProxyAspectData[aspects.length]; for (int i = 0; i < aspects.length; i++) { wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i); } }\n\n    ### Response:", "ground_truth": "Creates destination subclass header from current target class. Destination name is created from targets by\nadding a suffix and, optionally, a number. Destination extends the target.", "predict": "/**\n     * This method is called by the ASM framework when visiting a class. It initializes the proxy class writer and calls the visit method of the destination class, passing the modified access flags. It also creates an array of ProxyAspectData objects for each aspect, and passes them to the ProxyAspectData constructor.\n     * \n     * @param version the class file version\n     * @param access the class access flags\n     * @param name the internal name of the class\n     * @param signature the signature of this class\n     * @param superName the internal name of the super class\n     * @param interfaces the internal names of the implemented interfaces\n     */\n    @Override\n    public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) {\n        wd.init(name, superName, this.suffix, this.reqProxyClassName); // change access of destination access &= ~AsmUtil.ACC_ABSTRACT; // write destination class\n        final int v = Proxetta"}, {"ID": 1015, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3] return new AnnotationVisitorAdapter(destAnn); }\n\n    ### Response:", "ground_truth": "Copies all destination type annotations to the target.", "predict": "/**\r\n     * Visits an annotation of the method.\r\n     *\r\n     * @param desc the descriptor of the annotation class.\r\n     * @param visible if the annotation is visible at runtime.\r\n     * @return a visitor to visit the annotation values, or null if this visitor is not interested in visiting this annotation.\r\n     */\r\n    @Override\r\n    public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) {\r\n        AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3] return new AnnotationVisitorAdapter(destAnn);\r\n    }"}, {"ID": 1016, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void makeStaticInitBlock() { if (wd.adviceClinits != null) { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null); mv.visitCode(); for (String name : wd.adviceClinits) { mv.visitMethodInsn( INVOKESTATIC, wd.thisReference, name, DESC_VOID, false); } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } }\n\n    ### Response:", "ground_truth": "Creates static initialization block that simply calls all\nadvice static init methods in correct order.", "predict": "/**\r\n     * This method generates a static initialization block that calls the advice clinits.\r\n     */\r\n    protected void makeStaticInitBlock() {\r\n        // code goes here\r\n    }"}, {"ID": 1017, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void makeProxyConstructor() { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null); mv.visitCode(); if (wd.adviceInits != null) { for (String name : wd.adviceInits) { mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn (INVOKESPECIAL, wd.thisReference, name, DESC_VOID, false); } } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Creates init method that simply calls all advice constructor methods in correct order.\nThis created init method is called from each destination's constructor.", "predict": "/**\r\n     * Generates the constructor for the proxy class.\r\n     */\r\n    protected void makeProxyConstructor() {\r\n        // Method body goes here.\r\n    }"}, {"ID": 1018, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void processSuperMethods() { for (ClassReader cr : targetClassInfo.superClassReaders) { cr.accept(new EmptyClassVisitor() { String declaredClassName; @Override public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) { declaredClassName = name; } @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { if (name.equals(INIT) || name.equals(CLINIT)) { return null; } MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName); if (msign == null) { return null; } return applyProxy(msign); } }, 0); } }\n\n    ### Response:", "ground_truth": "Checks for all public super methods that are not overridden.", "predict": "/**\r\n     * This method is responsible for processing the super class methods.\r\n     */\r\n    protected void processSuperMethods() {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 1019, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int findLast(int low, int high) { int ndx = -1; while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(mid); if (delta > 0) { high = mid - 1; } else { if (delta == 0) { ndx = mid; } low = mid + 1; } } if (ndx == -1) { return -(low + 1); } return ndx; }\n\n    ### Response:", "ground_truth": "Finds very last index of given element in inclusive index range. Returns negative\nvalue if element is not found.", "predict": "/**\r\n     * Finds the last index of the target element in the given range [low, high].\r\n     * \r\n     * @param low the lower bound of the range (inclusive)\r\n     * @param high the upper bound of the range (inclusive)\r\n     * @return the last index of the target element in the range, or -1 if the element is not found\r\n     */\r\n    public int findLast(int low, int high) {\r\n        int ndx = -1;\r\n        while (low <= high) {\r\n            int mid = (low + high) >>> 1;\r\n            int delta = compare(mid);\r\n            if (delta > 0) {\r\n                high = mid - 1;\r\n            } else {\r\n                if (delta == 0) {\r\n                    ndx = mid;\r\n                }\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        if (ndx == -1) {\r\n            return -(low + 1);\r\n        }\r\n        return ndx;\r\n    }"}, {"ID": 1020, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String on(final String string) { if (!enabled) { return string; } final StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix).append(\"m\"); } sb.append(string); if (suffix != null) { sb.append(suffix).append(\"m\"); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns chalked string.", "predict": "/**\r\n     * This method takes a string as input and returns a modified string based on the prefix and suffix values.\r\n     * \r\n     * @param string The input string to be modified.\r\n     * @return The modified string.\r\n     */\r\n    public String on(final String string) {\r\n        // TODO: Implement logic to modify the input string based on prefix and suffix values.\r\n    }"}, {"ID": 1021, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) { final Attribute[] attributes = getAttributePrototypes(); firstField = null; lastField = null; firstMethod = null; lastMethod = null; lastRuntimeVisibleAnnotation = null; lastRuntimeInvisibleAnnotation = null; lastRuntimeVisibleTypeAnnotation = null; lastRuntimeInvisibleTypeAnnotation = null; moduleWriter = null; nestHostClassIndex = 0; numberOfNestMemberClasses = 0; nestMemberClasses = null; firstAttribute = null; compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING; new ClassReader(classFile, 0, /* checkClassVersion = */ false) .accept( this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS); return toByteArray(); }\n\n    ### Response:", "ground_truth": "Returns the equivalent of the given class file, with the ASM specific instructions replaced\nwith standard ones. This is done with a ClassReader -> ClassWriter round trip.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones.", "predict": "/**\n     * Replaces the ASM instructions in the given class file with the equivalent Java bytecode.\n     *\n     * @param classFile the class file to process\n     * @param hasFrames whether the class file has stack map frames\n     * @return the modified class file as a byte array\n     */\n    private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) {\n        // TODO: implement this method\n    }"}, {"ID": 1022, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Attribute[] getAttributePrototypes() { Attribute.Set attributePrototypes = new Attribute.Set(); attributePrototypes.addAttributes(firstAttribute); FieldWriter fieldWriter = firstField; while (fieldWriter != null) { fieldWriter.collectAttributePrototypes(attributePrototypes); fieldWriter = (FieldWriter) fieldWriter.fv; } MethodWriter methodWriter = firstMethod; while (methodWriter != null) { methodWriter.collectAttributePrototypes(attributePrototypes); methodWriter = (MethodWriter) methodWriter.mv; } return attributePrototypes.toArray(); }\n\n    ### Response:", "ground_truth": "Returns the prototypes of the attributes used by this class, its fields and its methods.\n\n@return the prototypes of the attributes used by this class, its fields and its methods.", "predict": "/**\r\n     * Returns an array of Attribute objects representing the prototypes of all attributes used by this class.\r\n     * \r\n     * @return an array of Attribute objects representing the prototypes of all attributes used by this class.\r\n     */\r\n    private Attribute[] getAttributePrototypes() {\r\n        Attribute.Set attributePrototypes = new Attribute.Set();\r\n        attributePrototypes.addAttributes(firstAttribute);\r\n        FieldWriter fieldWriter = firstField;\r\n        while (fieldWriter != null) {\r\n            fieldWriter.collectAttributePrototypes(attributePrototypes);\r\n            fieldWriter = (FieldWriter) fieldWriter.fv;\r\n        }\r\n        MethodWriter methodWriter = firstMethod;\r\n        while (methodWriter != null) {\r\n            methodWriter.collectAttributePrototypes(attributePrototypes);\r\n            methodWriter = (MethodWriter) methodWriter.mv;\r\n        }\r\n        return attributePrototypes.toArray();\r\n    }"}, {"ID": 1023, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerDefaults() { register(Integer.class, IntegerSqlType.class); register(int.class, IntegerSqlType.class); register(MutableInteger.class, IntegerSqlType.class); register(Float.class, FloatSqlType.class); register(float.class, FloatSqlType.class); register(MutableFloat.class, FloatSqlType.class); register(Double.class, DoubleSqlType.class); register(double.class, DoubleSqlType.class); register(MutableDouble.class, DoubleSqlType.class); register(Byte.class, ByteSqlType.class); register(byte.class, ByteSqlType.class); register(MutableByte.class, ByteSqlType.class); register(Boolean.class, BooleanSqlType.class); register(boolean.class, BooleanSqlType.class); register(MutableBoolean.class, BooleanSqlType.class); register(Long.class, LongSqlType.class); register(long.class, LongSqlType.class); register(MutableLong.class, LongSqlType.class); register(Short.class, ShortSqlType.class); register(short.class, ShortSqlType.class); register(MutableShort.class, ShortSqlType.class); register(Character.class, CharacterSqlType.class); register(char.class, CharacterSqlType.class); register(BigDecimal.class, BigDecimalSqlType.class); register(BigInteger.class, BigIntegerSqlType.class); register(String.class, StringSqlType.class); register(LocalDateTime.class, LocalDateTimeSqlType.class); register(LocalDate.class, LocalDateSqlType.class); register(LocalTime.class, LocalTimeSqlType.class); register(Date.class, SqlDateSqlType.class); register(Timestamp.class, TimestampSqlType.class); register(Time.class, TimeSqlType.class); register(java.util.Date.class, DateSqlType.class); register(JulianDate.class, JulianDateSqlType.class); register(byte[].class, ByteArraySqlType.class); register(URL.class, URLSqlType.class); register(Blob.class, BlobSqlType.class); register(Clob.class, ClobSqlType.class); register(Array.class, SqlArraySqlType.class); register(Ref.class, SqlRefSqlType.class); }\n\n    ### Response:", "ground_truth": "Registers default set of SQL types.", "predict": "/**\r\n     * Registers the default mappings between Java types and SQL types.\r\n     * <p>\r\n     * This method is called by the constructor of {@link SqlTypeRegistry} and should not be called directly.\r\n     */\r\n    public void registerDefaults() {\r\n        register(Integer.class, IntegerSqlType.class);\r\n        register(int.class, IntegerSqlType.class);\r\n        register(MutableInteger.class, IntegerSqlType.class);\r\n        register(Float.class, FloatSqlType.class);\r\n        register(float.class, FloatSqlType.class);\r\n        register(MutableFloat.class, FloatSqlType.class);\r\n        register(Double.class, DoubleSqlType.class);\r\n        register(double.class, DoubleSqlType.class);\r\n        register(MutableDouble.class, DoubleSqlType.class);\r\n        register(Byte.class, ByteSqlType.class);\r\n        register(byte.class, ByteSqlType.class);\r\n        register(MutableByte.class, ByteSqlType.class);\r\n        register(Boolean."}, {"ID": 1024, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) { types.put(type, lookupSqlType(sqlTypeClass)); }\n\n    ### Response:", "ground_truth": "Registers sql type for provided type.", "predict": "/**\r\n     * Registers a mapping between a Java type and a SQL type.\r\n     *\r\n     * @param type the Java type to register\r\n     * @param sqlTypeClass the SQL type to map to the Java type\r\n     */\r\n    public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) {\r\n        types.put(type, lookupSqlType(sqlTypeClass));\r\n    }"}, {"ID": 1025, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SqlType lookup(final Class clazz) { SqlType sqlType; for (Class x = clazz; x != null; x = x.getSuperclass()) { sqlType = types.get(clazz); if (sqlType != null) { return sqlType; } Class[] interfaces = x.getInterfaces(); for (Class i : interfaces) { sqlType = types.get(i); if (sqlType != null) { return sqlType; } } } return null; }\n\n    ### Response:", "ground_truth": "Retrieves SQL type for provided type. All subclasses and interfaces are examined\nfor matching sql type.", "predict": "/**\r\n     * This method is used to lookup the SqlType for a given class. It starts by checking the class itself, then its superclasses, and finally its interfaces.\r\n     * \r\n     * @param clazz The class to lookup the SqlType for.\r\n     * @return The SqlType for the given class, or null if no mapping exists.\r\n     */\r\n    public SqlType lookup(final Class clazz) {\r\n        SqlType sqlType;\r\n        for (Class x = clazz; x != null; x = x.getSuperclass()) {\r\n            sqlType = types.get(clazz);\r\n            if (sqlType != null) {\r\n                return sqlType;\r\n            }\r\n            Class[] interfaces = x.getInterfaces();\r\n            for (Class i : interfaces) {\r\n                sqlType = types.get(i);\r\n                if (sqlType != null) {\r\n                    return sqlType;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1026, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) { SqlType sqlType = sqlTypes.get(sqlTypeClass); if (sqlType == null) { try { sqlType = ClassUtil.newInstance(sqlTypeClass); } catch (Exception ex) { throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex); } sqlTypes.put(sqlTypeClass, sqlType); } return sqlType; }\n\n    ### Response:", "ground_truth": "Returns sql type instance. Instances are stored for better performances.", "predict": "/**\n     * Looks up the SQL type for the given SQL type class. If the SQL type is not found in the cache, it creates a new instance of the SQL type class using reflection and adds it to the cache.\n     *\n     * @param sqlTypeClass the SQL type class to lookup\n     * @return the SQL type for the given SQL type class\n     * @throws DbSqlException if the SQL type class cannot be instantiated\n     */\n    public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) {\n        SqlType sqlType = sqlTypes.get(sqlTypeClass);\n        if (sqlType == null) {\n            try {\n                sqlType = ClassUtil.newInstance(sqlTypeClass);\n            } catch (Exception ex) {\n                throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex);\n            }\n            sqlTypes.put(sqlTypeClass, sqlType);\n        }\n        return sqlType;\n    }"}, {"ID": 1027, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null); }\n\n    ### Response:", "ground_truth": "Creates SOCKS4 proxy.", "predict": "/**\r\n     * Creates a new ProxyInfo object with the given SOCKS4 proxy information.\r\n     *\r\n     * @param proxyAddress the proxy server address\r\n     * @param proxyPort the proxy server port\r\n     * @param proxyUser the username to authenticate with the proxy server\r\n     * @return a new ProxyInfo object with the given SOCKS4 proxy information\r\n     */\r\n    public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) {\r\n        return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null);\r\n    }"}, {"ID": 1028, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); }\n\n    ### Response:", "ground_truth": "Creates SOCKS5 proxy.", "predict": "/**\r\n     * Creates a new ProxyInfo object with the given proxy information for SOCKS5 proxy type.\r\n     *\r\n     * @param proxyAddress the proxy address\r\n     * @param proxyPort the proxy port\r\n     * @param proxyUser the proxy user name\r\n     * @param proxyPassword the proxy password\r\n     * @return a new ProxyInfo object with the given proxy information for SOCKS5 proxy type\r\n     */\r\n    public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) {\r\n        return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword);\r\n    }"}, {"ID": 1029, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword); }\n\n    ### Response:", "ground_truth": "Creates HTTP proxy.", "predict": "/**\r\n     * Returns a ProxyInfo object with the given proxy information for HTTP connections.\r\n     *\r\n     * @param proxyAddress the proxy address\r\n     * @param proxyPort the proxy port\r\n     * @param proxyUser the proxy user name\r\n     * @param proxyPassword the proxy password\r\n     * @return a ProxyInfo object with the given proxy information for HTTP connections\r\n     */\r\n    public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) {\r\n        return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword);\r\n    }"}, {"ID": 1030, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int totalThreadTransactions() { ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { return 0; } return txList.size(); }\n\n    ### Response:", "ground_truth": "Returns total number of transactions associated with current thread.", "predict": "/**\r\n     * This method returns the total number of transactions in the current thread's transaction stack.\r\n     * \r\n     * @return the total number of transactions in the current thread's transaction stack.\r\n     */\r\n    public int totalThreadTransactions() {\r\n        ArrayList<JtxTransaction> txList = txStack.get();\r\n        if (txList == null) {\r\n            return 0;\r\n        }\r\n        return txList.size();\r\n    }"}, {"ID": 1031, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int totalThreadTransactionsWithStatus(final JtxStatus status) { ArrayList<JtxTransaction> txlist = txStack.get(); if (txlist == null) { return 0; } int count = 0; for (JtxTransaction tx : txlist) { if (tx.getStatus() == status) { count++; } } return count; }\n\n    ### Response:", "ground_truth": "Returns total number of transactions of the specified status associated with current thread.", "predict": "/**\r\n     * This method returns the total number of transactions in the thread with the given status.\r\n     * \r\n     * @param status The status of the transactions to be counted.\r\n     * @return The total number of transactions with the given status.\r\n     */\r\n    public int totalThreadTransactionsWithStatus(final JtxStatus status) {\r\n        ArrayList<JtxTransaction> txlist = txStack.get();\r\n        if (txlist == null) {\r\n            return 0;\r\n        }\r\n        int count = 0;\r\n        for (JtxTransaction tx : txlist) {\r\n            if (tx.getStatus() == status) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }"}, {"ID": 1032, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void associateTransaction(final JtxTransaction tx) { totalTransactions++; ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { txList = new ArrayList<>(); txStack.set(txList); } txList.add(tx); // add last }\n\n    ### Response:", "ground_truth": "Associate transaction to current thread.", "predict": "/**\r\n     * This method is used to associate a transaction with the current thread.\r\n     * \r\n     * @param tx - The transaction to be associated with the current thread.\r\n     */\r\n    protected void associateTransaction(final JtxTransaction tx) {\r\n        totalTransactions++;\r\n        ArrayList<JtxTransaction> txList = txStack.get();\r\n        if (txList == null) {\r\n            txList = new ArrayList<>();\r\n            txStack.set(txList);\r\n        }\r\n        txList.add(tx); // add last\r\n    }"}, {"ID": 1033, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) { if (!validateExistingTransaction) { return; } JtxTransactionMode sourceMode = sourceTx.getTransactionMode(); JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel(); if (destIsolationLevel != ISOLATION_DEFAULT) { JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel(); if (currentIsolationLevel != destIsolationLevel) { throw new JtxException(\"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel); } } if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) { throw new JtxException(\"Participating TX is not marked as read-only, but existing TX is\"); } }\n\n    ### Response:", "ground_truth": "Check if propagation of a transaction is possible, due to source and destination transaction modes.\n@see #setValidateExistingTransaction(boolean)", "predict": "/**\r\n     * This method is used to continue a transaction from a source transaction to a new transaction mode.\r\n     * \r\n     * @param sourceTx\r\n     *            The source transaction to continue from.\r\n     * @param destMode\r\n     *            The new transaction mode to continue to.\r\n     * @throws JtxException\r\n     *             If the new transaction mode is incompatible with the existing transaction.\r\n     */\r\n    protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1034, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; }\n\n    ### Response:", "ground_truth": "Lookups resource manager for provided type. Throws an exception if provider doesn't exists.", "predict": "/**\r\n     * Looks up the resource manager for the given resource type.\r\n     *\r\n     * @param resourceType the resource type\r\n     * @return the resource manager\r\n     * @throws JtxException if no resource manager is registered for the given resource type\r\n     */\r\n    protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; }"}, {"ID": 1035, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected C createProxyObject(Class<C> target) { target = ProxettaUtil.resolveTargetClass(target); Class proxyClass = cache.get(target); if (proxyClass == null) { proxyClass = proxetta.defineProxy(target); cache.put(target, proxyClass); } C proxy; try { proxy = (C) ClassUtil.newInstance(proxyClass); } catch (Exception ex) { throw new PathrefException(ex); } return proxy; }\n\n    ### Response:", "ground_truth": "Creates proxy object.", "predict": "/**\r\n     * Creates a proxy object for the given target class.\r\n     * \r\n     * @param target the target class to create a proxy for\r\n     * @return the proxy object\r\n     */\r\n    protected C createProxyObject(Class<C> target) {\r\n        target = ProxettaUtil.resolveTargetClass(target);\r\n        Class proxyClass = cache.get(target);\r\n        if (proxyClass == null) {\r\n            proxyClass = proxetta.defineProxy(target);\r\n            cache.put(target, proxyClass);\r\n        }\r\n        C proxy;\r\n        try {\r\n            proxy = (C) ClassUtil.newInstance(proxyClass);\r\n        } catch (Exception ex) {\r\n            throw new PathrefException(ex);\r\n        }\r\n        return proxy;\r\n    }"}, {"ID": 1036, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void append(final String methodName) { if (path.length() != 0) { path += StringPool.DOT; } if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) { path = StringUtil.substring(path, 0, -1); } path += methodName; }\n\n    ### Response:", "ground_truth": "Appends method name to existing path.", "predict": "/**\r\n     * Appends the given method name to the current path.\r\n     * \r\n     * @param methodName the method name to append\r\n     */\r\n    protected void append(final String methodName) {\r\n        if (path.length() != 0) {\r\n            path += StringPool.DOT;\r\n        }\r\n        if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) {\r\n            path = StringUtil.substring(path, 0, -1);\r\n        }\r\n        path += methodName;\r\n    }"}, {"ID": 1037, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String alignLeftAndPad(final String text, final int size) { int textLength = text.length(); if (textLength > size) { return text.substring(0, size); } final StringBuilder sb = new StringBuilder(size); sb.append(text); while (textLength++ < size) { sb.append(' '); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Puts the text to the left and pads with spaces until the size is reached.", "predict": "/**\r\n     * This method takes a string and pads it with spaces on the right until it reaches the specified size.\r\n     * If the string is already larger than the specified size, it will be truncated.\r\n     * \r\n     * @param text the string to be padded\r\n     * @param size the desired size of the padded string\r\n     * @return the padded string\r\n     */\r\n    public static String alignLeftAndPad(final String text, final int size) {\r\n        int textLength = text.length();\r\n        if (textLength > size) {\r\n            return text.substring(0, size);\r\n        }\r\n        final StringBuilder sb = new StringBuilder(size);\r\n        sb.append(text);\r\n        while (textLength++ < size) {\r\n            sb.append(' ');\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1038, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toPrettyString(final Object value) { if (value == null) { return StringPool.NULL; } final Class<?> type = value.getClass(); if (type.isArray()) { final Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { final StringBuilder sb = new StringBuilder(); sb.append('['); if (componentType == int.class) { sb.append(ArraysUtil.toString((int[]) value)); } else if (componentType == long.class) { sb.append(ArraysUtil.toString((long[]) value)); } else if (componentType == double.class) { sb.append(ArraysUtil.toString((double[]) value)); } else if (componentType == float.class) { sb.append(ArraysUtil.toString((float[]) value)); } else if (componentType == boolean.class) { sb.append(ArraysUtil.toString((boolean[]) value)); } else if (componentType == short.class) { sb.append(ArraysUtil.toString((short[]) value)); } else if (componentType == byte.class) { sb.append(ArraysUtil.toString((byte[]) value)); } else { throw new IllegalArgumentException(); } sb.append(']'); return sb.toString(); } else { final StringBuilder sb = new StringBuilder(); sb.append('['); final Object[] array = (Object[]) value; for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(array[i])); } sb.append(']'); return sb.toString(); } } else if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final StringBuilder sb = new StringBuilder(); sb.append('{'); int i = 0; for (final Object o : iterable) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(o)); i++; } sb.append('}'); return sb.toString(); } return value.toString(); }\n\n    ### Response:", "ground_truth": "Converts object into pretty string. All arrays are iterated.", "predict": "/**\r\n * Converts the given value to a pretty string representation.\r\n *\r\n * @param value the value to convert\r\n * @return the pretty string representation of the value\r\n */\r\npublic static String toPrettyString(final Object value) {\r\n    // implementation goes here\r\n}"}, {"ID": 1039, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) { final int length = input.length(); final StringBuilder sb = new StringBuilder(length); boolean upperCase = firstCharUppercase; for (int i = 0; i < length; i++) { final char ch = input.charAt(i); if (ch == separator) { upperCase = true; } else if (upperCase) { sb.append(Character.toUpperCase(ch)); upperCase = false; } else { sb.append(ch); } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Converts separated string value to CamelCase.", "predict": "/**\r\n     * Converts a string to camel case.\r\n     * \r\n     * @param input the input string\r\n     * @param firstCharUppercase whether the first character should be uppercase or not\r\n     * @param separator the separator character\r\n     * @return the camel case string\r\n     */\r\n    public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) {\r\n        final int length = input.length();\r\n        final StringBuilder sb = new StringBuilder(length);\r\n        boolean upperCase = firstCharUppercase;\r\n        for (int i = 0; i < length; i++) {\r\n            final char ch = input.charAt(i);\r\n            if (ch == separator) {\r\n                upperCase = true;\r\n            } else if (upperCase) {\r\n                sb.append(Character.toUpperCase(ch));\r\n                upperCase = false;\r\n            } else {\r\n                sb.append(ch);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1040, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) { StringBuilder str = new StringBuilder(); int total = src.length(); int from = 0; while (from < total) { int to = from + len; if (to >= total) { to = total; } else if (breakOnWhitespace) { int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from); if (ndx != -1) { to = ndx + 1; } } int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to); if (cutFrom != -1) { int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1; str.append(src, cutFrom, cutTo); } str.append('\\n'); from = to; } return str.toString(); }\n\n    ### Response:", "ground_truth": "Formats provided string as paragraph.", "predict": "/**\r\n     * Formats a paragraph of text into lines of a specified length.\r\n     * \r\n     * @param src the source text to format\r\n     * @param len the maximum length of each line\r\n     * @param breakOnWhitespace whether to break lines on whitespace\r\n     * @return the formatted text\r\n     */\r\n    public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) {\r\n        StringBuilder str = new StringBuilder();\r\n        int total = src.length();\r\n        int from = 0;\r\n        while (from < total) {\r\n            int to = from + len;\r\n            if (to >= total) {\r\n                to = total;\r\n            } else if (breakOnWhitespace) {\r\n                int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from);\r\n                if (ndx != -1) {\r\n                    to = ndx + 1;\r\n                }\r\n            }\r\n            int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to);\r\n            if (cutFrom != -1) {\r\n               "}, {"ID": 1041, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String convertTabsToSpaces(final String line, final int tabWidth) { int tab_index, tab_size; int last_tab_index = 0; int added_chars = 0; if (tabWidth == 0) { return StringUtil.remove(line, '\\t'); } StringBuilder result = new StringBuilder(); while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) { tab_size = tabWidth - ((tab_index + added_chars) % tabWidth); if (tab_size == 0) { tab_size = tabWidth; } added_chars += tab_size - 1; result.append(line, last_tab_index, tab_index); result.append(StringUtil.repeat(' ', tab_size)); last_tab_index = tab_index+1; } if (last_tab_index == 0) { return line; } result.append(line.substring(last_tab_index)); return result.toString(); }\n\n    ### Response:", "ground_truth": "Converts all tabs on a line to spaces according to the provided tab width.\nThis is not a simple tab to spaces replacement, since the resulting\nindentation remains the same.", "predict": "/**\r\n     * Converts all tabs in the given line to the specified number of spaces.\r\n     *\r\n     * @param line the line to convert\r\n     * @param tabWidth the number of spaces to replace each tab with\r\n     * @return the converted line\r\n     */\r\n    public static String convertTabsToSpaces(final String line, final int tabWidth) {\r\n        int tab_index, tab_size;\r\n        int last_tab_index = 0;\r\n        int added_chars = 0;\r\n        if (tabWidth == 0) {\r\n            return StringUtil.remove(line, '\\t');\r\n        }\r\n        StringBuilder result = new StringBuilder();\r\n        while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) {\r\n            tab_size = tabWidth - ((tab_index + added_chars) % tabWidth);\r\n            if (tab_size == 0) {\r\n                tab_size = tabWidth;\r\n            }\r\n            added_chars += tab_size - 1;\r\n            result.append(line"}, {"ID": 1042, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String escapeJava(final String string) { int strLen = string.length(); StringBuilder sb = new StringBuilder(strLen); for (int i = 0; i < strLen; i++) { char c = string.charAt(i); switch (c) { case '\\b' : sb.append(\"\\\\b\"); break; case '\\t' : sb.append(\"\\\\t\"); break; case '\\n' : sb.append(\"\\\\n\"); break; case '\\f' : sb.append(\"\\\\f\"); break; case '\\r' : sb.append(\"\\\\r\"); break; case '\\\"' : sb.append(\"\\\\\\\"\"); break; case '\\\\' : sb.append(\"\\\\\\\\\"); break; default: if ((c < 32) || (c > 127)) { String hex = Integer.toHexString(c); sb.append(\"\\\\u\"); for (int k = hex.length(); k < 4; k++) { sb.append('0'); } sb.append(hex); } else { sb.append(c); } } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Escapes a string using java rules.", "predict": "/**\r\n     * Escapes the characters in a string using Java String rules.\r\n     *\r\n     * @param string the string to be escaped\r\n     * @return the escaped string\r\n     */\r\n    public static String escapeJava(final String string) {\r\n        int strLen = string.length();\r\n        StringBuilder sb = new StringBuilder(strLen);\r\n        for (int i = 0; i < strLen; i++) {\r\n            char c = string.charAt(i);\r\n            switch (c) {\r\n                case '\\b':\r\n                    sb.append(\"\\\\b\");\r\n                    break;\r\n                case '\\t':\r\n                    sb.append(\"\\\\t\");\r\n                    break;\r\n                case '\\n':\r\n                    sb.append(\"\\\\n\");\r\n                    break;\r\n                case '\\f':\r\n                    sb.append(\"\\\\f\");\r\n                    break;\r\n                case '\\r':\r\n                    sb.append(\"\\\\r\");\r\n                    break;\r\n                case '\\\"':\r\n                    sb.append(\"\\\\\\\"\");\r\n                    break;\r\n                case '\\\\':\r\n                    sb.append(\"\\\\\\\\\");\r\n                    break;\r\n                default:\r\n                    if ((c < 32) ||"}, {"ID": 1043, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String unescapeJava(final String str) { char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(str.length()); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c != '\\\\') { sb.append(c); continue; } i++; c = chars[i]; switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\\\"'); break; case '\\\\': sb.append('\\\\'); break; case 'u' : char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16); sb.append(hex); i += 4; break; default: throw new IllegalArgumentException(\"Invalid escaping character: \" + c); } } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Unescapes a string using java rules.", "predict": "/**\r\n     * Unescapes a Java string by replacing any Unicode escape sequences with the corresponding Unicode characters.\r\n     *\r\n     * @param str the string to unescape\r\n     * @return the unescaped string\r\n     * @throws IllegalArgumentException if an invalid escape sequence is encountered\r\n     */\r\n    public static String unescapeJava(final String str) {\r\n        char[] chars = str.toCharArray();\r\n        StringBuilder sb = new StringBuilder(str.length());\r\n        for (int i = 0; i < chars.length; i++) {\r\n            char c = chars[i];\r\n            if (c != '\\\\') {\r\n                sb.append(c);\r\n                continue;\r\n            }\r\n            i++;\r\n            c = chars[i];\r\n            switch (c) {\r\n                case 'b':\r\n                    sb.append('\\b');\r\n                    break;\r\n                case 't':\r\n                    sb.append('\\t');\r\n                    break;\r\n                case 'n':\r\n                    sb.append('\\n');\r\n                    break;\r\n                case 'f':\r\n                    sb.append('\\f');\r\n                    break;\r\n                case 'r':"}, {"ID": 1044, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final Class<T> type) { String name = resolveBeanName(type); return (T) getBean(name); }\n\n    ### Response:", "ground_truth": "Returns Petite bean instance. Bean name will be resolved from provided type.", "predict": "/**\r\n     * Gets the bean of the specified type.\r\n     * \r\n     * @param type the type of the bean to retrieve\r\n     * @return the bean of the specified type\r\n     */\r\n    @SuppressWarnings({\"unchecked\"})\r\n    public <T> T getBean(final Class<T> type) {\r\n        String name = resolveBeanName(type);\r\n        return (T) getBean(name);\r\n    }"}, {"ID": 1045, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T getBean(final String name) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name); if (def == null) { // try provider ProviderDefinition providerDefinition = providers.get(name); if (providerDefinition != null) { return (T) invokeProvider(providerDefinition); } return null; } // Find the bean in its scope Object bean = def.scopeLookup(); if (bean == null) { // Create new bean in the scope initBeanDefinition(def); final BeanData beanData = new BeanData(this, def); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData); bean = beanData.bean(); } return (T) bean; }\n\n    ### Response:", "ground_truth": "Returns Petite bean instance.\nPetite container will find the bean in corresponding scope and all its dependencies,\neither by constructor or property injection. When using constructor injection, cyclic dependencies\ncan not be prevented, but at least they are detected.\n\n@see PetiteContainer#createBean(Class)", "predict": "/**\r\n     * Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name);\r\n     * \r\n     * If the bean definition is null, try to find a provider definition in the provider map.\r\n     * If a provider definition is found, invoke the provider to create the bean.\r\n     * \r\n     * If the provider definition is not found, return null.\r\n     * \r\n     * If the bean is not found in its scope, create a new bean in the scope and initialize it.\r\n     * \r\n     * Register the bean, wire and inject its parameters and invoke its initialization methods.\r\n     * \r\n     * Return the bean.\r\n     * \r\n     * @param <T>\r\n     * @param name\r\n     * @return\r\n     */"}, {"ID": 1046, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initBeanDefinition(final BeanDefinition def) { // init methods if (def.initMethods == null) { def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type); } // destroy methods if (def.destroyMethods == null) { def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type); } // properties if (def.properties == null) { def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // methods if (def.methods == null) { def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type); } // ctors if (def.ctor == null) { def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type); } // values if (def.values == null) { def.values = paramManager.resolveParamInjectionPoints(def.type); } // sets if (def.sets == null) { def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // params if (def.params == null) { def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters()); } }\n\n    ### Response:", "ground_truth": "Resolves and initializes bean definition. May be called multiple times.", "predict": "/**\n     * Initializes the given bean definition by resolving its init methods, destroy methods, properties, methods, constructor, parameter values, set methods, and parameter references.\n     *\n     * @param def the bean definition to initialize\n     */\n    protected void initBeanDefinition(final BeanDefinition def) { // init methods if (def.initMethods == null) { def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type); } // destroy methods if (def.destroyMethods == null) { def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type); } // properties if (def.properties == null) { def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // methods if (def.methods == null) { def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type); } // ctors if (def.ctor == null) { def.ctor = petiteResolvers."}, {"ID": 1047, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeProvider(final ProviderDefinition provider) { if (provider.method != null) { final Object bean; if (provider.beanName != null) { // instance factory method bean = getBean(provider.beanName); } else { // static factory method bean = null; } try { return provider.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid provider method: \" + provider.method.getName(), ex); } } throw new PetiteException(\"Invalid provider\"); }\n\n    ### Response:", "ground_truth": "Invokes provider to get a bean.", "predict": "/**\r\n     * Invokes the provider method on the specified bean.\r\n     * \r\n     * @param provider the provider definition\r\n     * @return the result of the provider method invocation\r\n     * @throws PetiteException if the provider is invalid or the provider method invocation fails\r\n     */\r\n    protected Object invokeProvider(final ProviderDefinition provider) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1048, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addBean(final String name, final Object bean, WiringMode wiringMode) { wiringMode = petiteConfig.resolveWiringMode(wiringMode); registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null); BeanDefinition def = lookupExistingBeanDefinition(name); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean)); }\n\n    ### Response:", "ground_truth": "Adds object instance to the container as singleton bean.", "predict": "/**\n     * Adds a new bean to the container.\n     *\n     * @param name the name of the bean to add\n     * @param bean the bean instance to add\n     * @param wiringMode the wiring mode to use for the bean\n     */\n    public void addBean(final String name, final Object bean, WiringMode wiringMode) {\n        wiringMode = petiteConfig.resolveWiringMode(wiringMode);\n        registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null);\n        BeanDefinition def = lookupExistingBeanDefinition(name);\n        registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean));\n    }"}, {"ID": 1049, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setBeanProperty(final String name, final Object value) { Object bean = null; int ndx = name.length(); while (true) { ndx = name.lastIndexOf('.', ndx); if (ndx == -1) { break; } String beanName = name.substring(0, ndx); bean = getBean(beanName); if (bean != null) { break; } ndx--; } if (bean == null) { throw new PetiteException(\"Invalid bean property: \" + name); } try { BeanUtil.declared.setProperty(bean, name.substring(ndx + 1), value); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } }\n\n    ### Response:", "ground_truth": "Sets petite bean property.", "predict": "/**\r\n     * Sets the value of a property of a bean.\r\n     * \r\n     * @param name the name of the property to set, in the form \"beanName.propertyName\"\r\n     * @param value the value to set the property to\r\n     * @throws PetiteException if the property cannot be set\r\n     */\r\n    public void setBeanProperty(final String name, final Object value) {\r\n        Object bean = null;\r\n        int ndx = name.length();\r\n        while (true) {\r\n            ndx = name.lastIndexOf('.', ndx);\r\n            if (ndx == -1) {\r\n                break;\r\n            }\r\n            String beanName = name.substring(0, ndx);\r\n            bean = getBean(beanName);\r\n            if (bean != null) {\r\n                break;\r\n            }\r\n            ndx--;\r\n        }\r\n        if (bean == null) {\r\n            throw new PetiteException(\"Invalid bean property: \" + name);\r\n        }\r\n        try {\r\n            BeanUtil.declared.setProperty(bean, name.substring(ndx + 1"}, {"ID": 1050, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getBeanProperty(final String name) { int ndx = name.indexOf('.'); if (ndx == -1) { throw new PetiteException(\"Only bean name is specified, missing property name: \" + name); } String beanName = name.substring(0, ndx); Object bean = getBean(beanName); if (bean == null) { throw new PetiteException(\"Bean doesn't exist: \" + name); } try { return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1)); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } }\n\n    ### Response:", "ground_truth": "Returns petite bean property value.", "predict": "/**\r\n     * Gets the property of a bean specified by its name.\r\n     *\r\n     * @param name the name of the bean and the property separated by a dot.\r\n     * @return the property value.\r\n     * @throws PetiteException if the bean or property doesn't exist or if the property is not accessible.\r\n     */\r\n    public Object getBeanProperty(final String name) {\r\n        int ndx = name.indexOf('.');\r\n        if (ndx == -1) {\r\n            throw new PetiteException(\"Only bean name is specified, missing property name: \" + name);\r\n        }\r\n        String beanName = name.substring(0, ndx);\r\n        Object bean = getBean(beanName);\r\n        if (bean == null) {\r\n            throw new PetiteException(\"Bean doesn't exist: \" + name);\r\n        }\r\n        try {\r\n            return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1));\r\n        } catch (Exception ex) {\r\n            throw new PetiteException(\"Invalid bean property: \" +"}, {"ID": 1051, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void shutdown() { scopes.forEachValue(Scope::shutdown); externalsCache.clear(); beans.clear(); beansAlt.clear(); scopes.clear(); providers.clear(); beanCollections.clear(); }\n\n    ### Response:", "ground_truth": "Shutdowns container. After container is down, it can't be used anymore.", "predict": "/**\r\n     * Shuts down the application by shutting down all the scopes, clearing the caches, and removing all the beans.\r\n     */\r\n    public void shutdown() {\r\n        scopes.forEachValue(Scope::shutdown);\r\n        externalsCache.clear();\r\n        beans.clear();\r\n        beansAlt.clear();\r\n        scopes.clear();\r\n        providers.clear();\r\n        beanCollections.clear();\r\n    }"}, {"ID": 1052, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) { Class[] paramTypes; Class declaringClass; String name; if (methodOrCtor instanceof Method) { Method method = (Method) methodOrCtor; paramTypes = method.getParameterTypes(); name = method.getName(); declaringClass = method.getDeclaringClass(); } else { Constructor constructor = (Constructor) methodOrCtor; paramTypes = constructor.getParameterTypes(); declaringClass = constructor.getDeclaringClass(); name = CTOR_METHOD; } if (paramTypes.length == 0) { return MethodParameter.EMPTY_ARRAY; } InputStream stream; try { stream = ClassLoaderUtil.getClassAsStream(declaringClass); } catch (IOException ioex) { throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex); } if (stream == null) { throw new ParamoException(\"Class not found: \" + declaringClass); } try { ClassReader reader = new ClassReader(stream); MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes); reader.accept(visitor, 0); return visitor.getResolvedParameters(); } catch (IOException ioex) { throw new ParamoException(ioex); } finally { StreamUtil.close(stream); } }\n\n    ### Response:", "ground_truth": "Resolves method parameters from a method or constructor.\nReturns an empty array when target does not contain any parameter.\nNo caching is involved in this process, i.e. class bytecode\nis examined every time this method is called.", "predict": "/**\n     * Resolves the parameters of the given method or constructor.\n     *\n     * @param methodOrCtor the method or constructor to resolve the parameters for\n     * @return the resolved parameters\n     * @throws ParamoException if the parameters cannot be resolved\n     */\n    public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1053, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int doAfterBody() throws JspException { BodyContent body = getBodyContent(); JspWriter out = body.getEnclosingWriter(); String bodytext = populateForm(body.getString(), name -> value(name, pageContext)); try { out.print(bodytext); } catch (IOException ioex) { throw new JspException(ioex); } return SKIP_BODY; }\n\n    ### Response:", "ground_truth": "Performs smart form population.", "predict": "/**\r\n     * This method is called after the body of the tag is evaluated.\r\n     * \r\n     * @return int\r\n     * @throws JspException\r\n     */\r\n    @Override public int doAfterBody() throws JspException {\r\n        // BodyContent body = getBodyContent();\r\n        // JspWriter out = body.getEnclosingWriter();\r\n        // String bodytext = populateForm(body.getString(), name -> value(name, pageContext));\r\n        // try {\r\n        //     out.print(bodytext);\r\n        // } catch (IOException ioex) {\r\n        //     throw new JspException(ioex);\r\n        // }\r\n        // return SKIP_BODY;\r\n    }"}, {"ID": 1054, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getValue(final String... profiles) { if (hasMacro) { return propsData.resolveMacros(value, profiles); } return value; }\n\n    ### Response:", "ground_truth": "Returns the property value, with replaced macros.", "predict": "/**\r\n     * Returns the value of the property. If the property has macro, it will be resolved using the given profiles.\r\n     * \r\n     * @param profiles the profiles to be used for macro resolution\r\n     * @return the value of the property\r\n     */\r\n    public String getValue(final String... profiles) {\r\n        if (hasMacro) {\r\n            return propsData.resolveMacros(value, profiles);\r\n        }\r\n        return value;\r\n    }"}, {"ID": 1055, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void end() { if (parentNode != rootNode) { Node thisNode = parentNode; while (thisNode != rootNode) { if (domBuilder.config.isImpliedEndTags()) { if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) { thisNode = thisNode.getParentNode(); continue; } } error(\"Unclosed tag closed: <\" + thisNode.getNodeName() + \">\"); thisNode = thisNode.getParentNode(); } } // remove whitespaces if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } // foster if (domBuilder.config.isUseFosterRules()) { HtmlFosterRules fosterRules = new HtmlFosterRules(); fosterRules.fixFosterElements(rootNode); } // elapsed rootNode.end(); if (log.isDebugEnabled()) { log.debug(\"LagartoDom tree created in \" + rootNode.getElapsedTime() + \" ms\"); } }\n\n    ### Response:", "ground_truth": "Finishes the tree building. Closes unclosed tags.", "predict": "/**\n     * Ends the parsing of the document.\n     * \n     * @throws IOException\n     *             if an I/O error occurs\n     */\n    @Override\n    public void end() throws IOException {\n        if (parentNode != rootNode) {\n            Node thisNode = parentNode;\n            while (thisNode != rootNode) {\n                if (domBuilder.config.isImpliedEndTags()) {\n                    if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) {\n                        thisNode = thisNode.getParentNode();\n                        continue;\n                    }\n                }\n                error(\"Unclosed tag closed: <\" + thisNode.getNodeName() + \">\");\n                thisNode = thisNode.getParentNode();\n            }\n        }\n        // remove whitespaces\n        if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) {\n            removeLastChildNodeIfEmptyText(parentNode, true);\n        }\n        // foster\n        if (domBuilder.config.isUseFosterRules()) {\n            HtmlF"}, {"ID": 1056, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Element createElementNode(final Tag tag) { boolean hasVoidTags = htmlVoidRules != null; boolean isVoid = false; boolean selfClosed = false; if (hasVoidTags) { isVoid = htmlVoidRules.isVoidTag(tag.getName()); // HTML and XHTML if (isVoid) { // it's void tag, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } } else { // XML, no voids, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } return new Element(rootNode, tag, isVoid, selfClosed); }\n\n    ### Response:", "ground_truth": "Creates new element with correct configuration.", "predict": "/**\r\n     * Creates a new element node with the given tag.\r\n     * \r\n     * @param tag the tag of the element node to create\r\n     * @return the new element node\r\n     */\r\n    protected Element createElementNode(final Tag tag) {\r\n        boolean hasVoidTags = htmlVoidRules != null;\r\n        boolean isVoid = false;\r\n        boolean selfClosed = false;\r\n        if (hasVoidTags) {\r\n            isVoid = htmlVoidRules.isVoidTag(tag.getName()); // HTML and XHTML\r\n            if (isVoid) { // it's void tag, lookup the flag\r\n                selfClosed = domBuilder.config.isSelfCloseVoidTags();\r\n            }\r\n        } else { // XML, no voids, lookup the flag\r\n            selfClosed = domBuilder.config.isSelfCloseVoidTags();\r\n        }\r\n        return new Element(rootNode, tag, isVoid, selfClosed);\r\n    }"}, {"ID": 1057, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void tag(final Tag tag) { if (!enabled) { return; } TagType tagType = tag.getType(); Element node; switch (tagType) { case START: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); if (domBuilder.config.isImpliedEndTags()) { while (true) { String parentNodeName = parentNode.getNodeName(); if (!implRules.implicitlyCloseParentTagOnNewTag(parentNodeName, node.getNodeName())) { break; } parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + node.getNodeName() + \"> \"); } } } parentNode.addChild(node); if (!node.isVoidElement()) { parentNode = node; } break; case END: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } String tagName = tag.getName().toString(); Node matchingParent = findMatchingParentOpenTag(tagName); if (matchingParent == parentNode) { // regular situation parentNode = parentNode.getParentNode(); break; } if (matchingParent == null) { // matching open tag not found, remove it error(\"Orphan closed tag ignored: </\" + tagName + \"> \" + tag.getTagPosition()); break; } // try to close it implicitly if (domBuilder.config.isImpliedEndTags()) { boolean fixed = false; while (implRules.implicitlyCloseParentTagOnTagEnd(parentNode.getNodeName(), tagName)) { parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + tagName + \">\"); } if (parentNode == matchingParent) { parentNode = matchingParent.parentNode; fixed = true; break; } } if (fixed) { break; } } // matching tag found, but it is not a regular situation // therefore close all unclosed tags in between fixUnclosedTagsUpToMatchingParent(tag, matchingParent); break; case SELF_CLOSING: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); parentNode.addChild(node); break; } }\n\n    ### Response:", "ground_truth": "Visits tags.", "predict": "/**\n     * This method is used to add a tag to the DOM tree. It is called by the {@link DOMBuilder} when it encounters a tag in the input stream.\n     * \n     * @param tag the tag to be added to the DOM tree\n     */\n    @Override\n    public void tag(final Tag tag) {\n        // implementation details elided for brevity\n    }"}, {"ID": 1058, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) { if (parentNode == null) { return; } Node lastChild = parentNode.getLastChild(); if (lastChild == null) { return; } if (lastChild.getNodeType() != Node.NodeType.TEXT) { return; } if (closedTag) { if (parentNode.getChildNodesCount() == 1) { return; } } Text text = (Text) lastChild; if (text.isBlank()) { lastChild.detachFromParent(); } }\n\n    ### Response:", "ground_truth": "Removes last child node if contains just empty text.", "predict": "/**\r\n     * Removes the last child node of the given parent node if it is a text node with only whitespace characters.\r\n     * \r\n     * @param parentNode the parent node to remove the last child node from\r\n     * @param closedTag true if the parent node is a closed tag, false otherwise\r\n     */\r\n    protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) {\r\n        if (parentNode == null) {\r\n            return;\r\n        }\r\n        Node lastChild = parentNode.getLastChild();\r\n        if (lastChild == null) {\r\n            return;\r\n        }\r\n        if (lastChild.getNodeType() != Node.NodeType.TEXT) {\r\n            return;\r\n        }\r\n        if (closedTag) {\r\n            if (parentNode.getChildNodesCount() == 1) {\r\n                return;\r\n            }\r\n        }\r\n        Text text = (Text) lastChild;\r\n        if (text.isBlank()) {\r\n            lastChild.detachFromParent();\r\n        }\r\n    }"}, {"ID": 1059, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getQueryString() { if (sqlTemplate == null) { return toString(); } if (parameterValues == null) { return sqlTemplate; } final StringBuilder sb = new StringBuilder(); int qMarkCount = 0; final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', \"?\"); while (tok.hasMoreTokens()) { final String oneChunk = tok.nextToken(); sb.append(oneChunk); try { Object value = null; if (parameterValues.size() > 1 + qMarkCount) { value = parameterValues.get(1 + qMarkCount); qMarkCount++; } else { if (!tok.hasMoreTokens()) { value = \"\"; } } if (value == null) { value = \"?\"; } sb.append(value); } catch (Throwable th) { sb.append(\"--- Building query failed: \").append(th.toString()); } } return sb.toString().trim(); }\n\n    ### Response:", "ground_truth": "Returns the query string.", "predict": "/**\r\n     * This method generates the query string with the given parameter values.\r\n     * \r\n     * @return the query string with parameter values\r\n     */\r\n    public String getQueryString() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1060, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getActionClassName(final Object action) { Class clazz = action.getClass(); clazz = ProxettaUtil.resolveTargetClass(clazz); return clazz.getName(); }\n\n    ### Response:", "ground_truth": "Returns correct action class name. Detects Proxetta classes.", "predict": "/**\r\n     * Returns the fully qualified class name of the given action object.\r\n     * \r\n     * @param action the action object\r\n     * @return the fully qualified class name of the given action object\r\n     */\r\n    protected String getActionClassName(final Object action) {\r\n        Class clazz = action.getClass();\r\n        clazz = ProxettaUtil.resolveTargetClass(clazz);\r\n        return clazz.getName();\r\n    }"}, {"ID": 1061, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int calculateTo(final int from, final int count, final int size) { int to = size; if (count != -1) { to = from + count; if (to > size) { to = size; } } return to; }\n\n    ### Response:", "ground_truth": "Calculates 'TO'.", "predict": "/**\r\n     * Calculates the \"to\" index for a given \"from\" index, count, and size.\r\n     * \r\n     * @param from the starting index\r\n     * @param count the number of elements to retrieve, or -1 to retrieve all remaining elements\r\n     * @param size the total number of elements in the collection\r\n     * @return the \"to\" index for the given parameters\r\n     */\r\n    protected int calculateTo(final int from, final int count, final int size) {\r\n        int to = size;\r\n        if (count != -1) {\r\n            to = from + count;\r\n            if (to > size) {\r\n                to = size;\r\n            }\r\n        }\r\n        return to;\r\n    }"}, {"ID": 1062, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); Iterator iter = collection.iterator(); int i = 0; int to = calculateTo(from, count, collection.size()); while (i < to) { Object item = iter.next(); if (i >= from) { if (status != null) { iteratorStatus.next(!iter.hasNext()); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } i++; } }\n\n    ### Response:", "ground_truth": "Iterates collection.", "predict": "/**\r\n     * Iterates over a collection and renders the body for each item in the specified range.\r\n     * \r\n     * @param collection the collection to iterate over\r\n     * @param from the index of the first item to render\r\n     * @param count the number of items to render\r\n     * @param pageContext the page context\r\n     * @throws JspException if an error occurs during rendering\r\n     */\r\n    protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1063, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); int len = array.length; int to = calculateTo(from, count, len); int last = to - 1; for (int i = from; i < to; i++) { Object item = array[i]; if (status != null) { iteratorStatus.next(i == last); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } }\n\n    ### Response:", "ground_truth": "Iterates arrays.", "predict": "/**\r\n     * Iterates over the specified array, starting from the specified index and for the specified number of iterations.\r\n     * \r\n     * @param array the array to iterate over\r\n     * @param from the index to start from\r\n     * @param count the number of iterations to perform\r\n     * @param pageContext the current page context\r\n     * @throws JspException if an error occurs during iteration\r\n     */\r\n    protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1064, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replace(final String s, final String sub, final String with) { if (sub.isEmpty()) { return s; } int c = 0; int i = s.indexOf(sub, c); if (i == -1) { return s; } int length = s.length(); StringBuilder sb = new StringBuilder(length + with.length()); do { sb.append(s, c, i); sb.append(with); c = i + sub.length(); } while ((i = s.indexOf(sub, c)) != -1); if (c < length) { sb.append(s, c, length); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a certain pattern in a string with a\nreplacement string. This is the fastest replace function known to author.\n\n@param s      string to be inspected\n@param sub    string pattern to be replaced\n@param with   string that should go where the pattern was", "predict": "/**\r\n     * Replaces all occurrences of a substring within a string with a new substring.\r\n     *\r\n     * @param s the original string\r\n     * @param sub the substring to be replaced\r\n     * @param with the new substring\r\n     * @return the resulting string\r\n     */\r\n    public static String replace(final String s, final String sub, final String with) {\r\n        // TODO: implement the method\r\n    }"}, {"ID": 1065, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceChar(final String s, final char sub, final char with) { int startIndex = s.indexOf(sub); if (startIndex == -1) { return s; } char[] str = s.toCharArray(); for (int i = startIndex; i < str.length; i++) { if (str[i] == sub) { str[i] = with; } } return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a character in a string.\n\n@param s      input string\n@param sub    character to replace\n@param with   character to replace with", "predict": "/**\r\n     * Replaces all occurrences of a character in a string with another character.\r\n     * \r\n     * @param s the input string\r\n     * @param sub the character to be replaced\r\n     * @param with the character to replace the sub character with\r\n     * @return the modified string\r\n     */\r\n    public static String replaceChar(final String s, final char sub, final char with) {\r\n        int startIndex = s.indexOf(sub);\r\n        if (startIndex == -1) {\r\n            return s;\r\n        }\r\n        char[] str = s.toCharArray();\r\n        for (int i = startIndex; i < str.length; i++) {\r\n            if (str[i] == sub) {\r\n                str[i] = with;\r\n            }\r\n        }\r\n        return new String(str);\r\n    }"}, {"ID": 1066, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceChars(final String s, final char[] sub, final char[] with) { char[] str = s.toCharArray(); for (int i = 0; i < str.length; i++) { char c = str[i]; for (int j = 0; j < sub.length; j++) { if (c == sub[j]) { str[i] = with[j]; break; } } } return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces all occurrences of a characters in a string.\n\n@param s      input string\n@param sub    characters to replace\n@param with   characters to replace with", "predict": "/**\r\n     * Replaces all occurrences of the characters in the sub array with the corresponding characters in the with array in the given string.\r\n     * \r\n     * @param s the string to be modified\r\n     * @param sub the characters to be replaced\r\n     * @param with the replacement characters\r\n     * @return the modified string\r\n     */\r\n    public static String replaceChars(final String s, final char[] sub, final char[] with) {\r\n        char[] str = s.toCharArray();\r\n        for (int i = 0; i < str.length; i++) {\r\n            char c = str[i];\r\n            for (int j = 0; j < sub.length; j++) {\r\n                if (c == sub[j]) {\r\n                    str[i] = with[j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return new String(str);\r\n    }"}, {"ID": 1067, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceFirst(final String s, final String sub, final String with) { int i = s.indexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); }\n\n    ### Response:", "ground_truth": "Replaces the very first occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": "/**\r\n     * Replaces the first occurrence of a substring within a string with a new string.\r\n     * \r\n     * @param s the original string\r\n     * @param sub the substring to be replaced\r\n     * @param with the new string to replace the substring with\r\n     * @return the modified string\r\n     */\r\n    public static String replaceFirst(final String s, final String sub, final String with) {\r\n        int i = s.indexOf(sub);\r\n        if (i == -1) {\r\n            return s;\r\n        }\r\n        return s.substring(0, i) + with + s.substring(i + sub.length());\r\n    }"}, {"ID": 1068, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceFirst(final String s, final char sub, final char with) { int index = s.indexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces the very first occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": "/**\r\n     * Replaces the first occurrence of a specified character in a string with another character.\r\n     * \r\n     * @param s the input string\r\n     * @param sub the character to be replaced\r\n     * @param with the replacement character\r\n     * @return the resulting string\r\n     */\r\n    public static String replaceFirst(final String s, final char sub, final char with) {\r\n        int index = s.indexOf(sub);\r\n        if (index == -1) {\r\n            return s;\r\n        }\r\n        char[] str = s.toCharArray();\r\n        str[index] = with;\r\n        return new String(str);\r\n    }"}, {"ID": 1069, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceLast(final String s, final String sub, final String with) { int i = s.lastIndexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); }\n\n    ### Response:", "ground_truth": "Replaces the very last occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": "/**\r\n     * Replaces the last occurrence of a substring in a string with a new substring.\r\n     * \r\n     * @param s the original string\r\n     * @param sub the substring to be replaced\r\n     * @param with the new substring\r\n     * @return the modified string\r\n     */\r\n    public static String replaceLast(final String s, final String sub, final String with) {\r\n        int i = s.lastIndexOf(sub);\r\n        if (i == -1) {\r\n            return s;\r\n        }\r\n        return s.substring(0, i) + with + s.substring(i + sub.length());\r\n    }"}, {"ID": 1070, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String replaceLast(final String s, final char sub, final char with) { int index = s.lastIndexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); }\n\n    ### Response:", "ground_truth": "Replaces the very last occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": "/**\r\n     * Replaces the last occurrence of a character in a string with another character.\r\n     * \r\n     * @param s the input string\r\n     * @param sub the character to be replaced\r\n     * @param with the character to replace with\r\n     * @return the modified string\r\n     */\r\n    public static String replaceLast(final String s, final char sub, final char with) {\r\n        int index = s.lastIndexOf(sub);\r\n        if (index == -1) {\r\n            return s;\r\n        }\r\n        char[] str = s.toCharArray();\r\n        str[index] = with;\r\n        return new String(str);\r\n    }"}, {"ID": 1071, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String remove(final String s, final String sub) { int c = 0; int sublen = sub.length(); if (sublen == 0) { return s; } int i = s.indexOf(sub, c); if (i == -1) { return s; } StringBuilder sb = new StringBuilder(s.length()); do { sb.append(s, c, i); c = i + sublen; } while ((i = s.indexOf(sub, c)) != -1); if (c < s.length()) { sb.append(s, c, s.length()); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Removes all substring occurrences from the string.\n\n@param s      source string\n@param sub    substring to remove", "predict": "/**\r\n     * Removes all occurrences of the specified substring from the specified string.\r\n     *\r\n     * @param s the string to be modified\r\n     * @param sub the substring to be removed\r\n     * @return the resulting string\r\n     */\r\n    public static String remove(final String s, final String sub) {\r\n        int c = 0;\r\n        int sublen = sub.length();\r\n        if (sublen == 0) {\r\n            return s;\r\n        }\r\n        int i = s.indexOf(sub, c);\r\n        if (i == -1) {\r\n            return s;\r\n        }\r\n        StringBuilder sb = new StringBuilder(s.length());\r\n        do {\r\n            sb.append(s, c, i);\r\n            c = i + sublen;\r\n        } while ((i = s.indexOf(sub, c)) != -1);\r\n        if (c < s.length()) {\r\n            sb.append(s, c, s.length());\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1072, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String remove(final String string, final char ch) { int stringLen = string.length(); char[] result = new char[stringLen]; int offset = 0; for (int i = 0; i < stringLen; i++) { char c = string.charAt(i); if (c == ch) { continue; } result[offset] = c; offset++; } if (offset == stringLen) { return string; // no changes } return new String(result, 0, offset); }\n\n    ### Response:", "ground_truth": "Removes a single character from string.\n\n@param string    source string\n@param ch  character to remove", "predict": "/**\r\n     * Removes all occurrences of the specified character from the given string.\r\n     * \r\n     * @param string the input string\r\n     * @param ch the character to remove\r\n     * @return the modified string with all occurrences of the specified character removed\r\n     */\r\n    public static String remove(final String string, final char ch) {\r\n        int stringLen = string.length();\r\n        char[] result = new char[stringLen];\r\n        int offset = 0;\r\n        for (int i = 0; i < stringLen; i++) {\r\n            char c = string.charAt(i);\r\n            if (c == ch) {\r\n                continue;\r\n            }\r\n            result[offset] = c;\r\n            offset++;\r\n        }\r\n        if (offset == stringLen) {\r\n            return string; // no changes\r\n        }\r\n        return new String(result, 0, offset);\r\n    }"}, {"ID": 1073, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAllEmpty(final String... strings) { for (String string : strings) { if (!isEmpty(string)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Determines if string array contains empty strings.\n@see #isEmpty(CharSequence)", "predict": "/**\r\n     * Checks if all the strings in the array are empty or null.\r\n     * \r\n     * @param strings the array of strings to check\r\n     * @return true if all strings are empty or null, false otherwise\r\n     */\r\n    public static boolean isAllEmpty(final String... strings) {\r\n        for (String string : strings) {\r\n            if (!isEmpty(string)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1074, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isAllBlank(final String... strings) { for (String string : strings) { if (!isBlank(string)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Determines if string array contains just blank strings.", "predict": "/**\r\n     * Checks if all the strings in the array are blank or null.\r\n     *\r\n     * @param strings the array of strings to check\r\n     * @return true if all the strings are blank or null, false otherwise\r\n     */\r\n    public static boolean isAllBlank(final String... strings) {\r\n        for (String string : strings) {\r\n            if (!isBlank(string)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1075, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toStringArray(final Object value) { if (value == null) { return new String[0]; } Class<?> type = value.getClass(); if (!type.isArray()) { return new String[] {value.toString()}; } Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { if (componentType == int.class) { return ArraysUtil.toStringArray((int[]) value); } else if (componentType == long.class) { return ArraysUtil.toStringArray((long[]) value); } else if (componentType == double.class) { return ArraysUtil.toStringArray((double[]) value); } else if (componentType == float.class) { return ArraysUtil.toStringArray((float[]) value); } else if (componentType == boolean.class) { return ArraysUtil.toStringArray((boolean[]) value); } else if (componentType == short.class) { return ArraysUtil.toStringArray((short[]) value); } else if (componentType == byte.class) { return ArraysUtil.toStringArray((byte[]) value); } else { throw new IllegalArgumentException(); } } else { return ArraysUtil.toStringArray((Object[]) value); } }\n\n    ### Response:", "ground_truth": "Converts an array object to array of strings, where every element\nof input array is converted to a string. If input is not an array,\nthe result will still be an array with one element.", "predict": "/**\r\n     * Converts the given value to a String array.\r\n     * \r\n     * @param value the value to convert\r\n     * @return the String array representation of the value\r\n     * @throws IllegalArgumentException if the value is not an array or an array of a primitive type that is not supported\r\n     */\r\n    public static String[] toStringArray(final Object value) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1076, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String changeFirstCharacterCase(final boolean capitalize, final String string) { int strLen = string.length(); if (strLen == 0) { return string; } char ch = string.charAt(0); char modifiedCh; if (capitalize) { modifiedCh = Character.toUpperCase(ch); } else { modifiedCh = Character.toLowerCase(ch); } if (modifiedCh == ch) { // no change, return unchanged string return string; } char[] chars = string.toCharArray(); chars[0] = modifiedCh; return new String(chars); }\n\n    ### Response:", "ground_truth": "Internal method for changing the first character case.", "predict": "/**\r\n     * Changes the first character of a string to uppercase or lowercase based on the value of the capitalize parameter.\r\n     * \r\n     * @param capitalize\r\n     *            true to capitalize the first character, false to lowercase the first character\r\n     * @param string\r\n     *            the string to modify\r\n     * @return the modified string\r\n     */\r\n    private static String changeFirstCharacterCase(final boolean capitalize, final String string) {\r\n        int strLen = string.length();\r\n        if (strLen == 0) {\r\n            return string;\r\n        }\r\n        char ch = string.charAt(0);\r\n        char modifiedCh;\r\n        if (capitalize) {\r\n            modifiedCh = Character.toUpperCase(ch);\r\n        } else {\r\n            modifiedCh = Character.toLowerCase(ch);\r\n        }\r\n        if (modifiedCh == ch) {\r\n            // no change, return unchanged string\r\n            return string;\r\n        }\r\n        char[] chars = string.toCharArray();\r\n        chars[0] = modifiedCh;\r\n        return new String(chars);\r\n    }"}, {"ID": 1077, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUtil.isWhitespace(c)) { wasWhitespace = true; } else { if (wasWhitespace) { chars[i] = Character.toUpperCase(c); } else { chars[i] = Character.toLowerCase(c); } wasWhitespace = false; } } return new String(chars); }\n\n    ### Response:", "ground_truth": "Makes a title-cased string from given input.", "predict": "/**\r\n     * Converts the first character of each word to uppercase and the rest to lowercase.\r\n     *\r\n     * @param string the string to be converted\r\n     * @return the converted string\r\n     */\r\n    public static String title(final String string) {\r\n        char[] chars = string.toCharArray();\r\n        boolean wasWhitespace = true;\r\n        for (int i = 0; i < chars.length; i++) {\r\n            char c = chars[i];\r\n            if (CharUtil.isWhitespace(c)) {\r\n                wasWhitespace = true;\r\n            } else {\r\n                if (wasWhitespace) {\r\n                    chars[i] = Character.toUpperCase(c);\r\n                } else {\r\n                    chars[i] = Character.toLowerCase(c);\r\n                }\r\n                wasWhitespace = false;\r\n            }\r\n        }\r\n        return new String(chars);\r\n    }"}, {"ID": 1078, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String compressChars(final String s, final char c) { int len = s.length(); StringBuilder sb = new StringBuilder(len); boolean wasChar = false; for (int i = 0; i < len; i++) { char c1 = s.charAt(i); if (c1 == c) { if (wasChar) { continue; } wasChar = true; } else { wasChar = false; } sb.append(c1); } if (sb.length() == len) { return s; } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Compress multiple occurrences of given char into one appearance.", "predict": "/**\r\n     * Compresses all occurrences of a given character in a string into a single occurrence.\r\n     * \r\n     * @param s the input string\r\n     * @param c the character to compress\r\n     * @return the compressed string\r\n     */\r\n    public static String compressChars(final String s, final char c) {\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder(len);\r\n        boolean wasChar = false;\r\n        for (int i = 0; i < len; i++) {\r\n            char c1 = s.charAt(i);\r\n            if (c1 == c) {\r\n                if (wasChar) {\r\n                    continue;\r\n                }\r\n                wasChar = true;\r\n            } else {\r\n                wasChar = false;\r\n            }\r\n            sb.append(c1);\r\n        }\r\n        if (sb.length() == len) {\r\n            return s;\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1079, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) { String sub = subS.toLowerCase(); int sublen = sub.length(); if (startIndex + sublen > src.length()) { return false; } int j = 0; int i = startIndex; while (j < sublen) { char source = Character.toLowerCase(src.charAt(i)); if (sub.charAt(j) != source) { return false; } j++; i++; } return true; }\n\n    ### Response:", "ground_truth": "Tests if this string starts with the specified prefix with ignored case\nand with the specified prefix beginning a specified index.\n\n@param src        source string to test\n@param subS       starting substring\n@param startIndex index from where to test\n\n@return true if the character sequence represented by the argument is\na prefix of the character sequence represented by this string;\nfalse otherwise.", "predict": "/**\r\n     * Checks if the specified string starts with the specified substring (ignoring case).\r\n     *\r\n     * @param src the source string to search in\r\n     * @param subS the substring to search for\r\n     * @param startIndex the starting index in the source string to search from\r\n     * @return true if the source string starts with the specified substring (ignoring case), false otherwise\r\n     */\r\n    public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) {\r\n        String sub = subS.toLowerCase();\r\n        int sublen = sub.length();\r\n        if (startIndex + sublen > src.length()) {\r\n            return false;\r\n        }\r\n        int j = 0;\r\n        int i = startIndex;\r\n        while (j < sublen) {\r\n            char source = Character.toLowerCase(src.charAt(i));\r\n            if (sub.charAt(j) != source) {\r\n                return false;\r\n            }\r\n            j++;\r\n            i++;\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1080, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean endsWithChar(final String s, final char c) { if (s.length() == 0) { return false; } return s.charAt(s.length() - 1) == c; }\n\n    ### Response:", "ground_truth": "Returns if string ends with provided character.", "predict": "/**\r\n     * Checks if a string ends with a specific character.\r\n     * \r\n     * @param s the string to check\r\n     * @param c the character to check for\r\n     * @return true if the string ends with the character, false otherwise\r\n     */\r\n    public static boolean endsWithChar(final String s, final char c) {\r\n        if (s.length() == 0) {\r\n            return false;\r\n        }\r\n        return s.charAt(s.length() - 1) == c;\r\n    }"}, {"ID": 1081, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int countIgnoreCase(final String source, final String sub) { int count = 0; int j = 0; int sublen = sub.length(); if (sublen == 0) { return 0; } while (true) { int i = indexOfIgnoreCase(source, sub, j); if (i == -1) { break; } count++; j = i + sublen; } return count; }\n\n    ### Response:", "ground_truth": "Count substring occurrences in a source string, ignoring case.\n\n@param source\tsource string\n@param sub\t\tsubstring to count\n@return\t\t\tnumber of substring occurrences", "predict": "/**\r\n     * Counts the number of occurrences of the substring in the source string, ignoring case.\r\n     * \r\n     * @param source the source string to search in\r\n     * @param sub the substring to search for\r\n     * @return the number of occurrences of the substring in the source string, ignoring case\r\n     */\r\n    public static int countIgnoreCase(final String source, final String sub) {\r\n        int count = 0;\r\n        int j = 0;\r\n        int sublen = sub.length();\r\n        if (sublen == 0) {\r\n            return 0;\r\n        }\r\n        while (true) {\r\n            int i = indexOfIgnoreCase(source, sub, j);\r\n            if (i == -1) {\r\n                break;\r\n            }\r\n            count++;\r\n            j = i + sublen;\r\n        }\r\n        return count;\r\n    }"}, {"ID": 1082, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsIgnoreCase(final String[] as, final String[] as1) { if (as.length != as1.length) { return false; } for (int i = 0; i < as.length; i++) { if (!as[i].equalsIgnoreCase(as1[i])) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Compares two string arrays.\n\n@param as     first string array\n@param as1    second string array\n\n@return true if all array elements matches", "predict": "/**\r\n     * Compares two arrays of strings, ignoring case differences.\r\n     *\r\n     * @param as  the first array of strings to compare\r\n     * @param as1 the second array of strings to compare\r\n     * @return true if the arrays are equal, ignoring case differences; false otherwise\r\n     */\r\n    public static boolean equalsIgnoreCase(final String[] as, final String[] as1) {\r\n        if (as.length != as1.length) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < as.length; i++) {\r\n            if (!as[i].equalsIgnoreCase(as1[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1083, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOfWhitespace(final String string, final int startindex, final int endindex) { for (int i = startindex; i < endindex; i++) { if (CharUtil.isWhitespace(string.charAt(i))) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Returns first index of a whitespace character, starting from specified index offset.", "predict": "/**\r\n     * Returns the index of the first whitespace character in the specified substring of the given string.\r\n     * \r\n     * @param string the string to search in\r\n     * @param startindex the starting index of the substring (inclusive)\r\n     * @param endindex the ending index of the substring (exclusive)\r\n     * @return the index of the first whitespace character in the substring, or -1 if no whitespace character is found\r\n     */\r\n    public static int indexOfWhitespace(final String string, final int startindex, final int endindex) {\r\n        for (int i = startindex; i < endindex; i++) {\r\n            if (CharUtil.isWhitespace(string.charAt(i))) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1084, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripLeadingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(0) == c) { return string.substring(1); } } return string; }\n\n    ### Response:", "ground_truth": "Strips leading char if string starts with one.", "predict": "/**\r\n     * Removes the specified leading character from the given string.\r\n     * \r\n     * @param string the string to remove the leading character from\r\n     * @param c the leading character to remove\r\n     * @return the string with the leading character removed, or the original string if it did not start with the specified character\r\n     */\r\n    public static String stripLeadingChar(final String string, final char c) {\r\n        if (string.length() > 0) {\r\n            if (string.charAt(0) == c) {\r\n                return string.substring(1);\r\n            }\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1085, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripTrailingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(string.length() - 1) == c) { return string.substring(0, string.length() - 1); } } return string; }\n\n    ### Response:", "ground_truth": "Strips trailing char if string ends with one.", "predict": "/**\r\n     * Removes the last occurrence of the specified character from the given string.\r\n     * \r\n     * @param string the string to modify\r\n     * @param c the character to remove\r\n     * @return the modified string\r\n     */\r\n    public static String stripTrailingChar(final String string, final char c) {\r\n        if (string.length() > 0) {\r\n            if (string.charAt(string.length() - 1) == c) {\r\n                return string.substring(0, string.length() - 1);\r\n            }\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1086, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripChar(final String string, final char c) { if (string.length() == 0) { return string; } if (string.length() == 1) { if (string.charAt(0) == c) { return StringPool.EMPTY; } return string; } int left = 0; int right = string.length(); if (string.charAt(left) == c) { left++; } if (string.charAt(right - 1) == c) { right--; } return string.substring(left, right); }\n\n    ### Response:", "ground_truth": "Strips leading and trailing char from given string.", "predict": "/**\r\n     * Removes all occurrences of the specified character from the beginning and end of the specified string.\r\n     * \r\n     * @param string the string to be stripped\r\n     * @param c the character to be removed\r\n     * @return the stripped string\r\n     */\r\n    public static String stripChar(final String string, final char c) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 1087, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripToChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(ndx); }\n\n    ### Response:", "ground_truth": "Strips everything up to the first appearance of given char.\nCharacter IS included in the returned string.", "predict": "/**\r\n     * Returns a new string that is a substring of this string. The substring starts with the first occurrence of the specified character and ends with the end of this string. If the character is not found in the string, then the resulting substring is empty.\r\n     * \r\n     * @param string the string to be processed\r\n     * @param c the character to search for\r\n     * @return the resulting substring\r\n     */\r\n    public static String stripToChar(final String string, final char c) {\r\n        int ndx = string.indexOf(c);\r\n        if (ndx == -1) {\r\n            return string;\r\n        }\r\n        return string.substring(ndx);\r\n    }"}, {"ID": 1088, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String stripFromChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(0, ndx); }\n\n    ### Response:", "ground_truth": "Strips everything from the first appearance of given char.\nCharacter IS NOT included in the returned string.", "predict": "/**\r\n     * Removes all occurrences of the specified character from the beginning of the given string.\r\n     * \r\n     * @param string the input string\r\n     * @param c the character to remove\r\n     * @return the resulting string\r\n     */\r\n    public static String stripFromChar(final String string, final char c) {\r\n        int ndx = string.indexOf(c);\r\n        if (ndx == -1) {\r\n            return string;\r\n        }\r\n        return string.substring(0, ndx);\r\n    }"}, {"ID": 1089, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cropAll(final String... strings) { for (int i = 0; i < strings.length; i++) { String string = strings[i]; if (string != null) { string = crop(strings[i]); } strings[i] = string; } }\n\n    ### Response:", "ground_truth": "Crops all elements of string array.", "predict": "/**\r\n     * Crops all the strings in the given array and replaces them in the same array.\r\n     * \r\n     * @param strings The array of strings to be cropped.\r\n     */\r\n    public static void cropAll(final String... strings) {\r\n        for (int i = 0; i < strings.length; i++) {\r\n            String string = strings[i];\r\n            if (string != null) {\r\n                string = crop(strings[i]);\r\n            }\r\n            strings[i] = string;\r\n        }\r\n    }"}, {"ID": 1090, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String trimLeft(final String src) { int len = src.length(); int st = 0; while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) { st++; } return st > 0 ? src.substring(st) : src; }\n\n    ### Response:", "ground_truth": "Trim whitespaces from the left.", "predict": "/**\r\n     * Trims the leading whitespace characters from the given string.\r\n     * \r\n     * @param src the string to be trimmed\r\n     * @return the trimmed string\r\n     */\r\n    public static String trimLeft(final String src) {\r\n        int len = src.length();\r\n        int st = 0;\r\n        while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) {\r\n            st++;\r\n        }\r\n        return st > 0 ? src.substring(st) : src;\r\n    }"}, {"ID": 1091, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String trimRight(final String src) { int len = src.length(); int count = len; while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) { len--; } return (len < count) ? src.substring(0, len) : src; }\n\n    ### Response:", "ground_truth": "Trim whitespaces from the right.", "predict": "/**\r\n     * Trims whitespace characters from the right end of a string.\r\n     * \r\n     * @param src the string to be trimmed\r\n     * @return the trimmed string\r\n     */\r\n    public static String trimRight(final String src) {\r\n        int len = src.length();\r\n        int count = len;\r\n        while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) {\r\n            len--;\r\n        }\r\n        return (len < count) ? src.substring(0, len) : src;\r\n    }"}, {"ID": 1092, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) { int ndx = offset; int[] res = new int[4]; ndx = string.indexOf(leftBoundary, ndx); if (ndx == -1) { return null; } res[0] = ndx; ndx += leftBoundary.length(); res[1] = ndx; ndx = string.indexOf(rightBoundary, ndx); if (ndx == -1) { return null; } res[2] = ndx; res[3] = ndx + rightBoundary.length(); return res; }\n\n    ### Response:", "ground_truth": "Returns indexes of the first region without escaping character.\n@see #indexOfRegion(String, String, String, char, int)", "predict": "/**\r\n     * This method takes in a string, left boundary, right boundary and an offset. It returns an array of integers containing the starting and ending indices of the left and right boundaries in the string.\r\n     * \r\n     * @param string The input string\r\n     * @param leftBoundary The left boundary string\r\n     * @param rightBoundary The right boundary string\r\n     * @param offset The starting index of the search\r\n     * @return An array of integers containing the starting and ending indices of the left and right boundaries in the string.\r\n     */\r\n    public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) {\r\n        int ndx = offset;\r\n        int[] res = new int[4];\r\n        ndx = string.indexOf(leftBoundary, ndx);\r\n        if (ndx == -1) {\r\n            return null;\r\n        }\r\n        res[0] = ndx;\r\n        ndx += leftBoundary.length();\r\n        res[1] = ndx;\r\n        ndx = string.indexOf"}, {"ID": 1093, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String join(final Collection collection, final char separator) { if (collection == null) { return null; } if (collection.size() == 0) { return StringPool.EMPTY; } final StringBuilder sb = new StringBuilder(collection.size() * 16); final Iterator it = collection.iterator(); for (int i = 0; i < collection.size(); i++) { if (i > 0) { sb.append(separator); } sb.append(it.next()); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Joins an collection of objects into one string with separator.", "predict": "/**\r\n     * Joins the elements of the given collection into a single String,\r\n     * separated by the specified separator character.\r\n     *\r\n     * @param collection the collection to join\r\n     * @param separator the separator character to use\r\n     * @return the joined String\r\n     */\r\n    public static String join(final Collection collection, final char separator) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1094, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String join(final Object[] array, final String separator) { if (array == null) { return null; } if (array.length == 0) { return StringPool.EMPTY; } if (array.length == 1) { return String.valueOf(array[0]); } final StringBuilder sb = new StringBuilder(array.length * 16); for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(separator); } sb.append(array[i]); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Joins an array of objects into one string with separator.", "predict": "/**\r\n     * Joins the elements of the specified array into a single String containing the specified separator.\r\n     *\r\n     * @param array     the array of objects to be joined.\r\n     * @param separator the separator character to be used.\r\n     * @return the joined String.\r\n     */\r\n    public static String join(final Object[] array, final String separator) {\r\n        if (array == null) {\r\n            return null;\r\n        }\r\n        if (array.length == 0) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        if (array.length == 1) {\r\n            return String.valueOf(array[0]);\r\n        }\r\n        final StringBuilder sb = new StringBuilder(array.length * 16);\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (i > 0) {\r\n                sb.append(separator);\r\n            }\r\n            sb.append(array[i]);\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1095, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) { if (srcCharsetName.equals(newCharsetName)) { return source; } return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName); }\n\n    ### Response:", "ground_truth": "Converts string charset. If charset names are the same, the same string is returned.", "predict": "/**\r\n     * Converts the character encoding of a string from one charset to another.\r\n     * \r\n     * @param source the string to be converted\r\n     * @param srcCharsetName the character encoding of the source string\r\n     * @param newCharsetName the desired character encoding of the result\r\n     * @return the converted string\r\n     */\r\n    public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) {\r\n        if (srcCharsetName.equals(newCharsetName)) {\r\n            return source;\r\n        }\r\n        return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName);\r\n    }"}, {"ID": 1096, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) { if ((index < 0) || (index >= string.length())) { return false; } return string.charAt(index) == charToCompare; }\n\n    ### Response:", "ground_truth": "Safely compares provided char with char on given location.", "predict": "/**\r\n     * This method checks if the character at the specified index in the given string is equal to the given character.\r\n     * \r\n     * @param string the string to check\r\n     * @param index the index of the character to check\r\n     * @param charToCompare the character to compare with\r\n     * @return true if the character at the specified index is equal to the given character, false otherwise\r\n     */\r\n    public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) {\r\n        if ((index < 0) || (index >= string.length())) {\r\n            return false;\r\n        }\r\n        return string.charAt(index) == charToCompare;\r\n    }"}, {"ID": 1097, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String surround(String string, final String prefix, final String suffix) { if (!string.startsWith(prefix)) { string = prefix + string; } if (!string.endsWith(suffix)) { string += suffix; } return string; }\n\n    ### Response:", "ground_truth": "Surrounds the string with provided prefix and suffix if such missing from string.", "predict": "/**\r\n     * Surrounds the given string with the given prefix and suffix.\r\n     * \r\n     * @param string the string to surround\r\n     * @param prefix the prefix to add to the beginning of the string\r\n     * @param suffix the suffix to add to the end of the string\r\n     * @return the surrounded string\r\n     */\r\n    public static String surround(String string, final String prefix, final String suffix) {\r\n        if (!string.startsWith(prefix)) {\r\n            string = prefix + string;\r\n        }\r\n        if (!string.endsWith(suffix)) {\r\n            string += suffix;\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1098, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String prefix(String string, final String prefix) { if (!string.startsWith(prefix)) { string = prefix + string; } return string; }\n\n    ### Response:", "ground_truth": "Inserts prefix if doesn't exist.", "predict": "/**\r\n     * Adds a prefix to a string if it doesn't already have it.\r\n     * \r\n     * @param string the string to add the prefix to\r\n     * @param prefix the prefix to add to the string\r\n     * @return the string with the prefix added, or the original string if it already had the prefix\r\n     */\r\n    public static String prefix(String string, final String prefix) {\r\n        if (!string.startsWith(prefix)) {\r\n            string = prefix + string;\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1099, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String suffix(String string, final String suffix) { if (!string.endsWith(suffix)) { string += suffix; } return string; }\n\n    ### Response:", "ground_truth": "Appends suffix if doesn't exist.", "predict": "/**\r\n     * Adds the given suffix to the end of the given string if it doesn't already end with the suffix.\r\n     * \r\n     * @param string the string to add the suffix to\r\n     * @param suffix the suffix to add to the string\r\n     * @return the original string with the suffix added if it didn't already end with it\r\n     */\r\n    public static String suffix(String string, final String suffix) {\r\n        if (!string.endsWith(suffix)) {\r\n            string += suffix;\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1100, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutToIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(0, i); } return string; }\n\n    ### Response:", "ground_truth": "Cuts the string from beginning to the first index of provided substring.", "predict": "/**\r\n     * This method takes a string and a substring as input and returns the substring of the string that is before the first occurrence of the substring.\r\n     * \r\n     * @param string The input string.\r\n     * @param substring The substring to search for.\r\n     * @return The substring of the string that is before the first occurrence of the substring.\r\n     */\r\n    public static String cutToIndexOf(String string, final String substring) {\r\n        int i = string.indexOf(substring);\r\n        if (i != -1) {\r\n            string = string.substring(0, i);\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1101, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutFromIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(i); } return string; }\n\n    ### Response:", "ground_truth": "Cuts the string from the first index of provided substring to the end.", "predict": "/**\r\n     * This method takes a string and a substring as input and returns the string with the substring removed from the beginning.\r\n     * \r\n     * @param string The input string.\r\n     * @param substring The substring to be removed from the beginning of the string.\r\n     * @return The modified string.\r\n     */\r\n    public static String cutFromIndexOf(String string, final String substring) {\r\n        int i = string.indexOf(substring);\r\n        if (i != -1) {\r\n            string = string.substring(i);\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1102, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutPrefix(String string, final String prefix) { if (string.startsWith(prefix)) { string = string.substring(prefix.length()); } return string; }\n\n    ### Response:", "ground_truth": "Cuts prefix if exists.", "predict": "/**\r\n     * Removes the specified prefix from the beginning of the given string, if it exists.\r\n     * \r\n     * @param string the string to remove the prefix from\r\n     * @param prefix the prefix to remove\r\n     * @return the string with the prefix removed, or the original string if the prefix was not found\r\n     */\r\n    public static String cutPrefix(String string, final String prefix) {\r\n        if (string.startsWith(prefix)) {\r\n            string = string.substring(prefix.length());\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1103, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutSuffix(String string, final String suffix) { if (string.endsWith(suffix)) { string = string.substring(0, string.length() - suffix.length()); } return string; }\n\n    ### Response:", "ground_truth": "Cuts sufix if exists.", "predict": "/**\r\n     * Removes the given suffix from the given string if it exists.\r\n     * \r\n     * @param string the string to remove the suffix from\r\n     * @param suffix the suffix to remove\r\n     * @return the string with the suffix removed, or the original string if the suffix was not found\r\n     */\r\n    public static String cutSuffix(String string, final String suffix) {\r\n        if (string.endsWith(suffix)) {\r\n            string = string.substring(0, string.length() - suffix.length());\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1104, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String cutSurrounding(final String string, final String prefix, final String suffix) { int start = 0; int end = string.length(); if (string.startsWith(prefix)) { start = prefix.length(); } if (string.endsWith(suffix)) { end -= suffix.length(); } if (end <= start) { return StringPool.EMPTY; } return string.substring(start, end); }\n\n    ### Response:", "ground_truth": "Removes surrounding prefix and suffixes.", "predict": "/**\r\n     * Cuts the surrounding prefix and suffix from the given string.\r\n     *\r\n     * @param string the string to cut from\r\n     * @param prefix the prefix to cut\r\n     * @param suffix the suffix to cut\r\n     * @return the cut string\r\n     */\r\n    public static String cutSurrounding(final String string, final String prefix, final String suffix) {\r\n        int start = 0;\r\n        int end = string.length();\r\n        if (string.startsWith(prefix)) {\r\n            start = prefix.length();\r\n        }\r\n        if (string.endsWith(suffix)) {\r\n            end -= suffix.length();\r\n        }\r\n        if (end <= start) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        return string.substring(start, end);\r\n    }"}, {"ID": 1105, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String insert(final String src, final String insert, int offset) { if (offset < 0) { offset = 0; } if (offset > src.length()) { offset = src.length(); } StringBuilder sb = new StringBuilder(src); sb.insert(offset, insert); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Inserts a string on provided offset.", "predict": "/**\r\n     * Inserts the specified string into the specified source string at the specified offset.\r\n     * \r\n     * @param src the source string\r\n     * @param insert the string to insert\r\n     * @param offset the offset at which to insert the string\r\n     * @return the resulting string\r\n     */\r\n    public static String insert(final String src, final String insert, int offset) {\r\n        if (offset < 0) {\r\n            offset = 0;\r\n        }\r\n        if (offset > src.length()) {\r\n            offset = src.length();\r\n        }\r\n        StringBuilder sb = new StringBuilder(src);\r\n        sb.insert(offset, insert);\r\n        return sb.toString();\r\n    }"}, {"ID": 1106, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String repeat(final String source, int count) { StringBand result = new StringBand(count); while (count > 0) { result.append(source); count--; } return result.toString(); }\n\n    ### Response:", "ground_truth": "Creates a new string that contains the provided string a number of times.", "predict": "/**\r\n     * Repeats the given string count times and returns the concatenated result.\r\n     * \r\n     * @param source the string to repeat\r\n     * @param count the number of times to repeat the string\r\n     * @return the concatenated result of repeating the string count times\r\n     */\r\n    public static String repeat(final String source, int count) {\r\n        StringBand result = new StringBand(count);\r\n        while (count > 0) {\r\n            result.append(source);\r\n            count--;\r\n        }\r\n        return result.toString();\r\n    }"}, {"ID": 1107, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String reverse(final String s) { StringBuilder result = new StringBuilder(s.length()); for (int i = s.length() -1; i >= 0; i--) { result.append(s.charAt(i)); } return result.toString(); }\n\n    ### Response:", "ground_truth": "Reverse a string.", "predict": "/**\r\n     * This method takes a string as input and returns the reverse of the string.\r\n     * \r\n     * @param s the input string\r\n     * @return the reverse of the input string\r\n     */\r\n    public static String reverse(final String s) {\r\n        StringBuilder result = new StringBuilder(s.length());\r\n        for (int i = s.length() - 1; i >= 0; i--) {\r\n            result.append(s.charAt(i));\r\n        }\r\n        return result.toString();\r\n    }"}, {"ID": 1108, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String maxCommonPrefix(final String one, final String two) { final int minLength = Math.min(one.length(), two.length()); final StringBuilder sb = new StringBuilder(minLength); for (int pos = 0; pos < minLength; pos++) { final char currentChar = one.charAt(pos); if (currentChar != two.charAt(pos)) { break; } sb.append(currentChar); } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns max common prefix of two strings.", "predict": "/**\r\n     * Finds the maximum common prefix between two strings.\r\n     * \r\n     * @param one the first string\r\n     * @param two the second string\r\n     * @return the maximum common prefix between the two strings\r\n     */\r\n    public static String maxCommonPrefix(final String one, final String two) {\r\n        final int minLength = Math.min(one.length(), two.length());\r\n        final StringBuilder sb = new StringBuilder(minLength);\r\n        for (int pos = 0; pos < minLength; pos++) {\r\n            final char currentChar = one.charAt(pos);\r\n            if (currentChar != two.charAt(pos)) {\r\n                break;\r\n            }\r\n            sb.append(currentChar);\r\n        }\r\n        return sb.toString();\r\n    }"}, {"ID": 1109, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String findCommonPrefix(final String... strings) { StringBuilder prefix = new StringBuilder(); int index = 0; char c = 0; loop: while (true) { for (int i = 0; i < strings.length; i++) { String s = strings[i]; if (index == s.length()) { break loop; } if (i == 0) { c = s.charAt(index); } else { if (s.charAt(index) != c) { break loop; } } } index++; prefix.append(c); } return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString(); }\n\n    ### Response:", "ground_truth": "Finds common prefix for several strings. Returns an empty string if\narguments do not have a common prefix.", "predict": "/**\r\n     * Finds the common prefix among the given strings.\r\n     * \r\n     * @param strings the strings to find the common prefix among\r\n     * @return the common prefix, or an empty string if there is no common prefix\r\n     */\r\n    public static String findCommonPrefix(final String... strings) {\r\n        StringBuilder prefix = new StringBuilder();\r\n        int index = 0;\r\n        char c = 0;\r\n        loop: while (true) {\r\n            for (int i = 0; i < strings.length; i++) {\r\n                String s = strings[i];\r\n                if (index == s.length()) {\r\n                    break loop;\r\n                }\r\n                if (i == 0) {\r\n                    c = s.charAt(index);\r\n                } else {\r\n                    if (s.charAt(index) != c) {\r\n                        break loop;\r\n                    }\r\n                }\r\n            }\r\n            index++;\r\n            prefix.append(c);\r\n        }\r\n        return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString();\r\n    }"}, {"ID": 1110, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String shorten(String s, int length, final String suffix) { length -= suffix.length(); if (s.length() > length) { for (int j = length; j >= 0; j--) { if (CharUtil.isWhitespace(s.charAt(j))) { length = j; break; } } String temp = s.substring(0, length); s = temp.concat(suffix); } return s; }\n\n    ### Response:", "ground_truth": "Shorten string to given length.", "predict": "/**\r\n     * Shortens the given string to the given length, adding the given suffix if necessary.\r\n     * \r\n     * @param s the string to shorten\r\n     * @param length the maximum length of the resulting string\r\n     * @param suffix the suffix to add if the string needs to be shortened\r\n     * @return the shortened string\r\n     */\r\n    public static String shorten(String s, int length, final String suffix) {\r\n        length -= suffix.length();\r\n        if (s.length() > length) {\r\n            for (int j = length; j >= 0; j--) {\r\n                if (CharUtil.isWhitespace(s.charAt(j))) {\r\n                    length = j;\r\n                    break;\r\n                }\r\n            }\r\n            String temp = s.substring(0, length);\r\n            s = temp.concat(suffix);\r\n        }\r\n        return s;\r\n    }"}, {"ID": 1111, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toUpperCase(final String s, Locale locale) { if (s == null) { return null; } StringBuilder sb = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127) { // found non-ascii char, fallback to the slow unicode detection if (locale == null) { locale = Locale.getDefault(); } return s.toUpperCase(locale); } if ((c >= 'a') && (c <= 'z')) { if (sb == null) { sb = new StringBuilder(s); } sb.setCharAt(i, (char)(c - 32)); } } if (sb == null) { return s; } return sb.toString(); }\n\n    ### Response:", "ground_truth": "Converts all of the characters in the string to upper case, based on the\nlocale.\n\n@param  s the string to convert\n@param  locale apply this locale's rules\n@return the string, converted to upper case, or null if the\nstring is null", "predict": "/**\r\n     * Converts the given string to uppercase using the given locale. If the string contains non-ASCII characters, the method falls back to the slow unicode detection.\r\n     * \r\n     * @param s the string to convert to uppercase\r\n     * @param locale the locale to use for the conversion\r\n     * @return the uppercase string\r\n     */\r\n    public static String toUpperCase(final String s, Locale locale) {\r\n        if (s == null) {\r\n            return null;\r\n        }\r\n        StringBuilder sb = null;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (c > 127) { // found non-ascii char, fallback to the slow unicode detection\r\n                if (locale == null) {\r\n                    locale = Locale.getDefault();\r\n                }\r\n                return s.toUpperCase(locale);\r\n            }\r\n            if ((c >= 'a') && (c <= 'z')) {\r\n                if (sb == null) {\r\n                    sb = new StringBuilder(s);\r\n                }\r\n               "}, {"ID": 1112, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String removeQuotes(final String string) { if ( (startsWithChar(string, '\\'') && endsWithChar(string, '\\'')) || (startsWithChar(string, '\"') && endsWithChar(string, '\"')) || (startsWithChar(string, '`') && endsWithChar(string, '`')) ) { return substring(string, 1, -1); } return string; }\n\n    ### Response:", "ground_truth": "Removes starting and ending single or double quotes.", "predict": "/**\r\n     * Removes quotes from a string.\r\n     * \r\n     * @param string the string to remove quotes from\r\n     * @return the string with quotes removed\r\n     */\r\n    public static String removeQuotes(final String string) {\r\n        if ( (startsWithChar(string, '\\'') && endsWithChar(string, '\\'')) || (startsWithChar(string, '\"') && endsWithChar(string, '\"')) || (startsWithChar(string, '`') && endsWithChar(string, '`')) ) {\r\n            return substring(string, 1, -1);\r\n        }\r\n        return string;\r\n    }"}, {"ID": 1113, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toHexString(final byte[] bytes) { char[] chars = new char[bytes.length * 2]; int i = 0; for (byte b : bytes) { chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4); chars[i++] = CharUtil.int2hex(b & 0x0F); } return new String(chars); }\n\n    ### Response:", "ground_truth": "Converts bytes to hex string.", "predict": "/**\r\n     * Converts a byte array to its hexadecimal string representation.\r\n     *\r\n     * @param bytes the byte array to convert\r\n     * @return the hexadecimal string representation of the byte array\r\n     */\r\n    public static String toHexString(final byte[] bytes) {\r\n        char[] chars = new char[bytes.length * 2];\r\n        int i = 0;\r\n        for (byte b : bytes) {\r\n            chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4);\r\n            chars[i++] = CharUtil.int2hex(b & 0x0F);\r\n        }\r\n        return new String(chars);\r\n    }"}, {"ID": 1114, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] getBytes(final String string) { try { return string.getBytes(JoddCore.encoding); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } }\n\n    ### Response:", "ground_truth": "Returns String bytes using Jodds default encoding.", "predict": "/**\r\n     * Converts a string to a byte array using the default encoding.\r\n     *\r\n     * @param string the string to convert\r\n     * @return the resulting byte array\r\n     * @throws RuntimeException if the encoding is not supported\r\n     */\r\n    public static byte[] getBytes(final String string) {\r\n        try {\r\n            return string.getBytes(JoddCore.encoding);\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }"}, {"ID": 1115, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char detectQuoteChar(final String str) { if (str.length() < 2) { return 0; } final char c = str.charAt(0); if (c != str.charAt(str.length() - 1)) { return 0; } if (c == '\\'' || c == '\"' || c == '`') { return c; } return 0; }\n\n    ### Response:", "ground_truth": "Detects quote character or return 0.", "predict": "/**\r\n     * This method takes a string as input and returns the character that is used to enclose the string.\r\n     * \r\n     * @param str - the input string\r\n     * @return the character that is used to enclose the string, or 0 if the string is not enclosed in quotes\r\n     */\r\n    public static char detectQuoteChar(final String str) {\r\n        if (str.length() < 2) {\r\n            return 0;\r\n        }\r\n        final char c = str.charAt(0);\r\n        if (c != str.charAt(str.length() - 1)) {\r\n            return 0;\r\n        }\r\n        if (c == '\\'' || c == '\"' || c == '`') {\r\n            return c;\r\n        }\r\n        return 0;\r\n    }"}, {"ID": 1116, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit(final String name, final Object value) { if (av != null) { av.visit(name, value); } }\n\n    ### Response:", "ground_truth": "Visits a primitive value of the annotation.\n\n@param name the value name.\n@param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\nCharacter}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\n{@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\nvalue can also be an array of byte, boolean, short, char, int, long, float or double values\n(this is equivalent to using {@link #visitArray} and visiting each array element in turn,\nbut is more convenient).", "predict": "/**\r\n     * Visits a pair of name-value.\r\n     * \r\n     * @param name the name of the pair\r\n     * @param value the value of the pair\r\n     */\r\n    public void visit(final String name, final Object value) {\r\n        if (av != null) {\r\n            av.visit(name, value);\r\n        }\r\n    }"}, {"ID": 1117, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitEnum(final String name, final String descriptor, final String value) { if (av != null) { av.visitEnum(name, descriptor, value); } }\n\n    ### Response:", "ground_truth": "Visits an enumeration value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the enumeration class.\n@param value the actual enumeration value.", "predict": "/**\r\n     * Visits an enum declaration.\r\n     *\r\n     * @param name the name of the enum class\r\n     * @param descriptor the descriptor of the enum class (may be null)\r\n     * @param value the value of the enum constant (may be null)\r\n     */\r\n    public void visitEnum(final String name, final String descriptor, final String value) {\r\n        if (av != null) {\r\n            av.visitEnum(name, descriptor, value);\r\n        }\r\n    }"}, {"ID": 1118, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String name, final String descriptor) { if (av != null) { return av.visitAnnotation(name, descriptor); } return null; }\n\n    ### Response:", "ground_truth": "Visits a nested annotation value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the nested annotation class.\n@return a visitor to visit the actual nested annotation value, or {@literal null} if this\nvisitor is not interested in visiting this nested annotation. The nested annotation\nvalue must be fully visited before calling other methods on this annotation visitor.", "predict": "/**\r\n     * Visits an annotation of the method. The annotation values are passed in an array of objects. The default implementation of this method calls the visitAnnotation method of the visitor object.\r\n     *\r\n     * @param name the name of the annotation\r\n     * @param descriptor the class descriptor of the annotation class\r\n     * @param visible true if the annotation is visible at runtime\r\n     * @return a visitor to visit the annotation values, or null if this visitor is not interested in visiting this annotation.\r\n     */\r\n    public AnnotationVisitor visitAnnotation(final String name, final String descriptor, final boolean visible) {\r\n        if (av != null) {\r\n            return av.visitAnnotation(name, descriptor, visible);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1119, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> registerType(final Class<E> type) { DbEntityDescriptor<E> ded = createDbEntityDescriptor(type); DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded); if (log.isDebugEnabled()) { log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName()); } if (existing != null) { if (ded.getType() == type) { return ded; } throw new DbOomException(\"Type already registered: \" + existing.getType()); } existing = entityNamesMap.put(ded.getEntityName(), ded); if (existing != null) { throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType()); } return ded; }\n\n    ### Response:", "ground_truth": "Registers just type and entity names. Enough for most usages.", "predict": "/**\n     * Registers a type with the entity manager.\n     * \n     * @param type the type to register\n     * @return the descriptor for the registered type\n     * @throws DbOomException if the type is already registered or if the name of the type is already mapped to an entity\n     */\n    public <E> DbEntityDescriptor<E> registerType(final Class<E> type) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1120, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) { if (force) { removeEntity(type); } return registerEntity(type); }\n\n    ### Response:", "ground_truth": "Registers entity. Existing entity will be removed if exist, so no exception will be thrown.", "predict": "/**\r\n     * Registers a new entity descriptor for the given type. If the entity already exists, it will be removed first if the force flag is set to true.\r\n     * \r\n     * @param type the type of the entity to register\r\n     * @param force if true, the existing entity descriptor for the given type will be removed before registering a new one\r\n     * @return the newly registered entity descriptor\r\n     */\r\n    public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) {\r\n        if (force) {\r\n            removeEntity(type);\r\n        }\r\n        return registerEntity(type);\r\n    }"}, {"ID": 1121, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) { DbEntityDescriptor<E> ded = descriptorsMap.remove(type); if (ded == null) { ded = createDbEntityDescriptor(type); } entityNamesMap.remove(ded.getEntityName()); tableNamesMap.remove(ded.getTableName()); return ded; }\n\n    ### Response:", "ground_truth": "Removes entity and returns removed descriptor.", "predict": "/**\r\n     * Removes the entity descriptor for the given type from the cache.\r\n     * \r\n     * @param type the type of the entity to remove\r\n     * @return the removed entity descriptor, or a new one if it didn't exist\r\n     */\r\n    public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) {\r\n        DbEntityDescriptor<E> ded = descriptorsMap.remove(type);\r\n        if (ded == null) {\r\n            ded = createDbEntityDescriptor(type);\r\n        }\r\n        entityNamesMap.remove(ded.getEntityName());\r\n        tableNamesMap.remove(ded.getTableName());\r\n        return ded;\r\n    }"}, {"ID": 1122, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E createEntityInstance(final Class<E> type) { try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new DbOomException(ex); } }\n\n    ### Response:", "ground_truth": "Creates new entity instances.", "predict": "/**\r\n     * Creates a new instance of the specified type using the default constructor.\r\n     *\r\n     * @param type the type of the entity to be created\r\n     * @return a new instance of the specified type\r\n     * @throws DbOomException if an error occurs while creating the instance\r\n     */\r\n    public <E> E createEntityInstance(final Class<E> type) {\r\n        try {\r\n            return ClassUtil.newInstance(type);\r\n        } catch (Exception ex) {\r\n            throw new DbOomException(ex);\r\n        }\r\n    }"}, {"ID": 1123, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public WrapperProxettaFactory setTargetInterface(final Class targetInterface) { if (!targetInterface.isInterface()) { throw new ProxettaException(\"Not an interface: \" + targetInterface.getName()); } this.targetInterface = targetInterface; return this; }\n\n    ### Response:", "ground_truth": "Defines the interface of the resulting class.", "predict": "/**\r\n     * Sets the target interface for the factory.\r\n     * \r\n     * @param targetInterface the target interface to set\r\n     * @return the factory instance\r\n     * @throws ProxettaException if the target interface is not an interface\r\n     */\r\n    public WrapperProxettaFactory setTargetInterface(final Class targetInterface) {\r\n        if (!targetInterface.isInterface()) {\r\n            throw new ProxettaException(\"Not an interface: \" + targetInterface.getName());\r\n        }\r\n        this.targetInterface = targetInterface;\r\n        return this;\r\n    }"}, {"ID": 1124, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectTargetIntoWrapper(final Object target, final Object wrapper) { ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName); }\n\n    ### Response:", "ground_truth": "Injects target into wrapper.", "predict": "/**\r\n     * Injects the target object into the wrapper object using the specified field name.\r\n     * \r\n     * @param target the target object to be injected\r\n     * @param wrapper the wrapper object into which the target object is to be injected\r\n     * @param targetFieldName the name of the field in the wrapper object where the target object is to be injected\r\n     */\r\n    public void injectTargetIntoWrapper(final Object target, final Object wrapper) {\r\n        ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName);\r\n    }"}, {"ID": 1125, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) { PropertyDescriptor[] properties = annotatedProperties.get(type); if (properties != null) { return properties; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); List<PropertyDescriptor> list = new ArrayList<>(); for (PropertyDescriptor propertyDescriptor : allProperties) { Annotation ann = null; if (propertyDescriptor.getFieldDescriptor() != null) { ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) { ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) { ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann != null) { list.add(propertyDescriptor); } } if (list.isEmpty()) { properties = EMPTY; } else { properties = list.toArray(new PropertyDescriptor[0]); } annotatedProperties.put(type, properties); return properties; }\n\n    ### Response:", "ground_truth": "Lookups for annotated properties. Caches all annotated properties on the first\naction class scan.", "predict": "/**\r\n     * This method is used to lookup all the properties of a given class that are annotated with a specific annotation.\r\n     * \r\n     * @param type The class for which the properties are to be looked up.\r\n     * @return An array of PropertyDescriptor objects representing all the properties of the given class that are annotated with the specified annotation.\r\n     */\r\n    protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) {\r\n        // Implementation details are omitted for brevity.\r\n    }"}, {"ID": 1126, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) { cp.init(); final Connection connection = cp.getConnection(); final DbServer dbServer = detectDatabase(connection); cp.closeConnection(connection); dbServer.accept(dbOomConfig); return dbServer; }\n\n    ### Response:", "ground_truth": "Detects database and configure DbOom engine.", "predict": "/**\r\n     * This method detects the database type and configures the DbOomConfig object based on the detected database type.\r\n     * \r\n     * @param cp - ConnectionProvider object that provides connections to the database\r\n     * @param dbOomConfig - DbOomConfig object that holds the configuration for the DbOom library\r\n     * @return - DbServer object that represents the detected database type and configured DbOomConfig object\r\n     */\r\n    public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) {\r\n        cp.init();\r\n        final Connection connection = cp.getConnection();\r\n        final DbServer dbServer = detectDatabase(connection);\r\n        cp.closeConnection(connection);\r\n        dbServer.accept(dbOomConfig);\r\n        return dbServer;\r\n    }"}, {"ID": 1127, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void close() throws IOException { if (closed) { return; } if (gzipstream != null) { flushToGZip(); gzipstream.close(); gzipstream = null; } else { if (bufferCount > 0) { output.write(buffer, 0, bufferCount); bufferCount = 0; } } output.close(); closed = true; }\n\n    ### Response:", "ground_truth": "Closes this output stream, causing any buffered data to be flushed and any\nfurther output data to throw an IOException.", "predict": "/**\r\n     * Closes this output stream and releases any system resources associated with it.\r\n     *\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    @Override\r\n    public void close() throws IOException {\r\n        if (closed) {\r\n            return;\r\n        }\r\n        if (gzipstream != null) {\r\n            flushToGZip();\r\n            gzipstream.close();\r\n            gzipstream = null;\r\n        } else {\r\n            if (bufferCount > 0) {\r\n                output.write(buffer, 0, bufferCount);\r\n                bufferCount = 0;\r\n            }\r\n        }\r\n        output.close();\r\n        closed = true;\r\n    }"}, {"ID": 1128, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void write(final int b) throws IOException { if (closed) { throw new IOException(\"Cannot write to a closed output stream\"); } if (bufferCount >= buffer.length) { flushToGZip(); } buffer[bufferCount++] = (byte) b; }\n\n    ### Response:", "ground_truth": "Writes the specified byte to our output stream.", "predict": "/**\r\n     * Writes the specified byte to this output stream. The general contract for write is that one byte is written to the output stream. The byte to be written is the eight low-order bits of the argument b. The 24 high-order bits of b are ignored.\r\n     *\r\n     * @param b the byte to be written.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    @Override\r\n    public void write(final int b) throws IOException {\r\n        if (closed) {\r\n            throw new IOException(\"Cannot write to a closed output stream\");\r\n        }\r\n        if (bufferCount >= buffer.length) {\r\n            flushToGZip();\r\n        }\r\n        buffer[bufferCount++] = (byte) b;\r\n    }"}, {"ID": 1129, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; if (isRequestedSessionIdFromURL(httpRequest)) { HttpSession session = httpRequest.getSession(false); if (session != null) { session.invalidate(); // clear session if session id in URL } } // wrap response to remove URL encoding HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) { @Override public String encodeRedirectUrl(final String url) { return url; } @Override public String encodeRedirectURL(final String url) { return url; } @Override public String encodeUrl(final String url) { return url; } @Override public String encodeURL(final String url) { return url; } }; chain.doFilter(request, wrappedResponse); }\n\n    ### Response:", "ground_truth": "Filters requests to remove URL-based session identifiers.", "predict": "/**\r\n     * This method overrides the doFilter method of the Filter interface.\r\n     * \r\n     * @param request\r\n     *            the request object that contains the request the client made of the servlet\r\n     * @param response\r\n     *            the response object that contains the response the servlet returns to the client\r\n     * @param chain\r\n     *            the filter chain that contains the chain of filters\r\n     * @throws IOException\r\n     *             if an input or output error occurs while the servlet is handling the HTTP request\r\n     * @throws ServletException\r\n     *             if the request for the servlet is invalid\r\n     */\r\n    @Override\r\n    public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1130, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getEncodedName() { if (name == null) { return null; } try { return MimeUtility.encodeText(name); } catch (final UnsupportedEncodingException ueex) { throw new MailException(ueex); } }\n\n    ### Response:", "ground_truth": "Returns encoded attachment name.\n\n@return encoded attachment name. Value may be {@code null}.", "predict": "/**\r\n     * This method returns the encoded name of the user.\r\n     * \r\n     * @return the encoded name of the user.\r\n     * @throws MailException if there is an error in encoding the name.\r\n     */\r\n    public String getEncodedName() {\r\n        if (name == null) {\r\n            return null;\r\n        }\r\n        try {\r\n            return MimeUtility.encodeText(name);\r\n        } catch (UnsupportedEncodingException ueex) {\r\n            throw new MailException(ueex);\r\n        }\r\n    }"}, {"ID": 1131, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] toByteArray() { final FastByteArrayOutputStream out; if (size != -1) { out = new FastByteArrayOutputStream(size); } else { out = new FastByteArrayOutputStream(); } writeToStream(out); return out.toByteArray(); }\n\n    ### Response:", "ground_truth": "Returns byte content of the attachment.\n\n@return byte array with content of the attachment.", "predict": "/**\r\n     * Converts the contents of this byte buffer to a byte array.\r\n     *\r\n     * @return a byte array containing the remaining bytes in this buffer\r\n     */\r\n    public byte[] toByteArray() {\r\n        final FastByteArrayOutputStream out;\r\n        if (size != -1) {\r\n            out = new FastByteArrayOutputStream(size);\r\n        } else {\r\n            out = new FastByteArrayOutputStream();\r\n        }\r\n        writeToStream(out);\r\n        return out.toByteArray();\r\n    }"}, {"ID": 1132, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeToFile(final File destination) { InputStream input = null; final OutputStream output; try { input = getDataSource().getInputStream(); output = new FileOutputStream(destination); StreamUtil.copy(input, output); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } }\n\n    ### Response:", "ground_truth": "Saves attachment to a file.\n\n@param destination The destination file to be written.", "predict": "/**\r\n     * Writes the data source input stream to the specified file.\r\n     * \r\n     * @param destination the file to write to\r\n     * @throws MailException if an I/O error occurs\r\n     */\r\n    public void writeToFile(final File destination) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1133, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeToStream(final OutputStream out) { InputStream input = null; try { input = getDataSource().getInputStream(); StreamUtil.copy(input, out); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } }\n\n    ### Response:", "ground_truth": "Saves attachment to the output stream.\n\n@param out OutputStream where attachment should be copied to.", "predict": "/**\r\n     * Writes the data source content to the output stream.\r\n     * \r\n     * @param out\r\n     *            the output stream to write to\r\n     * @throws MailException\r\n     *             if an error occurs while writing to the output stream\r\n     */\r\n    public void writeToStream(final OutputStream out) {\r\n        InputStream input = null;\r\n        try {\r\n            input = getDataSource().getInputStream();\r\n            StreamUtil.copy(input, out);\r\n        } catch (final IOException ioex) {\r\n            throw new MailException(ioex);\r\n        } finally {\r\n            StreamUtil.close(input);\r\n        }\r\n    }"}, {"ID": 1134, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String appendArgument(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx) + type + desc.substring(ndx); }\n\n    ### Response:", "ground_truth": "Appends argument to the existing description.", "predict": "/**\r\n     * This method takes in a method descriptor and a type and returns a modified method descriptor with the type added as an argument.\r\n     * \r\n     * @param desc the method descriptor to modify\r\n     * @param type the type to add as an argument\r\n     * @return the modified method descriptor with the type added as an argument\r\n     */\r\n    protected static String appendArgument(final String desc, final String type) {\r\n        int ndx = desc.indexOf(')');\r\n        return desc.substring(0, ndx) + type + desc.substring(ndx);\r\n    }"}, {"ID": 1135, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); }\n\n    ### Response:", "ground_truth": "Prepends argument to the existing description.", "predict": "/**\r\n     * This method takes a method descriptor and a type as input and returns a modified method descriptor with the type prepended to the argument list.\r\n     * \r\n     * @param desc the method descriptor to modify\r\n     * @param type the type to prepend to the argument list\r\n     * @return the modified method descriptor with the type prepended to the argument list\r\n     */\r\n    protected static String prependArgument(final String desc, final String type) {\r\n        int ndx = desc.indexOf('(');\r\n        ndx++;\r\n        return desc.substring(0, ndx) + type + desc.substring(ndx);\r\n    }"}, {"ID": 1136, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; }\n\n    ### Response:", "ground_truth": "Changes return type.", "predict": "/**\r\n     * This method takes in a method descriptor and a new return type and returns a modified method descriptor with the new return type.\r\n     * \r\n     * @param desc - the method descriptor to modify\r\n     * @param type - the new return type for the modified method descriptor\r\n     * @return the modified method descriptor with the new return type\r\n     */\r\n    protected static String changeReturnType(final String desc, final String type) {\r\n        int ndx = desc.indexOf(')');\r\n        return desc.substring(0, ndx + 1) + type;\r\n    }"}, {"ID": 1137, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void text(final CharSequence text) { if (!strip) { super.text(text); return; } int textLength = text.length(); char[] dest = new char[textLength]; int ndx = 0; boolean regularChar = true; for (int i = 0; i < textLength; i++) { char c = text.charAt(i); if (CharUtil.isWhitespace(c)) { if (regularChar) { regularChar = false; c = ' '; } else { continue; } } else { regularChar = true; } dest[ndx] = c; ndx++; } if (regularChar || (ndx != 1)) { super.text(CharBuffer.wrap(dest, 0, ndx)); strippedCharsCount += textLength - ndx; } else { strippedCharsCount += textLength; } }\n\n    ### Response:", "ground_truth": "Cleans unnecessary whitespaces.", "predict": "/**\n     * This method overrides the text method of the parent class and strips out any leading or trailing whitespace characters.\n     * \n     * @param text the text to be displayed\n     */\n    @Override public void text(final CharSequence text) {\n        // code here\n    }"}, {"ID": 1138, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) { converters.put(type, typeConverter); }\n\n    ### Response:", "ground_truth": "Registers a converter for specified type.\nUser must register converter for all super-classes as well.\n\n@param type\t\tclass that converter is for\n@param typeConverter\tconverter for provided class", "predict": "/**\r\n     * Registers a type converter for a given type.\r\n     * \r\n     * @param type the type to register the converter for\r\n     * @param typeConverter the converter to register\r\n     */\r\n    public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) {\r\n        converters.put(type, typeConverter);\r\n    }"}, {"ID": 1139, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); }\n\n    ### Response:", "ground_truth": "Retrieves converter for provided type. Only registered types are matched,\ntherefore subclasses must be also registered.\n\n@return founded converter or null", "predict": "/**\r\n     * Looks up a converter for the given type.\r\n     * \r\n     * @param <T> the type of the converter to lookup\r\n     * @param type the type for which to lookup a converter\r\n     * @return the converter for the given type, or null if none is found\r\n     */\r\n    public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); }"}, {"ID": 1140, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Node> select(final String query) { Collection<List<CssSelector>> selectorsCollection = CSSelly.parse(query); return select(selectorsCollection); }\n\n    ### Response:", "ground_truth": "Selects nodes using CSS3 selector query.", "predict": "/**\r\n     * Selects nodes based on the given CSS selectors.\r\n     * \r\n     * @param query The CSS selectors to use for selecting nodes.\r\n     * @return A list of nodes that match the given CSS selectors.\r\n     */\r\n    public List<Node> select(final String query) {\r\n        Collection<List<CssSelector>> selectorsCollection = CSSelly.parse(query);\r\n        return select(selectorsCollection);\r\n    }"}, {"ID": 1141, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { List<Node> results = new ArrayList<>(); for (List<CssSelector> selectors : selectorsCollection) { processSelectors(results, selectors); } return results; }\n\n    ### Response:", "ground_truth": "Selected nodes using pre-parsed CSS selectors. Take in consideration\ncollection type for results grouping order.", "predict": "/**\r\n     * Selects nodes from a collection of CSS selectors.\r\n     * \r\n     * @param selectorsCollection A collection of CSS selectors.\r\n     * @return A list of selected nodes.\r\n     */\r\n    public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) {\r\n        List<Node> results = new ArrayList<>();\r\n        for (List<CssSelector> selectors : selectorsCollection) {\r\n            processSelectors(results, selectors);\r\n        }\r\n        return results;\r\n    }"}, {"ID": 1142, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) { List<Node> selectedNodes = select(rootNode, selectors); for (Node selectedNode : selectedNodes) { if (!results.contains(selectedNode)) { results.add(selectedNode); } } }\n\n    ### Response:", "ground_truth": "Process selectors and keep adding results.", "predict": "/**\r\n     * This method takes in a list of nodes and a list of CSS selectors and returns a list of nodes that match the CSS selectors.\r\n     * \r\n     * @param results The list of nodes to be updated with the selected nodes.\r\n     * @param selectors The list of CSS selectors to be used to select nodes.\r\n     */\r\n    protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) {\r\n        List<Node> selectedNodes = select(rootNode, selectors);\r\n        for (Node selectedNode : selectedNodes) {\r\n            if (!results.contains(selectedNode)) {\r\n                results.add(selectedNode);\r\n            }\r\n        }\r\n    }"}, {"ID": 1143, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node selectFirst(final String query) { List<Node> selectedNodes = select(query); if (selectedNodes.isEmpty()) { return null; } return selectedNodes.get(0); }\n\n    ### Response:", "ground_truth": "Selects nodes using CSS3 selector query and returns the very first one.", "predict": "/**\r\n     * Selects the first node that matches the given query.\r\n     * \r\n     * @param query the query to match against\r\n     * @return the first node that matches the query, or null if no nodes match\r\n     */\r\n    public Node selectFirst(final String query) {\r\n        List<Node> selectedNodes = select(query);\r\n        if (selectedNodes.isEmpty()) {\r\n            return null;\r\n        }\r\n        return selectedNodes.get(0);\r\n    }"}, {"ID": 1144, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void walkDescendantsIteratively(final LinkedList<Node> nodes, final CssSelector cssSelector, final List<Node> result) { while (!nodes.isEmpty()) { Node node = nodes.removeFirst(); selectAndAdd(node, cssSelector, result); // append children in walking order to be processed right after this node int childCount = node.getChildNodesCount(); for (int i = childCount - 1; i >= 0; i--) { nodes.addFirst(node.getChild(i)); } } }\n\n    ### Response:", "ground_truth": "Walks over the child notes, maintaining the tree order and not using recursion.", "predict": "/**\r\n     * This method walks the descendants of the given nodes using a LinkedList to keep track of the nodes to be processed.\r\n     * It selects the nodes that match the given CSS selector and adds them to the result list.\r\n     * The children of each node are added to the LinkedList in reverse order to be processed right after the current node.\r\n     * \r\n     * @param nodes the LinkedList of nodes to be processed\r\n     * @param cssSelector the CSS selector to be used for selecting nodes\r\n     * @param result the list to which selected nodes should be added\r\n     */\r\n    protected void walkDescendantsIteratively(final LinkedList<Node> nodes, final CssSelector cssSelector, final List<Node> result) { }"}, {"ID": 1145, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void walk(final Node rootNode, final CssSelector cssSelector, final List<Node> result) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector.getPrevCssSelector(); Combinator combinator = previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT; switch (combinator) { case DESCENDANT: LinkedList<Node> nodes = new LinkedList<>(); int childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { nodes.add(rootNode.getChild(i)); // recursive // selectAndAdd(node, cssSelector, result); // walk(node, cssSelector, result); } walkDescendantsIteratively(nodes, cssSelector, result); break; case CHILD: childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node node = rootNode.getChild(i); selectAndAdd(node, cssSelector, result); } break; case ADJACENT_SIBLING: Node node = rootNode.getNextSiblingElement(); if (node != null) { selectAndAdd(node, cssSelector, result); } break; case GENERAL_SIBLING: node = rootNode; while (true) { node = node.getNextSiblingElement(); if (node == null) { break; } selectAndAdd(node, cssSelector, result); } break; } }\n\n    ### Response:", "ground_truth": "Finds nodes in the tree that matches single selector.", "predict": "/**\r\n     * This method walks the DOM tree starting from the given root node and selects the nodes that match the given CSS selector.\r\n     * \r\n     * @param rootNode the root node of the DOM tree\r\n     * @param cssSelector the CSS selector to match the nodes\r\n     * @param result the list to store the selected nodes\r\n     */\r\n    protected void walk(final Node rootNode, final CssSelector cssSelector, final List<Node> result) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector.getPrevCssSelector(); Combinator combinator = previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT; switch (combinator) { case DESCENDANT: LinkedList<Node> nodes = new LinkedList<>(); int childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { nodes.add(rootNode.getChild(i)); // recursive // selectAndAdd(node, cssSelector, result); // walk(node"}, {"ID": 1146, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void selectAndAdd(final Node node, final CssSelector cssSelector, final List<Node> result) { // ignore all nodes that are not elements if (node.getNodeType() != Node.NodeType.ELEMENT) { return; } boolean matched = cssSelector.accept(node); if (matched) { // check for duplicates if (result.contains(node)) { return; } // no duplicate found, add it to the results result.add(node); } }\n\n    ### Response:", "ground_truth": "Selects single node for single selector and appends it to the results.", "predict": "/**\r\n     * Selects and adds the given node to the result list if it matches the given CSS selector.\r\n     *\r\n     * @param node the node to select and add\r\n     * @param cssSelector the CSS selector to match against\r\n     * @param result the list to add the node to if it matches the selector\r\n     */\r\n    protected void selectAndAdd(final Node node, final CssSelector cssSelector, final List<Node> result) { // ignore all nodes that are not elements if (node.getNodeType() != Node.NodeType.ELEMENT) { return; } boolean matched = cssSelector.accept(node); if (matched) { // check for duplicates if (result.contains(node)) { return; } // no duplicate found, add it to the results result.add(node); } }"}, {"ID": 1147, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean filter(final List<Node> currentResults, final Node node, final CssSelector cssSelector, final int index) { return cssSelector.accept(currentResults, node, index); }\n\n    ### Response:", "ground_truth": "Filter nodes.", "predict": "/**\r\n     * This method filters the current results based on the given CSS selector.\r\n     *\r\n     * @param currentResults The current results to be filtered.\r\n     * @param node The node to be checked against the CSS selector.\r\n     * @param cssSelector The CSS selector to be used for filtering.\r\n     * @param index The index of the node in the current results.\r\n     * @return True if the node should be included in the filtered results, false otherwise.\r\n     */\r\n    protected boolean filter(final List<Node> currentResults, final Node node, final CssSelector cssSelector, final int index) { return cssSelector.accept(currentResults, node, index); }"}, {"ID": 1148, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static char [] zzUnpackCMap(final String packed) { char [] map = new char[0x110000]; int i = 0; /* index in packed string */ int j = 0; /* index in unpacked array */ while (i < 128) { int count = packed.charAt(i++); char value = packed.charAt(i++); do map[j++] = value; while (--count > 0); } return map; }\n\n    ### Response:", "ground_truth": "Unpacks the compressed character translation table.\n\n@param packed   the packed character translation table\n@return         the unpacked character translation table", "predict": "/**\r\n * Unpacks the compressed character translation table.\r\n *\r\n * @param packed the packed character translation table\r\n * @return the unpacked character translation table\r\n */\r\nprivate static char[] zzUnpackCMap(final String packed) {\r\n    char[] map = new char[0x110000];\r\n    int i = 0;  /* index in packed string  */\r\n    int j = 0;  /* index in unpacked array */\r\n    while (i < 128) {\r\n        int count = packed.charAt(i++);\r\n        char value = packed.charAt(i++);\r\n        do map[j++] = value; while (--count > 0);\r\n    }\r\n    return map;\r\n}"}, {"ID": 1149, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean zzRefill() { if (zzBuffer == null) { zzBuffer = zzChars; zzEndRead += zzChars.length; return false; } return true; }\n\n    ### Response:", "ground_truth": "Refills the input buffer.\n\n@return      false, iff there was new input.", "predict": "/**\n     * Refills the input buffer.\n     *\n     * @return {@code true} if no error was encountered, {@code false} otherwise.\n     */\n    private boolean zzRefill() {\n        if (zzBuffer == null) {\n            zzBuffer = zzChars;\n            zzEndRead += zzChars.length;\n            return false;\n        }\n        return true;\n    }"}, {"ID": 1150, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T> PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) { if (sortColumnName != null) { sql = buildOrderSql(sql, sortColumnName, ascending); } int from = (page - 1) * pageSize; String pageSql = buildPageSql(sql, from, pageSize); DbSqlBuilder dbsql = sql(pageSql); DbOomQuery query = query(dbsql); query.setMaxRows(pageSize); query.setFetchSize(pageSize); query.setMap(params); List<T> list = query.list(pageSize, target); query.close(); String countSql = buildCountSql(sql); dbsql = sql(countSql); query = query(dbsql); query.setMap(params); long count = query.executeCount(); query.close(); return new PageData<>(page, (int) count, pageSize, list); }\n\n    ### Response:", "ground_truth": "Pages given page.\n\n@param sql sql query that lists all items\n@param params map of SQL parameters\n@param page current page to show\n@param pageSize number of items to show\n@param sortColumnName name of sorting column, null for no sorting\n@param ascending true for ascending order\n@param target db entities for mapping (sa usual in DbOom)", "predict": "/**\r\n     * This method is used to retrieve data from the database based on the given SQL, parameters, page number, page size, sort column name, sort order, and target class.\r\n     * \r\n     * @param sql - SQL query to retrieve data from the database\r\n     * @param params - Map of parameters to be used in the SQL query\r\n     * @param page - Page number to retrieve data from\r\n     * @param pageSize - Number of records to retrieve per page\r\n     * @param sortColumnName - Name of the column to sort the data by\r\n     * @param ascending - Boolean value indicating whether to sort the data in ascending or descending order\r\n     * @param target - Array of classes to map the data to\r\n     * @return PageData object containing the retrieved data, page number, total number of records, page size, and sort column name\r\n     */\r\n    protected <T> PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) {\r\n       "}, {"ID": 1151, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeSelect(String sql) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"select\"); if (ndx != -1) { sql = sql.substring(ndx + 6); // select.length() } return sql; }\n\n    ### Response:", "ground_truth": "Removes the first 'select' from the sql query.", "predict": "/**\r\n     * Removes the \"SELECT\" keyword from the beginning of the SQL statement.\r\n     * \r\n     * @param sql the SQL statement to remove the \"SELECT\" keyword from\r\n     * @return the SQL statement with the \"SELECT\" keyword removed\r\n     */\r\n    protected String removeSelect(String sql) {\r\n        int ndx = StringUtil.indexOfIgnoreCase(sql, \"select\");\r\n        if (ndx != -1) {\r\n            sql = sql.substring(ndx + 6); // select.length()\r\n        }\r\n        return sql;\r\n    }"}, {"ID": 1152, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeToFrom(String sql) { int from = 0; int fromCount = 1; int selectCount = 0; int lastNdx = 0; while (true) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from); if (ndx == -1) { break; } // count selects in left part String left = sql.substring(lastNdx, ndx); selectCount += StringUtil.countIgnoreCase(left, \"select\"); if (fromCount >= selectCount) { sql = sql.substring(ndx); break; } // find next 'from' lastNdx = ndx; from = ndx + 4; fromCount++; } return sql; }\n\n    ### Response:", "ground_truth": "Removes the first part of the sql up to the relevant 'from'.\nTries to detect sub-queries in the 'select' part.", "predict": "/**\r\n     * Removes the \"to\" keyword from the given SQL statement.\r\n     * \r\n     * @param sql the SQL statement to remove the \"to\" keyword from\r\n     * @return the SQL statement with the \"to\" keyword removed\r\n     */\r\n    protected String removeToFrom(String sql) {\r\n        int from = 0;\r\n        int fromCount = 1;\r\n        int selectCount = 0;\r\n        int lastNdx = 0;\r\n        while (true) {\r\n            int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from);\r\n            if (ndx == -1) {\r\n                break;\r\n            }\r\n            // count selects in left part\r\n            String left = sql.substring(lastNdx, ndx);\r\n            selectCount += StringUtil.countIgnoreCase(left, \"select\");\r\n            if (fromCount >= selectCount) {\r\n                sql = sql.substring(ndx);\r\n                break;\r\n            }\r\n            // find next 'from'\r\n            lastNdx = ndx;\r\n            from = ndx + 4"}, {"ID": 1153, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String removeLastOrderBy(String sql) { int ndx = StringUtil.lastIndexOfIgnoreCase(sql, \"order by\"); if (ndx != -1) { int ndx2 = sql.lastIndexOf(sql, ')'); if (ndx > ndx2) { sql = sql.substring(0, ndx); } } return sql; }\n\n    ### Response:", "ground_truth": "Removes everything from last \"order by\".", "predict": "/**\r\n     * Removes the last occurrence of \"ORDER BY\" clause from the given SQL statement.\r\n     * \r\n     * @param sql the SQL statement to remove the last \"ORDER BY\" clause from\r\n     * @return the SQL statement with the last \"ORDER BY\" clause removed\r\n     */\r\n    protected String removeLastOrderBy(String sql) {\r\n        int ndx = StringUtil.lastIndexOfIgnoreCase(sql, \"order by\");\r\n        if (ndx != -1) {\r\n            int ndx2 = sql.lastIndexOf(sql, ')');\r\n            if (ndx > ndx2) {\r\n                sql = sql.substring(0, ndx);\r\n            }\r\n        }\r\n        return sql;\r\n    }"}, {"ID": 1154, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(final String html) { int ndx = html.indexOf('&'); if (ndx == -1) { return html; } StringBuilder result = new StringBuilder(html.length()); int lastIndex = 0; int len = html.length(); mainloop: while (ndx != -1) { result.append(html.substring(lastIndex, ndx)); lastIndex = ndx; while (html.charAt(lastIndex) != ';') { lastIndex++; if (lastIndex == len) { lastIndex = ndx; break mainloop; } } if (html.charAt(ndx + 1) == '#') { // decimal/hex char c = html.charAt(ndx + 2); int radix; if ((c == 'x') || (c == 'X')) { radix = 16; ndx += 3; } else { radix = 10; ndx += 2; } String number = html.substring(ndx, lastIndex); int i = Integer.parseInt(number, radix); result.append((char) i); lastIndex++; } else { // token String encodeToken = html.substring(ndx + 1, lastIndex); char[] replacement = ENTITY_MAP.get(encodeToken); if (replacement == null) { result.append('&'); lastIndex = ndx + 1; } else { result.append(replacement); lastIndex++; } } ndx = html.indexOf('&', lastIndex); } result.append(html.substring(lastIndex)); return result.toString(); }\n\n    ### Response:", "ground_truth": "Decodes HTML text. Assumes that all character references are properly closed with semi-colon.", "predict": "/**\r\n * Decodes HTML entities in a string.\r\n *\r\n * @param html the HTML string to decode\r\n * @return the decoded string\r\n */\r\npublic static String decode(final String html) {\r\n    int ndx = html.indexOf('&');\r\n    if (ndx == -1) {\r\n        return html;\r\n    }\r\n    StringBuilder result = new StringBuilder(html.length());\r\n    int lastIndex = 0;\r\n    int len = html.length();\r\n    mainloop: while (ndx != -1) {\r\n        result.append(html.substring(lastIndex, ndx));\r\n        lastIndex = ndx;\r\n        while (html.charAt(lastIndex) != ';') {\r\n            lastIndex++;\r\n            if (lastIndex == len) {\r\n                lastIndex = ndx;\r\n                break mainloop;\r\n            }\r\n        }\r\n        if (html.charAt(ndx + 1) == '#') { // decimal/hex char\r\n            char c = html.charAt(ndx + 2);\r\n            int radix;\r\n           "}, {"ID": 1155, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String detectName(final char[] input, int ndx) { final Ptr ptr = new Ptr(); int firstIndex = 0; int lastIndex = ENTITY_NAMES.length - 1; int len = input.length; char[] lastName = null; final BinarySearchBase binarySearch = new BinarySearchBase() { @Override protected int compare(final int index) { char[] name = ENTITY_NAMES[index]; if (ptr.offset >= name.length) { return -1; } return name[ptr.offset] - ptr.c; } }; while (true) { ptr.c = input[ndx]; if (!CharUtil.isAlphaOrDigit(ptr.c)) { return lastName != null ? new String(lastName) : null; } firstIndex = binarySearch.findFirst(firstIndex, lastIndex); if (firstIndex < 0) { return lastName != null ? new String(lastName) : null; } char[] element = ENTITY_NAMES[firstIndex]; if (element.length == ptr.offset + 1) { // total match, remember position, continue for finding the longer name lastName = ENTITY_NAMES[firstIndex]; } lastIndex = binarySearch.findLast(firstIndex, lastIndex); if (firstIndex == lastIndex) { // only one element found, check the rest for (int i = ptr.offset; i < element.length; i++) { if (element[i] != input[ndx]) { return lastName != null ? new String(lastName) : null; } ndx++; } return new String(element); } ptr.offset++; ndx++; if (ndx == len) { return lastName != null ? new String(lastName) : null; } } }\n\n    ### Response:", "ground_truth": "Detects the longest character reference name on given position in char array.", "predict": "/**\n     * This method detects the name of an entity in the input string. It uses a binary search algorithm to find the longest matching name in the list of entity names. If no match is found, it returns the last remembered name. If no name is remembered, it returns null.\n     * \n     * @param input the input string to search for the entity name\n     * @param ndx the starting index of the entity name in the input string\n     * @return the name of the entity, or null if no match is found\n     */\n    public static String detectName(final char[] input, int ndx) {\n        final Ptr ptr = new Ptr();\n        int firstIndex = 0;\n        int lastIndex = ENTITY_NAMES.length - 1;\n        int len = input.length;\n        char[] lastName = null;\n        final BinarySearchBase binarySearch = new BinarySearchBase() {\n            @Override\n            protected int compare(final int index) {\n                char[] name = ENTITY_NAMES[index];\n               "}, {"ID": 1156, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String buildOrderSql(String sql, final String column, final boolean ascending) { sql += \" order by \" + column; if (!ascending) { sql += \" desc\"; } return sql; }\n\n    ### Response:", "ground_truth": "Appends ORDER BY keyword.", "predict": "/**\r\n     * This method overrides the buildOrderSql method of the parent class and adds the ability to sort the results in descending order.\r\n     * \r\n     * @param sql - The SQL query string to be modified.\r\n     * @param column - The column to sort the results by.\r\n     * @param ascending - A boolean flag indicating whether the results should be sorted in ascending or descending order.\r\n     * @return The modified SQL query string.\r\n     */\r\n    @Override protected String buildOrderSql(String sql, final String column, final boolean ascending) {\r\n        sql += \" order by \" + column;\r\n        if (!ascending) {\r\n            sql += \" desc\";\r\n        }\r\n        return sql;\r\n    }"}, {"ID": 1157, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String buildPageSql(String sql, final int from, final int pageSize) { sql = removeSelect(sql); return \"select LIMIT \" + from + ' ' + pageSize + sql; }\n\n    ### Response:", "ground_truth": "Builds page sql using LIMIT keyword after the SELECT.", "predict": "/**\r\n     * This method overrides the buildPageSql method of the parent class and adds the LIMIT keyword to the SQL query.\r\n     * \r\n     * @param sql The SQL query to be modified.\r\n     * @param from The starting index of the page.\r\n     * @param pageSize The number of records to be displayed on each page.\r\n     * @return The modified SQL query with the LIMIT keyword.\r\n     */\r\n    @Override protected String buildPageSql(String sql, final int from, final int pageSize) {\r\n        sql = removeSelect(sql);\r\n        return \"select LIMIT \" + from + ' ' + pageSize + sql;\r\n    }"}, {"ID": 1158, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void resolveColumnsAndProperties(final Class type) { PropertyDescriptor[] allProperties = ClassIntrospector.get().lookup(type).getAllPropertyDescriptors(); List<DbEntityColumnDescriptor> decList = new ArrayList<>(allProperties.length); int idcount = 0; HashSet<String> names = new HashSet<>(allProperties.length); for (PropertyDescriptor propertyDescriptor : allProperties) { DbEntityColumnDescriptor dec = DbMetaUtil.resolveColumnDescriptors(this, propertyDescriptor, isAnnotated, columnNamingStrategy); if (dec != null) { if (!names.add(dec.getColumnName())) { throw new DbOomException(\"Duplicate column name: \" + dec.getColumnName()); } decList.add(dec); if (dec.isId) { idcount++; } } } if (decList.isEmpty()) { throw new DbOomException(\"No column mappings in entity: \" + type); } columnDescriptors = decList.toArray(new DbEntityColumnDescriptor[0]); Arrays.sort(columnDescriptors); // extract ids from sorted list if (idcount > 0) { idColumnDescriptors = new DbEntityColumnDescriptor[idcount]; idcount = 0; for (DbEntityColumnDescriptor dec : columnDescriptors) { if (dec.isId) { idColumnDescriptors[idcount++] = dec; } } } }\n\n    ### Response:", "ground_truth": "Resolves list of all columns and properties.", "predict": "/**\n     * Resolves the column and property mappings for the given entity type.\n     * \n     * @param type the entity type\n     */\n    private void resolveColumnsAndProperties(final Class type) {\n        // TODO: Implement method\n    }"}, {"ID": 1159, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityColumnDescriptor findByColumnName(final String columnName) { if (columnName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.columnName.equalsIgnoreCase(columnName)) { return columnDescriptor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds column descriptor by column name. Case is ignored.", "predict": "/**\r\n     * Finds a column descriptor by its column name.\r\n     * \r\n     * @param columnName the name of the column to find\r\n     * @return the column descriptor, or null if not found\r\n     */\r\n    public DbEntityColumnDescriptor findByColumnName(final String columnName) {\r\n        if (columnName == null) {\r\n            return null;\r\n        }\r\n        init();\r\n        for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) {\r\n            if (columnDescriptor.columnName.equalsIgnoreCase(columnName)) {\r\n                return columnDescriptor;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1160, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbEntityColumnDescriptor findByPropertyName(final String propertyName) { if (propertyName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.propertyName.equals(propertyName)) { return columnDescriptor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds column descriptor by property name.", "predict": "/**\r\n     * Finds a column descriptor by its property name.\r\n     * \r\n     * @param propertyName the name of the property to search for\r\n     * @return the column descriptor, or null if not found\r\n     */\r\n    public DbEntityColumnDescriptor findByPropertyName(final String propertyName) {\r\n        if (propertyName == null) {\r\n            return null;\r\n        }\r\n        init();\r\n        for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) {\r\n            if (columnDescriptor.propertyName.equals(propertyName)) {\r\n                return columnDescriptor;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1161, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPropertyName(final String columnName) { DbEntityColumnDescriptor dec = findByColumnName(columnName); return dec == null ? null : dec.propertyName; }\n\n    ### Response:", "ground_truth": "Returns property name for specified column name.", "predict": "/**\r\n     * This method retrieves the property name of a column based on its column name.\r\n     * \r\n     * @param columnName The name of the column whose property name is to be retrieved.\r\n     * @return The property name of the column.\r\n     */\r\n    public String getPropertyName(final String columnName) {\r\n        DbEntityColumnDescriptor dec = findByColumnName(columnName);\r\n        return dec == null ? null : dec.propertyName;\r\n    }"}, {"ID": 1162, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getColumnName(final String propertyName) { DbEntityColumnDescriptor dec = findByPropertyName(propertyName); return dec == null ? null : dec.columnName; }\n\n    ### Response:", "ground_truth": "Returns column name for specified property name..", "predict": "/**\r\n     * Returns the column name for the given property name.\r\n     * \r\n     * @param propertyName the property name to search for\r\n     * @return the column name for the given property name, or null if not found\r\n     */\r\n    public String getColumnName(final String propertyName) {\r\n        DbEntityColumnDescriptor dec = findByPropertyName(propertyName);\r\n        return dec == null ? null : dec.columnName;\r\n    }"}, {"ID": 1163, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object getIdValue(final E object) { final String propertyName = getIdPropertyName(); return BeanUtil.declared.getProperty(object, propertyName); }\n\n    ### Response:", "ground_truth": "Returns ID value for given entity instance.", "predict": "/**\r\n     * Returns the value of the ID property of the given object.\r\n     * \r\n     * @param object the object to get the ID value from\r\n     * @return the ID value of the object\r\n     */\r\n    public Object getIdValue(final E object) {\r\n        final String propertyName = getIdPropertyName();\r\n        return BeanUtil.declared.getProperty(object, propertyName);\r\n    }"}, {"ID": 1164, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setIdValue(final E object, final Object value) { final String propertyName = getIdPropertyName(); BeanUtil.declared.setProperty(object, propertyName, value); }\n\n    ### Response:", "ground_truth": "Sets ID value for given entity.", "predict": "/**\r\n     * Sets the value of the id property of the given object to the given value.\r\n     * \r\n     * @param object the object whose id property value is to be set\r\n     * @param value the new value of the id property\r\n     */\r\n    public void setIdValue(final E object, final Object value) {\r\n        final String propertyName = getIdPropertyName();\r\n        BeanUtil.declared.setProperty(object, propertyName, value);\r\n    }"}, {"ID": 1165, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getKeyValue(final E object) { Object idValue = getIdValue(object); String idValueString = idValue == null ? StringPool.NULL : idValue.toString(); return type.getName().concat(StringPool.COLON).concat(idValueString); }\n\n    ### Response:", "ground_truth": "Returns unique key for this entity. Returned key\nis built from entity class and id value.", "predict": "/**\r\n     * This method takes an object as input and returns a string representation of the object's key-value pair.\r\n     * \r\n     * @param object The object to get the key-value pair for.\r\n     * @return A string representation of the object's key-value pair.\r\n     */\r\n    public String getKeyValue(final E object) {\r\n        Object idValue = getIdValue(object);\r\n        String idValueString = idValue == null ? StringPool.NULL : idValue.toString();\r\n        return type.getName().concat(StringPool.COLON).concat(idValueString);\r\n    }"}, {"ID": 1166, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; }\n\n    ### Response:", "ground_truth": "Appends a string.", "predict": "/**\r\n     * Appends the specified string to the end of this string band.\r\n     * \r\n     * @param s the string to be appended\r\n     * @return this string band object\r\n     */\r\n    public StringBand append(String s) {\r\n        if (s == null) {\r\n            s = StringPool.NULL;\r\n        }\r\n        if (index >= array.length) {\r\n            expandCapacity();\r\n        }\r\n        array[index++] = s;\r\n        length += s.length();\r\n        return this;\r\n    }"}, {"ID": 1167, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setIndex(final int newIndex) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { String[] newArray = new String[newIndex]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } if (newIndex > index) { for (int i = index; i < newIndex; i++) { array[i] = StringPool.EMPTY; } } else if (newIndex < index) { for (int i = newIndex; i < index; i++) { array[i] = null; } } index = newIndex; length = calculateLength(); }\n\n    ### Response:", "ground_truth": "Specifies the new index.", "predict": "/**\r\n     * Sets the index of the array.\r\n     * \r\n     * @param newIndex the new index of the array.\r\n     * @throws ArrayIndexOutOfBoundsException if the new index is negative.\r\n     * @throws IllegalArgumentException if the new index is greater than the length of the array.\r\n     */\r\n    public void setIndex(final int newIndex) {\r\n        // code goes here\r\n    }"}, {"ID": 1168, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void expandCapacity() { String[] newArray = new String[array.length << 1]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; }\n\n    ### Response:", "ground_truth": "Expands internal string array by multiplying its size by 2.", "predict": "/**\r\n     * This method is used to expand the capacity of the array when the current capacity is reached.\r\n     */"}, {"ID": 1169, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int calculateLength() { int len = 0; for (int i = 0; i < index; i++) { len += array[i].length(); } return len; }\n\n    ### Response:", "ground_truth": "Calculates string length.", "predict": "/**\r\n     * This method calculates the length of all the strings in the array.\r\n     * \r\n     * @return the length of all the strings in the array.\r\n     */\r\n    protected int calculateLength() {\r\n        int len = 0;\r\n        for (int i = 0; i < index; i++) {\r\n            len += array[i].length();\r\n        }\r\n        return len;\r\n    }"}, {"ID": 1170, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createMixingMessage(final BeanDefinition targetBeanDefinition, final BeanDefinition refBeanDefinition) { return \"Scopes mixing detected: \" + refBeanDefinition.name + \"@\" + refBeanDefinition.scope.getClass().getSimpleName() + \" -> \" + targetBeanDefinition.name + \"@\" + targetBeanDefinition.scope.getClass().getSimpleName(); }\n\n    ### Response:", "ground_truth": "Creates mixed scope message.", "predict": "/**\n     * Creates a message indicating that two beans with different scopes have been detected as being eligible for mixing.\n     *\n     * @param targetBeanDefinition the definition of the bean that is being checked for mixing\n     * @param refBeanDefinition the definition of the bean that is being referenced by the target bean\n     * @return the message indicating the detected mixing\n     */\n    protected String createMixingMessage(final BeanDefinition targetBeanDefinition, final BeanDefinition refBeanDefinition) {\n        return \"Scopes mixing detected: \" + refBeanDefinition.getName() + \"@\" + refBeanDefinition.getScope().getClass().getSimpleName() + \" -> \" + targetBeanDefinition.getName() + \"@\" + targetBeanDefinition.getScope().getClass().getSimpleName();\n    }"}, {"ID": 1171, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object createScopedProxyBean(final PetiteContainer petiteContainer, final BeanDefinition refBeanDefinition) { Class beanType = refBeanDefinition.type; Class proxyClass = proxyClasses.get(beanType); if (proxyClass == null) { // create proxy class only once if (refBeanDefinition instanceof ProxettaBeanDefinition) { // special case, double proxy! ProxettaBeanDefinition pbd = (ProxettaBeanDefinition) refBeanDefinition; ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspects(ArraysUtil.insert(pbd.proxyAspects, aspect, 0)); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(pbd.originalTarget); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } else { ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspect(aspect); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(beanType); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } } Object proxy; try { proxy = ClassUtil.newInstance(proxyClass); Field field = proxyClass.getField(\"$__petiteContainer$0\"); field.set(proxy, petiteContainer); field = proxyClass.getField(\"$__name$0\"); field.set(proxy, refBeanDefinition.name); } catch (Exception ex) { throw new PetiteException(ex); } return proxy; }\n\n    ### Response:", "ground_truth": "Creates scoped proxy bean for given bean definition.", "predict": "/**\n     * Creates a scoped proxy bean for the given reference bean definition.\n     *\n     * @param petiteContainer the Petite container\n     * @param refBeanDefinition the reference bean definition\n     * @return the scoped proxy bean\n     */\n    protected Object createScopedProxyBean(final PetiteContainer petiteContainer, final BeanDefinition refBeanDefinition) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1172, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void loopBody() throws JspException { JspFragment body = getJspBody(); if (body == null) { return; } LoopIterator loopIterator = new LoopIterator(start, end, step, modulus); if (status != null) { getJspContext().setAttribute(status, loopIterator); } while (loopIterator.next()) { TagUtil.invokeBody(body); } if (status != null) { getJspContext().removeAttribute(status); } }\n\n    ### Response:", "ground_truth": "Loops body.", "predict": "/**\r\n     * This method is called by the JSP container to execute the loop body.\r\n     * \r\n     * @throws JspException\r\n     *             if an error occurs while processing the JSP page\r\n     */\r\n    protected void loopBody() throws JspException {\r\n        // TODO: Implement the loop body logic here\r\n    }"}, {"ID": 1173, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void init() { File[] filesArray = dir.listFiles(); filesCount = 0; if (filesArray != null) { filesCount = filesArray.length; for (File file : filesArray) { if (!acceptFile(file)) { continue; } map.put(file, new MutableLong(file.lastModified())); } } }\n\n    ### Response:", "ground_truth": "Initializes dir watcher by reading all files\nfrom watched folder.", "predict": "/**\r\n     * Initializes the object by listing all the files in the specified directory and adding them to the map.\r\n     *\r\n     * @throws IOException if an error occurs while listing the files\r\n     */\r\n    protected void init() throws IOException {\r\n        File[] filesArray = dir.listFiles();\r\n        filesCount = 0;\r\n        if (filesArray != null) {\r\n            filesCount = filesArray.length;\r\n            for (File file : filesArray) {\r\n                if (!acceptFile(file)) {\r\n                    continue;\r\n                }\r\n                map.put(file, new MutableLong(file.lastModified()));\r\n            }\r\n        }\r\n    }"}, {"ID": 1174, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean acceptFile(final File file) { if (!file.isFile()) { return false; // ignore non-files } String fileName = file.getName(); if (ignoreDotFiles) { if (fileName.startsWith(StringPool.DOT)) { return false; // ignore hidden files } } if (patterns == null) { return true; } return Wildcard.matchOne(fileName, patterns) != -1; }\n\n    ### Response:", "ground_truth": "Accepts if a file is going to be watched.", "predict": "/**\r\n     * Checks if the given file should be accepted or not.\r\n     *\r\n     * @param file the file to check\r\n     * @return true if the file should be accepted, false otherwise\r\n     */\r\n    protected boolean acceptFile(final File file) {\r\n        // implementation goes here\r\n    }"}, {"ID": 1175, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirWatcher useWatchFile(final String name) { watchFile = new File(dir, name); if (!watchFile.isFile() || !watchFile.exists()) { try { FileUtil.touch(watchFile); } catch (IOException ioex) { throw new DirWatcherException(\"Invalid watch file: \" + name, ioex); } } watchFileLastAccessTime = watchFile.lastModified(); return this; }\n\n    ### Response:", "ground_truth": "Enables usage of provided watch file.", "predict": "/**\r\n     * Sets the watch file to the specified name and creates it if it doesn't exist.\r\n     * \r\n     * @param name the name of the watch file\r\n     * @return this DirWatcher object\r\n     * @throws DirWatcherException if the watch file is invalid or cannot be created\r\n     */\r\n    public DirWatcher useWatchFile(final String name) {\r\n        watchFile = new File(dir, name);\r\n        if (!watchFile.isFile() || !watchFile.exists()) {\r\n            try {\r\n                FileUtil.touch(watchFile);\r\n            } catch (IOException ioex) {\r\n                throw new DirWatcherException(\"Invalid watch file: \" + name, ioex);\r\n            }\r\n        }\r\n        watchFileLastAccessTime = watchFile.lastModified();\r\n        return this;\r\n    }"}, {"ID": 1176, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final long pollingInterval) { if (timer == null) { if (!startBlank) { init(); } timer = new Timer(true); timer.schedule(new WatchTask(), 0, pollingInterval); } }\n\n    ### Response:", "ground_truth": "Starts the watcher.", "predict": "/**\r\n     * This method starts the timer for the watch task.\r\n     * \r\n     * @param pollingInterval the interval at which the watch task should be executed.\r\n     */\r\n    public void start(final long pollingInterval) {\r\n        if (timer == null) {\r\n            if (!startBlank) {\r\n                init();\r\n            }\r\n            timer = new Timer(true);\r\n            timer.schedule(new WatchTask(), 0, pollingInterval);\r\n        }\r\n    }"}, {"ID": 1177, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onChange(final DirWatcherEvent.Type type, final File file) { listeners.accept(new DirWatcherEvent(type, file)); }\n\n    ### Response:", "ground_truth": "Triggers listeners on file change.", "predict": "/**\r\n     * This method is called when a change event occurs in the directory being watched.\r\n     * \r\n     * @param type the type of change event that occurred\r\n     * @param file the file that was changed\r\n     */\r\n    protected void onChange(final DirWatcherEvent.Type type, final File file) {\r\n        listeners.accept(new DirWatcherEvent(type, file));\r\n    }"}, {"ID": 1178, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Enumeration<T> enumeration) { if (allEnumerations.contains(enumeration)) { throw new IllegalArgumentException(\"Duplicate enumeration\"); } allEnumerations.add(enumeration); }\n\n    ### Response:", "ground_truth": "Adds an enumeration to this composite.", "predict": "/**\r\n     * Adds an enumeration to the set of all enumerations.\r\n     * \r\n     * @param enumeration the enumeration to add\r\n     * @throws IllegalArgumentException if the enumeration is already in the set of all enumerations\r\n     */\r\n    public void add(final Enumeration<T> enumeration) {\r\n        if (allEnumerations.contains(enumeration)) {\r\n            throw new IllegalArgumentException(\"Duplicate enumeration\");\r\n        }\r\n        allEnumerations.add(enumeration);\r\n    }"}, {"ID": 1179, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeFieldInfoSize() { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { // ConstantValue attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE); size += 8; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) { // Synthetic attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { // Signature attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { // Deprecated attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (lastRuntimeVisibleAnnotation != null) { size += lastRuntimeVisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_ANNOTATIONS); } if (lastRuntimeInvisibleAnnotation != null) { size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_ANNOTATIONS); } if (lastRuntimeVisibleTypeAnnotation != null) { size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS); } if (lastRuntimeInvisibleTypeAnnotation != null) { size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS); } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; }\n\n    ### Response:", "ground_truth": "Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure.", "predict": "/**\n     * Computes the size of the field_info structure corresponding to this field,\n     * including its attributes.\n     *\n     * @return the size of the field_info structure corresponding to this field,\n     *         including its attributes.\n     */\n    public int computeFieldInfoSize() {\n        // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.\n        int size = 8;\n        // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.\n        if (constantValueIndex != 0) {\n            // ConstantValue attributes always use 8 bytes.\n            symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);\n            size += 8;\n        }\n        // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.\n        if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_"}, {"ID": 1180, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putFieldInfo(final ByteVector output) { boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0; output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex); // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0; if (constantValueIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { ++attributesCount; } if (signatureIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { ++attributesCount; } if (lastRuntimeVisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeVisibleTypeAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleTypeAnnotation != null) { ++attributesCount; } if (firstAttribute != null) { attributesCount += firstAttribute.getAttributeCount(); } output.putShort(attributesCount); // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)) .putInt(2) .putShort(constantValueIndex); } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0); } if (signatureIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)) .putInt(2) .putShort(signatureIndex); } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0); } if (lastRuntimeVisibleAnnotation != null) { lastRuntimeVisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output); } if (lastRuntimeInvisibleAnnotation != null) { lastRuntimeInvisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output); } if (lastRuntimeVisibleTypeAnnotation != null) { lastRuntimeVisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output); } if (lastRuntimeInvisibleTypeAnnotation != null) { lastRuntimeInvisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output); } if (firstAttribute != null) { firstAttribute.putAttributes(symbolTable, output); } }\n\n    ### Response:", "ground_truth": "Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put.", "predict": "/**\n     * Puts the field_info structure of this field into the given output buffer.\n     *\n     * @param output where the field_info structure must be written.\n     */\n    public void putFieldInfo(final ByteVector output) {\n        // Put the access_flags, name_index and descriptor_index fields.\n        int mask = symbolTable.getMajorVersion() < Opcodes.V1_5 ? Opcodes.ACC_SYNTHETIC : 0;\n        output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex);\n\n        // Compute and put the attributes_count field.\n        int attributesCount = 0;\n        if (constantValueIndex != 0) {\n            ++attributesCount;\n        }\n        if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) {\n            ++attributesCount;\n        }\n        if (signatureIndex != 0) {"}, {"ID": 1181, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Target ofValue(final Object value, final ScopeData scopeData) { return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); }\n\n    ### Response:", "ground_truth": "Creates a common target over a value, with known scope data.", "predict": "/**\r\n     * Creates a new instance of the Target class with the given value, scope data, and instance creator.\r\n     *\r\n     * @param value the value of the target\r\n     * @param scopeData the scope data of the target\r\n     * @param instanceCreator the instance creator of the target\r\n     * @return a new instance of the Target class\r\n     */\r\n    public static Target ofValue(final Object value, final ScopeData scopeData) {\r\n        return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR);\r\n    }"}, {"ID": 1182, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeValue(final InjectionPoint injectionPoint, final Object propertyValue, final boolean silent) { writeValue(injectionPoint.targetName(), propertyValue, silent); }\n\n    ### Response:", "ground_truth": "Writes value to this target. Depending on a flag, writing the value can be\ncompletely silent, when no exception is thrown and with top performances.\nOtherwise, an exception is thrown on a failure.", "predict": "/**\n     * Writes the given property value to the given injection point.\n     * \n     * @param injectionPoint the injection point to write to\n     * @param propertyValue the property value to write\n     * @param silent whether to suppress any exceptions that occur during writing\n     */\n    public void writeValue(final InjectionPoint injectionPoint, final Object propertyValue, final boolean silent) {\n        writeValue(injectionPoint.targetName(), propertyValue, silent);\n    }"}, {"ID": 1183, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void decorate(final Writer writer, final char[] pageContent, final char[] decoraContent) throws IOException { DecoraTag[] decoraTags = parseDecorator(decoraContent); parsePage(pageContent, decoraTags); writeDecoratedPage(writer, decoraContent, pageContent, decoraTags); }\n\n    ### Response:", "ground_truth": "Decorates page content with decorator template and outputs the result.", "predict": "/**\r\n     * This method decorates a given page with the given decorator content.\r\n     * \r\n     * @param writer The writer to write the decorated page to.\r\n     * @param pageContent The content of the page to decorate.\r\n     * @param decoraContent The content of the decorator to use.\r\n     * @throws IOException If an error occurs while writing to the writer.\r\n     */\r\n    public void decorate(final Writer writer, final char[] pageContent, final char[] decoraContent) throws IOException {\r\n        // TODO: Implement this method.\r\n    }"}, {"ID": 1184, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void parsePage(final char[] pageContent, final DecoraTag[] decoraTags) { LagartoParser lagartoParser = new LagartoParser(pageContent); PageRegionExtractor writer = new PageRegionExtractor(decoraTags); lagartoParser.parse(writer); }\n\n    ### Response:", "ground_truth": "Parses target page and extracts Decora regions for replacements.", "predict": "/**\r\n     * Parses the given page content and extracts the regions specified by the given decora tags.\r\n     *\r\n     * @param pageContent the page content to parse\r\n     * @param decoraTags the decora tags specifying the regions to extract\r\n     */\r\n    protected void parsePage(final char[] pageContent, final DecoraTag[] decoraTags) {\r\n        LagartoParser lagartoParser = new LagartoParser(pageContent);\r\n        PageRegionExtractor writer = new PageRegionExtractor(decoraTags);\r\n        lagartoParser.parse(writer);\r\n    }"}, {"ID": 1185, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException { int ndx = 0; for (DecoraTag decoraTag : decoraTags) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag.getStartIndex() - ndx; if (decoratorLen <= 0) { continue; } out.write(decoratorContent, ndx, decoratorLen); ndx = decoraTag.getEndIndex(); // [2] now write region at the place of Decora tag int regionLen = decoraTag.getRegionLength(); if (regionLen == 0) { if (decoraTag.hasDefaultValue()) { out.write(decoratorContent, decoraTag.getDefaultValueStart(), decoraTag.getDefaultValueLength()); } } else { writeRegion(out, pageContent, decoraTag, decoraTags); } } // write remaining content out.write(decoratorContent, ndx, decoratorContent.length - ndx); }\n\n    ### Response:", "ground_truth": "Writes decorated content.", "predict": "/**\r\n     * Writes the decorated page to the output writer.\r\n     * \r\n     * @param out\r\n     *            the output writer\r\n     * @param decoratorContent\r\n     *            the decorator content\r\n     * @param pageContent\r\n     *            the page content\r\n     * @param decoraTags\r\n     *            the decora tags\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    protected void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException {\r\n        int ndx = 0;\r\n        for (DecoraTag decoraTag : decoraTags) {\r\n            // [1] just copy content before the Decora tag\r\n            int decoratorLen = decoraTag.getStartIndex() - ndx;\r\n            if (decoratorLen <= 0) {\r\n                continue;\r\n            }\r\n            out.write(decoratorContent, ndx, decoratorLen);\r\n            ndx = decoraTag.getEndIndex();\r\n            // [2] now write region"}, {"ID": 1186, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void writeRegion(final Writer out, final char[] pageContent, final DecoraTag decoraTag, final DecoraTag[] decoraTags) throws IOException { int regionStart = decoraTag.getRegionStart(); int regionLen = decoraTag.getRegionLength(); int regionEnd = regionStart + regionLen; for (DecoraTag innerDecoraTag : decoraTags) { if (decoraTag == innerDecoraTag) { continue; } if (decoraTag.isRegionUndefined()) { continue; } if (innerDecoraTag.isInsideOtherTagRegion(decoraTag)) { // write everything from region start to the inner Decora tag out.write(pageContent, regionStart, innerDecoraTag.getRegionTagStart() - regionStart); regionStart = innerDecoraTag.getRegionTagEnd(); } } // write remaining content of the region out.write(pageContent, regionStart, regionEnd - regionStart); }\n\n    ### Response:", "ground_truth": "Writes region to output, but extracts all inner regions.", "predict": "/**\r\n     * Writes the content of a region defined by a DecoraTag to a writer.\r\n     * \r\n     * @param out\r\n     *            The writer to write to.\r\n     * @param pageContent\r\n     *            The content of the page.\r\n     * @param decoraTag\r\n     *            The DecoraTag defining the region to write.\r\n     * @param decoraTags\r\n     *            An array of DecoraTags that may be nested inside the region.\r\n     * @throws IOException\r\n     *             If an error occurs while writing to the writer.\r\n     */\r\n    protected void writeRegion(final Writer out, final char[] pageContent, final DecoraTag decoraTag, final DecoraTag[] decoraTags) throws IOException {\r\n        int regionStart = decoraTag.getRegionStart();\r\n        int regionLen = decoraTag.getRegionLength();\r\n        int regionEnd = regionStart + regionLen;\r\n        \r\n        for (DecoraTag innerDecoraTag : decoraTags) {\r\n            if (decoraTag == innerDecoraTag) {"}, {"ID": 1187, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() throws IOException { serverSocket = new ServerSocket(listenPort, socketBacklog); serverSocket.setReuseAddress(true); executorService = Executors.newFixedThreadPool(threadPoolSize); running = true; while (running) { Socket socket = serverSocket.accept(); socket.setKeepAlive(false); executorService.execute(onSocketConnection(socket)); } executorService.shutdown(); }\n\n    ### Response:", "ground_truth": "Starts HTTP tunnel. Method ends when the tunnel is stopped.", "predict": "/**\r\n * This method starts the server socket and listens for incoming connections.\r\n * \r\n * @param listenPort\r\n *            the port number to listen on\r\n * @param socketBacklog\r\n *            the maximum number of queued connections\r\n * @param threadPoolSize\r\n *            the number of threads to use for handling incoming connections\r\n * @param onSocketConnection\r\n *            the callback method to handle incoming connections\r\n * @throws IOException\r\n *             if an I/O error occurs when opening the socket\r\n */\r\npublic void start(int listenPort, int socketBacklog, int threadPoolSize, Consumer<Socket> onSocketConnection) throws IOException {\r\n    serverSocket = new ServerSocket(listenPort, socketBacklog);\r\n    serverSocket.setReuseAddress(true);\r\n    executorService = Executors.newFixedThreadPool(threadPoolSize);\r\n    running = true;\r\n    while (running) {\r\n        Socket socket = serverSocket.accept();\r\n        socket.setKeepAlive(false);\r\n        executorService.execute(onSocketConnection.accept(socket));"}, {"ID": 1188, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ProcessResult run(final Process process) throws InterruptedException { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX); final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX); outputGobbler.start(); errorGobbler.start(); final int result = process.waitFor(); outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessResult(result, baos.toString()); }\n\n    ### Response:", "ground_truth": "Executes a process and returns the process output and exit code.", "predict": "/**\r\n     * Runs a process and waits for it to complete.\r\n     *\r\n     * @param process the process to run\r\n     * @return the result of the process\r\n     * @throws InterruptedException if the thread is interrupted while waiting for the process to complete\r\n     */\r\n    public static ProcessResult run(final Process process) throws InterruptedException {\r\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX);\r\n        final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX);\r\n        outputGobbler.start();\r\n        errorGobbler.start();\r\n        final int result = process.waitFor();\r\n        outputGobbler.waitFor();\r\n        errorGobbler.waitFor();\r\n        return new ProcessResult(result, baos.toString());\r\n    }"}, {"ID": 1189, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected IMAPSSLStore getStore(final Session session) { SimpleAuthenticator simpleAuthenticator = (SimpleAuthenticator) authenticator; final URLName url; if (simpleAuthenticator == null) { url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, null, null); } else { final PasswordAuthentication pa = simpleAuthenticator.getPasswordAuthentication(); url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, pa.getUserName(), pa.getPassword()); } return new IMAPSSLStore(session, url); }\n\n    ### Response:", "ground_truth": "Returns email store.\n\n@param session {@link Session}\n@return {@link com.sun.mail.imap.IMAPSSLStore}", "predict": "/**\r\n     * Returns an IMAPSSLStore object for the given session.\r\n     *\r\n     * @param session the session to use for the IMAPSSLStore object\r\n     * @return an IMAPSSLStore object for the given session\r\n     */\r\n    @Override protected IMAPSSLStore getStore(final Session session) {\r\n        SimpleAuthenticator simpleAuthenticator = (SimpleAuthenticator) authenticator;\r\n        final URLName url;\r\n        if (simpleAuthenticator == null) {\r\n            url = new URLName(PROTOCOL_IMAP, host, port, StringPool.EMPTY, null, null);\r\n        } else {\r\n            final PasswordAuthentication pa = simpleAuthenticator.getPasswordAuthentication();\r\n            url = new URLName(PROTOCOL_IMAP, host, port, StringPool.EMPTY, pa.getUserName(), pa.getPassword());\r\n        }\r\n        return new IMAPSSLStore(session, url);\r\n    }"}, {"ID": 1190, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ServletOutputStream createOutputStream() throws IOException { GzipResponseStream gzstream = new GzipResponseStream(origResponse); gzstream.setBuffer(threshold); return gzstream; }\n\n    ### Response:", "ground_truth": "Creates and returns a ServletOutputStream to write the content associated\nwith this Response.", "predict": "/**\r\n     * This method creates a new output stream for the response.\r\n     * \r\n     * @return A new output stream for the response.\r\n     * @throws IOException If an I/O error occurs.\r\n     */\r\n    public ServletOutputStream createOutputStream() throws IOException;"}, {"ID": 1191, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final TemplateData templateData) { super.init(templateData); if (hint != null) { templateData.incrementHintsCount(); } }\n\n    ### Response:", "ground_truth": "Counts actual real hints.", "predict": "/**\r\n     * Initializes the template data with the given hint.\r\n     * \r\n     * @param templateData the template data to initialize\r\n     */\r\n    @Override\r\n    public void init(final TemplateData templateData) {\r\n        super.init(templateData);\r\n        if (hint != null) {\r\n            templateData.incrementHintsCount();\r\n        }\r\n    }"}, {"ID": 1192, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendAlias(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { final ColumnAliasType columnAliasType = templateData.getColumnAliasType(); if (columnAliasType == null || columnAliasType == ColumnAliasType.TABLE_REFERENCE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnNameForQuery(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(columnName); } else if (columnAliasType == ColumnAliasType.COLUMN_CODE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnName(); final String code = templateData.registerColumnDataForColumnCode(tableName, columnName); query.append(code); } else if (columnAliasType == ColumnAliasType.TABLE_NAME) { final String tableName = ded.getTableNameForQuery(); final String columnName = dec.getColumnNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(columnName); } }\n\n    ### Response:", "ground_truth": "Appends alias.", "predict": "/**\r\n     * Appends the column alias to the query string based on the column alias type specified in the template data.\r\n     * \r\n     * @param query the query string to which the column alias is to be appended\r\n     * @param ded the descriptor for the entity to which the column belongs\r\n     * @param dec the descriptor for the column to be aliased\r\n     */\r\n    protected void appendAlias(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) {\r\n        final ColumnAliasType columnAliasType = templateData.getColumnAliasType();\r\n        if (columnAliasType == null || columnAliasType == ColumnAliasType.TABLE_REFERENCE) {\r\n            final String tableName = ded.getTableName();\r\n            final String columnName = dec.getColumnNameForQuery();\r\n            templateData.registerColumnDataForTableRef(tableRef, tableName);\r\n            query.append(tableRef).append(columnAliasSeparator).append(columnName);\r\n        } else if (columnAliasType == ColumnAliasType.COLUMN_CODE) {\r\n            final String"}, {"ID": 1193, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendColumnName(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName()); if (templateData.getColumnAliasType() != null) { // create column aliases query.append(AS); switch (templateData.getColumnAliasType()) { case TABLE_NAME: { final String tableName = ded.getTableNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case TABLE_REFERENCE: { final String tableName = ded.getTableName(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case COLUMN_CODE: { final String tableName = ded.getTableName(); final String code = templateData.registerColumnDataForColumnCode(tableName, dec.getColumnName()); query.append(code); break; } } } }\n\n    ### Response:", "ground_truth": "Simply appends column name with optional table reference and alias.", "predict": "/**\r\n     * Appends the column name to the query string.\r\n     * \r\n     * @param query the query string to append to\r\n     * @param ded the entity descriptor for the entity being queried\r\n     * @param dec the column descriptor for the column being queried\r\n     */\r\n    protected void appendColumnName(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) {\r\n        query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName());\r\n        if (templateData.getColumnAliasType() != null) {\r\n            // create column aliases\r\n            query.append(AS);\r\n            switch (templateData.getColumnAliasType()) {\r\n                case TABLE_NAME: {\r\n                    final String tableName = ded.getTableNameForQuery();\r\n                    query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery());\r\n                    break;\r\n                }\r\n                case TABLE_REFERENCE: {\r\n                    final String tableName = ded.getTableName();\r\n                    templateData.registerColumnDataForTableRef"}, {"ID": 1194, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addRule(final D ruleDefinition, final boolean include) { if (rules == null) { rules = new ArrayList<>(); } if (include) { includesCount++; } else { excludesCount++; } Rule<R> newRule = new Rule<>(makeRule(ruleDefinition), include); if (rules.contains(newRule)) { return; } rules.add(newRule); }\n\n    ### Response:", "ground_truth": "Adds a rule. Duplicates are not allowed and will be ignored.", "predict": "/**\r\n     * Adds a new rule to the list of rules.\r\n     * \r\n     * @param ruleDefinition the definition of the rule to be added\r\n     * @param include whether the rule should be included or excluded\r\n     */\r\n    protected void addRule(final D ruleDefinition, final boolean include) {\r\n        // implementation details omitted for brevity\r\n    }"}, {"ID": 1195, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean apply(final V value, final boolean blacklist, boolean flag) { if (rules == null) { return flag; } if (blacklist) { flag = processExcludes(value, flag); flag = processIncludes(value, flag); } else { flag = processIncludes(value, flag); flag = processExcludes(value, flag); } return flag; }\n\n    ### Response:", "ground_truth": "Applies rules on given flag. Flag is only changed if at least one rule\nmatched. Otherwise, the same value is returned. This way you can\nchain several rules and have the rule engine change the flag\nonly when a rule is matched.", "predict": "/**\r\n     * Applies the rules to the given value and returns the result.\r\n     * \r\n     * @param value the value to apply the rules to\r\n     * @param blacklist whether to apply the blacklist or the whitelist rules\r\n     * @param flag the initial flag value\r\n     * @return the final flag value after applying the rules\r\n     */\r\n    public boolean apply(final V value, final boolean blacklist, boolean flag) {\r\n        if (rules == null) {\r\n            return flag;\r\n        }\r\n        if (blacklist) {\r\n            flag = processExcludes(value, flag);\r\n            flag = processIncludes(value, flag);\r\n        } else {\r\n            flag = processIncludes(value, flag);\r\n            flag = processExcludes(value, flag);\r\n        }\r\n        return flag;\r\n    }"}, {"ID": 1196, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean processIncludes(final V value, boolean include) { if (includesCount > 0) { if (!include) { for (Rule<R> rule : rules) { if (!rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, true)) { include = true; break; } } } } return include; }\n\n    ### Response:", "ground_truth": "Process includes rules.", "predict": "/**\r\n     * Processes the include rules for the given value.\r\n     *\r\n     * @param value the value to process\r\n     * @param include the current include value\r\n     * @return the updated include value\r\n     */\r\n    protected boolean processIncludes(final V value, boolean include) {\r\n        if (includesCount > 0) {\r\n            if (!include) {\r\n                for (Rule<R> rule : rules) {\r\n                    if (!rule.include) {\r\n                        continue;\r\n                    }\r\n                    if (inExRuleMatcher.accept(value, rule.value, true)) {\r\n                        include = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return include;\r\n    }"}, {"ID": 1197, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean processExcludes(final V value, boolean include) { if (excludesCount > 0) { if (include) { for (Rule<R> rule : rules) { if (rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, false)) { include = false; break; } } } } return include; }\n\n    ### Response:", "ground_truth": "Process excludes rules.", "predict": "/**\r\n     * Processes the exclude rules for the given value and returns whether it should be included or not.\r\n     *\r\n     * @param value the value to process\r\n     * @param include whether the value should be included or not\r\n     * @return whether the value should be included or not after processing the exclude rules\r\n     */\r\n    protected boolean processExcludes(final V value, boolean include) {\r\n        if (excludesCount > 0) {\r\n            if (include) {\r\n                for (Rule<R> rule : rules) {\r\n                    if (rule.include) {\r\n                        continue;\r\n                    }\r\n                    if (inExRuleMatcher.accept(value, rule.value, false)) {\r\n                        include = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return include;\r\n    }"}, {"ID": 1198, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPseudoClassName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; }\n\n    ### Response:", "ground_truth": "Returns pseudo-class name from simple class name.", "predict": "/**\r\n     * This method returns the pseudo class name of the class.\r\n     * \r\n     * @return the pseudo class name of the class\r\n     */\r\n    public String getPseudoClassName() {\r\n        String name = getClass().getSimpleName().toLowerCase();\r\n        name = name.replace('_', '-');\r\n        return name;\r\n    }"}, {"ID": 1199, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean addAll(final Collection<? extends E> c) { Iterator<? extends E> i = c.iterator(); boolean changed = false; while (i.hasNext()) { boolean ret = add(i.next()); if (!changed) { changed = ret; } } return changed; }\n\n    ### Response:", "ground_truth": "Add all of the elements in the given collection to this list.", "predict": "/**\r\n     * Adds all of the elements in the specified collection to this collection.\r\n     *\r\n     * @param c the collection of elements to be added to this collection\r\n     * @return true if this collection changed as a result of the call\r\n     * @throws UnsupportedOperationException if the add operation is not supported by this collection\r\n     * @throws ClassCastException if the class of an element of the specified collection prevents it from being added to this collection\r\n     * @throws NullPointerException if the specified collection contains a null element and this collection does not permit null elements\r\n     * @throws IllegalArgumentException if some property of an element of the specified collection prevents it from being added to this collection\r\n     */\r\n    @Override public boolean addAll(final Collection<? extends E> c) {\r\n        Iterator<? extends E> i = c.iterator();\r\n        boolean changed = false;\r\n        while (i.hasNext()) {\r\n            boolean ret = add(i.next());\r\n            if (!changed) {\r\n                changed = ret;\r\n            }\r\n        }\r\n        return changed;\r\n    }"}, {"ID": 1200, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int findInsertionPoint(final E o, int low, int high) { while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(get(mid), o); if (delta > 0) { high = mid - 1; } else { low = mid + 1; } } return low; }\n\n    ### Response:", "ground_truth": "Conducts a binary search to find the index where Object\nshould be inserted.", "predict": "/**\r\n     * Finds the index at which the specified element should be inserted in the\r\n     * specified sorted list. The list must be sorted according to the natural\r\n     * ordering of its elements.\r\n     *\r\n     * @param o the element for which to find the insertion point\r\n     * @param low the index of the first element in the range\r\n     * @param high the index of the last element in the range\r\n     * @return the index at which the specified element should be inserted\r\n     */\r\n    protected int findInsertionPoint(final E o, int low, int high) {\r\n        while (low <= high) {\r\n            int mid = (low + high) >>> 1;\r\n            int delta = compare(get(mid), o);\r\n            if (delta > 0) {\r\n                high = mid - 1;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }"}, {"ID": 1201, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void bindAnnotationConfig(final Class<? extends Annotation> annotationType, final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass); actionConfigs.put(annotationType, actionConfig); for (final AnnotationParser annotationParser : annotationParsers) { if (annotationType.equals(annotationParser.getAnnotationType())) { // parser already exists return; } } annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class)); }\n\n    ### Response:", "ground_truth": "Binds action annotation and the action config. This can overwrite the default annotation\nconfiguration of an annotation.", "predict": "/**\r\n     * Binds the given annotation type to the given action configuration class.\r\n     * \r\n     * @param annotationType the annotation type to bind\r\n     * @param actionConfigClass the action configuration class to bind to the annotation type\r\n     */\r\n    public void bindAnnotationConfig(final Class<? extends Annotation> annotationType, final Class<? extends ActionConfig> actionConfigClass) {\r\n        final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass);\r\n        actionConfigs.put(annotationType, actionConfig);\r\n        for (final AnnotationParser annotationParser : annotationParsers) {\r\n            if (annotationType.equals(annotationParser.getAnnotationType())) {\r\n                // parser already exists\r\n                return;\r\n            }\r\n        }\r\n        annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class));\r\n    }"}, {"ID": 1202, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionConfig registerNewActionConfiguration(final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig newActionConfig = createActionConfig(actionConfigClass); actionConfigs.put(actionConfigClass, newActionConfig); return newActionConfig; }\n\n    ### Response:", "ground_truth": "Registers action configuration for given type.", "predict": "/**\r\n     * Registers a new action configuration of the specified class.\r\n     * \r\n     * @param actionConfigClass the class of the action configuration to register\r\n     * @return the new action configuration object\r\n     */\r\n    protected ActionConfig registerNewActionConfiguration(final Class<? extends ActionConfig> actionConfigClass) {\r\n        final ActionConfig newActionConfig = createActionConfig(actionConfigClass);\r\n        actionConfigs.put(actionConfigClass, newActionConfig);\r\n        return newActionConfig;\r\n    }"}, {"ID": 1203, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionConfig lookup(final Class actionTypeOrAnnotationType) { final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType); if (actionConfig == null) { throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName()); } return actionConfig; }\n\n    ### Response:", "ground_truth": "Lookup for the action configuration. Typically, the input argument is either the action type or annotation type.", "predict": "/**\r\n     * Looks up an action configuration by its type or annotation type.\r\n     * \r\n     * @param actionTypeOrAnnotationType the type or annotation type of the action configuration to lookup\r\n     * @return the action configuration, or null if not found\r\n     * @throws MadvocException if the action configuration is not registered\r\n     */\r\n    public ActionConfig lookup(final Class actionTypeOrAnnotationType) {\r\n        final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType);\r\n        if (actionConfig == null) {\r\n            throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName());\r\n        }\r\n        return actionConfig;\r\n    }"}, {"ID": 1204, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) { final T actionConfig = (T) lookup(actionConfigType); actionConfigConsumer.accept(actionConfig); }\n\n    ### Response:", "ground_truth": "Fetch some action config and consumes it.", "predict": "/**\r\n     * This method is used to configure an action with the given action configuration type and consumer.\r\n     * \r\n     * @param actionConfigType The type of the action configuration.\r\n     * @param actionConfigConsumer The consumer that will be used to configure the action.\r\n     * @param <T> The type of the action configuration.\r\n     */\r\n    public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) {\r\n        final T actionConfig = (T) lookup(actionConfigType);\r\n        actionConfigConsumer.accept(actionConfig);\r\n    }"}, {"ID": 1205, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static void setupSystemMailProperties() { System.setProperty(\"mail.mime.encodefilename\", Boolean.valueOf(Defaults.mailMimeEncodefilename).toString()); System.setProperty(\"mail.mime.decodefilename\", Boolean.valueOf(Defaults.mailMimeDecodefilename).toString()); }\n\n    ### Response:", "ground_truth": "Setups the system email properties.", "predict": "/**\r\n     * Sets up the system properties for mail encoding and decoding.\r\n     */\r\n    protected static void setupSystemMailProperties() {\r\n        System.setProperty(\"mail.mime.encodefilename\", Boolean.valueOf(Defaults.mailMimeEncodefilename).toString());\r\n        System.setProperty(\"mail.mime.decodefilename\", Boolean.valueOf(Defaults.mailMimeDecodefilename).toString());\r\n    }"}, {"ID": 1206, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void validateWithin(final ValidationContext vctx, final Object value) { vtor.validate(vctx, value, name); }\n\n    ### Response:", "ground_truth": "Validates provided context and value withing this constraint content.", "predict": "/**\r\n     * Validates the given value within the given validation context.\r\n     * \r\n     * @param vctx the validation context\r\n     * @param value the value to validate\r\n     */\r\n    public void validateWithin(final ValidationContext vctx, final Object value) {\r\n        vtor.validate(vctx, value, name);\r\n    }"}, {"ID": 1207, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Element findLastTable(final Node node) { Node tableNode = node; while (tableNode != null) { if (tableNode.getNodeType() == Node.NodeType.ELEMENT) { String tableNodeName = tableNode.getNodeName().toLowerCase(); if (tableNodeName.equals(\"table\")) { break; } } tableNode = tableNode.getParentNode(); } return (Element) tableNode; }\n\n    ### Response:", "ground_truth": "Finds the last table in stack of open elements.", "predict": "/**\r\n     * Finds the last table element in the DOM tree starting from the given node.\r\n     * \r\n     * @param node the starting node for the search\r\n     * @return the last table element found, or null if no table element was found\r\n     */\r\n    protected Element findLastTable(final Node node) {\r\n        Node tableNode = node;\r\n        while (tableNode != null) {\r\n            if (tableNode.getNodeType() == Node.NodeType.ELEMENT) {\r\n                String tableNodeName = tableNode.getNodeName().toLowerCase();\r\n                if (tableNodeName.equals(\"table\")) {\r\n                    break;\r\n                }\r\n            }\r\n            tableNode = tableNode.getParentNode();\r\n        }\r\n        return (Element) tableNode;\r\n    }"}, {"ID": 1208, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void fixElements() { for (Element fosterElement : fosterElements) { // find parent table Element lastTable = findLastTable(fosterElement); Node fosterElementParent = fosterElement.getParentNode(); // filter our foster element Node[] fosterChilds = fosterElement.getChildNodes(); for (Node fosterChild : fosterChilds) { if (fosterChild.getNodeType() == Node.NodeType.ELEMENT) { if (isOneOfTableElements((Element) fosterChild)) { // move all child table elements outside // the foster element fosterChild.detachFromParent(); fosterElementParent.insertBefore(fosterChild, fosterElement); } } } // finally, move foster element above the table fosterElement.detachFromParent(); lastTable.getParentNode().insertBefore(fosterElement, lastTable); } }\n\n    ### Response:", "ground_truth": "Performs the fix for elements.", "predict": "/**\r\n     * This method is responsible for fixing the table elements that were moved outside of their parent table.\r\n     * It does this by finding the last table element in the document and moving all child table elements outside of the foster element.\r\n     * It then moves the foster element above the last table element.\r\n     */"}, {"ID": 1209, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Map<String, BeanData> registerSessionBeans(final HttpSession httpSession) { SessionBeans sessionBeans = new SessionBeans(); httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans); return sessionBeans.getBeanMap(); }\n\n    ### Response:", "ground_truth": "Registers new session destroy callback if not already registered.", "predict": "/**\r\n     * Registers the session beans in the HTTP session and returns a map of the beans.\r\n     *\r\n     * @param httpSession the HTTP session\r\n     * @return a map of the beans\r\n     */\r\n    protected Map<String, BeanData> registerSessionBeans(final HttpSession httpSession) {\r\n        SessionBeans sessionBeans = new SessionBeans();\r\n        httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans);\r\n        return sessionBeans.getBeanMap();\r\n    }"}, {"ID": 1210, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Map<String, BeanData> getSessionMap(final HttpSession session) { SessionBeans sessionBeans = (SessionBeans) session.getAttribute(SESSION_BEANS_NAME); if (sessionBeans == null) { return null; } return sessionBeans.getBeanMap(); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Retrieves the session-scoped map of beans.\r\n     * \r\n     * @param session\r\n     *            the current HTTP session\r\n     * @return the session-scoped map of beans, or null if none exists\r\n     */\r\n    protected Map<String, BeanData> getSessionMap(final HttpSession session) {\r\n        // code omitted for brevity\r\n    }"}, {"ID": 1211, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void init(String name, final String superName, final String suffix, final String reqProxyClassName) { int lastSlash = name.lastIndexOf('/'); this.targetPackage = lastSlash == -1 ? StringPool.EMPTY : name.substring(0, lastSlash).replace('/', '.'); this.targetClassname = name.substring(lastSlash + 1); this.nextSupername = superName; this.superName = name; // create proxy name if (reqProxyClassName != null) { if (reqProxyClassName.startsWith(DOT)) { name = name.substring(0, lastSlash) + '/' + reqProxyClassName.substring(1); } else if (reqProxyClassName.endsWith(DOT)) { name = reqProxyClassName.replace('.', '/') + this.targetClassname; } else { name = reqProxyClassName.replace('.', '/'); } } // add optional suffix if (suffix != null) { name += suffix; } this.thisReference = name; this.superReference = this.superName; }\n\n    ### Response:", "ground_truth": "Work data initialization.", "predict": "/**\r\n     * Initializes the object with the given name, superName, suffix, and reqProxyClassName.\r\n     * \r\n     * @param name the name of the class to be generated.\r\n     * @param superName the name of the superclass of the class to be generated.\r\n     * @param suffix an optional suffix to be added to the generated class name.\r\n     * @param reqProxyClassName an optional name of the proxy class to be generated.\r\n     */\r\n    public void init(String name, final String superName, final String suffix, final String reqProxyClassName) {\r\n        int lastSlash = name.lastIndexOf('/');\r\n        this.targetPackage = lastSlash == -1 ? StringPool.EMPTY : name.substring(0, lastSlash).replace('/', '.');\r\n        this.targetClassname = name.substring(lastSlash + 1);\r\n        this.nextSupername = superName;\r\n        this.superName = name;\r\n        // create proxy name if (reqProxyClassName != null) {\r\n            if (reqProxyClassName.startsWith(DOT)) {"}, {"ID": 1212, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void addAdviceInitMethod(final String name) { if (adviceInits == null) { adviceInits = new ArrayList<>(); } adviceInits.add(name); }\n\n    ### Response:", "ground_truth": "Saves used constructors of advices.", "predict": "/**\r\n     * Adds the given name to the list of advice initialization methods.\r\n     *\r\n     * @param name the name of the advice initialization method to add\r\n     */\r\n    void addAdviceInitMethod(final String name);"}, {"ID": 1213, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void end() { if (newAction) { bundleId = bundlesManager.registerBundle(contextPath, actionPath, bundleId, bundleContentType, sources); } }\n\n    ### Response:", "ground_truth": "Called on end of parsing.", "predict": "/**\r\n     * Ends the current action by registering the bundle with the bundles manager.\r\n     * \r\n     * @param newAction - true if a new action is starting, false otherwise.\r\n     * @param bundleId - the ID of the bundle to register.\r\n     * @param bundleContentType - the content type of the bundle to register.\r\n     * @param sources - the sources of the bundle to register.\r\n     */\r\n    public void end(boolean newAction, String bundleId, String bundleContentType, List<String> sources) {\r\n        if (newAction) {\r\n            bundleId = bundlesManager.registerBundle(contextPath, actionPath, bundleId, bundleContentType, sources);\r\n        }\r\n    }"}, {"ID": 1214, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void add( final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) { // ignore lines without : or = if (key == null) { return; } String fullKey = key; if (section != null) { if (fullKey.length() != 0) { fullKey = section + '.' + fullKey; } else { fullKey = section; } } String v = value.toString(); if (trim) { if (valueTrimLeft && valueTrimRight) { v = v.trim(); } else if (valueTrimLeft) { v = StringUtil.trimLeft(v); } else { v = StringUtil.trimRight(v); } } if (v.length() == 0 && skipEmptyProps) { return; } extractProfilesAndAdd(fullKey, v, operator); }\n\n    ### Response:", "ground_truth": "Adds accumulated value to key and current section.", "predict": "/**\r\n     * Adds a property to the configuration.\r\n     * \r\n     * @param section the section of the property, can be null\r\n     * @param key the key of the property, cannot be null\r\n     * @param value the value of the property, cannot be null\r\n     * @param trim whether to trim the value or not\r\n     * @param operator the operator to use when adding the property\r\n     */\r\n    protected void add(final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) {\r\n        // ignore lines without : or =\r\n        if (key == null) {\r\n            return;\r\n        }\r\n        String fullKey = key;\r\n        if (section != null) {\r\n            if (fullKey.length() != 0) {\r\n                fullKey = section + '.' + fullKey;\r\n            } else {\r\n                fullKey = section;\r\n            }\r\n        }\r\n        String v = value.toString();\r\n        if (trim) {\r\n            if (valueTrimLeft && valueTrimRight) {\r\n                v = v.trim();\r\n            }"}, {"ID": 1215, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void extractProfilesAndAdd(final String key, final String value, final Operator operator) { String fullKey = key; int ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { justAdd(fullKey, value, null, operator); return; } // extract profiles ArrayList<String> keyProfiles = new ArrayList<>(); while (true) { ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { break; } final int len = fullKey.length(); int ndx2 = fullKey.indexOf(PROFILE_RIGHT, ndx + 1); if (ndx2 == -1) { ndx2 = len; } // remember profile final String profile = fullKey.substring(ndx + 1, ndx2); keyProfiles.add(profile); // extract profile from key ndx2++; final String right = (ndx2 == len) ? StringPool.EMPTY : fullKey.substring(ndx2); fullKey = fullKey.substring(0, ndx) + right; } if (fullKey.startsWith(StringPool.DOT)) { // check for special case when only profile is defined in section fullKey = fullKey.substring(1); } // add value to extracted profiles justAdd(fullKey, value, keyProfiles, operator); }\n\n    ### Response:", "ground_truth": "Extracts profiles from the key name and adds key-value to them.", "predict": "/**\n     * Extracts profiles from the given key and adds the value to the extracted profiles.\n     * \n     * @param key the key to extract profiles from\n     * @param value the value to add to the extracted profiles\n     * @param operator the operator to use for adding the value to the extracted profiles\n     */\n    protected void extractProfilesAndAdd(final String key, final String value, final Operator operator) {\n        String fullKey = key;\n        int ndx = fullKey.indexOf(PROFILE_LEFT);\n        if (ndx == -1) {\n            justAdd(fullKey, value, null, operator);\n            return;\n        }\n        // extract profiles\n        ArrayList<String> keyProfiles = new ArrayList<>();\n        while (true) {\n            ndx = fullKey.indexOf(PROFILE_LEFT);\n            if (ndx == -1) {\n                break;\n            }\n            final int len = fullKey.length();\n            int ndx2 = fullKey.indexOf(PROFILE_RIGHT, ndx + 1);\n            if"}, {"ID": 1216, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void justAdd(final String key, final String value, final ArrayList<String> keyProfiles, final Operator operator) { if (operator == Operator.COPY) { HashMap<String,Object> target = new HashMap<>(); String[] profiles = null; if (keyProfiles != null) { profiles = keyProfiles.toArray(new String[0]); } String[] sources = StringUtil.splitc(value, ','); for (String source : sources) { source = source.trim(); // try to extract profile for parsing String[] lookupProfiles = profiles; String lookupProfilesString = null; int leftIndex = source.indexOf('<'); if (leftIndex != -1) { int rightIndex = source.indexOf('>'); lookupProfilesString = source.substring(leftIndex + 1, rightIndex); source = source.substring(0, leftIndex).concat(source.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(lookupProfilesString, ','); StringUtil.trimAll(lookupProfiles); } String[] wildcards = new String[] {source + \".*\"}; propsData.extract(target, lookupProfiles, wildcards, null); for (Map.Entry<String, Object> entry : target.entrySet()) { String entryKey = entry.getKey(); String suffix = entryKey.substring(source.length()); String newKey = key + suffix; String newValue = \"${\" + entryKey; if (lookupProfilesString != null) { newValue += \"<\" + lookupProfilesString + \">\"; } newValue += \"}\"; if (profiles == null) { propsData.putBaseProperty(newKey, newValue, false); } else { for (final String p : profiles) { propsData.putProfileProperty(newKey, newValue, p, false); } } } } return; } boolean append = operator == Operator.QUICK_APPEND; if (keyProfiles == null) { propsData.putBaseProperty(key, value, append); return; } for (final String p : keyProfiles) { propsData.putProfileProperty(key, value, p, append); } }\n\n    ### Response:", "ground_truth": "Core key-value addition.", "predict": "/**\r\n     * Adds a property to the properties data object.\r\n     * \r\n     * @param key the key of the property to add\r\n     * @param value the value of the property to add\r\n     * @param keyProfiles the profiles to which the property should be added (null for base property)\r\n     * @param operator the operator to use when adding the property\r\n     */\r\n    protected void justAdd(final String key, final String value, final ArrayList<String> keyProfiles, final Operator operator) {\r\n        // implementation goes here\r\n    }"}, {"ID": 1217, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typedesc2ClassName(final String desc) { String className = desc; switch (desc.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': if (desc.length() != 1) { throw new IllegalArgumentException(INVALID_BASE_TYPE + desc); } break; case 'L': className = className.substring(1, className.length() - 1); break; case '[': // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. className = className.replace('/', '.'); break; default: throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } return className; }\n\n    ### Response:", "ground_truth": "Converts bytecode-like description to java class name that can be loaded\nwith a classloader. Uses less-known feature of class loaders for loading\narray classes.\n\n@see #typedescToSignature(String, jodd.mutable.MutableInteger)", "predict": "/**\r\n     * Converts a type descriptor to a class name.\r\n     *\r\n     * @param desc the type descriptor to convert\r\n     * @return the class name corresponding to the type descriptor\r\n     * @throws IllegalArgumentException if the type descriptor is invalid\r\n     */\r\n    public static String typedesc2ClassName(final String desc) {\r\n        String className = desc;\r\n        switch (desc.charAt(0)) {\r\n            case 'B':\r\n            case 'C':\r\n            case 'D':\r\n            case 'F':\r\n            case 'I':\r\n            case 'J':\r\n            case 'S':\r\n            case 'Z':\r\n            case 'V':\r\n                if (desc.length() != 1) {\r\n                    throw new IllegalArgumentException(INVALID_BASE_TYPE + desc);\r\n                }\r\n                break;\r\n            case 'L':\r\n                className = className.substring(1, className.length() - 1);\r\n                break;\r\n            case '[':\r\n                // uses less-known feature of class loaders for loading array types\r\n                // using bytecode-like signatures.\r\n                className = className.replace('/', '.');\r\n               "}, {"ID": 1218, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typeref2Name(final String desc) { if (desc.charAt(0) != TYPE_REFERENCE) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } String name = desc.substring(1, desc.length() - 1); return name.replace('/', '.'); }\n\n    ### Response:", "ground_truth": "Converts type reference to java-name.", "predict": "/**\r\n     * Converts a type descriptor to a fully qualified class name.\r\n     *\r\n     * @param desc the type descriptor to convert\r\n     * @return the fully qualified class name\r\n     * @throws IllegalArgumentException if the type descriptor is not valid\r\n     */\r\n    public static String typeref2Name(final String desc) {\r\n        if (desc.charAt(0) != TYPE_REFERENCE) {\r\n            throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc);\r\n        }\r\n        String name = desc.substring(1, desc.length() - 1);\r\n        return name.replace('/', '.');\r\n    }"}, {"ID": 1219, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typedescToSignature(final String desc, final MutableInteger from) { int fromIndex = from.get(); from.value++; // default usage for most cases switch (desc.charAt(fromIndex)) { case 'B': return \"byte\"; case 'C': return \"char\"; case 'D': return \"double\"; case 'F': return \"float\"; case 'I': return \"int\"; case 'J': return \"long\"; case 'S': return \"short\"; case 'Z': return \"boolean\"; case 'V': return \"void\"; case 'L': int index = desc.indexOf(';', fromIndex); if (index < 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } from.set(index + 1); String str = desc.substring(fromIndex + 1, index); return str.replace('/', '.'); case 'T': return desc.substring(from.value); case '[': StringBuilder brackets = new StringBuilder(); int n = fromIndex; while (desc.charAt(n) == '[') { // count opening brackets brackets.append(\"[]\"); n++; } from.value = n; String type = typedescToSignature(desc, from); // the rest of the string denotes a `<field_type>' return type + brackets; default: if (from.value == 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } // generics! return desc.substring(from.value); } }\n\n    ### Response:", "ground_truth": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n{@code\n ::= \n      ::= ||\n       ::= B|C|D|F|I|J|S|Z\n     ::= L;\n      ::= [\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL; ... an object of the given class\nS short signed short\nZ boolean true or false\n[ ... array\n}\n\nThis method converts this string into a Java type declaration such as\nString[].", "predict": "/**\n     * Converts a type descriptor to a method signature.\n     * \n     * @param desc the type descriptor to convert\n     * @param from the starting index in the descriptor (optional, default is 0)\n     * @return the method signature\n     * @throws IllegalArgumentException if the descriptor is invalid\n     */\n    public static String typedescToSignature(final String desc, final MutableInteger from) {\n        int fromIndex = from.get();\n        from.value++; // default usage for most cases\n        switch (desc.charAt(fromIndex)) {\n            case 'B':\n                return \"byte\";\n            case 'C':\n                return \"char\";\n            case 'D':\n                return \"double\";\n            case 'F':\n                return \"float\";\n            case 'I':\n                return \"int\";\n            case 'J':\n                return \"long\";\n            case 'S':\n                return \"short\";\n            case 'Z':\n                return \"boolean\";\n            case 'V':\n                return \"void\";\n            case 'L':\n                int index = desc.indexOf(';',"}, {"ID": 1220, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String typeToTyperef(final Class type) { if (!type.isArray()) { if (!type.isPrimitive()) { return 'L' + typeToSignature(type) + ';'; } if (type == int.class) { return \"I\"; } if (type == long.class) { return \"J\"; } if (type == boolean.class) { return \"Z\"; } if (type == double.class) { return \"D\"; } if (type == float.class) { return \"F\"; } if (type == short.class) { return \"S\"; } if (type == void.class) { return \"V\"; } if (type == byte.class) { return \"B\"; } if (type == char.class) { return \"C\"; } } return type.getName(); }\n\n    ### Response:", "ground_truth": "Converts type to byteccode type ref.", "predict": "/**\n     * Converts a Java type to a JVM type descriptor.\n     *\n     * @param type the Java type to convert\n     * @return the JVM type descriptor\n     */\n    public static String typeToTyperef(final Class type) {\n        // implementation goes here\n    }"}, {"ID": 1221, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Consumers<T> addAll(final Consumer<T>... consumers) { Collections.addAll(consumerList, consumers); return this; }\n\n    ### Response:", "ground_truth": "Registers additional consumers.", "predict": "/**\r\n     * Adds all the consumers to the consumer list.\r\n     * \r\n     * @param consumers the consumers to be added to the consumer list.\r\n     * @return the updated consumer list.\r\n     */\r\n    public Consumers<T> addAll(final Consumer<T>... consumers) {\r\n        Collections.addAll(consumerList, consumers);\r\n        return this;\r\n    }"}, {"ID": 1222, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Collection<T> createCollection(final int length) { if (collectionType.isInterface()) { if (collectionType == List.class) { if (length > 0) { return new ArrayList<>(length); } else { return new ArrayList<>(); } } if (collectionType == Set.class) { if (length > 0) { return new HashSet<>(length); } else { return new HashSet<>(); } } throw new TypeConversionException(\"Unknown collection: \" + collectionType.getName()); } if (length > 0) { try { Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class); return ctor.newInstance(Integer.valueOf(length)); } catch (Exception ex) { // ignore exception } } try { return collectionType.getDeclaredConstructor().newInstance(); } catch (Exception ex) { throw new TypeConversionException(ex); } }\n\n    ### Response:", "ground_truth": "Creates new collection of target component type.\nDefault implementation uses reflection to create\nan collection of target type. Override it for better performances.", "predict": "/**\r\n     * Creates a collection of the specified type and length.\r\n     * \r\n     * @param length the length of the collection to create\r\n     * @return the created collection\r\n     * @throws TypeConversionException if the collection type is not recognized or cannot be instantiated\r\n     */\r\n    protected Collection<T> createCollection(final int length) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1223, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertToSingleElementCollection(final Object value) { Collection<T> collection = createCollection(0); //noinspection unchecked collection.add((T) value); return collection; }\n\n    ### Response:", "ground_truth": "Creates a collection with single element.", "predict": "/**\r\n     * Converts the given value to a collection containing a single element.\r\n     *\r\n     * @param value the value to convert\r\n     * @return a collection containing a single element\r\n     */\r\n    protected Collection<T> convertToSingleElementCollection(final Object value) {\r\n        Collection<T> collection = createCollection(0); //noinspection unchecked\r\n        collection.add((T) value);\r\n        return collection;\r\n    }"}, {"ID": 1224, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertValueToCollection(Object value) { if (value instanceof Iterable) { Iterable iterable = (Iterable) value; Collection<T> collection = createCollection(0); for (Object element : iterable) { collection.add(convertType(element)); } return collection; } if (value instanceof CharSequence) { value = CsvUtil.toStringArray(value.toString()); } Class type = value.getClass(); if (type.isArray()) { // convert arrays Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { return convertPrimitiveArrayToCollection(value, componentType); } else { Object[] array = (Object[]) value; Collection<T> result = createCollection(array.length); for (Object a : array) { result.add(convertType(a)); } return result; } } // everything else: return convertToSingleElementCollection(value); }\n\n    ### Response:", "ground_truth": "Converts non-collection value to collection.", "predict": "/**\r\n     * Converts the given value to a collection of type T.\r\n     * \r\n     * @param value the value to convert\r\n     * @return the resulting collection\r\n     */\r\n    protected Collection<T> convertValueToCollection(Object value) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1225, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Collection<T> convertCollectionToCollection(final Collection value) { Collection<T> collection = createCollection(value.size()); for (Object v : value) { collection.add(convertType(v)); } return collection; }\n\n    ### Response:", "ground_truth": "Converts collection value to target collection.\nEach element is converted to target component type.", "predict": "/**\r\n     * Converts the given collection to a collection of type T.\r\n     * \r\n     * @param value the collection to convert\r\n     * @return the converted collection\r\n     */\r\n    protected Collection<T> convertCollectionToCollection(final Collection value) {\r\n        Collection<T> collection = createCollection(value.size());\r\n        for (Object v : value) {\r\n            collection.add(convertType(v));\r\n        }\r\n        return collection;\r\n    }"}, {"ID": 1226, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"AutoBoxing\") protected Collection<T> convertPrimitiveArrayToCollection(final Object value, final Class primitiveComponentType) { Collection<T> result = null; if (primitiveComponentType == int.class) { int[] array = (int[]) value; result = createCollection(array.length); for (int a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == long.class) { long[] array = (long[]) value; result = createCollection(array.length); for (long a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == float.class) { float[] array = (float[]) value; result = createCollection(array.length); for (float a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == double.class) { double[] array = (double[]) value; result = createCollection(array.length); for (double a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == short.class) { short[] array = (short[]) value; result = createCollection(array.length); for (short a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == byte.class) { byte[] array = (byte[]) value; result = createCollection(array.length); for (byte a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == char.class) { char[] array = (char[]) value; result = createCollection(array.length); for (char a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == boolean.class) { boolean[] array = (boolean[]) value; result = createCollection(array.length); for (boolean a : array) { result.add(convertType(a)); } } return result; }\n\n    ### Response:", "ground_truth": "Converts primitive array to target collection.", "predict": "/**\r\n     * Converts a primitive array to a collection of the specified type.\r\n     * \r\n     * @param value\r\n     *            the primitive array to convert\r\n     * @param primitiveComponentType\r\n     *            the primitive component type of the array\r\n     * @return a collection of the specified type containing the elements of the primitive array\r\n     */\r\n    protected Collection<T> convertPrimitiveArrayToCollection(final Object value, final Class primitiveComponentType) {\r\n        Collection<T> result = null;\r\n        if (primitiveComponentType == int.class) {\r\n            int[] array = (int[]) value;\r\n            result = createCollection(array.length);\r\n            for (int a : array) {\r\n                result.add(convertType(a));\r\n            }\r\n        } else if (primitiveComponentType == long.class) {\r\n            long[] array = (long[]) value;\r\n            result = createCollection(array.length);\r\n            for (long a : array) {\r\n                result.add(convertType(a));\r\n            }\r\n        } else if (primitiveComponentType == float.class) {\r\n           "}, {"ID": 1227, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void addLineNumber(final int lineNumber) { if (this.lineNumber == 0) { this.lineNumber = (short) lineNumber; } else { if (otherLineNumbers == null) { otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]; } int otherLineNumberIndex = ++otherLineNumbers[0]; if (otherLineNumberIndex >= otherLineNumbers.length) { int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]; System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length); otherLineNumbers = newLineNumbers; } otherLineNumbers[otherLineNumberIndex] = lineNumber; } }\n\n    ### Response:", "ground_truth": "Adds a source line number corresponding to this label.\n\n@param lineNumber a source line number (which should be strictly positive).", "predict": "/**\r\n     * Adds a line number to the list of line numbers associated with this method.\r\n     * \r\n     * @param lineNumber the line number to add\r\n     */\r\n    final void addLineNumber(final int lineNumber) {\r\n        if (this.lineNumber == 0) {\r\n            this.lineNumber = (short) lineNumber;\r\n        } else {\r\n            if (otherLineNumbers == null) {\r\n                otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];\r\n            }\r\n            int otherLineNumberIndex = ++otherLineNumbers[0];\r\n            if (otherLineNumberIndex >= otherLineNumbers.length) {\r\n                int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];\r\n                System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);\r\n                otherLineNumbers = newLineNumbers;\r\n            }\r\n            otherLineNumbers[otherLineNumberIndex] = lineNumber;\r\n        }\r\n    }"}, {"ID": 1228, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) { methodVisitor.visitLabel(this); if (visitLineNumbers && lineNumber != 0) { methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this); if (otherLineNumbers != null) { for (int i = 1; i <= otherLineNumbers[0]; ++i) { methodVisitor.visitLineNumber(otherLineNumbers[i], this); } } } }\n\n    ### Response:", "ground_truth": "Makes the given visitor visit this label and its source line numbers, if applicable.\n\n@param methodVisitor a method visitor.\n@param visitLineNumbers whether to visit of the label's source line numbers, if any.", "predict": "/**\n     * Visits the current label.\n     *\n     * @param methodVisitor the method visitor to which this label must be added\n     * @param visitLineNumbers true if line number information must be visited, false otherwise\n     */\n    final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {\n        methodVisitor.visitLabel(this);\n        if (visitLineNumbers && lineNumber != 0) {\n            methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this);\n            if (otherLineNumbers != null) {\n                for (int i = 1; i <= otherLineNumbers[0]; ++i) {\n                    methodVisitor.visitLineNumber(otherLineNumbers[i], this);\n                }\n            }\n        }\n    }"}, {"ID": 1229, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void put( final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) { if ((flags & FLAG_RESOLVED) == 0) { if (wideReference) { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length); code.putInt(-1); } else { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length); code.putShort(-1); } } else { if (wideReference) { code.putInt(bytecodeOffset - sourceInsnBytecodeOffset); } else { code.putShort(bytecodeOffset - sourceInsnBytecodeOffset); } } }\n\n    ### Response:", "ground_truth": "Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\nis known, the relative bytecode offset between the label and the instruction referencing it is\ncomputed and written directly. Otherwise, a null relative offset is written and a new forward\nreference is declared for this label.\n\n@param code the bytecode of the method. This is where the reference is appended.\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference to be appended.\n@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).", "predict": "/**\n     * Adds a forward reference to the bytecode of the current method.\n     * \n     * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that is referencing the forward reference\n     * @param referenceType the type of the forward reference (short or wide)\n     * @param bytecodeLength the length of the bytecode of the current method\n     */\n    private void addForwardReference(final int sourceInsnBytecodeOffset, final int referenceType, final int bytecodeLength) {\n        forwardReferences.add(new ForwardReference(sourceInsnBytecodeOffset, referenceType, bytecodeLength));\n    }"}, {"ID": 1230, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addForwardReference( final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) { if (forwardReferences == null) { forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]; } int lastElementIndex = forwardReferences[0]; if (lastElementIndex + 2 >= forwardReferences.length) { int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]; System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length); forwardReferences = newValues; } forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset; forwardReferences[++lastElementIndex] = referenceType | referenceHandle; forwardReferences[0] = lastElementIndex; }\n\n    ### Response:", "ground_truth": "Adds a forward reference to this label. This method must be called only for a true forward\nreference, i.e. only if this label is not resolved yet. For backward references, the relative\nbytecode offset of the reference can be, and must be, computed and stored directly.\n\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference stored at referenceHandle.\n@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n#FORWARD_REFERENCE_TYPE_WIDE}.\n@param referenceHandle the offset in the bytecode where the forward reference value must be\nstored.", "predict": "/**\r\n     * Adds a forward reference to the list of references.\r\n     * \r\n     * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that is referencing the forward reference\r\n     * @param referenceType the type of the forward reference (e.g. CONSTANT_Methodref, CONSTANT_Fieldref, etc.)\r\n     * @param referenceHandle the handle of the forward reference (e.g. the index of the CONSTANT_Methodref in the constant pool)\r\n     */\r\n    private void addForwardReference(final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {\r\n        if (forwardReferences == null) {\r\n            forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n        }\r\n        int lastElementIndex = forwardReferences[0];\r\n        if (lastElementIndex + 2 >= forwardReferences.length) {\r\n            int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];\r\n            System.arraycopy(forwardReferences, 0, newValues"}, {"ID": 1231, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final boolean resolve(final byte[] code, final int bytecodeOffset) { this.flags |= FLAG_RESOLVED; this.bytecodeOffset = bytecodeOffset; if (forwardReferences == null) { return false; } boolean hasAsmInstructions = false; for (int i = forwardReferences[0]; i > 0; i -= 2) { final int sourceInsnBytecodeOffset = forwardReferences[i - 1]; final int reference = forwardReferences[i]; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK; if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) { if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to // 65535, which is sufficient since the size of a method is limited to 65535 bytes). int opcode = code[sourceInsnBytecodeOffset] & 0xFF; if (opcode < Opcodes.IFNULL) { // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA); } else { // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA); } hasAsmInstructions = true; } code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } else { code[handle++] = (byte) (relativeOffset >>> 24); code[handle++] = (byte) (relativeOffset >>> 16); code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } } return hasAsmInstructions; }\n\n    ### Response:", "ground_truth": "Sets the bytecode offset of this label to the given value and resolves the forward references\nto this label, if any. This method must be called when this label is added to the bytecode of\nthe method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\nwhere left in the bytecode by each forward reference previously added to this label.\n\n@param code the bytecode of the method.\n@param bytecodeOffset the bytecode offset of this label.\n@return {@literal true} if a blank that was left for this label was too small to store the\noffset. In such a case the corresponding jump instruction is replaced with an equivalent\nASM specific instruction using an unsigned two bytes offset. These ASM specific\ninstructions are later replaced with standard bytecode instructions with wider offsets (4\nbytes instead of 2), in ClassReader.", "predict": "/**\n     * Resolves the forward references of the given code array, starting at the given bytecode offset.\n     *\n     * @param code the bytecode array to resolve\n     * @param bytecodeOffset the bytecode offset at which to start resolving\n     * @return true if the code array contains any ASM specific instructions, false otherwise\n     */\n    public boolean resolve(final byte[] code, final int bytecodeOffset) {\n        this.flags |= FLAG_RESOLVED;\n        this.bytecodeOffset = bytecodeOffset;\n        if (forwardReferences == null) {\n            return false;\n        }\n        boolean hasAsmInstructions = false;\n        for (int i = forwardReferences[0]; i > 0; i -= 2) {\n            final int sourceInsnBytecodeOffset = forwardReferences[i - 1];\n            final int reference = forwardReferences[i];\n            final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;\n            int handle = reference & FORWARD_REFERENCE_HANDLE_MASK;\n            if ((reference & FORWARD_REFERENCE_TYPE"}, {"ID": 1232, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void markSubroutine(final short subroutineId) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = listOfBlocksToProcess.nextListElement; basicBlock.nextListElement = null; // If it is not already marked as belonging to a subroutine, mark it as belonging to // subroutineId and add its successors to the list of blocks to process (unless already done). if (basicBlock.subroutineId == 0) { basicBlock.subroutineId = subroutineId; listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } } }\n\n    ### Response:", "ground_truth": "Finds the basic blocks that belong to the subroutine starting with the basic block\ncorresponding to this label, and marks these blocks as belonging to this subroutine. This\nmethod follows the control flow graph to find all the blocks that are reachable from the\ncurrent basic block WITHOUT following any jsr target.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineId the id of the subroutine starting with the basic block corresponding to\nthis label.", "predict": "/**\r\n * This method marks all basic blocks belonging to a subroutine with the given subroutineId.\r\n * \r\n * @param subroutineId the id of the subroutine to mark all basic blocks belonging to\r\n */\r\nfinal void markSubroutine(final short subroutineId) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = listOfBlocksToProcess.nextListElement; basicBlock.nextListElement = null; // If"}, {"ID": 1233, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void addSubroutineRetSuccessors(final Label subroutineCaller) { // Data flow algorithm: put this basic block in a list blocks to process (which are blocks // belonging to a subroutine starting with this label) and, while there are blocks to process, // remove one from the list, put it in a list of blocks that have been processed, add a return // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks // in the control flow graph to the list of blocks to process (if not already done). Label listOfProcessedBlocks = EMPTY_LIST; Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Move a basic block from the list of blocks to process to the list of processed blocks. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = basicBlock.nextListElement; basicBlock.nextListElement = listOfProcessedBlocks; listOfProcessedBlocks = basicBlock; // Add an edge from this block to the successor of the caller basic block, if this block is // the end of a subroutine and if this block and subroutineCaller do not belong to the same // subroutine. if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) { basicBlock.outgoingEdges = new Edge( basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr // instruction leads to the jsr continuation block, i.e. where execution continues // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}). subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges); } // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does // not push basic blocks which are already in a list. Here this means either in the list of // blocks to process, or in the list of already processed blocks. This second list is // important to make sure we don't reprocess an already processed block. listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null, // so that this method can be called again with a different subroutine or subroutine caller. while (listOfProcessedBlocks != EMPTY_LIST) { Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement; listOfProcessedBlocks.nextListElement = null; listOfProcessedBlocks = newListOfProcessedBlocks; } }\n\n    ### Response:", "ground_truth": "Finds the basic blocks that end a subroutine starting with the basic block corresponding to\nthis label and, for each one of them, adds an outgoing edge to the basic block following the\ngiven subroutine call. In other words, completes the control flow graph by adding the edges\ncorresponding to the return from this subroutine, when called from the given caller basic\nblock.\n\nNote: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\nthis label. This label is supposed to correspond to the start of a subroutine.", "predict": "/**\r\n     * Adds the successors of a basic block to the list of blocks to process, and adds a return edge to the successor of the subroutine caller if applicable.\r\n     * \r\n     * @param subroutineCaller the label of the subroutine caller basic block.\r\n     */\r\n    final void addSubroutineRetSuccessors(final Label subroutineCaller) {\r\n        // Data flow algorithm: put this basic block in a list blocks to process (which are blocks\r\n        // belonging to a subroutine starting with this label) and, while there are blocks to process,\r\n        // remove one from the list, put it in a list of blocks that have been processed, add a return\r\n        // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks\r\n        // in the control flow graph to the list of blocks to process (if not already done).\r\n        Label listOfProcessedBlocks = Label.EMPTY_LIST;\r\n        Label listOfBlocksToProcess = this;\r\n        listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;\r\n        while (listOfBlocks"}, {"ID": 1234, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int[] compareDigits(final String str1, int ndx1, final String str2, int ndx2) { // iterate all digits in the first string int zeroCount1 = 0; while (charAt(str1, ndx1) == '0') { zeroCount1++; ndx1++; } int len1 = 0; while (true) { final char char1 = charAt(str1, ndx1); final boolean isDigitChar1 = CharUtil.isDigit(char1); if (!isDigitChar1) { break; } len1++; ndx1++; } // iterate all digits in the second string and compare with the first int zeroCount2 = 0; while (charAt(str2, ndx2) == '0') { zeroCount2++; ndx2++; } int len2 = 0; int ndx1_new = ndx1 - len1; int equalNumbers = 0; while (true) { final char char2 = charAt(str2, ndx2); final boolean isDigitChar2 = CharUtil.isDigit(char2); if (!isDigitChar2) { break; } if (equalNumbers == 0 && (ndx1_new < ndx1)) { equalNumbers = charAt(str1, ndx1_new++) - char2; } len2++; ndx2++; } // compare if (len1 != len2) { // numbers are not equals size return new int[] {len1 - len2}; } if (equalNumbers != 0) { return new int[] {equalNumbers}; } // numbers are equal, but number of zeros is different return new int[] {0, zeroCount1 - zeroCount2, ndx1, ndx2}; }\n\n    ### Response:", "ground_truth": "Compare digits at certain position in two strings.\nThe longest run of digits wins. That aside, the greatest\nvalue wins.\n@return if numbers are different, only 1 element is returned.", "predict": "/**\n     * This method compares two strings of digits and returns an array of integers.\n     * The first integer in the array is the difference in length between the two strings.\n     * If the strings are equal, the second integer in the array is the difference in number of zeros between the two strings.\n     * If the strings are equal and have the same number of zeros, the third integer in the array is the index of the first non-zero digit in the first string.\n     * The fourth integer in the array is the index of the first non-zero digit in the second string.\n     * If the strings are not equal and have the same number of zeros, the method returns an empty array.\n     * @param str1 the first string of digits\n     * @param ndx1 the starting index of the first string\n     * @param str2 the second string of digits\n     * @param ndx2 the starting index of the second string\n     * @return an array of integers\n     */\n    protected int[] compareDigits(final String str1,"}, {"ID": 1235, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private char fixAccent(final char c) { for (int i = 0; i < ACCENT_CHARS.length; i+=2) { final char accentChar = ACCENT_CHARS[i]; if (accentChar == c) { return ACCENT_CHARS[i + 1]; } } return c; }\n\n    ### Response:", "ground_truth": "Fixes accent char.", "predict": "/**\r\n     * This method takes a character as input and replaces any accented character with its non-accented equivalent.\r\n     * \r\n     * @param c the character to be fixed\r\n     * @return the fixed character\r\n     */\r\n    private char fixAccent(final char c) {\r\n        for (int i = 0; i < ACCENT_CHARS.length; i+=2) {\r\n            final char accentChar = ACCENT_CHARS[i];\r\n            if (accentChar == c) {\r\n                return ACCENT_CHARS[i + 1];\r\n            }\r\n        }\r\n        return c;\r\n    }"}, {"ID": 1236, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putByte(final int byteValue) { int currentLength = length; if (currentLength + 1 > data.length) { enlarge(1); } data[currentLength++] = (byte) byteValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue a byte.\n@return this byte vector.", "predict": "/**\r\n     * Adds a byte value to the end of the vector.\r\n     * \r\n     * @param byteValue the byte value to add\r\n     * @return the updated vector\r\n     */\r\n    public ByteVector putByte(final int byteValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 1 > data.length) {\r\n            enlarge(1);\r\n        }\r\n        data[currentLength++] = (byte) byteValue;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1237, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put11(final int byteValue1, final int byteValue2) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@return this byte vector.", "predict": "/**\r\n     * Adds two bytes to the end of the vector.\r\n     * \r\n     * @param byteValue1 the first byte value to add\r\n     * @param byteValue2 the second byte value to add\r\n     * @return the updated vector\r\n     */\r\n    public final ByteVector put11(final int byteValue1, final int byteValue2) {\r\n        int currentLength = length;\r\n        if (currentLength + 2 > data.length) {\r\n            enlarge(2);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) byteValue1;\r\n        currentData[currentLength++] = (byte) byteValue2;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1238, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putShort(final int shortValue) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param shortValue a short.\n@return this byte vector.", "predict": "/**\r\n     * Puts a short value into the byte vector.\r\n     * \r\n     * @param shortValue the short value to be put\r\n     * @return the updated byte vector\r\n     */\r\n    public ByteVector putShort(final int shortValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 2 > data.length) {\r\n            enlarge(2);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n        currentData[currentLength++] = (byte) shortValue;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1239, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put12(final int byteValue, final int shortValue) { int currentLength = length; if (currentLength + 3 > data.length) { enlarge(3); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue a byte.\n@param shortValue a short.\n@return this byte vector.", "predict": "/**\r\n     * Adds the specified byte and short values to the end of this vector.\r\n     * \r\n     * @param byteValue the byte value to be added\r\n     * @param shortValue the short value to be added\r\n     * @return this vector\r\n     */\r\n    public final ByteVector put12(final int byteValue, final int shortValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 3 > data.length) {\r\n            enlarge(3);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) byteValue;\r\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n        currentData[currentLength++] = (byte) shortValue;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1240, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@param shortValue a short.\n@return this byte vector.", "predict": "/**\r\n     * Adds the specified byte values and short value to the end of this vector.\r\n     * \r\n     * @param byteValue1 the first byte value to add\r\n     * @param byteValue2 the second byte value to add\r\n     * @param shortValue the short value to add\r\n     * @return this vector\r\n     */\r\n    public final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 4 > data.length) {\r\n            enlarge(4);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) byteValue1;\r\n        currentData[currentLength++] = (byte) byteValue2;\r\n        currentData[currentLength++] = (byte) (shortValue >>> 8);\r\n        currentData[currentLength++] = (byte) shortValue;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1241, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putInt(final int intValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param intValue an int.\n@return this byte vector.", "predict": "/**\r\n     * Puts an integer value into the byte vector.\r\n     *\r\n     * @param intValue the integer value to be put into the byte vector.\r\n     * @return the updated byte vector.\r\n     */\r\n    public ByteVector putInt(final int intValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 4 > data.length) {\r\n            enlarge(4);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) (intValue >>> 24);\r\n        currentData[currentLength++] = (byte) (intValue >>> 16);\r\n        currentData[currentLength++] = (byte) (intValue >>> 8);\r\n        currentData[currentLength++] = (byte) intValue;\r\n        length = currentLength;\r\n        return this;\r\n    }"}, {"ID": 1242, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) { int currentLength = length; if (currentLength + 5 > data.length) { enlarge(5); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue1 >>> 8); currentData[currentLength++] = (byte) shortValue1; currentData[currentLength++] = (byte) (shortValue2 >>> 8); currentData[currentLength++] = (byte) shortValue2; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\nif necessary.\n\n@param byteValue a byte.\n@param shortValue1 a short.\n@param shortValue2 another short.\n@return this byte vector.", "predict": "/**\r\n     * Adds the specified byte value, two short values, and their corresponding bytes to the end of this vector.\r\n     * \r\n     * @param byteValue the byte value to be added\r\n     * @param shortValue1 the first short value to be added\r\n     * @param shortValue2 the second short value to be added\r\n     * @return this vector\r\n     */\r\n    public final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) {\r\n        int currentLength = length;\r\n        if (currentLength + 5 > data.length) {\r\n            enlarge(5);\r\n        }\r\n        byte[] currentData = data;\r\n        currentData[currentLength++] = (byte) byteValue;\r\n        currentData[currentLength++] = (byte) (shortValue1 >>> 8);\r\n        currentData[currentLength++] = (byte) shortValue1;\r\n        currentData[currentLength++] = (byte) (shortValue2 >>> 8);\r\n        currentData[currentLength++] = (byte) shortValue"}, {"ID": 1243, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putLong(final long longValue) { int currentLength = length; if (currentLength + 8 > data.length) { enlarge(8); } byte[] currentData = data; int intValue = (int) (longValue >>> 32); currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; intValue = (int) longValue; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; }\n\n    ### Response:", "ground_truth": "Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param longValue a long.\n@return this byte vector.", "predict": "/**\r\n     * Writes a 64-bit long value to the byte vector.\r\n     *\r\n     * @param longValue the long value to write\r\n     * @return the updated byte vector\r\n     */\r\n    public ByteVector putLong(final long longValue) {\r\n        int currentLength = length;\r\n        if (currentLength + 8 > data.length) {\r\n            enlarge(8);\r\n        }\r\n        byte[] currentData = data;\r\n        int intValue = (int) (longValue >>> 32);\r\n        currentData[currentLength++] = (byte) (intValue >>> 24);\r\n        currentData[currentLength++] = (byte) (intValue >>> 16);\r\n        currentData[currentLength++] = (byte) (intValue >>> 8);\r\n        currentData[currentLength++] = (byte) intValue;\r\n        intValue = (int) longValue;\r\n        currentData[currentLength++] = (byte) (intValue >>> 24);\r\n        currentData[currentLength++] = (byte) (intValue >>> 1"}, {"ID": 1244, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; }\n\n    ### Response:", "ground_truth": "Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\nbytes into this byte vector.\n@param byteOffset index of the first byte of byteArrayValue that must be copied.\n@param byteLength number of bytes of byteArrayValue that must be copied.\n@return this byte vector.", "predict": "/**\r\n     * Puts a byte array into the byte vector.\r\n     * \r\n     * @param byteArrayValue the byte array to be put\r\n     * @param byteOffset the starting offset in the byte array\r\n     * @param byteLength the number of bytes to be put\r\n     * @return the updated byte vector\r\n     */\r\n    public ByteVector putByteArray(final byte[] byteArrayValue, final int byteOffset, final int byteLength) {\r\n        if (length + byteLength > data.length) {\r\n            enlarge(byteLength);\r\n        }\r\n        if (byteArrayValue != null) {\r\n            System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength);\r\n        }\r\n        length += byteLength;\r\n        return this;\r\n    }"}, {"ID": 1245, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void enlarge(final int size) { int doubleCapacity = 2 * data.length; int minimalCapacity = length + size; byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity]; System.arraycopy(data, 0, newData, 0, length); data = newData; }\n\n    ### Response:", "ground_truth": "Enlarges this byte vector so that it can receive 'size' more bytes.\n\n@param size number of additional bytes that this byte vector should be able to receive.", "predict": "/**\r\n     * This method enlarges the byte array by the given size.\r\n     * \r\n     * @param size the size to enlarge the array by\r\n     */\r\n    private void enlarge(final int size) {\r\n        int doubleCapacity = 2 * data.length;\r\n        int minimalCapacity = length + size;\r\n        byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity];\r\n        System.arraycopy(data, 0, newData, 0, length);\r\n        data = newData;\r\n    }"}, {"ID": 1246, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaHttpSession(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final UserSession<T> userSession = UserSession.get(servletRequest); if (userSession == null) { return null; } final T authToken = userSession.getAuthToken(); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); if (newAuthToken != authToken) { final UserSession<T> newUserSesion = new UserSession<>(newAuthToken, userAuth().tokenValue(newAuthToken)); newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse()); } return newAuthToken; }\n\n    ### Response:", "ground_truth": "Tries to authenticate user via HTTP session. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": "/**\r\n     * Authenticates the user via HTTP session.\r\n     * \r\n     * @param actionRequest\r\n     *            the action request\r\n     * @return the authenticated user token\r\n     */\r\n    protected T authenticateUserViaHttpSession(final ActionRequest actionRequest) {\r\n        final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n        final UserSession<T> userSession = UserSession.get(servletRequest);\r\n        if (userSession == null) {\r\n            return null;\r\n        }\r\n        final T authToken = userSession.getAuthToken();\r\n        if (authToken == null) {\r\n            return null;\r\n        }\r\n        // granted\r\n        final T newAuthToken = userAuth().rotateToken(authToken);\r\n        if (newAuthToken != authToken) {\r\n            final UserSession<T> newUserSesion = new UserSession<>(newAuthToken, userAuth().tokenValue(newAuthToken));\r\n            newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse());\r\n        }\r\n        return newAuthToken;\r\n    }"}, {"ID": 1247, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaToken(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); // then try the auth token final String token = ServletUtil.resolveAuthBearerToken(servletRequest); if (token == null) { return null; } final T authToken = userAuth().validateToken(token); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken)); return newAuthToken; }\n\n    ### Response:", "ground_truth": "Tries to authenticate user via token. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": "/**\r\n     * Authenticates the user via token and returns a new token with a new expiration time.\r\n     *\r\n     * @param actionRequest the action request\r\n     * @return the authenticated token\r\n     */\r\n    protected T authenticateUserViaToken(final ActionRequest actionRequest) {\r\n        final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); // then try the auth token\r\n        final String token = ServletUtil.resolveAuthBearerToken(servletRequest);\r\n        if (token == null) {\r\n            return null;\r\n        }\r\n        final T authToken = userAuth().validateToken(token);\r\n        if (authToken == null) {\r\n            return null;\r\n        }\r\n        // granted\r\n        final T newAuthToken = userAuth().rotateToken(authToken);\r\n        actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken));\r\n        return newAuthToken;\r\n    }"}, {"ID": 1248, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T authenticateUserViaBasicAuth(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); final T authToken = userAuth().login(username, password); if (authToken == null) { return null; } return authToken; }\n\n    ### Response:", "ground_truth": "Tires to authenticate user via the basic authentication. Returns the token if user is authenticated.", "predict": "/**\r\n     * Authenticates the user via basic authentication and returns the authentication token.\r\n     *\r\n     * @param actionRequest the action request\r\n     * @return the authentication token\r\n     */\r\n    protected T authenticateUserViaBasicAuth(final ActionRequest actionRequest) {\r\n        final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n        final String username = ServletUtil.resolveAuthUsername(servletRequest);\r\n        if (username == null) {\r\n            return null;\r\n        }\r\n        final String password = ServletUtil.resolveAuthPassword(servletRequest);\r\n        final T authToken = userAuth().login(username, password);\r\n        if (authToken == null) {\r\n            return null;\r\n        }\r\n        return authToken;\r\n    }"}, {"ID": 1249, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String findDefaultMessage(final Locale locale, final String key) { String indexedKey = calcIndexKey(key); String msg = getMessage(fallbackBundlename, locale, key, indexedKey); if (msg != null) { return msg; } for (String bname : defaultBundles) { msg = getMessage(bname, locale, key, indexedKey); if (msg != null) { return msg; } } return null; }\n\n    ### Response:", "ground_truth": "Finds message in default bundles only, starting from fallback bundlename.", "predict": "/**\r\n     * This method is used to find the default message for a given key in the fallback bundle.\r\n     * If the message is not found in the fallback bundle, it will search for the message in the default bundles.\r\n     * If the message is not found in any of the default bundles, it will return null.\r\n     * \r\n     * @param locale The locale for which the message is required.\r\n     * @param key The key for which the message is required.\r\n     * @return The default message for the given key.\r\n     */\r\n    public String findDefaultMessage(final Locale locale, final String key) {\r\n        // Implementation of the method goes here.\r\n    }"}, {"ID": 1250, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ResourceBundle getBundle(final String bundleName, final Locale locale, final ClassLoader classLoader) { return ResourceBundle.getBundle(bundleName, locale, classLoader); }\n\n    ### Response:", "ground_truth": "Returns specified bundle. Invoked every time if cache is disabled.\nInput arguments are always valid.", "predict": "/**\r\n     * Returns a resource bundle using the specified bundle name, locale, and class loader.\r\n     *\r\n     * @param bundleName the base name of the resource bundle, a fully qualified class name\r\n     * @param locale the locale of the resource bundle\r\n     * @param classLoader the class loader to be used to load the resource bundle\r\n     * @return the resource bundle\r\n     */\r\n    protected ResourceBundle getBundle(final String bundleName, final Locale locale, final ClassLoader classLoader) {\r\n        return ResourceBundle.getBundle(bundleName, locale, classLoader);\r\n    }"}, {"ID": 1251, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected K get(final K[] array, final int index) { return (K) Array.get(array, index); }\n\n    ### Response:", "ground_truth": "Returns array's element at given index.", "predict": "/**\r\n     * Retrieves the element at the specified position in the specified array.\r\n     *\r\n     * @param array the array in which to search for the element\r\n     * @param index the index of the element to retrieve\r\n     * @return the element at the specified position in the specified array\r\n     */\r\n    protected K get(final K[] array, final int index) { return (K) Array.get(array, index); }"}, {"ID": 1252, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <E, ID> void setEntityId(final DbEntityDescriptor<E> ded, final E entity, final ID newIdValue) { ded.setIdValue(entity, newIdValue); }\n\n    ### Response:", "ground_truth": "Sets new ID value for entity.", "predict": "/**\r\n     * Sets the entity ID value for the given entity using the ID value provided.\r\n     * \r\n     * @param ded the entity descriptor for the entity type\r\n     * @param entity the entity whose ID value is to be set\r\n     * @param newIdValue the new ID value to set for the entity\r\n     */\r\n    protected <E, ID> void setEntityId(final DbEntityDescriptor<E> ded, final E entity, final ID newIdValue) { ded.setIdValue(entity, newIdValue); }"}, {"ID": 1253, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void save(final Object entity) { final DbQuery q = query(dbOom.entities().insert(entity)); q.autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Simply inserts object into the database.", "predict": "/**\r\n     * Saves the given entity to the database.\r\n     * \r\n     * @param entity the entity to save\r\n     */\r\n    public void save(final Object entity) {\r\n        final DbQuery q = query(dbOom.entities().insert(entity));\r\n        q.autoClose().executeUpdate();\r\n    }"}, {"ID": 1254, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void update(final Object entity) { query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Updates single entity.", "predict": "/**\r\n     * Updates the given entity in the database.\r\n     * \r\n     * @param entity the entity to update\r\n     */\r\n    public void update(final Object entity) {\r\n        query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate();\r\n    }"}, {"ID": 1255, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E updateProperty(final E entity, final String name, final Object newValue) { query(dbOom.entities().updateColumn(entity, name, newValue)).autoClose().executeUpdate(); BeanUtil.declared.setProperty(entity, name, newValue); return entity; }\n\n    ### Response:", "ground_truth": "Updates single property in database and in the bean.", "predict": "/**\r\n     * Updates the value of a property of an entity.\r\n     * \r\n     * @param entity\r\n     *            the entity to update\r\n     * @param name\r\n     *            the name of the property to update\r\n     * @param newValue\r\n     *            the new value of the property\r\n     * @return the updated entity\r\n     */\r\n    public <E> E updateProperty(final E entity, final String name, final Object newValue) {\r\n        // TODO: Implement method\r\n        return entity;\r\n    }"}, {"ID": 1256, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E updateProperty(final E entity, final String name) { Object value = BeanUtil.declared.getProperty(entity, name); query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate(); return entity; }\n\n    ### Response:", "ground_truth": "Updates property in the database by storing the current property value.", "predict": "/**\r\n     * Updates the value of a property of an entity.\r\n     * \r\n     * @param entity the entity to update\r\n     * @param name the name of the property to update\r\n     * @return the updated entity\r\n     */\r\n    public <E> E updateProperty(final E entity, final String name) {\r\n        Object value = BeanUtil.declared.getProperty(entity, name);\r\n        query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate();\r\n        return entity;\r\n    }"}, {"ID": 1257, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E, ID> E findById(final Class<E> entityType, final ID id) { return query(dbOom.entities().findById(entityType, id)).autoClose().find(entityType); }\n\n    ### Response:", "ground_truth": "Finds single entity by its id.", "predict": "/**\r\n     * Finds an entity by its ID.\r\n     * \r\n     * @param entityType the type of entity to find\r\n     * @param id the ID of the entity to find\r\n     * @return the entity found, or null if not found\r\n     */\r\n    public <E, ID> E findById(final Class<E> entityType, final ID id) {\r\n        return query(dbOom.entities().findById(entityType, id)).autoClose().find(entityType);\r\n    }"}, {"ID": 1258, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) { return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType); }\n\n    ### Response:", "ground_truth": "Finds single entity by matching property.", "predict": "/**\r\n     * Finds a single entity of the specified type with the given property name and value.\r\n     *\r\n     * @param entityType the type of entity to find\r\n     * @param name the name of the property to search for\r\n     * @param value the value of the property to search for\r\n     * @return the entity found, or null if no entity was found\r\n     */\r\n    public <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) {\r\n        return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType);\r\n    }"}, {"ID": 1259, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public <E> E findOne(final Object criteria) { return (E) query(dbOom.entities().find(criteria)).autoClose().find(criteria.getClass()); }\n\n    ### Response:", "ground_truth": "Finds one entity for given criteria.", "predict": "/**\r\n     * Finds a single entity based on the given criteria.\r\n     * \r\n     * @param criteria the criteria to use to find the entity\r\n     * @return the entity found, or null if no entity was found\r\n     * @throws IllegalArgumentException if the criteria is null or empty\r\n     */\r\n    public <E> E findOne(final Object criteria) {\r\n        if (criteria == null || criteria.toString().isEmpty()) {\r\n            throw new IllegalArgumentException(\"Criteria cannot be null or empty.\");\r\n        }\r\n        return (E) query(dbOom.entities().find(criteria)).autoClose().find(criteria.getClass());\r\n    }"}, {"ID": 1260, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void deleteById(final Class entityType, final ID id) { query(dbOom.entities().deleteById(entityType, id)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Deleted single entity by its id.", "predict": "/**\r\n     * Deletes an entity of the specified type with the given ID.\r\n     * \r\n     * @param entityType the type of entity to delete\r\n     * @param id the ID of the entity to delete\r\n     */\r\n    public <ID> void deleteById(final Class entityType, final ID id) {\r\n        query(dbOom.entities().deleteById(entityType, id)).autoClose().executeUpdate();\r\n    }"}, {"ID": 1261, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void deleteById(final Object entity) { if (entity != null) { int result = query(dbOom.entities().deleteById(entity)).autoClose().executeUpdate(); if (result != 0) { // now reset the ID value Class type = entity.getClass(); DbEntityDescriptor ded = dbOom.entityManager().lookupType(type); setEntityId(ded, entity, 0); } } }\n\n    ### Response:", "ground_truth": "Delete single object by its id. Resets ID value.", "predict": "/**\r\n     * Deletes the entity with the given ID from the database.\r\n     * \r\n     * @param entity the entity to delete\r\n     */\r\n    public void deleteById(final Object entity) {\r\n        if (entity != null) {\r\n            int result = query(dbOom.entities().deleteById(entity)).autoClose().executeUpdate();\r\n            if (result != 0) {\r\n                // now reset the ID value\r\n                Class type = entity.getClass();\r\n                DbEntityDescriptor ded = dbOom.entityManager().lookupType(type);\r\n                setEntityId(ded, entity, 0);\r\n            }\r\n        }\r\n    }"}, {"ID": 1262, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long count(final Class entityType) { return query(dbOom.entities().count(entityType)).autoClose().executeCount(); }\n\n    ### Response:", "ground_truth": "Counts number of all entities.", "predict": "/**\r\n     * Counts the number of entities of the specified type in the database.\r\n     * \r\n     * @param entityType the type of entity to count\r\n     * @return the number of entities of the specified type in the database\r\n     */\r\n    public long count(final Class entityType) {\r\n        return query(dbOom.entities().count(entityType)).autoClose().executeCount();\r\n    }"}, {"ID": 1263, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void increaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, true)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Increases a property.", "predict": "/**\r\n     * Increases the value of a property in the database for a given entity type and ID.\r\n     * \r\n     * @param entityType the entity type\r\n     * @param id the ID of the entity\r\n     * @param name the name of the property to increase\r\n     * @param delta the amount to increase the property by\r\n     */\r\n    public <ID> void increaseProperty(final Class entityType, final ID id, final String name, final Number delta) {\r\n        query(dbOom.entities().increaseColumn(entityType, id, name, delta, true)).autoClose().executeUpdate();\r\n    }"}, {"ID": 1264, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <ID> void decreaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, false)).autoClose().executeUpdate(); }\n\n    ### Response:", "ground_truth": "Decreases a property.", "predict": "/**\r\n     * Decreases the value of a property in the database.\r\n     * \r\n     * @param entityType The type of entity to update.\r\n     * @param id The id of the entity to update.\r\n     * @param name The name of the property to update.\r\n     * @param delta The amount to decrease the property by.\r\n     */\r\n    public <ID> void decreaseProperty(final Class entityType, final ID id, final String name, final Number delta) {\r\n        query(dbOom.entities().increaseColumn(entityType, id, name, delta, false)).autoClose().executeUpdate();\r\n    }"}, {"ID": 1265, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> List<E> findRelated(final Class<E> target, final Object source) { return query(dbOom.entities().findForeign(target, source)).autoClose().list(target); }\n\n    ### Response:", "ground_truth": "Finds related entity.", "predict": "/**\r\n     * Finds all entities of the specified type related to the given source entity.\r\n     * \r\n     * @param target the type of related entities to find\r\n     * @param source the source entity to find related entities for\r\n     * @return a list of related entities\r\n     */\r\n    public <E> List<E> findRelated(final Class<E> target, final Object source) {\r\n        return query(dbOom.entities().findForeign(target, source)).autoClose().list(target);\r\n    }"}, {"ID": 1266, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <E> List<E> listAll(final Class<E> target) { return query(dbOom.entities().from(target)).autoClose().list(target); }\n\n    ### Response:", "ground_truth": "List all entities.", "predict": "/**\r\n     * This method is used to retrieve all the entities of a given type from the database.\r\n     * \r\n     * @param target The type of entity to retrieve.\r\n     * @return A list of all the entities of the given type.\r\n     */\r\n    public <E> List<E> listAll(final Class<E> target) {\r\n        return query(dbOom.entities().from(target)).autoClose().list(target);\r\n    }"}, {"ID": 1267, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void clear() { entries = null; Iterator<String> keys = getAttributeNames(); while (keys.hasNext()) { removeAttribute(keys.next()); } }\n\n    ### Response:", "ground_truth": "Removes all attributes from the request as well as clears entries in this map.", "predict": "/**\r\n     * Removes all attributes from this session.\r\n     */\r\n    @Override\r\n    public void clear() {\r\n        entries = null;\r\n        Iterator<String> keys = getAttributeNames();\r\n        while (keys.hasNext()) {\r\n            removeAttribute(keys.next());\r\n        }\r\n    }"}, {"ID": 1268, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Set<Entry<String, Object>> entrySet() { if (entries == null) { entries = new HashSet<>(); Iterator<String> iterator = getAttributeNames(); while (iterator.hasNext()) { final String key = iterator.next(); final Object value = getAttribute(key); entries.add(new Entry<String, Object>() { @Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (this.getClass() != obj.getClass()) { return false; } Entry entry = (Entry) obj; return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue())); } @Override public int hashCode() { return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode()); } @Override public String getKey() { return key; } @Override public Object getValue() { return value; } @Override public Object setValue(final Object obj) { setAttribute(key, obj); return value; } }); } } return entries; }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Returns a set view of the attribute entries.\r\n     *\r\n     * @return a set view of the attribute entries\r\n     */\r\n    @Override\r\n    public Set<Entry<String, Object>> entrySet() {\r\n        if (entries == null) {\r\n            entries = new HashSet<>();\r\n            Iterator<String> iterator = getAttributeNames();\r\n            while (iterator.hasNext()) {\r\n                final String key = iterator.next();\r\n                final Object value = getAttribute(key);\r\n                entries.add(new Entry<String, Object>() {\r\n                    @Override\r\n                    public boolean equals(final Object obj) {\r\n                        if (obj == null) {\r\n                            return false;\r\n                        }\r\n                        if (this.getClass() != obj.getClass()) {\r\n                            return false;\r\n                        }\r\n                        Entry entry = (Entry) obj;\r\n                        return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey()))\r\n                                && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue()));\r\n                    }"}, {"ID": 1269, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object put(final String key, final Object value) { entries = null; Object previous = get(key); setAttribute(key, value); return previous; }\n\n    ### Response:", "ground_truth": "Saves an attribute in the request.", "predict": "/**\r\n     * This method overrides the put method of the HashMap class and sets the value of the given key to the given value.\r\n     * It also sets the entries variable to null to indicate that the map has been modified.\r\n     * @param key The key to be added to the map.\r\n     * @param value The value to be associated with the key.\r\n     * @return The previous value associated with the key, or null if there was no mapping for the key.\r\n     */\r\n    @Override public Object put(final String key, final Object value) { entries = null; Object previous = get(key); setAttribute(key, value); return previous; }"}, {"ID": 1270, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Object remove(final Object key) { entries = null; Object value = get(key); removeAttribute(key.toString()); return value; }\n\n    ### Response:", "ground_truth": "Removes the specified request attribute.", "predict": "/**\r\n     * Removes the mapping for a key from this map if it is present.\r\n     *\r\n     * @param key key whose mapping is to be removed from the map\r\n     * @return the previous value associated with key, or null if there was no mapping for key\r\n     */\r\n    @Override\r\n    public Object remove(final Object key) {\r\n        entries = null;\r\n        Object value = get(key);\r\n        removeAttribute(key.toString());\r\n        return value;\r\n    }"}, {"ID": 1271, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"ThrowCaughtLocally\"}) public static StackTraceElement[] getCurrentStackTrace() { StackTraceElement[] ste = new Exception().getStackTrace(); if (ste.length > 1) { StackTraceElement[] result = new StackTraceElement[ste.length - 1]; System.arraycopy(ste, 1, result, 0, ste.length - 1); return result; } else { return ste; } }\n\n    ### Response:", "ground_truth": "Returns current stack trace in form of array of stack trace elements.\nFirst stack trace element is removed.\nSince an exception is thrown internally, this method is slow.", "predict": "/**\r\n     * Returns an array of the current execution stack trace, with the first element being the top of the stack.\r\n     * \r\n     * @return an array of the current execution stack trace, with the first element being the top of the stack.\r\n     */\r\n    public static StackTraceElement[] getCurrentStackTrace() {\r\n        StackTraceElement[] ste = new Exception().getStackTrace();\r\n        if (ste.length > 1) {\r\n            StackTraceElement[] result = new StackTraceElement[ste.length - 1];\r\n            System.arraycopy(ste, 1, result, 0, ste.length - 1);\r\n            return result;\r\n        } else {\r\n            return ste;\r\n        }\r\n    }"}, {"ID": 1272, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) { StackTraceElement[] st = t.getStackTrace(); ArrayList<StackTraceElement> result = new ArrayList<>(st.length); elementLoop: for (StackTraceElement element : st) { String className = element.getClassName(); if (allow != null) { boolean validElemenet = false; for (String filter : allow) { if (className.contains(filter)) { validElemenet = true; break; } } if (!validElemenet) { continue; } } if (deny != null) { for (String filter : deny) { if (className.contains(filter)) { continue elementLoop; } } } result.add(element); } st = new StackTraceElement[result.size()]; return result.toArray(st); }\n\n    ### Response:", "ground_truth": "Returns stack trace filtered by class names.", "predict": "/**\r\n     * Returns a filtered stack trace for the given Throwable object.\r\n     *\r\n     * @param t the Throwable object to get the stack trace from\r\n     * @param allow an array of strings that specify the allowed classes in the stack trace\r\n     * @param deny an array of strings that specify the denied classes in the stack trace\r\n     * @return a filtered stack trace as an array of StackTraceElement objects\r\n     */\r\n    public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) {\r\n        StackTraceElement[] st = t.getStackTrace();\r\n        ArrayList<StackTraceElement> result = new ArrayList<>(st.length);\r\n        elementLoop: for (StackTraceElement element : st) {\r\n            String className = element.getClassName();\r\n            if (allow != null) {\r\n                boolean validElemenet = false;\r\n                for (String filter : allow) {\r\n                    if (className.contains(filter)) {\r\n                        validElemenet = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!validElemenet) {\r\n                   "}, {"ID": 1273, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) { ArrayList<StackTraceElement[]> result = new ArrayList<>(); while (t != null) { StackTraceElement[] stack = getStackTrace(t, allow, deny); result.add(stack); t = t.getCause(); } StackTraceElement[][] allStacks = new StackTraceElement[result.size()][]; for (int i = 0; i < allStacks.length; i++) { allStacks[i] = result.get(i); } return allStacks; }\n\n    ### Response:", "ground_truth": "Returns stack trace chain filtered by class names.", "predict": "/**\r\n     * Returns a chain of stack trace elements for the given Throwable, filtered by the given allow and deny lists.\r\n     *\r\n     * @param t the Throwable to get the stack trace chain for\r\n     * @param allow an array of package names to include in the stack trace chain (null for all packages)\r\n     * @param deny an array of package names to exclude from the stack trace chain (null for no packages)\r\n     * @return an array of stack trace element arrays, where each array represents a stack trace for a Throwable in the chain\r\n     */\r\n    public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) {\r\n        ArrayList<StackTraceElement[]> result = new ArrayList<>();\r\n        while (t != null) {\r\n            StackTraceElement[] stack = getStackTrace(t, allow, deny);\r\n            result.add(stack);\r\n            t = t.getCause();\r\n        }\r\n        StackTraceElement[][] allStacks = new StackTraceElement[result.size()][];\r\n        for (int i ="}, {"ID": 1274, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Throwable[] getExceptionChain(Throwable throwable) { ArrayList<Throwable> list = new ArrayList<>(); list.add(throwable); while ((throwable = throwable.getCause()) != null) { list.add(throwable); } Throwable[] result = new Throwable[list.size()]; return list.toArray(result); }\n\n    ### Response:", "ground_truth": "Returns exception chain starting from top up to root cause.", "predict": "/**\r\n     * Returns an array containing all the exceptions in the exception chain, starting from the specified throwable and going up to the root cause.\r\n     * \r\n     * @param throwable the throwable to start from\r\n     * @return an array of Throwable objects, starting with the specified throwable and going up to the root cause\r\n     */\r\n    public static Throwable[] getExceptionChain(Throwable throwable) {\r\n        ArrayList<Throwable> list = new ArrayList<>();\r\n        list.add(throwable);\r\n        while ((throwable = throwable.getCause()) != null) {\r\n            list.add(throwable);\r\n        }\r\n        Throwable[] result = new Throwable[list.size()];\r\n        return list.toArray(result);\r\n    }"}, {"ID": 1275, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String exceptionStackTraceToString(final Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); }\n\n    ### Response:", "ground_truth": "Prints stack trace into a String.", "predict": "/**\r\n     * Converts a Throwable object to a String representation of its stack trace.\r\n     *\r\n     * @param t the Throwable object to convert\r\n     * @return the String representation of the stack trace\r\n     */\r\n    public static String exceptionStackTraceToString(final Throwable t) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw, true);\r\n        t.printStackTrace(pw);\r\n        StreamUtil.close(pw);\r\n        StreamUtil.close(sw);\r\n        return sw.toString();\r\n    }"}, {"ID": 1276, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String exceptionChainToString(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); while (t != null) { t.printStackTrace(pw); t = t.getCause(); } StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); }\n\n    ### Response:", "ground_truth": "Prints full exception stack trace, from top to root cause, into a String.", "predict": "/**\r\n     * Converts a Throwable and its causes into a string.\r\n     * \r\n     * @param t the Throwable to convert\r\n     * @return the string representation of the Throwable and its causes\r\n     */\r\n    public static String exceptionChainToString(Throwable t) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw, true);\r\n        while (t != null) {\r\n            t.printStackTrace(pw);\r\n            t = t.getCause();\r\n        }\r\n        StreamUtil.close(pw);\r\n        StreamUtil.close(sw);\r\n        return sw.toString();\r\n    }"}, {"ID": 1277, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String buildMessage(final String message, Throwable cause) { if (cause != null) { cause = getRootCause(cause); StringBuilder buf = new StringBuilder(); if (message != null) { buf.append(message).append(\"; \"); } buf.append(\"<--- \").append(cause); return buf.toString(); } else { return message; } }\n\n    ### Response:", "ground_truth": "Build a message for the given base message and its cause.", "predict": "/**\r\n     * Builds a message string that includes the original message and the root cause of the exception.\r\n     * \r\n     * @param message the original message\r\n     * @param cause the exception that caused the error\r\n     * @return the message string\r\n     */\r\n    public static String buildMessage(final String message, Throwable cause) {\r\n        if (cause != null) {\r\n            cause = getRootCause(cause);\r\n            StringBuilder buf = new StringBuilder();\r\n            if (message != null) {\r\n                buf.append(message).append(\"; \");\r\n            }\r\n            buf.append(\"<--- \").append(cause);\r\n            return buf.toString();\r\n        } else {\r\n            return message;\r\n        }\r\n    }"}, {"ID": 1278, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Throwable unwrapThrowable(final Throwable wrappedThrowable) { Throwable unwrapped = wrappedThrowable; while (true) { if (unwrapped instanceof InvocationTargetException) { unwrapped = ((InvocationTargetException) unwrapped).getTargetException(); } else if (unwrapped instanceof UndeclaredThrowableException) { unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable(); } else { return unwrapped; } } }\n\n    ### Response:", "ground_truth": "Unwraps invocation and undeclared exceptions to real cause.", "predict": "/**\r\n     * Unwraps the given wrapped throwable by unwrapping it recursively if it is an instance of InvocationTargetException or UndeclaredThrowableException.\r\n     *\r\n     * @param wrappedThrowable the wrapped throwable to be unwrapped\r\n     * @return the unwrapped throwable\r\n     */\r\n    public static Throwable unwrapThrowable(final Throwable wrappedThrowable) {\r\n        Throwable unwrapped = wrappedThrowable;\r\n        while (true) {\r\n            if (unwrapped instanceof InvocationTargetException) {\r\n                unwrapped = ((InvocationTargetException) unwrapped).getTargetException();\r\n            } else if (unwrapped instanceof UndeclaredThrowableException) {\r\n                unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable();\r\n            } else {\r\n                return unwrapped;\r\n            }\r\n        }\r\n    }"}, {"ID": 1279, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void registerAsConsumer(final ClassScanner classScanner) { classScanner.registerEntryConsumer(classPathEntry -> { final String entryName = classPathEntry.name(); if (entryName.endsWith(actionClassSuffix)) { try { acceptActionClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc action, ignoring: \" + entryName); } } else if (classPathEntry.isTypeSignatureInUse(MADVOC_COMPONENT_ANNOTATION)) { try { acceptMadvocComponentClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc component ignoring: {}\" + entryName); } } }); }\n\n    ### Response:", "ground_truth": "Parses class name that matches madvoc-related names.", "predict": "/**\r\n     * Registers this class as a consumer of class entries in the given class scanner.\r\n     *\r\n     * @param classScanner the class scanner to register with\r\n     */\r\n    protected void registerAsConsumer(final ClassScanner classScanner) { }"}, {"ID": 1280, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void acceptMadvocComponentClass(final Class componentClass) { if (componentClass == null) { return; } if (!checkClass(componentClass)) { return; } madvocComponents.add(() -> madvocContainer.registerComponent(componentClass)); }\n\n    ### Response:", "ground_truth": "Registers new Madvoc component.", "predict": "/**\r\n     * Accepts a Madvoc component class and registers it with the Madvoc container.\r\n     *\r\n     * @param componentClass the Madvoc component class to register\r\n     */\r\n    protected void acceptMadvocComponentClass(final Class componentClass) {\r\n        if (componentClass == null) {\r\n            return;\r\n        }\r\n        if (!checkClass(componentClass)) {\r\n            return;\r\n        }\r\n        madvocComponents.add(() -> madvocContainer.registerComponent(componentClass));\r\n    }"}, {"ID": 1281, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClassLoader getSystemClassLoader() { if (System.getSecurityManager() == null) { return ClassLoader.getSystemClassLoader(); } else { return AccessController.doPrivileged( (PrivilegedAction<ClassLoader>) ClassLoader::getSystemClassLoader); } }\n\n    ### Response:", "ground_truth": "Returns system class loader.", "predict": "/**\r\n     * Returns the system class loader for delegation.\r\n     *\r\n     * @return the system class loader\r\n     */\r\n    public static ClassLoader getSystemClassLoader() {\r\n        if (System.getSecurityManager() == null) {\r\n            return ClassLoader.getSystemClassLoader();\r\n        } else {\r\n            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\r\n                public ClassLoader run() {\r\n                    return ClassLoader.getSystemClassLoader();\r\n                }\r\n            });\r\n        }\r\n    }"}, {"ID": 1282, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { return url.openStream(); } return null; }\n\n    ### Response:", "ground_truth": "Opens a resource of the specified name for reading.\n@see #getResourceUrl(String, ClassLoader)", "predict": "/**\r\n     * Returns an input stream for reading the specified resource.\r\n     * \r\n     * @param resourceName\r\n     *            the name of the resource to read\r\n     * @param callingClass\r\n     *            the class that is calling this method (used to locate the resource)\r\n     * @return an input stream for reading the specified resource, or null if the resource cannot be found\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass) throws IOException;"}, {"ID": 1283, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { URLConnection urlConnection = url.openConnection(); urlConnection.setUseCaches(useCache); return urlConnection.getInputStream(); } return null; }\n\n    ### Response:", "ground_truth": "Opens a resource of the specified name for reading. Controls caching,\nthat is important when the same jar is reloaded using custom classloader.", "predict": "/**\r\n     * Returns an input stream for reading the specified resource.\r\n     *\r\n     * @param resourceName the name of the resource to read\r\n     * @param callingClass the class that is calling this method (used to locate the resource)\r\n     * @param useCache whether to use the cache to store and retrieve the resource\r\n     * @return an input stream for reading the specified resource, or null if the resource cannot be found\r\n     * @throws IOException if an I/O error occurs while reading the resource\r\n     */\r\n    public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException {\r\n        URL url = getResourceUrl(resourceName, callingClass);\r\n        if (url != null) {\r\n            URLConnection urlConnection = url.openConnection();\r\n            urlConnection.setUseCaches(useCache);\r\n            return urlConnection.getInputStream();\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1284, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getClassAsStream(final Class clazz) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(clazz), clazz.getClassLoader()); }\n\n    ### Response:", "ground_truth": "Opens a class of the specified name for reading using class classloader.\n@see #getResourceAsStream(String, ClassLoader)", "predict": "/**\r\n     * Returns an input stream for the specified class.\r\n     *\r\n     * @param clazz the class to get the input stream for\r\n     * @return an input stream for the specified class\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static InputStream getClassAsStream(final Class clazz) throws IOException {\r\n        return getResourceAsStream(ClassUtil.convertClassNameToFileName(clazz), clazz.getClassLoader());\r\n    }"}, {"ID": 1285, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InputStream getClassAsStream(final String className, final ClassLoader classLoader) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader); }\n\n    ### Response:", "ground_truth": "Opens a class of the specified name for reading using provided class loader.", "predict": "/**\r\n     * Returns an input stream for the specified class name using the specified class loader.\r\n     *\r\n     * @param className the name of the class to load the input stream for\r\n     * @param classLoader the class loader to use to load the class\r\n     * @return an input stream for the specified class name using the specified class loader\r\n     * @throws IOException if an I/O error occurs while loading the class\r\n     */\r\n    public static InputStream getClassAsStream(final String className, final ClassLoader classLoader) throws IOException {\r\n        return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader);\r\n    }"}, {"ID": 1286, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; }\n\n    ### Response:", "ground_truth": "Adds a new child to the tree.", "predict": "/**\r\n     * Adds a new value to the route chunk.\r\n     *\r\n     * @param newValue the new value to add to the route chunk\r\n     * @return the newly created route chunk\r\n     */\r\n    public RouteChunk add(final String newValue) {\r\n        RouteChunk routeChunk = new RouteChunk(routes, this, newValue);\r\n        if (children == null) {\r\n            children = new RouteChunk[] {routeChunk};\r\n        } else {\r\n            children = ArraysUtil.append(children, routeChunk);\r\n        }\r\n        return routeChunk;\r\n    }"}, {"ID": 1287, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RouteChunk findOrCreateChild(final String value) { if (children != null) { for (RouteChunk child : children) { if (child.get().equals(value)) { return child; } } } return add(value); }\n\n    ### Response:", "ground_truth": "Finds existing chunk or creates a new one if does not exist.", "predict": "/**\r\n     * Finds or creates a child RouteChunk with the given value.\r\n     * \r\n     * @param value the value of the child RouteChunk to find or create\r\n     * @return the found or created RouteChunk\r\n     */\r\n    public RouteChunk findOrCreateChild(final String value) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 1288, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parseRequest() throws IOException { if (ServletUtil.isMultipartRequest(request)) { parseRequestStream(request.getInputStream(), characterEncoding); } else { Enumeration names = request.getParameterNames(); while (names.hasMoreElements()) { String paramName = (String) names.nextElement(); String[] values = request.getParameterValues(paramName); putParameters(paramName, values); } } }\n\n    ### Response:", "ground_truth": "Checks if request if multi-part and parse it. If request is not multi-part it\ncopies all parameters, to make usage the same in both cases.\n\n@see MultipartRequestWrapper", "predict": "/**\r\n     * Parses the request parameters and puts them into the parameter map.\r\n     * \r\n     * @throws IOException\r\n     *             if an I/O error occurs during parsing\r\n     */\r\n    public void parseRequest() throws IOException {\r\n        if (ServletUtil.isMultipartRequest(request)) {\r\n            parseRequestStream(request.getInputStream(), characterEncoding);\r\n        } else {\r\n            Enumeration names = request.getParameterNames();\r\n            while (names.hasMoreElements()) {\r\n                String paramName = (String) names.nextElement();\r\n                String[] values = request.getParameterValues(paramName);\r\n                putParameters(paramName, values);\r\n            }\r\n        }\r\n    }"}, {"ID": 1289, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Object convertToCollection(final Object value, final Class destinationType, final Class componentType) { return typeConverterManager.convertToCollection(value, destinationType, componentType); }\n\n    ### Response:", "ground_truth": "Converter to collection.", "predict": "/**\r\n     * Converts the given value to a collection of the specified type.\r\n     * \r\n     * @param value the value to convert\r\n     * @param destinationType the type of collection to create\r\n     * @param componentType the type of elements to include in the collection\r\n     * @return the converted collection\r\n     */\r\n    protected Object convertToCollection(final Object value, final Class destinationType, final Class componentType) {\r\n        return typeConverterManager.convertToCollection(value, destinationType, componentType);\r\n    }"}, {"ID": 1290, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeSetter(final Setter setter, final BeanProperty bp, Object value) { try { final MapperFunction setterMapperFunction = setter.getMapperFunction(); if (setterMapperFunction != null) { value = setterMapperFunction.apply(value); } final Class type = setter.getSetterRawType(); if (ClassUtil.isTypeOf(type, Collection.class)) { Class componentType = setter.getSetterRawComponentType(); value = convertToCollection(value, type, componentType); } else { // no collections value = convertType(value, type); } setter.invokeSetter(bp.bean, value); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Setter failed: \" + setter, ex); } return value; }\n\n    ### Response:", "ground_truth": "Invokes setter, but first converts type to match the setter type.", "predict": "/**\r\n     * Invokes the setter method on the given bean with the given value.\r\n     * \r\n     * @param setter\r\n     *            the setter method to invoke\r\n     * @param bp\r\n     *            the BeanProperty for the bean\r\n     * @param value\r\n     *            the value to set on the bean\r\n     * @return the value that was set on the bean\r\n     * @throws BeanException\r\n     *             if the setter method throws an exception\r\n     */\r\n    protected Object invokeSetter(final Setter setter, final BeanProperty bp, Object value) {\r\n        try {\r\n            final MapperFunction setterMapperFunction = setter.getMapperFunction();\r\n            if (setterMapperFunction != null) {\r\n                value = setterMapperFunction.apply(value);\r\n            }\r\n            final Class type = setter.getSetterRawType();\r\n            if (ClassUtil.isTypeOf(type, Collection.class)) {\r\n                Class componentType = setter.getSetterRawComponentType();\r\n                value = convertToCollection(value, type, componentType);\r\n            } else {\r\n                // no collections\r\n                value = convertType"}, {"ID": 1291, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void arrayForcedSet(final BeanProperty bp, Object array, final int index, Object value) { Class componentType = array.getClass().getComponentType(); array = ensureArraySize(bp, array, componentType, index); value = convertType(value, componentType); Array.set(array, index, value); }\n\n    ### Response:", "ground_truth": "Sets the array element forced. If index is greater then arrays length, array will be expanded to the index.\nIf speed is critical, it is better to allocate an array with proper size before using this method.", "predict": "/**\r\n     * Sets the value of the property represented by the given BeanProperty on the given array at the given index.\r\n     * \r\n     * @param bp the BeanProperty representing the property to set\r\n     * @param array the array on which to set the property value\r\n     * @param index the index at which to set the property value\r\n     * @param value the value to set on the property\r\n     */\r\n    protected void arrayForcedSet(final BeanProperty bp, Object array, final int index, Object value) {\r\n        Class componentType = array.getClass().getComponentType();\r\n        array = ensureArraySize(bp, array, componentType, index);\r\n        value = convertType(value, componentType);\r\n        Array.set(array, index, value);\r\n    }"}, {"ID": 1292, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object createBeanProperty(final BeanProperty bp) { Setter setter = bp.getSetter(true); if (setter == null) { return null; } Class type = setter.getSetterRawType(); Object newInstance; try { newInstance = ClassUtil.newInstance(type); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Invalid property: \" + bp.name, bp, ex); } newInstance = invokeSetter(setter, bp, newInstance); return newInstance; }\n\n    ### Response:", "ground_truth": "Creates new instance for current property name through its setter.\nIt uses default constructor!", "predict": "/**\r\n     * Creates a new instance of the property's type and sets it using the given setter.\r\n     *\r\n     * @param bp the BeanProperty to create a new instance for\r\n     * @return the new instance, or null if the property is read-only or the setter is null\r\n     * @throws BeanException if the property is invalid or the setter throws an exception\r\n     */\r\n    protected Object createBeanProperty(final BeanProperty bp) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1293, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class extractType(final BeanProperty bp) { Getter getter = bp.getGetter(isDeclared); if (getter != null) { if (bp.index != null) { Class type = getter.getGetterRawComponentType(); return type == null ? Object.class : type; } return getter.getGetterRawType(); } return null; // this should not happens }\n\n    ### Response:", "ground_truth": "Extracts type of current property.", "predict": "/**\r\n     * Extracts the type of the property represented by the given {@link BeanProperty}.\r\n     * \r\n     * @param bp the {@link BeanProperty} to extract the type from\r\n     * @return the type of the property, or {@code null} if the property is not readable\r\n     */\r\n    protected Class extractType(final BeanProperty bp) {\r\n        Getter getter = bp.getGetter(isDeclared);\r\n        if (getter != null) {\r\n            if (bp.index != null) {\r\n                Class type = getter.getGetterRawComponentType();\r\n                return type == null ? Object.class : type;\r\n            }\r\n            return getter.getGetterRawType();\r\n        }\r\n        return null; // this should not happens\r\n    }"}, {"ID": 1294, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void stop(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { final HttpSession httpSession = servletRequest.getSession(false); if (httpSession != null) { httpSession.removeAttribute(AUTH_SESSION_NAME); } final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME); if (cookie == null) { return; } cookie.setMaxAge(0); cookie.setPath(\"/\"); servletResponse.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * This method is used to logout the user from the system.\r\n     * \r\n     * @param servletRequest\r\n     *            The request object of the HTTP request.\r\n     * @param servletResponse\r\n     *            The response object of the HTTP request.\r\n     */\r\n    public static void stop(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) {\r\n        final HttpSession httpSession = servletRequest.getSession(false);\r\n        if (httpSession != null) {\r\n            httpSession.removeAttribute(AUTH_SESSION_NAME);\r\n        }\r\n        final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME);\r\n        if (cookie == null) {\r\n            return;\r\n        }\r\n        cookie.setMaxAge(0);\r\n        cookie.setPath(\"/\");\r\n        servletResponse.addCookie(cookie);\r\n    }"}, {"ID": 1295, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) { final HttpSession httpSession = httpServletRequest.getSession(true); httpSession.setAttribute(AUTH_SESSION_NAME, this); final Cookie cookie = new Cookie(AUTH_COOKIE_NAME, authTokenValue); //cookie.setDomain(SSORealm.SSO_DOMAIN); cookie.setMaxAge(cookieMaxAge); cookie.setPath(\"/\"); httpServletResponse.addCookie(cookie); }\n\n    ### Response:", "ground_truth": "Starts new user session.", "predict": "/**\r\n     * This method is used to start the authentication process.\r\n     * \r\n     * @param httpServletRequest\r\n     *            The request object.\r\n     * @param httpServletResponse\r\n     *            The response object.\r\n     */\r\n    public void start(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) {\r\n        final HttpSession httpSession = httpServletRequest.getSession(true);\r\n        httpSession.setAttribute(AUTH_SESSION_NAME, this);\r\n        final Cookie cookie = new Cookie(AUTH_COOKIE_NAME, authTokenValue);\r\n        //cookie.setDomain(SSORealm.SSO_DOMAIN);\r\n        cookie.setMaxAge(cookieMaxAge);\r\n        cookie.setPath(\"/\");\r\n        httpServletResponse.addCookie(cookie);\r\n    }"}, {"ID": 1296, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Date toDate(final LocalDate localDate) { return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant()); }\n\n    ### Response:", "ground_truth": "Converts local date to Date.", "predict": "/**\r\n     * Converts a LocalDate object to a Date object.\r\n     * \r\n     * @param localDate the LocalDate object to convert\r\n     * @return the converted Date object\r\n     */\r\n    public static Date toDate(final LocalDate localDate) {\r\n        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\r\n    }"}, {"ID": 1297, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Calendar toCalendar(final LocalDateTime localDateTime) { return GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault())); }\n\n    ### Response:", "ground_truth": "Converts local date time to Calendar.", "predict": "/**\r\n     * Converts a LocalDateTime to a Calendar object in the system default time zone.\r\n     *\r\n     * @param localDateTime the LocalDateTime object to convert\r\n     * @return a Calendar object representing the same time as the LocalDateTime in the system default time zone\r\n     */\r\n    public static Calendar toCalendar(final LocalDateTime localDateTime) {\r\n        return GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault()));\r\n    }"}, {"ID": 1298, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class defineProxy(final Class target) { ProxyProxettaFactory builder = proxetta.proxy(); builder.setTarget(target); return builder.define(); }\n\n    ### Response:", "ground_truth": "Generates new class.", "predict": "/**\r\n     * This method creates a proxy for the given target class using Proxetta library.\r\n     * \r\n     * @param target - The class to be proxied.\r\n     * @return A proxy object for the given target class.\r\n     */\r\n    public Class defineProxy(final Class target) {\r\n        ProxyProxettaFactory builder = proxetta.proxy();\r\n        builder.setTarget(target);\r\n        return builder.define();\r\n    }"}, {"ID": 1299, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Check check) { String name = check.getName(); List<Check> list = map.computeIfAbsent(name, k -> new ArrayList<>()); list.add(check); }\n\n    ### Response:", "ground_truth": "Adds validation checks.", "predict": "/**\r\n     * Adds a new check to the map of checks.\r\n     * \r\n     * @param check the check to add\r\n     */\r\n    public void add(final Check check) {\r\n        String name = check.getName();\r\n        List<Check> list = map.computeIfAbsent(name, k -> new ArrayList<>());\r\n        list.add(check);\r\n    }"}, {"ID": 1300, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ValidationContext resolveFor(final Class<?> target) { ValidationContext vc = new ValidationContext(); vc.addClassChecks(target); return vc; }\n\n    ### Response:", "ground_truth": "Resolve validation context for provided target class.\n@see #addClassChecks(Class)", "predict": "/**\r\n     * Resolves a validation context for the given target class.\r\n     * \r\n     * @param target the target class to resolve the validation context for\r\n     * @return the validation context for the target class\r\n     */\r\n    public static ValidationContext resolveFor(final Class<?> target) {\r\n        ValidationContext vc = new ValidationContext();\r\n        vc.addClassChecks(target);\r\n        return vc;\r\n    }"}, {"ID": 1301, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addClassChecks(final Class target) { final List<Check> list = cache.get(target, () -> { final List<Check> newList = new ArrayList<>(); final ClassDescriptor cd = ClassIntrospector.get().lookup(target); final PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { collectPropertyAnnotationChecks(newList, propertyDescriptor); } return newList; }); addAll(list); }\n\n    ### Response:", "ground_truth": "Parses class annotations and adds all checks.\n@see #resolveFor(Class)", "predict": "/**\r\n     * Adds checks for the properties of the given class to the list of checks.\r\n     * \r\n     * @param target the class to add checks for\r\n     */\r\n    public void addClassChecks(final Class target) {\r\n        // Implementation omitted for brevity\r\n    }"}, {"ID": 1302, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void collectPropertyAnnotationChecks(final List<Check> annChecks, final PropertyDescriptor propertyDescriptor) { FieldDescriptor fd = propertyDescriptor.getFieldDescriptor(); if (fd != null) { Annotation[] annotations = fd.getField().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } MethodDescriptor md = propertyDescriptor.getReadMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } md = propertyDescriptor.getWriteMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } }\n\n    ### Response:", "ground_truth": "Process all annotations of provided properties.", "predict": "/**\r\n     * Collects the annotation checks for a property.\r\n     * \r\n     * @param annChecks\r\n     *            the list of annotation checks to add to\r\n     * @param propertyDescriptor\r\n     *            the property descriptor to collect checks for\r\n     */\r\n    protected void collectPropertyAnnotationChecks(final List<Check> annChecks, final PropertyDescriptor propertyDescriptor) {\r\n        FieldDescriptor fd = propertyDescriptor.getFieldDescriptor();\r\n        if (fd != null) {\r\n            Annotation[] annotations = fd.getField().getAnnotations();\r\n            collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations);\r\n        }\r\n        MethodDescriptor md = propertyDescriptor.getReadMethodDescriptor();\r\n        if (md != null) {\r\n            Annotation[] annotations = md.getMethod().getAnnotations();\r\n            collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations);\r\n        }\r\n        md = propertyDescriptor.getWriteMethodDescriptor();\r\n        if (md != null) {\r\n            Annotation[] annotations = md.getMethod().getAnnotations();\r\n            collectAnnotationChecks(annChecks"}, {"ID": 1303, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected void collectAnnotationChecks(final List<Check> annChecks, final Class targetType, final String targetName, final Annotation[] annotations) { for (Annotation annotation : annotations) { Constraint c = annotation.annotationType().getAnnotation(Constraint.class); Class<? extends ValidationConstraint> constraintClass; if (c == null) { // if constraint is not available, try lookup String constraintClassName = annotation.annotationType().getName() + \"Constraint\"; try { constraintClass = ClassLoaderUtil.loadClass(constraintClassName, this.getClass().getClassLoader()); } catch (ClassNotFoundException ingore) { continue; } } else { constraintClass = c.value(); } ValidationConstraint vc; try { vc = newConstraint(constraintClass, targetType); } catch (Exception ex) { throw new VtorException(\"Invalid constraint: \" + constraintClass.getClass().getName(), ex); } vc.configure(annotation); Check check = new Check(targetName, vc); copyDefaultCheckProperties(check, annotation); annChecks.add(check); } }\n\n    ### Response:", "ground_truth": "Collect annotations for some target.", "predict": "/**\r\n     * Collects the annotation checks for the given target type, name, and annotations.\r\n     * \r\n     * @param annChecks the list to store the annotation checks\r\n     * @param targetType the target type\r\n     * @param targetName the target name\r\n     * @param annotations the annotations to collect checks from\r\n     */\r\n    protected void collectAnnotationChecks(final List<Check> annChecks, final Class targetType, final String targetName, final Annotation[] annotations) {\r\n        for (Annotation annotation : annotations) {\r\n            Constraint c = annotation.annotationType().getAnnotation(Constraint.class);\r\n            Class<? extends ValidationConstraint> constraintClass;\r\n            if (c == null) {\r\n                // if constraint is not available, try lookup\r\n                String constraintClassName = annotation.annotationType().getName() + \"Constraint\";\r\n                try {\r\n                    constraintClass = ClassLoaderUtil.loadClass(constraintClassName, this.getClass().getClassLoader());\r\n                } catch (ClassNotFoundException ingore) {\r\n                    continue;\r\n                }\r\n            } else {\r\n                constraintClass = c.value();\r\n            }\r\n           "}, {"ID": 1304, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void copyDefaultCheckProperties(final Check destCheck, final Annotation annotation) { Integer severity = (Integer) ClassUtil.readAnnotationValue(annotation, ANN_SEVERITY); destCheck.setSeverity(severity.intValue()); String[] profiles = (String[]) ClassUtil.readAnnotationValue(annotation, ANN_PROFILES); destCheck.setProfiles(profiles); String message = (String) ClassUtil.readAnnotationValue(annotation, ANN_MESSAGE); destCheck.setMessage(message); }\n\n    ### Response:", "ground_truth": "Copies default properties from annotation to the check.", "predict": "/**\r\n     * Copies the default check properties from the given annotation to the given check instance.\r\n     * \r\n     * @param destCheck the check instance to copy the properties to\r\n     * @param annotation the annotation to read the properties from\r\n     */\r\n    protected void copyDefaultCheckProperties(final Check destCheck, final Annotation annotation) {\r\n        Integer severity = (Integer) ClassUtil.readAnnotationValue(annotation, ANN_SEVERITY);\r\n        destCheck.setSeverity(severity.intValue());\r\n        \r\n        String[] profiles = (String[]) ClassUtil.readAnnotationValue(annotation, ANN_PROFILES);\r\n        destCheck.setProfiles(profiles);\r\n        \r\n        String message = (String) ClassUtil.readAnnotationValue(annotation, ANN_MESSAGE);\r\n        destCheck.setMessage(message);\r\n    }"}, {"ID": 1305, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String encodeUriComponent(final String source, final String encoding, final URIPart uriPart) { if (source == null) { return null; } byte[] bytes = encodeBytes(StringUtil.getBytes(source, encoding), uriPart); char[] chars = new char[bytes.length]; for (int i = 0; i < bytes.length; i++) { chars[i] = (char) bytes[i]; } return new String(chars); }\n\n    ### Response:", "ground_truth": "Encodes single URI component.", "predict": "/**\r\n     * Encodes the given string using the specified encoding scheme and URI part.\r\n     *\r\n     * @param source the string to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @param uriPart the URI part to use\r\n     * @return the encoded string\r\n     */\r\n    private static String encodeUriComponent(final String source, final String encoding, final URIPart uriPart) {\r\n        if (source == null) {\r\n            return null;\r\n        }\r\n        byte[] bytes = encodeBytes(StringUtil.getBytes(source, encoding), uriPart);\r\n        char[] chars = new char[bytes.length];\r\n        for (int i = 0; i < bytes.length; i++) {\r\n            chars[i] = (char) bytes[i];\r\n        }\r\n        return new String(chars);\r\n    }"}, {"ID": 1306, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode(final String string, final String encoding) { return encodeUriComponent(string, encoding, URIPart.UNRESERVED); }\n\n    ### Response:", "ground_truth": "Encodes string using default RFCP rules.", "predict": "/**\r\n     * Encodes the given string using the specified encoding scheme.\r\n     *\r\n     * @param string the string to be encoded\r\n     * @param encoding the encoding scheme to be used\r\n     * @return the encoded string\r\n     */\r\n    public static String encode(final String string, final String encoding) {\r\n        return encodeUriComponent(string, encoding, URIPart.UNRESERVED);\r\n    }"}, {"ID": 1307, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeScheme(final String scheme, final String encoding) { return encodeUriComponent(scheme, encoding, URIPart.SCHEME); }\n\n    ### Response:", "ground_truth": "Encodes the given URI scheme with the given encoding.", "predict": "/**\r\n     * Encodes the scheme of a URI using the specified encoding.\r\n     * \r\n     * @param scheme the scheme to encode\r\n     * @param encoding the encoding to use\r\n     * @return the encoded scheme\r\n     */\r\n    public static String encodeScheme(final String scheme, final String encoding) {\r\n        return encodeUriComponent(scheme, encoding, URIPart.SCHEME);\r\n    }"}, {"ID": 1308, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeHost(final String host, final String encoding) { return encodeUriComponent(host, encoding, URIPart.HOST); }\n\n    ### Response:", "ground_truth": "Encodes the given URI host with the given encoding.", "predict": "/**\r\n     * Encodes the given host string using the given encoding scheme.\r\n     *\r\n     * @param host the host string to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @return the encoded host string\r\n     */\r\n    public static String encodeHost(final String host, final String encoding) {\r\n        return encodeUriComponent(host, encoding, URIPart.HOST);\r\n    }"}, {"ID": 1309, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePort(final String port, final String encoding) { return encodeUriComponent(port, encoding, URIPart.PORT); }\n\n    ### Response:", "ground_truth": "Encodes the given URI port with the given encoding.", "predict": "/**\r\n     * Encodes the given port string using the given encoding scheme.\r\n     * \r\n     * @param port the port string to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @return the encoded port string\r\n     */\r\n    public static String encodePort(final String port, final String encoding) {\r\n        return encodeUriComponent(port, encoding, URIPart.PORT);\r\n    }"}, {"ID": 1310, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodePath(final String path, final String encoding) { return encodeUriComponent(path, encoding, URIPart.PATH); }\n\n    ### Response:", "ground_truth": "Encodes the given URI path with the given encoding.", "predict": "/**\r\n     * Encodes the given path using the specified encoding scheme.\r\n     *\r\n     * @param path the path to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @return the encoded path\r\n     */\r\n    public static String encodePath(final String path, final String encoding) {\r\n        return encodeUriComponent(path, encoding, URIPart.PATH);\r\n    }"}, {"ID": 1311, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQuery(final String query, final String encoding) { return encodeUriComponent(query, encoding, URIPart.QUERY); }\n\n    ### Response:", "ground_truth": "Encodes the given URI query with the given encoding.", "predict": "/**\r\n     * Encodes the query string of a URI component using the specified encoding scheme.\r\n     *\r\n     * @param query the query string to be encoded\r\n     * @param encoding the encoding scheme to be used\r\n     * @return the encoded query string\r\n     */\r\n    public static String encodeQuery(final String query, final String encoding) {\r\n        return encodeUriComponent(query, encoding, URIPart.QUERY);\r\n    }"}, {"ID": 1312, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeQueryParam(final String queryParam, final String encoding) { return encodeUriComponent(queryParam, encoding, URIPart.QUERY_PARAM); }\n\n    ### Response:", "ground_truth": "Encodes the given URI query parameter with the given encoding.", "predict": "/**\r\n     * Encodes the given query parameter using the given encoding scheme.\r\n     * \r\n     * @param queryParam the query parameter to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @return the encoded query parameter\r\n     */\r\n    public static String encodeQueryParam(final String queryParam, final String encoding) {\r\n        return encodeUriComponent(queryParam, encoding, URIPart.QUERY_PARAM);\r\n    }"}, {"ID": 1313, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeFragment(final String fragment, final String encoding) { return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT); }\n\n    ### Response:", "ground_truth": "Encodes the given URI fragment with the given encoding.", "predict": "/**\r\n     * Encodes the given fragment using the given encoding scheme.\r\n     * \r\n     * @param fragment the fragment to encode\r\n     * @param encoding the encoding scheme to use\r\n     * @return the encoded fragment\r\n     */\r\n    public static String encodeFragment(final String fragment, final String encoding) {\r\n        return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT);\r\n    }"}, {"ID": 1314, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected HashMap<String, PropertyDescriptor> inspectProperties() { boolean scanAccessible = classDescriptor.isScanAccessible(); Class type = classDescriptor.getType(); HashMap<String, PropertyDescriptor> map = new HashMap<>(); Method[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type); for (int iteration = 0; iteration < 2; iteration++) { // first find the getters, and then the setters! for (Method method : methods) { if (Modifier.isStatic(method.getModifiers())) { continue; // ignore static methods } boolean add = false; boolean issetter = false; String propertyName; if (iteration == 0) { propertyName = ClassUtil.getBeanPropertyGetterName(method); if (propertyName != null) { add = true; issetter = false; } } else { propertyName = ClassUtil.getBeanPropertySetterName(method); if (propertyName != null) { add = true; issetter = true; } } if (add) { MethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true); addProperty(map, propertyName, methodDescriptor, issetter); } } } if (classDescriptor.isIncludeFieldsAsProperties()) { FieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors(); String[] prefix = classDescriptor.getPropertyFieldPrefix(); for (FieldDescriptor fieldDescriptor : fieldDescriptors) { Field field = fieldDescriptor.getField(); if (Modifier.isStatic(field.getModifiers())) { continue; // ignore static fields } String name = field.getName(); if (prefix != null) { for (String p : prefix) { if (!name.startsWith(p)) { continue; } name = name.substring(p.length()); break; } } if (!map.containsKey(name)) { // add missing field as a potential property map.put(name, createPropertyDescriptor(name, fieldDescriptor)); } } } return map; }\n\n    ### Response:", "ground_truth": "Inspects all properties of target type.", "predict": "/**\n     * Inspects the properties of the class and returns a map of property names to property descriptors.\n     * \n     * @return a map of property names to property descriptors\n     */\n    protected HashMap<String, PropertyDescriptor> inspectProperties() {\n        // implementation details elided for brevity\n    }"}, {"ID": 1315, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyDescriptor[] getAllPropertyDescriptors() { if (allProperties == null) { PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()]; int index = 0; for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) { allProperties[index] = propertyDescriptor; index++; } Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() { @Override public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) { return pd1.getName().compareTo(pd2.getName()); } }); this.allProperties = allProperties; } return allProperties; }\n\n    ### Response:", "ground_truth": "Returns all property descriptors.\nProperties are sorted by name.", "predict": "/**\r\n     * Returns an array of PropertyDescriptor objects describing all the properties supported by this component.\r\n     *\r\n     * @return An array of PropertyDescriptor objects describing all the properties supported by this component.\r\n     * @see java.beans.BeanInfo#getPropertyDescriptors()\r\n     */\r\n    public PropertyDescriptor[] getAllPropertyDescriptors() {\r\n        if (allProperties == null) {\r\n            PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()];\r\n            int index = 0;\r\n            for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) {\r\n                allProperties[index] = propertyDescriptor;\r\n                index++;\r\n            }\r\n            Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() {\r\n                @Override\r\n                public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) {\r\n                    return pd1.getName().compareTo(pd2.getName());\r\n                }\r\n            });\r\n            this.allProperties = allProperties;\r\n        }\r\n        return allProperties;\r\n    }"}, {"ID": 1316, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Cookie[] cookies() { List<String> newCookies = headers(\"set-cookie\"); if (newCookies == null) { return new Cookie[0]; } List<Cookie> cookieList = new ArrayList<>(newCookies.size()); for (String cookieValue : newCookies) { try { Cookie cookie = new Cookie(cookieValue); cookieList.add(cookie); } catch (Exception ex) { // ignore } } return cookieList.toArray(new Cookie[0]); }\n\n    ### Response:", "ground_truth": "Returns list of valid cookies sent from server.\nIf no cookie found, returns an empty array. Invalid cookies are ignored.", "predict": "/**\r\n     * Returns an array of cookies extracted from the \"set-cookie\" header.\r\n     *\r\n     * @return an array of cookies, or an empty array if no cookies were found\r\n     */\r\n    public Cookie[] cookies() {\r\n        // implementation details\r\n    }"}, {"ID": 1317, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse unzip() { String contentEncoding = contentEncoding(); if (contentEncoding != null && contentEncoding().equals(\"gzip\")) { if (body != null) { headerRemove(HEADER_CONTENT_ENCODING); try { ByteArrayInputStream in = new ByteArrayInputStream(body.getBytes(StringPool.ISO_8859_1)); GZIPInputStream gzipInputStream = new GZIPInputStream(in); ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamUtil.copy(gzipInputStream, out); body(out.toString(StringPool.ISO_8859_1)); } catch (IOException ioex) { throw new HttpException(ioex); } } } return this; }\n\n    ### Response:", "ground_truth": "Unzips GZip-ed body content, removes the content-encoding header\nand sets the new content-length value.", "predict": "/**\n     * Unzips the response body if it is gzipped.\n     *\n     * @return the response object with the unzipped body.\n     */\n    public HttpResponse unzip() {\n        // TODO: implement unzip logic\n    }"}, {"ID": 1318, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse close() { HttpConnection httpConnection = httpRequest.httpConnection; if (httpConnection != null) { httpConnection.close(); httpRequest.httpConnection = null; } return this; }\n\n    ### Response:", "ground_truth": "Closes requests connection if it was open.\nShould be called when using keep-alive connections.\nOtherwise, connection will be already closed.", "predict": "/**\r\n     * Closes the underlying HttpConnection and sets the reference to null.\r\n     *\r\n     * @return the current instance of the HttpResponse object.\r\n     */\r\n    public HttpResponse close() {\r\n        HttpConnection httpConnection = httpRequest.httpConnection;\r\n        if (httpConnection != null) {\r\n            httpConnection.close();\r\n            httpRequest.httpConnection = null;\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1319, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final Scope referenceScope) { Class<? extends Scope> refScopeType = referenceScope.getClass(); if (refScopeType == ProtoScope.class) { return true; } if (refScopeType == SingletonScope.class) { return true; } if (refScopeType == ThreadLocalScope.class) { return true; } return false; }\n\n    ### Response:", "ground_truth": "Defines allowed referenced scopes that can be injected into the\nthread-local scoped bean.", "predict": "/**\r\n     * This method overrides the accept method of the Scope interface.\r\n     * \r\n     * @param referenceScope The reference scope to be checked for acceptance.\r\n     * @return True if the reference scope is an instance of ProtoScope, SingletonScope or ThreadLocalScope, false otherwise.\r\n     */\r\n    @Override public boolean accept(final Scope referenceScope) {\r\n        Class<? extends Scope> refScopeType = referenceScope.getClass();\r\n        if (refScopeType == ProtoScope.class) {\r\n            return true;\r\n        }\r\n        if (refScopeType == SingletonScope.class) {\r\n            return true;\r\n        }\r\n        if (refScopeType == ThreadLocalScope.class) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1320, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void printRoutes(final int width) { final ActionsManager actionsManager = webApp.madvocContainer().lookupComponent(ActionsManager.class); final List<ActionRuntime> actions = actionsManager.getAllActionRuntimes(); final Map<String, String> aliases = actionsManager.getAllAliases(); if (actions.isEmpty()) { return; } final Print print = new Print(); print.line(\"Routes\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionMethod = ar.getActionMethod(); print.out(Chalk256.chalk().yellow(), actionMethod == null ? \"*\" : actionMethod, 7); print.space(); final String signature = ClassUtil.getShortClassName( ProxettaUtil.resolveTargetClass(ar.getActionClass()), 2) + '#' + ar.getActionClassMethod().getName(); print.outLeftRightNewLine( Chalk256.chalk().green(), ar.getActionPath(), Chalk256.chalk().blue(), signature, width - 7 - 1 ); }); if (!aliases.isEmpty()) { print.line(\"Aliases\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionPath = ar.getActionPath(); for (final Map.Entry<String, String> entry : aliases.entrySet()) { if (entry.getValue().equals(actionPath)) { print.space(8); print.outLeftRightNewLine( Chalk256.chalk().green(), entry.getValue(), Chalk256.chalk().blue(), entry.getKey(), width - 8 ); } } }); } print.line(width); }\n\n    ### Response:", "ground_truth": "Prints routes to console.", "predict": "/**\r\n     * Prints all routes and aliases for the web application.\r\n     * \r\n     * @param width the maximum width of the output\r\n     */\r\n    protected void printRoutes(final int width) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1321, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] encrypt(final byte[] content) { FastByteBuffer fbb = new FastByteBuffer(); int length = content.length + 1; int blockCount = length / blockSizeInBytes; int remaining = length; int offset = 0; for (int i = 0; i < blockCount; i++) { if (remaining == blockSizeInBytes) { break; } byte[] encrypted = encryptBlock(content, offset); fbb.append(encrypted); offset += blockSizeInBytes; remaining -= blockSizeInBytes; } if (remaining != 0) { // process remaining bytes byte[] block = new byte[blockSizeInBytes]; System.arraycopy(content, offset, block, 0, remaining - 1); block[remaining - 1] = TERMINATOR; byte[] encrypted = encryptBlock(block, 0); fbb.append(encrypted); } return fbb.toArray(); }\n\n    ### Response:", "ground_truth": "Encrypts complete content, block by block.", "predict": "/**\r\n     * Encrypts the given content using the specified block size and encryption algorithm.\r\n     *\r\n     * @param content the content to encrypt\r\n     * @return the encrypted content\r\n     */\r\n    public byte[] encrypt(final byte[] content) {\r\n        FastByteBuffer fbb = new FastByteBuffer();\r\n        int length = content.length + 1;\r\n        int blockCount = length / blockSizeInBytes;\r\n        int remaining = length;\r\n        int offset = 0;\r\n        for (int i = 0; i < blockCount; i++) {\r\n            if (remaining == blockSizeInBytes) {\r\n                break;\r\n            }\r\n            byte[] encrypted = encryptBlock(content, offset);\r\n            fbb.append(encrypted);\r\n            offset += blockSizeInBytes;\r\n            remaining -= blockSizeInBytes;\r\n        }\r\n        if (remaining != 0) {\r\n            // process remaining bytes\r\n            byte[] block = new byte[blockSizeInBytes];\r\n            System.arraycopy(content, offset, block, 0, remaining - 1);\r\n            block[remaining - 1] = TERMINATOR;"}, {"ID": 1322, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public byte[] decrypt(final byte[] encryptedContent) { FastByteBuffer fbb = new FastByteBuffer(); int length = encryptedContent.length; int blockCount = length / blockSizeInBytes; int offset = 0; for (int i = 0; i < blockCount - 1; i++) { byte[] decrypted = decryptBlock(encryptedContent, offset); fbb.append(decrypted); offset += blockSizeInBytes; } // process last block byte[] decrypted = decryptBlock(encryptedContent, offset); // find terminator int ndx = blockSizeInBytes - 1; while (ndx >= 0) { if (decrypted[ndx] == TERMINATOR) { break; } ndx--; } fbb.append(decrypted, 0, ndx); return fbb.toArray(); }\n\n    ### Response:", "ground_truth": "Decrypts the whole content, block by block.", "predict": "/**\r\n     * Decrypts the given encrypted content using the provided key.\r\n     *\r\n     * @param encryptedContent the encrypted content to decrypt\r\n     * @return the decrypted content\r\n     */\r\n    public byte[] decrypt(final byte[] encryptedContent) {\r\n        FastByteBuffer fbb = new FastByteBuffer();\r\n        int length = encryptedContent.length;\r\n        int blockCount = length / blockSizeInBytes;\r\n        int offset = 0;\r\n\r\n        for (int i = 0; i < blockCount - 1; i++) {\r\n            byte[] decrypted = decryptBlock(encryptedContent, offset);\r\n            fbb.append(decrypted);\r\n            offset += blockSizeInBytes;\r\n        }\r\n\r\n        // process last block\r\n        byte[] decrypted = decryptBlock(encryptedContent, offset);\r\n\r\n        // find terminator\r\n        int ndx = blockSizeInBytes - 1;\r\n        while (ndx >= 0) {\r\n            if (decrypted[ndx] == TERMINATOR) {\r\n                break;\r\n            }\r\n            ndx--;\r\n        }\r\n\r\n        fbb.append(decrypted, 0"}, {"ID": 1323, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object map2bean(final Map map, Class targetType) { Object target = null; // create targets type String className = (String) map.get(classMetadataName); if (className == null) { if (targetType == null) { // nothing to do, no information about target type found target = map; } } else { checkClassName(jsonParser.classnameWhitelist, className); try { targetType = ClassLoaderUtil.loadClass(className); } catch (ClassNotFoundException cnfex) { throw new JsonException(cnfex); } } if (target == null) { target = jsonParser.newObjectInstance(targetType); } ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); boolean targetIsMap = target instanceof Map; for (Object key : map.keySet()) { String keyName = key.toString(); if (classMetadataName != null) { if (keyName.equals(classMetadataName)) { continue; } } PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared); if (!targetIsMap && pd == null) { // target property does not exist, continue continue; } // value is one of JSON basic types, like Number, Map, List... Object value = map.get(key); Class propertyType = pd == null ? null : pd.getType(); Class componentType = pd == null ? null : pd.resolveComponentType(true); if (value != null) { if (value instanceof List) { if (componentType != null && componentType != String.class) { value = generifyList((List) value, componentType); } } else if (value instanceof Map) { // if the value we want to inject is a Map... if (!ClassUtil.isTypeOf(propertyType, Map.class)) { // ... and if target is NOT a map value = map2bean((Map) value, propertyType); } else { // target is also a Map, but we might need to generify it Class keyType = pd == null ? null : pd.resolveKeyType(true); if (keyType != String.class || componentType != String.class) { // generify value = generifyMap((Map) value, keyType, componentType); } } } } if (targetIsMap) { ((Map)target).put(keyName, value); } else { try { setValue(target, pd, value); } catch (Exception ignore) { ignore.printStackTrace(); } } } return target; }\n\n    ### Response:", "ground_truth": "Converts map to target type.", "predict": "/**\n     * Maps a Map to a Java Bean object.\n     *\n     * @param map the Map to be mapped to a Java Bean object.\n     * @param targetType the target Java Bean object type.\n     * @return the Java Bean object.\n     */\n    public Object map2bean(final Map map, Class targetType) {\n        Object target = null; // create targets type String className = (String) map.get(classMetadataName); if (className == null) { if (targetType == null) { // nothing to do, no information about target type found target = map; } } else { checkClassName(jsonParser.classnameWhitelist, className); try { targetType = ClassLoaderUtil.loadClass(className); } catch (ClassNotFoundException cnfex) { throw new JsonException(cnfex); } } if (target == null) { target = jsonParser.newObjectInstance(targetType); } ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); boolean targetIsMap = target instanceof"}, {"ID": 1324, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object generifyList(final List list, final Class componentType) { for (int i = 0; i < list.size(); i++) { Object element = list.get(i); if (element != null) { if (element instanceof Map) { Object bean = map2bean((Map) element, componentType); list.set(i, bean); } else { Object value = convert(element, componentType); list.set(i, value); } } } return list; }\n\n    ### Response:", "ground_truth": "Converts type of all list elements to match the component type.", "predict": "/**\r\n     * This method takes a List and a Class as input and returns a modified List.\r\n     * The method iterates through the List and checks if each element is an instance of Map.\r\n     * If the element is a Map, the method converts the Map to a JavaBean using the map2bean() method.\r\n     * If the element is not a Map, the method converts the element to the specified Class using the convert() method.\r\n     * The modified List is then returned.\r\n     * \r\n     * @param list The List to be modified\r\n     * @param componentType The Class to which each element in the List should be converted\r\n     * @return The modified List\r\n     */\r\n    private Object generifyList(final List list, final Class componentType) {\r\n        for (int i = 0; i < list.size(); i++) {\r\n            Object element = list.get(i);\r\n            if (element != null) {\r\n                if (element instanceof Map) {\r\n                    Object bean = map2bean((Map) element, componentType);\r\n                    list"}, {"ID": 1325, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException { Class propertyType; Setter setter = pd.getSetter(true); if (setter != null) { if (value != null) { propertyType = setter.getSetterRawType(); value = jsonParser.convertType(value, propertyType); } setter.invokeSetter(target, value); } }\n\n    ### Response:", "ground_truth": "Sets the property value.", "predict": "/**\r\n     * Sets the value of a property on a target object using a PropertyDescriptor and a value.\r\n     * \r\n     * @param target the target object on which to set the property value\r\n     * @param pd the PropertyDescriptor for the property to set\r\n     * @param value the value to set on the property\r\n     * @throws InvocationTargetException if the setter method throws an exception\r\n     * @throws IllegalAccessException if the setter method is not accessible\r\n     */\r\n    private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException {\r\n        Class propertyType;\r\n        Setter setter = pd.getSetter(true);\r\n        if (setter != null) {\r\n            if (value != null) {\r\n                propertyType = setter.getSetterRawType();\r\n                value = jsonParser.convertType(value, propertyType);\r\n            }\r\n            setter.invokeSetter(target, value);\r\n        }\r\n    }"}, {"ID": 1326, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) { if (keyType == String.class) { // only value type is changed, we can make value replacements for (Map.Entry<Object, Object> entry : map.entrySet()) { Object value = entry.getValue(); Object newValue = convert(value, valueType); if (value != newValue) { entry.setValue(newValue); } } return (Map<K, V>) map; } // key is changed too, we need a new map Map<K, V> newMap = new HashMap<>(map.size()); for (Map.Entry<Object, Object> entry : map.entrySet()) { Object key = entry.getKey(); Object newKey = convert(key, keyType); Object value = entry.getValue(); Object newValue = convert(value, valueType); newMap.put((K)newKey, (V)newValue); } return newMap; }\n\n    ### Response:", "ground_truth": "Change map elements to match key and value types.", "predict": "/**\r\n     * This method takes a map of objects as input, and returns a map of the specified key and value types.\r\n     * If the key type is String, then the value type is changed, and we can make value replacements for the map.\r\n     * If the key type is changed, then we need a new map.\r\n     * \r\n     * @param map the input map of objects\r\n     * @param keyType the desired key type for the output map\r\n     * @param valueType the desired value type for the output map\r\n     * @return a map of the specified key and value types\r\n     */\r\n    protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) {\r\n        // implementation goes here\r\n    }"}, {"ID": 1327, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compareTo(final Object o) { DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o; if (this.isId != that.isId) { return this.isId ? -1 : 1; // IDs should be the first in the array } return this.columnName.compareTo(that.columnName); }\n\n    ### Response:", "ground_truth": "Compares two column descriptors. Identity columns should be the first on the list.\nEach group then will be sorted by column name.", "predict": "/**\r\n     * Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\r\n     * \r\n     * @param o the object to be compared.\r\n     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\r\n     * @throws ClassCastException if the specified object's type prevents it from being compared to this object.\r\n     */\r\n    @Override\r\n    public int compareTo(final Object o) {\r\n        DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o;\r\n        if (this.isId != that.isId) {\r\n            return this.isId ? -1 : 1; // IDs should be the first in the array\r\n        }\r\n        return this.columnName.compareTo(that.columnName);\r\n    }"}, {"ID": 1328, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; }\n\n    ### Response:", "ground_truth": "Adds default header to all requests.", "predict": "/**\r\n     * Sets the default header for the HTTP request.\r\n     * \r\n     * @param name the name of the header\r\n     * @param value the value of the header\r\n     * @return the current HttpBrowser instance\r\n     */\r\n    public HttpBrowser setDefaultHeader(final String name, final String value) {\r\n        defaultHeaders.addHeader(name, value);\r\n        return this;\r\n    }"}, {"ID": 1329, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public HttpResponse sendRequest(HttpRequest httpRequest) { elapsedTime = System.currentTimeMillis(); // send request httpRequest.followRedirects(false); while (true) { this.httpRequest = httpRequest; HttpResponse previousResponse = this.httpResponse; this.httpResponse = null; addDefaultHeaders(httpRequest); addCookies(httpRequest); // send request if (catchTransportExceptions) { try { this.httpResponse = _sendRequest(httpRequest, previousResponse); } catch (HttpException httpException) { httpResponse = new HttpResponse(); httpResponse.assignHttpRequest(httpRequest); httpResponse.statusCode(503); httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException)); } } else { this.httpResponse =_sendRequest(httpRequest, previousResponse); } readCookies(httpResponse); int statusCode = httpResponse.statusCode(); // 301: moved permanently if (statusCode == 301) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 302: redirect, 303: see other if (statusCode == 302 || statusCode == 303) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 307: temporary redirect, 308: permanent redirect if (statusCode == 307 || statusCode == 308) { String newPath = httpResponse.location(); if (newPath == null) { break; } String originalMethod = httpRequest.method(); httpRequest = new HttpRequest() .method(originalMethod) .set(newPath); continue; } break; } elapsedTime = System.currentTimeMillis() - elapsedTime; return this.httpResponse; }\n\n    ### Response:", "ground_truth": "Sends new request as a browser. Before sending,\nall browser cookies are added to the request.\nAfter sending, the cookies are read from the response.\nMoreover, status codes 301 and 302 are automatically\nhandled. Returns very last response.", "predict": "/**\r\n     * Sends an HTTP request and returns the response.\r\n     * \r\n     * @param httpRequest the HTTP request to send\r\n     * @return the HTTP response\r\n     */\r\n    public HttpResponse sendRequest(HttpRequest httpRequest) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1330, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) { if (!keepAlive) { httpRequest.open(httpConnectionProvider); } else { // keeping alive if (previouseResponse == null) { httpRequest.open(httpConnectionProvider).connectionKeepAlive(true); } else { httpRequest.keepAlive(previouseResponse, true); } } return httpRequest.send(); }\n\n    ### Response:", "ground_truth": "Opens connection and sends a response.", "predict": "/**\r\n     * Sends an HTTP request to the server and returns the response.\r\n     * \r\n     * @param httpRequest the HTTP request to send\r\n     * @param previouseResponse the previous response received from the server (may be null)\r\n     * @return the HTTP response received from the server\r\n     */\r\n    protected HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) {\r\n        if (!keepAlive) {\r\n            httpRequest.open(httpConnectionProvider);\r\n        } else {\r\n            // keeping alive\r\n            if (previouseResponse == null) {\r\n                httpRequest.open(httpConnectionProvider).connectionKeepAlive(true);\r\n            } else {\r\n                httpRequest.keepAlive(previouseResponse, true);\r\n            }\r\n        }\r\n        return httpRequest.send();\r\n    }"}, {"ID": 1331, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addDefaultHeaders(final HttpRequest httpRequest) { for (Map.Entry<String, String> entry : defaultHeaders.entries()) { String name = entry.getKey(); if (!httpRequest.headers.contains(name)) { httpRequest.headers.add(name, entry.getValue()); } } }\n\n    ### Response:", "ground_truth": "Add default headers to the request. If request already has a header set,\ndefault header will be ignored.", "predict": "/**\r\n     * Adds the default headers to the given HTTP request.\r\n     * \r\n     * @param httpRequest the HTTP request to add the headers to\r\n     */\r\n    protected void addDefaultHeaders(final HttpRequest httpRequest) {\r\n        for (Map.Entry<String, String> entry : defaultHeaders.entries()) {\r\n            String name = entry.getKey();\r\n            if (!httpRequest.headers.contains(name)) {\r\n                httpRequest.headers.add(name, entry.getValue());\r\n            }\r\n        }\r\n    }"}, {"ID": 1332, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void readCookies(final HttpResponse httpResponse) { Cookie[] newCookies = httpResponse.cookies(); for (Cookie cookie : newCookies) { cookies.add(cookie.getName(), cookie); } }\n\n    ### Response:", "ground_truth": "Reads cookies from response and adds to cookies list.", "predict": "/**\r\n     * This method is responsible for reading cookies from the HTTP response and adding them to the cookie store.\r\n     * \r\n     * @param httpResponse The HTTP response containing the cookies to be added to the cookie store.\r\n     */\r\n    protected void readCookies(final HttpResponse httpResponse) {\r\n        Cookie[] newCookies = httpResponse.cookies();\r\n        for (Cookie cookie : newCookies) {\r\n            cookies.add(cookie.getName(), cookie);\r\n        }\r\n    }"}, {"ID": 1333, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addCookies(final HttpRequest httpRequest) { // prepare all cookies List<Cookie> cookiesList = new ArrayList<>(); if (!cookies.isEmpty()) { for (Map.Entry<String, Cookie> cookieEntry : cookies) { cookiesList.add(cookieEntry.getValue()); } httpRequest.cookies(cookiesList.toArray(new Cookie[0])); } }\n\n    ### Response:", "ground_truth": "Add cookies to the request.", "predict": "/**\r\n     * Adds all cookies to the given HttpRequest object.\r\n     *\r\n     * @param httpRequest the HttpRequest object to add cookies to\r\n     */\r\n    protected void addCookies(final HttpRequest httpRequest) {\r\n        // prepare all cookies\r\n        List<Cookie> cookiesList = new ArrayList<>();\r\n\r\n        // check if cookies are present\r\n        if (!cookies.isEmpty()) {\r\n            // iterate over cookies and add them to the list\r\n            for (Map.Entry<String, Cookie> cookieEntry : cookies) {\r\n                cookiesList.add(cookieEntry.getValue());\r\n            }\r\n\r\n            // add all cookies to the HttpRequest object\r\n            httpRequest.cookies(cookiesList.toArray(new Cookie[0]));\r\n        }\r\n    }"}, {"ID": 1334, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String sendMail(final Email email) { try { final MimeMessage msg = createMessage(email); getService().sendMessage(msg, msg.getAllRecipients()); return msg.getMessageID(); } catch (final MessagingException msgexc) { throw new MailException(\"Failed to send email: \" + email, msgexc); } }\n\n    ### Response:", "ground_truth": "Prepares message and sends it. Returns Message ID of sent email.\n\n@param email {@link Email} to send.\n@return String representing message ID.", "predict": "/**\r\n     * Sends an email using the configured email service.\r\n     * \r\n     * @param email the email to send\r\n     * @return the message ID of the sent email\r\n     * @throws MailException if the email fails to send\r\n     */\r\n    public String sendMail(final Email email) {\r\n        try {\r\n            final MimeMessage msg = createMessage(email);\r\n            getService().sendMessage(msg, msg.getAllRecipients());\r\n            return msg.getMessageID();\r\n        } catch (final MessagingException msgexc) {\r\n            throw new MailException(\"Failed to send email: \" + email, msgexc);\r\n        }\r\n    }"}, {"ID": 1335, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setSubject(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { if (emailWithData.subjectEncoding() != null) { msgToSet.setSubject(emailWithData.subject(), emailWithData.subjectEncoding()); } else { msgToSet.setSubject(emailWithData.subject()); } }\n\n    ### Response:", "ground_truth": "Sets subject in msgToSet from subject in emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "/**\r\n     * Sets the subject of the given MimeMessage object based on the subject and subject encoding of the given Email object.\r\n     * \r\n     * @param emailWithData the Email object containing the subject and subject encoding information\r\n     * @param msgToSet the MimeMessage object to set the subject for\r\n     * @throws MessagingException if there is an error setting the subject of the MimeMessage object\r\n     */\r\n    private void setSubject(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {\r\n        if (emailWithData.subjectEncoding() != null) {\r\n            msgToSet.setSubject(emailWithData.subject(), emailWithData.subjectEncoding());\r\n        } else {\r\n            msgToSet.setSubject(emailWithData.subject());\r\n        }\r\n    }"}, {"ID": 1336, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setSentDate(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { Date date = emailWithData.sentDate(); if (date == null) { date = new Date(); } msgToSet.setSentDate(date); }\n\n    ### Response:", "ground_truth": "Sets sent date in msgToSet with sent date from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "/**\r\n     * Sets the sent date of the email message to the sent date of the email object. If the sent date of the email object is null, sets the sent date of the email message to the current date.\r\n     * \r\n     * @param emailWithData the email object containing the sent date\r\n     * @param msgToSet the email message to set the sent date for\r\n     * @throws MessagingException if there is an error setting the sent date of the email message\r\n     */\r\n    private void setSentDate(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {\r\n        Date date = emailWithData.sentDate();\r\n        if (date == null) {\r\n            date = new Date();\r\n        }\r\n        msgToSet.setSentDate(date);\r\n    }"}, {"ID": 1337, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setHeaders(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final Map<String, String> headers = emailWithData.headers(); if (headers != null) { for (final Map.Entry<String, String> entry : headers.entrySet()) { msgToSet.setHeader(entry.getKey(), entry.getValue()); } } }\n\n    ### Response:", "ground_truth": "Sets headers in msgToSet with headers from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "/**\r\n     * Sets the headers of the given email to the given MimeMessage.\r\n     * \r\n     * @param emailWithData\r\n     *            the email with headers to set\r\n     * @param msgToSet\r\n     *            the MimeMessage to set the headers to\r\n     * @throws MessagingException\r\n     *             if there is an error setting the headers\r\n     */\r\n    private void setHeaders(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {\r\n        final Map<String, String> headers = emailWithData.headers();\r\n        if (headers != null) {\r\n            for (final Map.Entry<String, String> entry : headers.entrySet()) {\r\n                msgToSet.setHeader(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n    }"}, {"ID": 1338, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { msgToSet.setFrom(emailWithData.from().toInternetAddress()); msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo())); setRecipients(emailWithData, msgToSet); }\n\n    ### Response:", "ground_truth": "Sets FROM, REPLY-TO and recipients.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": "/**\r\n     * Sets the from, reply-to, and recipients of a MimeMessage based on the data in an Email object.\r\n     * \r\n     * @param emailWithData the Email object containing the data to be used to set the MimeMessage\r\n     * @param msgToSet the MimeMessage to be modified\r\n     * @throws MessagingException if there is an error setting the message properties\r\n     */\r\n    private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {\r\n        msgToSet.setFrom(emailWithData.from().toInternetAddress());\r\n        msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo()));\r\n        setRecipients(emailWithData, msgToSet);\r\n    }"}, {"ID": 1339, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setRecipients(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { // TO final InternetAddress[] to = EmailAddress.convert(emailWithData.to()); if (to.length > 0) { msgToSet.setRecipients(RecipientType.TO, to); } // CC final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc()); if (cc.length > 0) { msgToSet.setRecipients(RecipientType.CC, cc); } // BCC final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc()); if (bcc.length > 0) { msgToSet.setRecipients(RecipientType.BCC, bcc); } }\n\n    ### Response:", "ground_truth": "Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": "/**\r\n     * Sets the recipients of the email message.\r\n     * \r\n     * @param emailWithData\r\n     *            the email with data to set the recipients for\r\n     * @param msgToSet\r\n     *            the message to set the recipients for\r\n     * @throws MessagingException\r\n     *             if there is an error setting the recipients\r\n     */\r\n    private void setRecipients(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { // TO final InternetAddress[] to = EmailAddress.convert(emailWithData.to()); if (to.length > 0) { msgToSet.setRecipients(RecipientType.TO, to); } // CC final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc()); if (cc.length > 0) { msgToSet.setRecipients(RecipientType.CC, cc); } // BCC final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc()); if (bcc.length > 0) { msgToSet.setRecipients(RecipientType.B"}, {"ID": 1340, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addBodyData(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final List<EmailMessage> messages = emailWithData.messages(); final int totalMessages = messages.size(); // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List final List<EmailAttachment<? extends DataSource>> attachments = new ArrayList<>(emailWithData.attachments()); if (attachments.isEmpty() && totalMessages == 1) { // special case: no attachments and just one content setContent(messages.get(0), msgToSet); } else { final MimeMultipart multipart = new MimeMultipart(); final MimeMultipart msgMultipart = new MimeMultipart(ALTERNATIVE); multipart.addBodyPart(getBaseBodyPart(msgMultipart)); for (final EmailMessage emailMessage : messages) { msgMultipart.addBodyPart(getBodyPart(emailMessage, attachments)); } addAnyAttachments(attachments, multipart); msgToSet.setContent(multipart); } }\n\n    ### Response:", "ground_truth": "Adds message data and attachments.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": "/**\r\n     * Adds the body data to the given MimeMessage.\r\n     * \r\n     * @param emailWithData\r\n     *            the email with data to add to the message\r\n     * @param msgToSet\r\n     *            the MimeMessage to set the body data on\r\n     * @throws MessagingException\r\n     *             if there is an error setting the body data on the message\r\n     */\r\n    private void addBodyData(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException {\r\n        final List<EmailMessage> messages = emailWithData.messages();\r\n        final int totalMessages = messages.size();\r\n        // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List\r\n        final List<EmailAttachment<? extends DataSource>> attachments = new ArrayList<>(emailWithData.attachments());\r\n        if (attachments.isEmpty() && totalMessages == 1) {\r\n            // special case: no attachments and just one content\r\n            setContent(messages.get(0), msgToSet);\r\n        } else {\r\n            final MimeMultipart multipart = new MimeMultipart();"}, {"ID": 1341, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setContent(final EmailMessage emailWithData, final Part partToSet) throws MessagingException { partToSet.setContent(emailWithData.getContent(), emailWithData.getMimeType() + CHARSET + emailWithData.getEncoding()); }\n\n    ### Response:", "ground_truth": "Sets emailWithData content into msgToSet.\n\n@param emailWithData {@link EmailMessage} with data.\n@param partToSet     {@link Part} to set data into.\n@throws MessagingException if there is a failure.", "predict": "/**\r\n     * Sets the content of the given part to the content of the given email message.\r\n     * \r\n     * @param emailWithData the email message containing the content to set\r\n     * @param partToSet the part to set the content of\r\n     * @throws MessagingException if an error occurs while setting the content of the part\r\n     */\r\n    private void setContent(final EmailMessage emailWithData, final Part partToSet) throws MessagingException {\r\n        partToSet.setContent(emailWithData.getContent(), emailWithData.getMimeType() + CHARSET + emailWithData.getEncoding());\r\n    }"}, {"ID": 1342, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MimeBodyPart createAttachmentBodyPart(final EmailAttachment<? extends DataSource> attachment) throws MessagingException { final MimeBodyPart part = new MimeBodyPart(); final String attachmentName = attachment.getEncodedName(); if (attachmentName != null) { part.setFileName(attachmentName); } part.setDataHandler(new DataHandler(attachment.getDataSource())); if (attachment.getContentId() != null) { part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV); } if (attachment.isInline()) { part.setDisposition(INLINE); } return part; }\n\n    ### Response:", "ground_truth": "Creates attachment body part. Handles regular and inline attachments.\n\n@param attachment Body part {@link EmailAttachment}.\n@return {@link MimeBodyPart} which represents body part attachment.\n@throws MessagingException if there is a failure.", "predict": "/**\r\n     * Creates a MimeBodyPart for the given attachment.\r\n     *\r\n     * @param attachment the attachment to create the MimeBodyPart for\r\n     * @return the created MimeBodyPart\r\n     * @throws MessagingException if an error occurs while creating the MimeBodyPart\r\n     */\r\n    protected MimeBodyPart createAttachmentBodyPart(final EmailAttachment<? extends DataSource> attachment) throws MessagingException {\r\n        final MimeBodyPart part = new MimeBodyPart();\r\n        final String attachmentName = attachment.getEncodedName();\r\n        if (attachmentName != null) {\r\n            part.setFileName(attachmentName);\r\n        }\r\n        part.setDataHandler(new DataHandler(attachment.getDataSource()));\r\n        if (attachment.getContentId() != null) {\r\n            part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV);\r\n        }\r\n        if (attachment.isInline()) {\r\n            part.setDisposition(INLINE);\r\n        }\r\n        return part;\r\n    }"}, {"ID": 1343, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String getContentType(final String dataHeader) { String token = \"Content-Type:\"; int start = dataHeader.indexOf(token); if (start == -1) { return StringPool.EMPTY; } start += token.length(); return dataHeader.substring(start).trim(); }\n\n    ### Response:", "ground_truth": "Strips content type information from requests data header.\n@param dataHeader data header string\n@return content type or an empty string if no content type defined", "predict": "/**\r\n     * This method extracts the content type from the data header.\r\n     * \r\n     * @param dataHeader the data header from which the content type needs to be extracted.\r\n     * @return the content type extracted from the data header.\r\n     */\r\n    private String getContentType(final String dataHeader) {\r\n        String token = \"Content-Type:\";\r\n        int start = dataHeader.indexOf(token);\r\n        if (start == -1) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        start += token.length();\r\n        return dataHeader.substring(start).trim();\r\n    }"}, {"ID": 1344, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void saveResultSet(final ResultSet rs) { if (resultSets == null) { resultSets = new HashSet<>(); } resultSets.add(rs); }\n\n    ### Response:", "ground_truth": "Stores result set.", "predict": "/**\r\n     * Saves the given ResultSet object in a HashSet to be used later.\r\n     * \r\n     * @param rs The ResultSet object to be saved.\r\n     */\r\n    protected void saveResultSet(final ResultSet rs) {\r\n        if (resultSets == null) {\r\n            resultSets = new HashSet<>();\r\n        }\r\n        resultSets.add(rs);\r\n    }"}, {"ID": 1345, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q closeAllResultSets() { final SQLException sex = closeQueryResultSets(); if (sex != null) { throw new DbSqlException(\"Close associated ResultSets error\", sex); } return _this(); }\n\n    ### Response:", "ground_truth": "Closes all result sets created by this query. Query remains active.", "predict": "/**\r\n     * Closes all associated ResultSets and returns the current Query object.\r\n     * \r\n     * @return the current Query object\r\n     * @throws DbSqlException if an error occurs while closing associated ResultSets\r\n     */\r\n    public Q closeAllResultSets() {\r\n        final SQLException sex = closeQueryResultSets();\r\n        if (sex != null) {\r\n            throw new DbSqlException(\"Close associated ResultSets error\", sex);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 1346, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SQLException closeQuery() { SQLException sqlException = closeQueryResultSets(); if (statement != null) { try { statement.close(); } catch (SQLException sex) { if (sqlException == null) { sqlException = sex; } else { sqlException.setNextException(sex); } } statement = null; } query = null; queryState = CLOSED; return sqlException; }\n\n    ### Response:", "ground_truth": "Closes all assigned result sets and then closes the query. Query becomes closed.", "predict": "/**\r\n     * Closes the query and releases any resources associated with it.\r\n     *\r\n     * @return any SQLExceptions that occurred during closing\r\n     */\r\n    protected SQLException closeQuery() {\r\n        SQLException sqlException = closeQueryResultSets();\r\n        if (statement != null) {\r\n            try {\r\n                statement.close();\r\n            } catch (SQLException sex) {\r\n                if (sqlException == null) {\r\n                    sqlException = sex;\r\n                } else {\r\n                    sqlException.setNextException(sex);\r\n                }\r\n            }\r\n            statement = null;\r\n        }\r\n        query = null;\r\n        queryState = CLOSED;\r\n        return sqlException;\r\n    }"}, {"ID": 1347, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings({\"ClassReferencesSubclass\"}) public void close() { final SQLException sqlException = closeQuery(); connection = null; if (this.session != null) { this.session.detachQuery(this); } if (sqlException != null) { throw new DbSqlException(\"Close query error\", sqlException); } }\n\n    ### Response:", "ground_truth": "Closes the query and all created results sets and detaches itself from the session.", "predict": "/**\r\n     * Closes the query and detaches it from the session.\r\n     *\r\n     * @throws DbSqlException if there is an error closing the query.\r\n     */\r\n    @Override\r\n    @SuppressWarnings({\"ClassReferencesSubclass\"})\r\n    public void close() {\r\n        final SQLException sqlException = closeQuery();\r\n        connection = null;\r\n        if (this.session != null) {\r\n            this.session.detachQuery(this);\r\n        }\r\n        if (sqlException != null) {\r\n            throw new DbSqlException(\"Close query error\", sqlException);\r\n        }\r\n    }"}, {"ID": 1348, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setFetchSize(final int rows) { checkNotClosed(); this.fetchSize = rows; if (statement != null) { try { statement.setFetchSize(fetchSize); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex); } } return _this(); }\n\n    ### Response:", "ground_truth": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when\nmore rows are needed. The number of rows specified affects only result sets created using this statement.\nIf the value specified is zero, then the hint is ignored. The default value is zero.\n@see Statement#setFetchSize(int)", "predict": "/**\r\n     * Sets the fetch size for the underlying statement.\r\n     *\r\n     * @param rows the number of rows to fetch\r\n     * @return this Query object\r\n     * @throws DbSqlException if there is an error setting the fetch size\r\n     */\r\n    public Q setFetchSize(final int rows) {\r\n        checkNotClosed();\r\n        this.fetchSize = rows;\r\n        if (statement != null) {\r\n            try {\r\n                statement.setFetchSize(fetchSize);\r\n            } catch (SQLException sex) {\r\n                throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex);\r\n            }\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 1349, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setMaxRows(final int maxRows) { checkNotClosed(); this.maxRows = maxRows; if (statement != null) { try { statement.setMaxRows(maxRows); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex); } } return _this(); }\n\n    ### Response:", "ground_truth": "Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.\nIf the limit is exceeded, the excess rows are silently dropped. Zero means there is no limit.\n@see Statement#setMaxRows(int)", "predict": "/**\n     * Sets the maximum number of rows that any ResultSet produced by this Statement can contain.\n     *\n     * @param maxRows the maximum number of rows, or 0 for unlimited\n     * @return this Query object\n     * @throws DbSqlException if there is an error setting the maximum number of rows\n     */\n    public Q setMaxRows(final int maxRows) {\n        checkNotClosed();\n        this.maxRows = maxRows;\n        if (statement != null) {\n            try {\n                statement.setMaxRows(maxRows);\n            } catch (SQLException sex) {\n                throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex);\n            }\n        }\n        return _this();\n    }"}, {"ID": 1350, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int executeUpdate(final boolean closeQuery) { start = System.currentTimeMillis(); init(); final int result; if (log.isDebugEnabled()) { log.debug(\"Executing update: \" + getQueryString()); } try { if (preparedStatement == null) { if (generatedColumns != null) { if (generatedColumns.length == 0) { result = statement.executeUpdate(query.sql, Statement.RETURN_GENERATED_KEYS); } else { result = statement.executeUpdate(query.sql, generatedColumns); } } else { result = statement.executeUpdate(query.sql); } } else { result = preparedStatement.executeUpdate(); } } catch (SQLException sex) { throw new DbSqlException(this, \"Query execution failed\", sex); } if (closeQuery) { close(); } elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return result; }\n\n    ### Response:", "ground_truth": "Executes UPDATE, INSERT or DELETE queries and optionally closes the query.\n@see Statement#executeUpdate(String)", "predict": "/**\r\n     * Executes an update query and returns the number of affected rows.\r\n     *\r\n     * @param closeQuery if true, the query will be closed after execution\r\n     * @return the number of affected rows\r\n     * @throws DbSqlException if the query execution fails\r\n     */\r\n    protected int executeUpdate(final boolean closeQuery) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1351, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected long executeCount(final boolean close) { start = System.currentTimeMillis(); init(); ResultSet rs = null; if (log.isDebugEnabled()) { log.debug(\"Executing prepared count: \" + getQueryString()); } try { if (preparedStatement == null) { rs = statement.executeQuery(query.sql); } else { rs = preparedStatement.executeQuery(); } final long firstLong = DbUtil.getFirstLong(rs); elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return firstLong; } catch (SQLException sex) { throw new DbSqlException(this, \"Count query failed\", sex); } finally { DbUtil.close(rs); if (close) { close(); } } }\n\n    ### Response:", "ground_truth": "Executes count queries and optionally closes query afterwards.", "predict": "/**\r\n     * Executes the count query and returns the first long value.\r\n     * \r\n     * @param close\r\n     *            whether to close the statement and connection after execution\r\n     * @return the first long value returned by the query\r\n     * @throws DbSqlException\r\n     *             if the query fails\r\n     */\r\n    protected long executeCount(final boolean close) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1352, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ResultSet getGeneratedColumns() { checkInitialized(); if (generatedColumns == null) { throw new DbSqlException(this, \"No column is specified as auto-generated\"); } final ResultSet rs; try { rs = statement.getGeneratedKeys(); } catch (SQLException sex) { throw new DbSqlException(this, \"No generated keys\", sex); } saveResultSet(rs); totalOpenResultSetCount++; return rs; }\n\n    ### Response:", "ground_truth": "Returns generated columns.", "predict": "/**\r\n     * Retrieves a result set with the auto-generated keys for the last executed statement.\r\n     * \r\n     * @return a result set with the auto-generated keys for the last executed statement.\r\n     * @throws DbSqlException if there is no column specified as auto-generated or if there is an error retrieving the generated keys.\r\n     */\r\n    public ResultSet getGeneratedColumns() {\r\n        checkInitialized();\r\n        if (generatedColumns == null) {\r\n            throw new DbSqlException(this, \"No column is specified as auto-generated\");\r\n        }\r\n        final ResultSet rs;\r\n        try {\r\n            rs = statement.getGeneratedKeys();\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(this, \"No generated keys\", sex);\r\n        }\r\n        saveResultSet(rs);\r\n        totalOpenResultSetCount++;\r\n        return rs;\r\n    }"}, {"ID": 1353, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getQueryString() { if (debug) { if ((callableStatement != null)) { if (preparedStatement instanceof LoggableCallableStatement) { return ((LoggableCallableStatement) callableStatement).getQueryString(); } } if (preparedStatement != null) { if (preparedStatement instanceof LoggablePreparedStatement) { return ((LoggablePreparedStatement) preparedStatement).getQueryString(); } } } if (query != null) { return query.sql; } return sqlString; }\n\n    ### Response:", "ground_truth": "Returns query SQL string. For prepared statements, returned sql string with quick-and-dirty replaced values.", "predict": "/**\r\n     * Returns the query string for the current statement.\r\n     * \r\n     * @return the query string for the current statement.\r\n     */\r\n    public String getQueryString() {\r\n        // TODO: Implement logic to return the query string for the current statement.\r\n    }"}, {"ID": 1354, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T proxyOf(final T target, final Class<? extends Aspect> aspectClass) { final Aspect aspect; try { aspect = ClassUtil.newInstance(aspectClass, target); } catch (Exception e) { throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e); } return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces()); }\n\n    ### Response:", "ground_truth": "Creates a proxy of given target and the aspect.", "predict": "/**\r\n     * Creates a proxy instance of the target object with the specified aspect.\r\n     * \r\n     * @param <T> the type of the target object\r\n     * @param target the target object to be proxied\r\n     * @param aspectClass the aspect class to be applied to the target object\r\n     * @return a proxy instance of the target object with the specified aspect\r\n     * @throws IllegalArgumentException if the aspect class cannot be instantiated\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static <T> T proxyOf(final T target, final Class<? extends Aspect> aspectClass) {\r\n        final Aspect aspect;\r\n        try {\r\n            aspect = ClassUtil.newInstance(aspectClass, target);\r\n        } catch (Exception e) {\r\n            throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e);\r\n        }\r\n        return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces());\r\n    }"}, {"ID": 1355, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Collection<T> collectionOf(final Iterator<? extends T> iterator) { final List<T> list = new ArrayList<>(); while (iterator.hasNext()) { list.add(iterator.next()); } return list; }\n\n    ### Response:", "ground_truth": "Returns a collection containing all elements of the iterator.", "predict": "/**\r\n     * Returns a collection containing all elements from the given iterator.\r\n     *\r\n     * @param <T> the type of elements in the iterator\r\n     * @param iterator the iterator to convert to a collection\r\n     * @return a collection containing all elements from the given iterator\r\n     */\r\n    public static <T> Collection<T> collectionOf(final Iterator<? extends T> iterator) {\r\n        final List<T> list = new ArrayList<>();\r\n        while (iterator.hasNext()) {\r\n            list.add(iterator.next());\r\n        }\r\n        return list;\r\n    }"}, {"ID": 1356, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Stream<T> streamOf(final Iterator<T> iterator) { return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false); }\n\n    ### Response:", "ground_truth": "Converts iterator to a stream.", "predict": "/**\r\n     * Returns a sequential Stream from the given Iterator.\r\n     *\r\n     * @param <T> the type of the stream elements\r\n     * @param iterator the iterator to create a stream from\r\n     * @return a sequential Stream from the given Iterator\r\n     */\r\n    public static <T> Stream<T> streamOf(final Iterator<T> iterator) {\r\n        return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false);\r\n    }"}, {"ID": 1357, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public int compare(final T o1, final T o2) { for (Comparator<T> comparator : comparators) { int result = comparator.compare(o1, o2); if (result != 0) { return result; } } return 0; }\n\n    ### Response:", "ground_truth": "Compares two objects starting with first comparator; if they are equals\nproceeds to the next comparator and so on.", "predict": "/**\n     * Compares two objects of type T using the comparators provided in the constructor.\n     *\n     * @param o1 the first object to be compared\n     * @param o2 the second object to be compared\n     * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second\n     * @throws NullPointerException if either argument is null and this comparator does not permit null arguments\n     */\n    @Override public int compare(final T o1, final T o2) {\n        for (Comparator<T> comparator : comparators) {\n            int result = comparator.compare(o1, o2);\n            if (result != 0) {\n                return result;\n            }\n        }\n        return 0;\n    }"}, {"ID": 1358, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PetiteConfig setDefaultWiringMode(final WiringMode defaultWiringMode) { if ((defaultWiringMode == null) || (defaultWiringMode == WiringMode.DEFAULT)) { throw new PetiteException(\"Invalid default wiring mode: \" + defaultWiringMode); } this.defaultWiringMode = defaultWiringMode; return this; }\n\n    ### Response:", "ground_truth": "Specifies default wiring mode.", "predict": "/**\r\n     * Sets the default wiring mode for this configuration.\r\n     *\r\n     * @param defaultWiringMode the default wiring mode to set, not null\r\n     * @return this configuration instance, not null\r\n     * @throws PetiteException if the default wiring mode is null or DEFAULT\r\n     */\r\n    public PetiteConfig setDefaultWiringMode(final WiringMode defaultWiringMode) {\r\n        if ((defaultWiringMode == null) || (defaultWiringMode == WiringMode.DEFAULT)) {\r\n            throw new PetiteException(\"Invalid default wiring mode: \" + defaultWiringMode);\r\n        }\r\n        this.defaultWiringMode = defaultWiringMode;\r\n        return this;\r\n    }"}, {"ID": 1359, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void print(final Level level, final String message, final Throwable throwable) { if (!isEnabled(level)) { return; } StringBuilder msg = new StringBuilder() .append(slf.getElapsedTime()).append(' ').append('[') .append(level).append(']').append(' ') .append(getCallerClass()).append(' ').append('-') .append(' ').append(message); System.out.println(msg.toString()); if (throwable != null) { throwable.printStackTrace(System.out); } }\n\n    ### Response:", "ground_truth": "Prints error message if level is enabled.", "predict": "/**\r\n     * Prints a message to the console with the specified level, message, and optional Throwable.\r\n     *\r\n     * @param level the logging level\r\n     * @param message the message to log\r\n     * @param throwable the optional Throwable to log\r\n     */\r\n    protected void print(final Level level, final String message, final Throwable throwable) {\r\n        if (!isEnabled(level)) {\r\n            return;\r\n        }\r\n        StringBuilder msg = new StringBuilder()\r\n                .append(slf.getElapsedTime())\r\n                .append(' ')\r\n                .append('[')\r\n                .append(level)\r\n                .append(']')\r\n                .append(' ')\r\n                .append(getCallerClass())\r\n                .append(' ')\r\n                .append('-')\r\n                .append(' ')\r\n                .append(message);\r\n        System.out.println(msg.toString());\r\n        if (throwable != null) {\r\n            throwable.printStackTrace(System.out);\r\n        }\r\n    }"}, {"ID": 1360, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String getCallerClass() { Exception exception = new Exception(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { String className = stackTraceElement.getClassName(); if (className.equals(SimpleLoggerProvider.class.getName())) { continue; } if (className.equals(SimpleLogger.class.getName())) { continue; } if (className.equals(Logger.class.getName())) { continue; } return shortenClassName(className) + '.' + stackTraceElement.getMethodName() + ':' + stackTraceElement.getLineNumber(); } return \"N/A\"; }\n\n    ### Response:", "ground_truth": "Returns called class.", "predict": "/**\r\n     * Returns the class and method name of the caller of the current method.\r\n     *\r\n     * @return the class and method name of the caller of the current method, or \"N/A\" if the caller could not be determined\r\n     */\r\n    protected String getCallerClass() {\r\n        // code goes here\r\n    }"}, {"ID": 1361, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String shortenClassName(final String className) { int lastDotIndex = className.lastIndexOf('.'); if (lastDotIndex == -1) { return className; } StringBuilder shortClassName = new StringBuilder(className.length()); int start = 0; while(true) { shortClassName.append(className.charAt(start)); int next = className.indexOf('.', start); if (next == lastDotIndex) { break; } start = next + 1; shortClassName.append('.'); } shortClassName.append(className.substring(lastDotIndex)); return shortClassName.toString(); }\n\n    ### Response:", "ground_truth": "Returns shorten class name.", "predict": "/**\r\n     * This method takes a fully qualified class name as input and returns a shortened version of the class name.\r\n     * \r\n     * @param className The fully qualified class name to be shortened.\r\n     * @return A shortened version of the class name.\r\n     */\r\n    protected String shortenClassName(final String className) {\r\n        int lastDotIndex = className.lastIndexOf('.');\r\n        if (lastDotIndex == -1) {\r\n            return className;\r\n        }\r\n        StringBuilder shortClassName = new StringBuilder(className.length());\r\n        int start = 0;\r\n        while(true) {\r\n            shortClassName.append(className.charAt(start));\r\n            int next = className.indexOf('.', start);\r\n            if (next == lastDotIndex) {\r\n                break;\r\n            }\r\n            start = next + 1;\r\n            shortClassName.append('.');\r\n        }\r\n        shortClassName.append(className.substring(lastDotIndex));\r\n        return shortClassName.toString();\r\n    }"}, {"ID": 1362, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonSerializer excludeTypes(final Class... types) { if (excludedTypes == null) { excludedTypes = types; } else { excludedTypes = ArraysUtil.join(excludedTypes, types); } return this; }\n\n    ### Response:", "ground_truth": "Excludes types. Supports interfaces and subclasses as well.", "predict": "/**\r\n     * Excludes the specified types from serialization.\r\n     *\r\n     * @param types the types to exclude\r\n     * @return this serializer\r\n     */\r\n    public JsonSerializer excludeTypes(final Class... types) {\r\n        if (excludedTypes == null) {\r\n            excludedTypes = types;\r\n        } else {\r\n            excludedTypes = ArraysUtil.join(excludedTypes, types);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1363, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void serialize(final Object source, final Appendable target) { JsonContext jsonContext = createJsonContext(target); jsonContext.serialize(source); }\n\n    ### Response:", "ground_truth": "Serializes object into provided appendable.", "predict": "/**\r\n     * Serializes the given object to the given Appendable using JSON format.\r\n     * \r\n     * @param source the object to be serialized\r\n     * @param target the Appendable to which the serialized object will be written\r\n     */\r\n    public void serialize(final Object source, final Appendable target) {\r\n        JsonContext jsonContext = createJsonContext(target);\r\n        jsonContext.serialize(source);\r\n    }"}, {"ID": 1364, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String serialize(final Object source) { FastCharBuffer fastCharBuffer = new FastCharBuffer(); serialize(source, fastCharBuffer); return fastCharBuffer.toString(); }\n\n    ### Response:", "ground_truth": "Serializes object into source.", "predict": "/**\r\n     * Serializes the given object to a string using the FastCharBuffer class.\r\n     *\r\n     * @param source the object to be serialized\r\n     * @return the serialized string\r\n     */\r\n    public String serialize(final Object source) {\r\n        FastCharBuffer fastCharBuffer = new FastCharBuffer();\r\n        serialize(source, fastCharBuffer);\r\n        return fastCharBuffer.toString();\r\n    }"}, {"ID": 1365, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream out = null; ObjectInputStream in = null; Object objCopy = null; try { out = new ObjectOutputStream(bos); out.writeObject(obj); out.flush(); byte[] bytes = bos.toByteArray(); in = new ObjectInputStream(new ByteArrayInputStream(bytes)); objCopy = in.readObject(); } finally { StreamUtil.close(out); StreamUtil.close(in); } return (T) objCopy; }\n\n    ### Response:", "ground_truth": "Create object copy using serialization mechanism.", "predict": "/**\n     * Clones the given object using serialization.\n     *\n     * @param obj the object to clone\n     * @param <T> the type of the object\n     * @return the cloned object\n     * @throws IOException if an I/O error occurs during serialization or deserialization\n     * @throws ClassNotFoundException if a class cannot be found during deserialization\n     */\n    public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException {\n        // implementation details elided\n    }"}, {"ID": 1366, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeObject(final File dest, final Object object) throws IOException { FileOutputStream fos = null; BufferedOutputStream bos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(dest); bos = new BufferedOutputStream(fos); oos = new ObjectOutputStream(bos); oos.writeObject(object); } finally { StreamUtil.close(oos); StreamUtil.close(bos); StreamUtil.close(fos); } }\n\n    ### Response:", "ground_truth": "Writes serializable object to a file. Existing file will be overwritten.", "predict": "/**\r\n     * Writes the specified object to the specified file using Java serialization.\r\n     *\r\n     * @param dest the file to write to\r\n     * @param object the object to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void writeObject(final File dest, final Object object) throws IOException {\r\n        FileOutputStream fos = null;\r\n        BufferedOutputStream bos = null;\r\n        ObjectOutputStream oos = null;\r\n        try {\r\n            fos = new FileOutputStream(dest);\r\n            bos = new BufferedOutputStream(fos);\r\n            oos = new ObjectOutputStream(bos);\r\n            oos.writeObject(object);\r\n        } finally {\r\n            StreamUtil.close(oos);\r\n            StreamUtil.close(bos);\r\n            StreamUtil.close(fos);\r\n        }\r\n    }"}, {"ID": 1367, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object readObject(final File source) throws IOException, ClassNotFoundException { Object result = null; FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; try { fis = new FileInputStream(source); bis = new BufferedInputStream(fis); ois = new ObjectInputStream(bis); result = ois.readObject(); } finally { StreamUtil.close(ois); StreamUtil.close(bis); StreamUtil.close(fis); } return result; }\n\n    ### Response:", "ground_truth": "Reads serialized object from the file.", "predict": "/**\r\n     * Reads an object from a file.\r\n     * \r\n     * @param source the file to read from\r\n     * @return the object read from the file\r\n     * @throws IOException if an I/O error occurs\r\n     * @throws ClassNotFoundException if a class cannot be found\r\n     */\r\n    public static Object readObject(final File source) throws IOException, ClassNotFoundException {\r\n        Object result = null;\r\n        FileInputStream fis = null;\r\n        BufferedInputStream bis = null;\r\n        ObjectInputStream ois = null;\r\n        try {\r\n            fis = new FileInputStream(source);\r\n            bis = new BufferedInputStream(fis);\r\n            ois = new ObjectInputStream(bis);\r\n            result = ois.readObject();\r\n        } finally {\r\n            StreamUtil.close(ois);\r\n            StreamUtil.close(bis);\r\n            StreamUtil.close(fis);\r\n        }\r\n        return result;\r\n    }"}, {"ID": 1368, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] objectToByteArray(final Object obj) throws IOException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(bos); oos.writeObject(obj); } finally { StreamUtil.close(oos); } return bos.toByteArray(); }\n\n    ### Response:", "ground_truth": "Serialize an object to byte array.", "predict": "/**\r\n     * Converts an object to a byte array using ObjectOutputStream.\r\n     *\r\n     * @param obj the object to be serialized\r\n     * @return the byte array representation of the object\r\n     * @throws IOException if an I/O error occurs during serialization\r\n     */\r\n    public static byte[] objectToByteArray(final Object obj) throws IOException {\r\n        FastByteArrayOutputStream bos = new FastByteArrayOutputStream();\r\n        ObjectOutputStream oos = null;\r\n        try {\r\n            oos = new ObjectOutputStream(bos);\r\n            oos.writeObject(obj);\r\n        } finally {\r\n            StreamUtil.close(oos);\r\n        }\r\n        return bos.toByteArray();\r\n    }"}, {"ID": 1369, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException { Object retObj = null; ByteArrayInputStream bais = new ByteArrayInputStream(data); ObjectInputStream ois = null; try { ois = new ObjectInputStream(bais); retObj = ois.readObject(); } finally { StreamUtil.close(ois); } return retObj; }\n\n    ### Response:", "ground_truth": "De-serialize an object from byte array.", "predict": "/**\r\n     * Converts a byte array to an object using ObjectInputStream.\r\n     * \r\n     * @param data\r\n     *            the byte array to be converted\r\n     * @return the object obtained from the byte array\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     * @throws ClassNotFoundException\r\n     *             if a class cannot be found\r\n     */\r\n    public static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException {\r\n        Object retObj = null;\r\n        ByteArrayInputStream bais = new ByteArrayInputStream(data);\r\n        ObjectInputStream ois = null;\r\n        try {\r\n            ois = new ObjectInputStream(bais);\r\n            retObj = ois.readObject();\r\n        } finally {\r\n            StreamUtil.close(ois);\r\n        }\r\n        return retObj;\r\n    }"}, {"ID": 1370, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[][] resolveMappedTypesTableNames(final Class[] types) { if (cachedMappedNames == null) { String[][] names = new String[types.length][]; for (int i = 0; i < types.length; i++) { Class type = types[i]; if (type != null) { DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded != null) { Class[] mappedTypes = ded.getMappedTypes(); if (mappedTypes != null) { names[i] = createTypesTableNames(mappedTypes); } } } } cachedMappedNames = names; } return cachedMappedNames; }\n\n    ### Response:", "ground_truth": "Resolved mapped type names for each type.", "predict": "/**\r\n     * Resolves the table names for the mapped types of the given types.\r\n     * \r\n     * @param types\r\n     *            The types to resolve the table names for.\r\n     * @return The table names for the mapped types of the given types.\r\n     */\r\n    protected String[][] resolveMappedTypesTableNames(final Class[] types) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n    }"}, {"ID": 1371, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] createTypesTableNames(final Class[] types) { String[] names = new String[types.length]; for (int i = 0; i < types.length; i++) { if (types[i] == null) { names[i] = null; continue; } DbEntityDescriptor ded = dbEntityManager.lookupType(types[i]); if (ded != null) { String tableName = ded.getTableName(); tableName = tableName.toUpperCase(); names[i] = tableName; } } return names; }\n\n    ### Response:", "ground_truth": "Creates table names for given types.", "predict": "/**\r\n     * This method creates an array of table names for the given types.\r\n     * \r\n     * @param types\r\n     *            The types for which table names are to be generated.\r\n     * @return An array of table names for the given types.\r\n     */\r\n    protected String[] createTypesTableNames(final Class[] types) {\r\n        String[] names = new String[types.length];\r\n        for (int i = 0; i < types.length; i++) {\r\n            if (types[i] == null) {\r\n                names[i] = null;\r\n                continue;\r\n            }\r\n            DbEntityDescriptor ded = dbEntityManager.lookupType(types[i]);\r\n            if (ded != null) {\r\n                String tableName = ded.getTableName();\r\n                tableName = tableName.toUpperCase();\r\n                names[i] = tableName;\r\n            }\r\n        }\r\n        return names;\r\n    }"}, {"ID": 1372, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) protected Object readColumnValue(final int colNdx, final Class destinationType, final Class<? extends SqlType> sqlTypeClass, final int columnDbSqlType) { if (colNdx != cachedColumnNdx) { try { SqlType sqlType; if (sqlTypeClass != null) { sqlType = SqlTypeManager.get().lookupSqlType(sqlTypeClass); } else { sqlType = SqlTypeManager.get().lookup(destinationType); } if (sqlType != null) { cachedColumnValue = sqlType.readValue(resultSet, colNdx + 1, destinationType, columnDbSqlType); } else { cachedColumnValue = resultSet.getObject(colNdx + 1); cachedColumnValue = TypeConverterManager.get().convertType(cachedColumnValue, destinationType); } } catch (SQLException sex) { throw new DbOomException(dbOomQuery, \"Invalid value for column #\" + (colNdx + 1), sex); } cachedColumnNdx = colNdx; } return cachedColumnValue; }\n\n    ### Response:", "ground_truth": "Reads column value from result set. Since this method may be called more then once for\nthe same column, it caches column values.", "predict": "/**\n     * Reads the value of the specified column from the current row of the result set and converts it to the specified type.\n     *\n     * @param colNdx the index of the column to read (0-based)\n     * @param destinationType the type to convert the column value to\n     * @param sqlTypeClass the class of the SQL type to use for conversion, or null to use the default SQL type for the destination type\n     * @param columnDbSqlType the SQL type of the column, or 0 if unknown\n     * @return the converted column value\n     * @throws DbOomException if an error occurs while reading or converting the column value\n     */\n    protected Object readColumnValue(final int colNdx, final Class destinationType, final Class<? extends SqlType> sqlTypeClass, final int columnDbSqlType) { }"}, {"ID": 1373, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void cacheResultSetEntities(final Object[] result) { if (entitiesCache == null) { entitiesCache = new HashMap<>(); } for (int i = 0; i < result.length; i++) { Object object = result[i]; if (object == null) { continue; } DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded == null) { // not a type, continue continue; } // calculate key Object key; if (ded.hasIdColumn()) { //noinspection unchecked key = ded.getKeyValue(object); } else { key = object; } Object cachedObject = entitiesCache.get(key); if (cachedObject == null) { // object is not in the cache, add it entitiesCache.put(key, object); } else { // object is in the cache, replace it result[i] = cachedObject; } } }\n\n    ### Response:", "ground_truth": "Caches returned entities. Replaces new instances with existing ones.", "predict": "/**\r\n     * Caches the result set entities in the entities cache.\r\n     *\r\n     * @param result the result set entities to cache\r\n     */\r\n    protected void cacheResultSetEntities(final Object[] result) {\r\n        if (entitiesCache == null) {\r\n            entitiesCache = new HashMap<>();\r\n        }\r\n        for (int i = 0; i < result.length; i++) {\r\n            Object object = result[i];\r\n            if (object == null) {\r\n                continue;\r\n            }\r\n            DbEntityDescriptor ded = cachedDbEntityDescriptors[i];\r\n            if (ded == null) {\r\n                // not a type, continue\r\n                continue;\r\n            }\r\n            // calculate key\r\n            Object key;\r\n            if (ded.hasIdColumn()) {\r\n                //noinspection unchecked\r\n                key = ded.getKeyValue(object);\r\n            } else {\r\n                key = object;\r\n            }\r\n            Object cachedObject = entitiesCache.get(key);\r\n            if (cachedObject == null) {\r\n                // object is not in the cache, add it\r\n                entitiesCache.put("}, {"ID": 1374, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProviderDefinition[] resolve(final Class type, final String name) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor[] methods = cd.getAllMethodDescriptors(); List<ProviderDefinition> list = new ArrayList<>(); for (MethodDescriptor methodDescriptor : methods) { Method method = methodDescriptor.getMethod(); PetiteProvider petiteProvider = method.getAnnotation(PetiteProvider.class); if (petiteProvider == null) { continue; } String providerName = petiteProvider.value(); if (StringUtil.isBlank(providerName)) { // default provider name providerName = method.getName(); if (providerName.endsWith(\"Provider\")) { providerName = StringUtil.substring(providerName, 0, -8); } } ProviderDefinition providerDefinition; if (Modifier.isStatic(method.getModifiers())) { providerDefinition = new ProviderDefinition(providerName, method); } else { providerDefinition = new ProviderDefinition(providerName, name, method); } list.add(providerDefinition); } ProviderDefinition[] providers; if (list.isEmpty()) { providers = ProviderDefinition.EMPTY; } else { providers = list.toArray(new ProviderDefinition[0]); } return providers; }\n\n    ### Response:", "ground_truth": "Resolves all providers in the class", "predict": "/**\n     * Resolves the provider definitions for the given type and name.\n     *\n     * @param type the type to resolve providers for\n     * @param name the name to resolve providers for\n     * @return the array of provider definitions\n     */\n    public ProviderDefinition[] resolve(final Class type, final String name) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1375, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String applyToTableName(final String tableName) { String entityName = convertTableNameToEntityName(tableName); return convertEntityNameToTableName(entityName); }\n\n    ### Response:", "ground_truth": "Applies table naming strategy to given table name hint.\nReturns full table name.", "predict": "/**\r\n     * This method takes a table name as input and returns the corresponding entity name.\r\n     *\r\n     * @param tableName The name of the table to be converted.\r\n     * @return The name of the corresponding entity.\r\n     */\r\n    public String applyToTableName(final String tableName) {\r\n        String entityName = convertTableNameToEntityName(tableName);\r\n        return convertEntityNameToTableName(entityName);\r\n    }"}, {"ID": 1376, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean isConnectionValid(final ConnectionData connectionData, final long now) { if (!validateConnection) { return true; } if (now < connectionData.lastUsed + validationTimeout) { return true; } Connection conn = connectionData.connection; if (validationQuery == null) { try { return !conn.isClosed(); } catch (SQLException sex) { return false; } } boolean valid = true; Statement st = null; try { st = conn.createStatement(); st.execute(validationQuery); } catch (SQLException sex) { valid = false; } finally { if (st != null) { try { st.close(); } catch (SQLException ignore) { } } } return valid; }\n\n    ### Response:", "ground_truth": "Checks if existing connection is valid and available. It may happens\nthat if connection is not used for a while it becomes inactive,\nalthough not technically closed.", "predict": "/**\r\n     * Checks if the connection is valid.\r\n     *\r\n     * @param connectionData the connection data\r\n     * @param now the current time\r\n     * @return true if the connection is valid, false otherwise\r\n     */\r\n    private boolean isConnectionValid(final ConnectionData connectionData, final long now) {\r\n        if (!validateConnection) {\r\n            return true;\r\n        }\r\n        if (now < connectionData.lastUsed + validationTimeout) {\r\n            return true;\r\n        }\r\n        Connection conn = connectionData.connection;\r\n        if (validationQuery == null) {\r\n            try {\r\n                return !conn.isClosed();\r\n            } catch (SQLException sex) {\r\n                return false;\r\n            }\r\n        }\r\n        boolean valid = true;\r\n        Statement st = null;\r\n        try {\r\n            st = conn.createStatement();\r\n            st.execute(validationQuery);\r\n        } catch (SQLException sex) {\r\n            valid = false;\r\n        } finally {\r\n            if (st != null) {\r\n                try {\r\n                    st.close();\r\n                } catch (SQLException ignore) {\r\n                }\r\n            }"}, {"ID": 1377, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void renderView(final ActionRequest actionRequest, final String target) throws Exception { HttpServletRequest request = actionRequest.getHttpServletRequest(); HttpServletResponse response = actionRequest.getHttpServletResponse(); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if (dispatcher == null) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + target); // should never happened return; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if (DispatcherUtil.isPageIncluded(request, response)) { dispatcher.include(request, response); } else { dispatcher.forward(request, response); } }\n\n    ### Response:", "ground_truth": "Renders the view by dispatching to the target JSP.", "predict": "/**\r\n     * This method overrides the renderView method of the AbstractDispatcherServlet class.\r\n     * It takes an ActionRequest object and a target string as input parameters.\r\n     * It uses the getHttpServletRequest() and getHttpServletResponse() methods of the ActionRequest object to get the corresponding HTTP request and response objects.\r\n     * It then uses the getRequestDispatcher() method of the HTTP request object to get a RequestDispatcher object for the target string.\r\n     * If the RequestDispatcher object is null, it sends an error response to the client with a 404 status code and a message indicating that the result was not found.\r\n     * If the RequestDispatcher object is not null, it checks if the request is for an included page or a forwarded page.\r\n     * If the request is for an included page, it uses the include() method of the RequestDispatcher object to include the view.\r\n     * If the request is for a forwarded page, it uses the forward() method of the RequestDispatcher object to forward the request to the target page.\r\n     * @param actionRequest An"}, {"ID": 1378, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected String locateTarget(final ActionRequest actionRequest, String path) { String target; if (path.endsWith(StringPool.SLASH)) { path = path + defaultViewPageName; } for (final String ext : defaultViewExtensions) { target = path + ext; if (targetExists(actionRequest, target)) { return target; } } return null; }\n\n    ### Response:", "ground_truth": "Locates target using path with various extensions appended.", "predict": "/**\r\n     * Locates the target view for the given action request and path.\r\n     *\r\n     * @param actionRequest the action request\r\n     * @param path the path to the target view\r\n     * @return the target view, or null if not found\r\n     */\r\n    @Override\r\n    protected String locateTarget(final ActionRequest actionRequest, String path) {\r\n        String target;\r\n        if (path.endsWith(StringPool.SLASH)) {\r\n            path = path + defaultViewPageName;\r\n        }\r\n        for (final String ext : defaultViewExtensions) {\r\n            target = path + ext;\r\n            if (targetExists(actionRequest, target)) {\r\n                return target;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1379, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); }\n\n    ### Response:", "ground_truth": "Returns buffered writer if buffering is enabled,\notherwise returns the original writer.", "predict": "/**\r\n     * Returns a PrintWriter object that can be used to send character data to the client.\r\n     * \r\n     * @return a PrintWriter object that can be used to send character data to the client.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    @Override public PrintWriter getWriter() throws IOException {\r\n        preResponseCommit();\r\n        if (buffer == null) {\r\n            return getResponse().getWriter();\r\n        }\r\n        return buffer.getWriter();\r\n    }"}, {"ID": 1380, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public ServletOutputStream getOutputStream() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getOutputStream(); } return buffer.getOutputStream(); }\n\n    ### Response:", "ground_truth": "Returns buffered output stream if buffering is enabled,\notherwise returns the original stream.", "predict": "/**\r\n     * @throws IOException\r\n     * @see javax.servlet.ServletResponse#getOutputStream()\r\n     */\r\n    @Override\r\n    public ServletOutputStream getOutputStream() throws IOException {\r\n        preResponseCommit();\r\n        if (buffer == null) {\r\n            return getResponse().getOutputStream();\r\n        }\r\n        return buffer.getOutputStream();\r\n    }"}, {"ID": 1381, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeContentToResponse(final char[] content) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUtil.toByteArray(content)); } else { outputStream.write(CharUtil.toByteArray(content, encoding)); } outputStream.flush(); } else { Writer out = getResponse().getWriter(); out.write(content); out.flush(); } }\n\n    ### Response:", "ground_truth": "Writes content to original output stream, using either output stream or writer, depending\non how the content was buffered. It is assumed that provided content is a modified\nwrapped content.", "predict": "/**\r\n     * Writes the given content to the response.\r\n     * \r\n     * @param content the content to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void writeContentToResponse(final char[] content) throws IOException;"}, {"ID": 1382, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void setContentType(final String type) { super.setContentType(type); contentTypeResolver = new ContentTypeHeaderResolver(type); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } }\n\n    ### Response:", "ground_truth": "Sets the content type and enables or disables buffering.", "predict": "/**\r\n     * Sets the content type of the response.\r\n     * \r\n     * @param type the content type of the response\r\n     */\r\n    @Override\r\n    public void setContentType(final String type) {\r\n        super.setContentType(type);\r\n        contentTypeResolver = new ContentTypeHeaderResolver(type);\r\n        if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) {\r\n            enableBuffering();\r\n        } else {\r\n            disableBuffering();\r\n        }\r\n    }"}, {"ID": 1383, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void print(final String string) throws IOException { if (isBufferStreamBased()) { String encoding = getContentTypeEncoding(); byte[] bytes; if (encoding == null) { bytes = string.getBytes(); } else { bytes = string.getBytes(encoding); } buffer.getOutputStream().write(bytes); return; } // make sure at least writer is initialized buffer.getWriter().write(string); }\n\n    ### Response:", "ground_truth": "Appends string to the buffer.", "predict": "/**\r\n     * Prints the given string to the output stream.\r\n     * \r\n     * @param string the string to print\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void print(final String string) throws IOException {\r\n        if (isBufferStreamBased()) {\r\n            String encoding = getContentTypeEncoding();\r\n            byte[] bytes;\r\n            if (encoding == null) {\r\n                bytes = string.getBytes();\r\n            } else {\r\n                bytes = string.getBytes(encoding);\r\n            }\r\n            buffer.getOutputStream().write(bytes);\r\n            return;\r\n        }\r\n        // make sure at least writer is initialized\r\n        buffer.getWriter().write(string);\r\n    }"}, {"ID": 1384, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult login() { T authToken; authToken = loginViaBasicAuth(servletRequest); if (authToken == null) { authToken = loginViaRequestParams(servletRequest); } if (authToken == null) { log.warn(\"Login failed.\"); return JsonResult.of(HttpStatus.error401().unauthorized(\"Login failed.\")); } log.info(\"login OK!\"); final UserSession<T> userSession = new UserSession<>(authToken, userAuth.tokenValue(authToken)); userSession.start(servletRequest, servletResponse); // return token return tokenAsJson(authToken); }\n\n    ### Response:", "ground_truth": "Authenticate user and start user session.", "predict": "/**\r\n     * Logs in the user and returns a JSON representation of the token.\r\n     *\r\n     * @return JSON representation of the token.\r\n     */\r\n    protected JsonResult login() {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 1385, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult tokenAsJson(final T authToken) { final JsonObject jsonObject = new JsonObject(); jsonObject.put(\"token\", userAuth.tokenValue(authToken)); return JsonResult.of(jsonObject); }\n\n    ### Response:", "ground_truth": "Prepares the JSON payload that carries on the token value.", "predict": "/**\r\n     * Converts the given authentication token to a JSON object with a \"token\" property containing the token value.\r\n     *\r\n     * @param authToken the authentication token to convert\r\n     * @return a JSON result containing the token value\r\n     */\r\n    protected JsonResult tokenAsJson(final T authToken) {\r\n        final JsonObject jsonObject = new JsonObject();\r\n        jsonObject.put(\"token\", userAuth.tokenValue(authToken));\r\n        return JsonResult.of(jsonObject);\r\n    }"}, {"ID": 1386, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T loginViaBasicAuth(final HttpServletRequest servletRequest) { final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); return userAuth.login(username, password); }\n\n    ### Response:", "ground_truth": "Tries to login user with basic authentication.", "predict": "/**\r\n     * Logs in the user using basic authentication.\r\n     * \r\n     * @param servletRequest\r\n     *            the HTTP request object\r\n     * @return the authenticated user object, or null if authentication failed\r\n     */\r\n    protected T loginViaBasicAuth(final HttpServletRequest servletRequest) {\r\n        final String username = ServletUtil.resolveAuthUsername(servletRequest);\r\n        if (username == null) {\r\n            return null;\r\n        }\r\n        final String password = ServletUtil.resolveAuthPassword(servletRequest);\r\n        return userAuth.login(username, password);\r\n    }"}, {"ID": 1387, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected JsonResult logout() { log.debug(\"logout user\"); UserSession.stop(servletRequest, servletResponse); return JsonResult.of(HttpStatus.ok()); }\n\n    ### Response:", "ground_truth": "Logout hook.", "predict": "/**\r\n     * Logs out the user by stopping the session and returning a JSON result with HTTP status code 200 OK.\r\n     *\r\n     * @return a JSON result with HTTP status code 200 OK.\r\n     */\r\n    protected JsonResult logout() {\r\n        log.debug(\"logout user\");\r\n        UserSession.stop(servletRequest, servletResponse);\r\n        return JsonResult.of(HttpStatus.ok());\r\n    }"}, {"ID": 1388, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File toContainerFile(final URL url) { String protocol = url.getProtocol(); if (protocol.equals(FILE_PROTOCOL)) { return toFile(url); } String path = url.getPath(); return new File(URI.create( path.substring(ZERO, path.lastIndexOf(\"!/\")))); }\n\n    ### Response:", "ground_truth": "Returns a file of either a folder or a containing archive.", "predict": "/**\r\n     * Converts a URL to a File object representing the container file.\r\n     *\r\n     * @param url the URL to convert\r\n     * @return the File object representing the container file\r\n     */\r\n    public static File toContainerFile(final URL url) {\r\n        String protocol = url.getProtocol();\r\n        if (protocol.equals(FILE_PROTOCOL)) {\r\n            return toFile(url);\r\n        }\r\n        String path = url.getPath();\r\n        return new File(URI.create(path.substring(ZERO, path.lastIndexOf(\"!/\"))));\r\n    }"}, {"ID": 1389, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File mkdirs(final File dirs) throws IOException { if (dirs.exists()) { checkIsDirectory(dirs); return dirs; } return checkCreateDirectory(dirs); }\n\n    ### Response:", "ground_truth": "Creates all directories at once.\n\n@param dirs Directories to make.\n@throws IOException if cannot create directory.", "predict": "/**\r\n     * Creates a new directory, including any necessary parent directories,\r\n     * and returns a reference to it.\r\n     *\r\n     * @param dirs the directory to be created\r\n     * @return a reference to the newly created directory\r\n     * @throws IOException if the directory cannot be created\r\n     */\r\n    public static File mkdirs(final File dirs) throws IOException {\r\n        if (dirs.exists()) {\r\n            checkIsDirectory(dirs);\r\n            return dirs;\r\n        }\r\n        return checkCreateDirectory(dirs);\r\n    }"}, {"ID": 1390, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File mkdir(final File dir) throws IOException { if (dir.exists()) { checkIsDirectory(dir); return dir; } return checkCreateDirectory(dir); }\n\n    ### Response:", "ground_truth": "Creates single directory.\n\n@throws IOException if cannot create directory.", "predict": "/**\r\n     * Creates a new directory, including any necessary but nonexistent parent directories.\r\n     *\r\n     * @param dir the directory to be created\r\n     * @return the directory created\r\n     * @throws IOException if the directory cannot be created\r\n     */\r\n    public static File mkdir(final File dir) throws IOException {\r\n        if (dir.exists()) {\r\n            checkIsDirectory(dir);\r\n            return dir;\r\n        }\r\n        return checkCreateDirectory(dir);\r\n    }"}, {"ID": 1391, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void _copyFile(final File srcFile, final File destFile) throws IOException { if (destFile.exists()) { if (destFile.isDirectory()) { throw new IOException(\"Destination '\" + destFile + \"' is a directory\"); } } // do copy file FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(srcFile); output = new FileOutputStream(destFile, false); StreamUtil.copy(input, output); } finally { StreamUtil.close(output); StreamUtil.close(input); } // done if (srcFile.length() != destFile.length()) { throw new IOException(\"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\"); } destFile.setLastModified(srcFile.lastModified()); }\n\n    ### Response:", "ground_truth": "Internal file copy when most of the pre-checking has passed.\n\n@param srcFile  Source {@link File}.\n@param destFile Destination {@link File}.\n@throws IOException if cannot copy", "predict": "/**\r\n     * Copies a file from the source to the destination.\r\n     * \r\n     * @param srcFile\r\n     *            the source file to copy from\r\n     * @param destFile\r\n     *            the destination file to copy to\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    private static void _copyFile(final File srcFile, final File destFile) throws IOException {\r\n        if (destFile.exists()) {\r\n            if (destFile.isDirectory()) {\r\n                throw new IOException(\"Destination '\" + destFile + \"' is a directory\");\r\n            }\r\n        }\r\n        // do copy file\r\n        FileInputStream input = null;\r\n        FileOutputStream output = null;\r\n        try {\r\n            input = new FileInputStream(srcFile);\r\n            output = new FileOutputStream(destFile, false);\r\n            StreamUtil.copy(input, output);\r\n        } finally {\r\n            StreamUtil.close(output);\r\n            StreamUtil.close(input);\r\n        }\r\n        // done\r\n        if (srcFile.length() != destFile.length()) {\r\n            throw new IOException"}, {"ID": 1392, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copyDir(final File srcDir, final File destDir) throws IOException { checkDirCopy(srcDir, destDir); _copyDirectory(srcDir, destDir); }\n\n    ### Response:", "ground_truth": "Copies directory with specified copy params.\n\n@see #_copyDirectory(File, File)", "predict": "/**\r\n     * Copies a directory from the source directory to the destination directory.\r\n     *\r\n     * @param srcDir the source directory to copy from\r\n     * @param destDir the destination directory to copy to\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void copyDir(final File srcDir, final File destDir) throws IOException {\r\n        checkDirCopy(srcDir, destDir);\r\n        _copyDirectory(srcDir, destDir);\r\n    }"}, {"ID": 1393, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File moveFileToDir(final File srcFile, final File destDir) throws IOException { checkExistsAndDirectory(destDir); return moveFile(srcFile, file(destDir, srcFile.getName())); }\n\n    ### Response:", "ground_truth": "Moves a file to a directory.\n\n@param srcFile Source {@link File}.\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": "/**\r\n     * Moves a file to a directory.\r\n     * \r\n     * @param srcFile the source file to move\r\n     * @param destDir the destination directory to move the file to\r\n     * @return the moved file\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static File moveFileToDir(final File srcFile, final File destDir) throws IOException {\r\n        checkExistsAndDirectory(destDir);\r\n        return moveFile(srcFile, file(destDir, srcFile.getName()));\r\n    }"}, {"ID": 1394, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void _moveDirectory(final File srcDest, File destDir) throws IOException { if (destDir.exists()) { checkIsDirectory(destDir); destDir = file(destDir, destDir.getName()); destDir.mkdir(); } final boolean rename = srcDest.renameTo(destDir); if (!rename) { _copyDirectory(srcDest, destDir); deleteDir(srcDest); } }\n\n    ### Response:", "ground_truth": "Moves a directory.\n\n@param srcDest Source directory\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": "/**\r\n     * Moves a directory from one location to another.\r\n     * \r\n     * @param srcDest the source directory to be moved.\r\n     * @param destDir the destination directory to move the source directory to.\r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    private static void _moveDirectory(final File srcDest, File destDir) throws IOException {\r\n        if (destDir.exists()) {\r\n            checkIsDirectory(destDir);\r\n            destDir = file(destDir, destDir.getName());\r\n            destDir.mkdir();\r\n        }\r\n        final boolean rename = srcDest.renameTo(destDir);\r\n        if (!rename) {\r\n            _copyDirectory(srcDest, destDir);\r\n            deleteDir(srcDest);\r\n        }\r\n    }"}, {"ID": 1395, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void cleanDir(final File destDir) throws IOException { checkExists(destDir); checkIsDirectory(destDir); File[] files = destDir.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of: \" + destDir); } IOException exception = null; for (File file : files) { try { if (file.isDirectory()) { deleteDir(file); } else { file.delete(); } } catch (IOException ioex) { exception = ioex; continue; } } if (exception != null) { throw exception; } }\n\n    ### Response:", "ground_truth": "Cleans a directory without deleting it.\n\n@param destDir destination to clean.\n@throws IOException if something went wrong.", "predict": "/**\r\n     * Deletes all files and subdirectories under the specified directory.\r\n     *\r\n     * @param destDir the directory to be deleted\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void cleanDir(final File destDir) throws IOException {\r\n        checkExists(destDir);\r\n        checkIsDirectory(destDir);\r\n        File[] files = destDir.listFiles();\r\n        if (files == null) {\r\n            throw new IOException(\"Failed to list contents of: \" + destDir);\r\n        }\r\n        IOException exception = null;\r\n        for (File file : files) {\r\n            try {\r\n                if (file.isDirectory()) {\r\n                    deleteDir(file);\r\n                } else {\r\n                    file.delete();\r\n                }\r\n            } catch (IOException ioex) {\r\n                exception = ioex;\r\n                continue;\r\n            }\r\n        }\r\n        if (exception != null) {\r\n            throw exception;\r\n        }\r\n    }"}, {"ID": 1396, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] readUTFChars(final File file) throws IOException { checkExists(file); checkIsFile(file); UnicodeInputStream in = unicodeInputStreamOf(file); try { return StreamUtil.readChars(in, detectEncoding(in)); } finally { StreamUtil.close(in); } }\n\n    ### Response:", "ground_truth": "Reads UTF file content as char array.\n\n@param file {@link File} to read.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": "/**\r\n     * Reads the contents of a file as a char array using the UTF-8 encoding.\r\n     *\r\n     * @param file the file to read from\r\n     * @return the contents of the file as a char array\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static char[] readUTFChars(final File file) throws IOException {\r\n        checkExists(file);\r\n        checkIsFile(file);\r\n        UnicodeInputStream in = unicodeInputStreamOf(file);\r\n        try {\r\n            return StreamUtil.readChars(in, detectEncoding(in));\r\n        } finally {\r\n            StreamUtil.close(in);\r\n        }\r\n    }"}, {"ID": 1397, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] readChars(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file, encoding); try { return StreamUtil.readChars(in, encoding); } finally { StreamUtil.close(in); } }\n\n    ### Response:", "ground_truth": "Reads file content as char array.\n\n@param file     {@link File} to read.\n@param encoding Encoding to use.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": "/**\r\n     * Reads the contents of a file into a character array using the specified encoding.\r\n     *\r\n     * @param file the file to read from\r\n     * @param encoding the encoding to use when reading the file\r\n     * @return the contents of the file as a character array\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static char[] readChars(final File file, final String encoding) throws IOException {\r\n        checkExists(file);\r\n        checkIsFile(file);\r\n        InputStream in = streamOf(file, encoding);\r\n        try {\r\n            return StreamUtil.readChars(in, encoding);\r\n        } finally {\r\n            StreamUtil.close(in);\r\n        }\r\n    }"}, {"ID": 1398, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeChars(final File dest, final char[] data, final String encoding) throws IOException { outChars(dest, data, encoding, false); }\n\n    ### Response:", "ground_truth": "Write characters. append = false\n\n@see #outChars(File, char[], String, boolean)", "predict": "/**\r\n     * Writes the given character array to the specified file using the specified encoding.\r\n     *\r\n     * @param dest the file to write to\r\n     * @param data the character array to write\r\n     * @param encoding the encoding to use\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void writeChars(final File dest, final char[] data, final String encoding) throws IOException {\r\n        outChars(dest, data, encoding, false);\r\n    }"}, {"ID": 1399, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, false); }\n\n    ### Response:", "ground_truth": "Writes String. append = false\n\n@see #outString(File, String, String, boolean)", "predict": "/**\r\n     * Writes the given string to the specified file using the specified encoding.\r\n     * \r\n     * @param dest the file to write to\r\n     * @param data the string to write\r\n     * @param encoding the encoding to use\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void writeString(final File dest, final String data, final String encoding) throws IOException {\r\n        outString(dest, data, encoding, false);\r\n    }"}, {"ID": 1400, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void appendString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, true); }\n\n    ### Response:", "ground_truth": "Appends String. append = true\n\n@see #outString(File, String, String, boolean)", "predict": "/**\r\n     * Appends the given string to the end of the file specified by the given File object.\r\n     * \r\n     * @param dest the File object representing the file to append to\r\n     * @param data the string to append to the file\r\n     * @param encoding the encoding to use when writing the string to the file\r\n     * @throws IOException if an I/O error occurs while writing to the file\r\n     */\r\n    public static void appendString(final File dest, final String data, final String encoding) throws IOException {\r\n        outString(dest, data, encoding, true);\r\n    }"}, {"ID": 1401, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] readBytes(final File file, final int count) throws IOException { checkExists(file); checkIsFile(file); long numToRead = file.length(); if (numToRead >= Integer.MAX_VALUE) { throw new IOException(\"File is larger then max array size\"); } if (count > NEGATIVE_ONE && count < numToRead) { numToRead = count; } byte[] bytes = new byte[(int) numToRead]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; }\n\n    ### Response:", "ground_truth": "Read file and returns byte array with contents.\n\n@param file  {@link File} to read\n@param count number of bytes to read\n@return byte array from {@link File} contents.\n@throws IOException if not a {@link File} or {@link File} does not exist or file size is\nlarger than {@link Integer#MAX_VALUE}.", "predict": "/**\r\n     * Reads the specified number of bytes from the specified file.\r\n     * \r\n     * @param file the file to read from\r\n     * @param count the number of bytes to read\r\n     * @return the bytes read from the file\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static byte[] readBytes(final File file, final int count) throws IOException {\r\n        checkExists(file);\r\n        checkIsFile(file);\r\n        long numToRead = file.length();\r\n        if (numToRead >= Integer.MAX_VALUE) {\r\n            throw new IOException(\"File is larger then max array size\");\r\n        }\r\n        if (count > NEGATIVE_ONE && count < numToRead) {\r\n            numToRead = count;\r\n        }\r\n        byte[] bytes = new byte[(int) numToRead];\r\n        RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\");\r\n        randomAccessFile.readFully(bytes);\r\n        randomAccessFile.close();\r\n        return bytes;\r\n    }"}, {"ID": 1402, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void writeBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, false); }\n\n    ### Response:", "ground_truth": "Write bytes. append = false\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": "/**\r\n     * Writes the specified byte array to the specified file starting at the specified offset and for the specified length.\r\n     * \r\n     * @param dest the file to write to\r\n     * @param data the byte array to write\r\n     * @param off the offset in the byte array to start writing from\r\n     * @param len the number of bytes to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void writeBytes(final File dest, final byte[] data, final int off, final int len) throws IOException {\r\n        outBytes(dest, data, off, len, false);\r\n    }"}, {"ID": 1403, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void appendBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, true); }\n\n    ### Response:", "ground_truth": "Appends bytes. append = true\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": "/**\r\n     * Appends the specified byte array to the end of the specified file.\r\n     * \r\n     * @param dest the file to append bytes to\r\n     * @param data the byte array to append\r\n     * @param off the start offset in the data\r\n     * @param len the number of bytes to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void appendBytes(final File dest, final byte[] data, final int off, final int len) throws IOException {\r\n        outBytes(dest, data, off, len, true);\r\n    }"}, {"ID": 1404, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void copy(final File src, final File dest) throws IOException { if (src.isDirectory()) { copyDir(src, dest); return; } if (dest.isDirectory()) { copyFileToDir(src, dest); return; } copyFile(src, dest); }\n\n    ### Response:", "ground_truth": "Smart copy. If source is a directory, copy it to destination.\nOtherwise, if destination is directory, copy source file to it.\nOtherwise, try to copy source file to destination file.\n\n@param src  source {@link File}\n@param dest destination {@link File}\n@throws IOException if there is an error copying.\n@see #copyDir(File, File)\n@see #copyFileToDir(File, File)\n@see #copyFile(File, File)", "predict": "/**\r\n * Copies a file or directory from the source to the destination.\r\n * \r\n * @param src the source file or directory\r\n * @param dest the destination file or directory\r\n * @throws IOException if an I/O error occurs\r\n */\r\npublic static void copy(final File src, final File dest) throws IOException {\r\n    if (src.isDirectory()) {\r\n        copyDir(src, dest);\r\n        return;\r\n    }\r\n    if (dest.isDirectory()) {\r\n        copyFileToDir(src, dest);\r\n        return;\r\n    }\r\n    copyFile(src, dest);\r\n}"}, {"ID": 1405, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void delete(final File dest) throws IOException { if (dest.isDirectory()) { deleteDir(dest); return; } deleteFile(dest); }\n\n    ### Response:", "ground_truth": "Smart delete of destination file or directory.\n\n@throws IOException if there is an issue deleting the file/directory.\n@see #deleteFile(File)\n@see #deleteDir(File)", "predict": "/**\r\n     * Deletes a file or directory recursively.\r\n     * \r\n     * @param dest the file or directory to delete\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void delete(final File dest) throws IOException {\r\n        if (dest.isDirectory()) {\r\n            deleteDir(dest);\r\n            return;\r\n        }\r\n        deleteFile(dest);\r\n    }"}, {"ID": 1406, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static File createTempDirectory(final String prefix, final String suffix, final File tempDir) throws IOException { File file = createTempFile(prefix, suffix, tempDir); file.delete(); file.mkdir(); return file; }\n\n    ### Response:", "ground_truth": "Creates temporary directory.\n\n@see #createTempFile(String, String, File)", "predict": "/**\r\n     * Creates a temporary directory with the specified prefix, suffix, and parent directory.\r\n     * \r\n     * @param prefix the prefix to use for the temporary directory name\r\n     * @param suffix the suffix to use for the temporary directory name\r\n     * @param tempDir the parent directory for the temporary directory\r\n     * @return the temporary directory\r\n     * @throws IOException if an I/O error occurs while creating the temporary directory\r\n     */\r\n    public static File createTempDirectory(final String prefix, final String suffix, final File tempDir) throws IOException {\r\n        File file = createTempFile(prefix, suffix, tempDir);\r\n        file.delete();\r\n        file.mkdir();\r\n        return file;\r\n    }"}, {"ID": 1407, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isBinary(final File file) throws IOException { byte[] bytes = readBytes(file, 128); for (byte b : bytes) { if (b < 32 && b != 9 && b != 10 && b != 13) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Checks the start of the file for ASCII control characters\n\n@param file {@link File}\n@return true if the the start of the {@link File} is ASCII control characters.", "predict": "/**\r\n     * This method checks if a file is a binary file or not.\r\n     * \r\n     * @param file The file to be checked.\r\n     * @return true if the file is a binary file, false otherwise.\r\n     * @throws IOException If an I/O error occurs.\r\n     */\r\n    public static boolean isBinary(final File file) throws IOException {\r\n        byte[] bytes = readBytes(file, 128);\r\n        for (byte b : bytes) {\r\n            if (b < 32 && b != 9 && b != 10 && b != 13) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1408, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void checkDirCopy(final File srcDir, final File destDir) throws IOException { checkExists(srcDir); checkIsDirectory(srcDir); if (equals(srcDir, destDir)) { throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\"); } }\n\n    ### Response:", "ground_truth": "Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.\n\n@param srcDir  Source directory\n@param destDir Destination directory\n@throws IOException if any of the above conditions are not true.", "predict": "/**\r\n     * Checks if the source directory exists and is a directory.\r\n     * \r\n     * @param srcDir the source directory to check\r\n     * @throws IllegalArgumentException if the source directory is null or not a directory\r\n     */\r\n    private static void checkExists(final File srcDir) {\r\n        if (srcDir == null || !srcDir.isDirectory()) {\r\n            throw new IllegalArgumentException(\"Source directory '\" + srcDir + \"' does not exist or is not a directory\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the source directory is a directory.\r\n     * \r\n     * @param srcDir the source directory to check\r\n     * @throws IllegalArgumentException if the source directory is null or not a directory\r\n     */\r\n    private static void checkIsDirectory(final File srcDir) {\r\n        if (srcDir == null || !srcDir.isDirectory()) {\r\n            throw new IllegalArgumentException(\"Source directory '\" + srcDir + \"' is not a directory\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the source directory and destination directory are not equal.\r\n     * \r\n     * @param srcDir"}, {"ID": 1409, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static void checkFileCopy(final File srcFile, final File destFile) throws IOException { checkExists(srcFile); checkIsFile(srcFile); if (equals(srcFile, destFile)) { throw new IOException(\"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\"); } File destParent = destFile.getParentFile(); if (destParent != null && !destParent.exists()) { checkCreateDirectory(destParent); } }\n\n    ### Response:", "ground_truth": "Checks that file copy can occur.\n\n@param srcFile  Source {@link File}\n@param destFile Destination {@link File}\n@throws IOException if srcFile does not exist or is not a file or\nsrcFile and destFile are equal or cannot create ancestor directories.", "predict": "/**\r\n     * Checks if the source file exists and is a file.\r\n     * \r\n     * @param srcFile the source file to check\r\n     * @throws IllegalArgumentException if the source file is null or not a file\r\n     */\r\n    private static void checkExists(final File srcFile) {\r\n        if (srcFile == null || !srcFile.isFile()) {\r\n            throw new IllegalArgumentException(\"Source file must exist and be a file\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the source file is a file.\r\n     * \r\n     * @param srcFile the source file to check\r\n     * @throws IllegalArgumentException if the source file is null or not a file\r\n     */\r\n    private static void checkIsFile(final File srcFile) {\r\n        if (srcFile == null || !srcFile.isFile()) {\r\n            throw new IllegalArgumentException(\"Source file must be a file\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the source file and destination file are equal.\r\n     * \r\n     * @param srcFile the source file to check\r\n     * @param destFile the destination file to"}, {"ID": 1410, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void printUsage(final String commandName) { final StringBuilder usage = new StringBuilder(commandName); for (final Option option : options) { if (option.shortName != null) { usage.append(\" [-\").append(option.shortName).append(\"]\"); } else if (option.longName != null) { usage.append(\" [--\").append(option.longName).append(\"]\"); } } for (final Param param : params) { usage.append(\" \").append(param.label); } System.out.println(usage); }\n\n    ### Response:", "ground_truth": "Prints the usage line.", "predict": "/**\r\n     * Prints the usage information for the specified command.\r\n     * \r\n     * @param commandName the name of the command to print usage for\r\n     */\r\n    public void printUsage(final String commandName) {\r\n        final StringBuilder usage = new StringBuilder(commandName);\r\n        for (final Option option : options) {\r\n            if (option.shortName != null) {\r\n                usage.append(\" [-\").append(option.shortName).append(\"]\");\r\n            } else if (option.longName != null) {\r\n                usage.append(\" [--\").append(option.longName).append(\"]\");\r\n            }\r\n        }\r\n        for (final Param param : params) {\r\n            usage.append(\" \").append(param.label);\r\n        }\r\n        System.out.println(usage);\r\n    }"}, {"ID": 1411, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Method resolveActionMethod(final Class<?> actionClass, final String methodName) { MethodDescriptor methodDescriptor = ClassIntrospector.get().lookup(actionClass).getMethodDescriptor(methodName, false); if (methodDescriptor == null) { throw new MadvocException(\"Public method not found: \" + actionClass.getSimpleName() + \"#\" + methodName); } return methodDescriptor.getMethod(); }\n\n    ### Response:", "ground_truth": "Resolves action method for given action class ane method name.", "predict": "/**\r\n     * Resolves an action method by its class and method name.\r\n     * \r\n     * @param actionClass the action class\r\n     * @param methodName the method name\r\n     * @return the resolved method\r\n     * @throws MadvocException if the method is not found or is not public\r\n     */\r\n    public Method resolveActionMethod(final Class<?> actionClass, final String methodName) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1412, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ActionRuntime registerAction(final Class actionClass, final String actionMethodName, final ActionDefinition actionDefinition) { Method actionMethod = resolveActionMethod(actionClass, actionMethodName); return registerAction(actionClass, actionMethod, actionDefinition); }\n\n    ### Response:", "ground_truth": "Registers action with provided action class and method name.\n@see #registerAction(Class, Method, ActionDefinition)", "predict": "/**\r\n     * Registers an action with the runtime.\r\n     * \r\n     * @param actionClass the class of the action to register\r\n     * @param actionMethodName the name of the method to invoke for the action\r\n     * @param actionDefinition the definition of the action to register\r\n     * @return the runtime for the registered action\r\n     */\r\n    public ActionRuntime registerAction(final Class actionClass, final String actionMethodName, final ActionDefinition actionDefinition) {\r\n        Method actionMethod = resolveActionMethod(actionClass, actionMethodName);\r\n        return registerAction(actionClass, actionMethod, actionDefinition);\r\n    }"}, {"ID": 1413, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerPathAlias(final String alias, final String path) { final String existing = pathAliases.put(alias, path); if (existing != null) { throw new MadvocException(\"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing); } }\n\n    ### Response:", "ground_truth": "Registers new path alias.", "predict": "/**\r\n     * Registers a path alias for the given alias and path.\r\n     * \r\n     * @param alias the alias to register\r\n     * @param path the path to register\r\n     * @throws MadvocException if a duplicated alias is detected\r\n     */\r\n    public void registerPathAlias(final String alias, final String path) {\r\n        final String existing = pathAliases.put(alias, path);\r\n        if (existing != null) {\r\n            throw new MadvocException(\"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing);\r\n        }\r\n    }"}, {"ID": 1414, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean next() { if (!looping) { return false; } if (last) { return false; } if (count == 0) { value = start; first = true; } else { value += step; first = false; } count++; last = isLastIteration(value + step); return true; }\n\n    ### Response:", "ground_truth": "Iterates to next value at the beginning of the loop.", "predict": "/**\r\n     * This method advances the loop by one iteration.\r\n     * \r\n     * @return true if the loop has more iterations, false otherwise.\r\n     */\r\n    public boolean next() {\r\n        // TODO: Implement logic for advancing the loop.\r\n    }"}, {"ID": 1415, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static CharArraySequence from(final char[] value, final int offset, final int len) { final char[] buffer = new char[value.length]; System.arraycopy(value, offset, buffer, 0, len); return new CharArraySequence(buffer); }\n\n    ### Response:", "ground_truth": "Static constructor that creates a char sequence by making a copy of provided char array.", "predict": "/**\r\n     * Creates a new CharArraySequence from the specified character array, offset, and length.\r\n     *\r\n     * @param value the character array to copy from\r\n     * @param offset the offset in the character array to start copying from\r\n     * @param len the number of characters to copy\r\n     * @return a new CharArraySequence containing the copied characters\r\n     */\r\n    public static CharArraySequence from(final char[] value, final int offset, final int len) {\r\n        final char[] buffer = new char[value.length];\r\n        System.arraycopy(value, offset, buffer, 0, len);\r\n        return new CharArraySequence(buffer);\r\n    }"}, {"ID": 1416, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object execute() throws Exception { String methodName = ProxyTarget.targetMethodName(); Class[] argTypes = ProxyTarget.createArgumentsClassArray(); Object[] args = ProxyTarget.createArgumentsArray(); // lookup method on target object class (and not #targetClass!() Class type = _target.getClass(); Method method = type.getMethod(methodName, argTypes); // remember context classloader ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Object result; try { // change class loader Thread.currentThread().setContextClassLoader(type.getClassLoader()); // invoke result = method.invoke(_target, args); } finally { // return context classloader Thread.currentThread().setContextClassLoader(contextClassLoader); } return ProxyTarget.returnValue(result); }\n\n    ### Response:", "ground_truth": "Looks up for method in target object and invokes it using reflection.", "predict": "/**\r\n     * This method is responsible for executing the target method on the target object.\r\n     * \r\n     * @return The return value of the target method.\r\n     * @throws Exception If an error occurs while executing the target method.\r\n     */\r\n    public Object execute() throws Exception {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1417, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final boolean matchUpperCase(final char[] uppercaseTarget) { if (ndx + uppercaseTarget.length > total) { return false; } int j = ndx; for (int i = 0; i < uppercaseTarget.length; i++, j++) { final char c = CharUtil.toUpperAscii(input[j]); if (c != uppercaseTarget[i]) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Matches char buffer given in uppercase with content at current location, that will\nbe converted to upper case to make case-insensitive matching.", "predict": "/**\r\n     * Matches the uppercase version of the input string with the given uppercase target string.\r\n     * \r\n     * @param uppercaseTarget the uppercase target string to match with.\r\n     * @return true if the input string matches the uppercase target string, false otherwise.\r\n     */\r\n    public final boolean matchUpperCase(final char[] uppercaseTarget) {\r\n        if (ndx + uppercaseTarget.length > total) {\r\n            return false;\r\n        }\r\n        int j = ndx;\r\n        for (int i = 0; i < uppercaseTarget.length; i++, j++) {\r\n            final char c = CharUtil.toUpperAscii(input[j]);\r\n            if (c != uppercaseTarget[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1418, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected final CharSequence charSequence(final int from, final int to) { if (from == to) { return CharArraySequence.EMPTY; } return CharArraySequence.of(input, from, to - from); }\n\n    ### Response:", "ground_truth": "Creates char sub-sequence from the input.", "predict": "/**\r\n     * Returns a subsequence of the input character sequence.\r\n     * \r\n     * @param from the start index, inclusive\r\n     * @param to the end index, exclusive\r\n     * @return the specified subsequence\r\n     */\r\n    protected final CharSequence charSequence(final int from, final int to) {\r\n        if (from == to) {\r\n            return CharArraySequence.EMPTY;\r\n        }\r\n        return CharArraySequence.of(input, from, to - from);\r\n    }"}, {"ID": 1419, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { URLClassLoader urlClassLoader = (URLClassLoader) classLoader; URL[] allURLS = urlClassLoader.getURLs(); Collections.addAll(urls, allURLS); break; } URL classUrl = classModuleUrl(classLoader, clazz); if (classUrl != null) { urls.add(classUrl); } classUrl = classModuleUrl(classLoader, ClassPathURLs.class); if (classUrl != null) { urls.add(classUrl); } ModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor(); if (moduleDescriptor != null) { moduleDescriptor.requires().forEach(req -> { ModuleLayer.boot() .findModule(req.name()) .ifPresent(mod -> { ClassLoader moduleClassLoader = mod.getClassLoader(); if (moduleClassLoader != null) { URL url = moduleClassLoader.getResource(MANIFEST); if (url != null) { url = fixManifestUrl(url); urls.add(url); } } }); }); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); }\n\n    ### Response:", "ground_truth": "Returns urls for the classloader.\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": "/**\n     * Returns an array of URLs representing all the resources on the classpath of the given class.\n     *\n     * @param classLoader the classloader to use to find the resources, or null to use the default classloader\n     * @param clazz the class to use to find the resources, or null to use the ClassPathURLs class\n     * @return an array of URLs representing all the resources on the classpath of the given class\n     */\n    public static URL[] of(ClassLoader classLoader, Class clazz) {\n        // implementation code here\n    }"}, {"ID": 1420, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Email bcc(final EmailAddress... bccs) { this.bcc = ArraysUtil.join(this.bcc, valueOrEmptyArray(bccs)); return _this(); }\n\n    ### Response:", "ground_truth": "Appends one or more BCC addresses.\n\n@param bccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": "/**\r\n     * Adds one or more email addresses to the Bcc list.\r\n     *\r\n     * @param bccs the email addresses to add to the Bcc list\r\n     * @return the updated Email object\r\n     */\r\n    public Email bcc(final EmailAddress... bccs) {\r\n        this.bcc = ArraysUtil.join(this.bcc, valueOrEmptyArray(bccs));\r\n        return _this();\r\n    }"}, {"ID": 1421, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void register(final Class type, final TypeJsonSerializer typeJsonSerializer) { map.put(type, typeJsonSerializer); cache.clear(); }\n\n    ### Response:", "ground_truth": "Registers new serializer.", "predict": "/**\r\n     * Registers a new type serializer for the specified type.\r\n     *\r\n     * @param type the type to register the serializer for\r\n     * @param typeJsonSerializer the serializer to register\r\n     */\r\n    public void register(final Class type, final TypeJsonSerializer typeJsonSerializer) {\r\n        map.put(type, typeJsonSerializer);\r\n        cache.clear();\r\n    }"}, {"ID": 1422, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TypeJsonSerializer lookupSerializer(final Class type) { TypeJsonSerializer tjs = map.get(type); if (tjs == null) { if (defaultSerializerMap != null) { tjs = defaultSerializerMap.map.get(type); } } return tjs; }\n\n    ### Response:", "ground_truth": "Get type serializer from map. First the current map is used.\nIf element is missing, default map will be used, if exist.", "predict": "/**\r\n     * Looks up the serializer for the given type.\r\n     * \r\n     * @param type the type to lookup the serializer for\r\n     * @return the serializer for the given type, or null if none is found\r\n     */\r\n    protected TypeJsonSerializer lookupSerializer(final Class type) {\r\n        TypeJsonSerializer tjs = map.get(type);\r\n        if (tjs == null) {\r\n            if (defaultSerializerMap != null) {\r\n                tjs = defaultSerializerMap.map.get(type);\r\n            }\r\n        }\r\n        return tjs;\r\n    }"}, {"ID": 1423, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parseRequestStream(final InputStream inputStream, final String encoding) throws IOException { setParsed(); MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream); input.readBoundary(); while (true) { FileUploadHeader header = input.readDataHeader(encoding); if (header == null) { break; } if (header.isFile) { String fileName = header.fileName; if (fileName.length() > 0) { if (header.contentType.indexOf(\"application/x-macbinary\") > 0) { input.skipBytes(128); } } FileUpload newFile = fileUploadFactory.create(input); newFile.processStream(); if (fileName.length() == 0) { // file was specified, but no name was provided, therefore it was not uploaded if (newFile.getSize() == 0) { newFile.size = -1; } } putFile(header.formFieldName, newFile); } else { // no file, therefore it is regular form parameter. FastByteArrayOutputStream fbos = new FastByteArrayOutputStream(); input.copyAll(fbos); String value = encoding != null ? new String(fbos.toByteArray(), encoding) : new String(fbos.toByteArray()); putParameter(header.formFieldName, value); } input.skipBytes(1); input.mark(1); // read byte, but may be end of stream int nextByte = input.read(); if (nextByte == -1 || nextByte == '-') { input.reset(); break; } input.reset(); } }\n\n    ### Response:", "ground_truth": "Extracts uploaded files and parameters from the request data.", "predict": "/**\n     * Parses the given input stream as a multipart request and extracts the file uploads and form parameters.\n     * \n     * @param inputStream the input stream to parse\n     * @param encoding the encoding to use for decoding the form parameters\n     * @throws IOException if an I/O error occurs during parsing\n     */\n    public void parseRequestStream(final InputStream inputStream, final String encoding) throws IOException {\n        setParsed();\n        MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream);\n        input.readBoundary();\n        while (true) {\n            FileUploadHeader header = input.readDataHeader(encoding);\n            if (header == null) {\n                break;\n            }\n            if (header.isFile) {\n                String fileName = header.fileName;\n                if (fileName.length() > 0) {\n                    if (header.contentType.indexOf(\"application/x-macbinary\") > 0) {\n                        input.skipBytes(128);\n                    }\n                }\n                FileUpload newFile = fileUploadFactory.create(input"}, {"ID": 1424, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getParameter(final String paramName) { if (requestParameters == null) { return null; } String[] values = requestParameters.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; }\n\n    ### Response:", "ground_truth": "Returns single value of a parameter. If parameter name is used for\nmore then one parameter, only the first one will be returned.\n\n@return parameter value, or null if not found", "predict": "/**\r\n     * This method retrieves the value of a parameter from the request parameters.\r\n     * \r\n     * @param paramName The name of the parameter to retrieve.\r\n     * @return The value of the parameter, or null if the parameter is not found or has no value.\r\n     */\r\n    public String getParameter(final String paramName) {\r\n        // TODO: Implement logic to retrieve parameter value from request parameters.\r\n    }"}, {"ID": 1425, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getParameterValues(final String paramName) { if (requestParameters == null) { return null; } return requestParameters.get(paramName); }\n\n    ### Response:", "ground_truth": "Returns all values all of the values the given request parameter has.", "predict": "/**\r\n     * This method retrieves the values of a parameter from the request parameters.\r\n     * \r\n     * @param paramName The name of the parameter whose values are to be retrieved.\r\n     * @return An array of values for the specified parameter, or null if the parameter is not found.\r\n     */\r\n    public String[] getParameterValues(final String paramName) {\r\n        if (requestParameters == null) {\r\n            return null;\r\n        }\r\n        return requestParameters.get(paramName);\r\n    }"}, {"ID": 1426, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FileUpload getFile(final String paramName) { if (requestFiles == null) { return null; } FileUpload[] values = requestFiles.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; }\n\n    ### Response:", "ground_truth": "Returns uploaded file.\n@param paramName parameter name of the uploaded file\n@return uploaded file or null if parameter name not found", "predict": "/**\r\n     * This method retrieves the first file object from the request parameter with the given name.\r\n     * \r\n     * @param paramName The name of the parameter to retrieve the file from.\r\n     * @return The first file object with the given name, or null if no such file exists.\r\n     */\r\n    public FileUpload getFile(final String paramName) {\r\n        // code goes here\r\n    }"}, {"ID": 1427, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FileUpload[] getFiles(final String paramName) { if (requestFiles == null) { return null; } return requestFiles.get(paramName); }\n\n    ### Response:", "ground_truth": "Returns all uploaded files the given request parameter has.", "predict": "/**\r\n     * Returns an array of FileUpload objects for the given parameter name.\r\n     * \r\n     * @param paramName the parameter name\r\n     * @return an array of FileUpload objects for the given parameter name, or null if no files were found for that parameter name\r\n     */\r\n    public FileUpload[] getFiles(final String paramName);"}, {"ID": 1428, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void init(final FilterConfig filterConfig) { this.filterConfig = filterConfig; this.encoding = filterConfig.getInitParameter(\"encoding\"); if (this.encoding == null) { this.encoding = JoddCore.encoding; } this.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true); }\n\n    ### Response:", "ground_truth": "Place this filter into service.\n\n@param filterConfig The filter configuration object", "predict": "/**\r\n     * Initializes the filter with the given configuration.\r\n     * \r\n     * @param filterConfig the filter configuration\r\n     */\r\n    @Override\r\n    public void init(final FilterConfig filterConfig) {\r\n        this.filterConfig = filterConfig;\r\n        this.encoding = filterConfig.getInitParameter(\"encoding\");\r\n        if (this.encoding == null) {\r\n            this.encoding = JoddCore.encoding;\r\n        }\r\n        this.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true);\r\n    }"}, {"ID": 1429, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void parse(final DbSqlBuilder sqlBuilder, final String template) { int length = template.length(); int last = 0; while (true) { int mark = template.indexOf('$', last); if (mark == -1) { if (last < length) { sqlBuilder.appendRaw(template.substring(last)); } break; } int escapesCount = countEscapes(template, mark); // check if escaped if (escapesCount > 0) { boolean isEscaped = escapesCount % 2 != 0; int escapesToAdd = escapesCount >> 1; sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$'); if (isEscaped) { last = mark + 1; continue; } } else { sqlBuilder.appendRaw(template.substring(last, mark)); } int end; if (template.startsWith(MACRO_TABLE, mark)) { mark += MACRO_TABLE.length(); end = findMacroEnd(template, mark); onTable(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_COLUMN, mark)) { mark += MACRO_COLUMN.length(); end = findMacroEnd(template, mark); onColumn(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_MATCH, mark)) { mark += MACRO_MATCH.length(); end = findMacroEnd(template, mark); onMatch(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_VALUE, mark)) { mark += MACRO_VALUE.length(); end = findMacroEnd(template, mark); onValue(sqlBuilder, template.substring(mark, end)); } else { mark++; // reference found end = mark; // find macro end while (end < length) { if (!isReferenceChar(template, end)) { break; } end++; } onReference(sqlBuilder, template.substring(mark, end)); end--; } end++; last = end; } }\n\n    ### Response:", "ground_truth": "Parses template and returns generated sql builder.", "predict": "/**\n     * Parses the given SQL template and applies the appropriate macros to the given SQL builder.\n     * \n     * @param sqlBuilder the SQL builder to apply the macros to\n     * @param template the SQL template to parse\n     */\n    public void parse(final DbSqlBuilder sqlBuilder, final String template) {\n        int length = template.length();\n        int last = 0;\n        while (true) {\n            int mark = template.indexOf('$', last);\n            if (mark == -1) {\n                if (last < length) {\n                    sqlBuilder.appendRaw(template.substring(last));\n                }\n                break;\n            }\n            int escapesCount = countEscapes(template, mark); // check if escaped\n            if (escapesCount > 0) {\n                boolean isEscaped = escapesCount % 2 != 0;\n                int escapesToAdd = escapesCount >> 1;\n                sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) +"}, {"ID": 1430, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int findMacroEnd(final String template, final int fromIndex) { int endIndex = template.indexOf('}', fromIndex); if (endIndex == -1) { throw new DbSqlBuilderException(\"Template syntax error, some macros are not closed. Error at: '...\" + template.substring(fromIndex)); } return endIndex; }\n\n    ### Response:", "ground_truth": "Finds macros end.", "predict": "/**\r\n     * Finds the index of the end of a macro in the given template string, starting from the given index.\r\n     * \r\n     * @param template the template string to search in\r\n     * @param fromIndex the index to start searching from\r\n     * @return the index of the end of the macro, or -1 if not found\r\n     * @throws DbSqlBuilderException if the template syntax is invalid\r\n     */\r\n    protected int findMacroEnd(final String template, final int fromIndex) {\r\n        int endIndex = template.indexOf('}', fromIndex);\r\n        if (endIndex == -1) {\r\n            throw new DbSqlBuilderException(\"Template syntax error, some macros are not closed. Error at: '...\" + template.substring(fromIndex));\r\n        }\r\n        return endIndex;\r\n    }"}, {"ID": 1431, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected int countEscapes(final String template, int macroIndex) { macroIndex--; int escapeCount = 0; while (macroIndex >= 0) { if (template.charAt(macroIndex) != ESCAPE_CHARACTER) { break; } escapeCount++; macroIndex--; } return escapeCount; }\n\n    ### Response:", "ground_truth": "Count escapes to the left.", "predict": "/**\r\n     * Counts the number of escape characters in the given template string before the given macro index.\r\n     * \r\n     * @param template the template string to search for escape characters\r\n     * @param macroIndex the index of the macro in the template string\r\n     * @return the number of escape characters found before the macro index\r\n     */\r\n    protected int countEscapes(final String template, int macroIndex) {\r\n        macroIndex--;\r\n        int escapeCount = 0;\r\n        while (macroIndex >= 0) {\r\n            if (template.charAt(macroIndex) != ESCAPE_CHARACTER) {\r\n                break;\r\n            }\r\n            escapeCount++;\r\n            macroIndex--;\r\n        }\r\n        return escapeCount;\r\n    }"}, {"ID": 1432, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) { if (queryMap.isEmpty()) { return StringPool.EMPTY; } int queryMapSize = queryMap.size(); StringBand query = new StringBand(queryMapSize * 4); int count = 0; for (Map.Entry<String, ?> entry : queryMap) { String key = entry.getKey(); key = URLCoder.encodeQueryParam(key, encoding); Object value = entry.getValue(); if (value == null) { if (count != 0) { query.append('&'); } query.append(key); count++; } else { if (count != 0) { query.append('&'); } query.append(key); count++; query.append('='); String valueString = URLCoder.encodeQueryParam(value.toString(), encoding); query.append(valueString); } } return query.toString(); }\n\n    ### Response:", "ground_truth": "Builds a query string from given query map.", "predict": "/**\r\n     * Builds a query string from the given HttpMultiMap.\r\n     *\r\n     * @param queryMap the HttpMultiMap to build the query string from\r\n     * @param encoding the encoding to use for the query string\r\n     * @return the query string\r\n     */\r\n    public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1433, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) { final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap(); if (StringUtil.isBlank(query)) { return queryMap; } int lastNdx = 0; while (lastNdx < query.length()) { int ndx = query.indexOf('&', lastNdx); if (ndx == -1) { ndx = query.length(); } final String paramAndValue = query.substring(lastNdx, ndx); ndx = paramAndValue.indexOf('='); if (ndx == -1) { queryMap.add(paramAndValue, null); } else { String name = paramAndValue.substring(0, ndx); if (decode) { name = URLDecoder.decodeQuery(name); } String value = paramAndValue.substring(ndx + 1); if (decode) { value = URLDecoder.decodeQuery(value); } queryMap.add(name, value); } lastNdx += paramAndValue.length() + 1; } return queryMap; }\n\n    ### Response:", "ground_truth": "Parses query from give query string. Values are optionally decoded.", "predict": "/**\n     * Parses a query string into a multi-value map.\n     *\n     * @param query the query string to parse\n     * @param decode whether to decode the query string\n     * @return the multi-value map of query parameters\n     */\n    public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) {\n        final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap();\n        if (StringUtil.isBlank(query)) {\n            return queryMap;\n        }\n        int lastNdx = 0;\n        while (lastNdx < query.length()) {\n            int ndx = query.indexOf('&', lastNdx);\n            if (ndx == -1) {\n                ndx = query.length();\n            }\n            final String paramAndValue = query.substring(lastNdx, ndx);\n            ndx = paramAndValue.indexOf('=');\n            if (ndx == -1) {\n                queryMap.add(paramAndValue, null"}, {"ID": 1434, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); }\n\n    ### Response:", "ground_truth": "Makes nice header names.", "predict": "/**\r\n     * This method prepares the header parameter name for the given header name.\r\n     * \r\n     * @param headerName the header name to be prepared\r\n     * @return the prepared header parameter name\r\n     */\r\n    public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); }"}, {"ID": 1435, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String extractMediaType(final String contentType) { int index = contentType.indexOf(';'); if (index == -1) { return contentType; } return contentType.substring(0, index); }\n\n    ### Response:", "ground_truth": "Extracts media-type from value of \"Content Type\" header.", "predict": "/**\r\n     * Extracts the media type from the given content type string.\r\n     * \r\n     * @param contentType the content type string to extract the media type from\r\n     * @return the media type string\r\n     */\r\n    public static String extractMediaType(final String contentType) {\r\n        int index = contentType.indexOf(';');\r\n        if (index == -1) {\r\n            return contentType;\r\n        }\r\n        return contentType.substring(0, index);\r\n    }"}, {"ID": 1436, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String toHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visit(renderer); return appendable.toString(); }\n\n    ### Response:", "ground_truth": "Renders node to appendable.", "predict": "/**\r\n     * Converts a DOM node to HTML and appends the result to an Appendable.\r\n     *\r\n     * @param node the DOM node to convert\r\n     * @param appendable the Appendable to which the HTML should be appended\r\n     * @return the HTML as a string\r\n     */\r\n    public String toHtml(final Node node, final Appendable appendable) {\r\n        NodeVisitor renderer = createRenderer(appendable);\r\n        node.visit(renderer);\r\n        return appendable.toString();\r\n    }"}, {"ID": 1437, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String toInnerHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visitChildren(renderer); return appendable.toString(); }\n\n    ### Response:", "ground_truth": "Renders node children to appendable.", "predict": "/**\r\n     * Converts a DOM node to its HTML representation and appends it to the given Appendable.\r\n     *\r\n     * @param node the DOM node to convert\r\n     * @param appendable the Appendable to which the HTML representation will be appended\r\n     * @return the HTML representation of the node\r\n     */\r\n    public String toInnerHtml(final Node node, final Appendable appendable) {\r\n        NodeVisitor renderer = createRenderer(appendable);\r\n        node.visitChildren(renderer);\r\n        return appendable.toString();\r\n    }"}, {"ID": 1438, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void configureWith(final ServletContext servletContext) { webAppClassName = servletContext.getInitParameter(PARAM_MADVOC_WEBAPP); paramsFiles = Converter.get().toStringArray(servletContext.getInitParameter(PARAM_MADVOC_PARAMS)); madvocConfiguratorClassName = servletContext.getInitParameter(PARAM_MADVOC_CONFIGURATOR); }\n\n    ### Response:", "ground_truth": "Configures Madvoc by reading context init parameters.", "predict": "/**\r\n     * Configures the Madvoc with the given servlet context.\r\n     * \r\n     * @param servletContext the servlet context to use for configuration\r\n     */\r\n    public void configureWith(final ServletContext servletContext) {\r\n        webAppClassName = servletContext.getInitParameter(PARAM_MADVOC_WEBAPP);\r\n        paramsFiles = Converter.get().toStringArray(servletContext.getInitParameter(PARAM_MADVOC_PARAMS));\r\n        madvocConfiguratorClassName = servletContext.getInitParameter(PARAM_MADVOC_CONFIGURATOR);\r\n    }"}, {"ID": 1439, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void reset() { this.ndx = 0; this.textLen = 0; this.path = new Path(); this.notFirstObject = false; if (useAltPaths) { path.altPath = new Path(); } if (classMetadataName != null) { mapToBean = createMapToBean(classMetadataName); } }\n\n    ### Response:", "ground_truth": "Resets JSON parser, so it can be reused.", "predict": "/**\r\n     * Resets the state of the object to its initial values.\r\n     */\r\n    protected void reset() {\r\n        this.ndx = 0;\r\n        this.textLen = 0;\r\n        this.path = new Path();\r\n        this.notFirstObject = false;\r\n        if (useAltPaths) {\r\n            path.altPath = new Path();\r\n        }\r\n        if (classMetadataName != null) {\r\n            mapToBean = createMapToBean(classMetadataName);\r\n        }\r\n    }"}, {"ID": 1440, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonParser lazy(final boolean lazy) { this.lazy = lazy; this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER; this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER; return this; }\n\n    ### Response:", "ground_truth": "Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\nIn the lazy mode, not everything is parsed, but some things are left lazy.\nThis way we gain performance, especially on partial usage of the whole JSON.\nHowever, be aware that parser holds the input memory until the returned\nobjects are disposed.", "predict": "/**\n     * Enables or disables lazy parsing.\n     * <p>\n     * When enabled, parsing is done on-demand as the values are accessed, rather than all at once when the parser is created. This can improve performance for large or complex documents.\n     * <p>\n     * Note that this setting only affects parsing of JSON values; it does not affect parsing of other types of values (such as numbers or strings).\n     * <p>\n     * The default value is false.\n     *\n     * @param lazy True to enable lazy parsing, false to disable it.\n     * @return This JsonParser instance.\n     */\n    public JsonParser lazy(final boolean lazy) {\n        this.lazy = lazy;\n        this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER;\n        this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER;\n        return this;\n    }"}, {"ID": 1441, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class replaceWithMappedTypeForPath(final Class target) { if (mappings == null) { return target; } Class newType; // first try alt paths Path altPath = path.getAltPath(); if (altPath != null) { if (!altPath.equals(path)) { newType = mappings.get(altPath); if (newType != null) { return newType; } } } // now check regular paths newType = mappings.get(path); if (newType != null) { return newType; } return target; }\n\n    ### Response:", "ground_truth": "Replaces type with mapped type for current path.", "predict": "/**\r\n     * Replaces the target class with the mapped type for the current path, if a mapping exists.\r\n     * \r\n     * @param target the target class to be replaced\r\n     * @return the new class to be used for the current path, or the original target class if no mapping exists\r\n     */\r\n    protected Class replaceWithMappedTypeForPath(final Class target) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 1442, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> List<T> parseAsList(final String string, final Class<T> componentType) { return new JsonParser() .map(JsonParser.VALUES, componentType) .parse(string); }\n\n    ### Response:", "ground_truth": "Parses input JSON to a list with specified component type.", "predict": "/**\r\n     * Parses the given string as a list of objects of the given component type.\r\n     *\r\n     * @param string the string to parse\r\n     * @param componentType the type of objects to be contained in the list\r\n     * @return the parsed list of objects\r\n     */\r\n    public <T> List<T> parseAsList(final String string, final Class<T> componentType) {\r\n        return new JsonParser()\r\n                .map(JsonParser.VALUES, componentType)\r\n                .parse(string);\r\n    }"}, {"ID": 1443, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <K, V> Map<K, V> parseAsMap( final String string, final Class<K> keyType, final Class<V> valueType) { return new JsonParser() .map(JsonParser.KEYS, keyType) .map(JsonParser.VALUES, valueType) .parse(string); }\n\n    ### Response:", "ground_truth": "Parses input JSON to a list with specified key and value types.", "predict": "/**\r\n     * Parses the given string as a Map of the given key and value types.\r\n     *\r\n     * @param string the string to parse\r\n     * @param keyType the type of the keys in the map\r\n     * @param valueType the type of the values in the map\r\n     * @return the parsed Map\r\n     */\r\n    public <K, V> Map<K, V> parseAsMap( final String string, final Class<K> keyType, final Class<V> valueType) { return new JsonParser() .map(JsonParser.KEYS, keyType) .map(JsonParser.VALUES, valueType) .parse(string); }"}, {"ID": 1444, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Object resolveLazyValue(Object value) { if (value instanceof Supplier) { value = ((Supplier)value).get(); } return value; }\n\n    ### Response:", "ground_truth": "Resolves lazy value during the parsing runtime.", "predict": "/**\r\n     * Resolves a lazy value by calling the supplier if the value is a supplier.\r\n     * \r\n     * @param value the value to resolve\r\n     * @return the resolved value\r\n     */\r\n    private Object resolveLazyValue(Object value) {\r\n        if (value instanceof Supplier) {\r\n            value = ((Supplier) value).get();\r\n        }\r\n        return value;\r\n    }"}, {"ID": 1445, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void skipObject() { int bracketCount = 1; boolean insideString = false; while (ndx < total) { final char c = input[ndx]; if (insideString) { if (c == '\\\"' && notPrecededByEvenNumberOfBackslashes()) { insideString = false; } } else if (c == '\\\"') { insideString = true; } else if (c == '{') { bracketCount++; } else if (c == '}') { bracketCount--; if (bracketCount == 0) { ndx++; return; } } ndx++; } }\n\n    ### Response:", "ground_truth": "Skips over complete object. It is not parsed, just skipped. It will be\nparsed later, but only if required.", "predict": "/**\r\n     * Skips over the next object in the input stream.\r\n     * \r\n     * @throws IOException if an I/O error occurs.\r\n     */\r\n    private void skipObject() throws IOException {\r\n        int bracketCount = 1;\r\n        boolean insideString = false;\r\n        while (ndx < total) {\r\n            final char c = input[ndx];\r\n            if (insideString) {\r\n                if (c == '\\\"' && notPrecededByEvenNumberOfBackslashes()) {\r\n                    insideString = false;\r\n                }\r\n            } else if (c == '\\\"') {\r\n                insideString = true;\r\n            } else if (c == '{') {\r\n                bracketCount++;\r\n            } else if (c == '}') {\r\n                bracketCount--;\r\n                if (bracketCount == 0) {\r\n                    ndx++;\r\n                    return;\r\n                }\r\n            }\r\n            ndx++;\r\n        }\r\n    }"}, {"ID": 1446, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); }\n\n    ### Response:", "ground_truth": "Parses a string.", "predict": "/**\r\n     * Parses a string literal.\r\n     * \r\n     * @return the parsed string literal\r\n     */\r\n    protected String parseString() {\r\n        char quote = '\\\"';\r\n        if (looseMode) {\r\n            quote = consumeOneOf('\\\"', '\\'');\r\n            if (quote == 0) {\r\n                return parseUnquotedStringContent();\r\n            }\r\n        } else {\r\n            consume(quote);\r\n        }\r\n        return parseStringContent(quote);\r\n    }"}, {"ID": 1447, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseStringContent(final char quote) { final int startNdx = ndx; // roll-out until the end of the string or the escape char while (true) { final char c = input[ndx]; if (c == quote) { // no escapes found, just use existing string ndx++; return new String(input, startNdx, ndx - 1 - startNdx); } if (c == '\\\\') { break; } ndx++; } // escapes found, proceed differently textLen = ndx - startNdx; growEmpty(); // for (int i = startNdx, j = 0; j < textLen; i++, j++) { // text[j] = input[i]; // } System.arraycopy(input, startNdx, text, 0, textLen); // escape char, process everything until the end while (true) { char c = input[ndx]; if (c == quote) { // done ndx++; final String str = new String(text, 0, textLen); textLen = 0; return str; } if (c == '\\\\') { // escape char found ndx++; c = input[ndx]; switch (c) { case '\\\"' : c = '\\\"'; break; case '\\\\' : c = '\\\\'; break; case '/' : c = '/'; break; case 'b' : c = '\\b'; break; case 'f' : c = '\\f'; break; case 'n' : c = '\\n'; break; case 'r' : c = '\\r'; break; case 't' : c = '\\t'; break; case 'u' : ndx++; c = parseUnicode(); break; default: if (looseMode) { if (c != '\\'') { c = '\\\\'; ndx--; } } else { syntaxError(\"Invalid escape char: \" + c); } } } text[textLen] = c; textLen++; growAndCopy(); ndx++; } }\n\n    ### Response:", "ground_truth": "Parses string content, once when starting quote has been consumed.", "predict": "/**\n     * Parses the string content of the JSON input.\n     * \n     * @param quote the quote character that starts the string content\n     * @return the parsed string content\n     */\n    protected String parseStringContent(final char quote) {\n        final int startNdx = ndx; // roll-out until the end of the string or the escape char\n        while (true) {\n            final char c = input[ndx];\n            if (c == quote) { // no escapes found, just use existing string\n                ndx++;\n                return new String(input, startNdx, ndx - 1 - startNdx);\n            }\n            if (c == '\\\\') {\n                break;\n            }\n            ndx++;\n        }\n        // escapes found, proceed differently\n        int textLen = ndx - startNdx;\n        growEmpty(); // for (int i = startNdx, j = 0; j < textLen; i++, j++) { // text[j] = input[i]; // }\n        System"}, {"ID": 1448, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected char parseUnicode() { int i0 = CharUtil.hex2int(input[ndx++]); int i1 = CharUtil.hex2int(input[ndx++]); int i2 = CharUtil.hex2int(input[ndx++]); int i3 = CharUtil.hex2int(input[ndx]); return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3); }\n\n    ### Response:", "ground_truth": "Parses 4 characters and returns unicode character.", "predict": "/**\r\n     * Parses a Unicode character from the input buffer.\r\n     *\r\n     * @return the parsed Unicode character\r\n     */\r\n    protected char parseUnicode() {\r\n        int i0 = CharUtil.hex2int(input[ndx++]);\r\n        int i1 = CharUtil.hex2int(input[ndx++]);\r\n        int i2 = CharUtil.hex2int(input[ndx++]);\r\n        int i3 = CharUtil.hex2int(input[ndx]);\r\n        return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3);\r\n    }"}, {"ID": 1449, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String parseUnquotedStringContent() { final int startNdx = ndx; while (true) { final char c = input[ndx]; if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) { final int currentNdx = ndx; // done skipWhiteSpaces(); return new String(input, startNdx, currentNdx - startNdx); } ndx++; } }\n\n    ### Response:", "ground_truth": "Parses un-quoted string content.", "predict": "/**\r\n     * Parses the unquoted string content of the input string.\r\n     * \r\n     * @return the parsed string content.\r\n     */\r\n    protected String parseUnquotedStringContent() {\r\n        final int startNdx = ndx;\r\n        while (true) {\r\n            final char c = input[ndx];\r\n            if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) {\r\n                final int currentNdx = ndx;\r\n                // done skipWhiteSpaces();\r\n                return new String(input, startNdx, currentNdx - startNdx);\r\n            }\r\n            ndx++;\r\n        }\r\n    }"}, {"ID": 1450, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Number parseNumber() { final int startIndex = ndx; char c = input[ndx]; boolean isDouble = false; boolean isExp = false; if (c == '-') { ndx++; } while (true) { if (isEOF()) { break; } c = input[ndx]; if (c >= '0' && c <= '9') { ndx++; continue; } if (c <= 32) { // white space break; } if (c == ',' || c == '}' || c == ']') { // delimiter break; } if (c == '.') { isDouble = true; } else if (c == 'e' || c == 'E') { isExp = true; } ndx++; } final String value = new String(input, startIndex, ndx - startIndex); if (isDouble) { return Double.valueOf(value); } long longNumber; if (isExp) { longNumber = Double.valueOf(value).longValue(); } else { if (value.length() >= 19) { // if string is 19 chars and longer, it can be over the limit BigInteger bigInteger = new BigInteger(value); if (isGreaterThanLong(bigInteger)) { return bigInteger; } longNumber = bigInteger.longValue(); } else { longNumber = Long.parseLong(value); } } if ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) { return (int) longNumber; } return longNumber; }\n\n    ### Response:", "ground_truth": "Parses JSON numbers.", "predict": "/**\n     * Parses a number from the input string starting at the current index.\n     * \n     * @return the parsed number\n     */\n    protected Number parseNumber() {\n        // implementation details omitted for brevity\n    }"}, {"ID": 1451, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object parseArrayContent(Class targetType, Class componentType) { // detect special case if (targetType == Object.class) { targetType = List.class; } // continue targetType = replaceWithMappedTypeForPath(targetType); if (componentType == null && targetType != null && targetType.isArray()) { componentType = targetType.getComponentType(); } path.push(VALUES); componentType = replaceWithMappedTypeForPath(componentType); Collection<Object> target = newArrayInstance(targetType); boolean koma = false; mainloop: while (true) { skipWhiteSpaces(); char c = input[ndx]; if (c == ']') { if (koma) { syntaxError(\"Trailing comma\"); } ndx++; path.pop(); return target; } Object value = parseValue(componentType, null, null); target.add(value); skipWhiteSpaces(); c = input[ndx]; switch (c) { case ']': ndx++; break mainloop; case ',': ndx++; koma = true; break; default: syntaxError(\"Invalid char: expected ] or ,\"); } } path.pop(); if (targetType != null) { return convertType(target, targetType); } return target; }\n\n    ### Response:", "ground_truth": "Parses arrays, once when open bracket has been consumed.", "predict": "/**\r\n     * Parses the content of an array as specified by the JSON specification.\r\n     * \r\n     * @param targetType the target type of the array\r\n     * @param componentType the component type of the array\r\n     * @return the parsed array\r\n     */\r\n    protected Object parseArrayContent(Class targetType, Class componentType) {"}, {"ID": 1452, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createEmptyCtor() { final MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC, INIT, \"()V\", null, null); mv.visitCode(); mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitMethodInsn( Opcodes.INVOKESPECIAL, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT, INIT, \"()V\", false); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Created empty default constructor.", "predict": "/**\n     * Creates an empty constructor for the destination class.\n     */\n    protected void createEmptyCtor() {\n        // Implementation goes here\n    }"}, {"ID": 1453, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createSimpleMethodWrapper(final MethodSignatureVisitor msign) { int access = msign.getAccessFlags(); access &= ~ACC_ABSTRACT; access &= ~ACC_NATIVE; MethodVisitor mv = wd.dest.visitMethod( access, msign.getMethodName(), msign.getDescription(), msign.getAsmMethodSignature(), msign.getExceptions()); mv.visitCode(); mv.visitVarInsn(ALOAD, 0); mv.visitFieldInsn(GETFIELD, wd.thisReference, wd.wrapperRef, wd.wrapperType); loadVirtualMethodArguments(mv, msign); if (wd.wrapInterface) { mv.visitMethodInsn( INVOKEINTERFACE, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), true); } else { mv.visitMethodInsn( INVOKEVIRTUAL, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), false); } ProxettaAsmUtil.prepareReturnValue(mv, msign, 0); visitReturn(mv, msign, true); mv.visitMaxs(0, 0); mv.visitEnd(); }\n\n    ### Response:", "ground_truth": "Creates simple method wrapper without proxy.", "predict": "/**\n     * Creates a simple method wrapper for the given method signature.\n     * \n     * @param msign\n     *            the method signature to wrap.\n     */\n    protected void createSimpleMethodWrapper(final MethodSignatureVisitor msign) {\n        // TODO: Implement method\n    }"}, {"ID": 1454, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String resolveRawTypeName(String typeName) { if (typeName == null) { return null; } boolean isArray = typeName.startsWith(StringPool.LEFT_SQ_BRACKET); if (isArray) { typeName = typeName.substring(1); } String rawTypeName; if (generics.containsKey(typeName)) { rawTypeName = generics.get(typeName); } else { rawTypeName = declaredTypeGeneric.getOrDefault(typeName, typeName); } if (isArray) { rawTypeName = '[' + rawTypeName; } return rawTypeName; }\n\n    ### Response:", "ground_truth": "Resolves raw type name using the generics information from the class\nor method information.", "predict": "/**\r\n     * Resolves the raw type name of the given type name.\r\n     * \r\n     * @param typeName the type name to resolve\r\n     * @return the raw type name\r\n     */\r\n    private String resolveRawTypeName(String typeName) {\r\n        // code here\r\n    }"}, {"ID": 1455, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) { BeanReferences references; if (refName == null || refName.isEmpty()) { references = buildDefaultReference(propertyDescriptor); } else { references = BeanReferences.of(refName); } references = references.removeDuplicateNames(); return references; }\n\n    ### Response:", "ground_truth": "Resolves reference from given values. Returns bean reference of given value or defaults\nif given name is blank.", "predict": "/**\r\n     * Resolves the reference from the value of the property descriptor.\r\n     * \r\n     * @param propertyDescriptor the property descriptor\r\n     * @param refName the reference name\r\n     * @return the bean references\r\n     */\r\n    public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) {\r\n        BeanReferences references;\r\n        if (refName == null || refName.isEmpty()) {\r\n            references = buildDefaultReference(propertyDescriptor);\r\n        } else {\r\n            references = BeanReferences.of(refName);\r\n        }\r\n        references = references.removeDuplicateNames();\r\n        return references;\r\n    }"}, {"ID": 1456, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) { BeanReferences[] references = convertRefToReferences(parameterReferences); if (references == null || references.length == 0) { references = buildDefaultReferences(methodOrCtor); } if (methodOrCtor.getParameterTypes().length != references.length) { throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName()); } removeAllDuplicateNames(references); return references; }\n\n    ### Response:", "ground_truth": "Takes given parameters references and returns reference set for given method or constructor.", "predict": "/**\r\n     * Resolves the references for the given method or constructor parameters.\r\n     *\r\n     * @param methodOrCtor the method or constructor to resolve references for\r\n     * @param parameterReferences the parameter references to resolve\r\n     * @return the resolved references\r\n     */\r\n    public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) {\r\n        BeanReferences[] references = convertRefToReferences(parameterReferences);\r\n        if (references == null || references.length == 0) {\r\n            references = buildDefaultReferences(methodOrCtor);\r\n        }\r\n        if (methodOrCtor.getParameterTypes().length != references.length) {\r\n            throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName());\r\n        }\r\n        removeAllDuplicateNames(references);\r\n        return references;\r\n    }"}, {"ID": 1457, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) { PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class); final Parameter[] parameters = methodOrCtor.getParameters(); BeanReferences[] references; final boolean hasAnnotationOnMethodOrCtor; if (petiteInject != null) { references = convertAnnValueToReferences(petiteInject.value()); hasAnnotationOnMethodOrCtor = true; } else { references = new BeanReferences[parameters.length]; hasAnnotationOnMethodOrCtor = false; } int parametersWithAnnotationCount = 0; for (int i = 0; i < parameters.length; i++) { Parameter parameter = parameters[i]; petiteInject = parameter.getAnnotation(PetiteInject.class); if (petiteInject == null) { // no annotation on argument continue; } // there is annotation on argument, override values String annotationValue = readAnnotationValue(petiteInject); if (annotationValue != null) { references[i] = BeanReferences.of(annotationValue); } parametersWithAnnotationCount++; } if (!hasAnnotationOnMethodOrCtor) { if (parametersWithAnnotationCount == 0) { return null; } if (parametersWithAnnotationCount != parameters.length) { throw new PetiteException(\"All arguments must be annotated with PetiteInject\"); } } references = updateReferencesWithDefaultsIfNeeded(methodOrCtor, references); removeAllDuplicateNames(references); return references; }\n\n    ### Response:", "ground_truth": "Extracts references from method or constructor annotation.", "predict": "/**\n     * Reads all references from the annotation on the method or constructor.\n     *\n     * @param methodOrCtor the method or constructor to read the annotation from.\n     * @return the references found in the annotation, or null if no annotation was found.\n     */\n    public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1458, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] buildDefaultReferences(final Executable methodOrCtor) { final boolean useParamo = petiteConfig.getUseParamo(); final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); MethodParameter[] methodParameters = null; if (useParamo) { methodParameters = Paramo.resolveParameters(methodOrCtor); } final Class[] paramTypes = methodOrCtor.getParameterTypes(); final BeanReferences[] references = new BeanReferences[paramTypes.length]; for (int j = 0; j < paramTypes.length; j++) { String[] ref = new String[lookupReferences.length]; references[j] = BeanReferences.of(ref); for (int i = 0; i < ref.length; i++) { switch (lookupReferences[i]) { case NAME: ref[i] = methodParameters != null ? methodParameters[j].getName() : null; break; case TYPE_SHORT_NAME: ref[i] = StringUtil.uncapitalize(paramTypes[j].getSimpleName()); break; case TYPE_FULL_NAME: ref[i] = paramTypes[j].getName(); break; } } } return references; }\n\n    ### Response:", "ground_truth": "Builds default method references.", "predict": "/**\n     * Builds the default references for the given method or constructor.\n     *\n     * @param methodOrCtor the method or constructor to build the references for\n     * @return the default references for the given method or constructor\n     */\n    private BeanReferences[] buildDefaultReferences(final Executable methodOrCtor) {\n        final boolean useParamo = petiteConfig.getUseParamo();\n        final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences();\n        MethodParameter[] methodParameters = null;\n        if (useParamo) {\n            methodParameters = Paramo.resolveParameters(methodOrCtor);\n        }\n        final Class[] paramTypes = methodOrCtor.getParameterTypes();\n        final BeanReferences[] references = new BeanReferences[paramTypes.length];\n        for (int j = 0; j < paramTypes.length; j++) {\n            String[] ref = new String[lookupReferences.length];\n            references[j] = BeanReferences.of(ref);\n            for (int i = 0; i"}, {"ID": 1459, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences buildDefaultReference(final PropertyDescriptor propertyDescriptor) { final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); final String[] references = new String[lookupReferences.length]; for (int i = 0; i < references.length; i++) { switch (lookupReferences[i]) { case NAME: references[i] = propertyDescriptor.getName(); break; case TYPE_SHORT_NAME: references[i] = StringUtil.uncapitalize(propertyDescriptor.getType().getSimpleName()); break; case TYPE_FULL_NAME: references[i] = propertyDescriptor.getType().getName(); break; } } return BeanReferences.of(references); }\n\n    ### Response:", "ground_truth": "Builds default field references.", "predict": "/**\r\n     * Builds the default reference for the given property descriptor.\r\n     * \r\n     * @param propertyDescriptor the property descriptor to build the reference for\r\n     * @return the default reference for the given property descriptor\r\n     */\r\n    public BeanReferences buildDefaultReference(final PropertyDescriptor propertyDescriptor) {\r\n        final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences();\r\n        final String[] references = new String[lookupReferences.length];\r\n        for (int i = 0; i < references.length; i++) {\r\n            switch (lookupReferences[i]) {\r\n                case NAME:\r\n                    references[i] = propertyDescriptor.getName();\r\n                    break;\r\n                case TYPE_SHORT_NAME:\r\n                    references[i] = StringUtil.uncapitalize(propertyDescriptor.getType().getSimpleName());\r\n                    break;\r\n                case TYPE_FULL_NAME:\r\n                    references[i] = propertyDescriptor.getType().getName();\r\n                    break;\r\n            }\r\n        }\r\n        return BeanReferences.of(references);\r\n    }"}, {"ID": 1460, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void removeAllDuplicateNames(final BeanReferences[] allBeanReferences) { for (int i = 0; i < allBeanReferences.length; i++) { BeanReferences references = allBeanReferences[i]; allBeanReferences[i] = references.removeDuplicateNames(); } }\n\n    ### Response:", "ground_truth": "Removes duplicate names from bean references.", "predict": "/**\r\n     * Removes all duplicate names from the given array of BeanReferences.\r\n     * \r\n     * @param allBeanReferences\r\n     *            the array of BeanReferences to remove duplicates from\r\n     */\r\n    private void removeAllDuplicateNames(final BeanReferences[] allBeanReferences) {\r\n        for (int i = 0; i < allBeanReferences.length; i++) {\r\n            BeanReferences references = allBeanReferences[i];\r\n            allBeanReferences[i] = references.removeDuplicateNames();\r\n        }\r\n    }"}, {"ID": 1461, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] convertRefToReferences(final String[] references) { if (references == null) { return null; } BeanReferences[] ref = new BeanReferences[references.length]; for (int i = 0; i < references.length; i++) { ref[i] = BeanReferences.of(references[i]); } return ref; }\n\n    ### Response:", "ground_truth": "Converts single string array to an array of bean references.", "predict": "/**\r\n     * Converts an array of references to an array of BeanReferences objects.\r\n     *\r\n     * @param references the array of references to convert\r\n     * @return the array of BeanReferences objects\r\n     */\r\n    private BeanReferences[] convertRefToReferences(final String[] references) {\r\n        if (references == null) {\r\n            return null;\r\n        }\r\n        BeanReferences[] ref = new BeanReferences[references.length];\r\n        for (int i = 0; i < references.length; i++) {\r\n            ref[i] = BeanReferences.of(references[i]);\r\n        }\r\n        return ref;\r\n    }"}, {"ID": 1462, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private BeanReferences[] convertAnnValueToReferences(String value) { if (value == null) { return null; } value = value.trim(); if (value.length() == 0) { return null; } String[] refNames = Converter.get().toStringArray(value); BeanReferences[] references = new BeanReferences[refNames.length]; for (int i = 0; i < refNames.length; i++) { references[i] = BeanReferences.of(refNames[i].trim()); } return references; }\n\n    ### Response:", "ground_truth": "Converts comma-separated string into array of Bean references.", "predict": "/**\r\n     * Converts a comma-separated string of bean references into an array of BeanReferences objects.\r\n     *\r\n     * @param value the comma-separated string of bean references\r\n     * @return an array of BeanReferences objects, or null if the input string is null or empty\r\n     */\r\n    private BeanReferences[] convertAnnValueToReferences(String value) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 1463, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void runJoy(final Consumer<JoddJoyRuntime> consumer) { final JoddJoy joddJoy = new JoddJoy(); final JoddJoyRuntime joyRuntime = joddJoy.startOnlyBackend(); joddJoy.withDb(joyDb -> setJtxManager(joyRuntime.getJtxManager())); final JtxTransaction tx = startRwTx(); final Print print = new Print(); try { print.line(\"START\", 80); print.newLine(); consumer.accept(joyRuntime); print.newLine(); print.line(\"END\", 80); if (tx != null) { tx.commit(); } } catch (Throwable throwable) { throwable.printStackTrace(); if (tx != null) { tx.rollback(); } } joddJoy.stop(); }\n\n    ### Response:", "ground_truth": "Runs JOY in standalone mode, with only backend.", "predict": "/**\r\n     * Runs the Jodd Joy application with the given consumer.\r\n     *\r\n     * @param consumer the consumer to run the application with\r\n     */\r\n    public void runJoy(final Consumer<JoddJoyRuntime> consumer) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1464, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Method findMethod(final Class c, final String methodName) { return findDeclaredMethod(c, methodName, true); }\n\n    ### Response:", "ground_truth": "Returns method from an object, matched by name. This may be considered as\na slow operation, since methods are matched one by one.\nReturns only accessible methods.\nOnly first method is matched.\n\n@param c          class to examine\n@param methodName Full name of the method.\n@return null if method not found", "predict": "/**\r\n     * Finds a method with the given name in the given class and its superclasses.\r\n     *\r\n     * @param c the class to search in\r\n     * @param methodName the name of the method to find\r\n     * @return the method object, or null if no such method exists\r\n     */\r\n    public static Method findMethod(final Class c, final String methodName) {\r\n        return findDeclaredMethod(c, methodName, true);\r\n    }"}, {"ID": 1465, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; }\n\n    ### Response:", "ground_truth": "Finds constructor with given parameter types. First matched ctor is returned.", "predict": "/**\r\n     * Finds a constructor of the given class that can be invoked with the given parameter types.\r\n     * \r\n     * @param <T> the type of the class to find the constructor for\r\n     * @param clazz the class to find the constructor for\r\n     * @param parameterTypes the parameter types to match the constructor against\r\n     * @return the constructor that matches the given parameter types, or null if no such constructor exists\r\n     */\r\n    public static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) {\r\n        final Constructor<?>[] constructors = clazz.getConstructors();\r\n        Class<?>[] pts;\r\n        for (Constructor<?> constructor : constructors) {\r\n            pts = constructor.getParameterTypes();\r\n            if (isAllAssignableFrom(pts, parameterTypes)) {\r\n                return (Constructor<T>) constructor;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1466, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class[] resolveAllInterfaces(final Class type) { Set<Class> bag = new LinkedHashSet<>(); _resolveAllInterfaces(type, bag); return bag.toArray(new Class[0]); }\n\n    ### Response:", "ground_truth": "Resolves all interfaces of a type. No duplicates are returned.\nDirect interfaces are prior the interfaces of subclasses in\nthe returned array.", "predict": "/**\n     * Resolves all the interfaces implemented by the given type and its superclasses recursively.\n     *\n     * @param type the type to resolve interfaces for\n     * @return an array of all the interfaces implemented by the given type and its superclasses\n     */\n    public static Class[] resolveAllInterfaces(final Class type) {\n        Set<Class> bag = new LinkedHashSet<>();\n        _resolveAllInterfaces(type, bag);\n        return bag.toArray(new Class[0]);\n    }\n\n    /**\n     * Helper method to resolve all the interfaces implemented by the given type and its superclasses recursively.\n     *\n     * @param type the type to resolve interfaces for\n     * @param bag  the set to store the interfaces in\n     */\n    private static void _resolveAllInterfaces(final Class type, final Set<Class> bag) {\n        for (Class iface : type.getInterfaces()) {\n            bag.add(iface);\n            _resolveAllInterfaces(iface, bag);\n        }\n        if (type.getSuperclass() != null) {"}, {"ID": 1467, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean compareParameters(final Class[] first, final Class[] second) { if (first.length != second.length) { return false; } for (int i = 0; i < first.length; i++) { if (first[i] != second[i]) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Compares classes, usually method or ctor parameters.", "predict": "/**\r\n     * Compares two arrays of classes to determine if they are equal.\r\n     * \r\n     * @param first the first array of classes to compare\r\n     * @param second the second array of classes to compare\r\n     * @return true if the arrays are equal, false otherwise\r\n     */\r\n    public static boolean compareParameters(final Class[] first, final Class[] second) {\r\n        if (first.length != second.length) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < first.length; i++) {\r\n            if (first[i] != second[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1468, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void forceAccess(final AccessibleObject accObject) { try { if (System.getSecurityManager() == null) accObject.setAccessible(true); else { AccessController.doPrivileged((PrivilegedAction) () -> { accObject.setAccessible(true); return null; }); } } catch (SecurityException sex) { // ignore } }\n\n    ### Response:", "ground_truth": "Suppress access check against a reflection object. SecurityException is silently ignored.\nChecks first if the object is already accessible.", "predict": "/**\r\n     * This method is used to set the accessible flag of a given AccessibleObject.\r\n     * \r\n     * @param accObject The AccessibleObject whose accessible flag needs to be set.\r\n     */\r\n    public static void forceAccess(final AccessibleObject accObject) {\r\n        try {\r\n            if (System.getSecurityManager() == null) {\r\n                accObject.setAccessible(true);\r\n            } else {\r\n                AccessController.doPrivileged((PrivilegedAction) () -> {\r\n                    accObject.setAccessible(true);\r\n                    return null;\r\n                });\r\n            }\r\n        } catch (SecurityException sex) {\r\n            // ignore\r\n        }\r\n    }"}, {"ID": 1469, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <T> T newInstance(final Class<T> clazz, final Object... params) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException { if (params.length == 0) { return newInstance(clazz); } final Class<?>[] paramTypes = getClasses(params); final Constructor<?> constructor = findConstructor(clazz, paramTypes); if (constructor == null) { throw new InstantiationException(\"No constructor matched parameter types.\"); } return (T) constructor.newInstance(params); }\n\n    ### Response:", "ground_truth": "Creates new instance of given class with given optional arguments.", "predict": "/**\r\n     * Creates a new instance of the specified class using the provided constructor parameters.\r\n     * \r\n     * @param <T> the type of the class to be instantiated\r\n     * @param clazz the class to be instantiated\r\n     * @param params the constructor parameters\r\n     * @return a new instance of the specified class\r\n     * @throws InstantiationException if the class cannot be instantiated\r\n     * @throws IllegalAccessException if the constructor is not accessible\r\n     * @throws InvocationTargetException if the constructor throws an exception\r\n     * @throws NoSuchMethodException if no matching constructor is found\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static <T> T newInstance(final Class<T> clazz, final Object... params) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {\r\n        if (params.length == 0) {\r\n            return newInstance(clazz);\r\n        }\r\n        final Class<?>[] paramTypes = getClasses(params);\r\n        final Constructor<?> constructor = findConstructor(clazz, paramTypes);\r\n        if (constructor == null) {\r\n            throw new"}, {"ID": 1470, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class[] getSuperclasses(final Class type) { int i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { i++; } Class[] result = new Class[i]; i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { result[i] = x; i++; } return result; }\n\n    ### Response:", "ground_truth": "Returns all superclasses.", "predict": "/**\r\n     * Returns an array of all the superclasses of the given type, including the type itself.\r\n     * \r\n     * @param type the type to get the superclasses of\r\n     * @return an array of all the superclasses of the given type, including the type itself\r\n     */\r\n    public static Class[] getSuperclasses(final Class type) {\r\n        int i = 0;\r\n        for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) {\r\n            i++;\r\n        }\r\n        Class[] result = new Class[i];\r\n        i = 0;\r\n        for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) {\r\n            result[i] = x;\r\n            i++;\r\n        }\r\n        return result;\r\n    }"}, {"ID": 1471, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class<?> childClassOf(final Class<?> parentClass, final Object instance) { if (instance == null || instance == Object.class) { return null; } if (parentClass != null) { if (parentClass.isInterface()) { return null; } } Class<?> childClass = instance.getClass(); while (true) { Class<?> parent = childClass.getSuperclass(); if (parent == parentClass) { return childClass; } if (parent == null) { return null; } childClass = parent; } }\n\n    ### Response:", "ground_truth": "Returns the class of the immediate subclass of the given parent class for\nthe given object instance; or null if such immediate subclass cannot be\nuniquely identified for the given object instance.", "predict": "/**\r\n     * Returns the child class of the given parent class for the given instance.\r\n     * \r\n     * @param parentClass the parent class\r\n     * @param instance the instance of the parent class\r\n     * @return the child class of the given parent class for the given instance, or null if no such child class exists\r\n     */\r\n    public static Class<?> childClassOf(final Class<?> parentClass, final Object instance) {\r\n        // implementation code here\r\n    }"}, {"ID": 1472, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JarFile jarFileOf(final Class<?> klass) { URL url = klass.getResource( \"/\" + klass.getName().replace('.', '/') + \".class\"); if (url == null) { return null; } String s = url.getFile(); int beginIndex = s.indexOf(\"file:\") + \"file:\".length(); int endIndex = s.indexOf(\".jar!\"); if (endIndex == -1) { return null; } endIndex += \".jar\".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, \"UTF-8\"); File file = new File(f); try { return file.exists() ? new JarFile(file) : null; } catch (IOException e) { throw new IllegalStateException(e); } }\n\n    ### Response:", "ground_truth": "Returns the jar file from which the given class is loaded; or null\nif no such jar file can be located.", "predict": "/**\r\n     * Returns a JarFile object for the given class.\r\n     * \r\n     * @param klass the class for which to retrieve the corresponding JarFile object\r\n     * @return a JarFile object for the given class or null if no corresponding JarFile object could be found\r\n     */\r\n    public static JarFile jarFileOf(final Class<?> klass) {\r\n        URL url = klass.getResource( \"/\" + klass.getName().replace('.', '/') + \".class\");\r\n        if (url == null) {\r\n            return null;\r\n        }\r\n        String s = url.getFile();\r\n        int beginIndex = s.indexOf(\"file:\") + \"file:\".length();\r\n        int endIndex = s.indexOf(\".jar!\");\r\n        if (endIndex == -1) {\r\n            return null;\r\n        }\r\n        endIndex += \".jar\".length();\r\n        String f = s.substring(beginIndex, endIndex);\r\n        // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances\r\n        f = URLDecoder"}, {"ID": 1473, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void sleep(final long ms) { try { Thread.sleep(ms); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Puts a thread to sleep, without throwing an InterruptedException.\n\n@param ms     the length of time to sleep in milliseconds", "predict": "/**\r\n     * Sleeps for the specified number of milliseconds, interrupting the current thread if interrupted.\r\n     * \r\n     * @param ms the number of milliseconds to sleep\r\n     */\r\n    public static void sleep(final long ms) {\r\n        try {\r\n            Thread.sleep(ms);\r\n        } catch (InterruptedException iex) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }"}, {"ID": 1474, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void sleep() { try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Puts a thread to sleep forever.", "predict": "/**\r\n     * This method is used to put the current thread to sleep indefinitely.\r\n     * \r\n     * @throws InterruptedException\r\n     *             if the current thread is interrupted while sleeping\r\n     */\r\n    public static void sleep() throws InterruptedException {\r\n        Thread.sleep(Long.MAX_VALUE);\r\n    }"}, {"ID": 1475, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void wait(final Object obj) { synchronized (obj) { try { obj.wait(); } catch (InterruptedException inex) { Thread.currentThread().interrupt(); } } }\n\n    ### Response:", "ground_truth": "Waits for a object for synchronization purposes.", "predict": "/**\r\n     * Waits for another thread to call notify() or notifyAll() on the same object.\r\n     * \r\n     * @param obj the object to wait on\r\n     */\r\n    public static void wait(final Object obj) {\r\n        synchronized (obj) {\r\n            try {\r\n                obj.wait();\r\n            } catch (InterruptedException inex) {\r\n                Thread.currentThread().interrupt();\r\n            }\r\n        }\r\n    }"}, {"ID": 1476, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ThreadFactory daemonThreadFactory(final String name, final int priority) { return new ThreadFactory() { private AtomicInteger count = new AtomicInteger(); @Override public Thread newThread(final Runnable r) { Thread thread = new Thread(r); thread.setName(name + '-' + count.incrementAndGet()); thread.setDaemon(true); thread.setPriority(priority); return thread; } }; }\n\n    ### Response:", "ground_truth": "Creates new daemon thread factory.", "predict": "/**\r\n * Creates a new ThreadFactory that creates daemon threads with the given name and priority.\r\n *\r\n * @param name the name to give to the threads\r\n * @param priority the priority to set on the threads\r\n * @return a new ThreadFactory\r\n */\r\npublic static ThreadFactory daemonThreadFactory(final String name, final int priority) {\r\n    return new ThreadFactory() {\r\n        private AtomicInteger count = new AtomicInteger();\r\n\r\n        @Override\r\n        public Thread newThread(final Runnable r) {\r\n            Thread thread = new Thread(r);\r\n            thread.setName(name + '-' + count.incrementAndGet());\r\n            thread.setDaemon(true);\r\n            thread.setPriority(priority);\r\n            return thread;\r\n        }\r\n    };\r\n}"}, {"ID": 1477, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T get() { if (!initialized) { synchronized (this) { if (!initialized) { final T t = supplier.get(); value = t; initialized = true; supplier = null; return t; } } } return value; }\n\n    ### Response:", "ground_truth": "Returns the value. Value will be computed on first call.", "predict": "/**\r\n     * Returns the value produced by the supplier or throws an exception if the supplier was null or the value was not initialized.\r\n     *\r\n     * @return the value produced by the supplier\r\n     * @throws IllegalStateException if the supplier was null or the value was not initialized\r\n     */\r\n    @Override public T get() {\r\n        if (!initialized) {\r\n            synchronized (this) {\r\n                if (!initialized) {\r\n                    final T t = supplier.get();\r\n                    value = t;\r\n                    initialized = true;\r\n                    supplier = null;\r\n                    return t;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    }"}, {"ID": 1478, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitParameter(final String name, final int access) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitParameter(name, access); } }\n\n    ### Response:", "ground_truth": "Visits a parameter of this method.\n\n@param name parameter name or null if none is provided.\n@param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\nor/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).", "predict": "/**\n     * Visits a parameter of a method.\n     * \n     * @param name the parameter name.\n     * @param access the parameter access flags, only the ACC_FINAL, ACC_SYNTHETIC, ACC_MANDATED and ACC_DEPRECATED flags can be set.\n     */\n    public void visitParameter(final String name, final int access) {\n        if (api < Opcodes.ASM5) {\n            throw new UnsupportedOperationException(REQUIRES_ASM5);\n        }\n        if (mv != null) {\n            mv.visitParameter(name, access);\n        }\n    }"}, {"ID": 1479, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of this method.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "/**\r\n     * Visits an annotation of the method. The annotation values are passed in an array of pairs of values. The array is\r\n     * indexed by the annotation type's index in the constant pool of this class. The values are visited in the order\r\n     * they appear in the array.\r\n     *\r\n     * @param descriptor the class descriptor of the annotation class.\r\n     * @param visible true if the annotation is visible at runtime.\r\n     * @return a visitor to visit the annotation values, or null if this visitor is not interested in visiting this\r\n     *     annotation.\r\n     */\r\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n        if (mv != null) {\r\n            return mv.visitAnnotation(descriptor, visible);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1480, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitTypeAnnotation( final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation on a type in the method signature.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\nTypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\nTypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\nTypeReference#THROWS}. See {@link TypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "/**\n     * Visits a type annotation of the method currently visited by this visitor.\n     * \n     * @param typeRef a reference to the annotated type. The sort of this type\n     * reference is determined by the value of the type_ref item of the annotation\n     * structure.\n     * @param typePath the path to the annotated type argument, wildcard bound,\n     * array element type, or static inner type within the type hierarchy of the\n     * annotated type. May be null if the annotation targets the type as a whole.\n     * @param descriptor the class descriptor of the annotated type.\n     * @param visible true if the annotation is visible at runtime.\n     * @return a visitor to visit the type annotation values, or null if this visitor\n     * is not interested in visiting these annotations.\n     */\n    public AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n        if (api < Opcodes.ASM5) {\n            throw new UnsupportedOperationException(REQUIRES_ASM"}, {"ID": 1481, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitParameterAnnotation( final int parameter, final String descriptor, final boolean visible) { if (mv != null) { return mv.visitParameterAnnotation(parameter, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of a parameter this method.\n\n@param parameter the parameter index. This index must be strictly smaller than the number of\nparameters in the method descriptor, and strictly smaller than the parameter count\nspecified in {@link #visitAnnotableParameterCount}. Important note: a parameter index i\nis not required to correspond to the i'th parameter descriptor in the method\ndescriptor", "predict": "/**\r\n     * Visits a parameter of the method. This method is called by the visitor when it encounters a parameter of the method, which is not annotated with an annotation of the current type. The parameter is specified by its index (the first parameter has index 0), and the method returns an AnnotationVisitor to visit all the annotations on the parameter.\r\n     *\r\n     * @param parameter the index of the parameter. This index is relative to the index of the first parameter, as in {@link java.lang.reflect.Method#getParameterAnnotations()}.\r\n     * @param descriptor the parameter's type descriptor (as returned by {@link java.lang.reflect.Method#getDescriptor()}).\r\n     * @param visible true if the annotation is visible at runtime.\r\n     * @return an {@link AnnotationVisitor} to visit the annotations on the parameter, or null if this visitor is not interested in visiting these annotations.\r\n     */\r\n    public AnnotationVisitor visitParameterAnnotation(final int parameter, final String descriptor, final boolean visible) {\r\n        if (mv != null)"}, {"ID": 1482, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitFieldInsn( final int opcode, final String owner, final String name, final String descriptor) { if (mv != null) { mv.visitFieldInsn(opcode, owner, name, descriptor); } }\n\n    ### Response:", "ground_truth": "Visits a field instruction. A field instruction is an instruction that loads or stores the\nvalue of a field of an object.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nGETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n@param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).", "predict": "/**\r\n     * Visits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an object.\r\n     *\r\n     * @param opcode the opcode of the instruction\r\n     * @param owner the internal name of the field's owner class (e.g., \"java/lang/String\")\r\n     * @param name the field's name (e.g., \"value\")\r\n     * @param descriptor the field's descriptor (e.g., \"Ljava/lang/String;\")\r\n     */\r\n    public void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor) {\r\n        if (mv != null) {\r\n            mv.visitFieldInsn(opcode, owner, name, descriptor);\r\n        }\r\n    }"}, {"ID": 1483, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitMethodInsn( final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) { if (api < Opcodes.ASM5) { if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) { throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\"); } visitMethodInsn(opcode, owner, name, descriptor); return; } if (mv != null) { mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface); } }\n\n    ### Response:", "ground_truth": "Visits a method instruction. A method instruction is an instruction that invokes a method.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nINVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n@param owner the internal name of the method's owner class (see {@link\nType#getInternalName()}).\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param isInterface if the method's owner class is an interface.", "predict": "/**\r\n * Visits a method instruction. A method instruction is an instruction that invokes a method.\r\n *\r\n * @param opcode the opcode of the instruction\r\n * @param owner the internal name of the method's owner class (see {@link Type#getInternalName()})\r\n * @param name the method's name\r\n * @param descriptor the method's descriptor (see {@link Type#getDescriptor()})\r\n * @param isInterface if the method's owner class is an interface\r\n */\r\npublic void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {\r\n    if (api < Opcodes.ASM5) {\r\n        if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) {\r\n            throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\");\r\n        }\r\n        visitMethodInsn(opcode, owner, name, descriptor);\r\n        return;\r\n    }\r\n    if (mv != null) {\r\n        mv.visitMethodInsn(opcode"}, {"ID": 1484, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitInvokeDynamicInsn( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments); } }\n\n    ### Response:", "ground_truth": "Visits an invokedynamic instruction.\n\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param bootstrapMethodHandle the bootstrap method.\n@param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\nan {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\nType}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\nthe content of the array so a caller should expect that this array may change.", "predict": "/**\r\n     * Visits an invokedynamic instruction.\r\n     *\r\n     * @param name the method name.\r\n     * @param descriptor the method descriptor (see {@link Type Type}).\r\n     * @param bootstrapMethodHandle the bootstrap method.\r\n     * @param bootstrapMethodArguments the bootstrap method arguments.\r\n     * @throws UnsupportedOperationException if the current API version is less than {@link Opcodes#ASM5}.\r\n     */\r\n    public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {\r\n        if (api < Opcodes.ASM5) {\r\n            throw new UnsupportedOperationException(REQUIRES_ASM5);\r\n        }\r\n        if (mv != null) {\r\n            mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\r\n        }\r\n    }"}, {"ID": 1485, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } }\n\n    ### Response:", "ground_truth": "Visits a jump instruction. A jump instruction is an instruction that may jump to another\ninstruction.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\nIFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\nIF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n@param label the operand of the instruction to be visited. This operand is a label that\ndesignates the instruction to which the jump instruction may jump.", "predict": "/**\r\n     * Visits a jump instruction. A jump instruction is an instruction that may continue execution from a different point than the usual control flow.\r\n     *\r\n     * @param opcode the opcode of the instruction to be visited. This opcode is either IFEQ, IFNE, IFLT, IFGE, IFGT, or IFLE, depending on the type of jump.\r\n     * @param label the label to which the jump instruction may jump.\r\n     */\r\n    public void visitJumpInsn(final int opcode, final Label label) {\r\n        if (mv != null) {\r\n            mv.visitJumpInsn(opcode, label);\r\n        }\r\n    }"}, {"ID": 1486, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) { if (mv != null) { mv.visitMultiANewArrayInsn(descriptor, numDimensions); } }\n\n    ### Response:", "ground_truth": "Visits a MULTIANEWARRAY instruction.\n\n@param descriptor an array type descriptor (see {@link Type}).\n@param numDimensions the number of dimensions of the array to allocate.", "predict": "/**\n     * Visits a multianewarray instruction.\n     * \n     * @param descriptor an array type descriptor (e.g. \"[I\" for an int[] array)\n     * @param numDimensions the number of dimensions of the array to allocate\n     */\n    public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n        if (mv != null) {\n            mv.visitMultiANewArrayInsn(descriptor, numDimensions);\n        }\n    }"}, {"ID": 1487, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitTryCatchBlock( final Label start, final Label end, final Label handler, final String type) { if (mv != null) { mv.visitTryCatchBlock(start, end, handler, type); } }\n\n    ### Response:", "ground_truth": "Visits a try catch block.\n\n@param start the beginning of the exception handler's scope (inclusive).\n@param end the end of the exception handler's scope (exclusive).\n@param handler the beginning of the exception handler's code.\n@param type the internal name of the type of exceptions handled by the handler, or {@literal\nnull} to catch any exceptions (for \"finally\" blocks).\n@throws IllegalArgumentException if one of the labels has already been visited by this visitor\n(by the {@link #visitLabel} method).", "predict": "/**\r\n     * Visits a try-catch block.\r\n     *\r\n     * @param start the start of the try block\r\n     * @param end the end of the try block\r\n     * @param handler the start of the catch block\r\n     * @param type the type of exception to catch\r\n     */\r\n    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) {\r\n        if (mv != null) {\r\n            mv.visitTryCatchBlock(start, end, handler, type);\r\n        }\r\n    }"}, {"ID": 1488, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitLocalVariableAnnotation( final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitLocalVariableAnnotation( typeRef, typePath, start, end, index, descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation on a local variable type.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\nTypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param start the fist instructions corresponding to the continuous ranges that make the scope\nof this local variable (inclusive).\n@param end the last instructions corresponding to the continuous ranges that make the scope of\nthis local variable (exclusive). This array must have the same size as the 'start' array.\n@param index the local variable's index in each range. This array must have the same size as\nthe 'start' array.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "/**\n     * Visits a local variable annotation.\n     * \n     * @param typeRef a reference to the annotated type. The sort of this type ref must be\n     *        {@link TypeReference#LOCAL_VARIABLE}. See {@link TypeReference}.\n     * @param typePath the path to the annotated type argument, wildcard bound, array element type, or\n     *        static inner type within the annotated type. May be {@literal null} if the annotation\n     *        targets the type as a whole.\n     * @param start an array of labels representing the start positions of the annotated local\n     *        variables.\n     * @param end an array of labels representing the end positions of the annotated local variables.\n     * @param index an array of integers representing the indices of the annotated local variables in\n     *        the code.\n     * @param descriptor a descriptor of the type of the annotated local variables.\n     * @param visible {@literal true} if the annotation is visible at runtime.\n     * @return a visitor to visit the individual annotation values, or {@"}, {"ID": 1489, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException { final BufferedWriter bw = getBufferedWriter(writer); writeBaseAndProfileProperties(bw, properties, profiles); writeProfilePropertiesThatAreNotInTheBase(bw, properties, profiles); bw.flush(); }\n\n    ### Response:", "ground_truth": "Convert Java Properties to Jodd Props format\n\n@param writer     Writer to write Props formatted file content to\n@param properties Properties to convert to Props format\n@param profiles   Properties per profile to convert and add to the Props format\n@throws IOException On any I/O error when writing to the writer", "predict": "/**\r\n     * Converts the given properties and profiles to a writer.\r\n     * \r\n     * @param writer the writer to write to\r\n     * @param properties the base properties\r\n     * @param profiles the profiles to write\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException;"}, {"ID": 1490, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void processStream() throws IOException { FastByteArrayOutputStream out = new FastByteArrayOutputStream(); size = 0; if (maxFileSize == -1) { size += input.copyAll(out); } else { size += input.copyMax(out, maxFileSize + 1); // one more byte to detect larger files if (size > maxFileSize) { fileTooBig = true; valid = false; input.skipToBoundary(); return; } } data = out.toByteArray(); size = data.length; valid = true; }\n\n    ### Response:", "ground_truth": "Reads data from input stream into byte array and stores file size.", "predict": "/**\r\n     * This method processes the input stream and extracts the data.\r\n     * \r\n     * @throws IOException\r\n     */\r\n    @Override\r\n    public void processStream() throws IOException {\r\n        FastByteArrayOutputStream out = new FastByteArrayOutputStream();\r\n        size = 0;\r\n        if (maxFileSize == -1) {\r\n            size += input.copyAll(out);\r\n        } else {\r\n            size += input.copyMax(out, maxFileSize + 1); // one more byte to detect larger files\r\n            if (size > maxFileSize) {\r\n                fileTooBig = true;\r\n                valid = false;\r\n                input.skipToBoundary();\r\n                return;\r\n            }\r\n        }\r\n        data = out.toByteArray();\r\n        size = data.length;\r\n        valid = true;\r\n    }"}, {"ID": 1491, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public T next() { if (hasNext == null) { hasNext = Boolean.valueOf(moveToNext()); } if (hasNext == false) { throw new NoSuchElementException(); } if (!entityAwareMode) { hasNext = null; return newElement; } count++; T result = previousElement; previousElement = newElement; hasNext = null; return result; }\n\n    ### Response:", "ground_truth": "Returns next mapped object.", "predict": "/**\n     * Returns the next element in the iteration.\n     *\n     * @return the next element in the iteration\n     * @throws NoSuchElementException if the iteration has no more elements\n     */\n    @Override\n    public T next() {\n        // TODO: Implement this method\n    }"}, {"ID": 1492, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private boolean moveToNext() { if (last) { // last has been set to true, so no more rows to iterate - close everything if (closeOnEnd) { query.close(); } else { query.closeResultSet(resultSetMapper.getResultSet()); } return false; } while (true) { if (!resultSetMapper.next()) { // no more rows, no more parsing, previousElement is the last one to iterate last = true; return entityAwareMode; } // parse row Object[] objects = resultSetMapper.parseObjects(types); Object row = query.resolveRowResults(objects); newElement = (T) row; if (entityAwareMode) { if (count == 0 && previousElement == null) { previousElement = newElement; continue; } if (previousElement != null && newElement != null) { boolean equals; if (newElement.getClass().isArray()) { equals = Arrays.equals((Object[]) previousElement, (Object[]) newElement); } else { equals = previousElement.equals(newElement); } if (equals) { continue; } } } break; } return true; }\n\n    ### Response:", "ground_truth": "Moves to next element.", "predict": "/**\r\n     * Moves the cursor to the next row in the result set and parses it into an object of type T.\r\n     *\r\n     * @return true if there is another row to iterate, false otherwise.\r\n     */\r\n    private boolean moveToNext() {\r\n        // implementation details omitted for brevity\r\n    }"}, {"ID": 1493, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(T[]... arrays) { Class<T> componentType = (Class<T>) arrays.getClass().getComponentType().getComponentType(); return join(componentType, arrays); }\n\n    ### Response:", "ground_truth": "Joins arrays. Component type is resolved from the array argument.", "predict": "/**\r\n     * Joins multiple arrays of the same type into a single array.\r\n     * \r\n     * @param arrays the arrays to join\r\n     * @return the joined array\r\n     */\r\n    @SuppressWarnings({\"unchecked\"})\r\n    public static <T> T[] join(T[]... arrays) {\r\n        Class<T> componentType = (Class<T>) arrays.getClass().getComponentType().getComponentType();\r\n        return join(componentType, arrays);\r\n    }"}, {"ID": 1494, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(Class<T> componentType, T[][] arrays) { if (arrays.length == 1) { return arrays[0]; } int length = 0; for (T[] array : arrays) { length += array.length; } T[] result = (T[]) Array.newInstance(componentType, length); length = 0; for (T[] array : arrays) { System.arraycopy(array, 0, result, length, array.length); length += array.length; } return result; }\n\n    ### Response:", "ground_truth": "Joins arrays using provided component type.", "predict": "/**\r\n     * Joins multiple arrays of the same type into a single array.\r\n     * \r\n     * @param componentType the type of the elements in the arrays\r\n     * @param arrays        the arrays to join\r\n     * @return a single array containing all the elements of the input arrays\r\n     */\r\n    @SuppressWarnings({\"unchecked\"})\r\n    public static <T> T[] join(Class<T> componentType, T[][] arrays) {\r\n        if (arrays.length == 1) {\r\n            return arrays[0];\r\n        }\r\n        int length = 0;\r\n        for (T[] array : arrays) {\r\n            length += array.length;\r\n        }\r\n        T[] result = (T[]) Array.newInstance(componentType, length);\r\n        length = 0;\r\n        for (T[] array : arrays) {\r\n            System.arraycopy(array, 0, result, length, array.length);\r\n            length += array.length;\r\n        }\r\n        return result;\r\n    }"}, {"ID": 1495, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] resize(T[] buffer, int newSize) { Class<T> componentType = (Class<T>) buffer.getClass().getComponentType(); T[] temp = (T[]) Array.newInstance(componentType, newSize); System.arraycopy(buffer, 0, temp, 0, buffer.length >= newSize ? newSize : buffer.length); return temp; }\n\n    ### Response:", "ground_truth": "Resizes an array.", "predict": "/**\r\n     * This method resizes an array of objects.\r\n     * \r\n     * @param buffer the array to be resized\r\n     * @param newSize the new size of the array\r\n     * @return the resized array\r\n     */\r\n    public static <T> T[] resize(T[] buffer, int newSize) {\r\n        // code goes here\r\n    }"}, {"ID": 1496, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> T[] append(T[] buffer, T newElement) { T[] t = resize(buffer, buffer.length + 1); t[buffer.length] = newElement; return t; }\n\n    ### Response:", "ground_truth": "Appends an element to array.", "predict": "/**\r\n     * Appends a new element to the end of an array and returns the modified array.\r\n     * \r\n     * @param buffer the array to append to\r\n     * @param newElement the new element to append\r\n     * @return the modified array with the new element appended\r\n     */\r\n    public static <T> T[] append(T[] buffer, T newElement) {\r\n        T[] t = resize(buffer, buffer.length + 1);\r\n        t[buffer.length] = newElement;\r\n        return t;\r\n    }"}, {"ID": 1497, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\"}) public static <T> T[] remove(T[] buffer, int offset, int length, Class<T> componentType) { int len2 = buffer.length - length; T[] temp = (T[]) Array.newInstance(componentType, len2); System.arraycopy(buffer, 0, temp, 0, offset); System.arraycopy(buffer, offset + length, temp, offset, len2 - offset); return temp; }\n\n    ### Response:", "ground_truth": "Removes sub-array.", "predict": "/**\r\n     * Removes a range of elements from the specified array and returns the remaining elements in a new array.\r\n     * \r\n     * @param buffer the array from which elements are to be removed\r\n     * @param offset the starting index of the range of elements to be removed\r\n     * @param length the number of elements to be removed\r\n     * @param componentType the class of the elements in the array\r\n     * @return a new array containing the remaining elements\r\n     */\r\n    @SuppressWarnings({\"unchecked\"})\r\n    public static <T> T[] remove(T[] buffer, int offset, int length, Class<T> componentType) {\r\n        int len2 = buffer.length - length;\r\n        T[] temp = (T[]) Array.newInstance(componentType, len2);\r\n        System.arraycopy(buffer, 0, temp, 0, offset);\r\n        System.arraycopy(buffer, offset + length, temp, offset, len2 - offset);\r\n        return temp;\r\n    }"}, {"ID": 1498, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(char[] array, char value) { for (int i = 0; i < array.length; i++) { if (array[i] == value) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds the first occurrence of an element in an array.", "predict": "/**\r\n     * Returns the index of the first occurrence of the specified character in the specified character array.\r\n     *\r\n     * @param array the character array to search\r\n     * @param value the character to find\r\n     * @return the index of the first occurrence of the character in the array, or -1 if the character is not found\r\n     */\r\n    public static int indexOf(char[] array, char value) {\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (array[i] == value) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1499, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(Object[] array, Object value) { for (int i = 0; i < array.length; i++) { if (array[i].equals(value)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds the first occurrence in an array.", "predict": "/**\r\n     * Returns the index of the first occurrence of the specified element in the specified array, or -1 if the element is not present.\r\n     * \r\n     * @param array the array to search for the element\r\n     * @param value the element to search for\r\n     * @return the index of the first occurrence of the element in the array, or -1 if the element is not present\r\n     */\r\n    public static int indexOf(Object[] array, Object value) {\r\n        for (int i = 0; i < array.length; i++) {\r\n            if (array[i].equals(value)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1500, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int indexOf(byte[] array, byte[] sub, int startIndex) { return indexOf(array, sub, startIndex, array.length); }\n\n    ### Response:", "ground_truth": "Finds the first occurrence in an array from specified given position.", "predict": "/**\r\n     * Returns the index within the specified array of the first occurrence of the specified subarray, starting the search at the specified index.\r\n     *\r\n     * @param array the array to search for the subarray.\r\n     * @param sub the subarray to search for.\r\n     * @param startIndex the index to start the search at.\r\n     * @return the index of the first occurrence of the subarray in the array, starting the search at the specified index, or -1 if the subarray is not found.\r\n     */\r\n    public static int indexOf(byte[] array, byte[] sub, int startIndex) {\r\n        return indexOf(array, sub, startIndex, array.length);\r\n    }"}, {"ID": 1501, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public LagartoDOMBuilder enableXhtmlMode() { config.ignoreWhitespacesBetweenTags = false; // collect all whitespaces config.setCaseSensitive(true); // XHTML is case sensitive config.setEnableRawTextModes(false); // all tags are parsed in the same way config.enabledVoidTags = true; // list of void tags config.selfCloseVoidTags = true; // self close void tags config.impliedEndTags = false; // no implied tag ends config.setEnableConditionalComments(false); // don't enable IE conditional comments config.setParseXmlTags(false); // enable XML mode in parsing return this; }\n\n    ### Response:", "ground_truth": "Enables XHTML mode.", "predict": "/**\r\n     * Enables XHTML mode for parsing.\r\n     * \r\n     * @return the LagartoDOMBuilder instance\r\n     */\r\n    public LagartoDOMBuilder enableXhtmlMode() {\r\n        config.ignoreWhitespacesBetweenTags = false; // collect all whitespaces\r\n        config.setCaseSensitive(true); // XHTML is case sensitive\r\n        config.setEnableRawTextModes(false); // all tags are parsed in the same way\r\n        config.enabledVoidTags = true; // list of void tags\r\n        config.selfCloseVoidTags = true; // self close void tags\r\n        config.impliedEndTags = false; // no implied tag ends\r\n        config.setEnableConditionalComments(false); // don't enable IE conditional comments\r\n        config.setParseXmlTags(false); // enable XML mode in parsing\r\n        return this;\r\n    }"}, {"ID": 1502, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Document parse(final char[] content) { LagartoParser lagartoParser = new LagartoParser(content); return doParse(lagartoParser); }\n\n    ### Response:", "ground_truth": "Creates DOM tree from provided content.", "predict": "/**\n     * Parses the given char array content using the LagartoParser and returns a Document object.\n     *\n     * @param content the char array content to be parsed\n     * @return a Document object representing the parsed content\n     */\n    @Override public Document parse(final char[] content) {\n        LagartoParser lagartoParser = new LagartoParser(content);\n        return doParse(lagartoParser);\n    }"}, {"ID": 1503, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Document doParse(final LagartoParser lagartoParser) { lagartoParser.setConfig(config); LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this); lagartoParser.parse(domBuilderTagVisitor); return domBuilderTagVisitor.getDocument(); }\n\n    ### Response:", "ground_truth": "Parses the content using provided lagarto parser.", "predict": "/**\n     * Parses the input using the specified Lagarto parser and returns the resulting document.\n     *\n     * @param lagartoParser the Lagarto parser to use for parsing the input\n     * @return the resulting document\n     */\n    protected Document doParse(final LagartoParser lagartoParser) {\n        lagartoParser.setConfig(config);\n        LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this);\n        lagartoParser.parse(domBuilderTagVisitor);\n        return domBuilderTagVisitor.getDocument();\n    }"}, {"ID": 1504, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void endCurrentBasicBlockWithNoSuccessor() { if (compute == COMPUTE_ALL_FRAMES) { Label nextBasicBlock = new Label(); nextBasicBlock.frame = new Frame(nextBasicBlock); nextBasicBlock.resolve(code.data, code.length); lastBasicBlock.nextBasicBlock = nextBasicBlock; lastBasicBlock = nextBasicBlock; currentBasicBlock = null; } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) { currentBasicBlock.outputStackMax = (short) maxRelativeStackSize; currentBasicBlock = null; } }\n\n    ### Response:", "ground_truth": "Ends the current basic block. This method must be used in the case where the current basic\nblock does not have any successor.\n\nWARNING: this method must be called after the currently visited instruction has been put in\n{@link #code} (if frames are computed, this method inserts a new Label to start a new basic\nblock after the current instruction).", "predict": "/**\r\n     * Ends the current basic block with no successor.\r\n     * \r\n     * @param compute the type of computation to perform on the basic block.\r\n     */\r\n    private void endCurrentBasicBlockWithNoSuccessor(int compute) {\r\n        if (compute == COMPUTE_ALL_FRAMES) {\r\n            Label nextBasicBlock = new Label();\r\n            nextBasicBlock.frame = new Frame(nextBasicBlock);\r\n            nextBasicBlock.resolve(code.data, code.length);\r\n            lastBasicBlock.nextBasicBlock = nextBasicBlock;\r\n            lastBasicBlock = nextBasicBlock;\r\n            currentBasicBlock = null;\r\n        } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {\r\n            currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;\r\n            currentBasicBlock = null;\r\n        }\r\n    }"}, {"ID": 1505, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void collectAttributePrototypes(final Attribute.Set attributePrototypes) { attributePrototypes.addAttributes(firstAttribute); attributePrototypes.addAttributes(firstCodeAttribute); }\n\n    ### Response:", "ground_truth": "Collects the attributes of this method into the given set of attribute prototypes.\n\n@param attributePrototypes a set of attribute prototypes.", "predict": "/**\r\n     * Collects the attribute prototypes for the first attribute and the first code attribute.\r\n     * \r\n     * @param attributePrototypes the attribute set to add the prototypes to\r\n     */\r\n    final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {\r\n        attributePrototypes.addAttributes(firstAttribute);\r\n        attributePrototypes.addAttributes(firstCodeAttribute);\r\n    }"}, {"ID": 1506, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void injectContext(final Object targetObject) { final Class targetType = targetObject.getClass(); final ScopeData scopeData = scopeDataInspector.inspectClassScopesWithCache(targetType); final Targets targets = new Targets(targetObject, scopeData); // inject no context scopeResolver.forEachScope(madvocScope -> madvocScope.inject(targets)); // inject special case scopeResolver.forScope(ParamsScope.class, scope -> scope.inject(targets)); // inject servlet context final ServletContext servletContext = madvocController.getApplicationContext(); if (servletContext != null) { scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); } }\n\n    ### Response:", "ground_truth": "Inject context into target.", "predict": "/**\r\n     * Injects the context for the given target object.\r\n     * \r\n     * @param targetObject the target object to inject the context for\r\n     */\r\n    public void injectContext(final Object targetObject) {\r\n        final Class targetType = targetObject.getClass();\r\n        final ScopeData scopeData = scopeDataInspector.inspectClassScopesWithCache(targetType);\r\n        final Targets targets = new Targets(targetObject, scopeData);\r\n        // inject no context scopeResolver.forEachScope(madvocScope -> madvocScope.inject(targets));\r\n        // inject special case scopeResolver.forScope(ParamsScope.class, scope -> scope.inject(targets));\r\n        // inject servlet context\r\n        final ServletContext servletContext = madvocController.getApplicationContext();\r\n        if (servletContext != null) {\r\n            scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets));\r\n        }\r\n    }"}, {"ID": 1507, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void registerPseudoClass(final Class<? extends PseudoClass> pseudoClassType) { PseudoClass pseudoClass; try { pseudoClass = ClassUtil.newInstance(pseudoClassType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass); }\n\n    ### Response:", "ground_truth": "Registers pseudo class.", "predict": "/**\r\n     * Registers a pseudo-class type with the system.\r\n     * \r\n     * @param pseudoClassType the pseudo-class type to register\r\n     * @throws CSSellyException if there is an error creating an instance of the pseudo-class type\r\n     */\r\n    public static void registerPseudoClass(final Class<? extends PseudoClass> pseudoClassType) {\r\n        PseudoClass pseudoClass;\r\n        try {\r\n            pseudoClass = ClassUtil.newInstance(pseudoClassType);\r\n        } catch (Exception ex) {\r\n            throw new CSSellyException(ex);\r\n        }\r\n        PSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass);\r\n    }"}, {"ID": 1508, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static PseudoClass lookupPseudoClass(final String pseudoClassName) { PseudoClass pseudoClass = PSEUDO_CLASS_MAP.get(pseudoClassName); if (pseudoClass == null) { throw new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName); } return pseudoClass; }\n\n    ### Response:", "ground_truth": "Lookups pseudo class for given pseudo class name.", "predict": "/**\r\n     * Looks up the PseudoClass instance for the given pseudo class name.\r\n     *\r\n     * @param pseudoClassName the name of the pseudo class to lookup\r\n     * @return the PseudoClass instance for the given pseudo class name\r\n     * @throws CSSellyException if the pseudo class name is not supported\r\n     */\r\n    public static PseudoClass lookupPseudoClass(final String pseudoClassName) {\r\n        PseudoClass pseudoClass = PSEUDO_CLASS_MAP.get(pseudoClassName);\r\n        if (pseudoClass == null) {\r\n            throw new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName);\r\n        }\r\n        return pseudoClass;\r\n    }"}, {"ID": 1509, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void invoke(final ActionRequest actionRequest) { if (executorService == null) { throw new MadvocException(\"No action is marked as async!\"); } final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); log.debug(() -> \"Async call to: \" + actionRequest); final AsyncContext asyncContext = servletRequest.startAsync(); executorService.submit(() -> { try { actionRequest.invoke(); } catch (Exception ex) { log.error(\"Invoking async action path failed: \" , ExceptionUtil.unwrapThrowable(ex)); } finally { asyncContext.complete(); } }); }\n\n    ### Response:", "ground_truth": "Invokes an action asynchronously by submitting it to the thread pool.", "predict": "/**\r\n     * Invokes the action request asynchronously.\r\n     * \r\n     * @param actionRequest the action request to invoke\r\n     */\r\n    public void invoke(final ActionRequest actionRequest) {\r\n        if (executorService == null) {\r\n            throw new MadvocException(\"No action is marked as async!\");\r\n        }\r\n        final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest();\r\n        log.debug(() -> \"Async call to: \" + actionRequest);\r\n        final AsyncContext asyncContext = servletRequest.startAsync();\r\n        executorService.submit(() -> {\r\n            try {\r\n                actionRequest.invoke();\r\n            } catch (Exception ex) {\r\n                log.error(\"Invoking async action path failed: \", ExceptionUtil.unwrapThrowable(ex));\r\n            } finally {\r\n                asyncContext.complete();\r\n            }\r\n        });\r\n    }"}, {"ID": 1510, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String[] getAllBeanPropertyNames(final Class type, final boolean declared) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); ArrayList<String> names = new ArrayList<>(propertyDescriptors.length); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { MethodDescriptor getter = propertyDescriptor.getReadMethodDescriptor(); if (getter != null) { if (getter.matchDeclared(declared)) { names.add(propertyDescriptor.getName()); } } else if (includeFields) { FieldDescriptor field = propertyDescriptor.getFieldDescriptor(); if (field != null) { if (field.matchDeclared(declared)) { names.add(field.getName()); } } } } return names.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Returns all bean property names.", "predict": "/**\r\n     * Returns an array of all the property names of the given type.\r\n     * \r\n     * @param type the type to introspect\r\n     * @param declared whether to include only declared properties or also include inherited properties\r\n     * @return an array of property names\r\n     */\r\n    protected String[] getAllBeanPropertyNames(final Class type, final boolean declared) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1511, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit() { String[] properties = resolveProperties(source, declared); for (String name : properties) { if (name == null) { continue; } if (!rules.match(name, blacklist)) { continue; } Object value; String propertyName = name; if (isSourceMap) { propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } if (declared) { value = BeanUtil.declared.getProperty(source, propertyName); } else { value = BeanUtil.pojo.getProperty(source, propertyName); } if (value == null && ignoreNullValues) { continue; } if (value instanceof String && StringUtil.isEmpty((String) value)) { continue; } visitProperty(name, value); } }\n\n    ### Response:", "ground_truth": "Starts visiting properties.", "predict": "/**\r\n     * Visits all properties of the source object that match the blacklist and are not null.\r\n     * \r\n     * @param source the source object to visit\r\n     * @param declared whether to use declared or public fields for property resolution\r\n     * @param ignoreNullValues whether to ignore null or empty string values\r\n     * @param isSourceMap whether the source object is a map\r\n     * @param rules the rules to match property names against\r\n     * @param blacklist the blacklist to match property names against\r\n     */\r\n    public void visit(Object source, boolean declared, boolean ignoreNullValues, boolean isSourceMap, PropertyNameMatcher rules, String[] blacklist) {\r\n        String[] properties = resolveProperties(source, declared);\r\n        for (String name : properties) {\r\n            if (name == null) {\r\n                continue;\r\n            }\r\n            if (!rules.match(name, blacklist)) {\r\n                continue;\r\n            }\r\n            Object value;\r\n            String propertyName = name;\r\n            if (isSourceMap) {\r\n                propertyName = LEFT_SQ_BRACKET + name + RIGHT_"}, {"ID": 1512, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final String propertyName, final String rule, final boolean include) { return propertyName.equals(rule); }\n\n    ### Response:", "ground_truth": "Compares property name to the rules.", "predict": "/**\r\n     * This method overrides the accept method of the Filter interface.\r\n     * It checks if the propertyName is equal to the rule.\r\n     * @param propertyName the name of the property to check\r\n     * @param rule the rule to check against\r\n     * @param include whether to include or exclude the property\r\n     * @return true if the property should be included, false otherwise\r\n     */\r\n    @Override public boolean accept(final String propertyName, final String rule, final boolean include) { return propertyName.equals(rule); }"}, {"ID": 1513, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodInjectionPoint[] resolve(final Class type) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method)) { // ignore setters continue; } if (method.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjectionPoints; if (list.isEmpty()) { methodInjectionPoints = MethodInjectionPoint.EMPTY; } else { methodInjectionPoints = list.toArray(new MethodInjectionPoint[0]); } return methodInjectionPoints; }\n\n    ### Response:", "ground_truth": "Resolve method injection points in given class.", "predict": "/**\n     * Resolves method injection points for the given type.\n     *\n     * @param type the type to resolve method injection points for\n     * @return the method injection points for the given type\n     */\n    public MethodInjectionPoint[] resolve(final Class type) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method)) { // ignore setters continue; } if (method.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjectionPoints; if ("}, {"ID": 1514, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void readFilterConfigParameters(final FilterConfig filterConfig, final Object target, final String... parameters) { for (String parameter : parameters) { String value = filterConfig.getInitParameter(parameter); if (value != null) { BeanUtil.declared.setProperty(target, parameter, value); } } }\n\n    ### Response:", "ground_truth": "Reads filter config parameters and set into destination target.", "predict": "/**\r\n     * Reads the filter configuration parameters and sets them on the target object.\r\n     * \r\n     * @param filterConfig the filter configuration object\r\n     * @param target the target object to set the parameters on\r\n     * @param parameters the parameters to read from the filter configuration\r\n     */\r\n    protected void readFilterConfigParameters(final FilterConfig filterConfig, final Object target, final String... parameters) {\r\n        for (String parameter : parameters) {\r\n            String value = filterConfig.getInitParameter(parameter);\r\n            if (value != null) {\r\n                BeanUtil.declared.setProperty(target, parameter, value);\r\n            }\r\n        }\r\n    }"}, {"ID": 1515, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void sendBundleFile(final HttpServletResponse resp, final File bundleFile) throws IOException { OutputStream out = resp.getOutputStream(); FileInputStream fileInputStream = new FileInputStream(bundleFile); try { StreamUtil.copy(fileInputStream, out); } finally { StreamUtil.close(fileInputStream); } }\n\n    ### Response:", "ground_truth": "Outputs bundle file to the response.", "predict": "/**\r\n     * Sends the bundle file to the client.\r\n     * \r\n     * @param resp\r\n     *            the HTTP response object\r\n     * @param bundleFile\r\n     *            the bundle file to be sent\r\n     * @throws IOException\r\n     *             if an I/O error occurs\r\n     */\r\n    protected void sendBundleFile(final HttpServletResponse resp, final File bundleFile) throws IOException {\r\n        OutputStream out = resp.getOutputStream();\r\n        FileInputStream fileInputStream = new FileInputStream(bundleFile);\r\n        try {\r\n            StreamUtil.copy(fileInputStream, out);\r\n        } finally {\r\n            StreamUtil.close(fileInputStream);\r\n        }\r\n    }"}, {"ID": 1516, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File lookupBundleFile(String bundleId) { if ((mirrors != null) && (!mirrors.isEmpty())) { String realBundleId = mirrors.remove(bundleId); if (realBundleId != null) { bundleId = realBundleId; } } return createBundleFile(bundleId); }\n\n    ### Response:", "ground_truth": "Lookups for bundle file.", "predict": "/**\r\n     * This method looks up the bundle file based on the bundle id.\r\n     * \r\n     * @param bundleId\r\n     *            the bundle id\r\n     * @return the bundle file\r\n     */\r\n    public File lookupBundleFile(String bundleId) {\r\n        // TODO: implement logic to lookup bundle file based on bundle id\r\n        // return null for now\r\n        return null;\r\n    }"}, {"ID": 1517, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public File lookupGzipBundleFile(final File file) throws IOException { String path = file.getPath() + ZipUtil.GZIP_EXT; File gzipFile = new File(path); if (!gzipFile.exists()) { if (log.isDebugEnabled()) { log.debug(\"gzip bundle to \" + path); } ZipUtil.gzip(file); } return gzipFile; }\n\n    ### Response:", "ground_truth": "Locates gzipped version of bundle file. If gzip file\ndoes not exist, it will be created.", "predict": "/**\r\n     * Looks up the gzip bundle file for the given file. If the gzip bundle file does not exist, it creates it by compressing the given file using the {@link ZipUtil#gzip(File)} method.\r\n     * \r\n     * @param file the file to lookup the gzip bundle file for\r\n     * @return the gzip bundle file for the given file\r\n     * @throws IOException if an I/O error occurs while creating the gzip bundle file\r\n     */\r\n    public File lookupGzipBundleFile(final File file) throws IOException {\r\n        String path = file.getPath() + ZipUtil.GZIP_EXT;\r\n        File gzipFile = new File(path);\r\n        if (!gzipFile.exists()) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"gzip bundle to \" + path);\r\n            }\r\n            ZipUtil.gzip(file);\r\n        }\r\n        return gzipFile;\r\n    }"}, {"ID": 1518, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) { if (tempBundleId == null || sources.isEmpty()) { if (strategy == Strategy.ACTION_MANAGED) { // page does not include any resource source file actionBundles.put(actionPath, StringPool.EMPTY); } return null; } // create unique digest from the collected sources String[] sourcesArray = sources.toArray(new String[0]); for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) { sourcesArray[i] = sourcesArray[i].trim().toLowerCase(); } if (sortResources) { Arrays.sort(sourcesArray); } StringBand sb = new StringBand(sourcesArray.length); for (String src : sourcesArray) { sb.append(src); } String sourcesString = sb.toString(); String bundleId = createDigest(sourcesString); bundleId += '.' + bundleContentType; // bundle appears for the first time, create the bundle if (strategy == Strategy.ACTION_MANAGED) { actionBundles.put(actionPath, bundleId); mirrors.put(tempBundleId, bundleId); } try { createBundle(contextPath, actionPath, bundleId, sources); } catch (IOException ioex) { throw new HtmlStaplerException(\"Can't create bundle\", ioex); } return bundleId; }\n\n    ### Response:", "ground_truth": "Registers new bundle that consist of provided list of source paths.\nReturns the real bundle id, as provided one is just a temporary bundle id.", "predict": "/**\r\n     * Registers a bundle for the given action path and sources.\r\n     *\r\n     * @param contextPath the context path of the bundle\r\n     * @param actionPath the action path of the bundle\r\n     * @param tempBundleId the temporary bundle id\r\n     * @param bundleContentType the content type of the bundle\r\n     * @param sources the list of sources for the bundle\r\n     * @return the bundle id if the bundle was successfully registered, null otherwise\r\n     */\r\n    public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) {\r\n        // implementation details omitted for brevity\r\n    }"}, {"ID": 1519, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String createDigest(final String source) { final DigestEngine digestEngine = DigestEngine.sha256(); final byte[] bytes = digestEngine.digest(CharUtil.toSimpleByteArray(source)); String digest = Base32.encode(bytes); if (uniqueDigestKey != null) { digest += uniqueDigestKey; } return digest; }\n\n    ### Response:", "ground_truth": "Creates digest i.e. bundle id from given string.\nReturned digest must be filename safe, for all platforms.", "predict": "/**\r\n     * Generates a unique digest for the given source string using SHA-256 algorithm and Base32 encoding.\r\n     * \r\n     * @param source the source string to generate the digest for\r\n     * @return the unique digest for the given source string\r\n     */\r\n    protected String createDigest(final String source) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1520, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException { final File bundleFile = createBundleFile(bundleId); if (bundleFile.exists()) { return; } StringBand sb = new StringBand(sources.size() * 2); for (String src : sources) { if (sb.length() != 0) { sb.append(StringPool.NEWLINE); } String content; if (isExternalResource(src)) { content = downloadString(src); } else { if (!downloadLocal) { // load local resource from file system String localFile = webRoot; if (src.startsWith(contextPath + '/')) { src = src.substring(contextPath.length()); } if (src.startsWith(StringPool.SLASH)) { // absolute path localFile += src; } else { // relative path localFile += '/' + FileNameUtil.getPathNoEndSeparator(actionPath) + '/' + src; } // trim link parameters, if any int qmndx = localFile.indexOf('?'); if (qmndx != -1) { localFile = localFile.substring(0, qmndx); } try { content = FileUtil.readString(localFile); } catch (IOException ioex) { if (notFoundExceptionEnabled) { throw ioex; } if (log.isWarnEnabled()) { log.warn(ioex.getMessage()); } content = null; } } else { // download local resource String localUrl = localAddressAndPort; if (src.startsWith(StringPool.SLASH)) { localUrl += contextPath + src; } else { localUrl += contextPath + FileNameUtil.getPath(actionPath) + '/' + src; } content = downloadString(localUrl); } if (content != null) { if (isCssResource(src)) { content = fixCssRelativeUrls(content, src); } } } if (content != null) { content = onResourceContent(content); sb.append(content); } } FileUtil.writeString(bundleFile, sb.toString()); if (log.isInfoEnabled()) { log.info(\"Bundle created: \" + bundleId); } }\n\n    ### Response:", "ground_truth": "Creates bundle file by loading resource files content. If bundle file already\nexist it will not be recreated!", "predict": "/**\n     * Creates a bundle file with the given bundle ID and sources.\n     * \n     * @param contextPath the context path of the current request\n     * @param actionPath the action path of the current request\n     * @param bundleId the ID of the bundle to create\n     * @param sources the list of sources to include in the bundle\n     * @throws IOException if an I/O error occurs\n     */\n    protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException {\n        // implementation details omitted\n    }"}, {"ID": 1521, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized void reset() { if (strategy == Strategy.ACTION_MANAGED) { actionBundles.clear(); mirrors.clear(); } final FindFile ff = new FindFile(); ff.includeDirs(false); ff.searchPath(new File(bundleFolder, staplerPath)); File f; int count = 0; while ((f = ff.nextFile()) != null) { f.delete(); count++; } if (log.isInfoEnabled()) { log.info(\"reset: \" + count + \" bundle files deleted.\"); } }\n\n    ### Response:", "ground_truth": "Clears all settings and removes all created bundle files from file system.", "predict": "/**\r\n     * Resets the bundle folder by deleting all bundle files.\r\n     */\r\n    public synchronized void reset() {\r\n        if (strategy == Strategy.ACTION_MANAGED) {\r\n            actionBundles.clear();\r\n            mirrors.clear();\r\n        }\r\n        final FindFile ff = new FindFile();\r\n        ff.includeDirs(false);\r\n        ff.searchPath(new File(bundleFolder, staplerPath));\r\n        File f;\r\n        int count = 0;\r\n        while ((f = ff.nextFile()) != null) {\r\n            f.delete();\r\n            count++;\r\n        }\r\n        if (log.isInfoEnabled()) {\r\n            log.info(\"reset: \" + count + \" bundle files deleted.\");\r\n        }\r\n    }"}, {"ID": 1522, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String fixCssRelativeUrls(final String content, final String src) { final String path = FileNameUtil.getPath(src); final Matcher matcher = CSS_URL_PATTERN.matcher(content); final StringBuilder sb = new StringBuilder(content.length()); int start = 0; while (matcher.find()) { sb.append(content, start, matcher.start()); final String matchedUrl = StringUtil.removeChars(matcher.group(1), \"'\\\"\"); final String url; if (matchedUrl.startsWith(\"https://\") || matchedUrl.startsWith(\"http://\") || matchedUrl.startsWith(\"data:\")) { url = \"url('\" + matchedUrl + \"')\"; } else { url = fixRelativeUrl(matchedUrl, path); } sb.append(url); start = matcher.end(); } sb.append(content.substring(start)); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns the content with all relative URLs fixed.", "predict": "/**\r\n     * This method replaces relative URLs in CSS files with absolute URLs based on the source file path.\r\n     * \r\n     * @param content The content of the CSS file.\r\n     * @param src The source file path.\r\n     * @return The updated content of the CSS file with absolute URLs.\r\n     */\r\n    protected String fixCssRelativeUrls(final String content, final String src) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1523, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbSqlBuilder updateColumn(final Object entity, final String columnRef) { final Object value = BeanUtil.pojo.getProperty(entity, columnRef); return updateColumn(entity, columnRef, value); }\n\n    ### Response:", "ground_truth": "Reads property value and updates the DB.", "predict": "/**\r\n     * Updates a column in the database based on the entity and column reference provided.\r\n     * \r\n     * @param entity the entity to update\r\n     * @param columnRef the column reference to update\r\n     * @return the updated database SQL builder\r\n     */\r\n    public DbSqlBuilder updateColumn(final Object entity, final String columnRef) {\r\n        final Object value = BeanUtil.pojo.getProperty(entity, columnRef);\r\n        return updateColumn(entity, columnRef, value);\r\n    }"}, {"ID": 1524, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static String createTableRefName(final Object entity) { Class type = entity.getClass(); type = (type == Class.class ? (Class) entity : type); return (type.getSimpleName() + '_'); }\n\n    ### Response:", "ground_truth": "Creates table reference name from entity type.\nAlways appends an underscore to reference name in order\nto circumvent SQL compatibility issues when entity class name\nequals to a reserved word.", "predict": "/**\r\n     * This method creates a reference name for a table based on the entity class name.\r\n     * \r\n     * @param entity the entity object or class\r\n     * @return the reference name for the table\r\n     */\r\n    protected static String createTableRefName(final Object entity) {\r\n        Class type = entity.getClass();\r\n        type = (type == Class.class ? (Class) entity : type);\r\n        return (type.getSimpleName() + '_');\r\n    }"}, {"ID": 1525, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public DbSession getDbSession() { log.debug(\"Requesting db TX manager session\"); final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction(); if (jtx == null) { throw new DbSqlException( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\"); } return jtx.requestResource(); }\n\n    ### Response:", "ground_truth": "Returns session from JTX transaction manager and started transaction.", "predict": "/**\r\n     * This method is used to get the database session for the current transaction.\r\n     * \r\n     * @return the database session for the current transaction.\r\n     * @throws DbSqlException if there is no transaction in progress and the database session can't be provided.\r\n     */\r\n    @Override public DbSession getDbSession() {\r\n        log.debug(\"Requesting db TX manager session\");\r\n        final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction();\r\n        if (jtx == null) {\r\n            throw new DbSqlException(\"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\");\r\n        }\r\n        return jtx.requestResource();\r\n    }"}, {"ID": 1526, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected T[] convertToSingleElementArray(final Object value) { T[] singleElementArray = createArray(1); singleElementArray[0] = convertType(value); return singleElementArray; }\n\n    ### Response:", "ground_truth": "Creates an array with single element.", "predict": "/**\r\n     * Converts the given value to an array of type T with a single element.\r\n     * \r\n     * @param value the value to be converted to an array of type T with a single element\r\n     * @return an array of type T with a single element containing the converted value\r\n     */\r\n    protected T[] convertToSingleElementArray(final Object value) {\r\n        T[] singleElementArray = createArray(1);\r\n        singleElementArray[0] = convertType(value);\r\n        return singleElementArray;\r\n    }"}, {"ID": 1527, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) { if (signature == null) { return Collections.emptyMap(); } final Map<String, String> genericsMap = new HashMap<>(); SignatureReader sr = new SignatureReader(signature); StringBuilder sb = new StringBuilder(); TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) { String genericName; @Override public void visitFormalTypeParameter(final String name) { genericName = name; super.visitFormalTypeParameter(name); } @Override public void visitClassType(final String name) { if (genericName != null) { genericsMap.put(genericName, 'L' + name + ';'); genericName = null; } super.visitClassType(name); } }; sr.accept(v); return genericsMap; }\n\n    ### Response:", "ground_truth": "Parses signature for generic information and returns a map where key is generic name\nand value is raw type. Returns an empty map if signature does not define any generics.", "predict": "/**\r\n     * Parses the signature of a method and returns a map of generics.\r\n     *\r\n     * @param signature the signature of the method\r\n     * @param isInterface whether the method is an interface or not\r\n     * @return a map of generics\r\n     */\r\n    public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) {\r\n        if (signature == null) {\r\n            return Collections.emptyMap();\r\n        }\r\n        final Map<String, String> genericsMap = new HashMap<>();\r\n        SignatureReader sr = new SignatureReader(signature);\r\n        StringBuilder sb = new StringBuilder();\r\n        TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) {\r\n            String genericName;\r\n\r\n            @Override\r\n            public void visitFormalTypeParameter(final String name) {\r\n                genericName = name;\r\n                super.visitFormalTypeParameter(name);\r\n            }\r\n\r\n            @Override\r\n            public void visitClassType(final String name) {\r\n                if (genericName != null) {\r\n                    genericsMap.put(genericName"}, {"ID": 1528, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public SetInjectionPoint[] resolve(final Class type, final boolean autowire) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<SetInjectionPoint> list = new ArrayList<>(); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { if (propertyDescriptor.isGetterOnly()) { continue; } Class propertyType = propertyDescriptor.getType(); if (!ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } MethodDescriptor writeMethodDescriptor = propertyDescriptor.getWriteMethodDescriptor(); FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); PetiteInject ref = null; if (writeMethodDescriptor != null) { ref = writeMethodDescriptor.getMethod().getAnnotation(PetiteInject.class); } if (ref == null && fieldDescriptor != null) { ref = fieldDescriptor.getField().getAnnotation(PetiteInject.class); } if ((!autowire) && (ref == null)) { continue; } list.add(new SetInjectionPoint(propertyDescriptor)); } SetInjectionPoint[] fields; if (list.isEmpty()) { fields = SetInjectionPoint.EMPTY; } else { fields = list.toArray(new SetInjectionPoint[0]); } return fields; }\n\n    ### Response:", "ground_truth": "Resolves all collections for given type.", "predict": "/**\n     * Resolves the set injection points for the given type.\n     *\n     * @param type the type to resolve\n     * @param autowire whether to autowire the set injection points\n     * @return the set injection points for the given type\n     */\n    public SetInjectionPoint[] resolve(final Class type, final boolean autowire) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1529, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) { if (!include) { return false; } if (propertyType != null) { if (!jsonSerializer.deep) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector.get().lookup(propertyType); if (propertyTypeClassDescriptor.isArray()) { return false; } if (propertyTypeClassDescriptor.isCollection()) { return false; } if (excludeMaps) { if (propertyTypeClassDescriptor.isMap()) { return false; } } } // still not excluded, continue with excluded types and type names // + excluded types if (jsonSerializer.excludedTypes != null) { for (Class excludedType : jsonSerializer.excludedTypes) { if (ClassUtil.isTypeOf(propertyType, excludedType)) { return false; } } } // + exclude type names final String propertyTypeName = propertyType.getName(); if (jsonSerializer.excludedTypeNames != null) { for (String excludedTypeName : jsonSerializer.excludedTypeNames) { if (Wildcard.match(propertyTypeName, excludedTypeName)) { return false; } } } } return true; }\n\n    ### Response:", "ground_truth": "Matches property types that are ignored by default.", "predict": "/**\r\n     * Checks if the given property type should be ignored based on the current configuration of the JsonSerializer.\r\n     * \r\n     * @param propertyType the type of the property to check\r\n     * @param excludeMaps whether to exclude maps from being ignored\r\n     * @param include whether to include the property type in the check\r\n     * @return true if the property type should be ignored, false otherwise\r\n     */\r\n    public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1530, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void openConnectionForQuery() { if (connection == null) { connection = connectionProvider.getConnection(); txActive = false; // txAction should already be false try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Failed to open non-TX connection\", sex); } } }\n\n    ### Response:", "ground_truth": "Opens connection in auto-commit mode, if already not opened.", "predict": "/**\r\n     * Opens a connection for a query.\r\n     * \r\n     * If a connection is not already open, it will be obtained from the connection provider and set to auto-commit mode.\r\n     * \r\n     * If a transaction is already active, the transaction will be marked as inactive.\r\n     * \r\n     * @throws DbSqlException if a database error occurs while opening the connection\r\n     */\r\n    protected void openConnectionForQuery() {\r\n        if (connection == null) {\r\n            connection = connectionProvider.getConnection();\r\n            txActive = false; // txAction should already be false\r\n            try {\r\n                connection.setAutoCommit(true);\r\n            } catch (SQLException sex) {\r\n                throw new DbSqlException(\"Failed to open non-TX connection\", sex);\r\n            }\r\n        }\r\n    }"}, {"ID": 1531, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void openTx() { if (connection == null) { connection = connectionProvider.getConnection(); } txActive = true; try { connection.setAutoCommit(false); if (txMode.getIsolation() != DbTransactionMode.ISOLATION_DEFAULT) { connection.setTransactionIsolation(txMode.getIsolation()); } connection.setReadOnly(txMode.isReadOnly()); } catch (SQLException sex) { throw new DbSqlException(\"Open TX failed\", sex); } }\n\n    ### Response:", "ground_truth": "Opens a transaction.", "predict": "/**\r\n     * Opens a transaction on the database connection.\r\n     * \r\n     * @throws DbSqlException if the transaction could not be opened.\r\n     */\r\n    protected void openTx() {\r\n        // Code goes here\r\n    }"}, {"ID": 1532, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void closeTx() { txActive = false; try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Close TX failed\", sex); } }\n\n    ### Response:", "ground_truth": "Closes current transaction.", "predict": "/**\r\n     * This method is used to close the transaction.\r\n     * It sets the txActive flag to false and sets the autoCommit flag of the connection to true.\r\n     * If there is an exception while setting the autoCommit flag, it throws a DbSqlException.\r\n     */"}, {"ID": 1533, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commitTransaction() { log.debug(\"Committing transaction\"); assertTxIsActive(); try { connection.commit(); } catch (SQLException sex) { throw new DbSqlException(\"Commit TX failed\", sex); } finally { closeTx(); } }\n\n    ### Response:", "ground_truth": "Commit the current transaction, writing any unflushed changes to the database.\nTransaction mode is closed.", "predict": "/**\r\n     * Commits the current transaction.\r\n     * \r\n     * @throws DbSqlException if the commit operation fails.\r\n     */\r\n    public void commitTransaction() {\r\n        log.debug(\"Committing transaction\");\r\n        assertTxIsActive();\r\n        try {\r\n            connection.commit();\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(\"Commit TX failed\", sex);\r\n        } finally {\r\n            closeTx();\r\n        }\r\n    }"}, {"ID": 1534, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void rollbackTransaction() { log.debug(\"Rolling-back transaction\"); assertTxIsActive(); try { connection.rollback(); } catch (SQLException sex) { throw new DbSqlException(\"Rollback TX failed\", sex); } finally { closeTx(); } }\n\n    ### Response:", "ground_truth": "Roll back the current transaction. Transaction mode is closed.", "predict": "/**\r\n     * This method is used to rollback the current transaction.\r\n     * \r\n     * @throws DbSqlException\r\n     *             if the rollback operation fails.\r\n     */\r\n    public void rollbackTransaction() throws DbSqlException {\r\n        log.debug(\"Rolling-back transaction\");\r\n        assertTxIsActive();\r\n        try {\r\n            connection.rollback();\r\n        } catch (SQLException sex) {\r\n            throw new DbSqlException(\"Rollback TX failed\", sex);\r\n        } finally {\r\n            closeTx();\r\n        }\r\n    }"}, {"ID": 1535, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromFile(final File file) throws IOException { Properties prop = new Properties(); loadFromFile(prop, file); return prop; }\n\n    ### Response:", "ground_truth": "Create properties from the file.\n\n@param file properties file to load", "predict": "/**\r\n     * This method creates a new Properties object and loads the properties from the specified file.\r\n     * \r\n     * @param file the file to load the properties from\r\n     * @return the Properties object containing the loaded properties\r\n     * @throws IOException if an error occurs while reading the file\r\n     */\r\n    public static Properties createFromFile(final File file) throws IOException {\r\n        Properties prop = new Properties();\r\n        loadFromFile(prop, file);\r\n        return prop;\r\n    }"}, {"ID": 1536, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromString(final String data) throws IOException { Properties p = new Properties(); loadFromString(p, data); return p; }\n\n    ### Response:", "ground_truth": "Creates properties from string.", "predict": "/**\r\n     * Creates a new Properties object from a string.\r\n     *\r\n     * @param data the string to load the properties from\r\n     * @return the new Properties object\r\n     * @throws IOException if an error occurs while loading the properties\r\n     */\r\n    public static Properties createFromString(final String data) throws IOException {\r\n        Properties p = new Properties();\r\n        loadFromString(p, data);\r\n        return p;\r\n    }"}, {"ID": 1537, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void loadFromString(final Properties p, final String data) throws IOException { try (ByteArrayInputStream is = new ByteArrayInputStream(data.getBytes(StringPool.ISO_8859_1))) { p.load(is); } }\n\n    ### Response:", "ground_truth": "Loads properties from string.", "predict": "/**\r\n     * Loads the properties from the given string data.\r\n     * \r\n     * @param p the properties to load the data into\r\n     * @param data the string data to load the properties from\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static void loadFromString(final Properties p, final String data) throws IOException {\r\n        try (ByteArrayInputStream is = new ByteArrayInputStream(data.getBytes(StringPool.ISO_8859_1))) {\r\n            p.load(is);\r\n        }\r\n    }"}, {"ID": 1538, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties subset(final Properties p, String prefix, final boolean stripPrefix) { if (StringUtil.isBlank(prefix)) { return p; } if (!prefix.endsWith(StringPool.DOT)) { prefix += '.'; } Properties result = new Properties(); int baseLen = prefix.length(); for (Object o : p.keySet()) { String key = (String) o; if (key.startsWith(prefix)) { result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key)); } } return result; }\n\n    ### Response:", "ground_truth": "Creates new Properties object from the original one, by copying\nthose properties that have specified first part of the key name.\nPrefix may be optionally stripped during this process.\n\n@param p         source properties, from which new object will be created\n@param prefix    key names prefix\n\n@return subset properties", "predict": "/**\r\n     * Returns a subset of the given properties, starting with the given prefix.\r\n     *\r\n     * @param p the properties to subset\r\n     * @param prefix the prefix to start with\r\n     * @param stripPrefix whether to strip the prefix from the keys in the result\r\n     * @return the subset of properties\r\n     */\r\n    public static Properties subset(final Properties p, String prefix, final boolean stripPrefix) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1539, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Properties createFromClasspath(final String... rootTemplate) { Properties p = new Properties(); return loadFromClasspath(p, rootTemplate); }\n\n    ### Response:", "ground_truth": "Creates properties from classpath.", "predict": "/**\r\n     * Creates a new Properties object and loads properties from the classpath.\r\n     *\r\n     * @param rootTemplate the root template to load properties from\r\n     * @return the Properties object with loaded properties\r\n     */\r\n    public static Properties createFromClasspath(final String... rootTemplate) {\r\n        Properties p = new Properties();\r\n        return loadFromClasspath(p, rootTemplate);\r\n    }"}, {"ID": 1540, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getProperty(final Map map, final String key, final String defaultValue) { Object val = map.get(key); return (val instanceof String) ? (String) val : defaultValue; }\n\n    ### Response:", "ground_truth": "Returns String property from a map.\n@see #getProperty(java.util.Map, String)", "predict": "/**\r\n     * This method retrieves the value of the specified key from the given map. If the value is not a string, it returns the default value.\r\n     * \r\n     * @param map the map to retrieve the value from\r\n     * @param key the key to retrieve the value for\r\n     * @param defaultValue the default value to return if the value is not a string\r\n     * @return the value of the specified key from the given map, or the default value if the value is not a string\r\n     */\r\n    public static String getProperty(final Map map, final String key, final String defaultValue) {\r\n        Object val = map.get(key);\r\n        return (val instanceof String) ? (String) val : defaultValue;\r\n    }"}, {"ID": 1541, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void resolveAllVariables(final Properties prop) { for (Object o : prop.keySet()) { String key = (String) o; String value = resolveProperty(prop, key); prop.setProperty(key, value); } }\n\n    ### Response:", "ground_truth": "Resolves all variables.", "predict": "/**\r\n     * This method resolves all variables in the given properties object.\r\n     * \r\n     * @param prop The properties object to resolve variables in.\r\n     */\r\n    public static void resolveAllVariables(final Properties prop) {\r\n        for (Object o : prop.keySet()) {\r\n            String key = (String) o;\r\n            String value = resolveProperty(prop, key);\r\n            prop.setProperty(key, value);\r\n        }\r\n    }"}, {"ID": 1542, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveProperty(final Map map, final String key) { String value = getProperty(map, key); if (value == null) { return null; } value = stp.parse(value, macroName -> getProperty(map, macroName)); return value; }\n\n    ### Response:", "ground_truth": "Returns property with resolved variables.", "predict": "/**\r\n     * Resolves a property value from a map.\r\n     * \r\n     * @param map the map to resolve from\r\n     * @param key the key to resolve\r\n     * @return the resolved value, or null if the key is not found or the value is null\r\n     */\r\n    public static String resolveProperty(final Map map, final String key) {\r\n        String value = getProperty(map, key);\r\n        if (value == null) {\r\n            return null;\r\n        }\r\n        value = stp.parse(value, macroName -> getProperty(map, macroName));\r\n        return value;\r\n    }"}, {"ID": 1543, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String resolveScope(final Class type, final String methodName) { if (scopePattern == null) { return null; } String ctx = scopePattern; ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_CLASS, type.getName()); ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_METHOD, methodName); return ctx; }\n\n    ### Response:", "ground_truth": "Resolves tx scope from scope pattern.", "predict": "/**\r\n     * Resolves the scope for the given type and method name using the configured scope pattern.\r\n     * \r\n     * @param type the type for which the scope is to be resolved\r\n     * @param methodName the name of the method for which the scope is to be resolved\r\n     * @return the resolved scope, or null if no scope pattern is configured\r\n     */\r\n    public String resolveScope(final Class type, final String methodName) {\r\n        if (scopePattern == null) {\r\n            return null;\r\n        }\r\n        String ctx = scopePattern;\r\n        ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_CLASS, type.getName());\r\n        ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_METHOD, methodName);\r\n        return ctx;\r\n    }"}, {"ID": 1544, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) { String signature = type.getName() + '#' + methodName + '%' + unique; JtxTransactionMode txMode = txmap.get(signature); if (txMode == null) { if (!txmap.containsKey(signature)) { final Method m; try { m = type.getMethod(methodName, methodArgTypes); } catch (NoSuchMethodException nsmex) { throw new ProxettaException(nsmex); } final TransactionAnnotationValues txAnn = readTransactionAnnotation(m); if (txAnn != null) { txMode = new JtxTransactionMode( txAnn.propagation(), txAnn.isolation(), txAnn.readOnly(), txAnn.timeout() ); } else { txMode = defaultTransactionMode; } txmap.put(signature, txMode); } } return txMode; }\n\n    ### Response:", "ground_truth": "Reads transaction mode from method annotation. Annotations are cached for better performances.\n@param type target class\n@param methodName target method name over which the transaction should be wrapped\n@param methodArgTypes types of arguments, used to find the method\n@param unique unique method fingerprint that contains return and arguments type information", "predict": "/**\r\n     * Retrieves the transaction mode for the given method.\r\n     * \r\n     * @param type the class of the object on which the method is invoked\r\n     * @param methodName the name of the method\r\n     * @param methodArgTypes the argument types of the method\r\n     * @param unique a unique identifier for the method (e.g. a hash code)\r\n     * @return the transaction mode for the given method, or the default transaction mode if no transaction annotation is found\r\n     */\r\n    public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) {\r\n        String signature = type.getName() + '#' + methodName + '%' + unique;\r\n        JtxTransactionMode txMode = txmap.get(signature);\r\n        if (txMode == null) {\r\n            if (!txmap.containsKey(signature)) {\r\n                final Method m;\r\n                try {\r\n                    m = type.getMethod(methodName, methodArgTypes);\r\n                } catch (NoSuchMethodException nsmex) {\r\n                    throw new"}, {"ID": 1545, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings( {\"unchecked\"}) public void registerAnnotations(final Class<? extends Annotation>[] annotations) { this.annotations = annotations; this.annotationParsers = new AnnotationParser[annotations.length]; for (int i = 0; i < annotations.length; i++) { annotationParsers[i] = TransactionAnnotationValues.parserFor(annotations[i]); } }\n\n    ### Response:", "ground_truth": "Registers new TX annotations.", "predict": "/**\r\n     * Registers the given annotations with the parser.\r\n     * \r\n     * @param annotations\r\n     *            the annotations to register\r\n     */\r\n    @SuppressWarnings( {\"unchecked\"})\r\n    public void registerAnnotations(final Class<? extends Annotation>[] annotations) {\r\n        this.annotations = annotations;\r\n        this.annotationParsers = new AnnotationParser[annotations.length];\r\n        for (int i = 0; i < annotations.length; i++) {\r\n            annotationParsers[i] = TransactionAnnotationValues.parserFor(annotations[i]);\r\n        }\r\n    }"}, {"ID": 1546, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected TransactionAnnotationValues readTransactionAnnotation(final Method method) { for (AnnotationParser annotationParser : annotationParsers) { TransactionAnnotationValues tad = TransactionAnnotationValues.of(annotationParser, method); if (tad != null) { return tad; } } return null; }\n\n    ### Response:", "ground_truth": "Finds TX annotation.", "predict": "/**\r\n     * Reads the transaction annotation values from the given method.\r\n     *\r\n     * @param method the method to read the transaction annotation values from\r\n     * @return the transaction annotation values or null if none were found\r\n     */\r\n    protected TransactionAnnotationValues readTransactionAnnotation(final Method method) {\r\n        for (AnnotationParser annotationParser : annotationParsers) {\r\n            TransactionAnnotationValues tad = TransactionAnnotationValues.of(annotationParser, method);\r\n            if (tad != null) {\r\n                return tad;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1547, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public boolean accept(final Node node) { // match element name with node name if (!matchElement(node)) { return false; } // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case ATTRIBUTE: if (!((AttributeSelector) selector).accept(node)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(node)) { return false; } break; case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(node)) { return false; } break; } } return true; }\n\n    ### Response:", "ground_truth": "Accepts single node.", "predict": "/**\r\n     * Matches the given node with the selector.\r\n     * \r\n     * @param node the node to match\r\n     * @return true if the node matches the selector, false otherwise\r\n     */\r\n    @Override\r\n    public boolean accept(final Node node) {\r\n        // match element name with node name\r\n        if (!matchElement(node)) {\r\n            return false;\r\n        }\r\n\r\n        // match attributes\r\n        int totalSelectors = selectorsCount();\r\n        for (int i = 0; i < totalSelectors; i++) {\r\n            Selector selector = getSelector(i);\r\n\r\n            // just attr name existence\r\n            switch (selector.getType()) {\r\n                case ATTRIBUTE:\r\n                    if (!((AttributeSelector) selector).accept(node)) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case PSEUDO_CLASS:\r\n                    if (!((PseudoClassSelector) selector).accept(node)) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case PSEUDO_FUNCTION:\r\n                    if (!((PseudoFunctionSelector) selector).accept(node)) {\r\n                        return false;\r\n                    }"}, {"ID": 1548, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean matchElement(final Node node) { if (node.getNodeType() != Node.NodeType.ELEMENT) { return false; } String element = getElement(); String nodeName = node.getNodeName(); return element.equals(StringPool.STAR) || element.equals(nodeName); }\n\n    ### Response:", "ground_truth": "Matches element to css selector. All non-element types are ignored.", "predict": "/**\r\n     * Matches the given node against the element name or the wildcard symbol (*).\r\n     *\r\n     * @param node the node to match against\r\n     * @return true if the node matches the element name or the wildcard symbol, false otherwise\r\n     */\r\n    protected boolean matchElement(final Node node) {\r\n        if (node.getNodeType() != Node.NodeType.ELEMENT) {\r\n            return false;\r\n        }\r\n        String element = getElement();\r\n        String nodeName = node.getNodeName();\r\n        return element.equals(StringPool.STAR) || element.equals(nodeName);\r\n    }"}, {"ID": 1549, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean accept(final List<Node> currentResults, final Node node, final int index) { // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(currentResults, node, index)) { return false; } break; default: } } return true; }\n\n    ### Response:", "ground_truth": "Accepts node within current results.", "predict": "/**\r\n     * This method accepts a list of current results, a node, and an index. It checks if the node matches the attributes of the selectors.\r\n     * \r\n     * @param currentResults\r\n     *            The list of current results.\r\n     * @param node\r\n     *            The node to be checked.\r\n     * @param index\r\n     *            The index of the node in the list.\r\n     * @return True if the node matches the attributes of the selectors, false otherwise.\r\n     */\r\n    public boolean accept(final List<Node> currentResults, final Node node, final int index) {\r\n        int totalSelectors = selectorsCount();\r\n        for (int i = 0; i < totalSelectors; i++) {\r\n            Selector selector = getSelector(i);\r\n            switch (selector.getType()) {\r\n                case PSEUDO_FUNCTION:\r\n                    if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case PSEUDO_CLASS:\r\n                    if (!((PseudoClassSelector)"}, {"ID": 1550, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String unescape(final String value) { if (value.indexOf('\\\\') == -1) { return value; } return StringUtil.remove(value, '\\\\'); }\n\n    ### Response:", "ground_truth": "Unescapes CSS string by removing all backslash characters from it.", "predict": "/**\r\n     * Unescapes a string by removing any backslashes that are preceded by another backslash.\r\n     *\r\n     * @param value the string to unescape\r\n     * @return the unescaped string\r\n     */\r\n    protected String unescape(final String value) {\r\n        if (value.indexOf('\\\\') == -1) {\r\n            return value;\r\n        }\r\n        return StringUtil.remove(value, '\\\\');\r\n    }"}, {"ID": 1551, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private String[] buildJrePackages(final int javaVersionNumber) { final ArrayList<String> packages = new ArrayList<>(); switch (javaVersionNumber) { case 9: case 8: case 7: case 6: case 5: // in Java1.5, the apache stuff moved packages.add(\"com.sun.org.apache\"); // fall through... case 4: if (javaVersionNumber == 4) { packages.add(\"org.apache.crimson\"); packages.add(\"org.apache.xalan\"); packages.add(\"org.apache.xml\"); packages.add(\"org.apache.xpath\"); } packages.add(\"org.ietf.jgss\"); packages.add(\"org.w3c.dom\"); packages.add(\"org.xml.sax\"); // fall through... case 3: packages.add(\"org.omg\"); packages.add(\"com.sun.corba\"); packages.add(\"com.sun.jndi\"); packages.add(\"com.sun.media\"); packages.add(\"com.sun.naming\"); packages.add(\"com.sun.org.omg\"); packages.add(\"com.sun.rmi\"); packages.add(\"sunw.io\"); packages.add(\"sunw.util\"); // fall through... case 2: packages.add(\"com.sun.java\"); packages.add(\"com.sun.image\"); // fall through... case 1: default: // core stuff packages.add(\"sun\"); packages.add(\"java\"); packages.add(\"javax\"); break; } return packages.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Builds a set of java core packages.", "predict": "/**\r\n     * Builds a list of packages that are part of the Java Runtime Environment (JRE) for the given Java version number.\r\n     * \r\n     * @param javaVersionNumber the Java version number (e.g. 5, 6, 7, 8, 9)\r\n     * @return an array of package names\r\n     */\r\n    private String[] buildJrePackages(final int javaVersionNumber) {\r\n        final ArrayList<String> packages = new ArrayList<>();\r\n        switch (javaVersionNumber) {\r\n            case 9:\r\n            case 8:\r\n            case 7:\r\n            case 6:\r\n            case 5:\r\n                // in Java1.5, the apache stuff moved packages\r\n                packages.add(\"com.sun.org.apache\");\r\n                // fall through...\r\n            case 4:\r\n                if (javaVersionNumber == 4) {\r\n                    packages.add(\"org.apache.crimson\");\r\n                    packages.add(\"org.apache.xalan\");\r\n                    packages.add(\"org.apache.xml\");\r\n                    packages.add(\"org"}, {"ID": 1552, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected <T extends Node> T cloneTo(final T dest) { // dest.nodeValue = nodeValue; // already in clone implementations! dest.parentNode = parentNode; if (attributes != null) { dest.attributes = new ArrayList<>(attributes.size()); for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) { Attribute attr = attributes.get(i); dest.attributes.add(attr.clone()); } } if (childNodes != null) { dest.childNodes = new ArrayList<>(childNodes.size()); for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node child = childNodes.get(i); Node childClone = child.clone(); childClone.parentNode = dest; // fix parent! dest.childNodes.add(childClone); } } return dest; }\n\n    ### Response:", "ground_truth": "Copies all non-final values to the empty cloned object.\nCache-related values are not copied.", "predict": "/**\r\n     * Clones this node and all its children recursively to the given destination node.\r\n     * \r\n     * @param dest\r\n     *            the destination node to clone to\r\n     * @return the cloned destination node\r\n     */\r\n    protected <T extends Node> T cloneTo(final T dest) {\r\n        // dest.nodeValue = nodeValue; // already in clone implementations!\r\n        dest.parentNode = parentNode;\r\n        if (attributes != null) {\r\n            dest.attributes = new ArrayList<>(attributes.size());\r\n            for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) {\r\n                Attribute attr = attributes.get(i);\r\n                dest.attributes.add(attr.clone());\r\n            }\r\n        }\r\n        if (childNodes != null) {\r\n            dest.childNodes = new ArrayList<>(childNodes.size());\r\n            for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\r\n                Node child = childNodes.get(i);\r\n                Node childClone ="}, {"ID": 1553, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void detachFromParent() { if (parentNode == null) { return; } if (parentNode.childNodes != null) { parentNode.childNodes.remove(siblingIndex); parentNode.reindexChildren(); } parentNode = null; }\n\n    ### Response:", "ground_truth": "Removes this node from DOM tree.", "predict": "/**\r\n     * Detaches this node from its parent node.\r\n     * \r\n     * @return the parent node of this node\r\n     */\r\n    public Node detachFromParent() {\r\n        if (parentNode == null) {\r\n            return null;\r\n        }\r\n        if (parentNode.childNodes != null) {\r\n            parentNode.childNodes.remove(siblingIndex);\r\n            parentNode.reindexChildren();\r\n        }\r\n        parentNode = null;\r\n        return parentNode;\r\n    }"}, {"ID": 1554, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addChild(final Node... nodes) { if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode = this; initChildNodes(node); childNodes.add(node); } reindexChildrenOnAdd(nodes.length); }\n\n    ### Response:", "ground_truth": "Appends several child nodes at once.\nReindex is done only once, after all children are added.", "predict": "/**\r\n     * Adds the given nodes as children of this node.\r\n     * \r\n     * @param nodes the nodes to add as children\r\n     */\r\n    public void addChild(final Node... nodes) {\r\n        if (nodes.length == 0) {\r\n            return; // nothing to add\r\n        }\r\n        for (Node node : nodes) {\r\n            node.detachFromParent();\r\n            node.parentNode = this;\r\n            initChildNodes(node);\r\n            childNodes.add(node);\r\n        }\r\n        reindexChildrenOnAdd(nodes.length);\r\n    }"}, {"ID": 1555, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertChild(final Node node, final int index) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); }\n\n    ### Response:", "ground_truth": "Inserts node at given index.", "predict": "/**\r\n     * Inserts the specified node as a child of this node at the specified index.\r\n     *\r\n     * @param node the node to insert\r\n     * @param index the index at which to insert the node\r\n     * @throws LagartoDOMException if the index is invalid\r\n     */\r\n    public void insertChild(final Node node, final int index) {\r\n        node.detachFromParent();\r\n        node.parentNode = this;\r\n        try {\r\n            initChildNodes(node);\r\n            childNodes.add(index, node);\r\n        } catch (IndexOutOfBoundsException ignore) {\r\n            throw new LagartoDOMException(\"Invalid node index: \" + index);\r\n        }\r\n        reindexChildren();\r\n    }"}, {"ID": 1556, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertBefore(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChild, siblingIndex); }\n\n    ### Response:", "ground_truth": "Inserts node before provided node.", "predict": "/**\r\n     * Inserts the specified node before the specified reference node in the list of children,\r\n     * and updates the sibling indices of the nodes in the list accordingly.\r\n     * \r\n     * @param newChild the node to be inserted\r\n     * @param refChild the reference node\r\n     */\r\n    public void insertBefore(final Node newChild, final Node refChild) {\r\n        int siblingIndex = refChild.getSiblingIndex();\r\n        refChild.parentNode.insertChild(newChild, siblingIndex);\r\n    }"}, {"ID": 1557, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertBefore(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChilds, siblingIndex); }\n\n    ### Response:", "ground_truth": "Inserts several child nodes before provided node.", "predict": "/**\r\n     * Inserts the specified nodes before the specified reference node in the list of children of its parent node.\r\n     * \r\n     * @param newChilds the nodes to be inserted\r\n     * @param refChild the reference node\r\n     */\r\n    public void insertBefore(final Node[] newChilds, final Node refChild) {\r\n        if (newChilds.length == 0) {\r\n            return;\r\n        }\r\n        int siblingIndex = refChild.getSiblingIndex();\r\n        refChild.parentNode.insertChild(newChilds, siblingIndex);\r\n    }"}, {"ID": 1558, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertAfter(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChild); } else { refChild.parentNode.insertChild(newChild, siblingIndex); } }\n\n    ### Response:", "ground_truth": "Inserts node after provided node.", "predict": "/**\r\n     * Inserts the specified node after the specified reference node in the list of children of its parent node.\r\n     * \r\n     * @param newChild the node to be inserted\r\n     * @param refChild the reference node\r\n     */\r\n    public void insertAfter(final Node newChild, final Node refChild) {\r\n        int siblingIndex = refChild.getSiblingIndex() + 1;\r\n        if (siblingIndex == refChild.parentNode.getChildNodesCount()) {\r\n            refChild.parentNode.addChild(newChild);\r\n        } else {\r\n            refChild.parentNode.insertChild(newChild, siblingIndex);\r\n        }\r\n    }"}, {"ID": 1559, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertAfter(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChilds); } else { refChild.parentNode.insertChild(newChilds, siblingIndex); } }\n\n    ### Response:", "ground_truth": "Inserts several child nodes after referent node.", "predict": "/**\r\n     * Inserts the specified nodes after the specified reference node in the list of children of its parent node.\r\n     * \r\n     * @param newChilds the nodes to be inserted\r\n     * @param refChild the reference node\r\n     */\r\n    public void insertAfter(final Node[] newChilds, final Node refChild) {\r\n        if (newChilds.length == 0) {\r\n            return;\r\n        }\r\n        int siblingIndex = refChild.getSiblingIndex() + 1;\r\n        if (siblingIndex == refChild.parentNode.getChildNodesCount()) {\r\n            refChild.parentNode.addChild(newChilds);\r\n        } else {\r\n            refChild.parentNode.insertChild(newChilds, siblingIndex);\r\n        }\r\n    }"}, {"ID": 1560, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void removeAllChilds() { List<Node> removedNodes = childNodes; childNodes = null; childElementNodes = null; childElementNodesCount = 0; if (removedNodes != null) { for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) { Node removedNode = removedNodes.get(i); removedNode.detachFromParent(); } } }\n\n    ### Response:", "ground_truth": "Removes all child nodes. Each child node will be detached from this parent.", "predict": "/**\r\n     * Removes all child nodes from this node.\r\n     */\r\n    public void removeAllChilds() {\r\n        List<Node> removedNodes = childNodes;\r\n        childNodes = null;\r\n        childElementNodes = null;\r\n        childElementNodesCount = 0;\r\n        if (removedNodes != null) {\r\n            for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) {\r\n                Node removedNode = removedNodes.get(i);\r\n                removedNode.detachFromParent();\r\n            }\r\n        }\r\n    }"}, {"ID": 1561, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node findChildNodeWithName(final String name) { if (childNodes == null) { return null; } for (final Node childNode : childNodes) { if (childNode.getNodeName().equals(name)) { return childNode; } } return null; }\n\n    ### Response:", "ground_truth": "Finds the first child node with given node name.", "predict": "/**\r\n     * This method finds the first child node with the given name.\r\n     * \r\n     * @param name the name of the child node to find\r\n     * @return the first child node with the given name, or null if no such node exists\r\n     */\r\n    public Node findChildNodeWithName(final String name) {\r\n        if (childNodes == null) {\r\n            return null;\r\n        }\r\n        for (final Node childNode : childNodes) {\r\n            if (childNode.getNodeName().equals(name)) {\r\n                return childNode;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1562, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node[] filterChildNodes(final Predicate<Node> nodePredicate) { if (childNodes == null) { return new Node[0]; } return childNodes.stream() .filter(nodePredicate) .toArray(Node[]::new); }\n\n    ### Response:", "ground_truth": "Filters child nodes.", "predict": "/**\r\n     * Filters the child nodes of this node using the given predicate.\r\n     *\r\n     * @param nodePredicate the predicate to use for filtering the child nodes\r\n     * @return an array of child nodes that match the given predicate\r\n     */\r\n    public Node[] filterChildNodes(final Predicate<Node> nodePredicate);"}, {"ID": 1563, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean check() { if (childNodes == null) { return true; } // children int siblingElementIndex = 0; for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); if (childNode.siblingIndex != i) { return false; } if (childNode.getNodeType() == NodeType.ELEMENT) { if (childNode.siblingElementIndex != siblingElementIndex) { return false; } siblingElementIndex++; } } if (childElementNodesCount != siblingElementIndex) { return false; } // child element nodes if (childElementNodes != null) { if (childElementNodes.length != childElementNodesCount) { return false; } int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { if (childElementNodes[child.siblingElementIndex] != child) { return false; } } } } // sibling names if (siblingNameIndex != -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { if (sibling.siblingNameIndex != index++) { return false; } } } } // process children for (Node childNode : childNodes) { if (!childNode.check()) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Checks the health of child nodes. Useful during complex tree manipulation,\nto check if everything is OK. Not optimized for speed, should be used just\nfor testing purposes.", "predict": "/**\r\n * Checks the validity of the node and its children.\r\n * \r\n * @return true if the node and its children are valid, false otherwise.\r\n */\r\npublic boolean check() {\r\n    // children\r\n    int siblingElementIndex = 0;\r\n    for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\r\n        Node childNode = childNodes.get(i);\r\n        if (childNode.siblingIndex != i) {\r\n            return false;\r\n        }\r\n        if (childNode.getNodeType() == NodeType.ELEMENT) {\r\n            if (childNode.siblingElementIndex != siblingElementIndex) {\r\n                return false;\r\n            }\r\n            siblingElementIndex++;\r\n        }\r\n    }\r\n    if (childElementNodesCount != siblingElementIndex) {\r\n        return false;\r\n    }\r\n    // child element nodes\r\n    if (childElementNodes != null) {\r\n        if (childElementNodes.length != childElementNodesCount) {\r\n            return false;\r\n        }\r\n        int childCount ="}, {"ID": 1564, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initChildElementNodes() { if (childElementNodes == null) { childElementNodes = new Element[childElementNodesCount]; int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { childElementNodes[child.siblingElementIndex] = (Element) child; } } } }\n\n    ### Response:", "ground_truth": "Initializes list of child elements.", "predict": "/**\r\n     * Initializes the child element nodes array.\r\n     */\r\n    protected void initChildElementNodes() {\r\n        if (childElementNodes == null) {\r\n            childElementNodes = new Element[childElementNodesCount];\r\n            int childCount = getChildNodesCount();\r\n            for (int i = 0; i < childCount; i++) {\r\n                Node child = getChild(i);\r\n                if (child.siblingElementIndex >= 0) {\r\n                    childElementNodes[child.siblingElementIndex] = (Element) child;\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 1565, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initSiblingNames() { if (siblingNameIndex == -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { sibling.siblingNameIndex = index++; } } } }\n\n    ### Response:", "ground_truth": "Initializes siblings elements of the same name.", "predict": "/**\r\n     * Initializes the sibling names for the current node.\r\n     */\r\n    protected void initSiblingNames() {\r\n        if (siblingNameIndex == -1) {\r\n            List<Node> siblings = parentNode.childNodes;\r\n            int index = 0;\r\n            for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) {\r\n                Node sibling = siblings.get(i);\r\n                if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) {\r\n                    sibling.siblingNameIndex = index++;\r\n                }\r\n            }\r\n        }\r\n    }"}, {"ID": 1566, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void initChildNodes(final Node newNode) { if (childNodes == null) { childNodes = new ArrayList<>(); } if (ownerDocument != null) { if (newNode.ownerDocument != ownerDocument) { changeOwnerDocument(newNode, ownerDocument); } } }\n\n    ### Response:", "ground_truth": "Initializes child nodes list when needed.\nAlso fix owner document for new node, if needed.", "predict": "/**\r\n     * Initializes the child nodes of this node.\r\n     * \r\n     * @param newNode the new node to be added as a child node\r\n     */\r\n    protected void initChildNodes(final Node newNode) {\r\n        if (childNodes == null) {\r\n            childNodes = new ArrayList<>();\r\n        }\r\n        if (ownerDocument != null) {\r\n            if (newNode.ownerDocument != ownerDocument) {\r\n                changeOwnerDocument(newNode, ownerDocument);\r\n            }\r\n        }\r\n    }"}, {"ID": 1567, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void changeOwnerDocument(final Node node, final Document ownerDocument) { node.ownerDocument = ownerDocument; int childCount = node.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = node.getChild(i); changeOwnerDocument(child, ownerDocument); } }\n\n    ### Response:", "ground_truth": "Changes owner document for given node and all its children.", "predict": "/**\r\n     * This method is used to change the owner document of a node and all its child nodes recursively.\r\n     * \r\n     * @param node The node whose owner document needs to be changed.\r\n     * @param ownerDocument The new owner document.\r\n     */\r\n    protected void changeOwnerDocument(final Node node, final Document ownerDocument) {\r\n        node.ownerDocument = ownerDocument;\r\n        int childCount = node.getChildNodesCount();\r\n        for (int i = 0; i < childCount; i++) {\r\n            Node child = node.getChild(i);\r\n            changeOwnerDocument(child, ownerDocument);\r\n        }\r\n    }"}, {"ID": 1568, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Node getPreviousSiblingName() { if (nodeName == null) { return null; } initSiblingNames(); int index = siblingNameIndex -1; for (int i = siblingIndex; i >= 0; i--) { Node sibling = parentNode.childNodes.get(i); if ((index == sibling.siblingNameIndex) && nodeName.equals(sibling.getNodeName())) { return sibling; } } return null; }\n\n    ### Response:", "ground_truth": "Returns this node's previous sibling element with the same name.", "predict": "/**\r\n     * This method returns the previous sibling node with the same name as the current node.\r\n     * \r\n     * @return the previous sibling node with the same name as the current node, or null if no such node exists.\r\n     */\r\n    public Node getPreviousSiblingName() {\r\n        // code goes here\r\n    }"}, {"ID": 1569, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getTextContent() { StringBuilder sb = new StringBuilder(getChildNodesCount() + 1); appendTextContent(sb); return sb.toString(); }\n\n    ### Response:", "ground_truth": "Returns the text content of this node and its descendants.\n@see #appendTextContent(Appendable)", "predict": "/**\r\n     * This method returns the text content of the current node and its child nodes.\r\n     * \r\n     * @return the text content of the current node and its child nodes\r\n     */\r\n    public String getTextContent() {\r\n        StringBuilder sb = new StringBuilder(getChildNodesCount() + 1);\r\n        appendTextContent(sb);\r\n        return sb.toString();\r\n    }"}, {"ID": 1570, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toHtml(this, new StringBuilder()); }\n\n    ### Response:", "ground_truth": "Generates HTML.", "predict": "/**\r\n     * Returns the HTML representation of the document.\r\n     *\r\n     * @return the HTML representation of the document\r\n     */\r\n    public String getHtml() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1571, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getInnerHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toInnerHtml(this, new StringBuilder()); }\n\n    ### Response:", "ground_truth": "Generates inner HTML.", "predict": "/**\r\n     * Returns the inner HTML of this element.\r\n     * \r\n     * @return the inner HTML of this element\r\n     */\r\n    public String getInnerHtml() {\r\n        // TODO: Implement this method\r\n    }"}, {"ID": 1572, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void visitChildren(final NodeVisitor nodeVisitor) { if (childNodes != null) { for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); childNode.visit(nodeVisitor); } } }\n\n    ### Response:", "ground_truth": "Visits children nodes.", "predict": "/**\r\n     * Visits the children of this node using the specified visitor.\r\n     *\r\n     * @param nodeVisitor the visitor to use to visit the children of this node\r\n     */\r\n    protected void visitChildren(final NodeVisitor nodeVisitor) {\r\n        if (childNodes != null) {\r\n            for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) {\r\n                Node childNode = childNodes.get(i);\r\n                childNode.visit(nodeVisitor);\r\n            }\r\n        }\r\n    }"}, {"ID": 1573, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getCssPath() { StringBuilder path = new StringBuilder(); Node node = this; while (node != null) { String nodeName = node.getNodeName(); if (nodeName != null) { StringBuilder sb = new StringBuilder(); sb.append(' ').append(nodeName); String id = node.getAttribute(\"id\"); if (id != null) { sb.append('#').append(id); } path.insert(0, sb); } node = node.getParentNode(); } if (path.charAt(0) == ' ') { return path.substring(1); } return path.toString(); }\n\n    ### Response:", "ground_truth": "Returns CSS path to this node from document root.", "predict": "/**\r\n     * This method returns the CSS path of the element.\r\n     * \r\n     * @return the CSS path of the element.\r\n     */\r\n    public String getCssPath() {\r\n        StringBuilder path = new StringBuilder();\r\n        Node node = this;\r\n        while (node != null) {\r\n            String nodeName = node.getNodeName();\r\n            if (nodeName != null) {\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.append(' ').append(nodeName);\r\n                String id = node.getAttribute(\"id\");\r\n                if (id != null) {\r\n                    sb.append('#').append(id);\r\n                }\r\n                path.insert(0, sb);\r\n            }\r\n            node = node.getParentNode();\r\n        }\r\n        if (path.charAt(0) == ' ') {\r\n            return path.substring(1);\r\n        }\r\n        return path.toString();\r\n    }"}, {"ID": 1574, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onDecoraTag(final Tag tag) { String tagName = tag.getName().toString(); if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); return; } // closed tag type decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); decoraTagDefaultValueEnd = tag.getTagPosition(); defineDecoraTag(); }\n\n    ### Response:", "ground_truth": "Handle Decora tags.", "predict": "/**\r\n     * This method is called when a decora tag is encountered in the HTML content.\r\n     * \r\n     * @param tag The tag object representing the decora tag.\r\n     */\r\n    protected void onDecoraTag(final Tag tag) {\r\n        String tagName = tag.getName().toString();\r\n        if (tag.getType() == TagType.SELF_CLOSING) {\r\n            checkNestedDecoraTags();\r\n            decoraTagName = tagName.substring(7);\r\n            decoraTagStart = tag.getTagPosition();\r\n            decoraTagEnd = tag.getTagPosition() + tag.getTagLength();\r\n            defineDecoraTag();\r\n            return;\r\n        }\r\n        if (tag.getType() == TagType.START) {\r\n            checkNestedDecoraTags();\r\n            decoraTagName = tagName.substring(7);\r\n            decoraTagStart = tag.getTagPosition();\r\n            decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength();\r\n            return;\r\n        }\r\n        // closed tag type\r\n        decoraTagEnd = tag.getTagPosition()"}, {"ID": 1575, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void onIdAttrStart(final Tag tag) { String id = tag.getId().toString().substring(7); String tagName; String idName; int dashIndex = id.indexOf('-'); if (dashIndex == -1) { tagName = id; idName = null; } else { tagName = id.substring(0, dashIndex); idName = id.substring(dashIndex + 1); } if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); closingTagName = tag.getName().toString(); closingTagDeepLevel = tag.getDeepLevel(); } }\n\n    ### Response:", "ground_truth": "Handle open and empty ID attribute tags.", "predict": "/**\r\n     * This method is called when the parser encounters an opening tag with an id attribute.\r\n     * \r\n     * @param tag The tag object representing the opening tag.\r\n     */\r\n    protected void onIdAttrStart(final Tag tag) {\r\n        String id = tag.getId().toString().substring(7);\r\n        String tagName;\r\n        String idName;\r\n        int dashIndex = id.indexOf('-');\r\n        if (dashIndex == -1) {\r\n            tagName = id;\r\n            idName = null;\r\n        } else {\r\n            tagName = id.substring(0, dashIndex);\r\n            idName = id.substring(dashIndex + 1);\r\n        }\r\n        if (tag.getType() == TagType.SELF_CLOSING) {\r\n            checkNestedDecoraTags();\r\n            decoraTagName = tagName;\r\n            decoraIdName = idName;\r\n            decoraTagStart = tag.getTagPosition();\r\n            decoraTagEnd = tag.getTagPosition() + tag.getTagLength();\r\n            defineDecoraTag();\r\n            return;\r\n        }\r\n       "}, {"ID": 1576, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void defineDecoraTag() { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd) : new DecoraTag( decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd, decoraTagDefaultValueStart, decoraTagDefaultValueEnd - decoraTagDefaultValueStart); decoraTags.add(decoraTag); decoraTagName = null; decoraIdName = null; closingTagName = null; decoraTagDefaultValueStart = 0; }\n\n    ### Response:", "ground_truth": "Defines Decora tag position inside decorator content.\nResets current Decora tag tracking.", "predict": "/**\r\n     * This method defines a new DecoraTag object and adds it to the list of decora tags.\r\n     * If the decoraTagDefaultValueStart is 0, a new DecoraTag object is created with the given tag name, id name, start and end positions.\r\n     * Otherwise, a new DecoraTag object is created with the given tag name, id name, start and end positions, and default value start and end positions.\r\n     */"}, {"ID": 1577, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; }\n\n    ### Response:", "ground_truth": "Adds a proxy aspect.", "predict": "/**\n     * Adds a proxy aspect to the list of aspects to be applied to the proxy.\n     * \n     * @param proxyAspect the proxy aspect to add\n     * @return this instance for chaining\n     * @throws IllegalStateException if the proxy has already been started\n     */\n    @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect) {\n        requireNotStarted(proxetta);\n        this.proxyAspects.add(proxyAspect);\n        return this;\n    }"}, {"ID": 1578, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addRootPackage(final String rootPackage, String mapping) { if (packages == null) { packages = new String[0]; } if (mappings == null) { mappings = new String[0]; } // fix mapping if (mapping.length() > 0) { // mapping must start with the slash if (!mapping.startsWith(StringPool.SLASH)) { mapping = StringPool.SLASH + mapping; } // mapping must NOT end with the slash if (mapping.endsWith(StringPool.SLASH)) { mapping = StringUtil.substring(mapping, 0, -1); } } // detect duplicates for (int i = 0; i < packages.length; i++) { if (packages[i].equals(rootPackage)) { if (mappings[i].equals(mapping)) { // both package and the mappings are the same return; } throw new MadvocException(\"Different mappings for the same root package: \" + rootPackage); } } packages = ArraysUtil.append(packages, rootPackage); mappings = ArraysUtil.append(mappings, mapping); }\n\n    ### Response:", "ground_truth": "Adds root package and its path mapping. Duplicate root packages\nare ignored, if mapping path is equals, otherwise exception is thrown.", "predict": "/**\n     * Adds a new root package to the list of packages and their mappings.\n     *\n     * @param rootPackage the root package to add.\n     * @param mapping the mapping for the root package.\n     * @throws MadvocException if there is already a mapping for the same root package.\n     */\n    public void addRootPackage(final String rootPackage, String mapping) {\n        if (packages == null) {\n            packages = new String[0];\n        }\n        if (mappings == null) {\n            mappings = new String[0];\n        }\n        // fix mapping\n        if (mapping.length() > 0) {\n            // mapping must start with the slash\n            if (!mapping.startsWith(StringPool.SLASH)) {\n                mapping = StringPool.SLASH + mapping;\n            }\n            // mapping must NOT end with the slash\n            if (mapping.endsWith(StringPool.SLASH)) {\n                mapping = StringUtil.substring(mapping, 0, -1);\n            }\n        }\n        // detect duplicates\n       "}, {"ID": 1579, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addRootPackageOf(final Class actionClass, final String mapping) { addRootPackage(actionClass.getPackage().getName(), mapping); }\n\n    ### Response:", "ground_truth": "Sets root package to package of given class.", "predict": "/**\r\n     * Adds the root package of the given action class to the given mapping.\r\n     * \r\n     * @param actionClass the action class whose root package is to be added to the mapping\r\n     * @param mapping the mapping to which the root package is to be added\r\n     */\r\n    public void addRootPackageOf(final Class actionClass, final String mapping) { addRootPackage(actionClass.getPackage().getName(), mapping); }"}, {"ID": 1580, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String findRootPackageForActionPath(final String actionPath) { if (mappings == null) { return null; } int ndx = -1; int delta = Integer.MAX_VALUE; for (int i = 0; i < mappings.length; i++) { String mapping = mappings[i]; boolean found = false; if (actionPath.equals(mapping)) { found = true; } else { mapping += StringPool.SLASH; if (actionPath.startsWith(mapping)) { found = true; } } if (found) { int distance = actionPath.length() - mapping.length(); if (distance < delta) { ndx = i; delta = distance; } } } if (ndx == -1) { return null; } return packages[ndx]; }\n\n    ### Response:", "ground_truth": "Finds closest root package for the given action path.", "predict": "/**\r\n     * Finds the root package for the given action path by comparing it with the mappings provided in the constructor.\r\n     * \r\n     * @param actionPath the action path to find the root package for\r\n     * @return the root package for the given action path, or null if no match was found\r\n     */\r\n    public String findRootPackageForActionPath(final String actionPath) {\r\n        // implementation goes here\r\n    }"}, {"ID": 1581, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveValidationMessage(final HttpServletRequest request, final Violation violation) { ValidationConstraint vc = violation.getConstraint(); String key = vc != null ? vc.getClass().getName() : violation.getName(); String msg = LocalizationUtil.findMessage(request, key); if (msg != null) { return beanTemplateParser.parseWithBean(msg, violation); } return null; }\n\n    ### Response:", "ground_truth": "Prepares validation messages.\nKey is either validation constraint class name or violation name.", "predict": "/**\r\n     * Resolves the validation message for the given violation.\r\n     * \r\n     * @param request\r\n     *            the current HTTP request\r\n     * @param violation\r\n     *            the violation to resolve the message for\r\n     * @return the resolved validation message or null if no message could be found\r\n     */\r\n    public static String resolveValidationMessage(final HttpServletRequest request, final Violation violation) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1582, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BeanReferences removeDuplicateNames() { if (names.length < 2) { return this; } int nullCount = 0; for (int i = 1; i < names.length; i++) { String thisRef = names[i]; if (thisRef == null) { nullCount++; continue; } for (int j = 0; j < i; j++) { if (names[j] == null) { continue; } if (thisRef.equals(names[j])) { names[i] = null; break; } } } if (nullCount == 0) { return this; } String[] newRefs = new String[names.length - nullCount]; int ndx = 0; for (String name : names) { if (name == null) { continue; } newRefs[ndx] = name; ndx++; } return new BeanReferences(newRefs); }\n\n    ### Response:", "ground_truth": "Removes later duplicated references in an array.\nReturns new instance of BeanReferences if there was changes,\notherwise returns the same instance.", "predict": "/**\r\n     * Removes duplicate names from the array of bean references.\r\n     * \r\n     * @return A new BeanReferences object with duplicate names removed.\r\n     */\r\n    public BeanReferences removeDuplicateNames() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1583, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public JoyProps addPropsFile(final String namePattern) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); return this; }\n\n    ### Response:", "ground_truth": "Adds props files or patterns.", "predict": "/**\n     * Adds a new property file pattern to the list of patterns to search for.\n     * \n     * @param namePattern the name pattern to add\n     * @return this instance for chaining\n     * @throws IllegalStateException if the {@link JoyProps} instance has already been started\n     */\n    @Override public JoyProps addPropsFile(final String namePattern) {\n        requireNotStarted(props);\n        this.propsNamePatterns.add(namePattern);\n        return this;\n    }"}, {"ID": 1584, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTarget(final Consumer<Target> targetConsumer) { for (final Target target : targets) { targetConsumer.accept(target); } }\n\n    ### Response:", "ground_truth": "Iterates all targets.", "predict": "/**\r\n     * This method takes a Consumer object as an argument and applies it to each Target object in the targets list.\r\n     * \r\n     * @param targetConsumer A Consumer object that takes a Target object as an argument and performs some action on it.\r\n     */\r\n    public void forEachTarget(final Consumer<Target> targetConsumer) {\r\n        for (final Target target : targets) {\r\n            targetConsumer.accept(target);\r\n        }\r\n    }"}, {"ID": 1585, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.in() == null) { continue; } for (final InjectionPoint in : scopeData.in()) { if (in.scope() != scope) { continue; } biConsumer.accept(target, in); } } }\n\n    ### Response:", "ground_truth": "Iterates all targets and for each target iterates all IN injection points of given scope.", "predict": "/**\r\n     * Iterates over all targets and injection points in the given scope, and applies the given biConsumer to each pair.\r\n     *\r\n     * @param scope the scope to iterate over\r\n     * @param biConsumer the consumer to apply to each pair of target and injection point\r\n     */\r\n    public void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) {\r\n        for (final Target target : targets) {\r\n            final ScopeData scopeData = target.scopeData();\r\n            if (scopeData.in() == null) {\r\n                continue;\r\n            }\r\n            for (final InjectionPoint in : scopeData.in()) {\r\n                if (in.scope() != scope) {\r\n                    continue;\r\n                }\r\n                biConsumer.accept(target, in);\r\n            }\r\n        }\r\n    }"}, {"ID": 1586, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.out() == null) { continue; } for (final InjectionPoint out : scopeData.out()) { if (out.scope() != scope) { continue; } biConsumer.accept(target, out); } } }\n\n    ### Response:", "ground_truth": "Iterates all targets and for each target iterates all OUT injection points of given scope.", "predict": "/**\r\n     * Iterates over all targets and their corresponding injection points that have an output with the given scope.\r\n     *\r\n     * @param scope the scope to match against\r\n     * @param biConsumer the consumer to invoke for each matching target and injection point\r\n     */\r\n    public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) {\r\n        for (final Target target : targets) {\r\n            final ScopeData scopeData = target.scopeData();\r\n            if (scopeData.out() == null) {\r\n                continue;\r\n            }\r\n            for (final InjectionPoint out : scopeData.out()) {\r\n                if (out.scope() != scope) {\r\n                    continue;\r\n                }\r\n                biConsumer.accept(target, out);\r\n            }\r\n        }\r\n    }"}, {"ID": 1587, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object[] extractParametersValues() { final Object[] values = new Object[targets.length - 1]; for (int i = 1; i < targets.length; i++) { values[i - 1] = targets[i].value(); } return values; }\n\n    ### Response:", "ground_truth": "Collects all parameters from target into an array.", "predict": "/**\r\n     * This method extracts the values of the parameters from the target objects and returns them as an array.\r\n     * \r\n     * @return an array of parameter values\r\n     */\r\n    public Object[] extractParametersValues() {\r\n        final Object[] values = new Object[targets.length - 1];\r\n        for (int i = 1; i < targets.length; i++) {\r\n            values[i - 1] = targets[i].value();\r\n        }\r\n        return values;\r\n    }"}, {"ID": 1588, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Target[] makeTargets(final Target actionTarget, final MethodParam[] methodParams) { if (methodParams == null) { // action does not have method parameters, so there is just one target return new Target[]{actionTarget}; } // action has method arguments, so there is more then one target final Target[] target = new Target[methodParams.length + 1]; target[0] = actionTarget; final Object action = actionTarget.value(); for (int i = 0; i < methodParams.length; i++) { final MethodParam methodParam = methodParams[i]; final Class paramType = methodParam.type(); final Target paramTarget; if (methodParam.annotationType() == null) { // parameter is NOT annotated, create new value for the target // the class itself will be a base class, and should be scanned final ScopeData newScopeData = methodParam.scopeData().inspector().inspectClassScopesWithCache(paramType); paramTarget = Target.ofValue(createActionMethodArgument(paramType, action), newScopeData); } else if (methodParam.annotationType() == Out.class) { // parameter is annotated with *only* OUT annotation // create the output value now AND to save the type paramTarget = Target.ofMethodParam(methodParam, createActionMethodArgument(paramType, action)); } else { // parameter is annotated with any IN annotation // create target with NO value, as the value will be created later paramTarget = Target.ofMethodParam(methodParam, type -> createActionMethodArgument(type, action)); } target[i + 1] = paramTarget; } return target; }\n\n    ### Response:", "ground_truth": "Joins action and parameters into one single array of Targets.", "predict": "/**\r\n     * This method creates the targets for the action method.\r\n     * \r\n     * @param actionTarget the target for the action method\r\n     * @param methodParams the method parameters for the action method\r\n     * @return the array of targets for the action method\r\n     */\r\n    protected Target[] makeTargets(final Target actionTarget, final MethodParam[] methodParams) {\r\n        // implementation of the method goes here\r\n    }"}, {"ID": 1589, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodArgument(final Class type, final Object action) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) { // regular or static class return ClassUtil.newInstance(type); } else { // member class Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass()); ctor.setAccessible(true); return ctor.newInstance(action); } } catch (Exception ex) { throw new MadvocException(ex); } }\n\n    ### Response:", "ground_truth": "Creates action method arguments.", "predict": "/**\r\n     * Creates an instance of the given type using the given action as an argument to a constructor.\r\n     * \r\n     * @param type the type to create an instance of\r\n     * @param action the action to use as an argument to the constructor\r\n     * @return the created instance\r\n     * @throws MadvocException if an error occurs during instantiation\r\n     */\r\n    protected Object createActionMethodArgument(final Class type, final Object action) {\r\n        try {\r\n            if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) {\r\n                // regular or static class\r\n                return ClassUtil.newInstance(type);\r\n            } else {\r\n                // member class\r\n                Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass());\r\n                ctor.setAccessible(true);\r\n                return ctor.newInstance(action);\r\n            }\r\n        } catch (Exception ex) {\r\n            throw new MadvocException(ex);\r\n        }\r\n    }"}, {"ID": 1590, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void sessionCreated(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.putIfAbsent(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionCreated(httpSessionEvent); } }\n\n    ### Response:", "ground_truth": "Stores session in map and broadcasts event to registered listeners.", "predict": "/**\r\n     * This method is called when a new session is created. It adds the session to a map and notifies all the registered listeners.\r\n     * \r\n     * @param httpSessionEvent the event that contains information about the session that was created\r\n     */\r\n    @Override\r\n    public void sessionCreated(final HttpSessionEvent httpSessionEvent) {\r\n        HttpSession session = httpSessionEvent.getSession();\r\n        sessionMap.putIfAbsent(session.getId(), session);\r\n        for (HttpSessionListener listener : listeners) {\r\n            listener.sessionCreated(httpSessionEvent);\r\n        }\r\n    }"}, {"ID": 1591, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(session.getId()); for (HttpSessionListener listener : listeners) { listener.sessionDestroyed(httpSessionEvent); } }\n\n    ### Response:", "ground_truth": "Removes session from a map and broadcasts event to registered listeners.", "predict": "/**\r\n     * This method is called when a session is destroyed.\r\n     * \r\n     * @param httpSessionEvent the event that contains the session information\r\n     */\r\n    @Override\r\n    public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) {\r\n        HttpSession session = httpSessionEvent.getSession();\r\n        sessionMap.remove(session.getId());\r\n        for (HttpSessionListener listener : listeners) {\r\n            listener.sessionDestroyed(httpSessionEvent);\r\n        }\r\n    }"}, {"ID": 1592, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonArray add(Object value) { Objects.requireNonNull(value); value = JsonObject.resolveValue(value); list.add(value); return this; }\n\n    ### Response:", "ground_truth": "Adds an object to the JSON array.", "predict": "/**\n     * Adds the specified value to the end of this array.\n     *\n     * @param value the value to be added\n     * @return this array\n     * @throws NullPointerException if the specified value is null\n     */\n    public JsonArray add(Object value) {\n        Objects.requireNonNull(value);\n        value = JsonObject.resolveValue(value);\n        list.add(value);\n        return this;\n    }"}, {"ID": 1593, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JsonArray addAll(final JsonArray array) { Objects.requireNonNull(array); list.addAll(array.list); return this; }\n\n    ### Response:", "ground_truth": "Appends all of the elements in the specified array to the end of this JSON array.", "predict": "/**\r\n     * Adds all elements of the specified array to the end of this array.\r\n     *\r\n     * @param array the array whose elements to add to this array\r\n     * @return this array\r\n     * @throws NullPointerException if the specified array is null\r\n     */\r\n    public JsonArray addAll(final JsonArray array) {\r\n        Objects.requireNonNull(array);\r\n        list.addAll(array.list);\r\n        return this;\r\n    }"}, {"ID": 1594, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Object remove(final int pos) { Object removed = list.remove(pos); if (removed instanceof Map) { return new JsonObject((Map) removed); } if (removed instanceof ArrayList) { return new JsonArray((List) removed); } return removed; }\n\n    ### Response:", "ground_truth": "Removes the value at the specified position in the JSON array.", "predict": "/**\r\n     * Removes the element at the specified position in this list.\r\n     *\r\n     * @param pos the index of the element to be removed\r\n     * @return the element that was removed from the list\r\n     */\r\n    public Object remove(final int pos) {\r\n        Object removed = list.remove(pos);\r\n        if (removed instanceof Map) {\r\n            return new JsonObject((Map) removed);\r\n        } else if (removed instanceof ArrayList) {\r\n            return new JsonArray((List) removed);\r\n        }\r\n        return removed;\r\n    }"}, {"ID": 1595, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveTarget(final ActionRequest actionRequest, final String resultValue) { String resultBasePath = actionRequest.getActionRuntime().getResultBasePath(); ResultPath resultPath = resultMapper.resolveResultPath(resultBasePath, resultValue); String actionPath = resultPath.path(); String path = actionPath; String value = resultPath.value(); if (StringUtil.isEmpty(value)) { value = null; } String target; while (true) { // variant #1: with value if (value != null) { if (path == null) { // only value remains int lastSlashNdx = actionPath.lastIndexOf('/'); if (lastSlashNdx != -1) { target = actionPath.substring(0, lastSlashNdx + 1) + value; } else { target = '/' + value; } } else { target = path + '.' + value; } target = locateTarget(actionRequest, target); if (target != null) { break; } } if (path != null) { // variant #2: without value target = locateTarget(actionRequest, path); if (target != null) { break; } } // continue if (path == null) { // path not found return null; } int dotNdx = MadvocUtil.lastIndexOfDotAfterSlash(path); if (dotNdx == -1) { path = null; } else { path = path.substring(0, dotNdx); } } return target; }\n\n    ### Response:", "ground_truth": "Locates the target file from action path and the result value.", "predict": "/**\n     * Resolves the target for the given action request and result value.\n     * \n     * @param actionRequest the action request\n     * @param resultValue the result value\n     * @return the target or null if not found\n     */\n    protected String resolveTarget(final ActionRequest actionRequest, final String resultValue) {\n        // TODO: implement me\n    }"}, {"ID": 1596, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void targetNotFound(final ActionRequest actionRequest, final String actionAndResultPath) throws IOException { final HttpServletResponse response = actionRequest.getHttpServletResponse(); if (!response.isCommitted()) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath); } }\n\n    ### Response:", "ground_truth": "Called when target not found. By default sends 404 to the response.", "predict": "/**\r\n     * This method handles the case where the target result is not found.\r\n     * \r\n     * @param actionRequest\r\n     *            The action request object.\r\n     * @param actionAndResultPath\r\n     *            The path of the action and result.\r\n     * @throws IOException\r\n     *             If an error occurs while sending the error response.\r\n     */\r\n    protected void targetNotFound(final ActionRequest actionRequest, final String actionAndResultPath) throws IOException {\r\n        final HttpServletResponse response = actionRequest.getHttpServletResponse();\r\n        if (!response.isCommitted()) {\r\n            response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath);\r\n        }\r\n    }"}, {"ID": 1597, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String valueToString(final String name, final Object valueObject) { if (!valueObject.getClass().isArray()) { return valueObject.toString(); } // array String[] array = (String[]) valueObject; if (valueNameIndexes == null) { valueNameIndexes = new HashMap<>(); } MutableInteger index = valueNameIndexes.get(name); if (index == null) { index = new MutableInteger(0); valueNameIndexes.put(name, index); } if (index.value >= array.length) { return null; } String result = array[index.value]; index.value++; return result; }\n\n    ### Response:", "ground_truth": "Converts value to a string.", "predict": "/**\r\n     * Converts the given value to a string representation.\r\n     * \r\n     * @param name the name of the value\r\n     * @param valueObject the value to convert\r\n     * @return the string representation of the value\r\n     */\r\n    protected String valueToString(final String name, final Object valueObject) {\r\n        // implementation details\r\n    }"}, {"ID": 1598, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) { filtersManager.resolve(actionFilterClass); return this; }\n\n    ### Response:", "ground_truth": "Returns action filter instance for further configuration.", "predict": "/**\n     * Adds a filter to the router.\n     * \n     * @param actionFilterClass the class of the filter to add\n     * @return the router itself\n     */\n    public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) {\n        filtersManager.resolve(actionFilterClass);\n        return this;\n    }"}, {"ID": 1599, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getPseudoFunctionName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; }\n\n    ### Response:", "ground_truth": "Returns pseudo-function name.", "predict": "/**\r\n     * This method returns the pseudo function name of the class.\r\n     * \r\n     * @return pseudo function name of the class\r\n     */\r\n    public String getPseudoFunctionName() {\r\n        String name = getClass().getSimpleName().toLowerCase();\r\n        name = name.replace('_', '-');\r\n        return name;\r\n    }"}, {"ID": 1600, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PropertyInjectionPoint[] resolve(Class type, final boolean autowire) { final List<PropertyInjectionPoint> list = new ArrayList<>(); final Set<String> usedPropertyNames = new HashSet<>(); // lookup fields while (type != Object.class) { final ClassDescriptor cd = ClassIntrospector.get().lookup(type); final PropertyDescriptor[] allPropertyDescriptors = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allPropertyDescriptors) { if (propertyDescriptor.isGetterOnly()) { continue; } if (usedPropertyNames.contains(propertyDescriptor.getName())) { continue; } Class propertyType = propertyDescriptor.getType(); if (ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } BeanReferences reference = referencesResolver.readReferenceFromAnnotation(propertyDescriptor); if (reference == null) { if (!autowire) { continue; } else { reference = referencesResolver.buildDefaultReference(propertyDescriptor); } } list.add(new PropertyInjectionPoint(propertyDescriptor, reference)); usedPropertyNames.add(propertyDescriptor.getName()); } // go to the supertype type = type.getSuperclass(); } final PropertyInjectionPoint[] fields; if (list.isEmpty()) { fields = PropertyInjectionPoint.EMPTY; } else { fields = list.toArray(new PropertyInjectionPoint[0]); } return fields; }\n\n    ### Response:", "ground_truth": "Resolves all properties for given type.", "predict": "/**\n     * Resolves the property injection points for the given type.\n     *\n     * @param type the type to resolve the property injection points for\n     * @param autowire whether to autowire unresolved properties\n     * @return the array of property injection points\n     */\n    public PropertyInjectionPoint[] resolve(Class type, final boolean autowire) {\n        final List<PropertyInjectionPoint> list = new ArrayList<>();\n        final Set<String> usedPropertyNames = new HashSet<>();\n        // lookup fields while (type != Object.class) {\n        // ...\n        // }\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ...\n        // ..."}, {"ID": 1601, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private Socket createSocks4ProxySocket(final String host, final int port) { Socket socket = null; final String proxyHost = proxy.getProxyAddress(); final int proxyPort = proxy.getProxyPort(); final String user = proxy.getProxyUsername(); try { socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout); final InputStream in = socket.getInputStream(); final OutputStream out = socket.getOutputStream(); socket.setTcpNoDelay(true); byte[] buf = new byte[1024]; // 1) CONNECT int index = 0; buf[index++] = 4; buf[index++] = 1; buf[index++] = (byte) (port >>> 8); buf[index++] = (byte) (port & 0xff); InetAddress addr = InetAddress.getByName(host); byte[] byteAddress = addr.getAddress(); for (byte byteAddres : byteAddress) { buf[index++] = byteAddres; } if (user != null) { System.arraycopy(user.getBytes(), 0, buf, index, user.length()); index += user.length(); } buf[index++] = 0; out.write(buf, 0, index); // 2) RESPONSE int len = 6; int s = 0; while (s < len) { int i = in.read(buf, s, len - s); if (i <= 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"stream is closed\"); } s += i; } if (buf[0] != 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned VN \" + buf[0]); } if (buf[1] != 90) { try { socket.close(); } catch (Exception ignore) { } throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned CD \" + buf[1]); } byte[] temp = new byte[2]; in.read(temp, 0, 2); return socket; } catch (RuntimeException rtex) { closeSocket(socket); throw rtex; } catch (Exception ex) { closeSocket(socket); throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex); } }\n\n    ### Response:", "ground_truth": "Connects to the SOCKS4 proxy and returns proxified socket.", "predict": "/**\r\n     * Creates a SOCKS4 proxy socket to the specified host and port.\r\n     * \r\n     * @param host the host to connect to\r\n     * @param port the port to connect to\r\n     * @return the socket connected to the proxy\r\n     * @throws HttpException if an error occurs during the connection process\r\n     */\r\n    private Socket createSocks4ProxySocket(final String host, final int port) {\r\n        Socket socket = null;\r\n        final String proxyHost = proxy.getProxyAddress();\r\n        final int proxyPort = proxy.getProxyPort();\r\n        final String user = proxy.getProxyUsername();\r\n        try {\r\n            socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout);\r\n            final InputStream in = socket.getInputStream();\r\n            final OutputStream out = socket.getOutputStream();\r\n            socket.setTcpNoDelay(true);\r\n            byte[] buf = new byte[1024]; // 1) CONNECT\r\n            int index = 0;\r\n            buf[index++] = 4;\r\n            buf[index++] = 1"}, {"ID": 1602, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final int getAttributeCount() { int count = 0; Attribute attribute = this; while (attribute != null) { count += 1; attribute = attribute.nextAttribute; } return count; }\n\n    ### Response:", "ground_truth": "Returns the number of attributes of the attribute list that begins with this attribute.\n\n@return the number of attributes of the attribute list that begins with this attribute.", "predict": "/**\r\n     * Returns the number of attributes in the list.\r\n     * \r\n     * @return the number of attributes in the list.\r\n     */\r\n    final int getAttributeCount() {\r\n        int count = 0;\r\n        Attribute attribute = this;\r\n        while (attribute != null) {\r\n            count += 1;\r\n            attribute = attribute.nextAttribute;\r\n        }\r\n        return count;\r\n    }"}, {"ID": 1603, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Set<ActionResult> getAllActionResults() { final Set<ActionResult> set = new HashSet<>(allResults.size()); allResults.forEachValue(set::add); return set; }\n\n    ### Response:", "ground_truth": "Returns all action results as new set.", "predict": "/**\r\n     * This method returns a set of all the action results stored in the database.\r\n     * @return a set of all the action results stored in the database.\r\n     */\r\n    public Set<ActionResult> getAllActionResults() {\r\n        final Set<ActionResult> set = new HashSet<>(allResults.size());\r\n        allResults.forEachValue(set::add);\r\n        return set;\r\n    }"}, {"ID": 1604, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean equalsOne(final char c, final CharSequence match) { for (int i = 0; i < match.length(); i++) { char aMatch = match.charAt(i); if (c == aMatch) { return true; } } return false; }\n\n    ### Response:", "ground_truth": "Match if one character equals to any of the given character.\n\n@return true if characters match any character from given array,\notherwise false", "predict": "/**\r\n     * Checks if the given character is present in the given character sequence.\r\n     * \r\n     * @param c the character to be checked\r\n     * @param match the character sequence to be searched\r\n     * @return true if the character is present in the character sequence, false otherwise\r\n     */\r\n    public static boolean equalsOne(final char c, final CharSequence match) {\r\n        for (int i = 0; i < match.length(); i++) {\r\n            char aMatch = match.charAt(i);\r\n            if (c == aMatch) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1605, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) { for (int i = index; i < source.length(); i++) { if (equalsOne(source.charAt(i), match)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given charsequence the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "/**\r\n     * Finds the index of the first character in the source that matches the first character in the match.\r\n     * \r\n     * @param source the source string to search in\r\n     * @param index the starting index in the source to search from\r\n     * @param match the string to match against\r\n     * @return the index of the first matching character, or -1 if no match is found\r\n     */\r\n    public static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) {\r\n        for (int i = index; i < source.length(); i++) {\r\n            if (equalsOne(source.charAt(i), match)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1606, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstEqual(final char[] source, final int index, final char match) { for (int i = index; i < source.length; i++) { if (source[i] == match) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given array the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "/**\r\n     * Finds the index of the first occurrence of the given character in the given character array starting from the given index.\r\n     * \r\n     * @param source the character array to search in\r\n     * @param index the starting index in the array\r\n     * @param match the character to find\r\n     * @return the index of the first occurrence of the character, or -1 if not found\r\n     */\r\n    public static int findFirstEqual(final char[] source, final int index, final char match) {\r\n        for (int i = index; i < source.length; i++) {\r\n            if (source[i] == match) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1607, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CommandLine args(final String... arguments) { if (arguments != null && arguments.length > 0) { Collections.addAll(cmdLine, arguments); } return this; }\n\n    ### Response:", "ground_truth": "Adds several arguments.", "predict": "/**\r\n     * Adds the specified arguments to the command line.\r\n     *\r\n     * @param arguments the arguments to add\r\n     * @return this instance\r\n     */\r\n    public CommandLine args(final String... arguments) {\r\n        if (arguments != null && arguments.length > 0) {\r\n            Collections.addAll(cmdLine, arguments);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1608, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CommandLine env(final String key, final String value) { if (env == null) { env = new HashMap<>(); } env.put(key, value); return this; }\n\n    ### Response:", "ground_truth": "Sets environment variable.", "predict": "/**\r\n     * Adds an environment variable to the command line.\r\n     * \r\n     * @param key the key of the environment variable\r\n     * @param value the value of the environment variable\r\n     * @return the updated command line object\r\n     */\r\n    public CommandLine env(final String key, final String value) {\r\n        if (env == null) {\r\n            env = new HashMap<>();\r\n        }\r\n        env.put(key, value);\r\n        return this;\r\n    }"}, {"ID": 1609, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProcessRunner.ProcessResult run() { ByteArrayOutputStream baos = new ByteArrayOutputStream(); out = err = baos; try { baos.write(StringUtil.join(cmdLine, ' ').getBytes()); baos.write(StringPool.BYTES_NEW_LINE); } catch (IOException ignore) { } ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(cmdLine); if (cleanEnvironment) { processBuilder.environment().clear(); } if (env != null) { processBuilder.environment().putAll(env); } processBuilder.directory(workingDirectory); Process process = null; try { process = processBuilder.start(); } catch (IOException ioex) { return writeException(baos, ioex); } StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix); StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix); outputGobbler.start(); errorGobbler.start(); int result; try { result = process.waitFor(); } catch (InterruptedException iex) { return writeException(baos, iex); } outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessRunner.ProcessResult(result, baos.toString()); }\n\n    ### Response:", "ground_truth": "Runs command and returns process result.", "predict": "/**\r\n     * Runs the command line process and returns the result.\r\n     *\r\n     * @return the result of the process execution\r\n     */\r\n    public ProcessRunner.ProcessResult run() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1610, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void invoke(final Object listener, final Class listenerType) { if (listenerType == Init.class) { ((Init) listener).init(); return; } if (listenerType == Start.class) { ((Start) listener).start(); return; } if (listenerType == Ready.class) { ((Ready) listener).ready(); return; } if (listenerType == Stop.class) { ((Stop) listener).stop(); return; } throw new MadvocException(\"Invalid listener\"); }\n\n    ### Response:", "ground_truth": "Invoke the listener based on type.\nNot very OOP, but works.", "predict": "/**\r\n     * Invokes the appropriate method on the given listener based on its type.\r\n     * \r\n     * @param listener the listener object to invoke the method on\r\n     * @param listenerType the type of the listener object\r\n     * @throws MadvocException if the listener type is invalid\r\n     */\r\n    public static void invoke(final Object listener, final Class listenerType) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1611, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void copyFrom(final Frame frame) { inputLocals = frame.inputLocals; inputStack = frame.inputStack; outputStackStart = 0; outputLocals = frame.outputLocals; outputStack = frame.outputStack; outputStackTop = frame.outputStackTop; initializationCount = frame.initializationCount; initializations = frame.initializations; }\n\n    ### Response:", "ground_truth": "Sets this frame to the value of the given frame.\n\nWARNING: after this method is called the two frames share the same data structures. It is\nrecommended to discard the given frame to avoid unexpected side effects.\n\n@param frame The new frame value.", "predict": "/**\n     * Copies the input and output stacks and local variables from the given frame.\n     * \n     * @param frame the frame to copy from\n     */\n    final void copyFrom(final Frame frame) {\n        inputLocals = frame.inputLocals;\n        inputStack = frame.inputStack;\n        outputStackStart = 0;\n        outputLocals = frame.outputLocals;\n        outputStack = frame.outputStack;\n        outputStackTop = frame.outputStackTop;\n        initializationCount = frame.initializationCount;\n        initializations = frame.initializations;\n    }"}, {"ID": 1612, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) { if (type instanceof Integer) { return CONSTANT_KIND | ((Integer) type).intValue(); } else if (type instanceof String) { String descriptor = Type.getObjectType((String) type).getDescriptor(); return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0); } else { return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset); } }\n\n    ### Response:", "ground_truth": "Returns the abstract type corresponding to the given public API frame element type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param type a frame element type described using the same format as in {@link\nMethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\nOpcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n{@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\na NEW instruction (for uninitialized types).\n@return the abstract type corresponding to the given frame element type.", "predict": "/**\r\n     * Returns the abstract type of the given type object.\r\n     *\r\n     * @param symbolTable the symbol table to use for resolving types\r\n     * @param type the type object to get the abstract type for\r\n     * @return the abstract type of the given type object\r\n     */\r\n    public static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\r\n        if (type instanceof Integer) {\r\n            return CONSTANT_KIND | ((Integer) type).intValue();\r\n        } else if (type instanceof String) {\r\n            String descriptor = Type.getObjectType((String) type).getDescriptor();\r\n            return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\r\n        } else {\r\n            return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset);\r\n        }\r\n    }"}, {"ID": 1613, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getAbstractTypeFromDescriptor( final SymbolTable symbolTable, final String buffer, final int offset) { String internalName; switch (buffer.charAt(offset)) { case 'V': return 0; case 'Z': case 'C': case 'B': case 'S': case 'I': return INTEGER; case 'F': return FLOAT; case 'J': return LONG; case 'D': return DOUBLE; case 'L': internalName = buffer.substring(offset + 1, buffer.length() - 1); return REFERENCE_KIND | symbolTable.addType(internalName); case '[': int elementDescriptorOffset = offset + 1; while (buffer.charAt(elementDescriptorOffset) == '[') { ++elementDescriptorOffset; } int typeValue; switch (buffer.charAt(elementDescriptorOffset)) { case 'Z': typeValue = BOOLEAN; break; case 'C': typeValue = CHAR; break; case 'B': typeValue = BYTE; break; case 'S': typeValue = SHORT; break; case 'I': typeValue = INTEGER; break; case 'F': typeValue = FLOAT; break; case 'J': typeValue = LONG; break; case 'D': typeValue = DOUBLE; break; case 'L': internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1); typeValue = REFERENCE_KIND | symbolTable.addType(internalName); break; default: throw new IllegalArgumentException(); } return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue; default: throw new IllegalArgumentException(); } }\n\n    ### Response:", "ground_truth": "Returns the abstract type corresponding to the given type descriptor.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param buffer a string ending with a type descriptor.\n@param offset the start offset of the type descriptor in buffer.\n@return the abstract type corresponding to the given type descriptor.", "predict": "/**\n     * Returns the abstract type of the given descriptor string.\n     *\n     * @param symbolTable the symbol table to use for resolving type names\n     * @param buffer the descriptor string to parse\n     * @param offset the offset in the buffer to start parsing\n     * @return the abstract type of the descriptor string\n     */\n    private static int getAbstractTypeFromDescriptor(final SymbolTable symbolTable, final String buffer, final int offset) {\n        String internalName;\n        switch (buffer.charAt(offset)) {\n            case 'V':\n                return 0;\n            case 'Z':\n            case 'C':\n            case 'B':\n            case 'S':\n            case 'I':\n                return INTEGER;\n            case 'F':\n                return FLOAT;\n            case 'J':\n                return LONG;\n            case 'D':\n                return DOUBLE;\n            case 'L':\n                internalName = buffer.substring(offset + 1, buffer.length() - 1);\n                return REFERENCE_KIND | symbolTable.addType(internalName);\n            case"}, {"ID": 1614, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < numLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int numStackTop = 0; for (int i = 0; i < numStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++numStackTop; } } inputStack = new int[numStack + numStackTop]; int inputStackIndex = 0; for (int i = 0; i < numStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; }\n\n    ### Response:", "ground_truth": "Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param numLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param numStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}.", "predict": "/**\r\n     * Sets the input frame from the API format.\r\n     * \r\n     * @param symbolTable the symbol table\r\n     * @param numLocal the number of local variables\r\n     * @param local the local variables in the API format\r\n     * @param numStack the number of stack elements\r\n     * @param stack the stack elements in the API format\r\n     */\r\n    final void setInputFrameFromApiFormat(final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) {\r\n        int inputLocalIndex = 0;\r\n        for (int i = 0; i < numLocal; ++i) {\r\n            inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);\r\n            if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {\r\n                inputLocals[inputLocalIndex++] = TOP;\r\n            }\r\n        }\r\n        while (inputLocalIndex < inputLocals.length) {\r\n            inputLocal"}, {"ID": 1615, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getLocal(final int localIndex) { if (outputLocals == null || localIndex >= outputLocals.length) { // If this local has never been assigned in this basic block, it is still equal to its value // in the input frame. return LOCAL_KIND | localIndex; } else { int abstractType = outputLocals[localIndex]; if (abstractType == 0) { // If this local has never been assigned in this basic block, so it is still equal to its // value in the input frame. abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex; } return abstractType; } }\n\n    ### Response:", "ground_truth": "Returns the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the local variable whose value must be returned.\n@return the abstract type stored at the given local variable index in the output frame.", "predict": "/**\r\n     * Returns the abstract type of the local variable at the given index.\r\n     * \r\n     * @param localIndex the index of the local variable to get the abstract type of\r\n     * @return the abstract type of the local variable at the given index\r\n     */\r\n    private int getLocal(final int localIndex) {\r\n        if (outputLocals == null || localIndex >= outputLocals.length) {\r\n            // If this local has never been assigned in this basic block, it is still equal to its value\r\n            // in the input frame.\r\n            return LOCAL_KIND | localIndex;\r\n        } else {\r\n            int abstractType = outputLocals[localIndex];\r\n            if (abstractType == 0) {\r\n                // If this local has never been assigned in this basic block, so it is still equal to its\r\n                // value in the input frame.\r\n                abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;\r\n            }\r\n            return abstractType;\r\n        }\r\n    }"}, {"ID": 1616, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setLocal(final int localIndex, final int abstractType) { // Create and/or resize the output local variables array if necessary. if (outputLocals == null) { outputLocals = new int[10]; } int outputLocalsLength = outputLocals.length; if (localIndex >= outputLocalsLength) { int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)]; System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength); outputLocals = newOutputLocals; } // Set the local variable. outputLocals[localIndex] = abstractType; }\n\n    ### Response:", "ground_truth": "Replaces the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the output frame local variable that must be set.\n@param abstractType the value that must be set.", "predict": "/**\r\n     * Sets the local variable at the given index to the given abstract type.\r\n     * \r\n     * @param localIndex the index of the local variable to set\r\n     * @param abstractType the abstract type to set the local variable to\r\n     */\r\n    private void setLocal(final int localIndex, final int abstractType) {\r\n        // Create and/or resize the output local variables array if necessary.\r\n        if (outputLocals == null) {\r\n            outputLocals = new int[10];\r\n        }\r\n        int outputLocalsLength = outputLocals.length;\r\n        if (localIndex >= outputLocalsLength) {\r\n            int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];\r\n            System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);\r\n            outputLocals = newOutputLocals;\r\n        }\r\n        // Set the local variable.\r\n        outputLocals[localIndex] = abstractType;\r\n   "}, {"ID": 1617, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final int abstractType) { // Create and/or resize the output stack array if necessary. if (outputStack == null) { outputStack = new int[10]; } int outputStackLength = outputStack.length; if (outputStackTop >= outputStackLength) { int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)]; System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength); outputStack = newOutputStack; } // Pushes the abstract type on the output stack. outputStack[outputStackTop++] = abstractType; // Updates the maximum size reached by the output stack, if needed (note that this size is // relative to the input stack size, which is not known yet). short outputStackSize = (short) (outputStackStart + outputStackTop); if (outputStackSize > owner.outputStackMax) { owner.outputStackMax = outputStackSize; } }\n\n    ### Response:", "ground_truth": "Pushes the given abstract type on the output frame stack.\n\n@param abstractType an abstract type.", "predict": "/**\r\n     * Pushes the abstract type on the output stack.\r\n     * \r\n     * @param abstractType the abstract type to be pushed on the output stack.\r\n     */\r\n    private void push(final int abstractType) {\r\n        // Create and/or resize the output stack array if necessary.\r\n        if (outputStack == null) {\r\n            outputStack = new int[10];\r\n        }\r\n        int outputStackLength = outputStack.length;\r\n        if (outputStackTop >= outputStackLength) {\r\n            int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];\r\n            System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);\r\n            outputStack = newOutputStack;\r\n        }\r\n        // Pushes the abstract type on the output stack.\r\n        outputStack[outputStackTop++] = abstractType;\r\n        // Updates the maximum size reached by the output stack, if needed (note that this size is\r\n        // relative to the input stack size,"}, {"ID": 1618, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void push(final SymbolTable symbolTable, final String descriptor) { int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0; int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset); if (abstractType != 0) { push(abstractType); if (abstractType == LONG || abstractType == DOUBLE) { push(TOP); } } }\n\n    ### Response:", "ground_truth": "Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param descriptor a type or method descriptor (in which case its return type is pushed).", "predict": "/**\r\n     * Pushes the abstract type of the given descriptor onto the operand stack.\r\n     * \r\n     * @param symbolTable the symbol table to use for resolving type names\r\n     * @param descriptor the descriptor to get the abstract type from\r\n     */\r\n    private void push(final SymbolTable symbolTable, final String descriptor) {\r\n        int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0;\r\n        int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);\r\n        if (abstractType != 0) {\r\n            push(abstractType);\r\n            if (abstractType == LONG || abstractType == DOUBLE) {\r\n                push(TOP);\r\n            }\r\n        }\r\n    }"}, {"ID": 1619, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pop(final int elements) { if (outputStackTop >= elements) { outputStackTop -= elements; } else { // If the number of elements to be popped is greater than the number of elements in the output // stack, clear it, and pop the remaining elements from the input stack. outputStackStart -= elements - outputStackTop; outputStackTop = 0; } }\n\n    ### Response:", "ground_truth": "Pops the given number of abstract types from the output frame stack.\n\n@param elements the number of abstract types that must be popped.", "predict": "/**\r\n     * Pops the specified number of elements from the output stack. If the number of elements to be popped is greater than the number of elements in the output stack, clear it, and pop the remaining elements from the input stack.\r\n     * \r\n     * @param elements the number of elements to be popped\r\n     */\r\n    private void pop(final int elements) {\r\n        if (outputStackTop >= elements) {\r\n            outputStackTop -= elements;\r\n        } else {\r\n            // If the number of elements to be popped is greater than the number of elements in the output stack, clear it, and pop the remaining elements from the input stack.\r\n            outputStackStart -= elements - outputStackTop;\r\n            outputStackTop = 0;\r\n        }\r\n    }"}, {"ID": 1620, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void pop(final String descriptor) { char firstDescriptorChar = descriptor.charAt(0); if (firstDescriptorChar == '(') { pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1); } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') { pop(2); } else { pop(1); } }\n\n    ### Response:", "ground_truth": "Pops as many abstract types from the output frame stack as described by the given descriptor.\n\n@param descriptor a type or method descriptor (in which case its argument types are popped).", "predict": "/**\r\n     * Pops the arguments and return value of the given method descriptor from the operand stack.\r\n     * \r\n     * @param descriptor the method descriptor of the method to pop\r\n     */\r\n    private void pop(final String descriptor) {\r\n        char firstDescriptorChar = descriptor.charAt(0);\r\n        if (firstDescriptorChar == '(') {\r\n            pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1);\r\n        } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') {\r\n            pop(2);\r\n        } else {\r\n            pop(1);\r\n        }\r\n    }"}, {"ID": 1621, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addInitializedType(final int abstractType) { // Create and/or resize the initializations array if necessary. if (initializations == null) { initializations = new int[2]; } int initializationsLength = initializations.length; if (initializationCount >= initializationsLength) { int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)]; System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength); initializations = newInitializations; } // Store the abstract type. initializations[initializationCount++] = abstractType; }\n\n    ### Response:", "ground_truth": "Adds an abstract type to the list of types on which a constructor is invoked in the basic\nblock.\n\n@param abstractType an abstract type on a which a constructor is invoked.", "predict": "/**\r\n     * Adds an initialized type to the list of initializations.\r\n     * \r\n     * @param abstractType the abstract type to add\r\n     */\r\n    private void addInitializedType(final int abstractType) {\r\n        // Create and/or resize the initializations array if necessary.\r\n        if (initializations == null) {\r\n            initializations = new int[2];\r\n        }\r\n        int initializationsLength = initializations.length;\r\n        if (initializationCount >= initializationsLength) {\r\n            int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)];\r\n            System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);\r\n            initializations = newInitializations;\r\n        }\r\n        // Store the abstract type.\r\n        initializations[initializationCount++] = abstractType;\r\n    }"}, {"ID": 1622, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) { if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) { for (int i = 0; i < initializationCount; ++i) { int initializedType = initializations[i]; int dim = initializedType & DIM_MASK; int kind = initializedType & KIND_MASK; int value = initializedType & VALUE_MASK; if (kind == LOCAL_KIND) { initializedType = dim + inputLocals[value]; } else if (kind == STACK_KIND) { initializedType = dim + inputStack[inputStack.length - value]; } if (abstractType == initializedType) { if (abstractType == UNINITIALIZED_THIS) { return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName()); } else { return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value); } } } } return abstractType; }\n\n    ### Response:", "ground_truth": "Returns the \"initialized\" abstract type corresponding to the given abstract type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type.\n@return the REFERENCE_KIND abstract type corresponding to abstractType if it is\nUNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\nconstructor is invoked in the basic block. Otherwise returns abstractType.", "predict": "/**\r\n     * Returns the type of the given abstract type, after resolving any uninitialized types.\r\n     *\r\n     * @param symbolTable the symbol table to use for resolving types\r\n     * @param abstractType the abstract type to resolve\r\n     * @return the resolved type\r\n     */\r\n    private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1623, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    static void putAbstractType( final SymbolTable symbolTable, final int abstractType, final ByteVector output) { int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT; if (arrayDimensions == 0) { int typeValue = abstractType & VALUE_MASK; switch (abstractType & KIND_MASK) { case CONSTANT_KIND: output.putByte(typeValue); break; case REFERENCE_KIND: output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index); break; case UNINITIALIZED_KIND: output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data); break; default: throw new AssertionError(); } } else { // Case of an array type, we need to build its descriptor first. StringBuilder typeDescriptor = new StringBuilder(); while (arrayDimensions-- > 0) { typeDescriptor.append('['); } if ((abstractType & KIND_MASK) == REFERENCE_KIND) { typeDescriptor .append('L') .append(symbolTable.getType(abstractType & VALUE_MASK).value) .append(';'); } else { switch (abstractType & VALUE_MASK) { case Frame.ITEM_ASM_BOOLEAN: typeDescriptor.append('Z'); break; case Frame.ITEM_ASM_BYTE: typeDescriptor.append('B'); break; case Frame.ITEM_ASM_CHAR: typeDescriptor.append('C'); break; case Frame.ITEM_ASM_SHORT: typeDescriptor.append('S'); break; case Frame.ITEM_INTEGER: typeDescriptor.append('I'); break; case Frame.ITEM_FLOAT: typeDescriptor.append('F'); break; case Frame.ITEM_LONG: typeDescriptor.append('J'); break; case Frame.ITEM_DOUBLE: typeDescriptor.append('D'); break; default: throw new AssertionError(); } } output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index); } }\n\n    ### Response:", "ground_truth": "Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\nformat used in StackMapTable attributes.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\nFrame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n@param output where the abstract type must be put.\n@see JVMS\n4.7.4", "predict": "/**\n     * Adds the given abstract type to the output byte vector.\n     *\n     * @param symbolTable the symbol table to use to resolve references.\n     * @param abstractType the abstract type to add to the output.\n     * @param output the output byte vector to which to add the type.\n     */\n    static void putAbstractType(final SymbolTable symbolTable, final int abstractType, final ByteVector output) {\n        int arrayDimensions = (abstractType & Frame.DIM_MASK) >> Frame.DIM_SHIFT;\n        if (arrayDimensions == 0) {\n            int typeValue = abstractType & Frame.VALUE_MASK;\n            switch (abstractType & Frame.KIND_MASK) {\n                case Frame.CONSTANT_KIND:\n                    output.putByte(typeValue);\n                    break;\n                case Frame.REFERENCE_KIND:\n                    output.putByte(Frame.ITEM_OBJECT).putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);\n                    break;\n                case Frame."}, {"ID": 1624, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected int pruneCache() { int count = 0; Iterator<CacheObject<K,V>> values = cacheMap.values().iterator(); while (values.hasNext()) { CacheObject co = values.next(); if (co.isExpired()) { values.remove(); count++; } } return count; }\n\n    ### Response:", "ground_truth": "Prunes expired elements from the cache. Returns the number of removed objects.", "predict": "/**\r\n     * Prunes the cache of expired objects.\r\n     * \r\n     * @return the number of objects removed from the cache.\r\n     */\r\n    @Override\r\n    protected int pruneCache() {\r\n        int count = 0;\r\n        Iterator<CacheObject<K, V>> values = cacheMap.values().iterator();\r\n        while (values.hasNext()) {\r\n            CacheObject co = values.next();\r\n            if (co.isExpired()) {\r\n                values.remove();\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }"}, {"ID": 1625, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void schedulePrune(final long delay) { if (pruneTimer != null) { pruneTimer.cancel(); } pruneTimer = new Timer(); pruneTimer.schedule( new TimerTask() { @Override public void run() { prune(); } }, delay, delay ); }\n\n    ### Response:", "ground_truth": "Schedules prune.", "predict": "/**\r\n     * Schedules a prune operation to occur after a specified delay.\r\n     * \r\n     * @param delay the delay in milliseconds before the prune operation occurs\r\n     */\r\n    public void schedulePrune(final long delay) {\r\n        if (pruneTimer != null) {\r\n            pruneTimer.cancel();\r\n        }\r\n        pruneTimer = new Timer();\r\n        pruneTimer.schedule(new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                prune();\r\n            }\r\n        }, delay, delay);\r\n    }"}, {"ID": 1626, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ModuleVisitor visitModule(final String name, final int access, final String version) { if (api < Opcodes.ASM6) { throw new UnsupportedOperationException(\"This feature requires ASM6\"); } if (cv != null) { return cv.visitModule(name, access, version); } return null; }\n\n    ### Response:", "ground_truth": "Visit the module corresponding to the class.\n\n@param name the fully qualified name (using dots) of the module.\n@param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\nACC_MANDATED}.\n@param version the module version, or {@literal null}.\n@return a visitor to visit the module values, or {@literal null} if this visitor is not\ninterested in visiting this module.", "predict": "/**\r\n     * Visits a module declaration.\r\n     * \r\n     * @param name the name of the module.\r\n     * @param access the access flags of the module, among {@link Opcodes#ACC_OPEN},\r\n     *        {@link Opcodes#ACC_SYNTHETIC}, {@link Opcodes#ACC_MANDATED},\r\n     *        {@link Opcodes#ACC_TRANSITIVE}, and {@link Opcodes#ACC_STATIC}.\r\n     * @param version the version of the module.\r\n     * @return a visitor to visit the module members, or {@literal null} if this visitor is not\r\n     *         interested in visiting the module members. The visitor may or may not visit the\r\n     *         module itself, depending on the implementation of the visitor.\r\n     * @throws UnsupportedOperationException if the visitor class does not support visiting modules\r\n     *         or if the visitor class does not support the current API version.\r\n     */\r\n    public ModuleVisitor visitModule(final String name, final int access, final String version) {\r\n        if (api"}, {"ID": 1627, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitNestHost(final String nestHost) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestHost(nestHost); } }\n\n    ### Response:", "ground_truth": "Visits the nest host class of the class. A nest is a set of classes of the same package that\nshare access to their private members. One of these classes, called the host, lists the other\nmembers of the nest, which in turn should link to the host of their nest. This method must be\ncalled only once and only if the visited class is a non-host member of a nest. A class is\nimplicitly its own nest, so it's invalid to call this method with the visited class name as\nargument.\n\n@param nestHost the internal name of the host class of the nest.", "predict": "/**\n     * Visits the nest host attribute of the class.\n     *\n     * @param nestHost the value of the nest host attribute of this class, or null if the class does not have a nest host attribute.\n     */\n    public void visitNestHost(final String nestHost) {\n        if (api < Opcodes.ASM7) {\n            throw new UnsupportedOperationException(\"This feature requires ASM7\");\n        }\n        if (cv != null) {\n            cv.visitNestHost(nestHost);\n        }\n    }"}, {"ID": 1628, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitOuterClass(final String owner, final String name, final String descriptor) { if (cv != null) { cv.visitOuterClass(owner, name, descriptor); } }\n\n    ### Response:", "ground_truth": "Visits the enclosing class of the class. This method must be called only if the class has an\nenclosing class.\n\n@param owner internal name of the enclosing class of the class.\n@param name the name of the method that contains the class, or {@literal null} if the class is\nnot enclosed in a method of its enclosing class.\n@param descriptor the descriptor of the method that contains the class, or {@literal null} if\nthe class is not enclosed in a method of its enclosing class.", "predict": "/**\n     * Visits the enclosing class of the current class.\n     *\n     * @param owner the internal name of the enclosing class of the current class.\n     * @param name the simple name of the enclosing class of the current class.\n     * @param descriptor the descriptor of the enclosing class of the current class.\n     */\n    public void visitOuterClass(final String owner, final String name, final String descriptor) {\n        if (cv != null) {\n            cv.visitOuterClass(owner, name, descriptor);\n        }\n    }"}, {"ID": 1629, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (cv != null) { return cv.visitAnnotation(descriptor, visible); } return null; }\n\n    ### Response:", "ground_truth": "Visits an annotation of the class.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": "/**\r\n     * Visits an annotation of the method. The annotation values are passed in an array of pairs of values. The array is\r\n     * indexed by the annotation type's index in the type array of the enclosing class.\r\n     *\r\n     * @param descriptor the class descriptor of the annotation class.\r\n     * @param visible true if the annotation is visible at runtime.\r\n     * @return a visitor to visit the annotation values, or null if this visitor is not interested in visiting\r\n     *         this annotation.\r\n     */\r\n    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\r\n        if (cv != null) {\r\n            return cv.visitAnnotation(descriptor, visible);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1630, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitNestMember(final String nestMember) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestMember(nestMember); } }\n\n    ### Response:", "ground_truth": "Visits a member of the nest. A nest is a set of classes of the same package that share access\nto their private members. One of these classes, called the host, lists the other members of the\nnest, which in turn should link to the host of their nest. This method must be called only if\nthe visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\nit's invalid to call this method with the visited class name as argument.\n\n@param nestMember the internal name of a nest member.", "predict": "/**\n     * Visits a nest member.\n     *\n     * @param nestMember the name of the nest member.\n     * @throws UnsupportedOperationException if the feature requires ASM7 or if the class version is not supported.\n     */\n    public void visitNestMember(final String nestMember) {\n        if (api < Opcodes.ASM7) {\n            throw new UnsupportedOperationException(\"This feature requires ASM7\");\n        }\n        if (cv != null) {\n            cv.visitNestMember(nestMember);\n        }\n    }"}, {"ID": 1631, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitInnerClass( final String name, final String outerName, final String innerName, final int access) { if (cv != null) { cv.visitInnerClass(name, outerName, innerName, access); } }\n\n    ### Response:", "ground_truth": "Visits information about an inner class. This inner class is not necessarily a member of the\nclass being visited.\n\n@param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@param outerName the internal name of the class to which the inner class belongs (see {@link\nType#getInternalName()}). May be {@literal null} for not member classes.\n@param innerName the (simple) name of the inner class inside its enclosing class. May be\n{@literal null} for anonymous inner classes.\n@param access the access flags of the inner class as originally declared in the enclosing\nclass.", "predict": "/**\r\n     * Visits a class or interface declaration contained within the body of another class or interface declaration.\r\n     *\r\n     * @param name the internal name of the class or interface, which may be an array type name\r\n     * @param outerName the internal name of the outer class or interface, or null if the class or interface is not a member of a nested class or interface\r\n     * @param innerName the simple name of the class or interface, which may be an array type name\r\n     * @param access the modifiers and signature of the class or interface, encoded as an integer\r\n     */\r\n    public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {\r\n        if (cv != null) {\r\n            cv.visitInnerClass(name, outerName, innerName, access);\r\n        }\r\n    }"}, {"ID": 1632, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public FieldVisitor visitField( final int access, final String name, final String descriptor, final String signature, final Object value) { if (cv != null) { return cv.visitField(access, name, descriptor, signature, value); } return null; }\n\n    ### Response:", "ground_truth": "Visits a field of the class.\n\n@param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\nthe field is synthetic and/or deprecated.\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).\n@param signature the field's signature. May be {@literal null} if the field's type does not use\ngeneric types.\n@param value the field's initial value. This parameter, which may be {@literal null} if the\nfield does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\nLong}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\nor {@code String} fields respectively). This parameter is only used for static\nfields. Its value is ignored for non static fields, which must be initialized through\nbytecode instructions in constructors or methods.\n@return a visitor to visit field annotations and attributes, or {@literal null} if this class\nvisitor is not interested in visiting these annotations and attributes.", "predict": "/**\r\n     * Visits a field of the class. This method is called by the JVM when a field is encountered in the class file.\r\n     * \r\n     * @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if the field is synthetic and/or deprecated.\r\n     * @param name the field's name.\r\n     * @param descriptor the field's descriptor (in JVM format).\r\n     * @param signature the field's signature. May be null if the field's type does not use generic types.\r\n     * @param value the field's initial value. This parameter, which may be null, is only used for static fields, and is ignored for non-static fields.\r\n     * @return a visitor to visit the field's annotations and attributes, or null if this visitor is not interested in visiting these annotations and attributes.\r\n     */\r\n    public FieldVisitor visitField(final int access, final String name, final String descriptor, final String signature, final Object value) {\r\n        if (cv != null) {\r\n            return cv"}, {"ID": 1633, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static DbThreadSession getThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session == null) { session = new DbThreadSession(); } return session; }\n\n    ### Response:", "ground_truth": "Returns existing thread session, or new one if already not exist. If session doesn't exist, it will be created\nusing default connection provider.", "predict": "/**\r\n * This method retrieves the current thread-bound session object from the ThreadDbSessionHolder class. If the session object is null, a new instance of the DbThreadSession class is created and returned.\r\n * @return The current thread-bound session object.\r\n */\r\npublic static DbThreadSession getThreadSession() {\r\n    DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get();\r\n    if (session == null) {\r\n        session = new DbThreadSession();\r\n    }\r\n    return session;\r\n}"}, {"ID": 1634, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session != null) { session.closeSession(); } }\n\n    ### Response:", "ground_truth": "Closes thread session.", "predict": "/**\r\n     * This method is used to close the thread-level database session.\r\n     */\r\n    public static void closeThreadSession() {\r\n        DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get();\r\n        if (session != null) {\r\n            session.closeSession();\r\n        }\r\n    }"}, {"ID": 1635, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionWrapper[] createExecutionArray() { int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0); int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0); ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1]; // filters int index = 0; if (totalFilters > 0) { System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters); index += totalFilters; } // result is executed AFTER the action AND interceptors executionArray[index++] = actionRequest -> { Object actionResult = actionRequest.invoke(); ActionRequest.this.madvocController.render(ActionRequest.this, actionResult); return actionResult; }; // interceptors if (totalInterceptors > 0) { System.arraycopy(actionRuntime.getInterceptors(), 0, executionArray, index, totalInterceptors); index += totalInterceptors; } // action executionArray[index] = actionRequest -> { actionResult = invokeActionMethod(); return actionResult; }; return executionArray; }\n\n    ### Response:", "ground_truth": "Creates execution array that will invoke all filters, actions and results\nin correct order.", "predict": "/**\r\n     * Creates an array of ActionWrappers that will be executed in order to process the action request.\r\n     * \r\n     * @return an array of ActionWrappers that will be executed in order to process the action request.\r\n     */\r\n    protected ActionWrapper[] createExecutionArray() {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1636, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object invokeActionMethod() throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return null; } final Object[] params = targets.extractParametersValues(); try { return actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } }\n\n    ### Response:", "ground_truth": "Invokes action method after starting all interceptors.\nAfter method invocation, all interceptors will finish, in opposite order.", "predict": "/**\r\n     * Invokes the action method on the action object with the extracted parameters values.\r\n     * \r\n     * @return the result of the action method invocation.\r\n     * @throws Exception if an error occurs during the invocation.\r\n     */\r\n    protected Object invokeActionMethod() throws Exception {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1637, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String readRequestBody() { if (requestBody == null) { try { requestBody = ServletUtil.readRequestBodyFromStream(getHttpServletRequest()); } catch (IOException ioex) { requestBody = StringPool.EMPTY; } } return requestBody; }\n\n    ### Response:", "ground_truth": "Reads request body only once and returns it to user.", "predict": "/**\r\n     * This method reads the request body from the input stream of the HTTP request.\r\n     * If the request body is null, it reads it from the input stream using the ServletUtil class.\r\n     * If an IOException occurs, it sets the request body to an empty string.\r\n     * @return the request body as a string\r\n     */"}, {"ID": 1638, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) { if (total == 0) { return 0; } if (page < 1) { page = 1; } int first = (page - 1) * pageSize; if (first >= total) { first = ((total - 1) / pageSize) * pageSize; // first item on the last page } return first; }\n\n    ### Response:", "ground_truth": "Calculates the first item index of requested page.", "predict": "/**\r\n     * Calculates the index of the first item on a given page.\r\n     * \r\n     * @param page the page number (starting from 1)\r\n     * @param pageSize the number of items per page\r\n     * @param total the total number of items\r\n     * @return the index of the first item on the given page\r\n     */\r\n    public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) {\r\n        if (total == 0) {\r\n            return 0;\r\n        }\r\n        if (page < 1) {\r\n            page = 1;\r\n        }\r\n        int first = (page - 1) * pageSize;\r\n        if (first >= total) {\r\n            first = ((total - 1) / pageSize) * pageSize; // first item on the last page\r\n        }\r\n        return first;\r\n    }"}, {"ID": 1639, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int calcFirstItemIndexOfPage(final PageRequest pageRequest, final int total) { return calcFirstItemIndexOfPage(pageRequest.getPage(), pageRequest.getSize(), total); }\n\n    ### Response:", "ground_truth": "Calculates first item index of the page.", "predict": "/**\r\n     * Calculates the index of the first item on a page based on the page number, page size, and total number of items.\r\n     *\r\n     * @param pageRequest the page request object containing the page number and page size\r\n     * @param total the total number of items\r\n     * @return the index of the first item on the page\r\n     */\r\n    public static int calcFirstItemIndexOfPage(final PageRequest pageRequest, final int total) {\r\n        return calcFirstItemIndexOfPage(pageRequest.getPage(), pageRequest.getSize(), total);\r\n    }"}, {"ID": 1640, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean match(final int value) { if (a == 0) { return value == b; } if (a > 0) { if (value < b) { return false; } return (value - b) % a == 0; } if (value > b) { return false; } return (b - value) % (-a) == 0; }\n\n    ### Response:", "ground_truth": "Matches expression with the value.", "predict": "/**\r\n     * This method checks if the given value matches the pattern of the given a, b, and c values.\r\n     * \r\n     * @param value the value to check against the pattern\r\n     * @return true if the value matches the pattern, false otherwise\r\n     */\r\n    public boolean match(final int value) {\r\n        if (a == 0) {\r\n            return value == b;\r\n        } else if (a > 0) {\r\n            if (value < b) {\r\n                return false;\r\n            }\r\n            return (value - b) % a == 0;\r\n        } else if (value > b) {\r\n            return false;\r\n        }\r\n        return (b - value) % (-a) == 0;\r\n    }"}, {"ID": 1641, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] toRawByteArray(final char[] carr) { byte[] barr = new byte[carr.length << 1]; for (int i = 0, bpos = 0; i < carr.length; i++) { char c = carr[i]; barr[bpos++] = (byte) ((c & 0xFF00) >> 8); barr[bpos++] = (byte) (c & 0x00FF); } return barr; }\n\n    ### Response:", "ground_truth": "Converts char array into byte array by replacing each character with two bytes.", "predict": "/**\r\n     * Converts a char array to a byte array in raw (uncompressed) format.\r\n     * \r\n     * @param carr the char array to convert\r\n     * @return the byte array in raw (uncompressed) format\r\n     */\r\n    public static byte[] toRawByteArray(final char[] carr) {\r\n        byte[] barr = new byte[carr.length << 1];\r\n        for (int i = 0, bpos = 0; i < carr.length; i++) {\r\n            char c = carr[i];\r\n            barr[bpos++] = (byte) ((c & 0xFF00) >> 8);\r\n            barr[bpos++] = (byte) (c & 0x00FF);\r\n        }\r\n        return barr;\r\n    }"}, {"ID": 1642, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findFirstDiff(final char[] source, final int index, final char[] match) { for (int i = index; i < source.length; i++) { if (!equalsOne(source[i], match)) { return i; } } return -1; }\n\n    ### Response:", "ground_truth": "Finds index of the first character in given array the differs from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": "/**\r\n     * Finds the index of the first character in the source array that is different from the corresponding character in the match array.\r\n     * \r\n     * @param source the source array to search in\r\n     * @param index the starting index in the source array to search from\r\n     * @param match the array of characters to compare with the source array\r\n     * @return the index of the first character in the source array that is different from the corresponding character in the match array, or -1 if no such character is found\r\n     */\r\n    public static int findFirstDiff(final char[] source, final int index, final char[] match) {\r\n        for (int i = index; i < source.length; i++) {\r\n            if (!equalsOne(source[i], match)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }"}, {"ID": 1643, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; }\n\n    ### Response:", "ground_truth": "Renders node name.", "predict": "/**\r\n     * Resolves the node name based on the tag case.\r\n     * \r\n     * @param node the node to resolve the name for\r\n     * @return the resolved node name\r\n     */\r\n    protected String resolveNodeName(final Node node) {\r\n        switch (tagCase) {\r\n            case DEFAULT:\r\n                return node.getNodeName();\r\n            case RAW:\r\n                return node.getNodeRawName();\r\n            case LOWERCASE:\r\n                return node.getNodeRawName().toLowerCase();\r\n            case UPPERCASE:\r\n                return node.getNodeRawName().toUpperCase();\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1644, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveAttributeName(final Node node, final Attribute attribute) { switch (attributeCase) { case DEFAULT: return attribute.getName(); case RAW: return attribute.getRawName(); case LOWERCASE: return attribute.getRawName().toLowerCase(); case UPPERCASE: return attribute.getRawName().toUpperCase(); } return null; }\n\n    ### Response:", "ground_truth": "Renders attribute name.", "predict": "/**\r\n     * Resolves the attribute name based on the attribute case.\r\n     * \r\n     * @param node the node containing the attribute\r\n     * @param attribute the attribute to resolve the name for\r\n     * @return the resolved attribute name\r\n     */\r\n    protected String resolveAttributeName(final Node node, final Attribute attribute) {\r\n        switch (attributeCase) {\r\n            case DEFAULT:\r\n                return attribute.getName();\r\n            case RAW:\r\n                return attribute.getRawName();\r\n            case LOWERCASE:\r\n                return attribute.getRawName().toLowerCase();\r\n            case UPPERCASE:\r\n                return attribute.getRawName().toUpperCase();\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1645, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDoubleQuoted(value)); appendable.append('\\\"'); } }\n\n    ### Response:", "ground_truth": "Renders attribute.", "predict": "/**\n     * Renders the specified attribute of the specified node to the specified appendable.\n     *\n     * @param node the node to render the attribute from\n     * @param attribute the attribute to render\n     * @param appendable the appendable to write the attribute to\n     * @throws IOException if an I/O error occurs\n     */\n    protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException {\n        String name = resolveAttributeName(node, attribute);\n        String value = attribute.getValue();\n        appendable.append(name);\n        if (value != null) {\n            appendable.append('=');\n            appendable.append('\\\"');\n            appendable.append(HtmlEncoder.attributeDoubleQuoted(value));\n            appendable.append('\\\"');\n        }\n    }"}, {"ID": 1646, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final File file) throws IOException { final String extension = FileNameUtil.getExtension(file.getAbsolutePath()); final String data; if (extension.equalsIgnoreCase(\"properties\")) { data = FileUtil.readString(file, StringPool.ISO_8859_1); } else { data = FileUtil.readString(file); } parse(data); return this; }\n\n    ### Response:", "ground_truth": "Loads props from the file. Assumes UTF8 encoding unless\nthe file ends with '.properties', than it uses ISO 8859-1.", "predict": "/**\r\n     * Loads the properties from the specified file.\r\n     * \r\n     * @param file the file to load the properties from\r\n     * @return the Props object\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public Props load(final File file) throws IOException {\r\n        final String extension = FileNameUtil.getExtension(file.getAbsolutePath());\r\n        final String data;\r\n        if (extension.equalsIgnoreCase(\"properties\")) {\r\n            data = FileUtil.readString(file, StringPool.ISO_8859_1);\r\n        } else {\r\n            data = FileUtil.readString(file);\r\n        }\r\n        parse(data);\r\n        return this;\r\n    }"}, {"ID": 1647, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final File file, final String encoding) throws IOException { parse(FileUtil.readString(file, encoding)); return this; }\n\n    ### Response:", "ground_truth": "Loads properties from the file in provided encoding.", "predict": "/**\r\n     * Loads the properties from the specified file using the specified encoding.\r\n     *\r\n     * @param file the file to load the properties from\r\n     * @param encoding the encoding to use when reading the file\r\n     * @return the Props object\r\n     * @throws IOException if an error occurs while reading the file\r\n     */\r\n    public Props load(final File file, final String encoding) throws IOException {\r\n        parse(FileUtil.readString(file, encoding));\r\n        return this;\r\n    }"}, {"ID": 1648, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final InputStream in) throws IOException { final Writer out = new FastCharArrayWriter(); StreamUtil.copy(in, out); parse(out.toString()); return this; }\n\n    ### Response:", "ground_truth": "Loads properties from input stream. Stream is not closed at the end.", "predict": "/**\r\n     * Loads properties from an input stream.\r\n     * \r\n     * @param in the input stream to load from\r\n     * @return the loaded properties\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public Props load(final InputStream in) throws IOException {\r\n        final Writer out = new FastCharArrayWriter();\r\n        StreamUtil.copy(in, out);\r\n        parse(out.toString());\r\n        return this;\r\n    }"}, {"ID": 1649, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props load(final Map<?, ?> p) { for (final Map.Entry<?, ?> entry : p.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(name, value.toString(), false); } return this; }\n\n    ### Response:", "ground_truth": "Loads base properties from the provided java properties.\nNull values are ignored.", "predict": "/**\r\n     * Loads the properties from the given map into the current instance.\r\n     *\r\n     * @param p the map to load the properties from\r\n     * @return the current instance\r\n     */\r\n    public Props load(final Map<?, ?> p) {\r\n        for (final Map.Entry<?, ?> entry : p.entrySet()) {\r\n            final String name = entry.getKey().toString();\r\n            final Object value = entry.getValue();\r\n            if (value == null) {\r\n                continue;\r\n            }\r\n            data.putBaseProperty(name, value.toString(), false);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1650, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Props load(final Map<?, ?> map, final String prefix) { String realPrefix = prefix; realPrefix += '.'; for (final Map.Entry entry : map.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(realPrefix + name, value.toString(), false); } return this; }\n\n    ### Response:", "ground_truth": "Loads base properties from java Map using provided prefix.\nNull values are ignored.", "predict": "/**\r\n     * Loads properties from a map into the configuration.\r\n     *\r\n     * @param map the map to load properties from\r\n     * @param prefix the prefix to add to each property name\r\n     * @return the updated configuration object\r\n     */\r\n    public Props load(final Map<?, ?> map, final String prefix) {\r\n        String realPrefix = prefix;\r\n        realPrefix += '.';\r\n        for (final Map.Entry entry : map.entrySet()) {\r\n            final String name = entry.getKey().toString();\r\n            final Object value = entry.getValue();\r\n            if (value == null) {\r\n                continue;\r\n            }\r\n            data.putBaseProperty(realPrefix + name, value.toString(), false);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1651, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Props loadFromClasspath(final String... patterns) { ClassScanner.create() .registerEntryConsumer(entryData -> { String usedEncoding = JoddCore.encoding; if (StringUtil.endsWithIgnoreCase(entryData.name(), \".properties\")) { usedEncoding = StringPool.ISO_8859_1; } final String encoding = usedEncoding; UncheckedException.runAndWrapException(() -> load(entryData.openInputStream(), encoding)); }) .includeResources(true) .ignoreException(true) .excludeCommonJars() .excludeAllEntries(true) .includeEntries(patterns) .scanDefaultClasspath() .start(); return this; }\n\n    ### Response:", "ground_truth": "Loads props and properties from the classpath.", "predict": "/**\r\n     * Loads properties from the classpath.\r\n     *\r\n     * @param patterns the patterns to match the resources\r\n     * @return the Props object\r\n     */\r\n    public Props loadFromClasspath(final String... patterns) {\r\n        // implementation details omitted for brevity\r\n    }"}, {"ID": 1652, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; }\n\n    ### Response:", "ground_truth": "Returns value of property, using active profiles or default value if not found.", "predict": "/**\r\n     * Retrieves the value associated with the given key from the configuration data. If the key is not found, the default value is returned.\r\n     * \r\n     * @param key the key to look up\r\n     * @param defaultValue the default value to return if the key is not found\r\n     * @return the value associated with the key, or the default value if the key is not found\r\n     */\r\n    public String getValueOrDefault(final String key, final String defaultValue) {\r\n        initialize();\r\n        final String value = data.lookupValue(key, activeProfiles);\r\n        if (value == null) {\r\n            return defaultValue;\r\n        }\r\n        return value;\r\n    }"}, {"ID": 1653, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setValue(final String key, final String value, final String profile) { if (profile == null) { data.putBaseProperty(key, value, false); } else { data.putProfileProperty(key, value, profile, false); } initialized = false; }\n\n    ### Response:", "ground_truth": "Sets value on some profile.", "predict": "/**\r\n     * Sets the value of a property in the specified profile or in the base profile.\r\n     * \r\n     * @param key the key of the property to set\r\n     * @param value the value to set the property to\r\n     * @param profile the profile to set the property in, or null to set it in the base profile\r\n     */\r\n    public void setValue(final String key, final String value, final String profile) {\r\n        if (profile == null) {\r\n            data.putBaseProperty(key, value, false);\r\n        } else {\r\n            data.putProfileProperty(key, value, profile, false);\r\n        }\r\n        initialized = false;\r\n    }"}, {"ID": 1654, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractProps(final Map target) { initialize(); data.extract(target, activeProfiles, null, null); }\n\n    ### Response:", "ground_truth": "Extracts props belonging to active profiles.", "predict": "/**\r\n     * Extracts properties from the data source and adds them to the target map.\r\n     *\r\n     * @param target the map to add the extracted properties to\r\n     */\r\n    public void extractProps(final Map target) {\r\n        initialize();\r\n        data.extract(target, activeProfiles, null, null);\r\n    }"}, {"ID": 1655, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractProps(final Map target, final String... profiles) { initialize(); data.extract(target, profiles, null, null); }\n\n    ### Response:", "ground_truth": "Extract props of given profiles.", "predict": "/**\r\n     * Extracts properties from the data source for the specified profiles and adds them to the target map.\r\n     * \r\n     * @param target the map to which the extracted properties will be added\r\n     * @param profiles the profiles for which properties should be extracted\r\n     */\r\n    public void extractProps(final Map target, final String... profiles) {\r\n        initialize();\r\n        data.extract(target, profiles, null, null);\r\n    }"}, {"ID": 1656, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void extractSubProps(final Map target, final String... wildcardPatterns) { initialize(); data.extract(target, activeProfiles, wildcardPatterns, null); }\n\n    ### Response:", "ground_truth": "Extracts subset of properties that matches given wildcards.", "predict": "/**\r\n     * Extracts sub-properties from the configuration data based on the specified wildcard patterns.\r\n     *\r\n     * @param target the target map to store the extracted sub-properties\r\n     * @param wildcardPatterns the wildcard patterns to match the sub-properties\r\n     */\r\n    public void extractSubProps(final Map target, final String... wildcardPatterns) {\r\n        initialize();\r\n        data.extract(target, activeProfiles, wildcardPatterns, null);\r\n    }"}, {"ID": 1657, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public Map<String, Object> innerMap(final String prefix) { initialize(); return data.extract(null, activeProfiles, null, prefix); }\n\n    ### Response:", "ground_truth": "Returns inner map from the props with given prefix. Keys in returned map\nwill not have the prefix.", "predict": "/**\r\n     * This method is used to extract the inner map from the data object.\r\n     * \r\n     * @param prefix - The prefix to be used for the inner map.\r\n     * @return - The inner map extracted from the data object.\r\n     */\r\n    public Map<String, Object> innerMap(final String prefix) {\r\n        initialize();\r\n        return data.extract(null, activeProfiles, null, prefix);\r\n    }"}, {"ID": 1658, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } for (Map.Entry<?, ?> entry : map.entrySet()) { String key = entry.getKey().toString(); key = prefix + key; setValue(key, entry.getValue().toString(), profile); } }\n\n    ### Response:", "ground_truth": "Adds child map to the props on given prefix.", "predict": "/**\r\n     * Adds the entries of the given map to the current map with the given prefix.\r\n     *\r\n     * @param prefix the prefix to add to the keys of the map entries\r\n     * @param map the map to add the entries from\r\n     * @param profile the profile to use for the values\r\n     */\r\n    public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) {\r\n        if (!StringUtil.endsWithChar(prefix, '.')) {\r\n            prefix += StringPool.DOT;\r\n        }\r\n        for (Map.Entry<?, ?> entry : map.entrySet()) {\r\n            String key = entry.getKey().toString();\r\n            key = prefix + key;\r\n            setValue(key, entry.getValue().toString(), profile);\r\n        }\r\n    }"}, {"ID": 1659, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void resolveActiveProfiles() { if (activeProfilesProp == null) { activeProfiles = null; return; } final PropsEntry pv = data.getBaseProperty(activeProfilesProp); if (pv == null) { // no active profile set as the property, exit return; } final String value = pv.getValue(); if (StringUtil.isBlank(value)) { activeProfiles = null; return; } activeProfiles = StringUtil.splitc(value, ','); StringUtil.trimAll(activeProfiles); }\n\n    ### Response:", "ground_truth": "Resolves active profiles from special property.\nThis property can be only a base property!\nIf default active property is not defined, nothing happens.\nOtherwise, it will replace currently active profiles.", "predict": "/**\r\n     * Resolves the active profiles based on the activeProfiles property.\r\n     */\r\n    protected void resolveActiveProfiles() {\r\n        // code here\r\n    }"}, {"ID": 1660, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getAllProfiles() { String[] profiles = new String[data.profileProperties.size()]; int index = 0; for (String profileName : data.profileProperties.keySet()) { profiles[index] = profileName; index++; } return profiles; }\n\n    ### Response:", "ground_truth": "Returns all profiles names.", "predict": "/**\r\n     * This method returns an array of all the profile names stored in the data object.\r\n     * \r\n     * @return an array of all the profile names stored in the data object\r\n     */\r\n    public String[] getAllProfiles() {\r\n        String[] profiles = new String[data.profileProperties.size()];\r\n        int index = 0;\r\n        for (String profileName : data.profileProperties.keySet()) {\r\n            profiles[index] = profileName;\r\n            index++;\r\n        }\r\n        return profiles;\r\n    }"}, {"ID": 1661, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] getProfilesFor(final String propKeyNameWildcard) { HashSet<String> profiles = new HashSet<>(); profile: for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) { String profileName = entries.getKey(); Map<String, PropsEntry> value = entries.getValue(); for (String propKeyName : value.keySet()) { if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) { profiles.add(profileName); continue profile; } } } return profiles.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Returns all the profiles that define certain prop's key name.\nKey name is given as a wildcard, or it can be matched fully.", "predict": "/**\r\n     * Returns a list of profiles that have a property key name that matches the given wildcard pattern.\r\n     * \r\n     * @param propKeyNameWildcard the wildcard pattern to match property key names against\r\n     * @return a list of profile names that have a property key name that matches the given wildcard pattern\r\n     */\r\n    public String[] getProfilesFor(final String propKeyNameWildcard) {\r\n        HashSet<String> profiles = new HashSet<>();\r\n        for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) {\r\n            String profileName = entries.getKey();\r\n            Map<String, PropsEntry> value = entries.getValue();\r\n            for (String propKeyName : value.keySet()) {\r\n                if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) {\r\n                    profiles.add(profileName);\r\n                    continue profile;\r\n                }\r\n            }\r\n        }\r\n        return profiles.toArray(new String[0]);\r\n    }"}, {"ID": 1662, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addPropertyInjectionPoint(final PropertyInjectionPoint pip) { if (properties == null) { properties = new PropertyInjectionPoint[1]; properties[0] = pip; } else { properties = ArraysUtil.append(properties, pip); } }\n\n    ### Response:", "ground_truth": "Adds property injection point.", "predict": "/**\r\n     * Adds a property injection point to the list of property injection points.\r\n     * \r\n     * @param pip the property injection point to add\r\n     */\r\n    protected void addPropertyInjectionPoint(final PropertyInjectionPoint pip) {\r\n        if (properties == null) {\r\n            properties = new PropertyInjectionPoint[1];\r\n            properties[0] = pip;\r\n        } else {\r\n            properties = ArraysUtil.append(properties, pip);\r\n        }\r\n    }"}, {"ID": 1663, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addSetInjectionPoint(final SetInjectionPoint sip) { if (sets == null) { sets = new SetInjectionPoint[1]; sets[0] = sip; } else { sets = ArraysUtil.append(sets, sip); } }\n\n    ### Response:", "ground_truth": "Adds set injection point.", "predict": "/**\r\n     * Adds a new SetInjectionPoint to the list of sets.\r\n     * \r\n     * @param sip the SetInjectionPoint to add\r\n     */\r\n    protected void addSetInjectionPoint(final SetInjectionPoint sip) {\r\n        if (sets == null) {\r\n            sets = new SetInjectionPoint[1];\r\n            sets[0] = sip;\r\n        } else {\r\n            sets = ArraysUtil.append(sets, sip);\r\n        }\r\n    }"}, {"ID": 1664, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addMethodInjectionPoint(final MethodInjectionPoint mip) { if (methods == null) { methods = new MethodInjectionPoint[1]; methods[0] = mip; } else { methods = ArraysUtil.append(methods, mip); } }\n\n    ### Response:", "ground_truth": "Adds method injection point.", "predict": "/**\r\n     * Adds a new method injection point to the list of method injection points.\r\n     * \r\n     * @param mip the method injection point to add\r\n     */\r\n    protected void addMethodInjectionPoint(final MethodInjectionPoint mip) {\r\n        if (methods == null) {\r\n            methods = new MethodInjectionPoint[1];\r\n            methods[0] = mip;\r\n        } else {\r\n            methods = ArraysUtil.append(methods, mip);\r\n        }\r\n    }"}, {"ID": 1665, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addInitMethodPoints(final InitMethodPoint[] methods) { if (initMethods == null) { initMethods = methods; } else { initMethods = ArraysUtil.join(initMethods, methods); } }\n\n    ### Response:", "ground_truth": "Adds init methods.", "predict": "/**\r\n     * Adds the given initialization methods to the existing ones.\r\n     * \r\n     * @param methods the initialization methods to add\r\n     */\r\n    protected void addInitMethodPoints(final InitMethodPoint[] methods) {\r\n        if (initMethods == null) {\r\n            initMethods = methods;\r\n        } else {\r\n            initMethods = ArraysUtil.join(initMethods, methods);\r\n        }\r\n    }"}, {"ID": 1666, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void addDestroyMethodPoints(final DestroyMethodPoint[] methods) { if (destroyMethods == null) { destroyMethods = methods; } else { destroyMethods = ArraysUtil.join(destroyMethods, methods); } }\n\n    ### Response:", "ground_truth": "Adds destroy methods.", "predict": "/**\r\n     * Adds the given destroy method points to the list of methods to be called during destruction of the object.\r\n     * \r\n     * @param methods the destroy method points to add\r\n     */\r\n    protected void addDestroyMethodPoints(final DestroyMethodPoint[] methods) {\r\n        if (destroyMethods == null) {\r\n            destroyMethods = methods;\r\n        } else {\r\n            destroyMethods = ArraysUtil.join(destroyMethods, methods);\r\n        }\r\n    }"}, {"ID": 1667, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class resolveTargetClass(final Class proxy) { final String name = proxy.getName(); if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) { return proxy.getSuperclass(); } if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) { return getTargetWrapperType(proxy); } return proxy; }\n\n    ### Response:", "ground_truth": "Returns target class if proxetta applied on given class.\nIf not, returns given class as result.", "predict": "/**\r\n     * Resolves the target class of a proxy class.\r\n     * \r\n     * @param proxy the proxy class\r\n     * @return the target class of the proxy\r\n     */\r\n    public static Class resolveTargetClass(final Class proxy) {\r\n        final String name = proxy.getName();\r\n        if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) {\r\n            return proxy.getSuperclass();\r\n        }\r\n        if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) {\r\n            return getTargetWrapperType(proxy);\r\n        }\r\n        return proxy;\r\n    }"}, {"ID": 1668, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void injectTargetIntoWrapper(final Object target, final Object wrapper) { injectTargetIntoWrapper(target, wrapper, ProxettaNames.wrapperTargetFieldName); }\n\n    ### Response:", "ground_truth": "Injects target instance into proxy using default target field name.\n@see #injectTargetIntoWrapper(Object, Object, String)", "predict": "/**\n     * Injects the target object into the wrapper object using the default field name.\n     * \n     * @param target the target object to be injected\n     * @param wrapper the wrapper object into which the target is to be injected\n     */\n    public static void injectTargetIntoWrapper(final Object target, final Object wrapper) {\n        injectTargetIntoWrapper(target, wrapper, ProxettaNames.wrapperTargetFieldName);\n    }"}, {"ID": 1669, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Class getTargetWrapperType(final Class wrapperClass) { try { final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName); return field.getType(); } catch (NoSuchFieldException nsfex) { throw new ProxettaException(nsfex); } }\n\n    ### Response:", "ground_truth": "Returns wrapper target type.", "predict": "/**\r\n     * Returns the type of the target class that is wrapped by the given wrapper class.\r\n     * \r\n     * @param wrapperClass the wrapper class\r\n     * @return the type of the target class\r\n     * @throws ProxettaException if the wrapper class does not have a field named \"wrapperTarget\"\r\n     */\r\n    public static Class getTargetWrapperType(final Class wrapperClass) {\r\n        try {\r\n            final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName);\r\n            return field.getType();\r\n        } catch (NoSuchFieldException nsfex) {\r\n            throw new ProxettaException(nsfex);\r\n        }\r\n    }"}, {"ID": 1670, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected FieldDescriptor findField(final String fieldName) { FieldDescriptor fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } // field descriptor not found in this class // try to locate it in the superclasses Class[] superclasses = classDescriptor.getAllSuperclasses(); for (Class superclass : superclasses) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(superclass); fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } } // nothing found return null; }\n\n    ### Response:", "ground_truth": "Locates property field. Field is being searched also in all\nsuperclasses of current class.", "predict": "/**\r\n     * Finds the field descriptor with the given name in this class or any of its superclasses.\r\n     * \r\n     * @param fieldName the name of the field to find\r\n     * @return the field descriptor, or null if not found\r\n     */\r\n    protected FieldDescriptor findField(final String fieldName) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1671, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class getType() { if (type == null) { if (fieldDescriptor != null) { type = fieldDescriptor.getRawType(); } else if (readMethodDescriptor != null) { type = getGetter(true).getGetterRawType(); //type = readMethodDescriptor.getGetterRawType(); } else if (writeMethodDescriptor != null) { type = getSetter(true).getSetterRawType(); //type = writeMethodDescriptor.getSetterRawType(); } } return type; }\n\n    ### Response:", "ground_truth": "Returns property type. Raw types are detected.", "predict": "/**\r\n     * Returns the type of the field represented by this descriptor.\r\n     * \r\n     * @return the type of the field represented by this descriptor\r\n     */\r\n    public Class getType() {\r\n        if (type == null) {\r\n            if (fieldDescriptor != null) {\r\n                type = fieldDescriptor.getRawType();\r\n            } else if (readMethodDescriptor != null) {\r\n                type = getGetter(true).getGetterRawType();\r\n            } else if (writeMethodDescriptor != null) {\r\n                type = getSetter(true).getSetterRawType();\r\n            }\r\n        }\r\n        return type;\r\n    }"}, {"ID": 1672, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class resolveKeyType(final boolean declared) { Class keyType = null; Getter getter = getGetter(declared); if (getter != null) { keyType = getter.getGetterRawKeyComponentType(); } if (keyType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { keyType = fieldDescriptor.getRawKeyComponentType(); } } return keyType; }\n\n    ### Response:", "ground_truth": "Resolves key type for given property descriptor.", "predict": "/**\r\n     * Resolves the key type for the given entity class.\r\n     * \r\n     * @param declared\r\n     *            whether to consider only declared fields or not.\r\n     * @return the resolved key type or null if no key type could be resolved.\r\n     */\r\n    public Class resolveKeyType(final boolean declared) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n    }"}, {"ID": 1673, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class resolveComponentType(final boolean declared) { Class componentType = null; Getter getter = getGetter(declared); if (getter != null) { componentType = getter.getGetterRawComponentType(); } if (componentType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { componentType = fieldDescriptor.getRawComponentType(); } } return componentType; }\n\n    ### Response:", "ground_truth": "Resolves component type for given property descriptor.", "predict": "/**\r\n     * Resolves the component type of the property represented by this descriptor.\r\n     * \r\n     * @param declared\r\n     *            whether to resolve the declared type or the actual type\r\n     * @return the component type of the property, or null if the property is not an array or the component type cannot be determined\r\n     */\r\n    public Class resolveComponentType(final boolean declared) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n    }"}, {"ID": 1674, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonResult of(final Object object) { final String json = JsonSerializer.create().deep(true).serialize(object); return new JsonResult(json); }\n\n    ### Response:", "ground_truth": "Creates JSON result from given object. The object will be serialized to JSON.", "predict": "/**\r\n     * Creates a new JsonResult object with the serialized JSON representation of the given object.\r\n     *\r\n     * @param object the object to serialize\r\n     * @return a new JsonResult object with the serialized JSON representation of the given object\r\n     */\r\n    public static JsonResult of(final Object object) {\r\n        final String json = JsonSerializer.create().deep(true).serialize(object);\r\n        return new JsonResult(json);\r\n    }"}, {"ID": 1675, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static JsonResult of(final Exception exception) { final HashMap<String, Object> errorMap = new HashMap<>(); errorMap.put(\"message\", ExceptionUtil.message(exception)); errorMap.put(\"error\", exception.getClass().getName()); errorMap.put(\"cause\", exception.getCause() != null ? exception.getCause().getClass().getName() : null); final ArrayList<String> details = new ArrayList<>(); final StackTraceElement[] ste = ExceptionUtil.getStackTrace(exception, null, null); for (StackTraceElement stackTraceElement : ste) { details.add(stackTraceElement.toString()); } errorMap.put(\"details\", details); final String json = JsonSerializer.create().deep(true).serialize(errorMap); return new JsonResult(json).status(HttpStatus.error500().internalError()); }\n\n    ### Response:", "ground_truth": "Creates a JSON response from an exception. Response body will have information about the\nexception and response status will be set to 500.", "predict": "/**\r\n     * Creates a JsonResult object with the given exception.\r\n     *\r\n     * @param exception the exception to be converted to a JsonResult object\r\n     * @return a JsonResult object with the given exception\r\n     */\r\n    public static JsonResult of(final Exception exception) {\r\n        // code goes here\r\n    }"}, {"ID": 1676, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveHttpMethodFromMethodName(final String methodName) { int i = 0; while (i < methodName.length()) { if (CharUtil.isUppercaseAlpha(methodName.charAt(i))) { break; } i++; } final String name = methodName.substring(0, i).toUpperCase(); for (final HttpMethod httpMethod : HttpMethod.values()) { if (httpMethod.equalsName(name)) { return httpMethod.name(); } } return null; }\n\n    ### Response:", "ground_truth": "Resolves HTTP method name from method name.\nIf method name or first camel-case word of a method equals to\na HTTP method, it will be used as that HTTP methods.", "predict": "/**\r\n     * Resolves the HTTP method from the given method name.\r\n     * \r\n     * @param methodName the method name to resolve the HTTP method from\r\n     * @return the resolved HTTP method or null if no match was found\r\n     */\r\n    protected String resolveHttpMethodFromMethodName(final String methodName) {\r\n        int i = 0;\r\n        while (i < methodName.length()) {\r\n            if (CharUtil.isUppercaseAlpha(methodName.charAt(i))) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        final String name = methodName.substring(0, i).toUpperCase();\r\n        for (final HttpMethod httpMethod : HttpMethod.values()) {\r\n            if (httpMethod.equalsName(name)) {\r\n                return httpMethod.name();\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1677, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) { int pLen = pattern.length(); if (pLen == 1) { if (pattern.charAt(0) == '*') { // speed-up return true; } } int sLen = string.length(); boolean nextIsNotWildcard = false; while (true) { // check if end of string and/or pattern occurred if ((sNdx >= sLen)) { // end of string still may have pending '*' in pattern while ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) { pNdx++; } return pNdx >= pLen; } if (pNdx >= pLen) { // end of pattern, but not end of the string return false; } char p = pattern.charAt(pNdx); // pattern char // perform logic if (!nextIsNotWildcard) { if (p == '\\\\') { pNdx++; nextIsNotWildcard = true; continue; } if (p == '?') { sNdx++; pNdx++; continue; } if (p == '*') { char pNext = 0; // next pattern char if (pNdx + 1 < pLen) { pNext = pattern.charAt(pNdx + 1); } if (pNext == '*') { // double '*' have the same effect as one '*' pNdx++; continue; } int i; pNdx++; // find recursively if there is any substring from the end of the // line that matches the rest of the pattern !!! for (i = string.length(); i >= sNdx; i--) { if (match(string, pattern, i, pNdx)) { return true; } } return false; } } else { nextIsNotWildcard = false; } // check if pattern char and string char are equals if (p != string.charAt(sNdx)) { return false; } // everything matches for now, continue sNdx++; pNdx++; } }\n\n    ### Response:", "ground_truth": "Internal matching recursive function.", "predict": "/**\r\n     * This method is used to check if the given string matches the given pattern.\r\n     * \r\n     * @param string\r\n     *            the string to be matched\r\n     * @param pattern\r\n     *            the pattern to be matched\r\n     * @param sNdx\r\n     *            the starting index of the string to be matched\r\n     * @param pNdx\r\n     *            the starting index of the pattern to be matched\r\n     * @return true if the string matches the pattern, false otherwise\r\n     */\r\n    private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) {\r\n        int pLen = pattern.length();\r\n        if (pLen == 1) {\r\n            if (pattern.charAt(0) == '*') {\r\n                // speed-up\r\n                return true;\r\n            }\r\n        }\r\n        int sLen = string.length();\r\n        boolean nextIsNotWildcard = false;\r\n        while (true) {\r\n            // check if end of string and/or pattern occurred\r\n            if ((sNdx >= sLen)) {"}, {"ID": 1678, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Loading resolveLoading(final boolean parentFirstStrategy, final String className) { boolean withParent = true; boolean withLoader = true; if (parentFirstStrategy) { if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } else if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } } else { if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } else if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } } return new Loading(withParent, withLoader); }\n\n    ### Response:", "ground_truth": "Resolves loading rules.", "predict": "/**\r\n     * Resolves the loading strategy based on the parentFirstStrategy and className.\r\n     * \r\n     * @param parentFirstStrategy\r\n     *            true if parent loading strategy should be used, false otherwise.\r\n     * @param className\r\n     *            the name of the class to be loaded.\r\n     * @return the resolved loading strategy.\r\n     */\r\n    protected Loading resolveLoading(final boolean parentFirstStrategy, final String className) {\r\n        boolean withParent = true;\r\n        boolean withLoader = true;\r\n        if (parentFirstStrategy) {\r\n            if (isMatchingRules(className, loaderOnlyRules)) {\r\n                withParent = false;\r\n            } else if (isMatchingRules(className, parentOnlyRules)) {\r\n                withLoader = false;\r\n            }\r\n        } else {\r\n            if (isMatchingRules(className, parentOnlyRules)) {\r\n                withLoader = false;\r\n            } else if (isMatchingRules(className, loaderOnlyRules)) {\r\n                withParent = false;\r\n            }\r\n        }\r\n        return new Loading(withParent, withLoader);\r\n    }"}, {"ID": 1679, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Loading resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) { if (matchResourcesAsPackages) { resourceName = StringUtil.replaceChar(resourceName, '/', '.'); } return resolveLoading(parentFirstStrategy, resourceName); }\n\n    ### Response:", "ground_truth": "Resolves resources.", "predict": "/**\r\n     * Resolves the loading strategy for a resource.\r\n     * \r\n     * @param parentFirstStrategy\r\n     *            whether to use parent-first loading strategy\r\n     * @param resourceName\r\n     *            the name of the resource to load\r\n     * @return the loading strategy for the resource\r\n     */\r\n    protected Loading resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) {\r\n        if (matchResourcesAsPackages) {\r\n            resourceName = StringUtil.replaceChar(resourceName, '/', '.');\r\n        }\r\n        return resolveLoading(parentFirstStrategy, resourceName);\r\n    }"}, {"ID": 1680, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException { // check first if the class has already been loaded Class<?> c = findLoadedClass(className); if (c != null) { if (resolve) { resolveClass(c); } return c; } // class not loaded yet Loading loading = resolveLoading(parentFirst, className); if (parentFirst) { // PARENT FIRST if (loading.withParent) { try { c = parentClassLoader.loadClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withLoader) { c = this.findClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } else { // THIS FIRST if (loading.withLoader) { try { c = this.findClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withParent) { c = parentClassLoader.loadClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } if (resolve) { resolveClass(c); } return c; }\n\n    ### Response:", "ground_truth": "Loads class using parent-first or parent-last strategy.", "predict": "/**\r\n * Loads the class with the specified name.\r\n *\r\n * @param className the name of the class to load\r\n * @param resolve whether to resolve the class\r\n * @return the loaded class\r\n * @throws ClassNotFoundException if the class cannot be loaded\r\n */\r\nprotected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException;"}, {"ID": 1681, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public URL getResource(final String resourceName) { URL url = null; Loading loading = resolveResourceLoading(parentFirst, resourceName); if (parentFirst) { // PARENT FIRST if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } if (url == null) { if (loading.withLoader) { url = this.findResource(resourceName); } } } else { // THIS FIRST if (loading.withLoader) { url = this.findResource(resourceName); } if (url == null) { if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } } } return url; }\n\n    ### Response:", "ground_truth": "Returns a resource using parent-first or parent-last strategy.", "predict": "/**\r\n     * Returns a URL for the resource with the specified name.\r\n     *\r\n     * @param resourceName the name of the resource to find.\r\n     * @return a URL for the resource, or null if the resource cannot be found.\r\n     */\r\n    @Override\r\n    public URL getResource(final String resourceName) {\r\n        URL url = null;\r\n        Loading loading = resolveResourceLoading(parentFirst, resourceName);\r\n        if (parentFirst) { // PARENT FIRST\r\n            if (loading.withParent) {\r\n                url = parentClassLoader.getResource(resourceName);\r\n            }\r\n            if (url == null && loading.withLoader) {\r\n                url = this.findResource(resourceName);\r\n            }\r\n        } else { // THIS FIRST\r\n            if (loading.withLoader) {\r\n                url = this.findResource(resourceName);\r\n            }\r\n            if (url == null && loading.withParent) {\r\n                url = parentClassLoader.getResource(resourceName);\r\n            }\r\n        }\r\n        return url;\r\n    }"}, {"ID": 1682, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void waitFor() { try { synchronized (lock) { if (!end) { lock.wait(); } } } catch (InterruptedException ignore) { Thread.currentThread().interrupt(); } }\n\n    ### Response:", "ground_truth": "Waits for gobbler to end.", "predict": "/**\r\n     * Waits for the thread to finish execution.\r\n     * \r\n     * @throws InterruptedException if the current thread is interrupted while waiting\r\n     */\r\n    public void waitFor() throws InterruptedException {\r\n        synchronized (lock) {\r\n            if (!end) {\r\n                lock.wait();\r\n            }\r\n        }\r\n    }"}, {"ID": 1683, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) { for (final Annotation annotation : annotations) { if (annotation instanceof In) { return annotation.annotationType(); } else if (annotation instanceof Out) { return annotation.annotationType(); } } return null; }\n\n    ### Response:", "ground_truth": "Scans annotation and returns type of Madvoc annotations.", "predict": "/**\r\n     * This method detects the annotation type of the given annotations.\r\n     * \r\n     * @param annotations\r\n     *            An array of annotations.\r\n     * @return The annotation type of the first annotation that is an instance of In or Out, or null if no such annotation is found.\r\n     */\r\n    public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) {\r\n        for (final Annotation annotation : annotations) {\r\n            if (annotation instanceof In) {\r\n                return annotation.annotationType();\r\n            } else if (annotation instanceof Out) {\r\n                return annotation.annotationType();\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1684, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected InjectionPoint buildInjectionPoint( final String annotationValue, final String propertyName, final Class propertyType, final Class<? extends MadvocScope> scope) { final String value = annotationValue.trim(); final String name, targetName; if (StringUtil.isNotBlank(value)) { name = value; targetName = propertyName; } else { name = propertyName; targetName = null; } return new InjectionPoint(propertyType, name, targetName, scopeResolver.defaultOrScopeType(scope)); }\n\n    ### Response:", "ground_truth": "Builds injection point.", "predict": "/**\r\n     * Builds an injection point for a property with the given annotation value, property name, property type, and scope.\r\n     * \r\n     * @param annotationValue the annotation value\r\n     * @param propertyName the property name\r\n     * @param propertyType the property type\r\n     * @param scope the scope\r\n     * @return the injection point\r\n     */\r\n    protected InjectionPoint buildInjectionPoint(final String annotationValue, final String propertyName, final Class propertyType, final Class<? extends MadvocScope> scope) {\r\n        final String value = annotationValue.trim();\r\n        final String name, targetName;\r\n        if (StringUtil.isNotBlank(value)) {\r\n            name = value;\r\n            targetName = propertyName;\r\n        } else {\r\n            name = propertyName;\r\n            targetName = null;\r\n        }\r\n        return new InjectionPoint(propertyType, name, targetName, scopeResolver.defaultOrScopeType(scope));\r\n    }"}, {"ID": 1685, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visit() { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); if (classMetadataName != null) { // process first 'meta' fields 'class' onProperty(classMetadataName, null, false); } PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { String propertyName = propertyDescriptor.getName(); boolean isTransient = false; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); if (fieldDescriptor != null) { isTransient = Modifier.isTransient(fieldDescriptor.getField().getModifiers()); } onProperty(propertyName, propertyDescriptor, isTransient); } } }\n\n    ### Response:", "ground_truth": "Visits a type.", "predict": "/**\r\n     * Visits the class and its properties.\r\n     */\r\n    public void visit() {\r\n        // TODO: implement\r\n    }"}, {"ID": 1686, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { final URLClassLoader urlClassLoader = (URLClassLoader) classLoader; return urlClassLoader.getURLs(); } final URL url = classModuleUrl(classLoader, clazz); if (url != null) { urls.add(url); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); }\n\n    ### Response:", "ground_truth": "Returns urls for the classloader\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": "/**\r\n     * Returns an array of URLs representing all of the locations on the classpath that can be loaded by the given classloader and class.\r\n     *\r\n     * @param classLoader the classloader to use to load the class, or null to use the system classloader\r\n     * @param clazz the class to use to determine the classpath locations, or null to use the ClassPathURLs class\r\n     * @return an array of URLs representing all of the locations on the classpath that can be loaded by the given classloader and class\r\n     */\r\n    public static URL[] of(ClassLoader classLoader, Class clazz) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1687, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setBean(final Object bean) { this.bean = bean; this.cd = (bean == null ? null : introspector.lookup(bean.getClass())); this.first = false; this.updateProperty = true; }\n\n    ### Response:", "ground_truth": "Sets new bean instance.", "predict": "/**\r\n     * Sets the bean for this instance.\r\n     * \r\n     * @param bean the bean to set\r\n     */\r\n    private void setBean(final Object bean) {\r\n        this.bean = bean;\r\n        this.cd = (bean == null ? null : introspector.lookup(bean.getClass()));\r\n        this.first = false;\r\n        this.updateProperty = true;\r\n    }"}, {"ID": 1688, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void updateBean(final Object bean) { this.setBean(bean); if (this.cd != null && this.cd.isSupplier()) { final Object newBean = ((Supplier)this.bean).get(); setBean(newBean); } }\n\n    ### Response:", "ground_truth": "Updates the bean. Detects special case of suppliers.", "predict": "/**\r\n     * Updates the bean with the given object. If the current bean is a supplier, it will be replaced with the new bean obtained from the supplier.\r\n     * \r\n     * @param bean the new bean to be set\r\n     */\r\n    public void updateBean(final Object bean) {\r\n        this.setBean(bean);\r\n        if (this.cd != null && this.cd.isSupplier()) {\r\n            final Object newBean = ((Supplier)this.bean).get();\r\n            setBean(newBean);\r\n        }\r\n    }"}, {"ID": 1689, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void loadPropertyDescriptor() { if (updateProperty) { if (cd == null) { propertyDescriptor = null; } else { propertyDescriptor = cd.getPropertyDescriptor(name, true); } updateProperty = false; } }\n\n    ### Response:", "ground_truth": "Loads property descriptor, if property was updated.", "predict": "/**\r\n     * This method is used to load the property descriptor for the given property name.\r\n     * \r\n     * @param name\r\n     *            The name of the property for which the descriptor is to be loaded.\r\n     */\r\n    private void loadPropertyDescriptor(String name) {\r\n        if (updateProperty) {\r\n            if (cd == null) {\r\n                propertyDescriptor = null;\r\n            } else {\r\n                propertyDescriptor = cd.getPropertyDescriptor(name, true);\r\n            }\r\n            updateProperty = false;\r\n        }\r\n    }"}, {"ID": 1690, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; }\n\n    ### Response:", "ground_truth": "Returns getter.", "predict": "/**\r\n     * Returns the getter for the property.\r\n     * \r\n     * @param declared\r\n     *            whether to return the declared getter or the public getter\r\n     * @return the getter for the property, or null if no getter exists\r\n     */\r\n    public Getter getGetter(final boolean declared) {\r\n        loadPropertyDescriptor();\r\n        return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null;\r\n    }"}, {"ID": 1691, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Setter getSetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getSetter(declared) : null; }\n\n    ### Response:", "ground_truth": "Returns setter.", "predict": "/**\r\n     * Returns the setter method for the property represented by this descriptor.\r\n     * \r\n     * @param declared\r\n     *            if true, only declared methods will be considered, otherwise, all methods will be considered.\r\n     * @return the setter method for the property represented by this descriptor, or null if no setter method is found.\r\n     */\r\n    public Setter getSetter(final boolean declared) {\r\n        loadPropertyDescriptor();\r\n        return propertyDescriptor != null ? propertyDescriptor.getSetter(declared) : null;\r\n    }"}, {"ID": 1692, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DbOom connect() { connectionProvider.init(); final DbDetector dbDetector = new DbDetector(); dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig); return this; }\n\n    ### Response:", "ground_truth": "Initializes the DbOom by connecting to the database. Database will be detected\nand DbOom will be configured to match it.", "predict": "/**\r\n     * Connects to the database and returns a DbOom object.\r\n     * \r\n     * @return a DbOom object\r\n     */\r\n    public DbOom connect() {\r\n        connectionProvider.init();\r\n        final DbDetector dbDetector = new DbDetector();\r\n        dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig);\r\n        return this;\r\n    }"}, {"ID": 1693, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(final Iterator<T> iterator) { if (allIterators.contains(iterator)) { throw new IllegalArgumentException(\"Duplicate iterator\"); } allIterators.add(iterator); }\n\n    ### Response:", "ground_truth": "Adds an iterator to this composite.", "predict": "/**\r\n     * Adds an iterator to the list of iterators.\r\n     * \r\n     * @param iterator the iterator to add\r\n     * @throws IllegalArgumentException if the iterator is already added\r\n     */\r\n    public void add(final Iterator<T> iterator) {\r\n        if (allIterators.contains(iterator)) {\r\n            throw new IllegalArgumentException(\"Duplicate iterator\");\r\n        }\r\n        allIterators.add(iterator);\r\n    }"}, {"ID": 1694, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void printLogo() { System.out.println(Chalk256.chalk().yellow().on(Jodd.JODD)); }\n\n    ### Response:", "ground_truth": "Prints a logo.", "predict": "/**\r\n     * Prints the logo of Jodd library.\r\n     */\r\n    private void printLogo() {\r\n        System.out.println(Chalk256.chalk().yellow().on(Jodd.JODD));\r\n    }"}, {"ID": 1695, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stop() { joyProps.stop(); try { joyDb.stop(); joyPetite.stop(); } catch (Exception ignore) { } if (log != null) { log.info(\"Joy is down. Bye, bye!\"); } }\n\n    ### Response:", "ground_truth": "Stops the Joy.", "predict": "/**\r\n     * This method is used to stop the Joy application. It calls the stop method of the joyProps, joyDb, and joyPetite objects.\r\n     * If there is an exception while stopping the joyDb or joyPetite objects, it is caught and ignored.\r\n     * If a log object is available, it logs a message indicating that Joy is down.\r\n     */"}, {"ID": 1696, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Socket createSocket(final String host, final int port, final int connectionTimeout) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, false, false, connectionTimeout); if (connectionTimeout < 0) { return socketFactory.createSocket(host, port); } else { // creates unconnected socket Socket socket = socketFactory.createSocket(); socket.connect(new InetSocketAddress(host, port), connectionTimeout); return socket; } }\n\n    ### Response:", "ground_truth": "Creates a socket using socket factory.", "predict": "/**\r\n     * Creates a socket to the specified host and port, with the specified connection timeout.\r\n     * \r\n     * @param host\r\n     *            the host name or IP address to connect to\r\n     * @param port\r\n     *            the port number to connect to\r\n     * @param connectionTimeout\r\n     *            the connection timeout in milliseconds, or 0 for infinite timeout\r\n     * @return a socket connected to the specified host and port\r\n     * @throws IOException\r\n     *             if an I/O error occurs while creating the socket\r\n     */\r\n    protected Socket createSocket(final String host, final int port, final int connectionTimeout) throws IOException;"}, {"ID": 1697, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SSLSocket createSSLSocket( final String host, final int port, final int connectionTimeout, final boolean trustAll, final boolean verifyHttpsHost) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll, connectionTimeout); final Socket socket; if (connectionTimeout < 0) { socket = socketFactory.createSocket(host, port); } else { // creates unconnected socket // unfortunately, this does not work always // sslSocket = (SSLSocket) socketFactory.createSocket(); // sslSocket.connect(new InetSocketAddress(host, port), connectionTimeout); // // Note: SSLSocketFactory has several create() methods. // Those that take arguments all connect immediately // and have no options for specifying a connection timeout. // // So, we have to create a socket and connect it (with a // connection timeout), then have the SSLSocketFactory wrap // the already-connected socket. // socket = Sockets.connect(host, port, connectionTimeout); //sock.setSoTimeout(readTimeout); //socket.connect(new InetSocketAddress(host, port), connectionTimeout); // continue to wrap this plain socket with ssl socket... } // wrap plain socket in an SSL socket SSLSocket sslSocket; if (socket instanceof SSLSocket) { sslSocket = (SSLSocket) socket; } else { if (socketFactory instanceof SSLSocketFactory) { sslSocket = (SSLSocket) ((SSLSocketFactory)socketFactory).createSocket(socket, host, port, true); } else { sslSocket = (SSLSocket) (getDefaultSSLSocketFactory(trustAll)).createSocket(socket, host, port, true); } } // sslSocket is now ready if (secureEnabledProtocols != null) { final String[] values = StringUtil.splitc(secureEnabledProtocols, ','); StringUtil.trimAll(values); sslSocket.setEnabledProtocols(values); } // set SSL parameters to allow host name verifier if (verifyHttpsHost) { final SSLParameters sslParams = new SSLParameters(); sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\"); sslSocket.setSSLParameters(sslParams); } return sslSocket; }\n\n    ### Response:", "ground_truth": "Creates a SSL socket. Enables default secure enabled protocols if specified.", "predict": "/**\r\n     * Creates an SSLSocket for the given host and port.\r\n     * \r\n     * @param host\r\n     *            the host name or IP address to connect to\r\n     * @param port\r\n     *            the port to connect to\r\n     * @param connectionTimeout\r\n     *            the connection timeout in milliseconds, or -1 for infinite\r\n     * @param trustAll\r\n     *            whether to trust all SSL certificates\r\n     * @param verifyHttpsHost\r\n     *            whether to verify the host name in the HTTPS certificate\r\n     * @return the SSLSocket\r\n     * @throws IOException\r\n     *             if an I/O error occurs while creating the SSLSocket\r\n     */\r\n    protected SSLSocket createSSLSocket(final String host, final int port, final int connectionTimeout, final boolean trustAll, final boolean verifyHttpsHost) throws IOException {\r\n        final SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll, connectionTimeout);\r\n        final Socket socket;\r\n        if (connectionTimeout < 0) {\r\n            socket = socketFactory.createSocket(host, port);\r\n       "}, {"ID": 1698, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SSLSocketFactory getDefaultSSLSocketFactory(final boolean trustAllCertificates) throws IOException { if (trustAllCertificates) { try { SSLContext sc = SSLContext.getInstance(sslProtocol); sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom()); return sc.getSocketFactory(); } catch (NoSuchAlgorithmException | KeyManagementException e) { throw new IOException(e); } } else { return (SSLSocketFactory) SSLSocketFactory.getDefault(); } }\n\n    ### Response:", "ground_truth": "Returns default SSL socket factory allowing setting trust managers.", "predict": "/**\r\n     * Returns the default SSLSocketFactory for the given trustAllCertificates flag.\r\n     * \r\n     * @param trustAllCertificates\r\n     *            true if all SSL certificates should be trusted, false otherwise\r\n     * @return the default SSLSocketFactory\r\n     * @throws IOException\r\n     *             if an error occurs while creating the SSLSocketFactory\r\n     */\r\n    protected SSLSocketFactory getDefaultSSLSocketFactory(final boolean trustAllCertificates) throws IOException {\r\n        if (trustAllCertificates) {\r\n            try {\r\n                SSLContext sc = SSLContext.getInstance(sslProtocol);\r\n                sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom());\r\n                return sc.getSocketFactory();\r\n            } catch (NoSuchAlgorithmException | KeyManagementException e) {\r\n                throw new IOException(e);\r\n            }\r\n        } else {\r\n            return (SSLSocketFactory) SSLSocketFactory.getDefault();\r\n        }\r\n    }"}, {"ID": 1699, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected SocketFactory getSocketFactory( final ProxyInfo proxy, final boolean ssl, final boolean trustAllCertificates, final int connectionTimeout) throws IOException { switch (proxy.getProxyType()) { case NONE: if (ssl) { return getDefaultSSLSocketFactory(trustAllCertificates); } else { return SocketFactory.getDefault(); } case HTTP: return new HTTPProxySocketFactory(proxy, connectionTimeout); case SOCKS4: return new Socks4ProxySocketFactory(proxy, connectionTimeout); case SOCKS5: return new Socks5ProxySocketFactory(proxy, connectionTimeout); default: return null; } }\n\n    ### Response:", "ground_truth": "Returns socket factory based on proxy type and SSL requirements.", "predict": "/**\r\n     * Returns a SocketFactory based on the given proxy information, SSL flag, and trustAllCertificates flag.\r\n     * \r\n     * @param proxy the ProxyInfo object containing the proxy information\r\n     * @param ssl whether to use SSL or not\r\n     * @param trustAllCertificates whether to trust all certificates or not\r\n     * @param connectionTimeout the connection timeout in milliseconds\r\n     * @return a SocketFactory based on the given proxy information, SSL flag, and trustAllCertificates flag\r\n     * @throws IOException if an error occurs while creating the SocketFactory\r\n     */\r\n    protected SocketFactory getSocketFactory(final ProxyInfo proxy, final boolean ssl, final boolean trustAllCertificates, final int connectionTimeout) throws IOException {\r\n        switch (proxy.getProxyType()) {\r\n            case NONE:\r\n                if (ssl) {\r\n                    return getDefaultSSLSocketFactory(trustAllCertificates);\r\n                } else {\r\n                    return SocketFactory.getDefault();\r\n                }\r\n            case HTTP:\r\n                return new HTTPProxySocketFactory(proxy, connectionTimeout);\r\n            case SOCKS4:\r\n                return new Socks"}, {"ID": 1700, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String random(int count, final char[] chars) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; while (count-- > 0) { result[count] = chars[rnd.nextInt(chars.length)]; } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the set of characters specified.", "predict": "/**\r\n     * Generates a random string of the specified length using the specified character set.\r\n     *\r\n     * @param count the length of the random string to generate\r\n     * @param chars the character set to use for generating the random string\r\n     * @return the generated random string\r\n     */\r\n    public String random(int count, final char[] chars) {\r\n        if (count == 0) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        final char[] result = new char[count];\r\n        while (count-- > 0) {\r\n            result[count] = chars[rnd.nextInt(chars.length)];\r\n        }\r\n        return new String(result);\r\n    }"}, {"ID": 1701, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String random(int count, final char start, final char end) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; final int len = end - start + 1; while (count-- > 0) { result[count] = (char) (rnd.nextInt(len) + start); } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the provided range.", "predict": "/**\r\n     * Generates a random string of characters within the specified range.\r\n     *\r\n     * @param count the number of characters to generate\r\n     * @param start the first character in the range (inclusive)\r\n     * @param end the last character in the range (inclusive)\r\n     * @return the generated random string\r\n     */\r\n    public String random(int count, final char start, final char end) {\r\n        if (count == 0) {\r\n            return StringPool.EMPTY;\r\n        }\r\n        final char[] result = new char[count];\r\n        final int len = end - start + 1;\r\n        while (count-- > 0) {\r\n            result[count] = (char) (rnd.nextInt(len) + start);\r\n        }\r\n        return new String(result);\r\n    }"}, {"ID": 1702, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String randomRanges(int count, final char... ranges) { if (count == 0) { return StringPool.EMPTY; } int i = 0; int len = 0; final int[] lens = new int[ranges.length]; while (i < ranges.length) { int gap = ranges[i + 1] - ranges[i] + 1; len += gap; lens[i] = len; i += 2; } final char[] result = new char[count]; while (count-- > 0) { char c = 0; int r = rnd.nextInt(len); for (i = 0; i < ranges.length; i += 2) { if (r < lens[i]) { r += ranges[i]; if (i != 0) { r -= lens[i - 2]; } c = (char) r; break; } } result[count] = c; } return new String(result); }\n\n    ### Response:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the multiple sets defined by range pairs.\nAll ranges must be in acceding order.", "predict": "/**\r\n     * Generates a random string of characters from the given ranges.\r\n     * \r\n     * @param count the number of characters to generate\r\n     * @param ranges the character ranges to choose from\r\n     * @return the generated random string\r\n     */\r\n    public String randomRanges(int count, final char... ranges) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 1703, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") protected Collection<Object> newArrayInstance(final Class targetType) { if (targetType == null || targetType == List.class || targetType == Collection.class || targetType.isArray()) { return listSupplier.get(); } if (targetType == Set.class) { return new HashSet<>(); } try { return (Collection<Object>) targetType.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new JsonException(e); } }\n\n    ### Response:", "ground_truth": "Creates new type for JSON array objects.\nIt returns a collection.\nLater, the collection will be converted into the target type.", "predict": "/**\r\n     * Creates a new instance of the specified collection type.\r\n     *\r\n     * @param targetType the collection type to create an instance of\r\n     * @return a new instance of the specified collection type\r\n     */\r\n    protected Collection<Object> newArrayInstance(final Class targetType) {\r\n        if (targetType == null || targetType == List.class || targetType == Collection.class || targetType.isArray()) {\r\n            return listSupplier.get();\r\n        }\r\n        if (targetType == Set.class) {\r\n            return new HashSet<>();\r\n        }\r\n        try {\r\n            return (Collection<Object>) targetType.getDeclaredConstructor().newInstance();\r\n        } catch (Exception e) {\r\n            throw new JsonException(e);\r\n        }\r\n    }"}, {"ID": 1704, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) { Object convertedValue = value; if (value != null) { Class targetClass = pd.getType(); convertedValue = convertType(value, targetClass); } try { Setter setter = pd.getSetter(true); if (setter != null) { setter.invokeSetter(target, convertedValue); } } catch (Exception ex) { throw new JsonException(ex); } }\n\n    ### Response:", "ground_truth": "Injects value into the targets property.", "predict": "/**\r\n     * This method is used to inject a value into an object using a property descriptor.\r\n     * \r\n     * @param target - The object that needs to be modified.\r\n     * @param pd - The property descriptor that describes the property to be modified.\r\n     * @param value - The value that needs to be injected into the object.\r\n     */\r\n    protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) {\r\n        Object convertedValue = value;\r\n        if (value != null) {\r\n            Class targetClass = pd.getType();\r\n            convertedValue = convertType(value, targetClass);\r\n        }\r\n        try {\r\n            Setter setter = pd.getSetter(true);\r\n            if (setter != null) {\r\n                setter.invokeSetter(target, convertedValue);\r\n            }\r\n        } catch (Exception ex) {\r\n            throw new JsonException(ex);\r\n        }\r\n    }"}, {"ID": 1705, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object convertType(final Object value, final Class targetType) { final Class valueClass = value.getClass(); if (valueClass == targetType) { return value; } try { return TypeConverterManager.get().convertType(value, targetType); } catch (Exception ex) { if (!strictTypes) { return null; } throw new JsonException(\"Type conversion failed\", ex); } }\n\n    ### Response:", "ground_truth": "Converts type of the given value.", "predict": "/**\r\n     * Converts the given value to the target type using the registered TypeConverterManager.\r\n     * \r\n     * @param value the value to convert\r\n     * @param targetType the target type to convert to\r\n     * @return the converted value, or null if the conversion failed and strictTypes is false\r\n     * @throws JsonException if the conversion failed and strictTypes is true\r\n     */\r\n    protected Object convertType(final Object value, final Class targetType) {\r\n        final Class valueClass = value.getClass();\r\n        if (valueClass == targetType) {\r\n            return value;\r\n        }\r\n        try {\r\n            return TypeConverterManager.get().convertType(value, targetType);\r\n        } catch (Exception ex) {\r\n            if (!strictTypes) {\r\n                return null;\r\n            }\r\n            throw new JsonException(\"Type conversion failed\", ex);\r\n        }\r\n    }"}, {"ID": 1706, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void visitProvide(final String service, final String... providers) { if (mv != null) { mv.visitProvide(service, providers); } }\n\n    ### Response:", "ground_truth": "Visit an implementation of a service.\n\n@param service the internal name of the service.\n@param providers the internal names of the implementations of the service (there is at least\none provider).", "predict": "/**\r\n     * Visits a provide statement.\r\n     *\r\n     * @param service the service name\r\n     * @param providers the service providers\r\n     */\r\n    public void visitProvide(final String service, final String... providers) {\r\n        if (mv != null) {\r\n            mv.visitProvide(service, providers);\r\n        }\r\n    }"}, {"ID": 1707, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unchecked\") public static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); }\n\n    ### Response:", "ground_truth": "Creates default implementation of the type cache.", "predict": "/**\r\n     * Creates a new instance of the default implementation of the {@link TypeCache} interface.\r\n     * \r\n     * @param <A> the type of the elements stored in the cache\r\n     * @return a new instance of the default implementation of the {@link TypeCache} interface\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static <A> TypeCache<A> createDefault() {\r\n        return (TypeCache<A>)Defaults.implementation.get();\r\n    }"}, {"ID": 1708, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T put(final Class<?> type, final T value) { return map.put(type, value); }\n\n    ### Response:", "ground_truth": "Add values to the map.", "predict": "/**\r\n     * Adds a mapping from the specified type to the specified value to this map.\r\n     *\r\n     * @param type the type of the mapping\r\n     * @param value the value of the mapping\r\n     * @return the previous value associated with the specified type, or null if there was no mapping for the type\r\n     */\r\n    public T put(final Class<?> type, final T value) { return map.put(type, value); }"}, {"ID": 1709, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MethodDescriptor[] getAllMethodDescriptors() { if (allMethods == null) { final List<MethodDescriptor> allMethodsList = new ArrayList<>(); for (MethodDescriptor[] methodDescriptors : methodsMap.values()) { Collections.addAll(allMethodsList, methodDescriptors); } final MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]); Arrays.sort(allMethods, Comparator.comparing(md -> md.getMethod().getName())); this.allMethods = allMethods; } return allMethods; }\n\n    ### Response:", "ground_truth": "Returns all methods. Cached. Lazy.", "predict": "/**\r\n     * Returns an array of all the method descriptors for all the methods in the class.\r\n     *\r\n     * @return an array of all the method descriptors for all the methods in the class.\r\n     */\r\n    public MethodDescriptor[] getAllMethodDescriptors() {\r\n        if (allMethods == null) {\r\n            final List<MethodDescriptor> allMethodsList = new ArrayList<>();\r\n            for (MethodDescriptor[] methodDescriptors : methodsMap.values()) {\r\n                Collections.addAll(allMethodsList, methodDescriptors);\r\n            }\r\n            final MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]);\r\n            Arrays.sort(allMethods, Comparator.comparing(md -> md.getMethod().getName()));\r\n            this.allMethods = allMethods;\r\n        }\r\n        return allMethods;\r\n    }"}, {"ID": 1710, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveIpAddress(final String hostname) { try { InetAddress netAddress; if (hostname == null || hostname.equalsIgnoreCase(LOCAL_HOST)) { netAddress = InetAddress.getLocalHost(); } else { netAddress = Inet4Address.getByName(hostname); } return netAddress.getHostAddress(); } catch (UnknownHostException ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Resolves IP address from a hostname.", "predict": "/**\r\n     * This method resolves the IP address of a given hostname.\r\n     * \r\n     * @param hostname The hostname to resolve the IP address for.\r\n     * @return The IP address of the hostname, or null if the hostname cannot be resolved.\r\n     */\r\n    public static String resolveIpAddress(final String hostname) {\r\n        try {\r\n            InetAddress netAddress;\r\n            if (hostname == null || hostname.equalsIgnoreCase(LOCAL_HOST)) {\r\n                netAddress = InetAddress.getLocalHost();\r\n            } else {\r\n                netAddress = Inet4Address.getByName(hostname);\r\n            }\r\n            return netAddress.getHostAddress();\r\n        } catch (UnknownHostException ignore) {\r\n            return null;\r\n        }\r\n    }"}, {"ID": 1711, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int getIpAsInt(final String ipAddress) { int ipIntValue = 0; String[] tokens = StringUtil.splitc(ipAddress, '.'); for (String token : tokens) { if (ipIntValue > 0) { ipIntValue <<= 8; } ipIntValue += Integer.parseInt(token); } return ipIntValue; }\n\n    ### Response:", "ground_truth": "Returns IP address as integer.", "predict": "/**\r\n     * This method takes an IP address as a string and returns the integer value of the IP address.\r\n     * \r\n     * @param ipAddress The IP address as a string.\r\n     * @return The integer value of the IP address.\r\n     */\r\n    public static int getIpAsInt(final String ipAddress) {\r\n        int ipIntValue = 0;\r\n        String[] tokens = StringUtil.splitc(ipAddress, '.');\r\n        for (String token : tokens) {\r\n            if (ipIntValue > 0) {\r\n                ipIntValue <<= 8;\r\n            }\r\n            ipIntValue += Integer.parseInt(token);\r\n        }\r\n        return ipIntValue;\r\n    }"}, {"ID": 1712, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean validateAgaintIPAdressV4Format(final String input) { if (input == null) { return false; } int hitDots = 0; char[] data = input.toCharArray(); for (int i = 0; i < data.length; i++) { char c = data[i]; int b = 0; do { if (c < '0' || c > '9') { return false; } b = (b * 10 + c) - 48; if (++i >= data.length) { break; } c = data[i]; } while (c != '.'); if (b > 255) { return false; } hitDots++; } return hitDots == 4; }\n\n    ### Response:", "ground_truth": "Checks given string against IP address v4 format.\n\n@param input an ip address - may be null\n@return true if param has a valid ip v4 format false otherwise\n@see ip address v4", "predict": "/**\r\n     * This method validates whether the given input string is a valid IPv4 address or not.\r\n     * \r\n     * @param input the input string to be validated\r\n     * @return true if the input string is a valid IPv4 address, false otherwise\r\n     */\r\n    public static boolean validateAgaintIPAdressV4Format(final String input) {\r\n        if (input == null) {\r\n            return false;\r\n        }\r\n        int hitDots = 0;\r\n        char[] data = input.toCharArray();\r\n        for (int i = 0; i < data.length; i++) {\r\n            char c = data[i];\r\n            int b = 0;\r\n            do {\r\n                if (c < '0' || c > '9') {\r\n                    return false;\r\n                }\r\n                b = (b * 10 + c) - 48;\r\n                if (++i >= data.length) {\r\n                    break;\r\n                }\r\n                c = data[i];\r\n            } while (c != '.');\r\n            if (b > 25"}, {"ID": 1713, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String resolveHostName(final byte[] ip) { try { InetAddress address = InetAddress.getByAddress(ip); return address.getHostName(); } catch (UnknownHostException ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Resolves host name from IP address bytes.", "predict": "/**\r\n     * Resolves the hostname of the given IP address.\r\n     *\r\n     * @param ip the IP address to resolve\r\n     * @return the hostname of the IP address, or null if it cannot be resolved\r\n     */\r\n    public static String resolveHostName(final byte[] ip) {\r\n        try {\r\n            InetAddress address = InetAddress.getByAddress(ip);\r\n            return address.getHostName();\r\n        } catch (UnknownHostException ignore) {\r\n            return null;\r\n        }\r\n    }"}, {"ID": 1714, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static byte[] downloadBytes(final String url) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return StreamUtil.readBytes(inputStream); } }\n\n    ### Response:", "ground_truth": "Downloads resource as byte array.", "predict": "/**\r\n     * Downloads the bytes from the given URL.\r\n     *\r\n     * @param url the URL to download from\r\n     * @return the downloaded bytes\r\n     * @throws IOException if an error occurs during the download\r\n     */\r\n    public static byte[] downloadBytes(final String url) throws IOException {\r\n        try (InputStream inputStream = new URL(url).openStream()) {\r\n            return StreamUtil.readBytes(inputStream);\r\n        }\r\n    }"}, {"ID": 1715, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String downloadString(final String url, final String encoding) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return new String(StreamUtil.readChars(inputStream, encoding)); } }\n\n    ### Response:", "ground_truth": "Downloads resource as String.", "predict": "/**\r\n     * Downloads the content of the given URL as a string using the specified encoding.\r\n     *\r\n     * @param url the URL to download\r\n     * @param encoding the encoding to use for decoding the bytes\r\n     * @return the content of the URL as a string\r\n     * @throws IOException if an I/O error occurs while downloading the URL\r\n     */\r\n    public static String downloadString(final String url, final String encoding) throws IOException {\r\n        try (InputStream inputStream = new URL(url).openStream()) {\r\n            return new String(StreamUtil.readChars(inputStream, encoding));\r\n        }\r\n    }"}, {"ID": 1716, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void downloadFile(final String url, final File file) throws IOException { try ( InputStream inputStream = new URL(url).openStream(); ReadableByteChannel rbc = Channels.newChannel(inputStream); FileChannel fileChannel = FileChannel.open( file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE) ) { fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE); } }\n\n    ### Response:", "ground_truth": "Downloads resource to a file, potentially very efficiently.", "predict": "/**\r\n     * Downloads a file from a URL to a local file.\r\n     *\r\n     * @param url The URL of the file to download.\r\n     * @param file The local file to download the file to.\r\n     * @throws IOException If an I/O error occurs.\r\n     */\r\n    public static void downloadFile(final String url, final File file) throws IOException {\r\n        try (InputStream inputStream = new URL(url).openStream();\r\n             ReadableByteChannel rbc = Channels.newChannel(inputStream);\r\n             FileChannel fileChannel = FileChannel.open(file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE)) {\r\n            fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE);\r\n        }\r\n    }"}, {"ID": 1717, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void inject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(actionRequest, targets)); }\n\n    ### Response:", "ground_truth": "Performs injection.", "predict": "/**\r\n     * Injects dependencies into the specified action request.\r\n     * \r\n     * @param actionRequest the action request to inject dependencies into\r\n     */\r\n    protected void inject(final ActionRequest actionRequest) {\r\n        final Targets targets = actionRequest.getTargets();\r\n        final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext();\r\n        scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets));\r\n        scopeResolver.forEachScope(madvocScope -> madvocScope.inject(actionRequest, targets));\r\n    }"}, {"ID": 1718, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void outject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets)); }\n\n    ### Response:", "ground_truth": "Performs outjection.", "predict": "/**\r\n     * This method is responsible for outjecting the action request into the appropriate scopes.\r\n     * \r\n     * @param actionRequest The action request to be outjected.\r\n     */\r\n    protected void outject(final ActionRequest actionRequest) {\r\n        final Targets targets = actionRequest.getTargets();\r\n        scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets));\r\n    }"}, {"ID": 1719, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket connect(final String hostname, final int port) throws IOException { final Socket socket = new Socket(); socket.connect(new InetSocketAddress(hostname, port)); return socket; }\n\n    ### Response:", "ground_truth": "Creates a socket.", "predict": "/**\r\n     * Connects to a server at the specified hostname and port.\r\n     * \r\n     * @param hostname the hostname of the server to connect to\r\n     * @param port the port number of the server to connect to\r\n     * @return a Socket object representing the connection to the server\r\n     * @throws IOException if an I/O error occurs while connecting to the server\r\n     */\r\n    public static Socket connect(final String hostname, final int port) throws IOException {\r\n        final Socket socket = new Socket();\r\n        socket.connect(new InetSocketAddress(hostname, port));\r\n        return socket;\r\n    }"}, {"ID": 1720, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException { final Socket socket = new Socket(); if (connectionTimeout <= 0) { socket.connect(new InetSocketAddress(hostname, port)); } else { socket.connect(new InetSocketAddress(hostname, port), connectionTimeout); } return socket; }\n\n    ### Response:", "ground_truth": "Creates a socket with a timeout.", "predict": "/**\r\n     * Connects to the specified host and port, with a specified connection timeout.\r\n     *\r\n     * @param hostname the hostname to connect to\r\n     * @param port the port to connect to\r\n     * @param connectionTimeout the connection timeout in milliseconds\r\n     * @return the connected socket\r\n     * @throws IOException if an I/O error occurs while connecting to the host\r\n     */\r\n    public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException {\r\n        final Socket socket = new Socket();\r\n        if (connectionTimeout <= 0) {\r\n            socket.connect(new InetSocketAddress(hostname, port));\r\n        } else {\r\n            socket.connect(new InetSocketAddress(hostname, port), connectionTimeout);\r\n        }\r\n        return socket;\r\n    }"}, {"ID": 1721, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static int getPrimitiveClassNameIndex(final String className) { int dotIndex = className.indexOf('.'); if (dotIndex != -1) { return -1; } return Arrays.binarySearch(PRIMITIVE_TYPE_NAMES, className); }\n\n    ### Response:", "ground_truth": "Detects if provided class name is a primitive type.\nReturns >= 0 number if so.", "predict": "/**\r\n     * Returns the index of the given class name in the array of primitive type names.\r\n     *\r\n     * @param className the class name to search for\r\n     * @return the index of the class name in the array, or -1 if it is not a primitive type\r\n     */\r\n    private static int getPrimitiveClassNameIndex(final String className) {\r\n        int dotIndex = className.indexOf('.');\r\n        if (dotIndex != -1) {\r\n            return -1;\r\n        }\r\n        return Arrays.binarySearch(PRIMITIVE_TYPE_NAMES, className);\r\n    }"}, {"ID": 1722, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public Class loadClass(final String className, final ClassLoader classLoader) throws ClassNotFoundException { String arrayClassName = prepareArrayClassnameForLoading(className); if ((className.indexOf('.') == -1) && (arrayClassName == null)) { // maybe a primitive int primitiveNdx = getPrimitiveClassNameIndex(className); if (primitiveNdx >= 0) { return PRIMITIVE_TYPES[primitiveNdx]; } } // try #1 - using provided class loader if (classLoader != null) { Class klass = loadClass(className, arrayClassName, classLoader); if (klass != null) { return klass; } } // try #2 - using thread class loader ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader(); if ((currentThreadClassLoader != null) && (currentThreadClassLoader != classLoader)) { Class klass = loadClass(className, arrayClassName, currentThreadClassLoader); if (klass != null) { return klass; } } // try #3 - using caller classloader, similar as Class.forName() //Class callerClass = ReflectUtil.getCallerClass(2); Class callerClass = ClassUtil.getCallerClass(); ClassLoader callerClassLoader = callerClass.getClassLoader(); if ((callerClassLoader != classLoader) && (callerClassLoader != currentThreadClassLoader)) { Class klass = loadClass(className, arrayClassName, callerClassLoader); if (klass != null) { return klass; } } // try #4 - everything failed, try alternative array loader if (arrayClassName != null) { try { return loadArrayClassByComponentType(className, classLoader); } catch (ClassNotFoundException ignore) { } } throw new ClassNotFoundException(\"Class not found: \" + className); }\n\n    ### Response:", "ground_truth": "Loads class by name.", "predict": "/**\n     * Loads the class with the specified name using the following algorithm:\n     * <ol>\n     * <li>If the name is a primitive type (int, boolean, etc.), return the corresponding primitive type.</li>\n     * <li>Try to load the class using the provided class loader.</li>\n     * <li>Try to load the class using the thread context class loader.</li>\n     * <li>Try to load the class using the caller class loader.</li>\n     * <li>Try to load the class using the alternative array loader.</li>\n     * <li>If all attempts fail, throw a ClassNotFoundException.</li>\n     * </ol>\n     * \n     * @param className the name of the class to load\n     * @param classLoader the class loader to use to load the class\n     * @return the loaded class\n     * @throws ClassNotFoundException if the class cannot be loaded\n     */\n    @Override public Class loadClass(final String className, final ClassLoader classLoader) throws ClassNotFoundException {\n        // ..."}, {"ID": 1723, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Class loadArrayClassByComponentType(final String className, final ClassLoader classLoader) throws ClassNotFoundException { int ndx = className.indexOf('['); int multi = StringUtil.count(className, '['); String componentTypeName = className.substring(0, ndx); Class componentType = loadClass(componentTypeName, classLoader); if (multi == 1) { return Array.newInstance(componentType, 0).getClass(); } int[] multiSizes; if (multi == 2) { multiSizes = new int[] {0, 0}; } else if (multi == 3) { multiSizes = new int[] {0, 0, 0}; } else { multiSizes = (int[]) Array.newInstance(int.class, multi); } return Array.newInstance(componentType, multiSizes).getClass(); }\n\n    ### Response:", "ground_truth": "Loads array class using component type.", "predict": "/**\r\n     * Loads the class of an array type based on its component type name and class loader.\r\n     * \r\n     * @param className the name of the array class, including the component type name\r\n     * @param classLoader the class loader to use to load the component type class\r\n     * @return the class object of the array type\r\n     * @throws ClassNotFoundException if the component type class cannot be loaded\r\n     */\r\n    protected Class loadArrayClassByComponentType(final String className, final ClassLoader classLoader) throws ClassNotFoundException {\r\n        int ndx = className.indexOf('[');\r\n        int multi = StringUtil.count(className, '[');\r\n        String componentTypeName = className.substring(0, ndx);\r\n        Class componentType = loadClass(componentTypeName, classLoader);\r\n        if (multi == 1) {\r\n            return Array.newInstance(componentType, 0).getClass();\r\n        }\r\n        int[] multiSizes;\r\n        if (multi == 2) {\r\n            multiSizes = new int[] {0, 0};\r\n        } else if (multi"}, {"ID": 1724, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); }\n\n    ### Response:", "ground_truth": "Iterate all beans and invokes registered destroy methods.", "predict": "/**\r\n     * This method is used to shutdown the application. It calls the destroy method of all the beans that have been registered with the application.\r\n     */\r\n    @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); }"}, {"ID": 1725, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T extends Comparable> BinarySearch<T> forArray(final T[] array) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return array[index].compareTo(element); } @Override protected int getLastIndex() { return array.length - 1; } }; }\n\n    ### Response:", "ground_truth": "Creates binary search wrapper over an array.", "predict": "/**\r\n * Returns a BinarySearch object that can be used to search for elements in the given array.\r\n *\r\n * @param <T> the type of elements in the array\r\n * @param array the array to search in\r\n * @return a BinarySearch object that can be used to search for elements in the given array\r\n */\r\npublic static <T extends Comparable> BinarySearch<T> forArray(final T[] array) {\r\n    return new BinarySearch<T>() {\r\n        @Override\r\n        @SuppressWarnings({\"unchecked\"})\r\n        protected int compare(final int index, final T element) {\r\n            return array[index].compareTo(element);\r\n        }\r\n\r\n        @Override\r\n        protected int getLastIndex() {\r\n            return array.length - 1;\r\n        }\r\n    };\r\n}"}, {"ID": 1726, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return comparator.compare(array[index], element); } @Override protected int getLastIndex() { return array.length - 1; } }; }\n\n    ### Response:", "ground_truth": "Creates binary search wrapper over an array with given comparator.", "predict": "/**\r\n * Creates a new BinarySearch instance for the given array and comparator.\r\n *\r\n * @param <T> the type of elements in the array\r\n * @param array the array to search\r\n * @param comparator the comparator to use for comparisons\r\n * @return a new BinarySearch instance for the given array and comparator\r\n */\r\npublic static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) {\r\n    return new BinarySearch<T>() {\r\n        @Override\r\n        @SuppressWarnings({\"unchecked\"})\r\n        protected int compare(final int index, final T element) {\r\n            return comparator.compare(array[index], element);\r\n        }\r\n\r\n        @Override\r\n        protected int getLastIndex() {\r\n            return array.length - 1;\r\n        }\r\n    };\r\n}"}, {"ID": 1727, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T exclude(final String... excludes) { for (String ex : excludes) { rules.exclude(ex); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines excluded property names.", "predict": "/**\r\n     * Excludes the specified fields from the validation rules.\r\n     * \r\n     * @param excludes the fields to exclude from the validation rules\r\n     * @return the current instance of the validator\r\n     */\r\n    public T exclude(final String... excludes) {\r\n        for (String ex : excludes) {\r\n            rules.exclude(ex);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 1728, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T include(final String... includes) { for (String in : includes) { rules.include(in); } return _this(); }\n\n    ### Response:", "ground_truth": "Defines included property names.", "predict": "/**\r\n     * Adds the specified includes to the list of includes for this query.\r\n     *\r\n     * @param includes the includes to add\r\n     * @return this query object\r\n     */\r\n    public T include(final String... includes) {\r\n        for (String in : includes) {\r\n            rules.include(in);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 1729, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public T includeAs(final Class template) { blacklist = false; String[] properties = getAllBeanPropertyNames(template, false); include(properties); return _this(); }\n\n    ### Response:", "ground_truth": "Defines included property names as public properties\nof given template class. Sets to black list mode.", "predict": "/**\r\n     * Includes all properties of the given template class as part of the current query.\r\n     * \r\n     * @param template the class whose properties should be included in the query\r\n     * @return the current query object\r\n     */\r\n    public T includeAs(final Class template) {\r\n        blacklist = false;\r\n        String[] properties = getAllBeanPropertyNames(template, false);\r\n        include(properties);\r\n        return _this();\r\n    }"}, {"ID": 1730, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start(final int startIndex) { this.tagStartIndex = startIndex; this.name = null; this.idNdx = -1; this.attributesCount = 0; this.tagLength = 0; this.modified = false; this.type = TagType.START; this.rawTag = false; }\n\n    ### Response:", "ground_truth": "Starts the tag with the index of first '<'.\nResets all tag data.", "predict": "/**\r\n     * Initializes the tag with the given start index.\r\n     * \r\n     * @param startIndex the start index of the tag in the input string\r\n     */\r\n    public void start(final int startIndex) {\r\n        this.tagStartIndex = startIndex;\r\n        this.name = null;\r\n        this.idNdx = -1;\r\n        this.attributesCount = 0;\r\n        this.tagLength = 0;\r\n        this.modified = false;\r\n        this.type = TagType.START;\r\n        this.rawTag = false;\r\n    }"}, {"ID": 1731, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> void registerComponent(final String name, final Class<T> component, final Consumer<T> consumer) { log.debug(() -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component.getName()); madpc.removeBean(name); madpc.registerPetiteBean(component, name, null, null, false, consumer); }\n\n    ### Response:", "ground_truth": "Registers Madvoc component with given name.", "predict": "/**\r\n     * Registers a component with the Madvoc WebApp.\r\n     * \r\n     * @param <T> the type of the component\r\n     * @param name the name of the component\r\n     * @param component the component class\r\n     * @param consumer the consumer for the component\r\n     */\r\n    public <T> void registerComponent(final String name, final Class<T> component, final Consumer<T> consumer) {\r\n        log.debug(() -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component.getName());\r\n        madpc.removeBean(name);\r\n        madpc.registerPetiteBean(component, name, null, null, false, consumer);\r\n    }"}, {"ID": 1732, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void resolveColumnDbSqlType(final Connection connection, final DbEntityColumnDescriptor dec) { if (dec.dbSqlType != SqlType.DB_SQLTYPE_UNKNOWN) { return; } ResultSet rs = null; DbEntityDescriptor ded = dec.getDbEntityDescriptor(); try { DatabaseMetaData dmd = connection.getMetaData(); rs = dmd.getColumns(null, ded.getSchemaName(), ded.getTableName(), dec.getColumnName()); if (rs.next()) { dec.dbSqlType = rs.getInt(\"DATA_TYPE\"); } else { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not available: \" + ded.toString() + '.' + dec.getColumnName()); } } } catch (SQLException sex) { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not resolved: \" + ded.toString() + '.' + dec.getColumnName(), sex); } } finally { DbUtil.close(rs); } }\n\n    ### Response:", "ground_truth": "Resolves column db sql type and populates it in column descriptor if missing.", "predict": "/**\r\n     * Resolves the database SQL type for the given column descriptor.\r\n     * \r\n     * @param connection the database connection\r\n     * @param dec the column descriptor\r\n     */\r\n    protected void resolveColumnDbSqlType(final Connection connection, final DbEntityColumnDescriptor dec) {\r\n        // TODO: Implement logic to resolve the database SQL type for the given column descriptor.\r\n    }"}, {"ID": 1733, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String preprocessSql(String sqlString) { // detects callable statement if (sqlString.charAt(0) == '{') { return sqlString; } // quickly detect if SQL string is a key if (!CharUtil.isAlpha(sqlString.charAt(0))) { sqlString = sqlString.substring(1); } else if (sqlString.indexOf(' ') != -1) { return sqlString; } final String sqlFromMap = dbOom.queryMap().getQuery(sqlString); if (sqlFromMap != null) { sqlString = sqlFromMap.trim(); } return sqlString; }\n\n    ### Response:", "ground_truth": "Pre-process SQL before using it. If string starts with a non-ascii char\nor it has no spaces, it will be loaded from the query map.", "predict": "/**\r\n     * Preprocess the SQL string to detect if it is a callable statement, remove the first character if it is a key, and check if the SQL string is in the query map.\r\n     * \r\n     * @param sqlString the SQL string to preprocess\r\n     * @return the preprocessed SQL string\r\n     */\r\n    protected String preprocessSql(String sqlString) {\r\n        // detects callable statement\r\n        if (sqlString.charAt(0) == '{') {\r\n            return sqlString;\r\n        }\r\n        // quickly detect if SQL string is a key\r\n        if (!CharUtil.isAlpha(sqlString.charAt(0))) {\r\n            sqlString = sqlString.substring(1);\r\n        } else if (sqlString.indexOf(' ') != -1) {\r\n            return sqlString;\r\n        }\r\n        // check if SQL string is in query map\r\n        final String sqlFromMap = dbOom.queryMap().getQuery(sqlString);\r\n        if (sqlFromMap != null) {\r\n            sqlString = sqlFromMap.trim();\r\n        }\r\n        return sql"}, {"ID": 1734, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ResultSetMapper createResultSetMapper(final ResultSet resultSet) { final Map<String, ColumnData> columnAliases = sqlgen != null ? sqlgen.getColumnData() : null; return new DefaultResultSetMapper(dbOom, resultSet, columnAliases, cacheEntities, this); }\n\n    ### Response:", "ground_truth": "Factory for result sets mapper.", "predict": "/**\r\n     * Creates a new instance of the ResultSetMapper class.\r\n     * \r\n     * @param resultSet\r\n     *            the ResultSet to map\r\n     * @return a new instance of the ResultSetMapper class\r\n     */\r\n    protected ResultSetMapper createResultSetMapper(final ResultSet resultSet) {\r\n        final Map<String, ColumnData> columnAliases = sqlgen != null ? sqlgen.getColumnData() : null;\r\n        return new DefaultResultSetMapper(dbOom, resultSet, columnAliases, cacheEntities, this);\r\n    }"}, {"ID": 1735, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public <T> T findGeneratedKey(final Class<T> type) { return find(new Class[] {type}, false, getGeneratedColumns()); }\n\n    ### Response:", "ground_truth": "Finds generated key column of given type.", "predict": "/**\r\n     * Finds the generated key for the given type.\r\n     * \r\n     * @param type the type of the entity\r\n     * @return the generated key for the given type\r\n     */\r\n    public <T> T findGeneratedKey(final Class<T> type) {\r\n        return find(new Class[] {type}, false, getGeneratedColumns());\r\n    }"}, {"ID": 1736, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void populateGeneratedKeys(final Object entity) { final String[] generatedColumns = getGeneratedColumnNames(); if (generatedColumns == null) { return; } DbEntityDescriptor ded = dbOom.entityManager().lookupType(entity.getClass()); // prepare key types Class[] keyTypes = new Class[generatedColumns.length]; String[] properties = new String[generatedColumns.length]; for (int i = 0; i < generatedColumns.length; i++) { String column = generatedColumns[i]; DbEntityColumnDescriptor decd = ded.findByColumnName(column); if (decd != null) { keyTypes[i] = decd.getPropertyType(); properties[i] = decd.getPropertyName(); } } final Object keyValues = findGeneratedColumns(keyTypes); if (!keyValues.getClass().isArray()) { BeanUtil.declared.setProperty(entity, properties[0], keyValues); } else { for (int i = 0; i < properties.length; i++) { BeanUtil.declared.setProperty(entity, properties[i], ((Object[]) keyValues)[i]); } } }\n\n    ### Response:", "ground_truth": "Populates entity with generated column values from executed query.", "predict": "/**\r\n     * Populates the generated key values into the entity object.\r\n     * \r\n     * @param entity\r\n     *            the entity object to populate the generated key values into.\r\n     */\r\n    public void populateGeneratedKeys(final Object entity) {\r\n        // implementation details omitted for brevity\r\n    }"}, {"ID": 1737, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); }\n\n    ### Response:", "ground_truth": "Acquires interceptor from Petite container.", "predict": "/**\n     * Creates a wrapper for the given class using the Petite container.\n     *\n     * @param wrapperClass the class to wrap\n     * @param <R> the type of the wrapper\n     * @return the created wrapper\n     */\n    @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); }"}, {"ID": 1738, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p.name; if (paramName.startsWith(beanNamePrefix)) { final String propertyName = paramName.substring(beanNamePrefix.length()); if (BeanUtil.declared.hasRootProperty(bean, propertyName)) { final Object value = BeanUtil.declared.getProperty(bean, propertyName); setObject(paramName, value); } } }); return _this(); }\n\n    ### Response:", "ground_truth": "Sets bean parameters from bean. Non-existing bean properties are ignored.", "predict": "/**\r\n     * Sets the value of a named parameter based on the value of a property of a given bean.\r\n     * \r\n     * @param beanName the name of the bean\r\n     * @param bean the bean whose property value will be used to set the parameter value\r\n     * @return this Query object\r\n     */\r\n    public Q setBean(final String beanName, final Object bean);"}, {"ID": 1739, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setMap(final Map parameters) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName = p.name; setObject(paramName, parameters.get(paramName)); }); return _this(); }\n\n    ### Response:", "ground_truth": "Sets properties from the map.", "predict": "/**\r\n     * Sets the named parameters for the query.\r\n     *\r\n     * @param parameters the map of parameters to set\r\n     * @return the query instance\r\n     */\r\n    public Q setMap(final Map parameters) {\r\n        if (parameters == null) {\r\n            return _this();\r\n        }\r\n        init();\r\n        query.forEachNamedParameter(p -> {\r\n            final String paramName = p.name;\r\n            setObject(paramName, parameters.get(paramName));\r\n        });\r\n        return _this();\r\n    }"}, {"ID": 1740, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Q setObjects(final Object... objects) { int index = 1; for (final Object object : objects) { setObject(index++, object); } return _this(); }\n\n    ### Response:", "ground_truth": "Sets an array of objects parameters in given order.", "predict": "/**\r\n     * Sets the objects for the query.\r\n     * \r\n     * @param objects the objects to set\r\n     * @return the query instance\r\n     */\r\n    public Q setObjects(final Object... objects) {\r\n        int index = 1;\r\n        for (final Object object : objects) {\r\n            setObject(index++, object);\r\n        }\r\n        return _this();\r\n    }"}, {"ID": 1741, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void insertChunkAfter(final SqlChunk previous) { SqlChunk next = previous.nextChunk; previous.nextChunk = this; this.previousChunk = previous; if (next != null) { next.previousChunk = this; this.nextChunk = next; } }\n\n    ### Response:", "ground_truth": "Appends chunk to previous one and maintains the double-linked list of the previous chunk.\nCurrent surrounding connections of this chunk will be cut-off.", "predict": "/**\r\n     * Inserts a new chunk after the specified previous chunk.\r\n     * \r\n     * @param previous the previous chunk\r\n     */\r\n    public void insertChunkAfter(final SqlChunk previous) {\r\n        SqlChunk next = previous.nextChunk;\r\n        previous.nextChunk = this;\r\n        this.previousChunk = previous;\r\n        if (next != null) {\r\n            next.previousChunk = this;\r\n            this.nextChunk = next;\r\n        }\r\n    }"}, {"ID": 1742, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor lookupType(final Class entity) { final DbEntityDescriptor ded = dbEntityManager.lookupType(entity); if (ded == null) { throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName()); } return ded; }\n\n    ### Response:", "ground_truth": "Lookups for entity name and throws an exception if entity type is invalid.", "predict": "/**\r\n     * Looks up the descriptor for the given entity class.\r\n     * \r\n     * @param entity the entity class\r\n     * @return the descriptor for the entity class\r\n     * @throws DbSqlBuilderException if the entity is invalid or not-persistent\r\n     */\r\n    protected DbEntityDescriptor lookupType(final Class entity) {\r\n        final DbEntityDescriptor ded = dbEntityManager.lookupType(entity);\r\n        if (ded == null) {\r\n            throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName());\r\n        }\r\n        return ded;\r\n    }"}, {"ID": 1743, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected DbEntityDescriptor findColumnRef(final String columnRef) { DbEntityDescriptor ded = templateData.findTableDescriptorByColumnRef(columnRef); if (ded == null) { throw new DbSqlBuilderException(\"Invalid column reference: [\" + columnRef + \"]\"); } return ded; }\n\n    ### Response:", "ground_truth": "Finds a table that contains given column.", "predict": "/**\r\n     * Finds the table descriptor for the given column reference.\r\n     * \r\n     * @param columnRef the column reference to find the table descriptor for\r\n     * @return the table descriptor for the given column reference\r\n     * @throws DbSqlBuilderException if the column reference is invalid\r\n     */\r\n    protected DbEntityDescriptor findColumnRef(final String columnRef) {\r\n        // implementation details elided for brevity\r\n    }"}, {"ID": 1744, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveTable(final String tableRef, final DbEntityDescriptor ded) { String tableAlias = templateData.getTableAlias(tableRef); if (tableAlias != null) { return tableAlias; } return ded.getTableNameForQuery(); }\n\n    ### Response:", "ground_truth": "Resolves table name or alias that will be used in the query.", "predict": "/**\r\n     * Resolves the table name for the given table reference. If a table alias is defined for the given table reference, it is returned. Otherwise, the table name defined in the DbEntityDescriptor is returned.\r\n     * \r\n     * @param tableRef the table reference\r\n     * @param ded the DbEntityDescriptor\r\n     * @return the resolved table name\r\n     */\r\n    protected String resolveTable(final String tableRef, final DbEntityDescriptor ded) {\r\n        String tableAlias = templateData.getTableAlias(tableRef);\r\n        if (tableAlias != null) {\r\n            return tableAlias;\r\n        }\r\n        return ded.getTableNameForQuery();\r\n    }"}, {"ID": 1745, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected static Class resolveClass(final Object object) { Class type = object.getClass(); return type == Class.class ? (Class) object : type; }\n\n    ### Response:", "ground_truth": "Resolves object to a class.", "predict": "/**\r\n     * Resolves the class of the given object.\r\n     * \r\n     * @param object the object whose class needs to be resolved\r\n     * @return the resolved class of the object\r\n     */\r\n    protected static Class resolveClass(final Object object) {\r\n        Class type = object.getClass();\r\n        return type == Class.class ? (Class) object : type;\r\n    }"}, {"ID": 1746, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void appendMissingSpace(final StringBuilder out) { int len = out.length(); if (len == 0) { return; } len--; if (!CharUtil.isWhitespace(out.charAt(len))) { out.append(' '); } }\n\n    ### Response:", "ground_truth": "Appends missing space if the output doesn't end with whitespace.", "predict": "/**\r\n     * Appends a missing space to the end of the StringBuilder if the last character is not a whitespace character.\r\n     *\r\n     * @param out the StringBuilder to append the missing space to\r\n     */\r\n    protected void appendMissingSpace(final StringBuilder out) {\r\n        int len = out.length();\r\n        if (len == 0) {\r\n            return;\r\n        }\r\n        len--;\r\n        if (!CharUtil.isWhitespace(out.charAt(len))) {\r\n            out.append(' ');\r\n        }\r\n    }"}, {"ID": 1747, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Enumeration<String> getFileParameterNames() { if (mreq == null) { return null; } return Collections.enumeration(mreq.getFileParameterNames()); }\n\n    ### Response:", "ground_truth": "Get an enumeration of the parameter names for uploaded files", "predict": "/**\r\n     * Returns an enumeration of all the parameter names that are associated with file uploads.\r\n     * \r\n     * @return an enumeration of all the parameter names that are associated with file uploads.\r\n     */\r\n    public Enumeration<String> getFileParameterNames() {\r\n        if (mreq == null) {\r\n            return null;\r\n        }\r\n        return Collections.enumeration(mreq.getFileParameterNames());\r\n    }"}, {"ID": 1748, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException { RequestDispatcher dispatcher = request.getRequestDispatcher(page); if (dispatcher != null) { dispatcher.include(request, response); return true; } return false; }\n\n    ### Response:", "ground_truth": "Include page which path is relative to the current HTTP request.", "predict": "/**\r\n     * This method is used to include a JSP page in the current request.\r\n     * \r\n     * @param request\r\n     *            The current request object.\r\n     * @param response\r\n     *            The current response object.\r\n     * @param page\r\n     *            The JSP page to be included.\r\n     * @return true if the JSP page is included successfully, false otherwise.\r\n     * @throws IOException\r\n     *             If an I/O error occurs.\r\n     * @throws ServletException\r\n     *             If a servlet error occurs.\r\n     */\r\n    public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException {\r\n        RequestDispatcher dispatcher = request.getRequestDispatcher(page);\r\n        if (dispatcher != null) {\r\n            dispatcher.include(request, response);\r\n            return true;\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1749, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getUrl(final HttpServletRequest request) { String servletPath = request.getServletPath(); String query = request.getQueryString(); if ((query != null) && (query.length() != 0)) { servletPath += '?' + query; } return servletPath; }\n\n    ### Response:", "ground_truth": "Returns url, without context path, convenient for request dispatcher.", "predict": "/**\r\n     * This method is used to get the URL of the current request.\r\n     * \r\n     * @param request\r\n     *            The current HTTP request.\r\n     * @return The URL of the current request.\r\n     */\r\n    public static String getUrl(final HttpServletRequest request) {\r\n        String servletPath = request.getServletPath();\r\n        String query = request.getQueryString();\r\n        if ((query != null) && (query.length() != 0)) {\r\n            servletPath += '?' + query;\r\n        }\r\n        return servletPath;\r\n    }"}, {"ID": 1750, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; }\n\n    ### Response:", "ground_truth": "Get current request uri.", "predict": "/**\r\n     * Returns the request URI of the current request, taking into account any included request URI.\r\n     * \r\n     * @param request\r\n     *            the current request\r\n     * @return the request URI of the current request, taking into account any included request URI\r\n     */\r\n    public static String getRequestUri(final HttpServletRequest request) {\r\n        String result = getIncludeRequestUri(request);\r\n        if (result == null) {\r\n            result = request.getRequestURI();\r\n        }\r\n        return result;\r\n    }"}, {"ID": 1751, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String[] resolveParamNames(final Method actionClassMethod) { MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); String[] names = new String[methodParameters.length]; for (int i = 0; i < methodParameters.length; i++) { names[i] = methodParameters[i].getName(); } return names; }\n\n    ### Response:", "ground_truth": "Returns method parameter names.", "predict": "/**\r\n     * This method takes a Method object as input and returns an array of Strings containing the names of the parameters of the method.\r\n     * \r\n     * @param actionClassMethod The Method object for which the parameter names are to be resolved.\r\n     * @return An array of Strings containing the names of the parameters of the method.\r\n     */\r\n    public String[] resolveParamNames(final Method actionClassMethod) {\r\n        MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod);\r\n        String[] names = new String[methodParameters.length];\r\n        for (int i = 0; i < methodParameters.length; i++) {\r\n            names[i] = methodParameters[i].getName();\r\n        }\r\n        return names;\r\n    }"}, {"ID": 1752, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void start() { initLogger(); log.info(\"PETITE start ----------\"); petiteContainer = createPetiteContainer(); if (externalsCache) { petiteContainer.setExternalsCache(TypeCache.createDefault()); } log.info(\"Web application? \" + isWebApplication); if (!isWebApplication) { // make session scope to act as singleton scope // if this is not a web application (and http session is not available). petiteContainer.registerScope(SessionScope.class, new SingletonScope(petiteContainer)); } // load parameters from properties files petiteContainer.defineParameters(joyPropsSupplier.get().getProps()); // automagic configuration if (autoConfiguration) { final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator(petiteContainer); automagicPetiteConfigurator.registerAsConsumer(joyScannerSupplier.get().getClassScanner()); } petiteContainerConsumers.accept(this.petiteContainer); log.info(\"PETITE OK!\"); }\n\n    ### Response:", "ground_truth": "Creates and initializes Petite container.\nIt will be auto-magically configured by scanning the classpath.", "predict": "/**\n     * Initializes the logger and logs the start of the PETITE container.\n     * Creates a new Petite container and sets the externals cache if required.\n     * Registers the session scope if this is not a web application.\n     * Defines parameters from properties files.\n     * Registers automagic configuration if required.\n     * Applies consumers to the Petite container.\n     * Logs the successful completion of the PETITE container.\n     */"}, {"ID": 1753, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void stop() { if (log != null) { log.info(\"PETITE stop\"); } if (petiteContainer != null) { petiteContainer.shutdown(); } petiteContainer = null; }\n\n    ### Response:", "ground_truth": "Stops Petite container.", "predict": "/**\r\n     * Stops the petite container.\r\n     */\r\n    @Override\r\n    public void stop() {\r\n        if (log != null) {\r\n            log.info(\"PETITE stop\");\r\n        }\r\n        if (petiteContainer != null) {\r\n            petiteContainer.shutdown();\r\n        }\r\n        petiteContainer = null;\r\n    }"}, {"ID": 1754, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter subject(final String subject) { final SearchTerm subjectTerm = new SubjectTerm(subject); concat(subjectTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for SUBJECT field.\n\n@param subject The SUBJECT.\n@return this", "predict": "/**\r\n     * Adds a subject term to the search query.\r\n     * \r\n     * @param subject the subject term to add to the search query.\r\n     * @return the updated EmailFilter object.\r\n     */\r\n    public EmailFilter subject(final String subject) {\r\n        final SearchTerm subjectTerm = new SubjectTerm(subject);\r\n        concat(subjectTerm);\r\n        return this;\r\n    }"}, {"ID": 1755, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter messageId(final String messageId) { final SearchTerm msgIdTerm = new MessageIDTerm(messageId); concat(msgIdTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for message id.\n\n@param messageId The message ID.\n@return this", "predict": "/**\r\n     * Adds a Message ID search term to the filter.\r\n     * \r\n     * @param messageId the message ID to search for\r\n     * @return the updated filter\r\n     */\r\n    public EmailFilter messageId(final String messageId) {\r\n        final SearchTerm msgIdTerm = new MessageIDTerm(messageId);\r\n        concat(msgIdTerm);\r\n        return this;\r\n    }"}, {"ID": 1756, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter from(final String fromAddress) { final SearchTerm fromTerm = new FromStringTerm(fromAddress); concat(fromTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for FROM field.\n\n@param fromAddress The FROM address\n@return this", "predict": "/**\r\n     * Adds a filter to the email search that only includes emails from the specified address.\r\n     * \r\n     * @param fromAddress the email address to filter by\r\n     * @return the updated EmailFilter object\r\n     */\r\n    public EmailFilter from(final String fromAddress) {\r\n        final SearchTerm fromTerm = new FromStringTerm(fromAddress);\r\n        concat(fromTerm);\r\n        return this;\r\n    }"}, {"ID": 1757, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter to(final String toAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, toAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for TO field.\n\n@param toAddress The TO address.\n@return this", "predict": "/**\r\n     * Sets the email address to which the email should be sent.\r\n     * \r\n     * @param toAddress the email address to which the email should be sent.\r\n     * @return the updated EmailFilter object.\r\n     */\r\n    public EmailFilter to(final String toAddress) {\r\n        final SearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, toAddress);\r\n        concat(toTerm);\r\n        return this;\r\n    }"}, {"ID": 1758, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter cc(final String ccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.CC, ccAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for CC field.\n\n@param ccAddress CC addreses.\n@return this", "predict": "/**\r\n     * Adds a CC recipient to the filter.\r\n     * \r\n     * @param ccAddress the CC recipient's email address.\r\n     * @return the updated EmailFilter object.\r\n     */\r\n    public EmailFilter cc(final String ccAddress) {\r\n        final SearchTerm toTerm = new RecipientStringTerm(RecipientType.CC, ccAddress);\r\n        concat(toTerm);\r\n        return this;\r\n    }"}, {"ID": 1759, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter bcc(final String bccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.BCC, bccAddress); concat(toTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for BCC field.\n\n@param bccAddress BCC address.\n@return this", "predict": "/**\r\n     * Adds a BCC recipient to the filter.\r\n     * \r\n     * @param bccAddress the BCC recipient's email address.\r\n     * @return the updated EmailFilter object.\r\n     */\r\n    public EmailFilter bcc(final String bccAddress) {\r\n        final SearchTerm toTerm = new RecipientStringTerm(RecipientType.BCC, bccAddress);\r\n        concat(toTerm);\r\n        return this;\r\n    }"}, {"ID": 1760, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter flags(final Flags flags, final boolean value) { final SearchTerm flagTerm = new FlagTerm(flags, value); concat(flagTerm); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for many flags at once.\n\n@param flags The {@link Flags} to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": "/**\r\n     * Adds a flag term to the list of search terms.\r\n     * \r\n     * @param flags the flags to search for\r\n     * @param value the value to search for\r\n     * @return the updated EmailFilter object\r\n     */\r\n    public EmailFilter flags(final Flags flags, final boolean value) {\r\n        final SearchTerm flagTerm = new FlagTerm(flags, value);\r\n        concat(flagTerm);\r\n        return this;\r\n    }"}, {"ID": 1761, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter flag(final Flag flag, final boolean value) { final Flags flags = new Flags(); flags.add(flag); return flags(flags, value); }\n\n    ### Response:", "ground_truth": "Defines filter for single flag.\n\n@param flag  The flag to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": "/**\r\n     * Sets the flag with the given value for the email filter.\r\n     * \r\n     * @param flag the flag to set\r\n     * @param value the value to set the flag to\r\n     * @return the updated email filter\r\n     */\r\n    public EmailFilter flag(final Flag flag, final boolean value) {\r\n        final Flags flags = new Flags();\r\n        flags.add(flag);\r\n        return flags(flags, value);\r\n    }"}, {"ID": 1762, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter receivedDate(final Operator operator, final long milliseconds) { final SearchTerm term = new ReceivedDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for received date.\n\n@return this", "predict": "/**\r\n     * Adds a search term for the received date of the email.\r\n     * \r\n     * @param operator the operator to use for the search term\r\n     * @param milliseconds the date in milliseconds to use for the search term\r\n     * @return the updated EmailFilter object\r\n     */\r\n    public EmailFilter receivedDate(final Operator operator, final long milliseconds) {\r\n        final SearchTerm term = new ReceivedDateTerm(operator.value, new Date(milliseconds));\r\n        concat(term);\r\n        return this;\r\n    }"}, {"ID": 1763, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter sentDate(final Operator operator, final long milliseconds) { final SearchTerm term = new SentDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for sent date.\n\n@param operator     {@link Operator} to use.\n@param milliseconds the milliseconds since January 1, 1970, 00:00:00 GMT.\n@return this", "predict": "/**\r\n     * Adds a search term for the sent date of the email.\r\n     * \r\n     * @param operator the operator to use for the search term\r\n     * @param milliseconds the date in milliseconds to use for the search term\r\n     * @return the updated EmailFilter object\r\n     */\r\n    public EmailFilter sentDate(final Operator operator, final long milliseconds) {\r\n        final SearchTerm term = new SentDateTerm(operator.value, new Date(milliseconds));\r\n        concat(term);\r\n        return this;\r\n    }"}, {"ID": 1764, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter size(final Operator comparison, final int size) { final SearchTerm term = new SizeTerm(comparison.value, size); concat(term); return this; }\n\n    ### Response:", "ground_truth": "Defines filter for message size.\n\n@param comparison {@link Operator}.\n@param size       size of message.\n@return this", "predict": "/**\r\n     * Adds a size term to the filter.\r\n     * \r\n     * @param comparison the comparison operator to use for the size term\r\n     * @param size the size to compare against\r\n     * @return the updated filter\r\n     */\r\n    public EmailFilter size(final Operator comparison, final int size) {\r\n        final SearchTerm term = new SizeTerm(comparison.value, size);\r\n        concat(term);\r\n        return this;\r\n    }"}, {"ID": 1765, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter and(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new AndTerm(searchTerms)); return this; }\n\n    ### Response:", "ground_truth": "Defines AND group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to AND.\n@return this", "predict": "/**\r\n     * Adds the given email filters to the current filter using the AND operator.\r\n     *\r\n     * @param emailFilters the email filters to add\r\n     * @return the updated email filter\r\n     */\r\n    public EmailFilter and(final EmailFilter... emailFilters) {\r\n        final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length];\r\n        for (int i = 0; i < emailFilters.length; i++) {\r\n            searchTerms[i] = emailFilters[i].searchTerm;\r\n        }\r\n        concat(new AndTerm(searchTerms));\r\n        return this;\r\n    }"}, {"ID": 1766, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter or(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new OrTerm(searchTerms)); return this; }\n\n    ### Response:", "ground_truth": "Defines OR group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to OR.\n@return this", "predict": "/**\r\n     * Adds an OR condition to the filter.\r\n     * \r\n     * @param emailFilters the email filters to be combined with OR condition.\r\n     * @return the updated email filter.\r\n     */\r\n    public EmailFilter or(final EmailFilter... emailFilters) {\r\n        final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length];\r\n        for (int i = 0; i < emailFilters.length; i++) {\r\n            searchTerms[i] = emailFilters[i].searchTerm;\r\n        }\r\n        concat(new OrTerm(searchTerms));\r\n        return this;\r\n    }"}, {"ID": 1767, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailFilter not(final EmailFilter emailFilter) { final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm); concat(searchTerm); return this; }\n\n    ### Response:", "ground_truth": "Appends single filter as NOT.\n\n@param emailFilter {@link EmailFilter} to append.\n@return this", "predict": "/**\r\n     * Negates the search term of the given email filter.\r\n     * \r\n     * @param emailFilter the email filter to negate\r\n     * @return the negated email filter\r\n     */\r\n    public EmailFilter not(final EmailFilter emailFilter) {\r\n        final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm);\r\n        concat(searchTerm);\r\n        return this;\r\n    }"}, {"ID": 1768, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void concat(SearchTerm searchTerm) { if (nextIsNot) { searchTerm = new NotTerm(searchTerm); nextIsNot = false; } if (operatorAnd) { and(searchTerm); } else { or(searchTerm); } }\n\n    ### Response:", "ground_truth": "Concatenates last search term with new one.\n\n@param searchTerm searchTerm {@link SearchTerm} concatenate.\n@see #and(SearchTerm)\n@see #or(SearchTerm)", "predict": "/**\r\n     * Concatenates the given search term with the current search term.\r\n     * \r\n     * @param searchTerm the search term to concatenate\r\n     */\r\n    protected void concat(SearchTerm searchTerm) {\r\n        if (nextIsNot) {\r\n            searchTerm = new NotTerm(searchTerm);\r\n            nextIsNot = false;\r\n        }\r\n        if (operatorAnd) {\r\n            and(searchTerm);\r\n        } else {\r\n            or(searchTerm);\r\n        }\r\n    }"}, {"ID": 1769, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encode(final byte[] bytes) { StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i < bytes.length) { // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] & 255; base32.append(CHARS[currByte >> 3]); digit = (currByte & 7) << 2; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 6)]); base32.append(CHARS[(currByte >> 1) & 31]); digit = (currByte & 1) << 4; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 4)]); digit = (currByte & 15) << 1; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 7)]); base32.append(CHARS[(currByte >> 2) & 31]); digit = (currByte & 3) << 3; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 5)]); base32.append(CHARS[currByte & 31]); } return base32.toString(); }\n\n    ### Response:", "ground_truth": "Encode an array of binary bytes into a Base32 string.", "predict": "/**\r\n * Encodes a byte array into a Base32 string.\r\n *\r\n * @param bytes the byte array to encode\r\n * @return the Base32 string representation of the byte array\r\n */\r\npublic static String encode(final byte[] bytes) {\r\n    StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5);\r\n    int currByte, digit, i = 0;\r\n    while (i < bytes.length) {\r\n        // STEP 0; insert new 5 bits, leave 3 bits\r\n        currByte = bytes[i++] & 255;\r\n        base32.append(CHARS[currByte >> 3]);\r\n        digit = (currByte & 7) << 2;\r\n        if (i >= bytes.length) {\r\n            base32.append(CHARS[digit]);\r\n            break;\r\n        }\r\n        // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit\r\n        currByte = bytes[i++] &"}, {"ID": 1770, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected byte[] convertValueToArray(final Object value) { if (value instanceof Blob) { final Blob blob = (Blob) value; try { final long length = blob.length(); if (length > Integer.MAX_VALUE) { throw new TypeConversionException(\"Blob is too big.\"); } return blob.getBytes(1, (int) length); } catch (SQLException sex) { throw new TypeConversionException(value, sex); } } if (value instanceof File) { try { return FileUtil.readBytes((File) value); } catch (IOException ioex) { throw new TypeConversionException(value, ioex); } } if (value instanceof Collection) { final Collection collection = (Collection) value; final byte[] target = new byte[collection.size()]; int i = 0; for (final Object element : collection) { target[i] = convertType(element); i++; } return target; } if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final ArrayList<Byte> byteArrayList = new ArrayList<>(); for (final Object element : iterable) { final byte convertedValue = convertType(element); byteArrayList.add(Byte.valueOf(convertedValue)); } final byte[] array = new byte[byteArrayList.size()]; for (int i = 0; i < byteArrayList.size(); i++) { final Byte b = byteArrayList.get(i); array[i] = b.byteValue(); } return array; } if (value instanceof CharSequence) { final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS); return convertArrayToArray(strings); } // everything else: return convertToSingleElementArray(value); }\n\n    ### Response:", "ground_truth": "Converts non-array value to array. Detects various\ntypes and collections, iterates them to make conversion\nand to create target array.", "predict": "/**\r\n     * Converts the given value to an array of bytes.\r\n     *\r\n     * @param value the value to convert\r\n     * @return the resulting array of bytes\r\n     * @throws TypeConversionException if the value cannot be converted to an array of bytes\r\n     */\r\n    protected byte[] convertValueToArray(final Object value) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1771, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean isGzipEligible(final HttpServletRequest request) { // request parameter name if (requestParameterName.length() != 0) { String forceGzipString = request.getParameter(requestParameterName); if (forceGzipString != null) { return Converter.get().toBooleanValue(forceGzipString, false); } } // extract uri String uri = request.getRequestURI(); if (uri == null) { return false; } uri = uri.toLowerCase(); boolean result = false; // check uri if (matches == null) { // match == * if (extensions == null) { // extensions == * return true; } // extension String extension = FileNameUtil.getExtension(uri); if (extension.length() > 0) { extension = extension.toLowerCase(); if (StringUtil.equalsOne(extension, extensions) != -1) { result = true; } } } else { if (wildcards) { result = Wildcard.matchPathOne(uri, matches) != -1; } else { for (String match : matches) { if (uri.contains(match)) { result = true; break; } } } } if ((result) && (excludes != null)) { if (wildcards) { if (Wildcard.matchPathOne(uri, excludes) != -1) { result = false; } } else { for (String exclude : excludes) { if (uri.contains(exclude)) { result = false; // excludes founded break; } } } } return result; }\n\n    ### Response:", "ground_truth": "Determine if request is eligible for GZipping.", "predict": "/**\r\n     * Checks if the given request is eligible for Gzip compression based on the request parameter name and the request URI.\r\n     * \r\n     * @param request\r\n     *            the HTTP request\r\n     * @param requestParameterName\r\n     *            the name of the request parameter that can be used to force Gzip compression\r\n     * @param matches\r\n     *            the list of URI patterns that are eligible for Gzip compression\r\n     * @param wildcards\r\n     *            true if the matches list contains wildcard patterns, false otherwise\r\n     * @param extensions\r\n     *            the list of file extensions that are eligible for Gzip compression\r\n     * @param excludes\r\n     *            the list of URI patterns that are excluded from Gzip compression\r\n     * @return true if the request is eligible for Gzip compression, false otherwise\r\n     */\r\n    protected boolean isGzipEligible(final HttpServletRequest request, final String requestParameterName, final List<String> matches, final boolean wildcards, final List<String> extensions, final List<String> excludes) {\r\n        // request parameter"}, {"ID": 1772, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Violation> validate(final Object target) { return validate(ValidationContext.resolveFor(target.getClass()), target); }\n\n    ### Response:", "ground_truth": "Validate object using context from the annotations.", "predict": "/**\n     * Validates the given target object using the default validation context and returns a list of violations.\n     * \n     * @param target the object to be validated\n     * @return a list of violations, or an empty list if there are no violations\n     */\n    public List<Violation> validate(final Object target) {\n        return validate(ValidationContext.resolveFor(target.getClass()), target);\n    }"}, {"ID": 1773, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) { for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) { String name = entry.getKey(); Object value = BeanUtil.declaredSilent.getProperty(target, name); String valueName = targetName != null ? (targetName + '.' + name) : name; // move up ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName); for (Check check : entry.getValue()) { String[] checkProfiles = check.getProfiles(); if (!matchProfiles(checkProfiles)) { continue; } if (check.getSeverity() < severity) { continue; } ValidationConstraint constraint = check.getConstraint(); if (!constraint.isValid(vcc, value)) { addViolation(new Violation(valueName, target, value, check)); } } } return getViolations(); }\n\n    ### Response:", "ground_truth": "Performs validation of provided validation context and appends violations.", "predict": "/**\r\n     * Validates the given target object using the given validation context.\r\n     * \r\n     * @param ctx the validation context\r\n     * @param target the target object to validate\r\n     * @param targetName the name of the target object (optional)\r\n     * @return a list of violations\r\n     */\r\n    public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) {\r\n        // implementation omitted for brevity\r\n    }"}, {"ID": 1774, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useProfile(final String profile) { if (profile == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } this.enabledProfiles.add(profile); }\n\n    ### Response:", "ground_truth": "Enables single profile.", "predict": "/**\r\n     * This method adds a profile to the list of enabled profiles.\r\n     * \r\n     * @param profile The profile to be added to the list of enabled profiles.\r\n     */\r\n    public void useProfile(final String profile) {\r\n        if (profile == null) {\r\n            return;\r\n        }\r\n        if (this.enabledProfiles == null) {\r\n            this.enabledProfiles = new HashSet<>();\r\n        }\r\n        this.enabledProfiles.add(profile);\r\n    }"}, {"ID": 1775, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void useProfiles(final String... enabledProfiles) { if (enabledProfiles == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } Collections.addAll(this.enabledProfiles, enabledProfiles); }\n\n    ### Response:", "ground_truth": "Enables list of profiles.", "predict": "/**\r\n     * This method is used to enable the given profiles for the current application.\r\n     * \r\n     * @param enabledProfiles - The profiles to be enabled.\r\n     */\r\n    public void useProfiles(final String... enabledProfiles) {\r\n        if (enabledProfiles == null) {\r\n            return;\r\n        }\r\n        if (this.enabledProfiles == null) {\r\n            this.enabledProfiles = new HashSet<>();\r\n        }\r\n        Collections.addAll(this.enabledProfiles, enabledProfiles);\r\n    }"}, {"ID": 1776, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected boolean matchProfiles(final String[] checkProfiles) { // test for all profiles if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) { return true; } if (enabledProfiles == null || enabledProfiles.isEmpty()) { if (validateAllProfilesByDefault) { return true; // all profiles are considered as enabled } // only default profile is enabled if ((checkProfiles == null) || (checkProfiles.length == 0)) { return true; } for (String profile : checkProfiles) { if (StringUtil.isEmpty(profile)) { return true; // default profile } if (profile.equals(DEFAULT_PROFILE)) { return true; } } return false; } // there are enabled profiles if ((checkProfiles == null) || (checkProfiles.length == 0)) { return enabledProfiles.contains(DEFAULT_PROFILE); } boolean result = false; for (String profile : checkProfiles) { boolean b = true; boolean must = false; if (StringUtil.isEmpty(profile)) { profile = DEFAULT_PROFILE; } else if (profile.charAt(0) == '-') { profile = profile.substring(1); b = false; } else if (profile.charAt(0) == '+') { profile = profile.substring(1); must = true; } if (enabledProfiles.contains(profile)) { if (!b) { return false; } result = true; } else { if (must) { return false; } } } return result; }\n\n    ### Response:", "ground_truth": "Determine if any of checks profiles is among enabled profiles.", "predict": "/**\r\n     * This method is used to match the given profiles with the enabled profiles.\r\n     * \r\n     * @param checkProfiles\r\n     *            the list of profiles to be checked.\r\n     * @return true if all the profiles match, false otherwise.\r\n     */\r\n    protected boolean matchProfiles(final String[] checkProfiles) {\r\n        // test for all profiles\r\n        if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) {\r\n            return true;\r\n        }\r\n        if (enabledProfiles == null || enabledProfiles.isEmpty()) {\r\n            if (validateAllProfilesByDefault) {\r\n                return true; // all profiles are considered as enabled\r\n            }\r\n            // only default profile is enabled\r\n            if ((checkProfiles == null) || (checkProfiles.length == 0)) {\r\n                return true;\r\n            }\r\n            for (String profile : checkProfiles) {\r\n                if (StringUtil.isEmpty(profile)) {\r\n                    return true; // default profile\r\n                }\r\n                if (profile.equals(DEFAULT_PROFILE"}, {"ID": 1777, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected Object parseRequestBody(final String body, final Class targetType) { return JsonParser.create().parse(body, targetType); }\n\n    ### Response:", "ground_truth": "Parses request body into the target type.", "predict": "/**\r\n     * Parses the given request body into an object of the given target type using the JSON parser.\r\n     *\r\n     * @param body the request body to parse\r\n     * @param targetType the target type of the object to parse into\r\n     * @return the parsed object\r\n     */\r\n    protected Object parseRequestBody(final String body, final Class targetType) { return JsonParser.create().parse(body, targetType); }"}, {"ID": 1778, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long toMilliseconds() { double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY; then += (integer - JD_1970.integer) * MILLIS_IN_DAY; then += then > 0 ? 1.0e-6 : -1.0e-6; return (long) then; }\n\n    ### Response:", "ground_truth": "Converts to milliseconds.", "predict": "/**\r\n     * Converts the Julian Date to milliseconds since January 1, 1970, 00:00:00 UTC.\r\n     *\r\n     * @return the number of milliseconds since January 1, 1970, 00:00:00 UTC\r\n     */\r\n    public long toMilliseconds() {\r\n        double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY;\r\n        then += (integer - JD_1970.integer) * MILLIS_IN_DAY;\r\n        then += then > 0 ? 1.0e-6 : -1.0e-6;\r\n        return (long) then;\r\n    }"}, {"ID": 1779, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JulianDate add(final JulianDate jds) { int i = this.integer + jds.integer; double f = this.fraction + jds.fraction; return new JulianDate(i, f); }\n\n    ### Response:", "ground_truth": "Adds a JD to current instance.", "predict": "/**\r\n     * Adds the given JulianDate to this JulianDate and returns the result.\r\n     * \r\n     * @param jds the JulianDate to add to this JulianDate\r\n     * @return the result of adding the two JulianDates\r\n     */\r\n    public JulianDate add(final JulianDate jds) {\r\n        int i = this.integer + jds.integer;\r\n        double f = this.fraction + jds.fraction;\r\n        return new JulianDate(i, f);\r\n    }"}, {"ID": 1780, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public JulianDate sub(final JulianDate jds) { int i = this.integer - jds.integer; double f = this.fraction -jds.fraction; return new JulianDate(i, f); }\n\n    ### Response:", "ground_truth": "Subtracts a JD from current instance.", "predict": "/**\r\n     * Subtracts the JulianDate object passed as parameter from the current JulianDate object.\r\n     * @param jds The JulianDate object to be subtracted from the current JulianDate object.\r\n     * @return A new JulianDate object that is the result of the subtraction operation.\r\n     */\r\n    public JulianDate sub(final JulianDate jds) {\r\n        int i = this.integer - jds.integer;\r\n        double f = this.fraction - jds.fraction;\r\n        return new JulianDate(i, f);\r\n    }"}, {"ID": 1781, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void set(final int i, double f) { integer = i; int fi = (int) f; f -= fi; integer += fi; if (f < 0) { f += 1; integer--; } this.fraction = f; }\n\n    ### Response:", "ground_truth": "Sets integer and fractional part with normalization.\nNormalization means that if double is out of range,\nvalues will be correctly fixed.", "predict": "/**\r\n     * Sets the integer and fraction of the object.\r\n     * \r\n     * @param i The integer value to set.\r\n     * @param f The fraction value to set.\r\n     */\r\n    private void set(final int i, double f) {\r\n        integer = i;\r\n        int fi = (int) f;\r\n        f -= fi;\r\n        integer += fi;\r\n        if (f < 0) {\r\n            f += 1;\r\n            integer--;\r\n        }\r\n        this.fraction = f;\r\n    }"}, {"ID": 1782, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected void initialize(final char[] input) { super.initialize(input); this.tag = new ParsedTag(); this.doctype = new ParsedDoctype(); this.text = new char[1024]; this.textLen = 0; this.parsingTime = -1; }\n\n    ### Response:", "ground_truth": "Initializes parser.", "predict": "/**\n     * Initializes the parser with the input character array.\n     * \n     * @param input the input character array\n     */\n    @Override\n    protected void initialize(final char[] input) {\n        super.initialize(input);\n        this.tag = new ParsedTag();\n        this.doctype = new ParsedDoctype();\n        this.text = new char[1024];\n        this.textLen = 0;\n        this.parsingTime = -1;\n    }"}, {"ID": 1783, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void emitComment(final int from, final int to) { if (config.enableConditionalComments) { // CC: downlevel-hidden starting if (match(CC_IF, from)) { int endBracketNdx = find(']', from + 3, to); CharSequence expression = charSequence(from + 1, endBracketNdx); ndx = endBracketNdx + 1; char c = input[ndx]; if (c != '>') { errorInvalidToken(); } visitor.condComment(expression, true, true, false); state = DATA_STATE; return; } if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) { // CC: downlevel-hidden ending visitor.condComment(_ENDIF, false, true, true); state = DATA_STATE; return; } } CharSequence comment = charSequence(from, to); visitor.comment(comment); commentStart = -1; }\n\n    ### Response:", "ground_truth": "Emits a comment. Also checks for conditional comments!", "predict": "/**\n     * Emits a comment to the output.\n     *\n     * @param from the starting index of the comment in the input buffer\n     * @param to the ending index of the comment in the input buffer\n     */\n    protected void emitComment(final int from, final int to) {\n        if (config.enableConditionalComments) {\n            // CC: downlevel-hidden starting\n            if (match(CC_IF, from)) {\n                int endBracketNdx = find(']', from + 3, to);\n                CharSequence expression = charSequence(from + 1, endBracketNdx);\n                ndx = endBracketNdx + 1;\n                char c = input[ndx];\n                if (c != '>') {\n                    errorInvalidToken();\n                }\n                visitor.condComment(expression, true, true, false);\n                state = DATA_STATE;\n                return;\n            }\n            if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) {"}, {"ID": 1784, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void _error(String message) { if (config.calculatePosition) { Position currentPosition = position(ndx); message = message .concat(StringPool.SPACE) .concat(currentPosition.toString()); } else { message = message .concat(\" [@\") .concat(Integer.toString(ndx)) .concat(StringPool.RIGHT_SQ_BRACKET); } visitor.error(message); }\n\n    ### Response:", "ground_truth": "Prepares error message and reports it to the visitor.", "predict": "/**\r\n     * Private method to handle errors.\r\n     * \r\n     * @param message the error message to display\r\n     */\r\n    protected void _error(String message) {\r\n        if (config.calculatePosition) {\r\n            Position currentPosition = position(ndx);\r\n            message = message.concat(StringPool.SPACE).concat(currentPosition.toString());\r\n        } else {\r\n            message = message.concat(\" [@\").concat(Integer.toString(ndx)).concat(StringPool.RIGHT_SQ_BRACKET);\r\n        }\r\n        visitor.error(message);\r\n    }"}, {"ID": 1785, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String createHash(final char[] password) { // Generate a random salt SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltBytes]; random.nextBytes(salt); // Hash the password byte[] hash = pbkdf2(password, salt, pbkdf2Iterations, hashBytes); // format iterations:salt:hash return pbkdf2Iterations + \":\" + StringUtil.toHexString(salt) + \":\" + StringUtil.toHexString(hash); }\n\n    ### Response:", "ground_truth": "Returns a salted PBKDF2 hash of the password.\n\n@param password the password to hash\n@return a salted PBKDF2 hash of the password", "predict": "/**\r\n     * Generates a hash for the given password using the PBKDF2 algorithm.\r\n     *\r\n     * @param password the password to hash\r\n     * @return the hash as a string in the format iterations:salt:hash\r\n     */\r\n    public String createHash(final char[] password) {\r\n        // Generate a random salt\r\n        SecureRandom random = new SecureRandom();\r\n        byte[] salt = new byte[saltBytes];\r\n        random.nextBytes(salt);\r\n\r\n        // Hash the password\r\n        byte[] hash = pbkdf2(password, salt, pbkdf2Iterations, hashBytes);\r\n\r\n        // Format iterations:salt:hash\r\n        return pbkdf2Iterations + \":\" + StringUtil.toHexString(salt) + \":\" + StringUtil.toHexString(hash);\r\n    }"}, {"ID": 1786, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] pbkdf2(final char[] password, final byte[] salt, final int iterations, final int bytes) { PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8); try { SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM); return skf.generateSecret(spec).getEncoded(); } catch (NoSuchAlgorithmException ignore) { return null; } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } }\n\n    ### Response:", "ground_truth": "Computes the PBKDF2 hash of a password.\n\n@param password the password to hash.\n@param salt the salt\n@param iterations the iteration count (slowness factor)\n@param bytes the length of the hash to compute in bytes\n@return the PBDKF2 hash of the password", "predict": "/**\r\n     * Generates a secret key using the PBKDF2 algorithm.\r\n     *\r\n     * @param password the password to use for the key generation.\r\n     * @param salt the salt to use for the key generation.\r\n     * @param iterations the number of iterations to use for the key generation.\r\n     * @param bytes the number of bytes to generate for the key.\r\n     * @return the generated secret key.\r\n     * @throws IllegalArgumentException if the password is null or empty, or if the salt is null or empty, or if the iterations is less than 1, or if the bytes is less than 1.\r\n     */\r\n    private static byte[] pbkdf2(final char[] password, final byte[] salt, final int iterations, final int bytes) {\r\n        // TODO: Implement method\r\n    }"}, {"ID": 1787, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static byte[] fromHex(final String hex) { final byte[] binary = new byte[hex.length() / 2]; for (int i = 0; i < binary.length; i++) { binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16); } return binary; }\n\n    ### Response:", "ground_truth": "Converts a string of hexadecimal characters into a byte array.\n\n@param hex the hex string\n@return the hex string decoded into a byte array", "predict": "/**\r\n     * Converts a hexadecimal string to a byte array.\r\n     *\r\n     * @param hex the hexadecimal string to convert\r\n     * @return the resulting byte array\r\n     */\r\n    private static byte[] fromHex(final String hex) {\r\n        final byte[] binary = new byte[hex.length() / 2];\r\n        for (int i = 0; i < binary.length; i++) {\r\n            binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);\r\n        }\r\n        return binary;\r\n    }"}, {"ID": 1788, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ProviderDefinition[] resolveProviderDefinitions(final Class type, final String name) { return providerResolver.resolve(type, name); }\n\n    ### Response:", "ground_truth": "Resolves provider definition defined in a bean.", "predict": "/**\r\n     * Resolves an array of provider definitions for the given type and name.\r\n     * \r\n     * @param type the type of the provider to resolve\r\n     * @param name the name of the provider to resolve\r\n     * @return an array of provider definitions for the given type and name\r\n     */\r\n    public ProviderDefinition[] resolveProviderDefinitions(final Class type, final String name) { return providerResolver.resolve(type, name); }"}, {"ID": 1789, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public EmailAttachmentBuilder name(final String name) { if (name != null && !name.trim().isEmpty()) { this.name = name; } return this; }\n\n    ### Response:", "ground_truth": "Sets file name.\n\n@param name File name to set.\n@return this", "predict": "/**\r\n     * Sets the name of the attachment.\r\n     * \r\n     * @param name the name of the attachment.\r\n     * @return the EmailAttachmentBuilder instance.\r\n     */\r\n    public EmailAttachmentBuilder name(final String name) {\r\n        if (name != null && !name.trim().isEmpty()) {\r\n            this.name = name;\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1790, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected EmailAttachmentBuilder setContentIdFromNameIfMissing() { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; }\n\n    ### Response:", "ground_truth": "Set content ID if it is missing.\n\n@return this\n@see #contentId(String)", "predict": "/**\r\n     * Sets the content ID of the attachment to the file name if it is missing.\r\n     * \r\n     * @return the updated EmailAttachmentBuilder instance\r\n     */\r\n    protected EmailAttachmentBuilder setContentIdFromNameIfMissing() {\r\n        if (contentId == null) {\r\n            if (name != null) {\r\n                contentId(FileNameUtil.getName(name));\r\n            } else {\r\n                contentId(NO_NAME);\r\n            }\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1791, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected String resolveContentType(final String contentType) { if (contentType != null) { return contentType; } if (name == null) { return MimeTypes.MIME_APPLICATION_OCTET_STREAM; } final String extension = FileNameUtil.getExtension(name); return MimeTypes.getMimeType(extension); }\n\n    ### Response:", "ground_truth": "Resolves content type from all data.\n\n@param contentType Content type if we know it. {@code null} is fine to use.\n@return content type", "predict": "/**\r\n     * Resolves the content type based on the given content type and file name.\r\n     * \r\n     * @param contentType the content type to resolve\r\n     * @return the resolved content type\r\n     */\r\n    protected String resolveContentType(final String contentType) {\r\n        if (contentType != null) {\r\n            return contentType;\r\n        }\r\n        if (name == null) {\r\n            return MimeTypes.MIME_APPLICATION_OCTET_STREAM;\r\n        }\r\n        final String extension = FileNameUtil.getExtension(name);\r\n        return MimeTypes.getMimeType(extension);\r\n    }"}, {"ID": 1792, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int computeAttributesSize() { symbolTable.addConstantUtf8(Constants.MODULE); // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; if (packageCount > 0) { symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES); // 6 attribute header bytes, and 2 bytes for package_count. size += 8 + packageIndex.length; } if (mainClassIndex > 0) { symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS); // 6 attribute header bytes, and 2 bytes for main_class_index. size += 8; } return size; }\n\n    ### Response:", "ground_truth": "Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\nModuleWriter. Also add the names of these attributes in the constant pool.\n\n@return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.", "predict": "/**\r\n     * Computes the size of the attributes of a module.\r\n     * \r\n     * @return the size of the attributes of a module.\r\n     */\r\n    private int computeAttributesSize() {\r\n        // TODO: Implement this method.\r\n    }"}, {"ID": 1793, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void putAttributes(final ByteVector output) { // 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; output .putShort(symbolTable.addConstantUtf8(Constants.MODULE)) .putInt(moduleAttributeLength) .putShort(moduleNameIndex) .putShort(moduleFlags) .putShort(moduleVersionIndex) .putShort(requiresCount) .putByteArray(requires.data, 0, requires.length) .putShort(exportsCount) .putByteArray(exports.data, 0, exports.length) .putShort(opensCount) .putByteArray(opens.data, 0, opens.length) .putShort(usesCount) .putByteArray(usesIndex.data, 0, usesIndex.length) .putShort(providesCount) .putByteArray(provides.data, 0, provides.length); if (packageCount > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)) .putInt(2 + packageIndex.length) .putShort(packageCount) .putByteArray(packageIndex.data, 0, packageIndex.length); } if (mainClassIndex > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)) .putInt(2) .putShort(mainClassIndex); } }\n\n    ### Response:", "ground_truth": "Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\nin the given ByteVector.\n\n@param output where the attributes must be put.", "predict": "/**\n     * Adds the module attribute to the constant pool of the given {@link ByteVector}.\n     *\n     * @param output the output byte vector to which the module attribute will be added.\n     */\n    public void putAttributes(final ByteVector output) {\n        // 6 bytes for name, flags and version, and 5 * 2 bytes for counts.\n        int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length;\n        output.putShort(symbolTable.addConstantUtf8(Constants.MODULE))\n                .putInt(moduleAttributeLength)\n                .putShort(moduleNameIndex)\n                .putShort(moduleFlags)\n                .putShort(moduleVersionIndex)\n                .putShort(requiresCount)\n                .putByteArray(requires.data, 0, requires.length)\n                .putShort(exportsCount)\n                .putByteArray(exports.data, 0, exports.length)\n                .putShort(opensCount)\n                ."}, {"ID": 1794, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decode(final String source, final String encoding) { return decode(source, encoding, false); }\n\n    ### Response:", "ground_truth": "Decodes URL elements. This method may be used for all\nparts of URL, except for the query parts, since it does\nnot decode the '+' character.\n@see #decodeQuery(String, String)", "predict": "/**\r\n     * Decodes the specified string using the specified encoding.\r\n     * \r\n     * @param source the string to be decoded\r\n     * @param encoding the encoding to be used\r\n     * @return the decoded string\r\n     */\r\n    public static String decode(final String source, final String encoding) {\r\n        return decode(source, encoding, false);\r\n    }"}, {"ID": 1795, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String decodeQuery(final String source, final String encoding) { return decode(source, encoding, true); }\n\n    ### Response:", "ground_truth": "Decodes query name or value.", "predict": "/**\r\n     * Decodes the query string of a URL using the specified encoding.\r\n     *\r\n     * @param source the URL query string to decode\r\n     * @param encoding the encoding to use for decoding\r\n     * @return the decoded query string\r\n     */\r\n    public static String decodeQuery(final String source, final String encoding) {\r\n        return decode(source, encoding, true);\r\n    }"}, {"ID": 1796, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override @SuppressWarnings(\"unchecked\") public void start() { initLogger(); if (!databaseEnabled) { log.info(\"DB not enabled.\"); return; } log.info(\"DB start ----------\"); final PetiteContainer petiteContainer = joyPetiteSupplier.get().getPetiteContainer(); // connection pool connectionProvider = createConnectionProviderIfNotSupplied(); petiteContainer.addBean(beanNamePrefix() + \"pool\", connectionProvider); if (connectionProvider instanceof CoreConnectionPool) { final CoreConnectionPool pool = (CoreConnectionPool) connectionProvider; if (pool.getDriver() == null) { databaseEnabled = false; log.warn(\"DB configuration not set (\" + beanNamePrefix() + \"pool.*). DB will be disabled.\"); return; } } connectionProvider.init(); checkConnectionProvider(); // transactions manager jtxManager = createJtxTransactionManager(connectionProvider); jtxManager.setValidateExistingTransaction(true); final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager(new LeanJtxWorker(jtxManager), jtxScopePattern); AnnotationTxAdviceSupport.manager = annTxAdviceManager; // create proxy joyProxettaSupplier.get().getProxetta().withAspect(createTxProxyAspects(annTxAdviceManager.getAnnotations())); final DbSessionProvider sessionProvider = new DbJtxSessionProvider(jtxManager); // querymap final long startTime = System.currentTimeMillis(); final QueryMap queryMap = new DbPropsQueryMap(); log.debug(\"Queries loaded in \" + (System.currentTimeMillis() - startTime) + \"ms.\"); log.debug(\"Total queries: \" + queryMap.size()); // dboom dbOom = DbOom.create() .withConnectionProvider(connectionProvider) .withSessionProvider(sessionProvider) .withQueryMap(queryMap) .get(); dbOom.connect(); final DbEntityManager dbEntityManager = dbOom.entityManager(); dbEntityManager.reset(); petiteContainer.addBean(beanNamePrefix() + \"query\", dbOom.queryConfig()); petiteContainer.addBean(beanNamePrefix() + \"oom\", dbOom.config()); // automatic configuration if (autoConfiguration) { final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator(dbEntityManager, true); automagicDbOomConfigurator.registerAsConsumer( joyScannerSupplier.get().getClassScanner()); } dbEntityManagerConsumers.accept(dbEntityManager); log.info(\"DB OK!\"); }\n\n    ### Response:", "ground_truth": "Initializes database. First, creates connection pool.\nand transaction manager. Then, Jodds DbEntityManager is\nconfigured. It is also configured automagically, by scanning\nthe class path for entities.", "predict": "/**\n     * This method is called by the container when the component is being started. It initializes the logger, checks if the database is enabled, creates the connection pool, creates the transactions manager, creates the proxy, creates the query map, creates the DbOom instance, and connects to the database.\n     */"}, {"ID": 1797, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void checkConnectionProvider() { final Connection connection = connectionProvider.getConnection(); try { final DatabaseMetaData databaseMetaData = connection.getMetaData(); String name = databaseMetaData.getDatabaseProductName(); String version = databaseMetaData.getDatabaseProductVersion(); if (log.isInfoEnabled()) { log.info(\"Connected to database: \" + name + \" v\" + version); } } catch (SQLException sex) { log.error(\"DB connection failed: \", sex); } finally { connectionProvider.closeConnection(connection); } }\n\n    ### Response:", "ground_truth": "Checks if connection provider can return a connection.", "predict": "/**\r\n     * Checks the connection provider for a valid connection and retrieves the database metadata.\r\n     * Logs the database name and version if the log level is INFO.\r\n     * If the connection fails, logs an error message.\r\n     * Closes the connection after use.\r\n     */"}, {"ID": 1798, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { // if ((access & AsmUtil.ACC_FINAL) != 0) { // return null; // skip finals // } MethodSignatureVisitor msign = createMethodSignature(access, name, desc, signature, exceptions, thisReference, this.generics); String key = ProxettaAsmUtil.createMethodSignaturesKey(access, name, desc, thisReference); methodSignatures.put(key, msign); allMethodSignatures.add(msign.getCleanSignature()); return new MethodAnnotationReader(msign); }\n\n    ### Response:", "ground_truth": "Stores method signature for target method.", "predict": "/**\r\n     * This method is called by the ASM framework when visiting a method.\r\n     * \r\n     * @param access the method's access flags (see {@link Opcodes}). This is an integer representation of the method's modifiers.\r\n     * @param name the method's name.\r\n     * @param desc the method's descriptor (see {@link Type}).\r\n     * @param signature the method's signature. May be null if the method is not a generic method or if the generic signature information is unavailable.\r\n     * @param exceptions the internal names of the method's exception classes (see {@link Type#getInternalName()}). May be null.\r\n     * @return a {@link MethodVisitor} that can be used to visit the method's code, or null if the method should be skipped.\r\n     */\r\n    @Override\r\n    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {\r\n        // if ((access & AsmUtil.ACC_FINAL) != 0) { //"}, {"ID": 1799, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void visitEnd() { // prepare class annotations if (classAnnotations != null) { annotations = classAnnotations.toArray(new AnnotationInfo[0]); classAnnotations = null; } List<String> superList = new ArrayList<>(); Set<String> allInterfaces = new HashSet<>(); if (nextInterfaces != null) { allInterfaces.addAll(nextInterfaces); } // check all public super methods that are not overridden in superclass while (nextSupername != null) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex); } finally { StreamUtil.close(inputStream); } superList.add(nextSupername); superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { Collections.addAll(allInterfaces, cr.getInterfaces()); } } superClasses = superList.toArray(new String[0]); // check all interface methods that are not overridden in super-interface Set<String> todoInterfaces = new HashSet<>(allInterfaces); Set<String> newCollectedInterfaces = new HashSet<>(); while (true) { for (String next : todoInterfaces) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(next, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super interface: \" + next, ioex); } finally { StreamUtil.close(inputStream); } superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { for (String newInterface : cr.getInterfaces()) { if (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) { // new interface found newCollectedInterfaces.add(newInterface); } } } } // perform collection allInterfaces.addAll(todoInterfaces); if (newCollectedInterfaces.isEmpty()) { // no new interface found break; } todoInterfaces.clear(); todoInterfaces.addAll(newCollectedInterfaces); newCollectedInterfaces.clear(); } }\n\n    ### Response:", "ground_truth": "Stores signatures for all super public methods not already overridden by target class.\nAll this methods will be accepted for proxyfication.", "predict": "/**\n     * Visits the end of the class.\n     * <p>\n     * This method is called by the Java Virtual Machine after the last instruction of the class is executed. It can be used to perform any clean-up or resource deallocation operations that are required for the class.\n     */\n    @Override public void visitEnd() { // prepare class annotations if (classAnnotations != null) { annotations = classAnnotations.toArray(new AnnotationInfo[0]); classAnnotations = null; } List<String> superList = new ArrayList<>(); Set<String> allInterfaces = new HashSet<>(); if (nextInterfaces != null) { allInterfaces.addAll(nextInterfaces); } // check all public super methods that are not overridden in superclass while (nextSupername != null) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super class: \""}, {"ID": 1800, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected MethodSignatureVisitor createMethodSignature( final int access, final String methodName, final String description, final String signature, final String[] exceptions, final String classname, final Map<String, String> declaredTypeGenerics) { MethodSignatureVisitor v = new MethodSignatureVisitor(methodName, access, classname, description, exceptions, signature, declaredTypeGenerics, this); new SignatureReader(signature != null ? signature : description).accept(v); return v; }\n\n    ### Response:", "ground_truth": "Creates method signature from method name.", "predict": "/**\r\n     * Creates a new MethodSignatureVisitor object for the given method signature.\r\n     * \r\n     * @param access the access flags of the method\r\n     * @param methodName the name of the method\r\n     * @param description the method descriptor\r\n     * @param signature the method signature (if any)\r\n     * @param exceptions the exceptions thrown by the method (if any)\r\n     * @param classname the name of the class containing the method\r\n     * @param declaredTypeGenerics the declared type generics of the class containing the method\r\n     * @return a new MethodSignatureVisitor object for the given method signature\r\n     */\r\n    protected MethodSignatureVisitor createMethodSignature(final int access, final String methodName, final String description, final String signature, final String[] exceptions, final String classname, final Map<String, String> declaredTypeGenerics) {\r\n        MethodSignatureVisitor v = new MethodSignatureVisitor(methodName, access, classname, description, exceptions, signature, declaredTypeGenerics, this);\r\n        new SignatureReader(signature != null ? signature : description).accept(v"}, {"ID": 1801, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String toCsvString(final Object... elements) { StringBuilder line = new StringBuilder(); int last = elements.length -1; for (int i = 0; i < elements.length; i++) { if (elements[i] == null) { if (i != last) { line.append(FIELD_SEPARATOR); } continue; } String field = elements[i].toString(); // check for special cases int ndx = field.indexOf(FIELD_SEPARATOR); if (ndx == -1) { ndx = field.indexOf(FIELD_QUOTE); } if (ndx == -1) { if (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) { ndx = 1; } } if (ndx == -1) { ndx = StringUtil.indexOfChars(field, SPECIAL_CHARS); } // add field if (ndx != -1) { line.append(FIELD_QUOTE); } field = StringUtil.replace(field, StringPool.QUOTE, DOUBLE_QUOTE); line.append(field); if (ndx != -1) { line.append(FIELD_QUOTE); } // last if (i != last) { line.append(FIELD_SEPARATOR); } } return line.toString(); }\n\n    ### Response:", "ground_truth": "Parse fields as csv string,", "predict": "/**\r\n     * Converts the given array of objects to a CSV string.\r\n     *\r\n     * @param elements the array of objects to convert to CSV\r\n     * @return the CSV string representation of the array of objects\r\n     */\r\n    public static String toCsvString(final Object... elements) {\r\n        StringBuilder line = new StringBuilder();\r\n        int last = elements.length - 1;\r\n        for (int i = 0; i < elements.length; i++) {\r\n            if (elements[i] == null) {\r\n                if (i != last) {\r\n                    line.append(FIELD_SEPARATOR);\r\n                }\r\n                continue;\r\n            }\r\n            String field = elements[i].toString();\r\n            // check for special cases\r\n            int ndx = field.indexOf(FIELD_SEPARATOR);\r\n            if (ndx == -1) {\r\n                ndx = field.indexOf(FIELD_QUOTE);\r\n            }\r\n            if (ndx == -1) {\r\n                if (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) {\r\n                   "}, {"ID": 1802, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String[] toStringArray(final String line) { List<String> row = new ArrayList<>(); boolean inQuotedField = false; int fieldStart = 0; final int len = line.length(); for (int i = 0; i < len; i++) { char c = line.charAt(i); if (c == FIELD_SEPARATOR) { if (!inQuotedField) { // ignore we are quoting addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 1; } } else if (c == FIELD_QUOTE) { if (inQuotedField) { if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) { // we are already quoting - peek to see if this is the end of the field addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 2; i++; // and skip the comma inQuotedField = false; } } else if (fieldStart == i) { inQuotedField = true; // this is a beginning of a quote fieldStart++; // move field start } } } // add last field - but only if string was not empty if (len > 0 && fieldStart <= len) { addField(row, line, fieldStart, len, inQuotedField); } return row.toArray(new String[0]); }\n\n    ### Response:", "ground_truth": "Converts CSV line to string array.", "predict": "/**\r\n     * Converts a CSV line into an array of strings.\r\n     *\r\n     * @param line the CSV line to convert\r\n     * @return an array of strings representing the fields in the CSV line\r\n     */\r\n    public static String[] toStringArray(final String line) {\r\n        List<String> row = new ArrayList<>();\r\n        boolean inQuotedField = false;\r\n        int fieldStart = 0;\r\n        final int len = line.length();\r\n        for (int i = 0; i < len; i++) {\r\n            char c = line.charAt(i);\r\n            if (c == FIELD_SEPARATOR) {\r\n                if (!inQuotedField) {\r\n                    // ignore we are quoting\r\n                    addField(row, line, fieldStart, i, inQuotedField);\r\n                    fieldStart = i + 1;\r\n                }\r\n            } else if (c == FIELD_QUOTE) {\r\n                if (inQuotedField) {\r\n                    if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) {\r\n                        //"}, {"ID": 1803, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor); if (ctorReferences == null) { continue; } if (foundedCtor != null) { throw new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName()); } foundedCtor = ctor; references = ctorReferences; } if (foundedCtor == null) { // there is no annotated constructor if (allCtors.length == 1) { foundedCtor = allCtors[0].getConstructor(); } else { foundedCtor = defaultCtor; } if (foundedCtor == null) { // no matching ctor found // still this is not an error if bean is already instantiated. return CtorInjectionPoint.EMPTY; } references = referencesResolver.readAllReferencesFromAnnotation(foundedCtor); if (references == null) { references = new BeanReferences[0]; } } return new CtorInjectionPoint(foundedCtor, references); }\n\n    ### Response:", "ground_truth": "Resolves constructor injection point from type. Looks for single annotated constructor.\nIf no annotated constructors found, the total number of constructors will be checked.\nIf there is only one constructor, that one will be used as injection point. If more\nconstructors exist, the default one will be used as injection point. Otherwise, exception\nis thrown.", "predict": "/**\n     * Resolves the constructor injection point for the given type.\n     *\n     * @param type the type for which to resolve the constructor injection point.\n     * @param useAnnotation whether to use the annotation to resolve the constructor injection point.\n     * @return the constructor injection point for the given type.\n     */\n    public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor"}, {"ID": 1804, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) { InputStream inputStream = null; try { inputStream = ClassLoaderUtil.getClassAsStream(advice); return new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(ioex); } finally { StreamUtil.close(inputStream); } }\n\n    ### Response:", "ground_truth": "Creates advice's class reader.", "predict": "/**\r\n     * Creates a new {@link ClassReader} for the given advice class.\r\n     * \r\n     * @param advice the advice class to create a reader for\r\n     * @return a new {@link ClassReader} for the given advice class\r\n     * @throws ProxettaException if an I/O error occurs while reading the class\r\n     */\r\n    private ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) {\r\n        InputStream inputStream = null;\r\n        try {\r\n            inputStream = ClassLoaderUtil.getClassAsStream(advice);\r\n            return new ClassReader(inputStream);\r\n        } catch (IOException ioex) {\r\n            throw new ProxettaException(ioex);\r\n        } finally {\r\n            StreamUtil.close(inputStream);\r\n        }\r\n    }"}, {"ID": 1805, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) { if (adviceClassReaderCache == null) { adviceClassReaderCache = TypeCache.createDefault(); } ClassReader adviceReader = adviceClassReaderCache.get(advice); if (adviceReader == null) { adviceReader = createAdviceClassReader(advice); adviceClassReaderCache.put(advice, adviceReader); } return adviceReader; }\n\n    ### Response:", "ground_truth": "Returns class reader for advice.", "predict": "/**\r\n     * Returns a cached {@link ClassReader} for the given advice class.\r\n     *\r\n     * @param advice the advice class\r\n     * @return a cached {@link ClassReader} for the given advice class\r\n     */\r\n    private ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) {\r\n        // TODO: implement method\r\n    }"}, {"ID": 1806, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String encrypt(final String str) { try { byte[] utf8 = StringUtil.getBytes(str); // encode the string into bytes using utf-8 byte[] enc = ecipher.doFinal(utf8); // encrypt return Base64.encodeToString(enc); // encode bytes to base64 to get a string } catch (Throwable ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Symmetrically encrypts the string.", "predict": "/**\r\n     * Encrypts the given string using the AES encryption algorithm.\r\n     *\r\n     * @param str the string to be encrypted\r\n     * @return the encrypted string in Base64 format\r\n     */\r\n    public String encrypt(final String str) {\r\n        try {\r\n            byte[] utf8 = StringUtil.getBytes(str); // encode the string into bytes using utf-8\r\n            byte[] enc = ecipher.doFinal(utf8); // encrypt\r\n            return Base64.encodeToString(enc); // encode bytes to base64 to get a string\r\n        } catch (Throwable ignore) {\r\n            return null;\r\n        }\r\n    }"}, {"ID": 1807, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String decrypt(String str) { try { str = StringUtil.replaceChar(str, ' ', '+'); // replace spaces with chars. byte[] dec = Base64.decode(str); // decode base64 to get bytes byte[] utf8 = dcipher.doFinal(dec); // decrypt return new String(utf8, UTF_8); // decode using utf-8 } catch (Throwable ignore) { return null; } }\n\n    ### Response:", "ground_truth": "Symmetrically decrypts the string.", "predict": "/**\r\n     * Decrypts a string using the AES encryption algorithm.\r\n     *\r\n     * @param str the string to decrypt\r\n     * @return the decrypted string or null if an error occurred\r\n     */\r\n    public String decrypt(String str) {\r\n        try {\r\n            str = StringUtil.replaceChar(str, ' ', '+'); // replace spaces with chars\r\n            byte[] dec = Base64.decode(str); // decode base64 to get bytes\r\n            byte[] utf8 = dcipher.doFinal(dec); // decrypt\r\n            return new String(utf8, UTF_8); // decode using utf-8\r\n        } catch (Throwable ignore) {\r\n            return null;\r\n        }\r\n    }"}, {"ID": 1808, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Logger getLogger(final String name) { if (loggers == null) { return loggerProvider.apply(name); } return loggers.computeIfAbsent(name, loggerProvider); }\n\n    ### Response:", "ground_truth": "Returns logger for given name. Repeated calls to this method with the\nsame argument should return the very same instance of the logger.", "predict": "/**\r\n * Returns a logger with the specified name.\r\n *\r\n * @param name the name of the logger.\r\n * @return a logger with the specified name.\r\n */\r\npublic static Logger getLogger(final String name) {\r\n    if (loggers == null) {\r\n        return loggerProvider.apply(name);\r\n    }\r\n    return loggers.computeIfAbsent(name, loggerProvider);\r\n}"}, {"ID": 1809, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void setName(final String name) { if (name.contains(\";\") || name.contains(\",\") || name.startsWith(\"$\")) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } for (int n = 0; n < name.length(); n++) { char c = name.charAt(n); if (c <= 0x20 || c >= 0x7f) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } } this.name = name; }\n\n    ### Response:", "ground_truth": "Sets the cookie name and checks for validity.", "predict": "/**\r\n     * Sets the name of the cookie.\r\n     * \r\n     * @param name the name of the cookie\r\n     * @throws IllegalArgumentException if the name is invalid\r\n     */\r\n    private void setName(final String name) {\r\n        if (name.contains(\";\") || name.contains(\",\") || name.startsWith(\"$\")) {\r\n            throw new IllegalArgumentException(\"Invalid cookie name:\" + name);\r\n        }\r\n        for (int n = 0; n < name.length(); n++) {\r\n            char c = name.charAt(n);\r\n            if (c <= 0x20 || c >= 0x7f) {\r\n                throw new IllegalArgumentException(\"Invalid cookie name:\" + name);\r\n            }\r\n        }\r\n        this.name = name;\r\n    }"}, {"ID": 1810, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected ActionRequest createActionRequest( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionRequest(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); }\n\n    ### Response:", "ground_truth": "", "predict": "/**\r\n     * Creates a new ActionRequest object.\r\n     * \r\n     * @param actionPath the action path\r\n     * @param actionPathChunks the action path chunks\r\n     * @param actionRuntime the action runtime\r\n     * @param action the action object\r\n     * @param servletRequest the servlet request\r\n     * @param servletResponse the servlet response\r\n     * @return the new ActionRequest object\r\n     */\r\n    protected ActionRequest createActionRequest( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionRequest(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); }"}, {"ID": 1811, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); }\n\n    ### Response:", "ground_truth": "Acquires filter from Petite container.", "predict": "/**\r\n     * Creates a wrapper for the given action filter class.\r\n     *\r\n     * @param wrapperClass the action filter class to wrap\r\n     * @param <R> the type of the action filter wrapper\r\n     * @return the created action filter wrapper\r\n     */\r\n    @Override\r\n    protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) {\r\n        return petiteContainer.createBean(wrapperClass);\r\n    }"}, {"ID": 1812, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    protected void destroyBean(final BeanData beanData) { if (destroyableBeans == null) { return; } if (!isBeanDestroyable(beanData)) { return; } if (destroyableBeans.remove(beanData)) { beanData.callDestroyMethods(); } }\n\n    ### Response:", "ground_truth": "Removes destroyable bean from the list and calls it destroy methods.\nIf bean is not destroyable, does nothing. Bean gets destroyed only once.", "predict": "/**\r\n     * Destroys the specified bean.\r\n     *\r\n     * @param beanData the bean data to destroy\r\n     */\r\n    protected void destroyBean(final BeanData beanData) {\r\n        if (destroyableBeans == null) {\r\n            return;\r\n        }\r\n        if (!isBeanDestroyable(beanData)) {\r\n            return;\r\n        }\r\n        if (destroyableBeans.remove(beanData)) {\r\n            beanData.callDestroyMethods();\r\n        }\r\n    }"}, {"ID": 1813, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void shutdown() { if (destroyableBeans == null) { return; } for (final BeanData destroyableBean : destroyableBeans) { destroyableBean.callDestroyMethods(); } destroyableBeans.clear(); }\n\n    ### Response:", "ground_truth": "Shutdowns the scope and calls all collected destroyable beans.", "predict": "/**\r\n     * This method is called by the container to shut down the application.\r\n     * It calls the destroy methods of all beans that have been registered for destruction.\r\n     * After that, it clears the list of destroyable beans.\r\n     */\r\n    @Override public void shutdown() {\r\n        if (destroyableBeans == null) {\r\n            return;\r\n        }\r\n        for (final BeanData destroyableBean : destroyableBeans) {\r\n            destroyableBean.callDestroyMethods();\r\n        }\r\n        destroyableBeans.clear();\r\n    }"}, {"ID": 1814, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ReceivedEmail[] get() { if (fromFolder != null) { session.useFolder(fromFolder); } return session.receiveMessages(filter, flagsToSet, flagsToUnset, envelopeOnly, messages -> { if (targetFolder != null) { try { session.folder.copyMessages(messages, session.getFolder(targetFolder)); } catch (MessagingException e) { throw new MailException(\"Copying messages failed\"); } } }); }\n\n    ### Response:", "ground_truth": "Receives the emails as specified by the builder.", "predict": "/**\r\n     * Retrieves the emails from the specified folder that match the specified filter, sets the specified flags on the retrieved emails, and optionally copies the retrieved emails to a target folder.\r\n     * \r\n     * @param fromFolder the folder to retrieve emails from\r\n     * @param filter the filter to apply to the emails\r\n     * @param flagsToSet the flags to set on the retrieved emails\r\n     * @param flagsToUnset the flags to unset on the retrieved emails\r\n     * @param envelopeOnly whether to retrieve only the email envelope or the entire email message\r\n     * @param targetFolder the folder to copy the retrieved emails to, or null to not copy them\r\n     * @return an array of the retrieved emails\r\n     * @throws MailException if an error occurs while retrieving or copying emails\r\n     */\r\n    public ReceivedEmail[] get(Folder fromFolder, MessageFilter filter, Flags flagsToSet, Flags flagsToUnset, boolean envelopeOnly, String targetFolder) throws MailException {\r\n        if (fromFolder != null) {\r\n            session.useFolder(fromFolder);\r\n        }\r\n       "}, {"ID": 1815, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) { loadPropertiesFiles(args); try (ClusteredServiceContainer container = launch()) { container.context().shutdownSignalBarrier().await(); System.out.println(\"Shutdown ClusteredServiceContainer...\"); } }\n\n    ### Response:", "ground_truth": "Launch the clustered service container and await a shutdown signal.\n\n@param args command line argument which is a list for properties files as URLs or filenames.", "predict": "/**\r\n * This method is the entry point for the application.\r\n * \r\n * @param args\r\n *            command line arguments\r\n */\r\npublic static void main(final String[] args) {\r\n    loadPropertiesFiles(args);\r\n    try (ClusteredServiceContainer container = launch()) {\r\n        container.context().shutdownSignalBarrier().await();\r\n        System.out.println(\"Shutdown ClusteredServiceContainer...\");\r\n    }\r\n}"}, {"ID": 1816, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void run() { do { LockSupport.parkNanos(parkNs); final long currentTotalMessages = totalMessages; final long currentTotalBytes = totalBytes; final long currentTimestamp = System.nanoTime(); final long timeSpanNs = currentTimestamp - lastTimestamp; final double messagesPerSec = ((currentTotalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs; final double bytesPerSec = ((currentTotalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs; reportingFunc.onReport(messagesPerSec, bytesPerSec, currentTotalMessages, currentTotalBytes); lastTotalBytes = currentTotalBytes; lastTotalMessages = currentTotalMessages; lastTimestamp = currentTimestamp; } while (!halt); }\n\n    ### Response:", "ground_truth": "Run loop for the rate reporter", "predict": "/**\r\n     * Runs the thread.\r\n     */\r\n    public void run() {\r\n        do {\r\n            LockSupport.parkNanos(parkNs);\r\n            final long currentTotalMessages = totalMessages;\r\n            final long currentTotalBytes = totalBytes;\r\n            final long currentTimestamp = System.nanoTime();\r\n            final long timeSpanNs = currentTimestamp - lastTimestamp;\r\n            final double messagesPerSec = ((currentTotalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs;\r\n            final double bytesPerSec = ((currentTotalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs;\r\n            reportingFunc.onReport(messagesPerSec, bytesPerSec, currentTotalMessages, currentTotalBytes);\r\n            lastTotalBytes = currentTotalBytes;\r\n            lastTotalMessages = currentTotalMessages;\r\n            lastTimestamp = currentTimestamp;\r\n        } while (!halt);\r\n    }"}, {"ID": 1817, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); }\n\n    ### Response:", "ground_truth": "Generic error handler that just prints message to stdout.\n\n@param channel   for the error\n@param streamId  for the error\n@param sessionId for the error, if source\n@param message   indicating what the error was\n@param cause     of the error", "predict": "/**\r\n     * Prints the error message to the console.\r\n     * \r\n     * @param channel the channel name\r\n     * @param streamId the stream id\r\n     * @param sessionId the session id\r\n     * @param message the error message\r\n     * @param cause the cause of the error\r\n     */\r\n    @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); }"}, {"ID": 1818, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); }\n\n    ### Response:", "ground_truth": "Print the rates to stdout\n\n@param messagesPerSec being reported\n@param bytesPerSec    being reported\n@param totalMessages  being reported\n@param totalBytes     being reported", "predict": "/**\r\n     * Prints the rate of messages and payload bytes per second.\r\n     * \r\n     * @param messagesPerSec the number of messages per second\r\n     * @param bytesPerSec the number of payload bytes per second\r\n     * @param totalMessages the total number of messages\r\n     * @param totalBytes the total number of payload bytes\r\n     */\r\n    public static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); }"}, {"ID": 1819, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MappedByteBuffer mapExistingFileReadOnly(final File location) { if (!location.exists()) { final String msg = \"file not found: \" + location.getAbsolutePath(); throw new IllegalStateException(msg); } MappedByteBuffer mappedByteBuffer = null; try (RandomAccessFile file = new RandomAccessFile(location, \"r\"); FileChannel channel = file.getChannel()) { mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size()); } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } return mappedByteBuffer; }\n\n    ### Response:", "ground_truth": "Map an existing file as a read only buffer.\n\n@param location of file to map.\n@return the mapped file.", "predict": "/**\r\n     * Maps an existing file in read-only mode using memory-mapped I/O.\r\n     *\r\n     * @param location the file to map\r\n     * @return a memory-mapped byte buffer representing the contents of the file\r\n     * @throws IllegalStateException if the file does not exist\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public static MappedByteBuffer mapExistingFileReadOnly(final File location) throws IOException {\r\n        if (!location.exists()) {\r\n            final String msg = \"file not found: \" + location.getAbsolutePath();\r\n            throw new IllegalStateException(msg);\r\n        }\r\n\r\n        MappedByteBuffer mappedByteBuffer = null;\r\n        try (RandomAccessFile file = new RandomAccessFile(location, \"r\");\r\n             FileChannel channel = file.getChannel()) {\r\n            mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size());\r\n        }\r\n\r\n        return mappedByteBuffer;\r\n    }"}, {"ID": 1820, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { final State state = this.state; if (State.CLOSED != state) { if (isReplayActive) { isReplayActive = false; archive.stopReplay(replaySessionId); } if (State.MERGED != state) { subscription.removeDestination(replayDestination); } state(State.CLOSED); } }\n\n    ### Response:", "ground_truth": "Close the merge and stop any active replay. Will remove the replay destination from the subscription. Will\nNOT remove the live destination if it has been added.", "predict": "/**\r\n     * Closes the subscription.\r\n     *\r\n     * @throws JMSException if an error occurs while closing the subscription\r\n     */\r\n    public void close() throws JMSException {\r\n        final State state = this.state;\r\n        if (State.CLOSED != state) {\r\n            if (isReplayActive) {\r\n                isReplayActive = false;\r\n                archive.stopReplay(replaySessionId);\r\n            }\r\n            if (State.MERGED != state) {\r\n                subscription.removeDestination(replayDestination);\r\n            }\r\n            state(State.CLOSED);\r\n        }\r\n    }"}, {"ID": 1821, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int doWork() { int workCount = 0; switch (state) { case AWAIT_INITIAL_RECORDING_POSITION: workCount += awaitInitialRecordingPosition(); break; case AWAIT_REPLAY: workCount += awaitReplay(); break; case AWAIT_CATCH_UP: workCount += awaitCatchUp(); break; case AWAIT_CURRENT_RECORDING_POSITION: workCount += awaitUpdatedRecordingPosition(); break; case AWAIT_STOP_REPLAY: workCount += awaitStopReplay(); break; } return workCount; }\n\n    ### Response:", "ground_truth": "Process the operation of the merge. Do not call the processing of fragments on the subscription.\n\n@return indication of work done processing the merge.", "predict": "/**\r\n     * This method performs the necessary actions to complete the current state of the recorder.\r\n     * \r\n     * @return the number of work units completed during this state transition.\r\n     */\r\n    public int doWork() {\r\n        int workCount = 0;\r\n        switch (state) {\r\n            case AWAIT_INITIAL_RECORDING_POSITION:\r\n                workCount += awaitInitialRecordingPosition();\r\n                break;\r\n            case AWAIT_REPLAY:\r\n                workCount += awaitReplay();\r\n                break;\r\n            case AWAIT_CATCH_UP:\r\n                workCount += awaitCatchUp();\r\n                break;\r\n            case AWAIT_CURRENT_RECORDING_POSITION:\r\n                workCount += awaitUpdatedRecordingPosition();\r\n                break;\r\n            case AWAIT_STOP_REPLAY:\r\n                workCount += awaitStopReplay();\r\n                break;\r\n        }\r\n        return workCount;\r\n    }"}, {"ID": 1822, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long position() { if (isClosed) { return CLOSED; } final long rawTail = rawTailVolatile(logMetaDataBuffer); final int termOffset = termOffset(rawTail, termBufferLength); return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId); }\n\n    ### Response:", "ground_truth": "Get the current position to which the publication has advanced for this stream.\n\n@return the current position to which the publication has advanced for this stream or {@link #CLOSED}.", "predict": "/**\r\n     * Returns the current position of the log file.\r\n     *\r\n     * @return the current position of the log file\r\n     */\r\n    public long position() {\r\n        if (isClosed) {\r\n            return CLOSED;\r\n        }\r\n        final long rawTail = rawTailVolatile(logMetaDataBuffer);\r\n        final int termOffset = termOffset(rawTail, termBufferLength);\r\n        return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId);\r\n    }"}, {"ID": 1823, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) { final int length = DirectBufferVector.validateAndComputeLength(vectors); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { final int result; if (length <= maxPayloadLength) { result = termAppender.appendUnfragmentedMessage( termId, termOffset, headerWriter, vectors, length, reservedValueSupplier); } else { checkMaxMessageLength(length); result = termAppender.appendFragmentedMessage( termId, termOffset, headerWriter, vectors, length, maxPayloadLength, reservedValueSupplier); } newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; }\n\n    ### Response:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message.\n\n@param vectors               which make up the message.\n@param reservedValueSupplier {@link ReservedValueSupplier} for the frame.\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.", "predict": "/**\n     * Offers a message to the term buffer.\n     *\n     * @param vectors the vectors to be appended to the message.\n     * @param reservedValueSupplier the supplier of reserved values for the message.\n     * @return the new position in the term after appending the message.\n     */\n    public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) {\n        final int length = DirectBufferVector.validateAndComputeLength(vectors);\n        long newPosition = CLOSED;\n        if (!isClosed) {\n            final long limit = positionLimit.getVolatile();\n            final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex];\n            final long position = termBeginPosition + termOffset;\n            if (position < limit) {\n                final int result;\n                if (length <= maxPayloadLength) {\n                    result = termAppender.appendUnfragmentedMessage(termId, termOffset, headerWriter, vectors, length, reservedValueSupplier);\n                } else {\n                    checkMaxMessageLength("}, {"ID": 1824, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long appendPadding(final int length) { checkMaxMessageLength(length); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { checkPositiveLength(length); final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length); newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; }\n\n    ### Response:", "ground_truth": "Append a padding record log of a given length to make up the log to a position.\n\n@param length of the range to claim, in bytes..\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.\n@throws IllegalArgumentException if the length is greater than {@link #maxMessageLength()}.", "predict": "/**\n     * Appends padding to the current term and returns the new position.\n     *\n     * @param length The length of the padding to append.\n     * @return The new position after appending the padding.\n     * @throws IllegalStateException If the term is closed.\n     * @throws IllegalArgumentException If the length is not positive.\n     * @throws IllegalArgumentException If the length is greater than the maximum message length.\n     */\n    public long appendPadding(final int length) {\n        checkMaxMessageLength(length);\n        long newPosition = CLOSED;\n        if (!isClosed) {\n            final long limit = positionLimit.getVolatile();\n            final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex];\n            final long position = termBeginPosition + termOffset;\n            if (position < limit) {\n                checkPositiveLength(length);\n                final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length);\n                newPosition = newPosition(result);\n            } else {\n                newPosition = backPressureStatus"}, {"ID": 1825, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { lock.lock(); try { if (!isClosed) { isClosed = true; archiveProxy.closeSession(controlSessionId); if (!context.ownsAeronClient()) { CloseHelper.close(controlResponsePoller.subscription()); CloseHelper.close(archiveProxy.publication()); } context.close(); } } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Notify the archive that this control session is closed so it can promptly release resources then close the\nlocal resources associated with the client.", "predict": "/**\r\n     * Closes the session and releases any resources associated with it.\r\n     *\r\n     * @throws Exception if an error occurs while closing the session.\r\n     */\r\n    public void close() throws Exception {\r\n        lock.lock();\r\n        try {\r\n            if (!isClosed) {\r\n                isClosed = true;\r\n                archiveProxy.closeSession(controlSessionId);\r\n                if (!context.ownsAeronClient()) {\r\n                    CloseHelper.close(controlResponsePoller.subscription());\r\n                    CloseHelper.close(archiveProxy.publication());\r\n                }\r\n                context.close();\r\n            }\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }"}, {"ID": 1826, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String pollForErrorResponse() { lock.lock(); try { ensureOpen(); if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) { if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) { return controlResponsePoller.errorMessage(); } } return null; } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Poll the response stream once for an error. If another message is present then it will be skipped over\nso only call when not expecting another response.\n\n@return the error String otherwise null if no error is found.", "predict": "/**\r\n     * Polls the control response poller for an error response.\r\n     * \r\n     * @return the error message if an error response is received, null otherwise.\r\n     */\r\n    public String pollForErrorResponse() {\r\n        lock.lock();\r\n        try {\r\n            ensureOpen();\r\n            if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) {\r\n                if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) {\r\n                    return controlResponsePoller.errorMessage();\r\n                }\r\n            }\r\n            return null;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }"}, {"ID": 1827, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void stopReplay(final long replaySessionId) { lock.lock(); try { ensureOpen(); final long correlationId = aeron.nextCorrelationId(); if (!archiveProxy.stopReplay(replaySessionId, correlationId, controlSessionId)) { throw new ArchiveException(\"failed to send stop replay request\"); } pollForResponse(correlationId); } finally { lock.unlock(); } }\n\n    ### Response:", "ground_truth": "Stop a replay session.\n\n@param replaySessionId to stop replay for.", "predict": "/**\r\n     * Stop a replay session on the archive.\r\n     *\r\n     * @param replaySessionId to stop.\r\n     * @throws ArchiveException if the request fails.\r\n     */\r\n    public void stopReplay(final long replaySessionId) throws ArchiveException {\r\n        lock.lock();\r\n        try {\r\n            ensureOpen();\r\n            final long correlationId = aeron.nextCorrelationId();\r\n            if (!archiveProxy.stopReplay(replaySessionId, correlationId, controlSessionId)) {\r\n                throw new ArchiveException(\"failed to send stop replay request\");\r\n            }\r\n            pollForResponse(correlationId);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }"}, {"ID": 1828, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void eventAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"new image on %s streamId %x sessionId %x from %s%n\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity()); }\n\n    ### Response:", "ground_truth": "Print the information for an available image to stdout.\n\n@param image that has been created", "predict": "/**\r\n     * This method is called when a new image is available on a subscription.\r\n     * \r\n     * @param image the new image that is available\r\n     */\r\n    public static void eventAvailableImage(final Image image) {\r\n        final Subscription subscription = image.subscription();\r\n        System.out.format(\r\n                \"new image on %s streamId %x sessionId %x from %s%n\",\r\n                subscription.channel(),\r\n                subscription.streamId(),\r\n                image.sessionId(),\r\n                image.sourceIdentity());\r\n    }"}, {"ID": 1829, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void eventUnavailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"inactive image on %s streamId %d sessionId %x%n\", subscription.channel(), subscription.streamId(), image.sessionId()); }\n\n    ### Response:", "ground_truth": "This handler is called when image is unavailable\n\n@param image that has gone inactive", "predict": "/**\r\n     * This method is used to log an event when an image is received on an inactive subscription.\r\n     *\r\n     * @param image The image that was received on an inactive subscription.\r\n     */\r\n    public static void eventUnavailableImage(final Image image) {\r\n        final Subscription subscription = image.subscription();\r\n        System.out.format(\r\n                \"inactive image on %s streamId %d sessionId %x%n\",\r\n                subscription.channel(),\r\n                subscription.streamId(),\r\n                image.sessionId()\r\n        );\r\n    }"}, {"ID": 1830, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == SendChannelStatus.SEND_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; }\n\n    ### Response:", "ground_truth": "Return the read-only status indicator for the given send channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the send channel.\n@return read-only status indicator that can be used to query the status of the send channel or null\n@see ChannelEndpointStatus for status values and indications.", "predict": "/**\r\n     * Sends a request to the media driver to retrieve the status of a channel.\r\n     *\r\n     * @param countersReader to read the counters from the media driver.\r\n     * @param channel        to identify the channel for which the status is requested.\r\n     * @return a reader for the status of the channel or null if the channel is not found.\r\n     */\r\n    public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) {\r\n        StatusIndicatorReader statusReader = null;\r\n        final MutableInteger id = new MutableInteger(-1);\r\n        countersReader.forEach( (counterId, typeId, keyBuffer, label) -> {\r\n            if (typeId == SendChannelStatus.SEND_CHANNEL_STATUS_TYPE_ID) {\r\n                if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) {\r\n                    id.value = counterId;\r\n                }\r\n            }\r\n        });\r\n        if (Aeron.NULL_VALUE != id.value) {\r\n            statusReader = new Unsafe"}, {"ID": 1831, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static StatusIndicatorReader receiveChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; }\n\n    ### Response:", "ground_truth": "Return the read-only status indicator for the given receive channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the receive channel.\n@return read-only status indicator that can be used to query the status of the receive channel or null.\n@see ChannelEndpointStatus for status values and indications.", "predict": "/**\r\n     * Receives the status of a channel from the counters reader.\r\n     *\r\n     * @param countersReader  the counters reader to poll for the channel status.\r\n     * @param channel         the channel to poll for the status.\r\n     * @return the status reader for the channel or null if the channel is not found.\r\n     */\r\n    public static StatusIndicatorReader receiveChannelStatus(final CountersReader countersReader, final String channel) {\r\n        StatusIndicatorReader statusReader = null;\r\n        final MutableInteger id = new MutableInteger(-1);\r\n        countersReader.forEach( (counterId, typeId, keyBuffer, label) -> {\r\n            if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) {\r\n                if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) {\r\n                    id.value = counterId;\r\n                }\r\n            }\r\n        });\r\n        if (Aeron.NULL_VALUE != id.value) {\r\n            statusReader = new UnsafeBufferStatusIndicator(counters"}, {"ID": 1832, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void limit(final int limit) { if (limit < 0 || limit >= buffer.capacity()) { throw new IllegalArgumentException( \"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit); } this.limit = limit; }\n\n    ### Response:", "ground_truth": "Set this limit for this buffer as the position at which the next append operation will occur.\n\n@param limit to be the new value.", "predict": "/**\r\n     * Sets the limit of this buffer, which is the number of elements that can be read from or written to the buffer.\r\n     * If the limit is greater than the current capacity of the buffer, then an IllegalArgumentException is thrown.\r\n     * \r\n     * @param limit the new limit\r\n     * @throws IllegalArgumentException if the new limit is negative or greater than the buffer's capacity\r\n     */\r\n    public void limit(final int limit) {\r\n        if (limit < 0 || limit >= buffer.capacity()) {\r\n            throw new IllegalArgumentException(\"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit);\r\n        }\r\n        this.limit = limit;\r\n    }"}, {"ID": 1833, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; }\n\n    ### Response:", "ground_truth": "Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage.", "predict": "/**\n     * Appends the contents of the given buffer to the end of this buffer.\n     *\n     * @param srcBuffer the buffer to append.\n     * @param srcOffset the offset in the source buffer to start copying from.\n     * @param length    the number of bytes to copy.\n     * @return this buffer.\n     * @throws IndexOutOfBoundsException if the specified {@code srcOffset} is negative, or {@code length} is negative, or {@code srcOffset + length} is greater than the {@code srcBuffer}'s capacity.\n     */\n    public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) {\n        ensureCapacity(length);\n        buffer.putBytes(limit, srcBuffer, srcOffset, length);\n        limit += length;\n        return this;\n    }"}, {"ID": 1834, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int poll() { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = null; pollComplete = false; return subscription.controlledPoll(fragmentAssembler, fragmentLimit); }\n\n    ### Response:", "ground_truth": "Poll for control response events.\n\n@return the number of fragments read during the operation. Zero if no events are available.", "predict": "/**\r\n     * Polls the subscription for new messages.\r\n     * \r\n     * @return the number of messages polled\r\n     */\r\n    public int poll() {\r\n        controlSessionId = -1;\r\n        correlationId = -1;\r\n        relevantId = -1;\r\n        templateId = -1;\r\n        errorMessage = null;\r\n        pollComplete = false;\r\n        return subscription.controlledPoll(fragmentAssembler, fragmentLimit);\r\n    }"}, {"ID": 1835, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static MappedByteBuffer mapLossReport(final String aeronDirectoryName, final int reportFileLength) { return mapNewFile(file(aeronDirectoryName), reportFileLength, false); }\n\n    ### Response:", "ground_truth": "Map a new loss report in the Aeron directory for a given length.\n\n@param aeronDirectoryName in which to create the file.\n@param reportFileLength   for the file.\n@return the newly mapped buffer for the file.", "predict": "/**\n     * Maps the loss report file for the given Aeron directory name and report file length.\n     *\n     * @param aeronDirectoryName the Aeron directory name\n     * @param reportFileLength the length of the loss report file\n     * @return the mapped byte buffer for the loss report file\n     */\n    public static MappedByteBuffer mapLossReport(final String aeronDirectoryName, final int reportFileLength) {\n        return mapNewFile(file(aeronDirectoryName), reportFileLength, false);\n    }"}, {"ID": 1836, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<StreamCompositeKey, List<StreamPosition>> snapshot() { final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamPosition position = new StreamPosition( keyBuffer.getLong(REGISTRATION_ID_OFFSET), counters.getCounterValue(counterId), typeId); streams .computeIfAbsent(key, (ignore) -> new ArrayList<>()) .add(position); } }); return streams; }\n\n    ### Response:", "ground_truth": "Take a snapshot of all the counters and group them by streams.\n\n@return a snapshot of all the counters and group them by streams.", "predict": "/**\r\n     * This method is used to create a snapshot of the current state of the counters.\r\n     *\r\n     * @return A map of stream composite keys and their corresponding list of stream positions.\r\n     */\r\n    public Map<StreamCompositeKey, List<StreamPosition>> snapshot() {\r\n        final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap<>();\r\n        counters.forEach( (counterId, typeId, keyBuffer, label) -> {\r\n            if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) {\r\n                final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET));\r\n                final StreamPosition position = new"}, {"ID": 1837, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) { final UnsafeBuffer buffer = new UnsafeBuffer( BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH)); buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION); buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS); buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN); buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN); buffer.putInt(STREAM_ID_FIELD_OFFSET, streamId, LITTLE_ENDIAN); buffer.putInt(TERM_ID_FIELD_OFFSET, termId, LITTLE_ENDIAN); buffer.putLong(RESERVED_VALUE_OFFSET, DEFAULT_RESERVE_VALUE); return buffer; }\n\n    ### Response:", "ground_truth": "Return an initialised default Data Frame Header.\n\n@param sessionId for the header\n@param streamId  for the header\n@param termId    for the header\n@return byte array containing the header", "predict": "/**\n     * Creates a default header buffer for a data frame.\n     *\n     * @param sessionId the session id for the data frame.\n     * @param streamId the stream id for the data frame.\n     * @param termId the term id for the data frame.\n     * @return the default header buffer for a data frame.\n     */\n    public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) {\n        final UnsafeBuffer buffer = new UnsafeBuffer(BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH));\n        buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION);\n        buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS);\n        buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN);\n        buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN);\n        buffer.putInt("}, {"ID": 1838, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) { buffer.putInt(KEY_LENGTH_OFFSET, keyLength); if (null != keyBuffer && keyLength > 0) { buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength); } return this; }\n\n    ### Response:", "ground_truth": "Fill the key buffer.\n\n@param keyBuffer containing the optional key for the counter.\n@param keyOffset within the keyBuffer at which the key begins.\n@param keyLength of the key in the keyBuffer.\n@return flyweight", "predict": "/**\n     * Sets the key buffer and its offset and length in the message flyweight.\n     *\n     * @param keyBuffer the key buffer to set\n     * @param keyOffset the offset in the key buffer to start copying from\n     * @param keyLength the length of the key to copy\n     * @return the updated flyweight object\n     */\n    public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) {\n        buffer.putInt(KEY_LENGTH_OFFSET, keyLength);\n        if (null != keyBuffer && keyLength > 0) {\n            buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength);\n        }\n        return this;\n    }"}, {"ID": 1839, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public CounterMessageFlyweight labelBuffer( final DirectBuffer labelBuffer, final int labelOffset, final int labelLength) { buffer.putInt(labelOffset(), labelLength); buffer.putBytes(labelBufferOffset(), labelBuffer, labelOffset, labelLength); return this; }\n\n    ### Response:", "ground_truth": "Fill the label buffer.\n\n@param labelBuffer containing the mandatory label for the counter.\n@param labelOffset within the labelBuffer at which the label begins.\n@param labelLength of the label in the labelBuffer.\n@return flyweight", "predict": "/**\n     * Sets the label buffer and its offset and length in the message flyweight.\n     *\n     * @param labelBuffer the buffer containing the label\n     * @param labelOffset the offset in the buffer where the label starts\n     * @param labelLength the length of the label in bytes\n     * @return this flyweight object\n     */\n    public CounterMessageFlyweight labelBuffer(final DirectBuffer labelBuffer, final int labelOffset, final int labelLength) {\n        buffer.putInt(labelOffset(), labelLength);\n        buffer.putBytes(labelBufferOffset(), labelBuffer, labelOffset, labelLength);\n        return this;\n    }"}, {"ID": 1840, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); return offerWithTimeout(connectRequestEncoder.encodedLength(), null); }\n\n    ### Response:", "ground_truth": "Connect to an archive on its control interface providing the response stream details.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Connect to the archive and request a session id.\r\n     *\r\n     * @param responseChannel  the channel to send the response on.\r\n     * @param responseStreamId the stream id to send the response on.\r\n     * @param correlationId    the correlation id to use for the request.\r\n     * @return true if the message was successfully sent.\r\n     */\r\n    public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) {\r\n        connectRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .correlationId(correlationId)\r\n                .responseStreamId(responseStreamId)\r\n                .version(AeronArchive.Configuration.SEMANTIC_VERSION)\r\n                .responseChannel(responseChannel);\r\n\r\n        return offerWithTimeout(connectRequestEncoder.encodedLength(), null);\r\n    }"}, {"ID": 1841, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength(); return publication.offer(buffer, 0, length) > 0; }\n\n    ### Response:", "ground_truth": "Try Connect to an archive on its control interface providing the response stream details. Only one attempt will\nbe made to offer the request.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * Tries to connect to the archive by sending a connect request message.\n     *\n     * @param responseChannel  the channel to which the response should be sent.\n     * @param responseStreamId the stream id to which the response should be sent.\n     * @param correlationId    the correlation id to be used for the request.\n     * @return true if the request was successfully sent, false otherwise.\n     */\n    public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) {\n        // implementation omitted for brevity\n    }"}, {"ID": 1842, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean closeSession(final long controlSessionId) { closeSessionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId); return offer(closeSessionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Close this control session with the archive.\n\n@param controlSessionId with the archive.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Closes a session with the specified controlSessionId.\r\n     * \r\n     * @param controlSessionId the controlSessionId of the session to close\r\n     * @return true if the session was successfully closed, false otherwise\r\n     */\r\n    public boolean closeSession(final long controlSessionId) {\r\n        closeSessionRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId);\r\n        return offer(closeSessionRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1843, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean startRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long correlationId, final long controlSessionId) { startRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(startRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Start recording streams for a given channel and stream id pairing.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * Start recording on a specified channel.\n     *\n     * @param channel the channel to start recording on.\n     * @param streamId the stream id of the recording.\n     * @param sourceLocation the source location of the recording.\n     * @param correlationId the correlation id of the recording.\n     * @param controlSessionId the control session id of the recording.\n     * @return true if the recording was started successfully, false otherwise.\n     */\n    public boolean startRecording(final String channel, final int streamId, final SourceLocation sourceLocation, final long correlationId, final long controlSessionId) {\n        startRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\n                .controlSessionId(controlSessionId)\n                .correlationId(correlationId)\n                .streamId(streamId)\n                .sourceLocation(sourceLocation)\n                .channel(channel);\n\n        return offer(startRecordingRequestEncoder.encodedLength());\n    }"}, {"ID": 1844, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean stopRecording( final String channel, final int streamId, final long correlationId, final long controlSessionId) { stopRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .channel(channel); return offer(stopRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Stop an active recording.\n\n@param channel          to be stopped.\n@param streamId         to be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Stop recording on a specified channel and streamId.\r\n     * \r\n     * @param channel the channel to stop recording on.\r\n     * @param streamId the streamId to stop recording on.\r\n     * @param correlationId the correlationId of the request.\r\n     * @param controlSessionId the controlSessionId of the request.\r\n     * @return true if the request was successfully sent, false otherwise.\r\n     */\r\n    public boolean stopRecording(final String channel, final int streamId, final long correlationId, final long controlSessionId) {\r\n        stopRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .streamId(streamId)\r\n                .channel(channel);\r\n\r\n        return offer(stopRecordingRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1845, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean replay( final long recordingId, final long position, final long length, final String replayChannel, final int replayStreamId, final long correlationId, final long controlSessionId) { replayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .position(position) .length(length) .replayStreamId(replayStreamId) .replayChannel(replayChannel); return offer(replayRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Replay a recording from a given position.\n\n@param recordingId      to be replayed.\n@param position         from which the replay should be started.\n@param length           of the stream to be replayed. Use {@link Long#MAX_VALUE} to follow a live stream.\n@param replayChannel    to which the replay should be sent.\n@param replayStreamId   to which the replay should be sent.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * Replays a recording segment to a specified replay channel.\n     *\n     * @param recordingId      the id of the recording to replay.\n     * @param position         the position in the recording to start replaying from.\n     * @param length           the length of the segment to replay.\n     * @param replayChannel    the name of the replay channel to replay to.\n     * @param replayStreamId   the stream id to use for the replay.\n     * @param correlationId    the correlation id for the replay request.\n     * @param controlSessionId the control session id for the replay request.\n     * @return true if the replay request was successfully submitted, false otherwise.\n     */\n    public boolean replay(final long recordingId, final long position, final long length, final String replayChannel, final int replayStreamId, final long correlationId, final long controlSessionId) {\n        replayRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\n                .controlSessionId(controlSessionId)\n                .correlationId"}, {"ID": 1846, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) { stopReplayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .replaySessionId(replaySessionId); return offer(replayRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Stop an existing replay session.\n\n@param replaySessionId  that should be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Stops a replay session.\r\n     * \r\n     * @param replaySessionId the replay session ID to stop.\r\n     * @param correlationId the correlation ID of the replay session to stop.\r\n     * @param controlSessionId the control session ID of the replay session to stop.\r\n     * @return true if the request was successfully sent to the replay session, false otherwise.\r\n     */\r\n    public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) {\r\n        stopReplayRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .replaySessionId(replaySessionId);\r\n\r\n        return offer(replayRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1847, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId) { listRecordingsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount); return offer(listRecordingsRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a range of recording descriptors.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * List recordings request.\r\n     * \r\n     * @param fromRecordingId from recording id\r\n     * @param recordCount record count\r\n     * @param correlationId correlation id\r\n     * @param controlSessionId control session id\r\n     * @return true if successful\r\n     */\r\n    public boolean listRecordings(final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId) {\r\n        listRecordingsRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .fromRecordingId(fromRecordingId)\r\n                .recordCount(recordCount);\r\n\r\n        return offer(listRecordingsRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1848, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordingsForUri( final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) { listRecordingsForUriRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount) .streamId(streamId) .channel(channelFragment); return offer(listRecordingsForUriRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a range of recording descriptors which match a channel URI fragment and stream id.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param channelFragment  to match recordings on from the original channel URI in the archive descriptor.\n@param streamId         to match recordings on.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * List recordings for a given URI.\n     *\n     * @param fromRecordingId the id of the recording to start from.\n     * @param recordCount the number of recordings to return.\n     * @param channelFragment the URI fragment to filter recordings by.\n     * @param streamId the stream id to filter recordings by.\n     * @param correlationId the correlation id to correlate responses with requests.\n     * @param controlSessionId the control session id to filter recordings by.\n     * @return true if the message was successfully sent, false otherwise.\n     */\n    public boolean listRecordingsForUri(final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) {\n        listRecordingsForUriRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\n                .controlSessionId(controlSessionId)\n                .correlationId(correlationId)\n                .fromRecordingId(fromRecordingId)\n                .recordCount"}, {"ID": 1849, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) { listRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(listRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List a recording descriptor for a given recording id.\n\n@param recordingId      at which to begin listing.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * List a recording.\r\n     * \r\n     * @param recordingId the id of the recording to list\r\n     * @param correlationId the correlation id of the request\r\n     * @param controlSessionId the control session id of the request\r\n     * @return true if the request was successfully sent, false otherwise\r\n     */\r\n    public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) {\r\n        listRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .recordingId(recordingId);\r\n        return offer(listRecordingRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1850, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean extendRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long recordingId, final long correlationId, final long controlSessionId) { extendRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(extendRecordingRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Extend an existing, non-active, recorded stream for a the same channel and stream id.\n\nThe channel must be configured for the initial position from which it will be extended. This can be done\nwith {@link ChannelUriStringBuilder#initialPosition(long, int, int)}. The details required to initialise can\nbe found by calling {@link #listRecording(long, long, long)}.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param recordingId      to be extended.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * Extend a recording for a given channel and streamId.\n     *\n     * @param channel the channel to extend the recording for.\n     * @param streamId the streamId to extend the recording for.\n     * @param sourceLocation the source location of the recording.\n     * @param recordingId the id of the recording to extend.\n     * @param correlationId the correlation id for the request.\n     * @param controlSessionId the control session id for the request.\n     * @return true if the request was successfully sent, false otherwise.\n     */\n    public boolean extendRecording(final String channel, final int streamId, final SourceLocation sourceLocation, final long recordingId, final long correlationId, final long controlSessionId) {\n        extendRecordingRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\n                .controlSessionId(controlSessionId)\n                .correlationId(correlationId)\n                .recordingId(recordingId)\n                .streamId(streamId)\n                .sourceLocation(sourceLocation)\n                .channel("}, {"ID": 1851, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) { recordingPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(recordingPositionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Get the recorded position of an active recording.\n\n@param recordingId      of the active recording that the position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Sends a request to get the recording position for a given recording and correlation id.\r\n     * \r\n     * @param recordingId the id of the recording to get the position for\r\n     * @param correlationId the correlation id of the request\r\n     * @param controlSessionId the control session id of the request\r\n     * @return true if the request was successfully sent, false otherwise\r\n     */\r\n    public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) {\r\n        recordingPositionRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .recordingId(recordingId);\r\n\r\n        return offer(recordingPositionRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1852, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) { stopPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(stopPositionRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "Get the stop position of a recording.\n\n@param recordingId      of the recording that the stop position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\r\n     * Sends a stop position request to the server for the specified recording and correlation ID.\r\n     *\r\n     * @param recordingId the ID of the recording to request the stop position for\r\n     * @param correlationId the correlation ID of the request\r\n     * @param controlSessionId the control session ID to use for the request\r\n     * @return true if the request was successfully sent, false otherwise\r\n     */\r\n    public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) {\r\n        stopPositionRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\r\n                .controlSessionId(controlSessionId)\r\n                .correlationId(correlationId)\r\n                .recordingId(recordingId);\r\n\r\n        return offer(stopPositionRequestEncoder.encodedLength());\r\n    }"}, {"ID": 1853, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean listRecordingSubscriptions( final int pseudoIndex, final int subscriptionCount, final String channelFragment, final int streamId, final boolean applyStreamId, final long correlationId, final long controlSessionId) { listRecordingSubscriptionsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .pseudoIndex(pseudoIndex) .subscriptionCount(subscriptionCount) .applyStreamId(applyStreamId ? BooleanType.TRUE : BooleanType.FALSE) .streamId(streamId) .channel(channelFragment); return offer(listRecordingSubscriptionsRequestEncoder.encodedLength()); }\n\n    ### Response:", "ground_truth": "List registered subscriptions in the archive which have been used to record streams.\n\n@param pseudoIndex       in the list of active recording subscriptions.\n@param subscriptionCount for the number of descriptors to be listed.\n@param channelFragment   for a contains match on the stripped channel used with the registered subscription.\n@param streamId          for the subscription.\n@param applyStreamId     when matching.\n@param correlationId     for this request.\n@param controlSessionId  for this request.\n@return true if successfully offered otherwise false.", "predict": "/**\n     * List recording subscriptions request.\n     *\n     * @param pseudoIndex         pseudo-index of the recording subscription to list.\n     * @param subscriptionCount   number of recording subscriptions to list.\n     * @param channelFragment     fragment of the channel name to match.\n     * @param streamId            stream id to match.\n     * @param applyStreamId       whether to apply the stream id filter.\n     * @param correlationId       correlation id for the request.\n     * @param controlSessionId    control session id for the request.\n     * @return true if the request was successfully offered to the media driver.\n     */\n    public boolean listRecordingSubscriptions(final int pseudoIndex, final int subscriptionCount, final String channelFragment, final int streamId, final boolean applyStreamId, final long correlationId, final long controlSessionId) {\n        listRecordingSubscriptionsRequestEncoder.wrapAndApplyHeader(buffer, 0, messageHeaderEncoder)\n                .controlSessionId(controlSessionId)\n                .correlationId(correlationId)\n                .pseudoIndex(pseudo"}, {"ID": 1854, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean matchesTag(final UdpChannel udpChannel) { if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) { return false; } if (udpChannel.remoteData().getAddress().isAnyLocalAddress() && udpChannel.remoteData().getPort() == 0 && udpChannel.localData().getAddress().isAnyLocalAddress() && udpChannel.localData().getPort() == 0) { return true; } throw new IllegalArgumentException(\"matching tag has set endpoint or control address\"); }\n\n    ### Response:", "ground_truth": "Does this channel have a tag match to another channel including endpoints.\n\n@param udpChannel to match against.\n@return true if there is a match otherwise false.", "predict": "/**\r\n     * Checks if the given UDP channel matches the tag of this channel.\r\n     *\r\n     * @param udpChannel the UDP channel to check\r\n     * @return true if the channel matches the tag, false otherwise\r\n     * @throws IllegalArgumentException if the matching tag has set endpoint or control address\r\n     */\r\n    public boolean matchesTag(final UdpChannel udpChannel) {\r\n        if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) {\r\n            return false;\r\n        }\r\n        if (udpChannel.remoteData().getAddress().isAnyLocalAddress() &&\r\n                udpChannel.remoteData().getPort() == 0 &&\r\n                udpChannel.localData().getAddress().isAnyLocalAddress() &&\r\n                udpChannel.localData().getPort() == 0) {\r\n            return true;\r\n        }\r\n        throw new IllegalArgumentException(\"matching tag has set endpoint or control address\");\r\n    }"}, {"ID": 1855, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static InetSocketAddress destinationAddress(final ChannelUri uri) { try { validateConfiguration(uri); return getEndpointAddress(uri); } catch (final Exception ex) { throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex); } }\n\n    ### Response:", "ground_truth": "Get the endpoint address from the URI.\n\n@param uri to check\n@return endpoint address for URI", "predict": "/**\r\n     * Returns the destination address of the channel based on the provided URI.\r\n     *\r\n     * @param uri the channel URI\r\n     * @return the destination address of the channel\r\n     * @throws InvalidChannelException if the channel URI is invalid or the destination address cannot be determined\r\n     */\r\n    public static InetSocketAddress destinationAddress(final ChannelUri uri) {\r\n        try {\r\n            validateConfiguration(uri);\r\n            return getEndpointAddress(uri);\r\n        } catch (final Exception ex) {\r\n            throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex);\r\n        }\r\n    }"}, {"ID": 1856, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String description() { final StringBuilder builder = new StringBuilder(\"UdpChannel - \"); if (null != localInterface) { builder .append(\"interface: \") .append(localInterface.getDisplayName()) .append(\", \"); } builder .append(\"localData: \").append(localData) .append(\", remoteData: \").append(remoteData) .append(\", ttl: \").append(multicastTtl); return builder.toString(); }\n\n    ### Response:", "ground_truth": "Used for debugging to get a human readable description of the channel.\n\n@return a human readable description of the channel.", "predict": "/**\r\n     * Returns a string representation of the UdpChannel.\r\n     *\r\n     * @return a string representation of the UdpChannel.\r\n     */\r\n    public String description() {\r\n        final StringBuilder builder = new StringBuilder(\"UdpChannel - \");\r\n        if (null != localInterface) {\r\n            builder.append(\"interface: \").append(localInterface.getDisplayName()).append(\", \");\r\n        }\r\n        builder.append(\"localData: \").append(localData).append(\", remoteData: \").append(remoteData).append(\", ttl: \").append(multicastTtl);\r\n        return builder.toString();\r\n    }"}, {"ID": 1857, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) { imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1); if (transport.isMulticast()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl()); } else if (transport.hasExplicitControl()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.explicitControlAddress()); } }\n\n    ### Response:", "ground_truth": "Add a destination to this image so it can merge streams.\n\n@param transportIndex from which packets will arrive.\n@param transport      from which packets will arrive.", "predict": "/**\r\n     * Adds a new destination to the specified transport index.\r\n     * \r\n     * @param transportIndex the index of the transport to add the destination to\r\n     * @param transport the transport to add the destination to\r\n     */\r\n    public void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) {\r\n        imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1);\r\n        if (transport.isMulticast()) {\r\n            imageConnections[transportIndex] = new ImageConnection(cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl());\r\n        } else if (transport.hasExplicitControl()) {\r\n            imageConnections[transportIndex] = new ImageConnection(cachedNanoClock.nanoTime(), transport.explicitControlAddress());\r\n        }\r\n    }"}, {"ID": 1858, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    int insertPacket( final int termId, final int termOffset, final UnsafeBuffer buffer, final int length, final int transportIndex, final InetSocketAddress srcAddress) { final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length); final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId); final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length; if (!isFlowControlUnderRun(packetPosition) && !isFlowControlOverRun(proposedPosition)) { trackConnection(transportIndex, srcAddress, lastPacketTimestampNs); if (isHeartbeat) { if (DataHeaderFlyweight.isEndOfStream(buffer) && !isEndOfStream && allEos(transportIndex)) { LogBufferDescriptor.endOfStreamPosition(rawLog.metaData(), proposedPosition); isEndOfStream = true; } heartbeatsReceived.incrementOrdered(); } else { final UnsafeBuffer termBuffer = termBuffers[indexByPosition(packetPosition, positionBitsToShift)]; TermRebuilder.insert(termBuffer, termOffset, buffer, length); } lastPacketTimestampNs = cachedNanoClock.nanoTime(); hwmPosition.proposeMaxOrdered(proposedPosition); } return length; }\n\n    ### Response:", "ground_truth": "Insert frame into term buffer.\n\n@param termId         for the data packet to insert into the appropriate term.\n@param termOffset     for the start of the packet in the term.\n@param buffer         for the data packet to insert into the appropriate term.\n@param length         of the data packet\n@param transportIndex which the packet came from.\n@param srcAddress     which the packet came from.\n@return number of bytes applied as a result of this insertion.", "predict": "/**\n     * Inserts a packet into the log.\n     *\n     * @param termId           the term id of the packet.\n     * @param termOffset       the offset within the term of the packet.\n     * @param buffer           the buffer containing the packet data.\n     * @param length           the length of the packet data.\n     * @param transportIndex   the transport index of the packet.\n     * @param srcAddress       the source address of the packet.\n     * @return the length of the packet data.\n     */\n    int insertPacket(final int termId, final int termOffset, final UnsafeBuffer buffer, final int length, final int transportIndex, final InetSocketAddress srcAddress) {\n        final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length);\n        final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId);\n        final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length;\n\n        if (!isFlowControlUnderRun(packetPosition"}, {"ID": 1859, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter findControlToggle(final CountersReader counters) { final AtomicBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { final int recordOffset = CountersReader.metaDataOffset(i); if (counters.getCounterState(i) == RECORD_ALLOCATED && buffer.getInt(recordOffset + TYPE_ID_OFFSET) == CONTROL_TOGGLE_TYPE_ID) { return new AtomicCounter(counters.valuesBuffer(), i, null); } } return null; }\n\n    ### Response:", "ground_truth": "Find the control toggle counter or return null if not found.\n\n@param counters to search for the control toggle.\n@return the control toggle counter or return null if not found.", "predict": "/**\r\n     * Finds the control toggle counter in the given counters reader.\r\n     *\r\n     * @param counters the counters reader to search for the control toggle counter.\r\n     * @return the control toggle counter or null if not found.\r\n     */\r\n    public static AtomicCounter findControlToggle(final CountersReader counters) {\r\n        final AtomicBuffer buffer = counters.metaDataBuffer();\r\n        for (int i = 0, size = counters.maxCounterId(); i < size; i++) {\r\n            final int recordOffset = CountersReader.metaDataOffset(i);\r\n            if (counters.getCounterState(i) == RECORD_ALLOCATED && buffer.getInt(recordOffset + TYPE_ID_OFFSET) == CONTROL_TOGGLE_TYPE_ID) {\r\n                return new AtomicCounter(counters.valuesBuffer(), i, null);\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1860, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String put(final String key, final String value) { return params.put(key, value); }\n\n    ### Response:", "ground_truth": "Put a key and value pair in the map of params.\n\n@param key   of the param to be put.\n@param value of the param to be put.\n@return the existing value otherwise null.", "predict": "/**\r\n     * Adds a new key-value pair to the parameter map.\r\n     * \r\n     * @param key the key for the new parameter\r\n     * @param value the value for the new parameter\r\n     * @return the previous value associated with the key, or null if there was no mapping for the key\r\n     */\r\n    public String put(final String key, final String value) { return params.put(key, value); }"}, {"ID": 1861, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; }\n\n    ### Response:", "ground_truth": "Get the channel tag, if it exists, that refers to an another channel.\n\n@return channel tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": "/**\r\n     * Returns the channel tag from the tags array.\r\n     *\r\n     * @return the channel tag or null if it doesn't exist\r\n     */\r\n    public String channelTag() {\r\n        return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null;\r\n    }"}, {"ID": 1862, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String entityTag() { return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null; }\n\n    ### Response:", "ground_truth": "Get the entity tag, if it exists, that refers to an entity such as subscription or publication.\n\n@return entity tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": "/**\r\n     * Returns the entity tag for the entity.\r\n     *\r\n     * @return the entity tag or null if no entity tag is available.\r\n     */\r\n    public String entityTag() {\r\n        return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null;\r\n    }"}, {"ID": 1863, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String addSessionId(final String channel, final int sessionId) { final ChannelUri channelUri = ChannelUri.parse(channel); channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId)); return channelUri.toString(); }\n\n    ### Response:", "ground_truth": "Add a sessionId to a given channel.\n\n@param channel   to add sessionId to.\n@param sessionId to add to channel.\n@return new string that represents channel with sessionId added.", "predict": "/**\r\n     * Adds the session id to the channel URI.\r\n     *\r\n     * @param channel the channel URI to add the session id to\r\n     * @param sessionId the session id to add to the channel URI\r\n     * @return the updated channel URI with the session id added\r\n     */\r\n    public static String addSessionId(final String channel, final int sessionId) {\r\n        final ChannelUri channelUri = ChannelUri.parse(channel);\r\n        channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId));\r\n        return channelUri.toString();\r\n    }"}, {"ID": 1864, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getTag(final String paramValue) { return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG; }\n\n    ### Response:", "ground_truth": "Get the value of the tag from a given parameter value.\n\n@param paramValue to extract the tag value from.\n@return the value of the tag or {@link #INVALID_TAG} if not tagged.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": "/**\r\n     * This method returns the tag value of a given parameter value.\r\n     * \r\n     * @param paramValue The parameter value to get the tag from.\r\n     * @return The tag value of the parameter value.\r\n     */\r\n    public static long getTag(final String paramValue) {\r\n        return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG;\r\n    }"}, {"ID": 1865, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public int appendPadding( final int termId, final int termOffset, final HeaderWriter header, final int length) { final int frameLength = length + HEADER_LENGTH; final int alignedLength = align(frameLength, FRAME_ALIGNMENT); final UnsafeBuffer termBuffer = this.termBuffer; final int termLength = termBuffer.capacity(); int resultingOffset = termOffset + alignedLength; putRawTailOrdered(termId, resultingOffset); if (resultingOffset > termLength) { resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId); } else { header.write(termBuffer, termOffset, frameLength, termId); frameType(termBuffer, termOffset, PADDING_FRAME_TYPE); frameLengthOrdered(termBuffer, termOffset, frameLength); } return resultingOffset; }\n\n    ### Response:", "ground_truth": "Pad a length of the term buffer with a padding record.\n\n@param termId     for the current term.\n@param termOffset in the term at which to append.\n@param header     for writing the default header.\n@param length     of the padding to be written.\n@return the resulting offset of the term after success otherwise {@link #FAILED}.", "predict": "/**\n     * Appends a padding frame to the end of the log buffer.\n     *\n     * @param termId       for the term to which the frame will be appended.\n     * @param termOffset   for the start of the term to which the frame will be appended.\n     * @param header       to write the header for the frame.\n     * @param length       of the padding to be appended.\n     * @return the resulting offset after the frame has been appended.\n     */\n    public int appendPadding(final int termId, final int termOffset, final HeaderWriter header, final int length) {\n        final int frameLength = length + HEADER_LENGTH;\n        final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\n        final UnsafeBuffer termBuffer = this.termBuffer;\n        final int termLength = termBuffer.capacity();\n        int resultingOffset = termOffset + alignedLength;\n        putRawTailOrdered(termId, resultingOffset);\n        if (resultingOffset > termLength) {\n            resultingOffset = handleEndOf"}, {"ID": 1866, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    final int updatePublisherLimit() { int workCount = 0; final long senderPosition = this.senderPosition.getVolatile(); if (hasReceivers || (spiesSimulateConnection && spyPositions.length > 0)) { long minConsumerPosition = senderPosition; for (final ReadablePosition spyPosition : spyPositions) { minConsumerPosition = Math.min(minConsumerPosition, spyPosition.getVolatile()); } final long proposedPublisherLimit = minConsumerPosition + termWindowLength; if (publisherLimit.proposeMaxOrdered(proposedPublisherLimit)) { cleanBuffer(proposedPublisherLimit); workCount = 1; } } else if (publisherLimit.get() > senderPosition) { publisherLimit.setOrdered(senderPosition); } return workCount; }\n\n    ### Response:", "ground_truth": "Update the publishers limit for flow control as part of the conductor duty cycle.\n\n@return 1 if the limit has been updated otherwise 0.", "predict": "/**\r\n     * Updates the publisher limit based on the current sender position and the positions of the connected receivers.\r\n     *\r\n     * @return the number of work items processed (0 or 1)\r\n     */\r\n    final int updatePublisherLimit() {\r\n        int workCount = 0;\r\n        final long senderPosition = this.senderPosition.getVolatile();\r\n        if (hasReceivers || (spiesSimulateConnection && spyPositions.length > 0)) {\r\n            long minConsumerPosition = senderPosition;\r\n            for (final ReadablePosition spyPosition : spyPositions) {\r\n                minConsumerPosition = Math.min(minConsumerPosition, spyPosition.getVolatile());\r\n            }\r\n            final long proposedPublisherLimit = minConsumerPosition + termWindowLength;\r\n            if (publisherLimit.proposeMaxOrdered(proposedPublisherLimit)) {\r\n                cleanBuffer(proposedPublisherLimit);\r\n                workCount = 1;\r\n            }\r\n        } else if (publisherLimit.get() > senderPosition) {\r\n            publisherLimit.setOrdered(senderPosition);\r\n       "}, {"ID": 1867, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, streamId, channel), countersManager); }\n\n    ### Response:", "ground_truth": "Allocate a counter for tracking a position on a stream of messages.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@param sessionId       for the stream of messages.\n@param streamId        for the stream of messages.\n@param channel         for the stream of messages.\n@return a new {@link UnsafeBufferPosition} for tracking the stream.", "predict": "/**\n     * Allocate a new UnsafeBufferPosition object.\n     *\n     * @param tempBuffer the temporary buffer to use for counter allocation.\n     * @param name the name of the counter.\n     * @param typeId the type id of the counter.\n     * @param countersManager the counters manager to use for counter allocation.\n     * @param registrationId the registration id of the counter.\n     * @param sessionId the session id of the counter.\n     * @param streamId the stream id of the counter.\n     * @param channel the channel of the counter.\n     * @return a new UnsafeBufferPosition object.\n     */\n    public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, stream"}, {"ID": 1868, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String labelName(final int typeId) { switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: return PublisherLimit.NAME; case SenderPos.SENDER_POSITION_TYPE_ID: return SenderPos.NAME; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: return ReceiverHwm.NAME; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: return SubscriberPos.NAME; case ReceiverPos.RECEIVER_POS_TYPE_ID: return ReceiverPos.NAME; case SenderLimit.SENDER_LIMIT_TYPE_ID: return SenderLimit.NAME; case PublisherPos.PUBLISHER_POS_TYPE_ID: return PublisherPos.NAME; case SenderBpe.SENDER_BPE_TYPE_ID: return SenderBpe.NAME; default: return \"<unknown>\"; } }\n\n    ### Response:", "ground_truth": "Return the label name for a counter type identifier.\n\n@param typeId of the counter.\n@return the label name as a String.", "predict": "/**\r\n     * Returns the name of the type identified by the given type ID.\r\n     * \r\n     * @param typeId the type ID\r\n     * @return the name of the type, or \"<unknown>\" if the type is not recognized\r\n     */\r\n    public static String labelName(final int typeId) {\r\n        switch (typeId) {\r\n            case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID:\r\n                return PublisherLimit.NAME;\r\n            case SenderPos.SENDER_POSITION_TYPE_ID:\r\n                return SenderPos.NAME;\r\n            case ReceiverHwm.RECEIVER_HWM_TYPE_ID:\r\n                return ReceiverHwm.NAME;\r\n            case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID:\r\n                return SubscriberPos.NAME;\r\n            case ReceiverPos.RECEIVER_POS_TYPE_ID:\r\n                return ReceiverPos.NAME;\r\n            case SenderLimit.SENDER_LIMIT_TYPE_ID:\r\n                return SenderLimit.NAME;\r\n            case PublisherPos.PUBLISHER_POS_TYPE_ID:"}, {"ID": 1869, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) { final int limit = Math.min(maxLength, termBuffer.capacity() - offset); int available = 0; int padding = 0; do { final int termOffset = offset + available; final int frameLength = frameLengthVolatile(termBuffer, termOffset); if (frameLength <= 0) { break; } int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT); if (isPaddingFrame(termBuffer, termOffset)) { padding = alignedFrameLength - HEADER_LENGTH; alignedFrameLength = HEADER_LENGTH; } available += alignedFrameLength; if (available > limit) { available -= alignedFrameLength; padding = 0; break; } } while (0 == padding && available < limit); return pack(padding, available); }\n\n    ### Response:", "ground_truth": "Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.\n\n@param termBuffer to be scanned for new message fragments.\n@param offset     at which the scan should begin.\n@param maxLength  in bytes of how much should be scanned.\n@return resulting status of the scan which packs the available bytes and padding into a long.", "predict": "/**\n     * Scans the term buffer for the availability of messages.\n     *\n     * @param termBuffer to scan.\n     * @param offset     in the term buffer to start scanning.\n     * @param maxLength  to scan up to.\n     * @return a packed value containing the padding and available length.\n     */\n    public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) {\n        final int limit = Math.min(maxLength, termBuffer.capacity() - offset);\n        int available = 0;\n        int padding = 0;\n        do {\n            final int termOffset = offset + available;\n            final int frameLength = frameLengthVolatile(termBuffer, termOffset);\n            if (frameLength <= 0) {\n                break;\n            }\n            int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT);\n            if (isPaddingFrame(termBuffer, termOffset)) {\n                padding = alignedFrameLength - HEADER_LENGTH;\n                alignedFrameLength = HEADER_LENGTH;\n           "}, {"ID": 1870, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder clear() { prefix = null; media = null; endpoint = null; networkInterface = null; controlEndpoint = null; controlMode = null; tags = null; alias = null; reliable = null; ttl = null; mtu = null; termLength = null; initialTermId = null; termId = null; termOffset = null; sessionId = null; linger = null; sparse = null; eos = null; tether = null; isSessionIdTagged = false; return this; }\n\n    ### Response:", "ground_truth": "Clear out all the values thus setting back to the initial state.\n\n@return this for a fluent API.", "predict": "/**\n     * Clears all the parameters set in the builder.\n     *\n     * @return the updated builder object.\n     */\n    public ChannelUriStringBuilder clear() {\n        prefix = null;\n        media = null;\n        endpoint = null;\n        networkInterface = null;\n        controlEndpoint = null;\n        controlMode = null;\n        tags = null;\n        alias = null;\n        reliable = null;\n        ttl = null;\n        mtu = null;\n        termLength = null;\n        initialTermId = null;\n        termId = null;\n        termOffset = null;\n        sessionId = null;\n        linger = null;\n        sparse = null;\n        eos = null;\n        tether = null;\n        isSessionIdTagged = false;\n        return this;\n    }"}, {"ID": 1871, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder validate() { if (null == media) { throw new IllegalStateException(\"media type is mandatory\"); } if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) { throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\"); } int count = 0; count += null == initialTermId ? 0 : 1; count += null == termId ? 0 : 1; count += null == termOffset ? 0 : 1; if (count > 0) { if (count < 3) { throw new IllegalStateException( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\"); } if (termId - initialTermId < 0) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId); } if (null != termLength && termOffset > termLength) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException(\"termOffset=\" + termOffset + \" > termLength=\" + termLength); } } return this; }\n\n    ### Response:", "ground_truth": "Validates that the collection of set parameters are valid together.\n\n@return this for a fluent API.\n@throws IllegalStateException if the combination of params is invalid.", "predict": "/**\n     * Validates the parameters of the channel URI and returns the updated builder.\n     *\n     * @return the updated builder.\n     * @throws IllegalStateException if any of the parameters are invalid.\n     */\n    public ChannelUriStringBuilder validate() {\n        if (null == media) {\n            throw new IllegalStateException(\"media type is mandatory\");\n        }\n        if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) {\n            throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\");\n        }\n        int count = 0;\n        count += null == initialTermId ? 0 : 1;\n        count += null == termId ? 0 : 1;\n        count += null == termOffset ? 0 : 1;\n        if (count > 0) {\n            if (count < 3) {\n                throw new IllegalStateException(\"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\");"}, {"ID": 1872, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder prefix(final String prefix) { if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid prefix: \" + prefix); } this.prefix = prefix; return this; }\n\n    ### Response:", "ground_truth": "Set the prefix for taking an addition action such as spying on an outgoing publication with \"aeron-spy\".\n\n@param prefix to be applied to the URI before the the scheme.\n@return this for a fluent API.\n@see ChannelUri#SPY_QUALIFIER", "predict": "/**\n     * Adds a prefix to the channel URI.\n     *\n     * @param prefix the prefix to add to the channel URI.\n     * @return the updated ChannelUriStringBuilder object.\n     * @throws IllegalArgumentException if the prefix is invalid.\n     */\n    public ChannelUriStringBuilder prefix(final String prefix) {\n        if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) {\n            throw new IllegalArgumentException(\"invalid prefix: \" + prefix);\n        }\n        this.prefix = prefix;\n        return this;\n    }"}, {"ID": 1873, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder media(final String media) { switch (media) { case CommonContext.UDP_MEDIA: case CommonContext.IPC_MEDIA: break; default: throw new IllegalArgumentException(\"invalid media: \" + media); } this.media = media; return this; }\n\n    ### Response:", "ground_truth": "Set the media for this channel. Valid values are \"udp\" and \"ipc\".\n\n@param media for this channel.\n@return this for a fluent API.", "predict": "/**\n     * Sets the media type for the channel.\n     *\n     * @param media the media type to set\n     * @return the updated ChannelUriStringBuilder object\n     * @throws IllegalArgumentException if the media type is invalid\n     */\n    public ChannelUriStringBuilder media(final String media) {\n        switch (media) {\n            case CommonContext.UDP_MEDIA:\n            case CommonContext.IPC_MEDIA:\n                break;\n            default:\n                throw new IllegalArgumentException(\"invalid media: \" + media);\n        }\n        this.media = media;\n        return this;\n    }"}, {"ID": 1874, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder controlMode(final String controlMode) { if (null != controlMode && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_MANUAL) && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_DYNAMIC)) { throw new IllegalArgumentException(\"invalid control mode: \" + controlMode); } this.controlMode = controlMode; return this; }\n\n    ### Response:", "ground_truth": "Set the control mode for multi-destination-cast. Set to \"manual\" for allowing control from the publication API.\n\n@param controlMode for taking control of MDC.\n@return this for a fluent API.\n@see Publication#addDestination(String)\n@see Publication#removeDestination(String)\n@see CommonContext#MDC_CONTROL_MODE_PARAM_NAME\n@see CommonContext#MDC_CONTROL_MODE_MANUAL\n@see CommonContext#MDC_CONTROL_MODE_DYNAMIC", "predict": "/**\n     * Sets the control mode for the channel.\n     *\n     * @param controlMode the control mode to set. Valid values are \"manual\" and \"dynamic\".\n     * @return the updated ChannelUriStringBuilder object.\n     * @throws IllegalArgumentException if the control mode is not valid.\n     */\n    public ChannelUriStringBuilder controlMode(final String controlMode) {\n        if (null != controlMode && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_MANUAL) && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_DYNAMIC)) {\n            throw new IllegalArgumentException(\"invalid control mode: \" + controlMode);\n        }\n        this.controlMode = controlMode;\n        return this;\n    }"}, {"ID": 1875, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder termLength(final Integer termLength) { if (null != termLength) { LogBufferDescriptor.checkTermLength(termLength); } this.termLength = termLength; return this; }\n\n    ### Response:", "ground_truth": "Set the length of buffer used for each term of the log. Valid values are powers of 2 in the 64K - 1G range.\n\n@param termLength of the buffer used for each term of the log.\n@return this for a fluent API.\n@see CommonContext#TERM_LENGTH_PARAM_NAME", "predict": "/**\n     * Sets the term length for the channel.\n     *\n     * @param termLength the term length for the channel.\n     * @return the ChannelUriStringBuilder instance.\n     * @throws IllegalArgumentException if the term length is not within the valid range.\n     */\n    public ChannelUriStringBuilder termLength(final Integer termLength) {\n        if (null != termLength) {\n            LogBufferDescriptor.checkTermLength(termLength);\n        }\n        this.termLength = termLength;\n        return this;\n    }"}, {"ID": 1876, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder termOffset(final Integer termOffset) { if (null != termOffset) { if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) { throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset); } if (0 != (termOffset & (FRAME_ALIGNMENT - 1))) { throw new IllegalArgumentException(\"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset); } } this.termOffset = termOffset; return this; }\n\n    ### Response:", "ground_truth": "Set the offset within a term at which a publication will start. This when combined with the term id can establish\na starting position.\n\n@param termOffset within a term at which a publication will start.\n@return this for a fluent API.\n@see CommonContext#TERM_OFFSET_PARAM_NAME", "predict": "/**\n     * Sets the term offset for the channel URI.\n     *\n     * @param termOffset the term offset for the channel URI.\n     * @return the updated ChannelUriStringBuilder object.\n     * @throws IllegalArgumentException if the term offset is not in the range 0-1g or is not a multiple of FRAME_ALIGNMENT.\n     */\n    public ChannelUriStringBuilder termOffset(final Integer termOffset) {\n        if (null != termOffset) {\n            if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) {\n                throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset);\n            }\n            if (0 != (termOffset & (FRAME_ALIGNMENT - 1))) {\n                throw new IllegalArgumentException(\"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset);\n            }\n        }\n        this.termOffset = termOffset;\n        return this;\n    }"}, {"ID": 1877, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ChannelUriStringBuilder linger(final Long lingerNs) { if (null != lingerNs && lingerNs < 0) { throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs); } this.linger = lingerNs; return this; }\n\n    ### Response:", "ground_truth": "Set the time a network publication will linger in nanoseconds after being drained. This time is so that tail loss\ncan be recovered.\n\n@param lingerNs time for the publication after it is drained.\n@return this for a fluent API.\n@see CommonContext#LINGER_PARAM_NAME", "predict": "/**\n     * Sets the linger time in nanoseconds for the connection.\n     *\n     * @param lingerNs the linger time in nanoseconds.\n     * @return this ChannelUriStringBuilder.\n     * @throws IllegalArgumentException if the linger time is negative.\n     */\n    public ChannelUriStringBuilder linger(final Long lingerNs) {\n        if (null != lingerNs && lingerNs < 0) {\n            throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs);\n        }\n        this.linger = lingerNs;\n        return this;\n    }"}, {"ID": 1878, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void openDatagramChannel(final AtomicCounter statusIndicator) { try { sendDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); receiveDatagramChannel = sendDatagramChannel; if (udpChannel.isMulticast()) { if (null != connectAddress) { receiveDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); } receiveDatagramChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); receiveDatagramChannel.bind(new InetSocketAddress(endPointAddress.getPort())); receiveDatagramChannel.join(endPointAddress.getAddress(), udpChannel.localInterface()); sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_IF, udpChannel.localInterface()); if (udpChannel.isHasMulticastTtl()) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, udpChannel.multicastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } else if (context.socketMulticastTtl() != 0) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, context.socketMulticastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } } else { sendDatagramChannel.bind(bindAddress); } if (null != connectAddress) { sendDatagramChannel.connect(connectAddress); } if (0 != context.socketSndbufLength()) { sendDatagramChannel.setOption(SO_SNDBUF, context.socketSndbufLength()); } if (0 != context.socketRcvbufLength()) { receiveDatagramChannel.setOption(SO_RCVBUF, context.socketRcvbufLength()); } sendDatagramChannel.configureBlocking(false); receiveDatagramChannel.configureBlocking(false); } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERRORED); } CloseHelper.quietClose(sendDatagramChannel); if (receiveDatagramChannel != sendDatagramChannel) { CloseHelper.quietClose(receiveDatagramChannel); } sendDatagramChannel = null; receiveDatagramChannel = null; throw new AeronException( \"channel error - \" + ex.getMessage() + \" (at \" + ex.getStackTrace()[0].toString() + \"): \" + udpChannel.originalUriString(), ex); } }\n\n    ### Response:", "ground_truth": "Create the underlying channel for reading and writing.\n\n@param statusIndicator to set for error status", "predict": "/**\n     * Opens a datagram channel for sending and receiving UDP packets.\n     *\n     * @param statusIndicator to be updated with the status of the channel.\n     * @throws AeronException if the channel cannot be opened.\n     */\n    public void openDatagramChannel(final AtomicCounter statusIndicator) {\n        try {\n            sendDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily());\n            receiveDatagramChannel = sendDatagramChannel;\n\n            if (udpChannel.isMulticast()) {\n                if (null != connectAddress) {\n                    receiveDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily());\n                }\n\n                receiveDatagramChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n                receiveDatagramChannel.bind(new InetSocketAddress(endPointAddress.getPort()));\n                receiveDatagramChannel.join(endPointAddress.getAddress(), udpChannel.localInterface());\n\n                sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_IF"}, {"ID": 1879, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (!isClosed) { isClosed = true; try { if (null != selectionKey) { selectionKey.cancel(); } if (null != transportPoller) { transportPoller.cancelRead(this); transportPoller.selectNowWithoutProcessing(); } if (null != sendDatagramChannel) { sendDatagramChannel.close(); } if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) { receiveDatagramChannel.close(); } if (null != transportPoller) { transportPoller.selectNowWithoutProcessing(); } } catch (final IOException ex) { errorLog.record(ex); } } }\n\n    ### Response:", "ground_truth": "Close transport, canceling any pending read operations and closing channel", "predict": "/**\r\n     * Closes the transport and releases any resources associated with it.\r\n     *\r\n     * @throws IOException if an I/O error occurs while closing the transport.\r\n     */\r\n    public void close() throws IOException {\r\n        if (!isClosed) {\r\n            isClosed = true;\r\n            try {\r\n                if (null != selectionKey) {\r\n                    selectionKey.cancel();\r\n                }\r\n                if (null != transportPoller) {\r\n                    transportPoller.cancelRead(this);\r\n                    transportPoller.selectNowWithoutProcessing();\r\n                }\r\n                if (null != sendDatagramChannel) {\r\n                    sendDatagramChannel.close();\r\n                }\r\n                if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) {\r\n                    receiveDatagramChannel.close();\r\n                }\r\n                if (null != transportPoller) {\r\n                    transportPoller.selectNowWithoutProcessing();\r\n                }\r\n            } catch (final IOException ex) {\r\n                errorLog.record(ex);\r\n            }\r\n        }\r\n    }"}, {"ID": 1880, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isValidFrame(final UnsafeBuffer buffer, final int length) { boolean isFrameValid = true; if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) { isFrameValid = false; invalidPackets.increment(); } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) { isFrameValid = false; invalidPackets.increment(); } return isFrameValid; }\n\n    ### Response:", "ground_truth": "Is the received frame valid. This method will do some basic checks on the header and can be\noverridden in a subclass for further validation.\n\n@param buffer containing the frame.\n@param length of the frame.\n@return true if the frame is believed valid otherwise false.", "predict": "/**\n     * Checks if the frame is valid or not.\n     *\n     * @param buffer - The buffer containing the frame.\n     * @param length - The length of the frame.\n     * @return true if the frame is valid, false otherwise.\n     */\n    public boolean isValidFrame(final UnsafeBuffer buffer, final int length) {\n        boolean isFrameValid = true;\n        if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) {\n            isFrameValid = false;\n            invalidPackets.increment();\n        } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) {\n            isFrameValid = false;\n            invalidPackets.increment();\n        }\n        return isFrameValid;\n    }"}, {"ID": 1881, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public InetSocketAddress receive(final ByteBuffer buffer) { buffer.clear(); InetSocketAddress address = null; try { if (receiveDatagramChannel.isOpen()) { address = (InetSocketAddress)receiveDatagramChannel.receive(buffer); } } catch (final PortUnreachableException ignored) { } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } return address; }\n\n    ### Response:", "ground_truth": "Receive a datagram from the media layer.\n\n@param buffer into which the datagram will be received.\n@return the source address of the datagram if one is available otherwise false.", "predict": "/**\r\n     * Receives a datagram packet from the receiveDatagramChannel and returns the sender's address.\r\n     *\r\n     * @param buffer the buffer to receive the datagram packet into\r\n     * @return the sender's address, or null if no packet was received\r\n     */\r\n    public InetSocketAddress receive(final ByteBuffer buffer) {\r\n        buffer.clear();\r\n        InetSocketAddress address = null;\r\n        try {\r\n            if (receiveDatagramChannel.isOpen()) {\r\n                address = (InetSocketAddress) receiveDatagramChannel.receive(buffer);\r\n            }\r\n        } catch (final PortUnreachableException ignored) {\r\n        } catch (final Exception ex) {\r\n            LangUtil.rethrowUnchecked(ex);\r\n        }\r\n        return address;\r\n    }"}, {"ID": 1882, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void onNak( final int termId, final int termOffset, final int length, final int termLength, final RetransmitSender retransmitSender) { if (!isInvalid(termOffset, termLength)) { if (null == activeRetransmitsMap.get(termId, termOffset) && activeRetransmitsMap.size() < MAX_RETRANSMITS_DEFAULT) { final RetransmitAction action = assignRetransmitAction(); action.termId = termId; action.termOffset = termOffset; action.length = Math.min(length, termLength - termOffset); final long delay = delayGenerator.generateDelay(); if (0 == delay) { retransmitSender.resend(termId, termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else { action.delay(delay, nanoClock.nanoTime()); } activeRetransmitsMap.put(termId, termOffset, action); } } }\n\n    ### Response:", "ground_truth": "Called on reception of a NAK to start retransmits handling.\n\n@param termId           from the NAK and the term id of the buffer to retransmit from\n@param termOffset       from the NAK and the offset of the data to retransmit\n@param length           of the missing data\n@param termLength       of the term buffer.\n@param retransmitSender to call if an immediate retransmit is required", "predict": "/**\n     * This method is called when a NAK is received for a term. It checks if the term offset and length are valid, and if not, it returns. If the term offset and length are valid, it checks if there is already an active retransmit for the given term and offset. If there is not, it assigns a retransmit action, generates a delay, and adds the action to the active retransmits map. If the delay is 0, it calls the retransmit sender to resend the missing data. Otherwise, it sets the delay for the action. If the active retransmits map size exceeds the maximum allowed retransmits, it returns without adding the action to the map.\n     * \n     * @param termId The ID of the term that the NAK was received for.\n     * @param termOffset The offset of the missing data in the term.\n     * @param length The length of the missing data.\n     * @param termLength The length of the term.\n     * @param retransmitSender The retransmit"}, {"ID": 1883, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void processTimeouts(final long nowNs, final RetransmitSender retransmitSender) { if (activeRetransmitsMap.size() > 0) { for (final RetransmitAction action : retransmitActionPool) { if (DELAYED == action.state && (action.expireNs - nowNs < 0)) { retransmitSender.resend(action.termId, action.termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else if (LINGERING == action.state && (action.expireNs - nowNs < 0)) { action.cancel(); activeRetransmitsMap.remove(action.termId, action.termOffset); } } } }\n\n    ### Response:", "ground_truth": "Called to process any outstanding timeouts.\n\n@param nowNs            time in nanoseconds\n@param retransmitSender to call on retransmissions", "predict": "/**\r\n     * Processes any timeouts for retransmit actions.\r\n     *\r\n     * @param nowNs the current time in nanoseconds.\r\n     * @param retransmitSender the retransmit sender to use for resending messages.\r\n     */\r\n    public void processTimeouts(final long nowNs, final RetransmitSender retransmitSender) { }"}, {"ID": 1884, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String status(final long status) { if (INITIALIZING == status) { return \"INITIALIZING\"; } if (ERRORED == status) { return \"ERRORED\"; } if (ACTIVE == status) { return \"ACTIVE\"; } if (CLOSING == status) { return \"CLOSING\"; } return \"unknown id=\" + status; }\n\n    ### Response:", "ground_truth": "String representation of the channel status.\n\n@param status to be converted.\n@return representation of the channel status.", "predict": "/**\r\n     * Returns the status of the connection based on the status code.\r\n     * \r\n     * @param status the status code of the connection\r\n     * @return the status of the connection\r\n     */\r\n    public static String status(final long status) {\r\n        if (INITIALIZING == status) {\r\n            return \"INITIALIZING\";\r\n        } else if (ERRORED == status) {\r\n            return \"ERRORED\";\r\n        } else if (ACTIVE == status) {\r\n            return \"ACTIVE\";\r\n        } else if (CLOSING == status) {\r\n            return \"CLOSING\";\r\n        } else {\r\n            return \"unknown id=\" + status;\r\n        }\r\n    }"}, {"ID": 1885, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) { final int keyLength = tempBuffer.putStringWithoutLengthAscii( CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH); tempBuffer.putInt(CHANNEL_OFFSET, keyLength); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name); labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, \": \"); labelLength += tempBuffer.putStringWithoutLengthAscii( keyLength + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength); return countersManager.newCounter(typeId, tempBuffer, 0, keyLength, tempBuffer, keyLength, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate an indicator for tracking the status of a channel endpoint.\n\n@param tempBuffer      to be used for labels and metadata.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param channel         for the stream of messages.\n@return a new {@link AtomicCounter} for tracking the status.", "predict": "/**\n     * Allocate a new atomic counter with the given name, type id, and channel.\n     *\n     * @param tempBuffer the temporary buffer to use for encoding the counter key and label\n     * @param name the name of the counter\n     * @param typeId the type id of the counter\n     * @param countersManager the counters manager to use for allocating the counter\n     * @param channel the channel of the counter\n     * @return the newly allocated atomic counter\n     */\n    public static AtomicCounter allocate(final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) {\n        final int keyLength = tempBuffer.putStringWithoutLengthAscii(CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH);\n        tempBuffer.putInt(CHANNEL_OFFSET, keyLength);\n        int labelLength = 0;\n        labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name);\n        labelLength += tempBuffer"}, {"ID": 1886, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; }\n\n    ### Response:", "ground_truth": "Reset the values.\n\n@param buffer which is the super set.\n@param offset at which the vector begins.\n@param length of the vector.\n@return this for a fluent API.", "predict": "/**\n     * Resets the DirectBufferVector with the given buffer, offset, and length.\n     *\n     * @param buffer the buffer to set\n     * @param offset the offset to set\n     * @param length the length to set\n     * @return the updated DirectBufferVector\n     */\n    public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) {\n        this.buffer = buffer;\n        this.offset = offset;\n        this.length = length;\n        return this;\n    }"}, {"ID": 1887, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public DirectBufferVector validate() { final int capacity = buffer.capacity(); if (offset < 0 || offset >= capacity) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity); } if (length < 0 || length > (capacity - offset)) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length); } return this; }\n\n    ### Response:", "ground_truth": "Ensure the vector is valid for the buffer.\n\n@throws NullPointerException if the buffer is null.\n@throws IllegalArgumentException if the offset is out of range for the buffer.\n@throws IllegalArgumentException if the length is out of range for the buffer.\n@return this for a fluent API.", "predict": "/**\n     * Validates the buffer vector.\n     *\n     * @return the validated buffer vector.\n     * @throws IllegalArgumentException if the offset or length is invalid.\n     */\n    public DirectBufferVector validate() {\n        final int capacity = buffer.capacity();\n        if (offset < 0 || offset >= capacity) {\n            throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity);\n        }\n        if (length < 0 || length > (capacity - offset)) {\n            throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length);\n        }\n        return this;\n    }"}, {"ID": 1888, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int validateAndComputeLength(final DirectBufferVector[] vectors) { int messageLength = 0; for (final DirectBufferVector vector : vectors) { vector.validate(); messageLength += vector.length; if (messageLength < 0) { throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors)); } } return messageLength; }\n\n    ### Response:", "ground_truth": "Validate an array of vectors to make up a message and compute the total length.\n\n@param vectors to be validated summed.\n@return the sum of the vector lengths.", "predict": "/**\r\n     * Validates the DirectBufferVector array and computes the total length of the message.\r\n     * \r\n     * @param vectors the DirectBufferVector array to validate and compute the length of\r\n     * @return the total length of the message\r\n     * @throws IllegalStateException if the length of the message overflows an int\r\n     */\r\n    public static int validateAndComputeLength(final DirectBufferVector[] vectors) {\r\n        int messageLength = 0;\r\n        for (final DirectBufferVector vector : vectors) {\r\n            vector.validate();\r\n            messageLength += vector.length;\r\n            if (messageLength < 0) {\r\n                throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors));\r\n            }\r\n        }\r\n        return messageLength;\r\n    }"}, {"ID": 1889, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) { int termWindowLength = termBufferLength / 2; if (0 != defaultTermWindowLength) { termWindowLength = Math.min(defaultTermWindowLength, termWindowLength); } return termWindowLength; }\n\n    ### Response:", "ground_truth": "How far ahead a producer can get from a consumer position.\n\n@param termBufferLength        for when default is not set and considering an appropriate minimum.\n@param defaultTermWindowLength to take priority.\n@return the length to be used for the producer window.", "predict": "/**\r\n     * Calculates the length of the producer window based on the term buffer length and the default term window length.\r\n     *\r\n     * @param termBufferLength      the length of the term buffer in bytes.\r\n     * @param defaultTermWindowLength the default length of the term window in bytes.\r\n     * @return the length of the producer window in bytes.\r\n     */\r\n    public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) {\r\n        int termWindowLength = termBufferLength / 2;\r\n        if (0 != defaultTermWindowLength) {\r\n            termWindowLength = Math.min(defaultTermWindowLength, termWindowLength);\r\n        }\r\n        return termWindowLength;\r\n    }"}, {"ID": 1890, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateSocketBufferLengths(final MediaDriver.Context ctx) { try (DatagramChannel probe = DatagramChannel.open()) { final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE); final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); if (maxSoSndBuf < ctx.socketSndbufLength()) { System.err.format( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.socketSndbufLength(), maxSoSndBuf); } probe.setOption(StandardSocketOptions.SO_RCVBUF, Integer.MAX_VALUE); final int maxSoRcvBuf = probe.getOption(StandardSocketOptions.SO_RCVBUF); if (maxSoRcvBuf < ctx.socketRcvbufLength()) { System.err.format( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_RCVBUF_LENGTH_PROP_NAME, ctx.socketRcvbufLength(), maxSoRcvBuf); } final int soSndBuf = 0 == ctx.socketSndbufLength() ? defaultSoSndBuf : ctx.socketSndbufLength(); if (ctx.mtuLength() > soSndBuf) { throw new ConfigurationException(String.format( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.mtuLength(), soSndBuf)); } if (ctx.initialWindowLength() > maxSoRcvBuf) { throw new ConfigurationException(\"window length greater than socket SO_RCVBUF, increase '\" + Configuration.INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx.initialWindowLength() + \", SO_RCVBUF=\" + maxSoRcvBuf); } } catch (final IOException ex) { throw new AeronException(\"probe socket: \" + ex.toString(), ex); } }\n\n    ### Response:", "ground_truth": "Validate that the socket buffer lengths are sufficient for the media driver configuration.\n\n@param ctx to be validated.", "predict": "/**\n     * Validates the socket buffer lengths for the media driver based on the configuration.\n     *\n     * @param ctx the context for the media driver.\n     * @throws ConfigurationException if the configuration is invalid.\n     * @throws AeronException        if an error occurs probing the socket.\n     */\n    public static void validateSocketBufferLengths(final MediaDriver.Context ctx) {\n        try (DatagramChannel probe = DatagramChannel.open()) {\n            final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF);\n            probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE);\n            final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF);\n            if (maxSoSndBuf < ctx.socketSndbufLength()) {\n                System.err.format(\n                    \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d"}, {"ID": 1891, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validatePageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new ConfigurationException( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new ConfigurationException( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new ConfigurationException(\"page size not a power of 2: \" + pageSize); } }\n\n    ### Response:", "ground_truth": "Validate that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws ConfigurationException if the size is not as expected.", "predict": "/**\r\n     * Validates the page size parameter.\r\n     * \r\n     * @param pageSize the page size to validate\r\n     * @throws ConfigurationException if the page size is less than the minimum allowed size or greater than the maximum allowed size or not a power of 2\r\n     */\r\n    public static void validatePageSize(final int pageSize) {\r\n        if (pageSize < PAGE_MIN_SIZE) {\r\n            throw new ConfigurationException(\"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize);\r\n        }\r\n        if (pageSize > PAGE_MAX_SIZE) {\r\n            throw new ConfigurationException(\"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize);\r\n        }\r\n        if (!BitUtil.isPowerOfTwo(pageSize)) {\r\n            throw new ConfigurationException(\"page size not a power of 2: \" + pageSize);\r\n        }\r\n    }"}, {"ID": 1892, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateSessionIdRange(final int low, final int high) { if (low > high) { throw new ConfigurationException(\"low session id value \" + low + \" must be <= high value \" + high); } if (Math.abs((long)high - low) > Integer.MAX_VALUE) { throw new ConfigurationException(\"reserved range to too large\"); } }\n\n    ### Response:", "ground_truth": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.\n\n@param low  value in the range.\n@param high value in the range.\n@throws ConfigurationException if the values are not valid.", "predict": "/**\r\n     * Validates that the given session id range is valid.\r\n     * \r\n     * @param low the lower bound of the session id range\r\n     * @param high the upper bound of the session id range\r\n     * @throws ConfigurationException if the session id range is invalid\r\n     */\r\n    public static void validateSessionIdRange(final int low, final int high) {\r\n        if (low > high) {\r\n            throw new ConfigurationException(\"low session id value \" + low + \" must be <= high value \" + high);\r\n        }\r\n        if (Math.abs((long)high - low) > Integer.MAX_VALUE) {\r\n            throw new ConfigurationException(\"reserved range to too large\");\r\n        }\r\n    }"}, {"ID": 1893, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateUnblockTimeout( final long publicationUnblockTimeoutNs, final long clientLivenessTimeoutNs, final long timerIntervalNs) { if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) { throw new ConfigurationException( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs); } if (clientLivenessTimeoutNs <= timerIntervalNs) { throw new ConfigurationException( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs); } }\n\n    ### Response:", "ground_truth": "Validate that the timeouts for unblocking publications from a client are valid.\n\n@param publicationUnblockTimeoutNs after which an uncommitted publication will be unblocked.\n@param clientLivenessTimeoutNs     after which a client will be considered not alive.\n@param timerIntervalNs             interval at which the driver will check timeouts.\n@throws ConfigurationException if the values are not valid.", "predict": "/**\r\n     * Validates the unblock timeout configuration parameters.\r\n     * \r\n     * @param publicationUnblockTimeoutNs the publication unblock timeout in nanoseconds.\r\n     * @param clientLivenessTimeoutNs the client liveness timeout in nanoseconds.\r\n     * @param timerIntervalNs the timer interval in nanoseconds.\r\n     * @throws ConfigurationException if the configuration is invalid.\r\n     */\r\n    public static void validateUnblockTimeout( final long publicationUnblockTimeoutNs, final long clientLivenessTimeoutNs, final long timerIntervalNs) {\r\n        if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) {\r\n            throw new ConfigurationException( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs);\r\n        }\r\n        if (clientLivenessTimeoutNs <= timerIntervalNs) {\r\n            throw new ConfigurationException( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs);\r\n        }\r\n    }"}, {"ID": 1894, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ErrorResponseFlyweight errorCode(final ErrorCode code) { buffer.putInt(offset + ERROR_CODE_OFFSET, code.value()); return this; }\n\n    ### Response:", "ground_truth": "Set the error code for the command.\n\n@param code for the error\n@return flyweight", "predict": "/**\n     * Sets the error code in the buffer.\n     *\n     * @param code the error code to set\n     * @return this flyweight object\n     */\n    public ErrorResponseFlyweight errorCode(final ErrorCode code) {\n        buffer.putInt(offset + ERROR_CODE_OFFSET, code.value());\n        return this;\n    }"}, {"ID": 1895, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reset() { isBallotSent = false; isLeader = false; hasRequestedJoin = false; hasSentTerminationAck = false; vote = null; candidateTermId = Aeron.NULL_VALUE; leadershipTermId = Aeron.NULL_VALUE; logPosition = NULL_POSITION; }\n\n    ### Response:", "ground_truth": "Reset the state of a cluster member so it can be canvassed and reestablished.", "predict": "/**\n     * Resets the state of the Raft node to its initial state.\n     */\n    public void reset() {\n        isBallotSent = false;\n        isLeader = false;\n        hasRequestedJoin = false;\n        hasSentTerminationAck = false;\n        vote = null;\n        candidateTermId = Aeron.NULL_VALUE;\n        leadershipTermId = Aeron.NULL_VALUE;\n        logPosition = NULL_POSITION;\n    }"}, {"ID": 1896, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static String encodeAsString(final ClusterMember[] clusterMembers) { final StringBuilder builder = new StringBuilder(); for (int i = 0, length = clusterMembers.length; i < length; i++) { final ClusterMember member = clusterMembers[i]; builder .append(member.id()) .append(',') .append(member.endpointsDetail()); if ((length - 1) != i) { builder.append('|'); } } return builder.toString(); }\n\n    ### Response:", "ground_truth": "Encode member details from a cluster members array to a string.\n\n@param clusterMembers to fill the details from\n@return String representation suitable for use with {@link ClusterMember#parse}", "predict": "/**\r\n     * Encodes the given cluster members as a string.\r\n     *\r\n     * @param clusterMembers the cluster members to encode\r\n     * @return the encoded string\r\n     */\r\n    public static String encodeAsString(final ClusterMember[] clusterMembers) {\r\n        final StringBuilder builder = new StringBuilder();\r\n        for (int i = 0, length = clusterMembers.length; i < length; i++) {\r\n            final ClusterMember member = clusterMembers[i];\r\n            builder.append(member.id())\r\n                    .append(',')\r\n                    .append(member.endpointsDetail());\r\n            if ((length - 1) != i) {\r\n                builder.append('|');\r\n            }\r\n        }\r\n        return builder.toString();\r\n    }"}, {"ID": 1897, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void addMemberStatusPublications( final ClusterMember[] members, final ClusterMember exclude, final ChannelUri channelUri, final int streamId, final Aeron aeron) { for (final ClusterMember member : members) { if (member != exclude) { channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint()); member.publication = aeron.addExclusivePublication(channelUri.toString(), streamId); } } }\n\n    ### Response:", "ground_truth": "Add the publications for sending status messages to the other members of the cluster.\n\n@param members    of the cluster.\n@param exclude    this member when adding publications.\n@param channelUri for the publication.\n@param streamId   for the publication.\n@param aeron      to add the publications to.", "predict": "/**\r\n     * Adds a new publication to each member in the cluster, excluding the specified member.\r\n     *\r\n     * @param members the array of cluster members to add publications to\r\n     * @param exclude the member to exclude from adding publications\r\n     * @param channelUri the channel URI to use for the publications\r\n     * @param streamId the stream ID to use for the publications\r\n     * @param aeron the Aeron instance to use for adding the publications\r\n     */\r\n    public static void addMemberStatusPublications(final ClusterMember[] members, final ClusterMember exclude, final ChannelUri channelUri, final int streamId, final Aeron aeron) {\r\n        for (final ClusterMember member : members) {\r\n            if (member != exclude) {\r\n                channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint());\r\n                member.publication = aeron.addExclusivePublication(channelUri.toString(), streamId);\r\n            }\r\n        }\r\n    }"}, {"ID": 1898, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void closeMemberPublications(final ClusterMember[] clusterMembers) { for (final ClusterMember member : clusterMembers) { CloseHelper.close(member.publication); } }\n\n    ### Response:", "ground_truth": "Close the publications associated with members of the cluster.\n\n@param clusterMembers to close the publications for.", "predict": "/**\r\n     * Closes the publication of each cluster member in the given array.\r\n     * \r\n     * @param clusterMembers\r\n     *            the array of cluster members to close the publication of\r\n     */\r\n    public static void closeMemberPublications(final ClusterMember[] clusterMembers) {\r\n        for (final ClusterMember member : clusterMembers) {\r\n            CloseHelper.close(member.publication);\r\n        }\r\n    }"}, {"ID": 1899, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasActiveQuorum( final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs) { int threshold = quorumThreshold(clusterMembers.length); for (final ClusterMember member : clusterMembers) { if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs)) { if (--threshold <= 0) { return true; } } } return false; }\n\n    ### Response:", "ground_truth": "Check if the cluster leader has an active quorum of cluster followers.\n\n@param clusterMembers for the current cluster.\n@param nowMs          for the current time.\n@param timeoutMs      after which a follower is not considered active.\n@return true if quorum of cluster members are considered active.", "predict": "/**\r\n     * Determines if the cluster has an active quorum of leaders or followers.\r\n     *\r\n     * @param clusterMembers the array of cluster members\r\n     * @param nowMs the current time in milliseconds\r\n     * @param timeoutMs the maximum time in milliseconds that a follower can be behind the leader before it is considered inactive\r\n     * @return true if the cluster has an active quorum of leaders or followers, false otherwise\r\n     */\r\n    public static boolean hasActiveQuorum(final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs) {\r\n        int threshold = quorumThreshold(clusterMembers.length);\r\n        for (final ClusterMember member : clusterMembers) {\r\n            if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs)) {\r\n                if (--threshold <= 0) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1900, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) { final int length = rankedPositions.length; for (int i = 0; i < length; i++) { rankedPositions[i] = 0; } for (final ClusterMember member : members) { long newPosition = member.logPosition; for (int i = 0; i < length; i++) { final long rankedPosition = rankedPositions[i]; if (newPosition > rankedPosition) { rankedPositions[i] = newPosition; newPosition = rankedPosition; } } } return rankedPositions[length - 1]; }\n\n    ### Response:", "ground_truth": "Calculate the position reached by a quorum of cluster members.\n\n@param members         of the cluster.\n@param rankedPositions temp array to be used for sorting the positions to avoid allocation.\n@return the position reached by a quorum of cluster members.", "predict": "/**\r\n     * This method calculates the quorum position for a set of cluster members based on their log positions.\r\n     *\r\n     * @param members an array of cluster members\r\n     * @param rankedPositions an array of longs representing the ranked positions of the cluster members\r\n     * @return the quorum position for the set of cluster members\r\n     */\r\n    public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) {\r\n        final int length = rankedPositions.length;\r\n        for (int i = 0; i < length; i++) {\r\n            rankedPositions[i] = 0;\r\n        }\r\n        for (final ClusterMember member : members) {\r\n            long newPosition = member.logPosition;\r\n            for (int i = 0; i < length; i++) {\r\n                final long rankedPosition = rankedPositions[i];\r\n                if (newPosition > rankedPosition) {\r\n                    rankedPositions[i] = newPosition;\r\n                    newPosition = rankedPosition;\r\n                }\r\n           "}, {"ID": 1901, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) { for (final ClusterMember member : clusterMembers) { member.logPosition(logPosition); } }\n\n    ### Response:", "ground_truth": "Reset the log position of all the members to the provided value.\n\n@param clusterMembers to be reset.\n@param logPosition    to set for them all.", "predict": "/**\r\n     * Resets the log positions of all cluster members to the given log position.\r\n     * \r\n     * @param clusterMembers\r\n     *            the cluster members to reset the log positions for\r\n     * @param logPosition\r\n     *            the log position to reset to\r\n     */\r\n    public static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) {\r\n        for (final ClusterMember member : clusterMembers) {\r\n            member.logPosition(logPosition);\r\n        }\r\n    }"}, {"ID": 1902, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean haveVotersReachedPosition( final ClusterMember[] clusterMembers, final long position, final long leadershipTermId) { for (final ClusterMember member : clusterMembers) { if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Has the members of the cluster the voted reached the provided position in their log.\n\n@param clusterMembers   to check.\n@param position         to compare the {@link #logPosition()} against.\n@param leadershipTermId expected of the members.\n@return true if all members have reached this position otherwise false.", "predict": "/**\r\n     * This method checks if all the voters have reached the given position and leadership term id.\r\n     *\r\n     * @param clusterMembers the array of cluster members\r\n     * @param position the position to check for\r\n     * @param leadershipTermId the leadership term id to check for\r\n     * @return true if all voters have reached the given position and leadership term id, false otherwise\r\n     */\r\n    public static boolean haveVotersReachedPosition(final ClusterMember[] clusterMembers, final long position, final long leadershipTermId) {\r\n        for (final ClusterMember member : clusterMembers) {\r\n            if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1903, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) { int votes = 0; for (final ClusterMember member : members) { if (null == member.vote || member.candidateTermId != candidateTermId) { return false; } votes += member.vote ? 1 : 0; } return votes >= ClusterMember.quorumThreshold(members.length); }\n\n    ### Response:", "ground_truth": "Has the candidate got unanimous support of the cluster?\n\n@param members         to check for votes.\n@param candidateTermId for the vote.\n@return false if any member has not voted for the candidate.", "predict": "/**\r\n     * Checks if the given cluster members have won the vote on the full count of the candidate term.\r\n     *\r\n     * @param members the cluster members to check\r\n     * @param candidateTermId the candidate term id to check for\r\n     * @return true if the cluster members have won the vote on the full count of the candidate term, false otherwise\r\n     */\r\n    public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) {\r\n        int votes = 0;\r\n        for (final ClusterMember member : members) {\r\n            if (null == member.vote || member.candidateTermId != candidateTermId) {\r\n                return false;\r\n            }\r\n            votes += member.vote ? 1 : 0;\r\n        }\r\n        return votes >= ClusterMember.quorumThreshold(members.length);\r\n    }"}, {"ID": 1904, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) { int votes = 0; for (final ClusterMember member : clusterMembers) { if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) { ++votes; } } return votes >= ClusterMember.quorumThreshold(clusterMembers.length); }\n\n    ### Response:", "ground_truth": "Has sufficient votes being counted for a majority?\n\n@param clusterMembers  to check for votes.\n@param candidateTermId for the vote.\n@return true if a majority of positive votes.", "predict": "/**\r\n     * Checks if the majority of the cluster members have voted for the given candidate term id.\r\n     *\r\n     * @param clusterMembers the array of cluster members\r\n     * @param candidateTermId the candidate term id to check for\r\n     * @return true if the majority of the cluster members have voted for the given candidate term id, false otherwise\r\n     */\r\n    public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) {\r\n        int votes = 0;\r\n        for (final ClusterMember member : clusterMembers) {\r\n            if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) {\r\n                ++votes;\r\n            }\r\n        }\r\n        return votes >= ClusterMember.quorumThreshold(clusterMembers.length);\r\n    }"}, {"ID": 1905, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClusterMember determineMember( final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) { ClusterMember member = NULL_VALUE != memberId ? ClusterMember.findMember(clusterMembers, memberId) : null; if ((null == clusterMembers || 0 == clusterMembers.length) && null == member) { member = ClusterMember.parseEndpoints(NULL_VALUE, memberEndpoints); } else { if (null == member) { throw new ClusterException(\"memberId=\" + memberId + \" not found in clusterMembers\"); } if (!\"\".equals(memberEndpoints)) { ClusterMember.validateMemberEndpoints(member, memberEndpoints); } } return member; }\n\n    ### Response:", "ground_truth": "Determine which member of a cluster this is and check endpoints.\n\n@param clusterMembers  for the current cluster which can be null.\n@param memberId        for this member.\n@param memberEndpoints for this member.\n@return the {@link ClusterMember} determined.", "predict": "/**\r\n     * Determines the cluster member based on the memberId or memberEndpoints.\r\n     * \r\n     * @param clusterMembers\r\n     *            the array of cluster members\r\n     * @param memberId\r\n     *            the member id\r\n     * @param memberEndpoints\r\n     *            the member endpoints\r\n     * @return the cluster member\r\n     * @throws ClusterException\r\n     *             if the memberId is not found in the clusterMembers and memberEndpoints is not valid\r\n     */\r\n    public static ClusterMember determineMember(final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) {\r\n        ClusterMember member = NULL_VALUE != memberId ? ClusterMember.findMember(clusterMembers, memberId) : null;\r\n        if ((null == clusterMembers || 0 == clusterMembers.length) && null == member) {\r\n            member = ClusterMember.parseEndpoints(NULL_VALUE, memberEndpoints);\r\n        } else {\r\n            if (null == member) {\r\n                throw new ClusterException(\"memberId=\" + memberId + \" not found in clusterMembers\");\r\n            }"}, {"ID": 1906, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) { final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints); if (!areSameEndpoints(member, endpointMember)) { throw new ClusterException( \"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints); } }\n\n    ### Response:", "ground_truth": "Check the member with the memberEndpoints\n\n@param member          to check memberEndpoints against\n@param memberEndpoints to check member against\n@see ConsensusModule.Context#memberEndpoints()\n@see ConsensusModule.Context#clusterMembers()", "predict": "/**\r\n     * Validates that the given member's endpoints match the given member endpoints.\r\n     *\r\n     * @param member the cluster member to validate.\r\n     * @param memberEndpoints the member endpoints to validate against.\r\n     * @throws ClusterException if the member endpoints do not match.\r\n     */\r\n    public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) {\r\n        final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints);\r\n        if (!areSameEndpoints(member, endpointMember)) {\r\n            throw new ClusterException(\"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints);\r\n        }\r\n    }"}, {"ID": 1907, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) { return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint()); }\n\n    ### Response:", "ground_truth": "Are two cluster members using the same endpoints?\n\n@param lhs to check\n@param rhs to check\n@return true if both are using the same endpoints or false if not.", "predict": "/**\r\n     * This method checks if two ClusterMembers have the same clientFacingEndpoint, memberFacingEndpoint, logEndpoint, transferEndpoint, and archiveEndpoint.\r\n     * \r\n     * @param lhs The first ClusterMember to compare.\r\n     * @param rhs The second ClusterMember to compare.\r\n     * @return True if the ClusterMembers have the same endpoints, false otherwise.\r\n     */\r\n    public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) {\r\n        return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint());\r\n    }"}, {"ID": 1908, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Has the member achieved a unanimous view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": "/**\r\n     * This method checks if the candidate is unanimous among the cluster members.\r\n     * \r\n     * @param clusterMembers\r\n     *            The array of cluster members.\r\n     * @param candidate\r\n     *            The candidate to check.\r\n     * @return True if the candidate is unanimous, false otherwise.\r\n     */\r\n    public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) {\r\n        for (final ClusterMember member : clusterMembers) {\r\n            if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1909, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { int possibleVotes = 0; for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { continue; } ++possibleVotes; } return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length); }\n\n    ### Response:", "ground_truth": "Has the member achieved a quorum view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": "/**\r\n     * Determines if a candidate is a quorum candidate based on the current cluster members and the candidate's log position.\r\n     *\r\n     * @param clusterMembers the current cluster members\r\n     * @param candidate the candidate to be checked for quorum\r\n     * @return true if the candidate is a quorum candidate, false otherwise\r\n     */\r\n    public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) {\r\n        int possibleVotes = 0;\r\n        for (final ClusterMember member : clusterMembers) {\r\n            if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) {\r\n                continue;\r\n            }\r\n            ++possibleVotes;\r\n        }\r\n        return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length);\r\n    }"}, {"ID": 1910, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isNotDuplicateEndpoints(final ClusterMember[] members, final String memberEndpoints) { for (final ClusterMember member : members) { if (member.endpointsDetail().equals(memberEndpoints)) { return false; } } return true; }\n\n    ### Response:", "ground_truth": "Is the string of member endpoints not duplicated in the members.\n\n@param members         to check if the provided endpoints have a duplicate.\n@param memberEndpoints to check for duplicates.\n@return true if no duplicate is found otherwise false.", "predict": "/**\r\n     * This method checks if the given member endpoints are not already present in the given list of members.\r\n     * \r\n     * @param members\r\n     *            The list of cluster members.\r\n     * @param memberEndpoints\r\n     *            The endpoints of the member to be checked.\r\n     * @return True if the member endpoints are not already present in the list of members, false otherwise.\r\n     */\r\n    public static boolean isNotDuplicateEndpoints(final ClusterMember[] members, final String memberEndpoints) {\r\n        for (final ClusterMember member : members) {\r\n            if (member.endpointsDetail().equals(memberEndpoints)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }"}, {"ID": 1911, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) { final int length = clusterMembers.length; int index = ArrayUtil.UNKNOWN_INDEX; for (int i = 0; i < length; i++) { if (clusterMembers[i].id() == memberId) { index = i; } } return index; }\n\n    ### Response:", "ground_truth": "Find the index at which a member id is present.\n\n@param clusterMembers to be searched.\n@param memberId       to search for.\n@return the index at which the member id is found otherwise {@link ArrayUtil#UNKNOWN_INDEX}.", "predict": "/**\r\n     * Finds the index of the member with the given ID in the given cluster members array.\r\n     * \r\n     * @param clusterMembers the array of cluster members to search in\r\n     * @param memberId the ID of the member to find\r\n     * @return the index of the member with the given ID, or {@link ArrayUtil#UNKNOWN_INDEX} if not found\r\n     */\r\n    public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) {\r\n        final int length = clusterMembers.length;\r\n        int index = ArrayUtil.UNKNOWN_INDEX;\r\n        for (int i = 0; i < length; i++) {\r\n            if (clusterMembers[i].id() == memberId) {\r\n                index = i;\r\n            }\r\n        }\r\n        return index;\r\n    }"}, {"ID": 1912, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static ClusterMember[] removeMember(final ClusterMember[] oldMembers, final int memberId) { return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId)); }\n\n    ### Response:", "ground_truth": "Remove a member from an array if found, otherwise return the array unmodified.\n\n@param oldMembers to remove a member from.\n@param memberId   of the member to remove.\n@return a new array with the member removed or the existing array if not found.", "predict": "/**\r\n     * Removes a member from the given array of cluster members based on the member ID.\r\n     *\r\n     * @param oldMembers the array of cluster members to remove the member from\r\n     * @param memberId the ID of the member to remove\r\n     * @return the updated array of cluster members with the member removed\r\n     */\r\n    public static ClusterMember[] removeMember(final ClusterMember[] oldMembers, final int memberId) {\r\n        return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId));\r\n    }"}, {"ID": 1913, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; }\n\n    ### Response:", "ground_truth": "Find the highest member id in an array of members.\n\n@param clusterMembers to search for the highest id.\n@return the highest id otherwise {@link Aeron#NULL_VALUE} if empty.", "predict": "/**\r\n     * Returns the highest id of the given cluster members.\r\n     *\r\n     * @param clusterMembers the array of cluster members to check\r\n     * @return the highest id of the given cluster members\r\n     */\r\n    public static int highMemberId(final ClusterMember[] clusterMembers) {\r\n        int highId = Aeron.NULL_VALUE;\r\n        for (final ClusterMember member : clusterMembers) {\r\n            highId = Math.max(highId, member.id());\r\n        }\r\n        return highId;\r\n    }"}, {"ID": 1914, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public MappedByteBuffer mapExistingCncFile(final Consumer<String> logger) { final File cncFile = new File(aeronDirectory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { if (null != logger) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); } return IoUtil.mapExistingFile(cncFile, CncFileDescriptor.CNC_FILE); } return null; }\n\n    ### Response:", "ground_truth": "Map the CnC file if it exists.\n\n@param logger for feedback\n@return a new mapping for the file if it exists otherwise null;", "predict": "/**\r\n     * Maps the existing CnC file in the Aeron directory.\r\n     *\r\n     * @param logger the logger to use for logging any messages.\r\n     * @return the mapped byte buffer of the CnC file or null if it does not exist or is empty.\r\n     */\r\n    public MappedByteBuffer mapExistingCncFile(final Consumer<String> logger) {\r\n        final File cncFile = new File(aeronDirectory, CncFileDescriptor.CNC_FILE);\r\n        if (cncFile.exists() && cncFile.length() > 0) {\r\n            if (null != logger) {\r\n                logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile);\r\n            }\r\n            return IoUtil.mapExistingFile(cncFile, CncFileDescriptor.CNC_FILE);\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1915, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isDriverActive( final File directory, final long driverTimeoutMs, final Consumer<String> logger) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } return false; }\n\n    ### Response:", "ground_truth": "Is a media driver active in the given directory?\n\n@param directory       to check\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": "/**\r\n     * Checks if the driver is active by checking the CnC file.\r\n     *\r\n     * @param directory           the directory where the CnC file is located.\r\n     * @param driverTimeoutMs     the timeout in milliseconds for the driver to become active.\r\n     * @param logger              the logger to use for logging messages.\r\n     * @return true if the driver is active, false otherwise.\r\n     */\r\n    public static boolean isDriverActive(final File directory, final long driverTimeoutMs, final Consumer<String> logger) {\r\n        final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE);\r\n        if (cncFile.exists() && cncFile.length() > 0) {\r\n            logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile);\r\n            final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\");\r\n            try {\r\n                return isDriverActive(driverTimeoutMs, logger, cnc"}, {"ID": 1916, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger) { final MappedByteBuffer cncByteBuffer = mapExistingCncFile(logger); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } }\n\n    ### Response:", "ground_truth": "Is a media driver active in the current Aeron directory?\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": "/**\r\n     * Checks if the driver is active by reading the CNC file and checking the timestamp.\r\n     *\r\n     * @param driverTimeoutMs the timeout in milliseconds to wait for the driver to become active\r\n     * @param logger the logger to use for logging any errors or warnings\r\n     * @return true if the driver is active, false otherwise\r\n     */\r\n    public boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger) {\r\n        final MappedByteBuffer cncByteBuffer = mapExistingCncFile(logger);\r\n        try {\r\n            return isDriverActive(driverTimeoutMs, logger, cncByteBuffer);\r\n        } finally {\r\n            IoUtil.unmap(cncByteBuffer);\r\n        }\r\n    }"}, {"ID": 1917, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isDriverActive( final long driverTimeoutMs, final Consumer<String> logger, final ByteBuffer cncByteBuffer) { if (null == cncByteBuffer) { return false; } final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final long startTimeMs = System.currentTimeMillis(); int cncVersion; while (0 == (cncVersion = cncMetaDataBuffer.getIntVolatile(CncFileDescriptor.cncVersionOffset(0)))) { if (System.currentTimeMillis() > (startTimeMs + driverTimeoutMs)) { throw new DriverTimeoutException(\"CnC file is created but not initialised.\"); } sleep(1); } if (CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long timestamp = toDriverBuffer.consumerHeartbeatTime(); final long now = System.currentTimeMillis(); final long timestampAge = now - timestamp; logger.accept(\"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge); return timestampAge <= driverTimeoutMs; }\n\n    ### Response:", "ground_truth": "Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait for\nup to the driverTimeoutMs by checking for the cncVersion being set.\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@param cncByteBuffer   for the existing CnC file.\n@return true if a driver is active or false if not.", "predict": "/**\n     * Checks if the driver is active by checking the CnC file version and the age of the toDriver consumer heartbeat.\n     *\n     * @param driverTimeoutMs   the timeout in milliseconds for the driver to become active.\n     * @param logger            the logger to use for logging messages.\n     * @param cncByteBuffer     the CnC file buffer.\n     * @return true if the driver is active, false otherwise.\n     * @throws DriverTimeoutException if the driver is not active within the specified timeout.\n     * @throws AeronException         if the CnC file version does not match the required version.\n     */\n    public static boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger, final ByteBuffer cncByteBuffer) {\n        if (null == cncByteBuffer) {\n            return false;\n        }\n\n        final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer);\n        final long startTimeMs = System.currentTimeMillis();\n        int cncVersion;\n        while ("}, {"ID": 1918, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean requestDriverTermination( final File directory, final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final int cncVersion = cncMetaDataBuffer.getIntVolatile(cncVersionOffset(0)); if (CncFileDescriptor.CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long clientId = toDriverBuffer.nextCorrelationId(); final DriverProxy driverProxy = new DriverProxy(toDriverBuffer, clientId); return driverProxy.terminateDriver(tokenBuffer, tokenOffset, tokenLength); } finally { IoUtil.unmap(cncByteBuffer); } } return false; }\n\n    ### Response:", "ground_truth": "Request a driver to run its termination hook.\n\n@param directory for the driver.\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return true if request was sent or false if request could not be sent.", "predict": "/**\n     * Requests the termination of the media driver by sending a message to the driver.\n     *\n     * @param directory      the directory in which the media driver is running.\n     * @param tokenBuffer    containing the token to be sent to the driver.\n     * @param tokenOffset    at which the token begins.\n     * @param tokenLength    of the token in bytes.\n     * @return true if the driver has been terminated, false if not.\n     */\n    public static boolean requestDriverTermination(final File directory, final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) {\n        final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE);\n        if (cncFile.exists() && cncFile.length() > 0) {\n            final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\");\n            try {\n                final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer"}, {"ID": 1919, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) { int frameLength = buffer.getIntVolatile(termOffset); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } return frameLength; }\n\n    ### Response:", "ground_truth": "Get the length of a frame from the header as a volatile read.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@return the value for the frame length.", "predict": "/**\n     * This method retrieves the frame length from the term buffer at the given offset.\n     *\n     * @param buffer the term buffer from which to retrieve the frame length.\n     * @param termOffset the offset in the term buffer at which the frame length is stored.\n     * @return the frame length stored in the term buffer.\n     */\n    public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) {\n        int frameLength = buffer.getIntVolatile(termOffset);\n        if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\n            frameLength = Integer.reverseBytes(frameLength);\n        }\n        return frameLength;\n    }"}, {"ID": 1920, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength) { int length = frameLength; if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { length = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(termOffset, length); }\n\n    ### Response:", "ground_truth": "Write the length header for a frame in a memory ordered fashion.\n\n@param buffer      containing the frame.\n@param termOffset  at which a frame begins.\n@param frameLength field to be set for the frame.", "predict": "/**\n     * This method is used to write the frame length to the term buffer in the correct byte order.\n     *\n     * @param buffer the buffer to write to\n     * @param termOffset the offset in the buffer to write to\n     * @param frameLength the length of the frame to write\n     */\n    public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength) {\n        int length = frameLength;\n        if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\n            length = Integer.reverseBytes(frameLength);\n        }\n        buffer.putIntOrdered(termOffset, length);\n    }"}, {"ID": 1921, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) { buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the type field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param type       type value for the frame.", "predict": "/**\n     * Sets the frame type for the specified term offset in the buffer.\n     *\n     * @param buffer the buffer to update.\n     * @param termOffset the offset of the term to update.\n     * @param type the frame type to set.\n     */\n    public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) {\n        buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN);\n    }"}, {"ID": 1922, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) { buffer.putByte(flagsOffset(termOffset), flags); }\n\n    ### Response:", "ground_truth": "Write the flags field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param flags      value for the frame.", "predict": "/**\n     * Sets the flags for a given term in the term buffer.\n     *\n     * @param buffer     the term buffer to update.\n     * @param termOffset the offset in the term buffer of the term to update.\n     * @param flags      the new flags to set.\n     */\n    public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) {\n        buffer.putByte(flagsOffset(termOffset), flags);\n    }"}, {"ID": 1923, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) { buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the term offset field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.", "predict": "/**\n     * This method is used to set the term offset in the frame header of the log buffer.\n     * \n     * @param buffer The log buffer to set the term offset in.\n     * @param termOffset The term offset to set.\n     */\n    public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) {\n        buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN);\n    }"}, {"ID": 1924, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); }\n\n    ### Response:", "ground_truth": "Write the term id field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param termId     value for the frame.", "predict": "/**\n     * This method is used to write the termId to the termOffset in the buffer.\n     * \n     * @param buffer - The buffer to write the termId to.\n     * @param termOffset - The offset in the buffer to write the termId to.\n     * @param termId - The termId to write to the buffer.\n     */\n    public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); }"}, {"ID": 1925, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for a stream based on the recording id.\n\n@param countersReader to search within.\n@param recordingId    for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": "/**\r\n     * Finds the counter id for a given recording id.\r\n     *\r\n     * @param countersReader the counters reader to use\r\n     * @param recordingId the recording id to search for\r\n     * @return the counter id for the given recording id, or NULL_COUNTER_ID if not found\r\n     */\r\n    public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) {\r\n        final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n        for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) {\r\n            if (countersReader.getCounterState(i) == RECORD_ALLOCATED) {\r\n                final int recordOffset = CountersReader.metaDataOffset(i);\r\n                if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) {\r\n                    return i;\r\n                }\r\n            }"}, {"ID": 1926, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for a stream based on the session id.\n\n@param countersReader to search within.\n@param sessionId      for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": "/**\r\n     * Finds the counter id for the given session id in the given counters reader.\r\n     *\r\n     * @param countersReader the counters reader to search for the counter id.\r\n     * @param sessionId the session id to search for.\r\n     * @return the counter id for the given session id, or NULL_COUNTER_ID if not found.\r\n     */\r\n    public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) {\r\n        final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n        for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) {\r\n            if (countersReader.getCounterState(i) == RECORD_ALLOCATED) {\r\n                final int recordOffset = CountersReader.metaDataOffset(i);\r\n                if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) {\r\n                   "}, {"ID": 1927, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getRecordingId(final CountersReader countersReader, final int counterId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) { return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET); } } return NULL_RECORDING_ID; }\n\n    ### Response:", "ground_truth": "Get the recording id for a given counter id.\n\n@param countersReader to search within.\n@param counterId      for the active recording.\n@return the counter id if found otherwise {@link #NULL_RECORDING_ID}.", "predict": "/**\r\n     * Returns the recording id for the given counter id.\r\n     *\r\n     * @param countersReader the counters reader\r\n     * @param counterId the counter id\r\n     * @return the recording id for the given counter id, or NULL_RECORDING_ID if the counter is not a recording position\r\n     */\r\n    public static long getRecordingId(final CountersReader countersReader, final int counterId) {\r\n        final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n        if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(counterId);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) {\r\n                return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET);\r\n            }\r\n        }\r\n        return NULL_RECORDING_ID;\r\n    }"}, {"ID": 1928, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean isActive(final CountersReader countersReader, final int counterId, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); return buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId; } return false; }\n\n    ### Response:", "ground_truth": "Is the recording counter still active.\n\n@param countersReader to search within.\n@param counterId      to search for.\n@param recordingId    to confirm it is still the same value.\n@return true if the counter is still active otherwise false.", "predict": "/**\r\n     * Checks if a counter is active for a given recording.\r\n     *\r\n     * @param countersReader the counters reader to use\r\n     * @param counterId the id of the counter to check\r\n     * @param recordingId the id of the recording to check\r\n     * @return true if the counter is active for the given recording, false otherwise\r\n     */\r\n    public static boolean isActive(final CountersReader countersReader, final int counterId, final long recordingId) {\r\n        final DirectBuffer buffer = countersReader.metaDataBuffer();\r\n        if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(counterId);\r\n            return buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID &&\r\n                   buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId;\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1929, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) { frameLength(HEADER_LENGTH + length); putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length); return this; }\n\n    ### Response:", "ground_truth": "Set the Application Specific Feedback for the Status Message.\n\n@param source of the feedback to set\n@param offset of the feedback in the source\n@param length of the feedback in bytes\n@return flyweight", "predict": "/**\r\n     * This method is used to set the application specific feedback field of the StatusMessageFlyweight.\r\n     * \r\n     * @param source - The byte array containing the application specific feedback.\r\n     * @param offset - The offset in the byte array where the application specific feedback starts.\r\n     * @param length - The length of the application specific feedback.\r\n     * @return The updated StatusMessageFlyweight object.\r\n     */\r\n    public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) {\r\n        frameLength(HEADER_LENGTH + length);\r\n        putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length);\r\n        return this;\r\n    }"}, {"ID": 1930, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void reload() { entries.clear(); indexByLeadershipTermIdMap.clear(); indexByLeadershipTermIdMap.compact(); nextEntryIndex = 0; byteBuffer.clear(); try { while (true) { final int bytes = fileChannel.read(byteBuffer); if (byteBuffer.remaining() == 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } if (-1 == bytes) { if (byteBuffer.position() > 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } break; } } } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response:", "ground_truth": "Reload the log from disk.", "predict": "/**\n     * Reloads the entries from the log file.\n     */\n    public void reload() {\n        entries.clear();\n        indexByLeadershipTermIdMap.clear();\n        indexByLeadershipTermIdMap.compact();\n        nextEntryIndex = 0;\n        byteBuffer.clear();\n        try {\n            while (true) {\n                final int bytes = fileChannel.read(byteBuffer);\n                if (byteBuffer.remaining() == 0) {\n                    byteBuffer.flip();\n                    captureEntriesFromBuffer(byteBuffer, buffer, entries);\n                    byteBuffer.clear();\n                }\n                if (-1 == bytes) {\n                    if (byteBuffer.position() > 0) {\n                        byteBuffer.flip();\n                        captureEntriesFromBuffer(byteBuffer, buffer, entries);\n                        byteBuffer.clear();\n                    }\n                    break;\n                }\n            }\n        } catch (final IOException ex) {\n            LangUtil.rethrowUnchecked(ex);\n        }\n    }"}, {"ID": 1931, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Entry findLastTerm() { for (int i = entries.size() - 1; i >= 0; i--) { final Entry entry = entries.get(i); if (ENTRY_TYPE_TERM == entry.type) { return entry; } } return null; }\n\n    ### Response:", "ground_truth": "Find the last leadership term in the recording log.\n\n@return the last leadership term in the recording log.", "predict": "/**\r\n     * Finds the last term entry in the list of entries.\r\n     * \r\n     * @return the last term entry, or null if no term entry is found.\r\n     */\r\n    public Entry findLastTerm() {\r\n        for (int i = entries.size() - 1; i >= 0; i--) {\r\n            final Entry entry = entries.get(i);\r\n            if (ENTRY_TYPE_TERM == entry.type) {\r\n                return entry;\r\n            }\r\n        }\r\n        return null;\r\n    }"}, {"ID": 1932, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public RecoveryPlan createRecoveryPlan(final AeronArchive archive, final int serviceCount) { final ArrayList<Snapshot> snapshots = new ArrayList<>(); final ArrayList<Log> logs = new ArrayList<>(); planRecovery(snapshots, logs, entries, archive, serviceCount); long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } if (!logs.isEmpty()) { final Log log = logs.get(0); lastLeadershipTermId = log.leadershipTermId; lastTermBaseLogPosition = log.termBaseLogPosition; appendedLogPosition = log.stopPosition; committedLogPosition = log.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, logs); }\n\n    ### Response:", "ground_truth": "Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the\nlatest stable state.\n\n@param archive      to lookup recording descriptors.\n@param serviceCount of services that may have snapshots.\n@return a new {@link RecoveryPlan} for the cluster.", "predict": "/**\r\n     * Creates a recovery plan for a given AeronArchive and service count.\r\n     *\r\n     * @param archive the AeronArchive to recover from.\r\n     * @param serviceCount the number of services to recover.\r\n     * @return the recovery plan.\r\n     */\r\n    public RecoveryPlan createRecoveryPlan(final AeronArchive archive, final int serviceCount) {\r\n        final ArrayList<Snapshot> snapshots = new ArrayList<>();\r\n        final ArrayList<Log> logs = new ArrayList<>();\r\n        planRecovery(snapshots, logs, entries, archive, serviceCount);\r\n        long lastLeadershipTermId = NULL_VALUE;\r\n        long lastTermBaseLogPosition = 0;\r\n        long committedLogPosition = -1;\r\n        long appendedLogPosition = 0;\r\n        final int snapshotStepsSize = snapshots.size();\r\n        if (snapshotStepsSize > 0) {\r\n            final Snapshot snapshot = snapshots.get(0);\r\n            lastLeadershipTermId = snapshot.leadershipTermId;\r\n            lastTermBaseLogPosition = snapshot.termBaseLogPosition;\r\n            appended"}, {"ID": 1933, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) { long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new ArrayList<>()); }\n\n    ### Response:", "ground_truth": "Create a recovery plan that has only snapshots. Used for dynamicJoin snapshot load.\n\n@param snapshots to construct plan from\n@return a new {@link RecoveryPlan} for the cluster", "predict": "/**\n     * Creates a recovery plan based on the given list of snapshots.\n     *\n     * @param snapshots the list of snapshots to use for recovery\n     * @return the recovery plan\n     */\n    public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) {\n        long lastLeadershipTermId = NULL_VALUE;\n        long lastTermBaseLogPosition = 0;\n        long committedLogPosition = -1;\n        long appendedLogPosition = 0;\n        final int snapshotStepsSize = snapshots.size();\n        if (snapshotStepsSize > 0) {\n            final RecordingLog.Snapshot snapshot = snapshots.get(0);\n            lastLeadershipTermId = snapshot.leadershipTermId;\n            lastTermBaseLogPosition = snapshot.termBaseLogPosition;\n            appendedLogPosition = snapshot.logPosition;\n            committedLogPosition = snapshot.logPosition;\n        }\n        return new RecoveryPlan(lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new"}, {"ID": 1934, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void appendTerm( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { final int size = entries.size(); if (size > 0) { final Entry lastEntry = entries.get(size - 1); if (lastEntry.type != NULL_VALUE && lastEntry.leadershipTermId >= leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + lastEntry.leadershipTermId + \" this \" + leadershipTermId); } } indexByLeadershipTermIdMap.put(leadershipTermId, nextEntryIndex); append( ENTRY_TYPE_TERM, recordingId, leadershipTermId, termBaseLogPosition, NULL_POSITION, timestamp, NULL_VALUE); }\n\n    ### Response:", "ground_truth": "Append a log entry for a leadership term.\n\n@param recordingId         of the log.\n@param leadershipTermId    for the current term.\n@param termBaseLogPosition reached at the beginning of the term.\n@param timestamp           at the beginning of the term.", "predict": "/**\n     * Appends a new term entry to the log.\n     *\n     * @param recordingId           the recording id of the term.\n     * @param leadershipTermId      the leadership term id of the term.\n     * @param termBaseLogPosition   the base log position of the term.\n     * @param timestamp             the timestamp of the term.\n     * @throws ClusterException if the leadershipTermId is out of sequence.\n     */\n    public void appendTerm(final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) {\n        final int size = entries.size();\n        if (size > 0) {\n            final Entry lastEntry = entries.get(size - 1);\n            if (lastEntry.type != NULL_VALUE && lastEntry.leadershipTermId >= leadershipTermId) {\n                throw new ClusterException(\"leadershipTermId out of sequence: previous \" + lastEntry.leadershipTermId + \" this \" + leadershipTerm"}, {"ID": 1935, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) { final Entry entry = entries.get(size - 1); if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + entry.leadershipTermId + \" this \" + leadershipTermId); } } append( ENTRY_TYPE_SNAPSHOT, recordingId, leadershipTermId, termBaseLogPosition, logPosition, timestamp, serviceId); }\n\n    ### Response:", "ground_truth": "Append a log entry for a snapshot.\n\n@param recordingId         in the archive for the snapshot.\n@param leadershipTermId    for the current term\n@param termBaseLogPosition at the beginning of the leadership term.\n@param logPosition         for the position in the current term or length so far for that term.\n@param timestamp           at which the snapshot was taken.\n@param serviceId           for which the snapshot is recorded.", "predict": "/**\n     * Appends a snapshot entry to the log.\n     *\n     * @param recordingId the recording id of the snapshot.\n     * @param leadershipTermId the leadership term id of the snapshot.\n     * @param termBaseLogPosition the term base log position of the snapshot.\n     * @param logPosition the log position of the snapshot.\n     * @param timestamp the timestamp of the snapshot.\n     * @param serviceId the service id of the snapshot.\n     * @throws ClusterException if the leadership term id is out of sequence.\n     */\n    public void appendSnapshot(final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) {\n        final int size = entries.size();\n        if (size > 0) {\n            final Entry entry = entries.get(size - 1);\n            if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) {"}, {"ID": 1936, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void commitLogPosition(final long leadershipTermId, final long logPosition) { final int index = getLeadershipTermEntryIndex(leadershipTermId); commitEntryValue(index, logPosition, LOG_POSITION_OFFSET); final Entry entry = entries.get(index); entries.set(index, new Entry( entry.recordingId, entry.leadershipTermId, entry.termBaseLogPosition, logPosition, entry.timestamp, entry.serviceId, entry.type, entry.entryIndex)); }\n\n    ### Response:", "ground_truth": "Commit the position reached in a leadership term before a clean shutdown.\n\n@param leadershipTermId for committing the term position reached.\n@param logPosition      reached in the leadership term.", "predict": "/**\n     * Commits the log position for the given leadership term.\n     *\n     * @param leadershipTermId the leadership term id for which the log position is being committed.\n     * @param logPosition      the log position to be committed.\n     */\n    public void commitLogPosition(final long leadershipTermId, final long logPosition) {\n        final int index = getLeadershipTermEntryIndex(leadershipTermId);\n        commitEntryValue(index, logPosition, LOG_POSITION_OFFSET);\n        final Entry entry = entries.get(index);\n        entries.set(index, new Entry(entry.recordingId, entry.leadershipTermId, entry.termBaseLogPosition, logPosition, entry.timestamp, entry.serviceId, entry.type, entry.entryIndex));\n    }"}, {"ID": 1937, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void tombstoneEntry(final long leadershipTermId, final int entryIndex) { int index = -1; for (int i = 0, size = entries.size(); i < size; i++) { final Entry entry = entries.get(i); if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) { index = entry.entryIndex; if (ENTRY_TYPE_TERM == entry.type) { indexByLeadershipTermIdMap.remove(leadershipTermId); } break; } } if (-1 == index) { throw new ClusterException(\"unknown entry index: \" + entryIndex); } buffer.putInt(0, NULL_VALUE, LITTLE_ENDIAN); byteBuffer.limit(SIZE_OF_INT).position(0); final long filePosition = (index * (long)ENTRY_LENGTH) + ENTRY_TYPE_OFFSET; try { if (SIZE_OF_INT != fileChannel.write(byteBuffer, filePosition)) { throw new ClusterException(\"failed to write field atomically\"); } } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } }\n\n    ### Response:", "ground_truth": "Tombstone an entry in the log so it is no longer valid.\n\n@param leadershipTermId to match for validation.\n@param entryIndex       reached in the leadership term.", "predict": "/**\n     * Updates the tombstone entry for the given leadership term and entry index.\n     *\n     * @param leadershipTermId the leadership term id of the entry to update.\n     * @param entryIndex       the entry index of the entry to update.\n     * @throws ClusterException if the entry is not found or if the update fails.\n     */\n    public void tombstoneEntry(final long leadershipTermId, final int entryIndex) {\n        int index = -1;\n        for (int i = 0, size = entries.size(); i < size; i++) {\n            final Entry entry = entries.get(i);\n            if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) {\n                index = entry.entryIndex;\n                if (ENTRY_TYPE_TERM == entry.type) {\n                    indexByLeadershipTermIdMap.remove(leadershipTermId);\n                }\n                break;\n            }\n        }\n        if (-1 == index) {"}, {"ID": 1938, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { if (null != publication && publication.isConnected()) { closeSession(); } if (!ctx.ownsAeronClient()) { CloseHelper.close(subscription); CloseHelper.close(publication); } ctx.close(); }\n\n    ### Response:", "ground_truth": "Close session and release associated resources.", "predict": "/**\r\n     * Closes the Aeron client and releases any associated resources.\r\n     *\r\n     * @throws Exception if an error occurs while closing the client.\r\n     */\r\n    public void close() throws Exception {\r\n        if (null != publication && publication.isConnected()) {\r\n            closeSession();\r\n        }\r\n        if (!ctx.ownsAeronClient()) {\r\n            CloseHelper.close(subscription);\r\n            CloseHelper.close(publication);\r\n        }\r\n        ctx.close();\r\n    }"}, {"ID": 1939, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBufferVector[] vectors) { if (headerVector != vectors[0]) { vectors[0] = headerVector; } return publication.offer(vectors, null); }\n\n    ### Response:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message. The first vector will be replaced by the cluster\ningress header so must be left unused.\n\n@param vectors which make up the message.\n@return the same as {@link Publication#offer(DirectBufferVector[])}.\n@see Publication#offer(DirectBufferVector[])", "predict": "/**\r\n * Offers a set of buffers to the publisher.\r\n *\r\n * @param vectors the buffers to offer\r\n * @return the sequence number of the offer\r\n */\r\npublic long offer(final DirectBufferVector[] vectors) {\r\n    if (headerVector != vectors[0]) {\r\n        vectors[0] = headerVector;\r\n    }\r\n    return publication.offer(vectors, null);\r\n}"}, {"ID": 1940, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean unblock( final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) { final int positionBitsToShift = LogBufferDescriptor.positionBitsToShift(termLength); final int blockedTermCount = (int)(blockedPosition >> positionBitsToShift); final int blockedOffset = (int)blockedPosition & (termLength - 1); final int activeTermCount = activeTermCount(logMetaDataBuffer); if (activeTermCount == (blockedTermCount - 1) && blockedOffset == 0) { final int currentTermId = termId(rawTailVolatile(logMetaDataBuffer, indexByTermCount(activeTermCount))); return rotateLog(logMetaDataBuffer, activeTermCount, currentTermId); } final int blockedIndex = indexByTermCount(blockedTermCount); final long rawTail = rawTailVolatile(logMetaDataBuffer, blockedIndex); final int termId = termId(rawTail); final int tailOffset = termOffset(rawTail, termLength); final UnsafeBuffer termBuffer = termBuffers[blockedIndex]; switch (TermUnblocker.unblock(logMetaDataBuffer, termBuffer, blockedOffset, tailOffset, termId)) { case UNBLOCKED_TO_END: rotateLog(logMetaDataBuffer, blockedTermCount, termId); // fall through case UNBLOCKED: return true; } return false; }\n\n    ### Response:", "ground_truth": "Attempt to unblock a log buffer at given position\n\n@param termBuffers       for current blockedOffset\n@param logMetaDataBuffer for log buffer\n@param blockedPosition   to attempt to unblock\n@param termLength        of the buffer for each term in the log\n@return whether unblocked or not", "predict": "/**\n     * Unblocks a term by rotating the log and updating the term tail.\n     *\n     * @param termBuffers the term buffers to use for unblocking.\n     * @param logMetaDataBuffer the log meta data buffer to use for unblocking.\n     * @param blockedPosition the position of the blocked term.\n     * @param termLength the length of each term in the log.\n     * @return true if the term was unblocked successfully, false otherwise.\n     */\n    public static boolean unblock(final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) {\n        final int positionBitsToShift = LogBufferDescriptor.positionBitsToShift(termLength);\n        final int blockedTermCount = (int) (blockedPosition >> positionBitsToShift);\n        final int blockedOffset = (int) blockedPosition & (termLength - 1);\n        final int activeTermCount = activeTermCount(logMetaDataBuffer);\n\n        if (activeTermCount == (blockedTermCount"}, {"ID": 1941, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public String channel() { final int length = buffer.getInt(offset + CHANNEL_OFFSET); lengthOfChannel = SIZE_OF_INT + length; return buffer.getStringAscii(offset + CHANNEL_OFFSET, length); }\n\n    ### Response:", "ground_truth": "Get the channel field as ASCII\n\n@return channel field", "predict": "/**\r\n     * Returns the channel name of the message.\r\n     * \r\n     * @return the channel name of the message\r\n     */\r\n    public String channel() {\r\n        final int length = buffer.getInt(offset + CHANNEL_OFFSET);\r\n        lengthOfChannel = SIZE_OF_INT + length;\r\n        return buffer.getStringAscii(offset + CHANNEL_OFFSET, length);\r\n    }"}, {"ID": 1942, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public ImageMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; }\n\n    ### Response:", "ground_truth": "Set the channel field as ASCII\n\n@param channel field value\n@return flyweight", "predict": "/**\n     * Sets the channel for the image message flyweight.\n     *\n     * @param channel the channel for the image message flyweight\n     * @return the updated image message flyweight\n     */\n    public ImageMessageFlyweight channel(final String channel) {\n        lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel);\n        return this;\n    }"}, {"ID": 1943, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkTermLength(final int termLength) { if (termLength < TERM_MIN_LENGTH) { throw new IllegalStateException( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength); } if (termLength > TERM_MAX_LENGTH) { throw new IllegalStateException( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength); } if (!BitUtil.isPowerOfTwo(termLength)) { throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength); } }\n\n    ### Response:", "ground_truth": "Check that term length is valid and alignment is valid.\n\n@param termLength to be checked.\n@throws IllegalStateException if the length is not as expected.", "predict": "/**\r\n     * Checks if the given term length is within the allowed range and is a power of 2.\r\n     *\r\n     * @param termLength the length of the term to check\r\n     * @throws IllegalStateException if the term length is less than the minimum allowed length,\r\n     *         more than the maximum allowed length, or not a power of 2\r\n     */\r\n    public static void checkTermLength(final int termLength) {\r\n        if (termLength < TERM_MIN_LENGTH) {\r\n            throw new IllegalStateException(\"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength);\r\n        }\r\n        if (termLength > TERM_MAX_LENGTH) {\r\n            throw new IllegalStateException(\"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength);\r\n        }\r\n        if (!BitUtil.isPowerOfTwo(termLength)) {\r\n            throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength);\r\n        }\r\n    }"}, {"ID": 1944, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void checkPageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new IllegalStateException( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new IllegalStateException( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize); } }\n\n    ### Response:", "ground_truth": "Check that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws IllegalStateException if the size is not as expected.", "predict": "/**\r\n     * Checks if the given page size is valid.\r\n     * \r\n     * @param pageSize the page size to check\r\n     * @throws IllegalStateException if the page size is less than the minimum allowed size, or if it is more than the maximum allowed size, or if it is not a power of 2\r\n     */\r\n    public static void checkPageSize(final int pageSize) {\r\n        if (pageSize < PAGE_MIN_SIZE) {\r\n            throw new IllegalStateException(\"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize);\r\n        }\r\n        if (pageSize > PAGE_MAX_SIZE) {\r\n            throw new IllegalStateException(\"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize);\r\n        }\r\n        if (!BitUtil.isPowerOfTwo(pageSize)) {\r\n            throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize);\r\n        }\r\n    }"}, {"ID": 1945, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean casActiveTermCount( final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) { return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount); }\n\n    ### Response:", "ground_truth": "Compare and set the value of the current active term count.\n\n@param metadataBuffer    containing the meta data.\n@param expectedTermCount value of the active term count expected in the log\n@param updateTermCount   value of the active term count to be updated in the log\n@return true if successful otherwise false.", "predict": "/**\n     * Atomically sets the active term count in the metadata buffer to the given value if the current value is equal to the expected value.\n     *\n     * @param metadataBuffer to be updated.\n     * @param expectedTermCount the expected active term count.\n     * @param updateTermCount the new active term count.\n     * @return true if successful.\n     */\n    public static boolean casActiveTermCount(final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) {\n        return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount);\n    }"}, {"ID": 1946, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long computePosition( final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId) { final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover return (termCount << positionBitsToShift) + termOffset; }\n\n    ### Response:", "ground_truth": "Compute the current position in absolute number of bytes.\n\n@param activeTermId        active term id.\n@param termOffset          in the term.\n@param positionBitsToShift number of times to left shift the term count\n@param initialTermId       the initial term id that this stream started on\n@return the absolute position in bytes", "predict": "/**\r\n     * Computes the position in the active term based on the active term id, term offset, position bits to shift, and initial term id.\r\n     * \r\n     * @param activeTermId the active term id\r\n     * @param termOffset the term offset\r\n     * @param positionBitsToShift the number of bits to shift the position by\r\n     * @param initialTermId the initial term id\r\n     * @return the position in the active term\r\n     */\r\n    public static long computePosition(final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId) {\r\n        final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover\r\n        return (termCount << positionBitsToShift) + termOffset;\r\n    }"}, {"ID": 1947, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long computeLogLength(final int termLength, final int filePageSize) { if (termLength < (1024 * 1024 * 1024)) { return align((termLength * PARTITION_COUNT) + LOG_META_DATA_LENGTH, filePageSize); } return (PARTITION_COUNT * (long)termLength) + align(LOG_META_DATA_LENGTH, filePageSize); }\n\n    ### Response:", "ground_truth": "Compute the total length of a log file given the term length.\n\nAssumes {@link #TERM_MAX_LENGTH} is 1GB and that filePageSize is 1GB or less and a power of 2.\n\n@param termLength   on which to base the calculation.\n@param filePageSize to use for log.\n@return the total length of the log file.", "predict": "/**\r\n     * Computes the length of the log file based on the term length and file page size.\r\n     * \r\n     * @param termLength the length of each term in the log\r\n     * @param filePageSize the size of each page in the log file\r\n     * @return the length of the log file in bytes\r\n     */\r\n    public static long computeLogLength(final int termLength, final int filePageSize) {\r\n        if (termLength < (1024 * 1024 * 1024)) {\r\n            return align((termLength * PARTITION_COUNT) + LOG_META_DATA_LENGTH, filePageSize);\r\n        }\r\n        return (PARTITION_COUNT * (long)termLength) + align(LOG_META_DATA_LENGTH, filePageSize);\r\n    }"}, {"ID": 1948, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) { if (defaultHeader.capacity() != HEADER_LENGTH) { throw new IllegalArgumentException( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity()); } metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH); metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH); }\n\n    ### Response:", "ground_truth": "Store the default frame header to the log meta data buffer.\n\n@param metadataBuffer into which the default headers should be stored.\n@param defaultHeader  to be stored.\n@throws IllegalArgumentException if the defaultHeader larger than {@link #LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH}", "predict": "/**\r\n     * Stores the default frame header in the metadata buffer.\r\n     *\r\n     * @param metadataBuffer the metadata buffer to store the header in.\r\n     * @param defaultHeader the default header to store.\r\n     * @throws IllegalArgumentException if the default header length is not equal to HEADER_LENGTH.\r\n     */\r\n    public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) {\r\n        if (defaultHeader.capacity() != HEADER_LENGTH) {\r\n            throw new IllegalArgumentException(\"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity());\r\n        }\r\n        metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH);\r\n        metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH);\r\n    }"}, {"ID": 1949, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void applyDefaultHeader( final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) { termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH); }\n\n    ### Response:", "ground_truth": "Apply the default header for a message in a term.\n\n@param metadataBuffer containing the default headers.\n@param termBuffer     to which the default header should be applied.\n@param termOffset     at which the default should be applied.", "predict": "/**\n     * Applies the default header to the term buffer.\n     *\n     * @param metadataBuffer the metadata buffer to copy the header from.\n     * @param termBuffer     the term buffer to apply the header to.\n     * @param termOffset     the offset in the term buffer to apply the header to.\n     */\n    public static void applyDefaultHeader(final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) {\n        termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH);\n    }"}, {"ID": 1950, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = indexByTermCount(nextTermCount); final int expectedTermId = nextTermId - PARTITION_COUNT; long rawTail; do { rawTail = rawTail(metadataBuffer, nextIndex); if (expectedTermId != termId(rawTail)) { break; } } while (!casRawTail(metadataBuffer, nextIndex, rawTail, packTail(nextTermId, 0))); return casActiveTermCount(metadataBuffer, termCount, nextTermCount); }\n\n    ### Response:", "ground_truth": "Rotate the log and update the tail counter for the new term.\n\nThis method is safe for concurrent use.\n\n@param metadataBuffer for the log.\n@param termCount      from which to rotate.\n@param termId         to be used in the default headers.\n@return true if log was rotated.", "predict": "/**\n     * Rotates the log by appending a new term to the end of the log.\n     *\n     * @param metadataBuffer to be used for accessing the log metadata.\n     * @param termCount      to be used for checking the current term count.\n     * @param termId         to be used for checking the current term id.\n     * @return true if the rotation was successful, false otherwise.\n     */\n    public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) {\n        final int nextTermId = termId + 1;\n        final int nextTermCount = termCount + 1;\n        final int nextIndex = indexByTermCount(nextTermCount);\n        final int expectedTermId = nextTermId - PARTITION_COUNT;\n        long rawTail;\n        do {\n            rawTail = rawTail(metadataBuffer, nextIndex);\n            if (expectedTermId != termId(rawTail)) {\n                break;\n            }\n        } while (!casRawTail("}, {"ID": 1951, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void initialiseTailWithTermId( final UnsafeBuffer metadataBuffer, final int partitionIndex, final int termId) { metadataBuffer.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0)); }\n\n    ### Response:", "ground_truth": "Set the initial value for the termId in the upper bits of the tail counter.\n\n@param metadataBuffer contain the tail counter.\n@param partitionIndex to be initialised.\n@param termId         to be set.", "predict": "/**\n     * Initialises the tail counter for a given partition with the given termId and a position of 0.\n     *\n     * @param metadataBuffer The buffer containing the metadata.\n     * @param partitionIndex The index of the partition to initialise the tail counter for.\n     * @param termId The termId to set the tail counter to.\n     */\n    public static void initialiseTailWithTermId(final UnsafeBuffer metadataBuffer, final int partitionIndex, final int termId) {\n        metadataBuffer.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0));\n    }"}, {"ID": 1952, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int termOffset(final long rawTail, final long termLength) { final long tail = rawTail & 0xFFFF_FFFFL; return (int)Math.min(tail, termLength); }\n\n    ### Response:", "ground_truth": "Read the termOffset from a packed raw tail value.\n\n@param rawTail    containing the termOffset.\n@param termLength that the offset cannot exceed.\n@return the termOffset value.", "predict": "/**\r\n     * Calculates the offset of the given tail value within the given term length.\r\n     *\r\n     * @param rawTail the raw tail value to calculate the offset for\r\n     * @param termLength the length of the term to calculate the offset within\r\n     * @return the offset of the tail within the term, capped at the term length\r\n     */\r\n    public static int termOffset(final long rawTail, final long termLength) {\r\n        final long tail = rawTail & 0xFFFF_FFFFL;\r\n        return (int)Math.min(tail, termLength);\r\n    }"}, {"ID": 1953, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) { final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer)); return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex)); }\n\n    ### Response:", "ground_truth": "Get the raw value of the tail for the current active partition.\n\n@param metadataBuffer containing the tail counters.\n@return the raw value of the tail for the current active partition.", "predict": "/**\n     * Returns the raw tail value for the given partition index.\n     *\n     * @param metadataBuffer to read the active term count from.\n     * @return the raw tail value for the given partition index.\n     */\n    public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) {\n        final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer));\n        return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex));\n    }"}, {"ID": 1954, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean casRawTail( final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) { final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex); return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail); }\n\n    ### Response:", "ground_truth": "Compare and set the raw value of the tail for the given partition.\n\n@param metadataBuffer  containing the tail counters.\n@param partitionIndex  for the tail counter.\n@param expectedRawTail expected current value.\n@param updateRawTail   to be applied.\n@return true if the update was successful otherwise false.", "predict": "/**\n     * Atomically updates the raw tail value for a given partition in the metadata buffer.\n     *\n     * @param metadataBuffer to be updated.\n     * @param partitionIndex for which the tail value needs to be updated.\n     * @param expectedRawTail the expected value for the tail.\n     * @param updateRawTail the new value for the tail.\n     * @return true if the update was successful, false otherwise.\n     */\n    public static boolean casRawTail(final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) {\n        final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex);\n        return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail);\n    }"}, {"ID": 1955, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public TerminateDriverFlyweight tokenBuffer( final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength); if (null != tokenBuffer && tokenLength > 0) { buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength); } return this; }\n\n    ### Response:", "ground_truth": "Fill the token buffer.\n\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return flyweight", "predict": "/**\r\n     * Sets the token buffer for the flyweight.\r\n     *\r\n     * @param tokenBuffer the token buffer to set\r\n     * @param tokenOffset the offset in the token buffer where the token starts\r\n     * @param tokenLength the length of the token in the token buffer\r\n     * @return this flyweight\r\n     */\r\n    public TerminateDriverFlyweight tokenBuffer(final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) {\r\n        buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength);\r\n        if (null != tokenBuffer && tokenLength > 0) {\r\n            buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength);\r\n        }\r\n        return this;\r\n    }"}, {"ID": 1956, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) { tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId); tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition); tempBuffer.putLong(TIMESTAMP_OFFSET, timestamp); tempBuffer.putInt(REPLAY_FLAG_OFFSET, hasReplay ? 1 : 0); final int serviceCount = snapshotRecordingIds.length; tempBuffer.putInt(SERVICE_COUNT_OFFSET, serviceCount); final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + (serviceCount * SIZE_OF_LONG); if (keyLength > MAX_KEY_LENGTH) { throw new ClusterException(keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH); } for (int i = 0; i < serviceCount; i++) { tempBuffer.putLong(SNAPSHOT_RECORDING_IDS_OFFSET + (i * SIZE_OF_LONG), snapshotRecordingIds[i]); } final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putLongAscii(keyLength + labelLength, leadershipTermId); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" logPosition=\"); labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, logPosition); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" hasReplay=\" + hasReplay); return aeron.addCounter(RECOVERY_STATE_TYPE_ID, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate a counter to represent the snapshot services should load on start.\n\n@param aeron                to allocate the counter.\n@param tempBuffer           to use for building the key and label without allocation.\n@param leadershipTermId     at which the snapshot was taken.\n@param logPosition          at which the snapshot was taken.\n@param timestamp            the snapshot was taken.\n@param hasReplay            flag is true if all or part of the log must be replayed.\n@param snapshotRecordingIds for the services to use during recovery indexed by service id.\n@return the {@link Counter} for the recovery state.", "predict": "/**\n * Allocate a new counter for recording the state of a service in the cluster.\n *\n * @param aeron             to allocate the counter with.\n * @param tempBuffer        to use for encoding the counter key and label.\n * @param leadershipTermId  for the counter.\n * @param logPosition       for the counter.\n * @param timestamp         for the counter.\n * @param hasReplay         for the counter.\n * @param snapshotRecordingIds for the counter.\n * @return the allocated counter.\n * @throws ClusterException if the key length exceeds the maximum allowed.\n */\npublic static Counter allocate(final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) {\n    tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId);\n    tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition"}, {"ID": 1957, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterId(final CountersReader counters) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for recovery state.\n\n@param counters to search within.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": "/**\r\n     * Finds the counter id of the recovery state counter.\r\n     * \r\n     * @param counters the counters reader to search for the recovery state counter\r\n     * @return the counter id of the recovery state counter, or NULL_COUNTER_ID if not found\r\n     */\r\n    public static int findCounterId(final CountersReader counters) {\r\n        final DirectBuffer buffer = counters.metaDataBuffer();\r\n        for (int i = 0, size = counters.maxCounterId(); i < size; i++) {\r\n            if (counters.getCounterState(i) == RECORD_ALLOCATED) {\r\n                final int recordOffset = CountersReader.metaDataOffset(i);\r\n                if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return NULL_COUNTER_ID;\r\n    }"}, {"ID": 1958, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static boolean hasReplay(final CountersReader counters, final int counterId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1; } } return false; }\n\n    ### Response:", "ground_truth": "Has the recovery process got a log to replay?\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@return true if a replay is required.", "predict": "/**\r\n     * Checks if the given counter has a replay flag set to 1.\r\n     *\r\n     * @param counters the counters reader to use\r\n     * @param counterId the id of the counter to check\r\n     * @return true if the counter has a replay flag set to 1, false otherwise\r\n     */\r\n    public static boolean hasReplay(final CountersReader counters, final int counterId) {\r\n        final DirectBuffer buffer = counters.metaDataBuffer();\r\n        if (counters.getCounterState(counterId) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(counterId);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) {\r\n                return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1;\r\n            }\r\n        }\r\n        return false;\r\n    }"}, {"ID": 1959, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET); if (serviceId < 0 || serviceId >= serviceCount) { throw new ClusterException(\"invalid serviceId \" + serviceId + \" for count of \" + serviceCount); } return buffer.getLong( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + (serviceId * SIZE_OF_LONG)); } } throw new ClusterException(\"Active counter not found \" + counterId); }\n\n    ### Response:", "ground_truth": "Get the recording id of the snapshot for a service.\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@param serviceId for the snapshot required.\n@return the count of replay terms if found otherwise {@link Aeron#NULL_VALUE}.", "predict": "/**\r\n     * Returns the snapshot recording id for the given counter and service id.\r\n     *\r\n     * @param counters the counters reader to use\r\n     * @param counterId the id of the counter to get the snapshot recording id for\r\n     * @param serviceId the id of the service to get the snapshot recording id for\r\n     * @return the snapshot recording id for the given counter and service id\r\n     * @throws ClusterException if the counter is not active or the service id is invalid\r\n     */\r\n    public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) {\r\n        final DirectBuffer buffer = counters.metaDataBuffer();\r\n        if (counters.getCounterState(counterId) == RECORD_ALLOCATED) {\r\n            final int recordOffset = CountersReader.metaDataOffset(counterId);\r\n            if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) {\r\n                final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET +"}, {"ID": 1960, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static char[] flagsToChars(final short flags) { final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' }; final int length = chars.length; short mask = (short)(1 << (length - 1)); for (int i = 0; i < length; i++) { if ((flags & mask) == mask) { chars[i] = '1'; } mask >>= 1; } return chars; }\n\n    ### Response:", "ground_truth": "Convert header flags to an array of chars to be human readable.\n\n@param flags to be converted.\n@return header flags converted to an array of chars to be human readable.", "predict": "/**\r\n     * Converts a short integer to an array of characters representing the binary representation of the integer.\r\n     * \r\n     * @param flags the short integer to convert\r\n     * @return an array of characters representing the binary representation of the integer\r\n     */\r\n    public static char[] flagsToChars(final short flags) {\r\n        final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' };\r\n        final int length = chars.length;\r\n        short mask = (short)(1 << (length - 1));\r\n        for (int i = 0; i < length; i++) {\r\n            if ((flags & mask) == mask) {\r\n                chars[i] = '1';\r\n            }\r\n            mask >>= 1;\r\n        }\r\n        return chars;\r\n    }"}, {"ID": 1961, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PublicationMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; }\n\n    ### Response:", "ground_truth": "Set the channel field in ASCII\n\n@param channel field value\n@return flyweight", "predict": "/**\n     * Sets the channel for the publication message flyweight.\n     *\n     * @param channel the channel to set\n     * @return the publication message flyweight\n     */\n    public PublicationMessageFlyweight channel(final String channel) {\n        lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel);\n        return this;\n    }"}, {"ID": 1962, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public long offer(final DirectBuffer buffer, final int offset, final int length) { return cluster.offer(id, responsePublication, buffer, offset, length); }\n\n    ### Response:", "ground_truth": "Non-blocking publish of a partial buffer containing a message to a cluster.\n\n@param buffer containing message.\n@param offset offset in the buffer at which the encoded message begins.\n@param length in bytes of the encoded message.\n@return the same as {@link Publication#offer(DirectBuffer, int, int)} when in {@link Cluster.Role#LEADER}\notherwise {@link #MOCKED_OFFER}.", "predict": "/**\n     * Offers a buffer to the cluster for publication.\n     *\n     * @param buffer the buffer to offer\n     * @param offset the offset in the buffer to start from\n     * @param length the length of the buffer to offer\n     * @return the sequence ID of the offered buffer\n     */\n    public long offer(final DirectBuffer buffer, final int offset, final int length) {\n        return cluster.offer(id, responsePublication, buffer, offset, length);\n    }"}, {"ID": 1963, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void wrap(final AtomicBuffer buffer, final int offset, final int length) { this.buffer.wrap(buffer, offset, length); }\n\n    ### Response:", "ground_truth": "Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.\n\n@param buffer to be wrapped.\n@param offset at which the claimed region begins including space for the header.\n@param length length of the underlying claimed region including space for the header.", "predict": "/**\n     * Wraps the underlying buffer of this view.\n     *\n     * @param buffer  the buffer to be wrapped.\n     * @param offset  the offset in the buffer at which the view starts.\n     * @param length  the length of the view in the buffer.\n     */\n    public final void wrap(final AtomicBuffer buffer, final int offset, final int length) {\n        this.buffer.wrap(buffer, offset, length);\n    }"}, {"ID": 1964, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void commit() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); }\n\n    ### Response:", "ground_truth": "Commit the message to the log buffer so that is it available to subscribers.", "predict": "/**\n     * Commits the current frame to the output buffer.\n     *\n     * This method should be called after all data has been written to the frame buffer. It will write the frame length to the output buffer, followed by the frame data.\n     *\n     * The frame length is written in network byte order (big-endian).\n     */\n    public final void commit() {\n        int frameLength = buffer.capacity();\n        if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) {\n            frameLength = Integer.reverseBytes(frameLength);\n        }\n        buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength);\n    }"}, {"ID": 1965, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final void abort() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_PAD, LITTLE_ENDIAN); buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); }\n\n    ### Response:", "ground_truth": "Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.", "predict": "/**\r\n     * This method is used to abort the current frame.\r\n     * It sets the frame type to PAD and sets the frame length to the current capacity of the buffer.\r\n     */"}, {"ID": 1966, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void main(final String[] args) { loadPropertiesFiles(args); final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier(); final MediaDriver.Context ctx = new MediaDriver.Context(); ctx.terminationHook(barrier::signal); try (MediaDriver ignore = MediaDriver.launch(ctx)) { barrier.await(); System.out.println(\"Shutdown Driver...\"); } }\n\n    ### Response:", "ground_truth": "Start Media Driver as a stand-alone process.\n\n@param args command line arguments", "predict": "/**\r\n     * This method is the entry point for the application.\r\n     * \r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(final String[] args) {\r\n        loadPropertiesFiles(args);\r\n        final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier();\r\n        final MediaDriver.Context ctx = new MediaDriver.Context();\r\n        ctx.terminationHook(barrier::signal);\r\n        try (MediaDriver ignore = MediaDriver.launch(ctx)) {\r\n            barrier.await();\r\n            System.out.println(\"Shutdown Driver...\");\r\n        }\r\n    }"}, {"ID": 1967, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { CloseHelper.close(sharedRunner); CloseHelper.close(sharedNetworkRunner); CloseHelper.close(receiverRunner); CloseHelper.close(senderRunner); CloseHelper.close(conductorRunner); CloseHelper.close(sharedInvoker); if (ctx.useWindowsHighResTimer() && SystemUtil.osName().startsWith(\"win\")) { if (!wasHighResTimerEnabled) { HighResolutionTimer.disable(); } } }\n\n    ### Response:", "ground_truth": "Shutdown the media driver by stopping all threads and freeing resources.", "predict": "/**\r\n     * Closes the resources used by the conductor.\r\n     * \r\n     * @throws IOException\r\n     *             if an I/O error occurs while closing the resources.\r\n     */\r\n    public void close() throws IOException {\r\n        CloseHelper.close(sharedRunner);\r\n        CloseHelper.close(sharedNetworkRunner);\r\n        CloseHelper.close(receiverRunner);\r\n        CloseHelper.close(senderRunner);\r\n        CloseHelper.close(conductorRunner);\r\n        CloseHelper.close(sharedInvoker);\r\n        if (ctx.useWindowsHighResTimer() && SystemUtil.osName().startsWith(\"win\")) {\r\n            if (!wasHighResTimerEnabled) {\r\n                HighResolutionTimer.disable();\r\n            }\r\n        }\r\n    }"}, {"ID": 1968, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public final long position() { final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT); return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId); }\n\n    ### Response:", "ground_truth": "Get the current position to which the image has advanced on reading this message.\n\n@return the current position to which the image has advanced on reading this message.", "predict": "/**\r\n     * Returns the current position in the file.\r\n     *\r\n     * @return the current position in the file.\r\n     */\r\n    public final long position() {\r\n        final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT);\r\n        return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId);\r\n    }"}, {"ID": 1969, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) { tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId); final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId); return aeron.addCounter( SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength); }\n\n    ### Response:", "ground_truth": "Allocate a counter to represent the heartbeat of a clustered service.\n\n@param aeron           to allocate the counter.\n@param tempBuffer      to use for building the key and label without allocation.\n@param serviceId       of the service heartbeat.\n@return the {@link Counter} for the commit position.", "predict": "/**\n     * Allocate a new counter for the given serviceId.\n     *\n     * @param aeron      to allocate the counter with.\n     * @param tempBuffer to use for encoding the counter key.\n     * @param serviceId  to allocate the counter for.\n     * @return the allocated counter.\n     */\n    public static Counter allocate(final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) {\n        tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId);\n        final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT);\n        int labelLength = 0;\n        labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME);\n        labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId);\n        return aeron.addCounter(SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength);\n    }"}, {"ID": 1970, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static int findCounterId(final CountersReader counters, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) { return i; } } } return NULL_COUNTER_ID; }\n\n    ### Response:", "ground_truth": "Find the active counter id for heartbeat of a given service id.\n\n@param counters  to search within.\n@param serviceId to search for.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": "/**\r\n     * Finds the counter id for a given service id in the counters buffer.\r\n     *\r\n     * @param counters the counters buffer to search in\r\n     * @param serviceId the service id to search for\r\n     * @return the counter id for the given service id, or NULL_COUNTER_ID if not found\r\n     */\r\n    public static int findCounterId(final CountersReader counters, final int serviceId) {\r\n        final DirectBuffer buffer = counters.metaDataBuffer();\r\n        for (int i = 0, size = counters.maxCounterId(); i < size; i++) {\r\n            if (counters.getCounterState(i) == RECORD_ALLOCATED) {\r\n                final int recordOffset = CountersReader.metaDataOffset(i);\r\n                if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n       "}, {"ID": 1971, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public Map<StreamCompositeKey, StreamBacklog> snapshot() { final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamBacklog streamBacklog = streams.computeIfAbsent(key, (ignore) -> new StreamBacklog()); final long registrationId = keyBuffer.getLong(REGISTRATION_ID_OFFSET); final long value = counters.getCounterValue(counterId); switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().limit(value); break; case PublisherPos.PUBLISHER_POS_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().position(value); break; case SenderPos.SENDER_POSITION_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().position(value); break; case SenderLimit.SENDER_LIMIT_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().limit(value); break; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().highWaterMark(value); break; case ReceiverPos.RECEIVER_POS_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().position(value); break; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: streamBacklog.subscriberBacklogs().put(registrationId, new Subscriber(value)); break; } } }); return streams; }\n\n    ### Response:", "ground_truth": "Take a snapshot of all the backlog information and group by stream.\n\n@return a snapshot of all the backlog information and group by stream.", "predict": "/**\n     * This method creates a snapshot of the current state of the counters and returns a map of stream composite keys to stream backlogs.\n     *\n     * @return a map of stream composite keys to stream backlogs\n     */\n    public Map<StreamCompositeKey, StreamBacklog> snapshot() {\n        final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>();\n        counters.forEach( (counterId, typeId, keyBuffer, label) -> {\n            if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) {\n                final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET));\n                final StreamBack"}, {"ID": 1972, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) { return new AtomicCounter( countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager); }\n\n    ### Response:", "ground_truth": "Allocate a counter for tracking the last heartbeat of an entity.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@return a new {@link AtomicCounter} for tracking the last heartbeat.", "predict": "/**\n     * Allocate a new atomic counter with the given name, type id, and registration id.\n     *\n     * @param tempBuffer         the temporary buffer to use for atomic operations\n     * @param name               the name of the counter\n     * @param typeId             the type id of the counter\n     * @param countersManager    the counters manager to use for allocation\n     * @param registrationId     the registration id of the counter\n     * @return the allocated atomic counter\n     */\n    public static AtomicCounter allocate(final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) {\n        return new AtomicCounter(countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager);\n    }"}, {"ID": 1973, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void close() { final MappedByteBuffer cncByteBuffer = this.cncByteBuffer; this.cncByteBuffer = null; IoUtil.unmap(cncByteBuffer); super.close(); }\n\n    ### Response:", "ground_truth": "Clean up all resources that the client uses to communicate with the Media Driver.", "predict": "/**\r\n     * Closes the channel and releases any system resources associated with it.\r\n     *\r\n     * @throws IOException if an I/O error occurs\r\n     */\r\n    public void close() throws IOException {\r\n        final MappedByteBuffer cncByteBuffer = this.cncByteBuffer;\r\n        this.cncByteBuffer = null;\r\n        IoUtil.unmap(cncByteBuffer);\r\n        super.close();\r\n    }"}, {"ID": 1974, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static void dispatchDescriptor( final RecordingDescriptorDecoder decoder, final RecordingDescriptorConsumer consumer) { consumer.onRecordingDescriptor( decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity()); }\n\n    ### Response:", "ground_truth": "Dispatch a descriptor message to a consumer by reading the fields in the correct order.\n\n@param decoder  which wraps the encoded message ready for reading.\n@param consumer to which the decoded fields should be passed.", "predict": "/**\n     * Dispatches the recording descriptor to the specified consumer.\n     *\n     * @param decoder the decoder to decode the recording descriptor from.\n     * @param consumer the consumer to dispatch the recording descriptor to.\n     */\n    public static void dispatchDescriptor(final RecordingDescriptorDecoder decoder, final RecordingDescriptorConsumer consumer) {\n        consumer.onRecordingDescriptor(\n                decoder.controlSessionId(),\n                decoder.correlationId(),\n                decoder.recordingId(),\n                decoder.startTimestamp(),\n                decoder.stopTimestamp(),\n                decoder.startPosition(),\n                decoder.stopPosition(),\n                decoder.initialTermId(),\n                decoder.segmentFileLength(),\n                decoder.termBufferLength(),\n                decoder.mtuLength(),\n                decoder.sessionId(),\n                decoder.streamId(),\n                decoder.strippedChannel(),\n                decoder.originalChannel(),\n                decoder.sourceIdentity()\n        );\n    }"}, {"ID": 1975, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void addSlab(int minimumSize) { int nextSlabSize; if (bytesUsed == 0) { nextSlabSize = initialSlabSize; } else if (bytesUsed > maxCapacityHint / 5) { // to avoid an overhead of up to twice the needed size, we get linear when approaching target page size nextSlabSize = maxCapacityHint / 5; } else { // double the size every time nextSlabSize = bytesUsed; } if (nextSlabSize < minimumSize) { LOG.debug(\"slab size {} too small for value of size {}. Bumping up slab size\", nextSlabSize, minimumSize); nextSlabSize = minimumSize; } LOG.debug(\"used {} slabs, adding new slab of size {}\", slabs.size(), nextSlabSize); this.currentSlab = allocator.allocate(nextSlabSize); this.slabs.add(currentSlab); this.bytesAllocated += nextSlabSize; this.currentSlabIndex = 0; }\n\n    ### Response:", "ground_truth": "the new slab is guaranteed to be at least minimumSize\n@param minimumSize the size of the data we want to copy in the new slab", "predict": "/**\n     * Adds a new slab to the buffer. The slab size is determined based on the amount of data already in the buffer, and the minimum size requested.\n     * \n     * @param minimumSize the minimum size of the slab to add\n     */\n    private void addSlab(int minimumSize) {\n        int nextSlabSize;\n        if (bytesUsed == 0) {\n            nextSlabSize = initialSlabSize;\n        } else if (bytesUsed > maxCapacityHint / 5) {\n            // to avoid an overhead of up to twice the needed size, we get linear when approaching target page size\n            nextSlabSize = maxCapacityHint / 5;\n        } else {\n            // double the size every time\n            nextSlabSize = bytesUsed;\n        }\n        if (nextSlabSize < minimumSize) {\n            LOG.debug(\"slab size {} too small for value of size {}. Bumping up slab size\", nextSlabSize, minimumSize);\n            nextSlabSize"}, {"ID": 1976, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void setByte(long index, byte value) { checkArgument(index < bytesUsed, \"Index: \" + index + \" is >= the current size of: \" + bytesUsed); long seen = 0; for (int i = 0; i < slabs.size(); i++) { ByteBuffer slab = slabs.get(i); if (index < seen + slab.limit()) { // ok found index slab.put((int)(index-seen), value); break; } seen += slab.limit(); } }\n\n    ### Response:", "ground_truth": "Replace the byte stored at position index in this stream with value\n\n@param index which byte to replace\n@param value the value to replace it with", "predict": "/**\n     * Sets the byte value at the specified index.\n     *\n     * @param index the index to set the byte value at.\n     * @param value the byte value to set.\n     * @throws IllegalArgumentException if the index is >= the current size of the buffer.\n     */\n    public void setByte(long index, byte value) {\n        checkArgument(index < bytesUsed, \"Index: \" + index + \" is >= the current size of: \" + bytesUsed);\n        long seen = 0;\n        for (int i = 0; i < slabs.size(); i++) {\n            ByteBuffer slab = slabs.get(i);\n            if (index < seen + slab.limit()) {\n                // ok found index\n                slab.put((int) (index - seen), value);\n                break;\n            }\n            seen += slab.limit();\n        }\n    }"}, {"ID": 1977, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void add(Statistics<?> stats) { if (stats.hasNonNullValue()) { nullPages.add(false); Object min = stats.genericGetMin(); Object max = stats.genericGetMax(); addMinMax(min, max); pageIndexes.add(nextPageIndex); minMaxSize += sizeOf(min); minMaxSize += sizeOf(max); } else { nullPages.add(true); } nullCounts.add(stats.getNumNulls()); ++nextPageIndex; }\n\n    ### Response:", "ground_truth": "Adds the data from the specified statistics to this builder\n\n@param stats\nthe statistics to be added", "predict": "/**\r\n     * Adds the given statistics to this object.\r\n     * \r\n     * @param stats the statistics to add\r\n     */\r\n    public void add(Statistics<?> stats) {\r\n        if (stats.hasNonNullValue()) {\r\n            nullPages.add(false);\r\n            Object min = stats.genericGetMin();\r\n            Object max = stats.genericGetMax();\r\n            addMinMax(min, max);\r\n            pageIndexes.add(nextPageIndex);\r\n            minMaxSize += sizeOf(min);\r\n            minMaxSize += sizeOf(max);\r\n        } else {\r\n            nullPages.add(true);\r\n        }\r\n        nullCounts.add(stats.getNumNulls());\r\n        ++nextPageIndex;\r\n    }"}, {"ID": 1978, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) { return filter.accept(new FilterCompat.Visitor<RowRanges>() { @Override public RowRanges visit(FilterPredicateCompat filterPredicateCompat) { try { return filterPredicateCompat.getFilterPredicate() .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount)); } catch (MissingOffsetIndexException e) { LOGGER.info(e.getMessage()); return RowRanges.createSingle(rowCount); } } @Override public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) { return RowRanges.createSingle(rowCount); } @Override public RowRanges visit(NoOpFilter noOpFilter) { return RowRanges.createSingle(rowCount); } }); }\n\n    ### Response:", "ground_truth": "Calculates the row ranges containing the indexes of the rows might match the specified filter.\n\n@param filter\nto be used for filtering the rows\n@param columnIndexStore\nthe store for providing column/offset indexes\n@param paths\nthe paths of the columns used in the actual projection; a column not being part of the projection will be\nhandled as containing {@code null} values only even if the column has values written in the file\n@param rowCount\nthe total number of rows in the row-group\n@return the ranges of the possible matching row indexes; the returned ranges will contain all the rows if any of\nthe required offset index is missing", "predict": "/**\r\n     * Calculates the row ranges that match the given filter for the given set of column paths.\r\n     *\r\n     * @param filter the filter to apply\r\n     * @param columnIndexStore the column index store to use for filtering\r\n     * @param paths the set of column paths to filter on\r\n     * @param rowCount the total number of rows in the table\r\n     * @return the row ranges that match the filter for the given set of column paths\r\n     */\r\n    public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) {\r\n        return filter.accept(new FilterCompat.Visitor<RowRanges>() {\r\n            @Override\r\n            public RowRanges visit(FilterPredicateCompat filterPredicateCompat) {\r\n                try {\r\n                    return filterPredicateCompat.getFilterPredicate()\r\n                            .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount));\r\n                } catch (MissingOffsetIndexException e) {\r\n                    LOGGER.info(e.getMessage());\r\n                    return RowRanges.createSingle"}, {"ID": 1979, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo) { final TypeInfo subType = typeInfo.getListElementTypeInfo(); return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType(\"array_element\", subType))); }\n\n    ### Response:", "ground_truth": "1 anonymous element \"array_element\"", "predict": "/**\r\n     * Converts an array type to a GroupType.\r\n     *\r\n     * @param name the name of the array type\r\n     * @param typeInfo the type information for the array type\r\n     * @return the GroupType representation of the array type\r\n     */\r\n    private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo) {\r\n        final TypeInfo subType = typeInfo.getListElementTypeInfo();\r\n        return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType(\"array_element\", subType)));\r\n    }"}, {"ID": 1980, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) { final List<String> columnNames = typeInfo.getAllStructFieldNames(); final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos(); return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes)); }\n\n    ### Response:", "ground_truth": "An optional group containing multiple elements", "predict": "/**\r\n     * Converts a StructTypeInfo to a GroupType.\r\n     *\r\n     * @param name The name of the group type.\r\n     * @param typeInfo The StructTypeInfo to convert.\r\n     * @return The resulting GroupType.\r\n     */\r\n    private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) {\r\n        final List<String> columnNames = typeInfo.getAllStructFieldNames();\r\n        final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos();\r\n        return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes));\r\n    }"}, {"ID": 1981, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private static String annotateMessage(String message, int pos) { StringBuilder sb = new StringBuilder(message); sb.append('\\n'); for (int i = 0; i < pos; i++) { sb.append('-'); } sb.append('^'); return sb.toString(); }\n\n    ### Response:", "ground_truth": "for pretty printing which character had the error", "predict": "/**\r\n     * This method takes a message and a position as input and returns the message with a caret (^) at the specified position.\r\n     * \r\n     * @param message The message to be annotated.\r\n     * @param pos The position at which to add the caret.\r\n     * @return The annotated message.\r\n     */\r\n    private static String annotateMessage(String message, int pos) {\r\n        StringBuilder sb = new StringBuilder(message);\r\n        sb.append('\\n');\r\n        for (int i = 0; i < pos; i++) {\r\n            sb.append('-');\r\n        }\r\n        sb.append('^');\r\n        return sb.toString();\r\n    }"}, {"ID": 1982, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void endPreviousBitPackedRun() { if (bitPackedRunHeaderPointer == -1) { // we're not currently in a bit-packed-run return; } // create bit-packed-header, which needs to fit in 1 byte byte bitPackHeader = (byte) ((bitPackedGroupCount << 1) | 1); // update this byte baos.setByte(bitPackedRunHeaderPointer, bitPackHeader); // mark that this run is over bitPackedRunHeaderPointer = -1; // reset the number of groups bitPackedGroupCount = 0; }\n\n    ### Response:", "ground_truth": "If we are currently writing a bit-packed-run, update the\nbit-packed-header and consider this run to be over\n\ndoes nothing if we're not currently writing a bit-packed run", "predict": "/**\r\n     * Ends the previous bit-packed run, if there was one.\r\n     * \r\n     * This method should be called whenever a new run of bit-packed values is started.\r\n     * \r\n     * The method updates the header of the previous bit-packed run, which is stored in the byte array\r\n     * starting at the given pointer. The header consists of two parts: the number of groups in the run,\r\n     * which is stored in the most significant bit of the header byte, and a flag indicating that the\r\n     * header is valid, which is set to 1.\r\n     * \r\n     * The method also resets the number of groups in the run and the pointer to the header.\r\n     */\r\n    private void endPreviousBitPackedRun() {\r\n        if (bitPackedRunHeaderPointer == -1) { // we're not currently in a bit-packed-run\r\n            return;\r\n        }\r\n        // create bit-packed-header, which needs to fit in 1 byte\r\n        byte bitPackHeader = (byte) ((bitPackedGroupCount << "}, {"ID": 1983, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Override public void readOne(TProtocol in, TProtocol out) throws TException { readOneStruct(in, out); }\n\n    ### Response:", "ground_truth": "reads one record from in and writes it to out\nexceptions are not recoverable as record might be halfway written\n@param in input protocol\n@param out output protocol\n@throws TException if there is an error while reading or writing", "predict": "/**\n     * Reads a single object from the input protocol and writes it to the output protocol.\n     * @param in the input protocol\n     * @param out the output protocol\n     * @throws TException if an error occurs during reading or writing\n     */\n    public void readOne(TProtocol in, TProtocol out) throws TException { readOneStruct(in, out); }"}, {"ID": 1984, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException { return readFooters(configuration, pathStatus, false); }\n\n    ### Response:", "ground_truth": "this always returns the row groups\n@param configuration a configuration\n@param pathStatus a file status to read footers from\n@return a list of footers\n@throws IOException if an exception is thrown while reading the footers\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": "/**\r\n     * This method is deprecated and will be removed in a future release.\r\n     * \r\n     * @param configuration Hadoop configuration object\r\n     * @param pathStatus FileStatus object for the file to be read\r\n     * @return List of Footer objects\r\n     * @throws IOException\r\n     */\r\n    public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException {\r\n        return readFooters(configuration, pathStatus, false);\r\n    }"}, {"ID": 1985, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException { final Path parent = summaryStatus.getPath().getParent(); ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false)); return footersFromSummaryFile(parent, mergedFooters); }\n\n    ### Response:", "ground_truth": "Specifically reads a given summary file\n@param configuration a configuration\n@param summaryStatus file status for a summary file\n@return the metadata translated for each file\n@throws IOException if an exception is thrown while reading the summary file\n@deprecated metadata files are not recommended and will be removed in 2.0.0", "predict": "/**\r\n     * This method is deprecated and will be removed in a future release.\r\n     * \r\n     * @param configuration The Hadoop configuration object.\r\n     * @param summaryStatus The summary file status object.\r\n     * @return A list of footer objects.\r\n     * @throws IOException If an error occurs while reading the footer.\r\n     */\r\n    public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException {\r\n        final Path parent = summaryStatus.getPath().getParent();\r\n        ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false));\r\n        return footersFromSummaryFile(parent, mergedFooters);\r\n    }"}, {"ID": 1986, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    @Deprecated public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException { ParquetReadOptions options; if (file instanceof HadoopInputFile) { options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration()) .withMetadataFilter(filter).build(); } else { options = ParquetReadOptions.builder().withMetadataFilter(filter).build(); } try (SeekableInputStream in = file.newStream()) { return readFooter(file, options, in); } }\n\n    ### Response:", "ground_truth": "Reads the meta data block in the footer of the file using provided input stream\n@param file a {@link InputFile} to read\n@param filter the filter to apply to row groups\n@return the metadata blocks in the footer\n@throws IOException if an error occurs while reading the file\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": "/**\r\n     * Reads the footer of a Parquet file.\r\n     *\r\n     * @param file the input file to read from\r\n     * @param filter the filter to apply to the metadata\r\n     * @return the footer metadata\r\n     * @throws IOException if an I/O error occurs\r\n     * @deprecated Use {@link ParquetFileReader#readFooter(InputFile, ParquetReadOptions)} instead.\r\n     */\r\n    public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException {\r\n        ParquetReadOptions options;\r\n        if (file instanceof HadoopInputFile) {\r\n            options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration())\r\n                    .withMetadataFilter(filter).build();\r\n        } else {\r\n            options = ParquetReadOptions.builder().withMetadataFilter(filter).build();\r\n        }\r\n        try (SeekableInputStream in = file.newStream()) {\r\n            return readFooter(file, options, in);\r\n        }\r\n    }"}, {"ID": 1987, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PageReadStore readNextRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } this.currentRowGroup = new ColumnChunkPageReadStore(block.getRowCount()); // prepare the list of consecutive parts to read them in one scan List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); BenchmarkCounter.incrementTotalBytes(mc.getTotalSize()); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { long startingPos = mc.getStartingPos(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } currentParts.addChunk(new ChunkDescriptor(columnDescriptor, mc, startingPos, (int)mc.getTotalSize())); } } // actually read all the chunks ChunkListBuilder builder = new ChunkListBuilder(); for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; }\n\n    ### Response:", "ground_truth": "Reads all the columns requested from the row group at the current file position.\n@throws IOException if an error occurs while reading\n@return the PageReadStore which can provide PageReaders for each column.", "predict": "/**\n     * Reads the next row group from the file and returns a PageReadStore object that can be used to access the data.\n     *\n     * @return the next row group as a PageReadStore object, or null if there are no more row groups.\n     * @throws IOException if an I/O error occurs while reading the file.\n     */\n    public PageReadStore readNextRowGroup() throws IOException {\n        // implementation details elided for brevity\n    }"}, {"ID": 1988, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public PageReadStore readNextFilteredRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } if (!options.useColumnIndexFilter()) { return readNextRowGroup(); } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } ColumnIndexStore ciStore = getColumnIndexStore(currentBlock); RowRanges rowRanges = getRowRanges(currentBlock); long rowCount = rowRanges.rowCount(); if (rowCount == 0) { // There are no matching rows -> skipping this row-group advanceToNextBlock(); return readNextFilteredRowGroup(); } if (rowCount == block.getRowCount()) { // All rows are matching -> fall back to the non-filtering path return readNextRowGroup(); } this.currentRowGroup = new ColumnChunkPageReadStore(rowRanges); // prepare the list of consecutive parts to read them in one scan ChunkListBuilder builder = new ChunkListBuilder(); List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { OffsetIndex offsetIndex = ciStore.getOffsetIndex(mc.getPath()); OffsetIndex filteredOffsetIndex = filterOffsetIndex(offsetIndex, rowRanges, block.getRowCount()); for (OffsetRange range : calculateOffsetRanges(filteredOffsetIndex, mc, offsetIndex.getOffset(0))) { BenchmarkCounter.incrementTotalBytes(range.getLength()); long startingPos = range.getOffset(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } ChunkDescriptor chunkDescriptor = new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) range.getLength()); currentParts.addChunk(chunkDescriptor); builder.setOffsetIndex(chunkDescriptor, filteredOffsetIndex); } } } // actually read all the chunks for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; }\n\n    ### Response:", "ground_truth": "Reads all the columns requested from the row group at the current file position. It may skip specific pages based\non the column indexes according to the actual filter. As the rows are not aligned among the pages of the different\ncolumns row synchronization might be required. See the documentation of the class SynchronizingColumnReader for\ndetails.\n\n@return the PageReadStore which can provide PageReaders for each column\n@throws IOException\nif any I/O error occurs while reading", "predict": "/**\n     * Reads the next filtered row group from the file.\n     *\n     * @return the next filtered row group, or null if there are no more row groups.\n     * @throws IOException if an I/O error occurs.\n     */\n    public PageReadStore readNextFilteredRowGroup() throws IOException {\n        // TODO: Implement this method\n    }"}, {"ID": 1989, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException { if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) { return null; } // TODO: this should use getDictionaryPageOffset() but it isn't reliable. if (f.getPos() != meta.getStartingPos()) { f.seek(meta.getStartingPos()); } PageHeader pageHeader = Util.readPageHeader(f); if (!pageHeader.isSetDictionary_page_header()) { return null; // TODO: should this complain? } DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f); BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec()); return new DictionaryPage( decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()), compressedPage.getDictionarySize(), compressedPage.getEncoding()); }\n\n    ### Response:", "ground_truth": "Reads and decompresses a dictionary page for the given column chunk.\n\nReturns null if the given column chunk has no dictionary page.\n\n@param meta a column's ColumnChunkMetaData to read the dictionary from\n@return an uncompressed DictionaryPage or null\n@throws IOException if there is an error while reading the dictionary", "predict": "/**\n     * Reads a dictionary page from the given column chunk metadata and file input stream.\n     *\n     * @param meta the column chunk metadata\n     * @return the dictionary page, or null if the metadata does not indicate a dictionary page\n     * @throws IOException if an I/O error occurs while reading the page\n     */\n    public DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException {\n        if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) {\n            return null;\n        }\n        // TODO: this should use getDictionaryPageOffset() but it isn't reliable.\n        if (f.getPos() != meta.getStartingPos()) {\n            f.seek(meta.getStartingPos());\n        }\n        PageHeader pageHeader = Util.readPageHeader(f);\n        if (!pageHeader.isSetDictionary_page_header()) {\n            return null; // TODO: should this complain?\n        }\n        DictionaryPage"}, {"ID": 1990, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) { Long oldValue = writerList.get(writer); if (oldValue == null) { writerList.put(writer, allocation); } else { throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer); } updateAllocation(); }\n\n    ### Response:", "ground_truth": "Add a new writer and its memory allocation to the memory manager.\n@param writer the new created writer\n@param allocation the requested buffer size", "predict": "/**\r\n     * Adds a new writer to the list of writers and updates the total allocation.\r\n     *\r\n     * @param writer the writer to add\r\n     * @param allocation the amount of memory to allocate for the writer\r\n     * @throws IllegalArgumentException if the writer is already in the list\r\n     */\r\n    synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) {\r\n        Long oldValue = writerList.get(writer);\r\n        if (oldValue == null) {\r\n            writerList.put(writer, allocation);\r\n        } else {\r\n            throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" +\r\n                    \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" +\r\n                    \"the writer: \" + writer);\r\n        }\r\n        updateAllocation();\r\n    }"}, {"ID": 1991, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    synchronized void removeWriter(InternalParquetRecordWriter writer) { if (writerList.containsKey(writer)) { writerList.remove(writer); } if (!writerList.isEmpty()) { updateAllocation(); } }\n\n    ### Response:", "ground_truth": "Remove the given writer from the memory manager.\n@param writer the writer that has been closed", "predict": "/**\r\n     * Removes a writer from the list of active writers.\r\n     * \r\n     * @param writer the writer to remove\r\n     */\r\n    synchronized void removeWriter(InternalParquetRecordWriter writer) {\r\n        if (writerList.containsKey(writer)) {\r\n            writerList.remove(writer);\r\n        }\r\n        if (!writerList.isEmpty()) {\r\n            updateAllocation();\r\n        }\r\n    }"}, {"ID": 1992, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    private void updateAllocation() { long totalAllocations = 0; for (Long allocation : writerList.values()) { totalAllocations += allocation; } if (totalAllocations <= totalMemoryPool) { scale = 1.0; } else { scale = (double) totalMemoryPool / totalAllocations; LOG.warn(String.format( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\", 100*memoryPoolRatio, totalMemoryPool, 100*scale, writerList.size())); for (Runnable callBack : callBacks.values()) { // we do not really want to start a new thread here. callBack.run(); } } int maxColCount = 0; for (InternalParquetRecordWriter w : writerList.keySet()) { maxColCount = Math.max(w.getSchema().getColumns().size(), maxColCount); } for (Map.Entry<InternalParquetRecordWriter, Long> entry : writerList.entrySet()) { long newSize = (long) Math.floor(entry.getValue() * scale); if(scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation) { throw new ParquetRuntimeException(String.format(\"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\", newSize, minMemoryAllocation)){}; } entry.getKey().setRowGroupSizeThreshold(newSize); LOG.debug(String.format(\"Adjust block size from %,d to %,d for writer: %s\", entry.getValue(), newSize, entry.getKey())); } }\n\n    ### Response:", "ground_truth": "Update the allocated size of each writer based on the current allocations and pool size.", "predict": "/**\r\n     * Updates the row group sizes of the Parquet writers based on the current memory usage and the total memory pool size.\r\n     * If the total memory usage exceeds the total memory pool size, the row group sizes are scaled down to fit within the memory pool.\r\n     * If the total memory usage is less than or equal to the total memory pool size, the row group sizes are set to 1.\r\n     * If the total memory usage exceeds the total memory pool size, a warning message is logged.\r\n     * If the total memory usage is less than or equal to the total memory pool size, a debug message is logged.\r\n     * The maximum column count is also updated for each writer.\r\n     *\r\n     * @throws ParquetRuntimeException if the new memory allocation is smaller than the minimum allocation size.\r\n     */\r\n    private void updateAllocation() {\r\n        // Implementation details omitted for brevity.\r\n    }"}, {"ID": 1993, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks.put(callBackName, callBack); } }\n\n    ### Response:", "ground_truth": "Register callback and deduplicate it if any.\n@param callBackName the name of callback. It should be identical.\n@param callBack the callback passed in from upper layer, such as Hive.", "predict": "/**\r\n     * Registers a callback for a specific scale event.\r\n     * \r\n     * @param callBackName the name of the callback.\r\n     * @param callBack the callback to be executed when the event occurs.\r\n     * @throws IllegalArgumentException if the callBackName is duplicated and has been registered already.\r\n     */\r\n    public void registerScaleCallBack(String callBackName, Runnable callBack) {\r\n        Preconditions.checkNotNull(callBackName, \"callBackName\");\r\n        Preconditions.checkNotNull(callBack, \"callBack\");\r\n        if (callBacks.containsKey(callBackName)) {\r\n            throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\");\r\n        } else {\r\n            callBacks.put(callBackName, callBack);\r\n        }\r\n    }"}, {"ID": 1994, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void start() throws IOException { state = state.start(); LOG.debug(\"{}: start\", out.getPos()); out.write(MAGIC); }\n\n    ### Response:", "ground_truth": "start the file\n@throws IOException if there is an error while writing", "predict": "/**\n     * Starts the output stream by writing the magic number to the beginning of the stream.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    public void start() throws IOException {\n        state = state.start();\n        LOG.debug(\"{}: start\", out.getPos());\n        out.write(MAGIC);\n    }"}, {"ID": 1995, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startBlock(long recordCount) throws IOException { state = state.startBlock(); LOG.debug(\"{}: start block\", out.getPos()); // out.write(MAGIC); // TODO: add a magic delimiter alignment.alignForRowGroup(out); currentBlock = new BlockMetaData(); currentRecordCount = recordCount; currentColumnIndexes = new ArrayList<>(); currentOffsetIndexes = new ArrayList<>(); }\n\n    ### Response:", "ground_truth": "start a block\n@param recordCount the record count in this block\n@throws IOException if there is an error while writing", "predict": "/**\n     * Start a new block with the given record count.\n     *\n     * @param recordCount the number of records in the block.\n     * @throws IOException if an I/O error occurs.\n     */\n    public void startBlock(long recordCount) throws IOException {\n        state = state.startBlock();\n        LOG.debug(\"{}: start block\", out.getPos());\n        // out.write(MAGIC); // TODO: add a magic delimiter alignment.alignForRowGroup(out);\n        currentBlock = new BlockMetaData();\n        currentRecordCount = recordCount;\n        currentColumnIndexes = new ArrayList<>();\n        currentOffsetIndexes = new ArrayList<>();\n    }"}, {"ID": 1996, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException { state = state.startColumn(); encodingStatsBuilder.clear(); currentEncodings = new HashSet<Encoding>(); currentChunkPath = ColumnPath.get(descriptor.getPath()); currentChunkType = descriptor.getPrimitiveType(); currentChunkCodec = compressionCodecName; currentChunkValueCount = valueCount; currentChunkFirstDataPage = out.getPos(); compressedLength = 0; uncompressedLength = 0; // The statistics will be copied from the first one added at writeDataPage(s) so we have the correct typed one currentStatistics = null; columnIndexBuilder = ColumnIndexBuilder.getBuilder(currentChunkType, columnIndexTruncateLength); offsetIndexBuilder = OffsetIndexBuilder.getBuilder(); firstPageOffset = -1; }\n\n    ### Response:", "ground_truth": "start a column inside a block\n@param descriptor the column descriptor\n@param valueCount the value count in this column\n@param compressionCodecName a compression codec name\n@throws IOException if there is an error while writing", "predict": "/**\n     * Start a new column with the given descriptor, value count, and compression codec name.\n     *\n     * @param descriptor the column descriptor\n     * @param valueCount the number of values in the column\n     * @param compressionCodecName the name of the compression codec to use for the column\n     * @throws IOException if an I/O error occurs\n     */\n    public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException {\n        state = state.startColumn();\n        encodingStatsBuilder.clear();\n        currentEncodings = new HashSet<Encoding>();\n        currentChunkPath = ColumnPath.get(descriptor.getPath());\n        currentChunkType = descriptor.getPrimitiveType();\n        currentChunkCodec = compressionCodecName;\n        currentChunkValueCount = valueCount;\n        currentChunkFirstDataPage = out.getPos();\n        compressedLength = 0;\n        uncompressedLength = 0;\n        // The statistics will be copied from the first one added at writeDataPage(s) so we have"}, {"ID": 1997, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException { state = state.write(); LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize()); currentChunkDictionaryPageOffset = out.getPos(); int uncompressedSize = dictionaryPage.getUncompressedSize(); int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts metadataConverter.writeDictionaryPageHeader( uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out); long headerSize = out.getPos() - currentChunkDictionaryPageOffset; this.uncompressedLength += uncompressedSize + headerSize; this.compressedLength += compressedPageSize + headerSize; LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize); dictionaryPage.getBytes().writeAllTo(out); encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding()); currentEncodings.add(dictionaryPage.getEncoding()); }\n\n    ### Response:", "ground_truth": "writes a dictionary page page\n@param dictionaryPage the dictionary page\n@throws IOException if there is an error while writing", "predict": "/**\n     * Writes a dictionary page to the output stream.\n     *\n     * @param dictionaryPage the dictionary page to write\n     * @throws IOException if an I/O error occurs\n     */\n    public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException {\n        state = state.write();\n        LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize());\n        currentChunkDictionaryPageOffset = out.getPos();\n        int uncompressedSize = dictionaryPage.getUncompressedSize();\n        int compressedPageSize = (int) dictionaryPage.getBytes().size();\n        // TODO: fix casts\n        metadataConverter.writeDictionaryPageHeader(uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out);\n        long headerSize = out.getPos() - currentChunkDictionaryPageOffset;\n        this.uncompressedLength += uncompressedSize + headerSize;\n        this.compressedLength += compressedPageSize + headerSize;\n        LOG.debug(\"{}: write dictionary page"}, {"ID": 1998, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void writeDataPage( int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException { long beforeHeader = out.getPos(); innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding); offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount); }\n\n    ### Response:", "ground_truth": "Writes a single page\n@param valueCount count of values\n@param uncompressedPageSize the size of the data once uncompressed\n@param bytes the compressed data for the page without header\n@param statistics the statistics of the page\n@param rowCount the number of rows in the page\n@param rlEncoding encoding of the repetition level\n@param dlEncoding encoding of the definition level\n@param valuesEncoding encoding of values\n@throws IOException if any I/O error occurs during writing the file", "predict": "/**\n     * Writes a data page to the output stream.\n     *\n     * @param valueCount the number of values in the page\n     * @param uncompressedPageSize the uncompressed size of the page in bytes\n     * @param bytes the input bytes for the page\n     * @param statistics the statistics for the page\n     * @param rowCount the number of rows in the page\n     * @param rlEncoding the run length encoding for the page\n     * @param dlEncoding the dictionary encoding for the page\n     * @param valuesEncoding the values encoding for the page\n     * @throws IOException if an I/O error occurs\n     */\n    public void writeDataPage(int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException {\n        long beforeHeader = out.getPos();\n        innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding);\n        offsetIndexBuilder.add((int) ("}, {"ID": 1999, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    void writeColumnChunk(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IOException { startColumn(descriptor, valueCount, compressionCodecName); state = state.write(); if (dictionaryPage != null) { writeDictionaryPage(dictionaryPage); } LOG.debug(\"{}: write data pages\", out.getPos()); long headersSize = bytes.size() - compressedTotalPageSize; this.uncompressedLength += uncompressedTotalPageSize + headersSize; this.compressedLength += compressedTotalPageSize + headersSize; LOG.debug(\"{}: write data pages content\", out.getPos()); firstPageOffset = out.getPos(); bytes.writeAllTo(out); encodingStatsBuilder.addDataEncodings(dataEncodings); if (rlEncodings.isEmpty()) { encodingStatsBuilder.withV2Pages(); } currentEncodings.addAll(rlEncodings); currentEncodings.addAll(dlEncodings); currentEncodings.addAll(dataEncodings); currentStatistics = totalStats; this.columnIndexBuilder = columnIndexBuilder; this.offsetIndexBuilder = offsetIndexBuilder; endColumn(); }\n\n    ### Response:", "ground_truth": "Writes a column chunk at once\n@param descriptor the descriptor of the column\n@param valueCount the value count in this column\n@param compressionCodecName the name of the compression codec used for compressing the pages\n@param dictionaryPage the dictionary page for this column chunk (might be null)\n@param bytes the encoded pages including page headers to be written as is\n@param uncompressedTotalPageSize total uncompressed size (without page headers)\n@param compressedTotalPageSize total compressed size (without page headers)\n@param totalStats accumulated statistics for the column chunk\n@param columnIndexBuilder the builder object for the column index\n@param offsetIndexBuilder the builder object for the offset index\n@param rlEncodings the RL encodings used in this column chunk\n@param dlEncodings the DL encodings used in this column chunk\n@param dataEncodings the data encodings used in this column chunk\n@throws IOException if there is an error while writing", "predict": "/**\n     * Writes a column chunk to the output stream.\n     *\n     * @param descriptor the column descriptor\n     * @param valueCount the number of values in the column\n     * @param compressionCodecName the name of the compression codec used for the data pages\n     * @param dictionaryPage the dictionary page, if any\n     * @param bytes the bytes of the data pages\n     * @param uncompressedTotalPageSize the total uncompressed size of the data pages\n     * @param compressedTotalPageSize the total compressed size of the data pages\n     * @param totalStats the statistics for the column\n     * @param columnIndexBuilder the column index builder\n     * @param offsetIndexBuilder the offset index builder\n     * @param rlEncodings the set of run length encodings used for the data pages\n     * @param dlEncodings the set of dictionary encodings used for the data pages\n     * @param dataEncodings the list of data encodings used for the data pages\n     * @throws IOException if an I/O error occurs\n     */\n    void writeColumnChunk(Column"}, {"ID": 2000, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Generate the method-level comment for the following java Code.\n\n    ### Input:\n    public void endBlock() throws IOException { state = state.endBlock(); LOG.debug(\"{}: end block\", out.getPos()); currentBlock.setRowCount(currentRecordCount); blocks.add(currentBlock); columnIndexes.add(currentColumnIndexes); offsetIndexes.add(currentOffsetIndexes); currentColumnIndexes = null; currentOffsetIndexes = null; currentBlock = null; }\n\n    ### Response:", "ground_truth": "ends a block once all column chunks have been written\n@throws IOException if there is an error while writing", "predict": "/**\n     * Ends the current block and adds it to the list of blocks.\n     *\n     * @throws IOException if an I/O error occurs.\n     */\n    public void endBlock() throws IOException {\n        state = state.endBlock();\n        LOG.debug(\"{}: end block\", out.getPos());\n        currentBlock.setRowCount(currentRecordCount);\n        blocks.add(currentBlock);\n        columnIndexes.add(currentColumnIndexes);\n        offsetIndexes.add(currentOffsetIndexes);\n        currentColumnIndexes = null;\n        currentOffsetIndexes = null;\n        currentBlock = null;\n    }"}]