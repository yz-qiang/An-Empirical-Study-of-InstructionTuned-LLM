[{"ID": 101, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    PXA2xxState *pxa255_init(unsigned int sdram_size) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s->env = cpu_init(\"pxa255\"); if (!s->env) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0]; /* SDRAM & Internal Memory Storage */ cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size, qemu_ram_alloc(NULL, \"pxa255.sdram\", sdram_size) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, \"pxa255.internal\", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s->pic = pxa2xx_pic_init(0x40d00000, s->env); s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]); pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]); s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, \"qemu: missing SecureDigital device\\n\"); exit(1); } s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv, s->pic[PXA2XX_PIC_MMC], s->dma); for (i = 0; pxa255_serial[i].io_base; i ++) if (serial_hds[i]) { #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 1); #else serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 0); #endif } else { break; } if (serial_hds[i]) s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP], s->dma, serial_hds[i]); s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]); s->cm_base = 0x41300000; s->cm_regs[CCCR >> 2] = 0x02000210; /* 416.0 MHz */ s->clkcfg = 0x00000009; /* Turbo mode active */ iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype); register_savevm(NULL, \"pxa2xx_cm\", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s->mm_base = 0x48000000; s->mm_regs[MDMRS >> 2] = 0x00020002; s->mm_regs[MDREFR >> 2] = 0x03ca4000; s->mm_regs[MECR >> 2] = 0x00000001; /* Two PC Card sockets */ iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype); register_savevm(NULL, \"pxa2xx_mm\", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s->pm_base = 0x40f00000; iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->pm_base, 0x100, iomemtype); register_savevm(NULL, \"pxa2xx_pm\", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_ssp[i].io_base; i ++); s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_ssp[i].io_base; i ++) { DeviceState *dev; dev = sysbus_create_simple(\"pxa2xx-ssp\", pxa255_ssp[i].io_base, s->pic[pxa255_ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\"); } if (usb_enabled) { sysbus_create_simple(\"sysbus-ohci\", 0x4c000000, s->pic[PXA2XX_PIC_USBH1]); } s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000); s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000); s->rtc_base = 0x40900000; iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype); pxa2xx_rtc_init(s); register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s->i2c[0] = pxa2xx", "ground_truth": "NO", "predict": "_i2c_init(0x40500000, s->pic[PXA2XX_PIC_I2C]); s->i2c[1] = pxa2xx_i2c_init(0x40600000, s->pic[PXA2XX_PIC_I2C]); s->i2c[2] = pxa2xx_i2c_init(0x40700000, s->pic[PXA2XX_PIC_I2C]); s->i2c[3] = pxa2xx_i2c_init(0x40800000, s->pic[PXA2XX_PIC_I2C]); s->i2c[4] = pxa2xx_i2c_init(0x40900000, s->pic[PXA2XX_PIC_I2C"}, {"ID": 105, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int input_buffer_size) { ALACContext *alac = avctx->priv_data; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wasted_bytes; int isnotcompressed; uint8_t interlacing_shift; uint8_t interlacing_leftweight; /* short-circuit null buffers */ if (!inbuffer || !input_buffer_size) return input_buffer_size; /* initialize from the extradata */ if (!alac->context_initialized) { if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) { av_log(avctx, AV_LOG_ERROR, \"alac: expected %d extradata bytes\\n\", ALAC_EXTRADATA_SIZE); return input_buffer_size; } if (alac_set_info(alac)) { av_log(avctx, AV_LOG_ERROR, \"alac: set_info failed\\n\"); return input_buffer_size; } alac->context_initialized = 1; } init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8); channels = get_bits(&alac->gb, 3) + 1; if (channels > MAX_CHANNELS) { av_log(avctx, AV_LOG_ERROR, \"channels > %d not supported\\n\", MAX_CHANNELS); return input_buffer_size; } /* 2^result = something to do with output waiting. * perhaps matters if we read > 1 frame in a pass? */ skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); /* unknown, skip 12 bits */ /* the output sample size is stored soon */ hassize = get_bits1(&alac->gb); wasted_bytes = get_bits(&alac->gb, 2); /* unknown ? */ /* whether the frame is compressed */ isnotcompressed = get_bits1(&alac->gb); if (hassize) { /* now read the number of samples as a 32bit integer */ outputsamples = get_bits_long(&alac->gb, 32); if(outputsamples > alac->setinfo_max_samples_per_frame){ av_log(avctx, AV_LOG_ERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfo_max_samples_per_frame); return -1; } } else outputsamples = alac->setinfo_max_samples_per_frame; if(outputsamples > *outputsize / alac->bytespersample){ av_log(avctx, AV_LOG_ERROR, \"sample buffer too small\\n\"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (!isnotcompressed) { /* so it is compressed */ int16_t predictor_coef_table[channels][32]; int predictor_coef_num[channels]; int prediction_type[channels]; int prediction_quantitization[channels]; int ricemodifier[channels]; int i, chan; interlacing_shift = get_bits(&alac->gb, 8); interlacing_leftweight = get_bits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { prediction_type[chan] = get_bits(&alac->gb, 4); prediction_quantitization[chan] = get_bits(&alac->gb, 4); ricemodifier[chan] = get_bits(&alac->gb, 3); predictor_coef_num[chan] = get_bits(&alac->gb, 5); /* read the predictor table */ for (i = 0; i < predictor_coef_num[chan]; i++) predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16); } if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented, unhandling of wasted_bytes\\n\"); for (chan = 0; chan < channels; chan++) { bastardized_rice_decompress(alac, alac->predicterror_buffer[chan], outputsamples, readsamplesize, alac->setinfo_rice_initialhistory, alac->setinfo_rice_kmodifier, ricemodifier[chan] * alac->setinfo_rice_historymult / 4, (1 << alac->setinfo_rice_kmodifier) - 1); if (prediction_type[chan] == 0) { /* adaptive fir */ predictor_decompress_fir_adapt(alac->predicterror_buffer[chan], alac->outputsamples_buffer[chan], outputsamples, readsamplesize, predictor_coef_table[chan], predictor_coef_num[chan], prediction_quantitization[chan]); } else { av_log(avctx, AV_LOG_ERROR, \"FIXME: unhandled prediction type: %i\\n\", prediction_type[chan]); /* I think the only other prediction type (or perhaps this is * just a boolean?) runs adaptive fir twice.. like: * predictor_decompress_fir_adapt(predictor_error, tempout, ...) * predictor_decompress_fir_adapt(predictor_error, outputsamples ...) * little strange.. */ } } } else { /* not compressed, easy case */ int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32_t audiobits; audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size); audiobits = extend_sign32(audiobits, alac->setinfo_sample_size); alac->outputsamples_buffer[chan][i] = audiobits; } /* wasted_bytes = 0; */ interlacing_shift = 0; interlacing_leftweight = 0; } if (get_bits(&alac->gb, 3) != 7) av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\"); switch(alac->setinfo_sample_size) { case 16: if (channels == 2) { reconstruct_stereo_16(alac->outputsamples_buffer, (int16_t*)outbuffer, alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16_t sample = alac->outputsamples_buffer[0][i]; ((int16_t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: // It is not clear if there exist any encoder that creates 24 bit ALAC // files. iTunes convert 24 bit raw files to 16 bit before encoding. case 32: av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size); break; default: break; } if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8) av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8", "ground_truth": "YES", "predict": " - get_bits_count(&alac->gb)); return input_buffer_size; }"}, {"ID": 211, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *board) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int flash_size; I2CBus *i2c; DeviceState *dev; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = ((board->dc0 >> 18) + 1) * 1024; /* Flash programming is done via the SCU, so pretend it is ROM. */ memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size, &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, true); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES, kernel_filename, cpu_model); if (board->dc1 & (1 << 16)) { dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in(dev, 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { dev = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); /* TODO: This is incorrect, but we get away with it because the ADC output is only ever pulsed. */ qdev_connect_gpio_out(dev, 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if (board->dc2 & (1 << 12)) { dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\"); if (board->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, \"ssd0303\", 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if (board->dc2 & (1 << 4)) { dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]); if (board->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; /* Some boards have both an OLED controller and SD card connected to * the same SSI port, with the SD card chip select connected to a * GPIO pin. Technically the OLED chip select is connected to the * SSI Fss pin. We do not bother emulating that as both devices * should never be selected simultaneously, and our OLED controller * ignores stray 0xff commands that occur when deselecting the SD * card. */ bus = qdev_get_child_bus(dev, \"ssi\"); sddev = ssi_create_slave(bus, \"ssi-sd\"); ssddev = ssi_create_slave(bus, \"ssd0323\"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); /* Make sure the select pin is high. */ qemu_irq_raise(gpio_out[GPIO_D][0]); } } if (board->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], \"stellaris\"); enet = qdev_create(NULL, \"stellaris_enet\"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if (board->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */ gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */ gpad_", "ground_truth": "YES", "predict": "irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */ gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */ gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_E][4]); /* select */ for (i = 0; i < 5; i++) { dev = qdev_create(NULL, \"gpio-keys\"); qdev_init_nofail(dev); qdev_connect_gpio_out(dev, 0, gpad_irq[i]); qdev_connect_gpio_in(dev, 1, gpio_in[GPIO_E][5 + i], gpad_keycode[i]); } } if (board->peripherals & BP_SDCARD) { dev = sysbus_create_simple(\"sdhci-pl280\", 0x4002"}, {"ID": 307, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size, const char *boot_device, DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *env, *envs[MAX_CPUS]; unsigned int i; void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi; qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq, *espdma_irq, *ledma_irq; qemu_irq *esp_reset, *le_reset; ram_addr_t ram_offset, prom_offset, tcx_offset; unsigned long kernel_size; int ret; char buf[1024]; int drive_index; void *fw_cfg; /* init CPUs */ if (!cpu_model) cpu_model = hwdef->default_cpu_model; for (i = 0; i < smp_cpus; i++) { env = cpu_init(cpu_model); if (!env) { fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\"); exit(1); } cpu_sparc_set_id(env, i); envs[i] = env; if (i == 0) { qemu_register_reset(main_cpu_reset, env); } else { qemu_register_reset(secondary_cpu_reset, env); env->halted = 1; } cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS); env->prom_addr = hwdef->slavio_base; } for (i = smp_cpus; i < MAX_CPUS; i++) cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS); /* allocate RAM */ if ((uint64_t)RAM_size > hwdef->max_mem) { fprintf(stderr, \"qemu: Too much memory for this machine: %d, maximum %d\\n\", (unsigned int)(RAM_size / (1024 * 1024)), (unsigned int)(hwdef->max_mem / (1024 * 1024))); exit(1); } ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); /* load boot prom */ prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->slavio_base, (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name); ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL); if (ret < 0 || ret > PROM_SIZE_MAX) ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX); if (ret < 0 || ret > PROM_SIZE_MAX) { fprintf(stderr, \"qemu: could not load prom '%s'\\n\", buf); exit(1); } /* set up devices */ sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs); for (i = 0; i < MAX_IOUNITS; i++) if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1) iounits[i] = iommu_init(hwdef->iounit_bases[i], hwdef->iounit_version, sbi_irq[hwdef->me_irq]); espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq], iounits[0], &espdma_irq, &esp_reset); ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq], iounits[0], &ledma_irq, &le_reset); if (graphic_depth != 8 && graphic_depth != 24) { fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphic_depth); exit (1); } tcx_offset = qemu_ram_alloc(hwdef->vram_size); tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset, hwdef->vram_size, graphic_width, graphic_height, graphic_depth); if (nd_table[0].model == NULL) nd_table[0].model = \"lance\"; if (strcmp(nd_table[0].model, \"lance\") == 0) { lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset); } else if (strcmp(nd_table[0].model, \"?\") == 0) { fprintf(stderr, \"qemu: Supported NICs: lance\\n\"); exit (1); } else { fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model); exit (1); } nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, hwdef->nvram_size, 8); slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq], sbi_cpu_irq, smp_cpus); slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq], nographic, ESCC_CLOCK, 1); // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1], serial_hds[0], ESCC_CLOCK, 1); if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, \"qemu: too many SCSI bus\\n\"); exit(1); } main_esp = esp_init(hwdef->esp_base, 2, espdma_memory_read, espdma_memory_write, espdma, *espdma_irq, esp_reset); for (i = 0; i < ESP_MAX_DEVS; i++) { drive_index = drive_get_index(IF_SCSI, 0, i); if (drive_index == -1) continue; esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i); } kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename, RAM_size); nvram_init(nvram, (uint8_t *)&nd_table[0].mac", "ground_truth": "NO", "predict": "addr, sizeof(nd_table[0].macaddr)); /* load kernel */ if (kernel_size > 0) { cpu_physical_memory_write(ram_offset, kernel_size, kernel_filename); } /* load initrd */ if (initrd_filename && initrd_filename[0]) { cpu_physical_memory_write(ram_offset + kernel_size, initrd_size, initrd_filename); } /* start CPUs */ for (i = 0; i < smp_cpus; i++) { env = envs[i]; env->halted = 0; env->exception_index = -1; env->pc = hwdef->kernel_entry; env->npc = env->pc + 4; env->y = 0; env->g0 = ram_offset; env->g1 = ram_offset + kernel_size; env->g2 = 0; env->g3 = 0; env->g4 = 0;"}, {"ID": 362, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int smacker_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; SmackerContext *smk = s->priv_data; AVStream *st, *ast[7]; int i, ret; int tbase; /* read and check header */ smk->magic = avio_rl32(pb); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = avio_rl32(pb); smk->height = avio_rl32(pb); smk->frames = avio_rl32(pb); smk->pts_inc = (int32_t)avio_rl32(pb); smk->flags = avio_rl32(pb); if(smk->flags & SMACKER_FLAG_RING_FRAME) smk->frames++; for(i = 0; i < 7; i++) smk->audio[i] = avio_rl32(pb); smk->treesize = avio_rl32(pb); if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant) av_log(s, AV_LOG_ERROR, \"treesize too large\\n\"); //FIXME remove extradata \"rebuilding\" smk->mmap_size = avio_rl32(pb); smk->mclr_size = avio_rl32(pb); smk->full_size = avio_rl32(pb); smk->type_size = avio_rl32(pb); for(i = 0; i < 7; i++) { smk->rates[i] = avio_rl24(pb); smk->aflags[i] = avio_r8(pb); smk->pad = avio_rl32(pb); /* setup data */ if(smk->frames > 0xFFFFFF) { av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames); smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size)); smk->frm_flags = av_malloc(smk->frames); if (!smk->frm_size || !smk->frm_flags) { av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); /* read frame info */ for(i = 0; i < smk->frames; i++) { smk->frm_size[i] = avio_rl32(pb); for(i = 0; i < smk->frames; i++) { smk->frm_flags[i] = avio_r8(pb); /* init video codec */ st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); smk->videoindex = st->index; st->codec->width = smk->width; st->codec->height = smk->height; st->codec->pix_fmt = AV_PIX_FMT_PAL8; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO; st->codec->codec_tag = smk->magic; /* Smacker uses 100000 as internal timebase */ if(smk->pts_inc < 0) smk->pts_inc = -smk->pts_inc; else smk->pts_inc *= 100; tbase = 100000; av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1); avpriv_set_pts_info(st, 33, smk->pts_inc, tbase); st->duration = smk->frames; /* handle possible audio streams */ for(i = 0; i < 7; i++) { smk->indexes[i] = -1; if (smk->rates[i]) { ast[i] = avformat_new_stream(s, NULL); if (!ast[i]) return AVERROR(ENOMEM); smk->indexes[i] = ast[i]->index; ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO; if (smk->aflags[i] & SMK_AUD_BINKAUD) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT; } else if (smk->aflags[i] & SMK_AUD_USEDCT) { ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT; } else if (smk->aflags[i] & SMK_AUD_PACKED){ ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO; ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A'); } else { ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8; if (smk->aflags[i] & SMK_AUD_STEREO) { ast[i]->codec->channels = 2; ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO; } else { ast[i]->codec->channels = 1; ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO; ast[i]->codec->sample_rate = smk->rates[i]; ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8; if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8) ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE; avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8); /* load trees to extradata, they will be unpacked by decoder */ if(ff_alloc_extradata(st->codec, smk->treesize + 16)){ av_log(s, AV_LOG_ERROR, \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\", smk->treesize + 16); av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(ENOMEM); ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16); if(ret != st->codec->extradata_size - 16){ av_freep(&smk->frm_size); av_freep(&smk->frm_flags); return AVERROR(EIO); ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size); ((int32_t*)st->codec->extradata)[1] = av_le2", "ground_truth": "YES", "predict": "ne32(smk->mclr_size); ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size); ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size); for(i = 0; i < 7; i++) { ((int32_t*)st->codec->extradata)[4+i] = av_le2ne32(smk->rates[i]); ((uint8_t*)st->codec->extradata)[12+i] = smk->aflags[i]; ((int32_t*)st->codec->extradata)[13+i] = av_le2ne32(smk->pad); } memcpy(st->codec->extradata + 20, smk->trees, smk->treesize); } } } } } }"}, {"ID": 379, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role, int w, int h) { ImageContext *img; HuffReader *hg; int i, j, ret, x, y, width; img = &s->image[role]; img->role = role; if (!img->frame) { img->frame = av_frame_alloc(); if (!img->frame) return AVERROR(ENOMEM); } img->frame->format = AV_PIX_FMT_ARGB; img->frame->width = w; img->frame->height = h; if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) { ThreadFrame pt = { .f = img->frame }; ret = ff_thread_get_buffer(s->avctx, &pt, 0); } else ret = av_frame_get_buffer(img->frame, 1); if (ret < 0) return ret; if (get_bits1(&s->gb)) { img->color_cache_bits = get_bits(&s->gb, 4); if (img->color_cache_bits < 1 || img->color_cache_bits > 11) { av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\", img->color_cache_bits); return AVERROR_INVALIDDATA; } img->color_cache = av_mallocz_array(1 << img->color_cache_bits, sizeof(*img->color_cache)); if (!img->color_cache) return AVERROR(ENOMEM); } else { img->color_cache_bits = 0; } img->nb_huffman_groups = 1; if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) { ret = decode_entropy_image(s); if (ret < 0) return ret; img->nb_huffman_groups = s->nb_huffman_groups; } img->huffman_groups = av_mallocz_array(img->nb_huffman_groups * HUFFMAN_CODES_PER_META_CODE, sizeof(*img->huffman_groups)); if (!img->huffman_groups) return AVERROR(ENOMEM); for (i = 0; i < img->nb_huffman_groups; i++) { hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE]; for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) { int alphabet_size = alphabet_sizes[j]; if (!j && img->color_cache_bits > 0) alphabet_size += 1 << img->color_cache_bits; if (get_bits1(&s->gb)) { read_huffman_code_simple(s, &hg[j]); } else { ret = read_huffman_code_normal(s, &hg[j], alphabet_size); if (ret < 0) return ret; } } } width = img->frame->width; if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0) width = s->reduced_width; x = 0; y = 0; while (y < img->frame->height) { int v; hg = get_huffman_group(s, img, x, y); v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb); if (v < NUM_LITERAL_CODES) { /* literal pixel values */ uint8_t *p = GET_PIXEL(img->frame, x, y); p[2] = v; p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED], &s->gb); p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE], &s->gb); p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb); if (img->color_cache_bits) color_cache_put(img, AV_RB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) { /* LZ77 backwards mapping */ int prefix_code, length, distance, ref_x, ref_y; /* parse length and distance */ prefix_code = v - NUM_LITERAL_CODES; if (prefix_code < 4) { length = prefix_code + 1; } else { int extra_bits = (prefix_code - 2) >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; length = offset + get_bits(&s->gb, extra_bits) + 1; } prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb); if (prefix_code > 39) { av_log(s->avctx, AV_LOG_ERROR, \"distance prefix code too large: %d\\n\", prefix_code); return AVERROR_INVALIDDATA; } if (prefix_code < 4) { distance = prefix_code + 1; } else { int extra_bits = prefix_code - 2 >> 1; int offset = 2 + (prefix_code & 1) << extra_bits; distance = offset + get_bits(&s->gb, extra_bits) + 1; } /* find reference location */ if (distance <= NUM_SHORT_DISTANCES) { int xi = lz77_distance_offsets[distance - 1][0]; int yi = lz77_distance_offsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUM_SHORT_DISTANCES; } ref_x = x; ref_y = y; if (distance <= x) { ref_x -= distance; distance = 0; } else { ref_x = 0; distance -= x; } while (distance >= width) { ref_y--; distance -= width; } if (distance > 0) { ref_x = width - distance; ref_y--; } ref_x = FFMAX(0, ref_x); ref_y = FFMAX(0, ref_y); /* copy pixels * source and dest regions can overlap and wrap lines, so just * copy per-pixel */ for (i = 0; i < length; i++) { uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y); uint8_t *p = GET_PIXEL(img->frame, x, y); AV_COPY32(p, p_ref); if (img->color_cache_bits) color_cache_put(img, AV_RB32(p)); x++; ref_x++; if (x == width) { x = 0; y++; } if (ref_x == width) { ref_x = 0; ref_y++; } if (y == img->frame->height || ref_y == img->frame->height) break; } } else { /* read from color cache */ uint8_t *p = GET_PIXEL(img->frame, x, y); int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES); if (!img->color_cache_bits) { av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\"); return AVERROR_INVALIDDATA; } if (cache_idx >= 1 << img->color_cache_bits) { av_log(s", "ground_truth": "YES", "predict": "->avctx, AV_LOG_ERROR, \"color cache index out of range: %d\\n\", cache_idx); return AVERROR_INVALIDDATA; } AV_COPY32(p, img->color_cache[cache_idx]); x++; if (x == width) { x = 0; y++; } } } } if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) { ThreadFrame pt = { .f = img->frame }; ff_thread_release_buffer(s->avctx, &pt); } return 0; }"}, {"ID": 455, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void pc_init1(QEMUMachineInitArgs *args, int pci_enabled, int kvmclock_enabled) { MemoryRegion *system_memory = get_system_memory(); MemoryRegion *system_io = get_system_io(); int i; ram_addr_t below_4g_mem_size, above_4g_mem_size; PCIBus *pci_bus; ISABus *isa_bus; PCII440FXState *i440fx_state; int piix3_devfn = -1; qemu_irq *cpu_irq; qemu_irq *gsi; qemu_irq *i8259; qemu_irq *smi_irq; GSIState *gsi_state; DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BusState *idebus[MAX_IDE_BUS]; ISADevice *rtc_state; ISADevice *floppy; MemoryRegion *ram_memory; MemoryRegion *pci_memory; MemoryRegion *rom_memory; DeviceState *icc_bridge; FWCfgState *fw_cfg = NULL; PcGuestInfo *guest_info; if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) { fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\"); exit(1); } icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE); object_property_add_child(qdev_get_machine(), \"icc-bridge\", OBJECT(icc_bridge), NULL); pc_cpus_init(args->cpu_model, icc_bridge); if (kvm_enabled() && kvmclock_enabled) { kvmclock_create(); } /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory). * If it doesn't, we need to split it in chunks below and above 4G. * In any case, try to make sure that guest addresses aligned at * 1G boundaries get mapped to host addresses aligned at 1G boundaries. * For old machine types, use whatever split we used historically to avoid * breaking migration. */ if (args->ram_size >= 0xe0000000) { ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000; above_4g_mem_size = args->ram_size - lowmem; below_4g_mem_size = lowmem; } else { above_4g_mem_size = 0; below_4g_mem_size = args->ram_size; } if (pci_enabled) { pci_memory = g_new(MemoryRegion, 1); memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX); rom_memory = pci_memory; } else { pci_memory = NULL; rom_memory = system_memory; } guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size); guest_info->has_acpi_build = has_acpi_build; guest_info->has_pci_info = has_pci_info; guest_info->isapc_ram_fw = !pci_enabled; if (smbios_defaults) { /* These values are guest ABI, do not change */ smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\", args->machine->name); } /* allocate ram and load rom/bios */ if (!xen_enabled()) { fw_cfg = pc_memory_init(system_memory, args->kernel_filename, args->kernel_cmdline, args->initrd_filename, below_4g_mem_size, above_4g_mem_size, rom_memory, &ram_memory, guest_info); } gsi_state = g_malloc0(sizeof(*gsi_state)); if (kvm_irqchip_in_kernel()) { kvm_pc_setup_irq_routing(pci_enabled); gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state, GSI_NUM_PINS); } else { gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS); } if (pci_enabled) { pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi, system_memory, system_io, args->ram_size, below_4g_mem_size, above_4g_mem_size, pci_memory, ram_memory); } else { pci_bus = NULL; i440fx_state = NULL; isa_bus = isa_bus_new(NULL, system_io); no_hpet = 1; } isa_bus_irqs(isa_bus, gsi); if (kvm_irqchip_in_kernel()) { i8259 = kvm_i8259_init(isa_bus); } else if (xen_enabled()) { i8259 = xen_interrupt_controller_init(); } else { cpu_irq = pc_allocate_cpu_irq(); i8259 = i8259_init(isa_bus, cpu_irq[0]); } for (i = 0; i < ISA_NUM_IRQS; i++) { gsi_state->i8259_irq[i] = i8259[i]; } if (pci_enabled) { ioapic_init_gsi(gsi_state, \"i440fx\"); } qdev_init_nofail(icc_bridge); pc_register_ferr_irq(gsi[13]); pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL); /* init basic PC hardware */ pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(), 0x4); pc_nic_init(isa_bus, pci_bus); ide_drive_get(hd, MAX_IDE_BUS); if (pci_enabled) { PCIDevice *dev; if (xen_enabled()) { dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1); } else { dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1); } idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\"); idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\"); } else { for(i = 0; i < MAX_IDE_BUS; i++) { ISADevice *dev; char busname[] = \"ide.0\"; dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i], ide_irq[i], hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]); /* * The ide bus name is ide.0 for the first bus and ide.1 for the * second one. */ busname[4] = '0' + i; idebus[i] = qdev_get_child_bus(DEVICE(dev), busname); } } pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_", "ground_truth": "NO", "predict": "order, args->boot_menu, args->boot_time); if (args->machine->default_machine_opts) { args->machine->default_machine_opts(args); } if (args->machine->init_machine) { args->machine->init_machine(args); } if (args->machine->exit_machine) { qemu_add_exit_handler(args->machine->exit_machine, args); } }"}, {"ID": 680, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { CuvidContext *ctx = avctx->priv_data; AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *device_hwctx = device_ctx->hwctx; CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx; AVFrame *frame = data; CUVIDSOURCEDATAPACKET cupkt; AVPacket filter_packet = { 0 }; AVPacket filtered_packet = { 0 }; CUdeviceptr mapped_frame = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) { av_log(avctx, AV_LOG_ERROR, \"av_packet_ref failed\\n\"); return ret; } if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, \"av_bsf_send_packet failed\\n\"); av_packet_unref(&filter_packet); return ret; } if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) { av_log(avctx, AV_LOG_ERROR, \"av_bsf_receive_packet failed\\n\"); return ret; } avpkt = &filtered_packet; } ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx)); if (ret < 0) { av_packet_unref(&filtered_packet); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payload_size = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AV_NOPTS_VALUE) { cupkt.flags = CUVID_PKT_TIMESTAMP; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVID_PKT_ENDOFSTREAM; } ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt)); av_packet_unref(&filtered_packet); if (ret < 0) { if (ctx->internal_error) ret = ctx->internal_error; goto error; } if (av_fifo_size(ctx->frame_queue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressive_frame = dispinfo.progressive_frame; params.second_field = 0; params.top_field_first = dispinfo.top_field_first; ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params)); if (ret < 0) goto error; if (avctx->pix_fmt == AV_PIX_FMT_CUDA) { ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, \"av_hwframe_get_buffer failed\\n\"); goto error; } ret = ff_decode_frame_props(avctx, frame); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, \"ff_decode_frame_props failed\\n\"); goto error; } for (i = 0; i < 2; i++) { CUDA_MEMCPY2D cpy = { .srcMemoryType = CU_MEMORYTYPE_DEVICE, .dstMemoryType = CU_MEMORYTYPE_DEVICE, .srcDevice = mapped_frame, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->coded_height >> (i ? 1 : 0), }; ret = CHECK_CU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->coded_height; } } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) { AVFrame *tmp_frame = av_frame_alloc(); if (!tmp_frame) { av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\"); ret = AVERROR(ENOMEM); goto error; } tmp_frame->format = AV_PIX_FMT_CUDA; tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe); tmp_frame->data[0] = (uint8_t*)mapped_frame; tmp_frame->linesize[0] = pitch; tmp_frame->data[1] = (uint8_t*)(mapped_frame + avctx->coded_height * pitch); tmp_frame->linesize[1] = pitch; tmp_frame->width = avctx->width; tmp_frame->height = avctx->height; ret = ff_get_buffer(avctx, frame, 0); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\"); av_frame_free(&tmp_frame); goto error; } ret = av_hwframe_transfer_data(frame, tmp_frame, 0); if (ret) { av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\"); av_frame_free(&tmp_frame); goto error; } av_frame_free(&tmp_frame); } else { ret = AVERROR_BUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkt_timebase.num && avctx->pkt_timebase.den) frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase); else frame->pts = dispinfo.timestamp; /* CUVIDs opaque reordering breaks the internal pkt logic. * So set pkt_pts and clear all the other pkt_ fields. */ frame->pkt_pts = frame->pts; av_frame_set_pkt_pos(frame, -1); av_frame_set_pkt_duration(frame, 0); av_frame_set_pkt_size(frame, -1); frame->interlaced_frame = !dispinfo.progressive_frame; if (!dispinfo.progressive_frame) frame->top_field_first = dispinfo.top_field_first; *got_frame = 1; } else { *got_frame = 0; } error: if (mapped_frame) eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame)); eret = CHECK_CU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; }", "ground_truth": "YES", "predict": " \r\n\r\n### Output:No, there is no defect in the code."}, {"ID": 735, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int plane_idx, int is_key, int is_chroma) { int blk, ret; int i, j, bx, by; uint8_t *dst, *ref, *ref_start, *ref_end; int v, col[2]; const uint8_t *scan; int xoff, yoff; LOCAL_ALIGNED_16(int16_t, block, [64]); LOCAL_ALIGNED_16(int32_t, dctblock, [64]); int coordmap[64]; int ybias = is_key ? -15 : 0; int qp; const int stride = frame->linesize[plane_idx]; int bw = is_chroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkb_init_bundles(c); ref_start = frame->data[plane_idx]; ref_end = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8; for (i = 0; i < 64; i++) coordmap[i] = (i & 7) + (i >> 3) * stride; for (by = 0; by < bh; by++) { for (i = 0; i < BINKB_NB_SRC; i++) { if ((ret = binkb_read_bundle(c, bc, i)) < 0) return ret; } dst = frame->data[plane_idx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES); switch (blk) { case 0: break; case 1: scan = bink_patterns[bitstream_read(bc, 4)]; i = 0; do { int mode = bitstream_read_bit(bc); int run = bitstream_read(bc, binkb_runbits[i]) + 1; i += run; if (i > 64) { av_log(c->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\"); return AVERROR_INVALIDDATA; } if (mode) { v = binkb_get_value(c, BINKB_SRC_COLORS); for (j = 0; j < run; j++) dst[coordmap[*scan++]] = v; } else { for (j = 0; j < run; j++) dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); } } while (i < 63); if (i == 63) dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC); qp = binkb_get_value(c, BINKB_SRC_INTRA_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp); c->binkdsp.idct_put(dst, stride, dctblock); break; case 3: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8*stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } c->bdsp.clear_block(block); v = binkb_get_value(c, BINKB_SRC_INTER_COEFS); read_residue(bc, block, v); c->binkdsp.add_pixels8(dst, block, stride); break; case 4: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC); qp = binkb_get_value(c, BINKB_SRC_INTER_Q); read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp); c->binkdsp.idct_add(dst, stride, dctblock); break; case 5: v = binkb_get_value(c, BINKB_SRC_COLORS); c->bdsp.fill_block_tab[1](dst, v, stride, 8); break; case 6: for (i = 0; i < 2; i++) col[i] = binkb_get_value(c, BINKB_SRC_COLORS); for (i = 0; i < 8; i++) { v = binkb_get_value(c, BINKB_SRC_PATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[i*stride + j] = col[v & 1]; } break; case 7: xoff = binkb_get_value(c, BINKB_SRC_X_OFF); yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < ref_start || ref + 8 * stride > ref_end) { av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8); } else { put_pixels8x8_overlapped(dst, ref, stride); } break; case 8: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_", "ground_truth": "NO", "predict": "SRC_BLOCK_DATA].data + i*8, 8); break; case 9: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_BLOCK_DATA].data + i*8, 8); break; case 10: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_BLOCK_DATA].data + i*8, 8); break; case 11: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_BLOCK_DATA].data + i*8, 8); break; case 12: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKB_SRC_BLOCK_DATA].data + i*8, "}, {"ID": 769, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static av_cold int vc2_encode_init(AVCodecContext *avctx) { Plane *p; SubBand *b; int i, j, level, o, shift; const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt); const int depth = fmt->comp[0].depth; VC2EncContext *s = avctx->priv_data; s->picture_number = 0; /* Total allowed quantization range */ s->q_ceil = DIRAC_MAX_QUANT_INDEX; s->ver.major = 2; s->ver.minor = 0; s->profile = 3; s->level = 3; s->base_vf = -1; s->strict_compliance = 1; s->q_avg = 0; s->slice_max_bytes = 0; s->slice_min_bytes = 0; /* Mark unknown as progressive */ s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) || (avctx->field_order == AV_FIELD_PROGRESSIVE)); for (i = 0; i < base_video_fmts_len; i++) { const VC2BaseVideoFormat *fmt = &base_video_fmts[i]; if (avctx->pix_fmt != fmt->pix_fmt) continue; if (avctx->time_base.num != fmt->time_base.num) continue; if (avctx->time_base.den != fmt->time_base.den) continue; if (avctx->width != fmt->width) continue; if (avctx->height != fmt->height) continue; if (s->interlaced != fmt->interlaced) continue; s->base_vf = i; s->level = base_video_fmts[i].level; break; } if (s->interlaced) av_log(avctx, AV_LOG_WARNING, \"Interlacing enabled!\\n\"); if ((s->slice_width & (s->slice_width - 1)) || (s->slice_height & (s->slice_height - 1))) { av_log(avctx, AV_LOG_ERROR, \"Slice size is not a power of two!\\n\"); return AVERROR_UNKNOWN; } if ((s->slice_width > avctx->width) || (s->slice_height > avctx->height)) { av_log(avctx, AV_LOG_ERROR, \"Slice size is bigger than the image!\\n\"); return AVERROR_UNKNOWN; } if (s->base_vf <= 0) { if (avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { s->strict_compliance = s->base_vf = 0; av_log(avctx, AV_LOG_WARNING, \"Disabling strict compliance\\n\"); } else { av_log(avctx, AV_LOG_WARNING, \"Given format does not strictly comply with \" \"the specifications, please add a -strict -1 flag to use it\\n\"); return AVERROR_UNKNOWN; } } else { av_log(avctx, AV_LOG_INFO, \"Selected base video format = %i (%s)\\n\", s->base_vf, base_video_fmts[s->base_vf].name); } /* Chroma subsampling */ avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift); /* Bit depth and color range index */ if (depth == 8 && avctx->color_range == AVCOL_RANGE_JPEG) { s->bpp = 1; s->bpp_idx = 1; s->diff_offset = 128; } else if (depth == 8 && (avctx->color_range == AVCOL_RANGE_MPEG || avctx->color_range == AVCOL_RANGE_UNSPECIFIED)) { s->bpp = 1; s->bpp_idx = 2; s->diff_offset = 128; } else if (depth == 10) { s->bpp = 2; s->bpp_idx = 3; s->diff_offset = 512; } else { s->bpp = 2; s->bpp_idx = 4; s->diff_offset = 2048; } /* Planes initialization */ for (i = 0; i < 3; i++) { int w, h; p = &s->plane[i]; p->width = avctx->width >> (i ? s->chroma_x_shift : 0); p->height = avctx->height >> (i ? s->chroma_y_shift : 0); if (s->interlaced) p->height >>= 1; p->dwt_width = w = FFALIGN(p->width, (1 << s->wavelet_depth)); p->dwt_height = h = FFALIGN(p->height, (1 << s->wavelet_depth)); p->coef_stride = FFALIGN(p->dwt_width, 32); p->coef_buf = av_malloc(p->coef_stride*p->dwt_height*sizeof(dwtcoef)); if (!p->coef_buf) goto alloc_fail; for (level = s->wavelet_depth-1; level >= 0; level--) { w = w >> 1; h = h >> 1; for (o = 0; o < 4; o++) { b = &p->band[level][o]; b->width = w; b->height = h; b->stride = p->coef_stride; shift = (o > 1)*b->height*b->stride + (o & 1)*b->width; b->buf = p->coef_buf + shift; } } /* DWT init */ if (ff_vc2enc_init_transforms(&s->transform_args[i].t, s->plane[i].coef_stride, s->plane[i].dwt_height)) goto alloc_fail; } /* Slices */ s->num_x = s->plane[0].dwt_width/s->slice_width; s->num_y = s->plane[0].dwt_height/s->slice_height; s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs)); if (!s->slice_args) goto alloc_fail; /* Lookup tables */ s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len)); if (!s->coef_lut_len) goto alloc_fail; s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val)); if (!s->coef_lut_val) goto alloc_fail; for (i = 0; i < s->q_ceil; i++) { uint8_t *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB]; uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB]; for (j = 0; j < COEF_LUT_TAB; j++) { get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]), &len_lut[j], &val_lut[j]); if (len_lut[j] != 1) { len_lut[j] += 1; val_lut[j] <<= 1; } else { val_lut[j] =", "ground_truth": "NO", "predict": " 0; } } } return 0; alloc_fail: av_log(avctx, AV_LOG_ERROR, \"Memory allocation failed!\\n\"); return AVERROR(ENOMEM); }"}, {"ID": 961, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd, abi_long cmd, abi_long arg) { void *argptr; struct dm_ioctl *host_dm; abi_long guest_data; uint32_t guest_data_size; int target_size; const argtype *arg_type = ie->arg_type; abi_long ret; void *big_buf = NULL; char *host_data; arg_type++; target_size = thunk_type_size(arg_type, 0); argptr = lock_user(VERIFY_READ, arg, target_size, 1); if (!argptr) { ret = -TARGET_EFAULT; goto out; } thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST); unlock_user(argptr, arg, 0); /* buf_temp is too small, so fetch things into a bigger buffer */ big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2); memcpy(big_buf, buf_temp, target_size); buf_temp = big_buf; host_dm = big_buf; guest_data = arg + host_dm->data_start; if ((guest_data - arg) < 0) { ret = -EINVAL; goto out; } guest_data_size = host_dm->data_size - host_dm->data_start; host_data = (char*)host_dm + host_dm->data_start; argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_LIST_DEVICES: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_DEV_WAIT: case DM_TABLE_STATUS: case DM_TABLE_CLEAR: case DM_TABLE_DEPS: case DM_LIST_VERSIONS: /* no input data */ break; case DM_DEV_RENAME: case DM_DEV_SET_GEOMETRY: /* data contains only strings */ memcpy(host_data, argptr, guest_data_size); break; case DM_TARGET_MSG: memcpy(host_data, argptr, guest_data_size); *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr); break; case DM_TABLE_LOAD: { void *gspec = argptr; void *cur_data = host_data; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { struct dm_target_spec *spec = cur_data; uint32_t next; int slen; thunk_convert(spec, gspec, arg_type, THUNK_HOST); slen = strlen((char*)gspec + spec_size) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + spec_size); gspec += next; cur_data += spec->next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, 0); ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp)); if (!is_error(ret)) { guest_data = arg + host_dm->data_start; guest_data_size = host_dm->data_size - host_dm->data_start; argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0); switch (ie->host_cmd) { case DM_REMOVE_ALL: case DM_DEV_CREATE: case DM_DEV_REMOVE: case DM_DEV_RENAME: case DM_DEV_SUSPEND: case DM_DEV_STATUS: case DM_TABLE_LOAD: case DM_TABLE_CLEAR: case DM_TARGET_MSG: case DM_DEV_SET_GEOMETRY: /* no return data */ break; case DM_LIST_DEVICES: { struct dm_name_list *nl = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) }; int nl_size = 12; /* can't use thunk_size due to alignment */ while (1) { uint32_t next = nl->next; if (next) { nl->next = nl_size + (strlen(nl->name) + 1); } if (remaining_data < nl->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, nl, arg_type, THUNK_TARGET); strcpy(cur_data + nl_size, nl->name); cur_data += nl->next; remaining_data -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DM_DEV_WAIT: case DM_TABLE_STATUS: { struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) }; int spec_size = thunk_type_size(arg_type, 0); int i; for (i = 0; i < host_dm->target_count; i++) { uint32_t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (cur_data - argptr) + spec_size + slen; if (guest_data_size < spec->next) { host_dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, spec, arg_type, THUNK_TARGET); strcpy(cur_data + spec_size, (char*)&spec[1]); cur_data = argptr + spec->next; spec = (void*)host_dm + host_dm->data_start + next; } break; } case DM_TABLE_DEPS: { void *hdata = (void*)host_dm + host_dm->data_start; int count = *(uint32_t*)hdata; uint64_t *hdev = hdata + 8; uint64_t *gdev = argptr + 8; int i; *(uint32_t*)argptr = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DM_LIST_VERSIONS: { struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start; uint32_t remaining_data = guest_data_size; void *cur_data = argptr; const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) }; int vers_size = thunk_type_size(arg_type, 0); while (1) { uint32_t next = vers->next; if (next) { vers->next = vers_size + (strlen(vers->name) + 1); } if (remaining_data < vers->next) { host_", "ground_truth": "NO", "predict": "dm->flags |= DM_BUFFER_FULL_FLAG; break; } thunk_convert(cur_data, vers, arg_type, THUNK_TARGET); strcpy(cur_data + vers_size, vers->name); cur_data += vers->next; remaining_data -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGET_EINVAL; goto out; } unlock_user(argptr, guest_data, 1); } out: if (big_buf) { g_free(big_buf); } return ret; } \r\n\r\n### Output:NO. The code is correct and does not have any defects."}, {"ID": 970, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, long width, long height, long lumStride, long chromStride, long srcStride) { long y; const x86_reg chromWidth= width>>1; for (y=0; y<height; y+=2) { #if COMPILE_TEMPLATE_MMX __asm__ volatile( \"xor %%\"REG_a\", %%\"REG_a\" \\n\\t\" \"pcmpeqw %%mm7, %%mm7 \\n\\t\" \"psrlw $8, %%mm7 \\n\\t\" // FF,00,FF,00... \".p2align 4 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REG_a\", 4) \\n\\t\" \"movq (%0, %%\"REG_a\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REG_a\", 4), %%mm1 \\n\\t\" // YUYV YUYV(4) \"movq %%mm0, %%mm2 \\n\\t\" // YUYV YUYV(0) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(4) \"psrlw $8, %%mm0 \\n\\t\" // U0V0 U0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(4) \"packuswb %%mm1, %%mm0 \\n\\t\" // UVUV UVUV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(0) MOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2) \\n\\t\" \"movq 16(%0, %%\"REG_a\", 4), %%mm1 \\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REG_a\", 4), %%mm2 \\n\\t\" // YUYV YUYV(12) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(8) \"movq %%mm2, %%mm4 \\n\\t\" // YUYV YUYV(12) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(8) \"psrlw $8, %%mm2 \\n\\t\" // U0V0 U0V0(12) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm4 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm2, %%mm1 \\n\\t\" // UVUV UVUV(8) \"packuswb %%mm4, %%mm3 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2) \\n\\t\" \"movq %%mm0, %%mm2 \\n\\t\" // UVUV UVUV(0) \"movq %%mm1, %%mm3 \\n\\t\" // UVUV UVUV(8) \"psrlw $8, %%mm0 \\n\\t\" // V0V0 V0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // V0V0 V0V0(8) \"pand %%mm7, %%mm2 \\n\\t\" // U0U0 U0U0(0) \"pand %%mm7, %%mm3 \\n\\t\" // U0U0 U0U0(8) \"packuswb %%mm1, %%mm0 \\n\\t\" // VVVV VVVV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // UUUU UUUU(0) MOVNTQ\" %%mm0, (%3, %%\"REG_a\") \\n\\t\" MOVNTQ\" %%mm2, (%2, %%\"REG_a\") \\n\\t\" \"add $8, %%\"REG_a\" \\n\\t\" \"cmp %4, %%\"REG_a\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth) : \"memory\", \"%\"REG_a ); ydst += lumStride; src += srcStride; __asm__ volatile( \"xor %%\"REG_a\", %%\"REG_a\" \\n\\t\" \".p2align 4 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REG_a\", 4) \\n\\t\" \"movq (%0, %%\"REG_a\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REG_a\", 4), %%mm1 \\n\\t\" // YUYV YUYV(4) \"movq 16(%0, %%\"REG_a\", 4), %%mm2 \\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REG_a\", 4), %%mm3 \\n\\t\" // YUYV YUYV(12) \"pand %%mm7, %%mm0 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm1 \\n\\t\" // Y0Y0 Y0Y0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm1, %%mm0 \\n\\t\" // YYYY YYYY(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2) \\n\\t\" MOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\" \"add $8, %%\"REG_a\" \\n\\t\" \"cmp %4, %%\"REG_a\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth) : \"memory\", \"%\"REG_a ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride", "ground_truth": "NO", "predict": "; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride; #endif } }"}, {"ID": 987, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int decode_element(AVCodecContext *avctx, void *data, int ch_index, int channels) { ALACContext *alac = avctx->priv_data; int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret; uint32_t output_samples; int i, ch; skip_bits(&alac->gb, 4); /* element instance tag */ skip_bits(&alac->gb, 12); /* unused header bits */ /* the number of output samples is stored in the frame */ has_size = get_bits1(&alac->gb); alac->extra_bits = get_bits(&alac->gb, 2) << 3; bps = alac->sample_size - alac->extra_bits + channels - 1; if (bps > 32) { av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps); return AVERROR_PATCHWELCOME; } /* whether the frame is compressed */ is_compressed = !get_bits1(&alac->gb); if (has_size) output_samples = get_bits_long(&alac->gb, 32); else output_samples = alac->max_samples_per_frame; if (!output_samples || output_samples > alac->max_samples_per_frame) { av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\", output_samples); return AVERROR_INVALIDDATA; } if (!alac->nb_samples) { /* get output buffer */ alac->frame.nb_samples = output_samples; if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\"); return ret; } } else if (output_samples != alac->nb_samples) { av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\", output_samples, alac->nb_samples); return AVERROR_INVALIDDATA; } alac->nb_samples = output_samples; if (alac->direct_output) { for (ch = 0; ch < channels; ch++) alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch]; } if (is_compressed) { int16_t lpc_coefs[2][32]; int lpc_order[2]; int prediction_type[2]; int lpc_quant[2]; int rice_history_mult[2]; decorr_shift = get_bits(&alac->gb, 8); decorr_left_weight = get_bits(&alac->gb, 8); for (ch = 0; ch < channels; ch++) { prediction_type[ch] = get_bits(&alac->gb, 4); lpc_quant[ch] = get_bits(&alac->gb, 4); rice_history_mult[ch] = get_bits(&alac->gb, 3); lpc_order[ch] = get_bits(&alac->gb, 5); /* read the predictor table */ for (i = lpc_order[ch] - 1; i >= 0; i--) lpc_coefs[ch][i] = get_sbits(&alac->gb, 16); } if (alac->extra_bits) { for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits); } } for (ch = 0; ch < channels; ch++) { int ret=rice_decompress(alac, alac->predict_error_buffer[ch], alac->nb_samples, bps, rice_history_mult[ch] * alac->rice_history_mult / 4); if(ret<0) return ret; /* adaptive FIR filter */ if (prediction_type[ch] == 15) { /* Prediction type 15 runs the adaptive FIR twice. * The first pass uses the special-case coef_num = 31, while * the second pass uses the coefs from the bitstream. * * However, this prediction type is not currently used by the * reference encoder. */ lpc_prediction(alac->predict_error_buffer[ch], alac->predict_error_buffer[ch], alac->nb_samples, bps, NULL, 31, 0); } else if (prediction_type[ch] > 0) { av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\", prediction_type[ch]); } lpc_prediction(alac->predict_error_buffer[ch], alac->output_samples_buffer[ch], alac->nb_samples, bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]); } } else { /* not compressed, easy case */ for (i = 0; i < alac->nb_samples; i++) { if(get_bits_left(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) { alac->output_samples_buffer[ch][i] = get_sbits_long(&alac->gb, alac->sample_size); } } alac->extra_bits = 0; decorr_shift = 0; decorr_left_weight = 0; } if (channels == 2 && decorr_left_weight) { decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples, decorr_shift, decorr_left_weight); } if (alac->extra_bits) { append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer, alac->extra_bits, channels, alac->nb_samples); } if(av_sample_fmt_is_planar(avctx->sample_fmt)) { switch(alac->sample_size) { case 16: { for (ch = 0; ch < channels; ch++) { int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch]; for (i = 0; i < alac->nb_samples; i++) *outbuffer++ = alac->output_samples_buffer[ch][i]; }} break; case 24: { for (ch = 0; ch < channels; ch++) { for (i = 0; i < alac->nb_samples; i++) alac->output_samples_buffer[ch][i] <<= 8; }} break; } }else{ switch(alac->sample_size) { case 16: { int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i]; outbuffer += alac->channels - channels; } } break; case 24: { int32_t *outbuffer", "ground_truth": "NO", "predict": " = ((int32_t *)alac->frame.extended_data[0]) + ch_index; for (i = 0; i < alac->nb_samples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->output_samples_buffer[ch][i] << 8; outbuffer += alac->channels - channels; } } break; } } return 0; }"}, {"ID": 1004, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *ps, int bit_length) { AVBufferRef *pps_buf; const SPS *sps; unsigned int pps_id = get_ue_golomb(gb); PPS *pps; int qp_bd_offset; int bits_left; int ret; if (pps_id >= MAX_PPS_COUNT) { av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id); return AVERROR_INVALIDDATA; pps_buf = av_buffer_allocz(sizeof(*pps)); if (!pps_buf) return AVERROR(ENOMEM); pps = (PPS*)pps_buf->data; pps->data_size = gb->buffer_end - gb->buffer; if (pps->data_size > sizeof(pps->data)) { av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \" \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\", pps->data_size, sizeof(pps->data)); pps->data_size = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->data_size); pps->sps_id = get_ue_golomb_31(gb); if ((unsigned)pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id); sps = (const SPS*)ps->sps_list[pps->sps_id]->data; if (sps->bit_depth_luma > 14) { av_log(avctx, AV_LOG_ERROR, \"Invalid luma bit depth=%d\\n\", sps->bit_depth_luma); } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) { av_log(avctx, AV_LOG_ERROR, \"Unimplemented luma bit depth=%d\\n\", sps->bit_depth_luma); ret = AVERROR_PATCHWELCOME; pps->cabac = get_bits1(gb); pps->pic_order_present = get_bits1(gb); pps->slice_group_count = get_ue_golomb(gb) + 1; if (pps->slice_group_count > 1) { pps->mb_slice_group_map_type = get_ue_golomb(gb); av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\"); switch (pps->mb_slice_group_map_type) { case 0: #if 0 | for (i = 0; i <= num_slice_groups_minus1; i++) | | | | run_length[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < num_slice_groups_minus1; i++) { | | | | top_left_mb[i] |1 |ue(v) | | bottom_right_mb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slice_group_change_direction_flag |1 |u(1) | | slice_group_change_rate_minus1 |1 |ue(v) | #endif break; case 6: #if 0 | slice_group_id_cnt_minus1 |1 |ue(v) | | for (i = 0; i <= slice_group_id_cnt_minus1; i++)| | | | slice_group_id[i] |1 |u(v) | #endif break; pps->ref_count[0] = get_ue_golomb(gb) + 1; pps->ref_count[1] = get_ue_golomb(gb) + 1; if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) { av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\"); qp_bd_offset = 6 * (sps->bit_depth_luma - 8); pps->weighted_pred = get_bits1(gb); pps->weighted_bipred_idc = get_bits(gb, 2); pps->init_qp = get_se_golomb(gb) + 26 + qp_bd_offset; pps->init_qs = get_se_golomb(gb) + 26 + qp_bd_offset; pps->chroma_qp_index_offset[0] = get_se_golomb(gb); pps->deblocking_filter_parameters_present = get_bits1(gb); pps->constrained_intra_pred = get_bits1(gb); pps->redundant_pic_cnt_present = get_bits1(gb); pps->transform_8x8_mode = 0; memcpy(pps->scaling_matrix4, sps->scaling_matrix4, sizeof(pps->scaling_matrix4)); memcpy(pps->scaling_matrix8, sps->scaling_matrix8, sizeof(pps->scaling_matrix8)); bits_left = bit_length - get_bits_count(gb); if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) { pps->transform_8x8_mode = get_bits1(gb); decode_scaling_matrices(gb, sps, pps, 0, pps->scaling_matrix4, pps->scaling_matrix8); // second_chroma_qp_index_offset pps->chroma_qp_index_offset[1] = get_se_golomb(gb); if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) { } else { pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0]; build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], sps->bit_depth_luma); build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], sps->bit_depth_luma); init_dequant_tables(pps, sps); if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1]) pps->chroma_qp_diff = 1; if (avctx->debug & FF_DEBUG_PICT_INFO) { av_log(avctx, AV_LOG_DEBUG, \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\", pps_id, pps->sps_id,", "ground_truth": "YES", "predict": " pps->cabac ? \"CABAC\" : \"CAVLC\", pps->slice_group_count, pps->ref_count[0], pps->ref_count[1], pps->weighted_pred ? \"weighted_pred\" : \"\", pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1], pps->deblocking_filter_parameters_present ? \"deblocking\" : \"\", pps->constrained_intra_pred ? \"constrained_intra_pred\" : \"\", pps->redundant_pic_cnt_present ? \"redundant_pic_cnt\" : \"\", pps->transform_8x8_mode ? \"transform_8x8\" : \"\"); } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }"}, {"ID": 1054, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program) { AVStream *stream = fmt_ctx->streams[stream_idx]; AVCodecContext *dec_ctx; const AVCodec *dec; char val_str[128]; const char *s; AVRational sar, dar; AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int(\"index\", stream->index); if ((dec_ctx = stream->codec)) { const char *profile = NULL; dec = dec_ctx->codec; if (dec) { print_str(\"codec_name\", dec->name); if (!do_bitexact) { if (dec->long_name) print_str (\"codec_long_name\", dec->long_name); else print_str_opt(\"codec_long_name\", \"unknown\"); } } else { print_str_opt(\"codec_name\", \"unknown\"); if (!do_bitexact) { print_str_opt(\"codec_long_name\", \"unknown\"); } } if (dec && (profile = av_get_profile_name(dec, dec_ctx->profile))) print_str(\"profile\", profile); else print_str_opt(\"profile\", \"unknown\"); s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str (\"codec_type\", s); else print_str_opt(\"codec_type\", \"unknown\"); print_q(\"codec_time_base\", dec_ctx->time_base, '/'); /* print AVI/FourCC tag */ av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag); print_str(\"codec_tag_string\", val_str); print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int(\"width\", dec_ctx->width); print_int(\"height\", dec_ctx->height); print_int(\"has_b_frames\", dec_ctx->has_b_frames); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q(\"sample_aspect_ratio\", sar, ':'); av_reduce(&dar.num, &dar.den, dec_ctx->width * sar.num, dec_ctx->height * sar.den, 1024*1024); print_q(\"display_aspect_ratio\", dar, ':'); } else { print_str_opt(\"sample_aspect_ratio\", \"N/A\"); print_str_opt(\"display_aspect_ratio\", \"N/A\"); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str (\"pix_fmt\", s); else print_str_opt(\"pix_fmt\", \"unknown\"); print_int(\"level\", dec_ctx->level); if (dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str(\"timecode\", tcbuf); } else { print_str_opt(\"timecode\", \"N/A\"); } break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str (\"sample_fmt\", s); else print_str_opt(\"sample_fmt\", \"unknown\"); print_val(\"sample_rate\", dec_ctx->sample_rate, unit_hertz_str); print_int(\"channels\", dec_ctx->channels); if (dec_ctx->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, dec_ctx->channels, dec_ctx->channel_layout); print_str (\"channel_layout\", pbuf.str); } else { print_str_opt(\"channel_layout\", \"unknown\"); } print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (dec_ctx->width) print_int(\"width\", dec_ctx->width); else print_str_opt(\"width\", \"N/A\"); if (dec_ctx->height) print_int(\"height\", dec_ctx->height); else print_str_opt(\"height\", \"N/A\"); break; } } else { print_str_opt(\"codec_type\", \"unknown\"); } if (dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt (\"id\", \"0x%x\", stream->id); else print_str_opt(\"id\", \"N/A\"); print_q(\"r_frame_rate\", stream->r_frame_rate, '/'); print_q(\"avg_frame_rate\", stream->avg_frame_rate, '/'); print_q(\"time_base\", stream->time_base, '/'); print_ts (\"start_pts\", stream->start_time); print_time(\"start_time\", stream->start_time, &stream->time_base); print_ts (\"duration_ts\", stream->duration); print_time(\"duration\", stream->duration, &stream->time_base); if (dec_ctx->bit_rate > 0) print_val (\"bit_rate\", dec_ctx->bit_rate, unit_bit_per_second_str); else print_str_opt(\"bit_rate\", \"N/A\"); if (stream->nb_frames) print_fmt (\"nb_frames\", \"%\"PRId64, stream->nb_frames); else print_str_opt(\"nb_frames\", \"N/A\"); if (nb_streams_frames[stream_idx]) print_fmt (\"nb_read_frames\", \"%\"PRIu64, nb_streams_frames[stream_idx]); else print_str_opt(\"nb_read_frames\", \"N/A\"); if (nb_streams_packets[stream_idx]) print_fmt (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]); else print_str_opt(\"nb_read_packets\", \"N/A\"); if (do_show_data) writer_print_data(w, \"extradata\", dec_ctx->extradata, dec_ctx->extradata_size); /* Print disposition information */ #define PRINT_DISPOSITION(flagname, name) do { \\ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT,", "ground_truth": "NO", "predict": " \"default\"); PRINT_DISPOSITION(DUB, \"dub\"); PRINT_DISPOSITION(ORIGINAL, \"original\"); PRINT_DISPOSITION(COMMENT, \"comment\"); PRINT_DISPOSITION(LYRICS, \"lyrics\"); PRINT_DISPOSITION(KARAOKE, \"karaoke\"); PRINT_DISPOSITION(FORCED, \"forced\"); PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\"); PRINT_DISPOSITION(VISUAL_IMPAIRED, \"visual_impaired\"); PRINT_DISPOSITION(CLEAN_EFFECTS, \"clean_effects\"); PRINT_DISPOSITION(ATTACHED_PIC, \"attached_pic\"); PRINT_DISPOSITION(CAPTIONS, \"captions\"); PRINT_DISPOSITION(DESCRIPTIONS, \"descriptions\"); PRINT_DISPOSITION(METADATA, \"metadata\"); } #undef PRINT_DISPOSITION writer_print_section_footer(w); } else { print_str_opt(\"codec_name\", \"unknown\"); print_str_opt"}, {"ID": 1300, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void taihu_405ep_init(MachineState *machine) { ram_addr_t ram_size = machine->ram_size; const char *kernel_filename = machine->kernel_filename; const char *initrd_filename = machine->initrd_filename; char *filename; qemu_irq *pic; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *bios; MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories)); MemoryRegion *ram = g_malloc0(sizeof(*ram)); hwaddr ram_bases[2], ram_sizes[2]; long bios_size; target_ulong kernel_base, initrd_base; long kernel_size, initrd_size; int linux_boot; int fl_idx, fl_sectors; DriveInfo *dinfo; /* RAM is soldered to the board so the size cannot be changed */ ram_size = 0x08000000; memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\", ram_size); ram_bases[0] = 0; ram_sizes[0] = 0x04000000; memory_region_init_alias(&ram_memories[0], NULL, \"taihu_405ep.ram-0\", ram, ram_bases[0], ram_sizes[0]); ram_bases[1] = 0x04000000; ram_sizes[1] = 0x04000000; memory_region_init_alias(&ram_memories[1], NULL, \"taihu_405ep.ram-1\", ram, ram_bases[1], ram_sizes[1]); #ifdef DEBUG_BOARD_INIT printf(\"%s: register cpu\\n\", __func__); #endif ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes, 33333333, &pic, kernel_filename == NULL ? 0 : 1); /* allocate and load BIOS */ #ifdef DEBUG_BOARD_INIT printf(\"%s: register BIOS\\n\", __func__); #endif fl_idx = 0; #if defined(USE_FLASH_BIOS) dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); bios_size = bdrv_getlength(bs); /* XXX: should check that size is 2MB */ // bios_size = 2 * 1024 * 1024; fl_sectors = (bios_size + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf(\"Register parallel flash %d size %lx\" \" at addr %lx '%s' %d\\n\", fl_idx, bios_size, -bios_size, bdrv_get_device_name(bs), fl_sectors); #endif pflash_cfi02_register((uint32_t)(-bios_size), NULL, \"taihu_405ep.bios\", bios_size, bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } else #endif { #ifdef DEBUG_BOARD_INIT printf(\"Load BIOS from file\\n\"); #endif if (bios_name == NULL) bios_name = BIOS_FILENAME; bios = g_new(MemoryRegion, 1); memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE, &error_abort); vmstate_register_ram_global(bios); filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { bios_size = load_image(filename, memory_region_get_ram_ptr(bios)); g_free(filename); if (bios_size < 0 || bios_size > BIOS_SIZE) { error_report(\"Could not load PowerPC BIOS '%s'\", bios_name); exit(1); } bios_size = (bios_size + 0xfff) & ~0xfff; memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios); } else if (!qtest_enabled()) { error_report(\"Could not load PowerPC BIOS '%s'\", bios_name); exit(1); } memory_region_set_readonly(bios, true); } /* Register Linux flash */ dinfo = drive_get(IF_PFLASH, 0, fl_idx); if (dinfo) { BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo)); bios_size = bdrv_getlength(bs); /* XXX: should check that size is 32MB */ bios_size = 32 * 1024 * 1024; fl_sectors = (bios_size + 65535) >> 16; #ifdef DEBUG_BOARD_INIT printf(\"Register parallel flash %d size %lx\" \" at addr \" TARGET_FMT_lx \" '%s'\\n\", fl_idx, bios_size, (target_ulong)0xfc000000, bdrv_get_device_name(bs)); #endif pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size, bs, 65536, fl_sectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); fl_idx++; } /* Register CLPD & LCD display */ #ifdef DEBUG_BOARD_INIT printf(\"%s: register CPLD\\n\", __func__); #endif taihu_cpld_init(sysmem, 0x50100000); /* Load kernel */ linux_boot = (kernel_filename != NULL); if (linux_boot) { #ifdef DEBUG_BOARD_INIT printf(\"%s: load kernel\\n\", __func__); #endif kernel_base = KERNEL_LOAD_ADDR; /* now we can load the kernel */ kernel_size = load_image_targphys(kernel_filename, kernel_base, ram_size - kernel_base); if (kernel_size < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename); exit(1); } /* load initrd */ if (initrd_filename) { initrd_base = INITRD_LOAD_ADDR; initrd_size = load_image_targphys(initrd_filename, initrd_base, ram_size - initrd_base); if (initrd_size < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } else { kernel_base = 0; kernel_size = 0; initrd_base = 0; initrd_size = 0; } #ifdef DEBUG_BOARD_INIT printf(\"%", "ground_truth": "NO", "predict": "s: register RAM\\n\", __func__); #endif memory_region_add_subregion(sysmem, ram_bases[0], ram_memories[0]); memory_region_add_subregion(sysmem, ram_bases[1], ram_memories[1]); #ifdef DEBUG_BOARD_INIT printf(\"%s: register PIC\\n\", __func__); #endif ppc405ep_register_pic(pic); #ifdef DEBUG_BOARD_INIT printf(\"%s: register UART\\n\", __func__); #endif taihu_405ep_register_uart(sysmem, 0x50000000); #ifdef DEBUG_BOARD_INIT printf(\"%s: register RTC\\n\", __func__); #endif taihu_405ep_register_rtc(sysmem, 0x50001000); #ifdef DEBUG_BOARD_INIT printf(\"%s: register CF\\n\", __func__); #endif t"}, {"ID": 1322, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int rebuild_refcount_structure(BlockDriverState *bs, BdrvCheckResult *res, void **refcount_table, int64_t *nb_clusters) { BDRVQcow2State *s = bs->opaque; int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0; int64_t refblock_offset, refblock_start, refblock_index; uint32_t reftable_size = 0; uint64_t *on_disk_reftable = NULL; void *on_disk_refblock; int ret = 0; struct { uint64_t reftable_offset; uint32_t reftable_clusters; } QEMU_PACKED reftable_offset_and_clusters; qcow2_cache_empty(bs, s->refcount_block_cache); write_refblocks: for (; cluster < *nb_clusters; cluster++) { if (!s->get_refcount(*refcount_table, cluster)) { continue; } refblock_index = cluster >> s->refcount_block_bits; refblock_start = refblock_index << s->refcount_block_bits; /* Don't allocate a cluster in a refblock already written to disk */ if (first_free_cluster < refblock_start) { first_free_cluster = refblock_start; } refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table, nb_clusters, &first_free_cluster); if (refblock_offset < 0) { fprintf(stderr, \"ERROR allocating refblock: %s\\n\", strerror(-refblock_offset)); res->check_errors++; ret = refblock_offset; goto fail; } if (reftable_size <= refblock_index) { uint32_t old_reftable_size = reftable_size; uint64_t *new_on_disk_reftable; reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t), s->cluster_size) / sizeof(uint64_t); new_on_disk_reftable = g_try_realloc(on_disk_reftable, reftable_size * sizeof(uint64_t)); if (!new_on_disk_reftable) { res->check_errors++; ret = -ENOMEM; goto fail; } on_disk_reftable = new_on_disk_reftable; memset(on_disk_reftable + old_reftable_size, 0, (reftable_size - old_reftable_size) * sizeof(uint64_t)); /* The offset we have for the reftable is now no longer valid; * this will leak that range, but we can easily fix that by running * a leak-fixing check after this rebuild operation */ reftable_offset = -1; } on_disk_reftable[refblock_index] = refblock_offset; /* If this is apparently the last refblock (for now), try to squeeze the * reftable in */ if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits && reftable_offset < 0) { uint64_t reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, refcount_table, nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, \"ERROR allocating reftable: %s\\n\", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } } ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset, s->cluster_size); if (ret < 0) { fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret)); goto fail; } /* The size of *refcount_table is always cluster-aligned, therefore the * write operation will not overflow */ on_disk_refblock = (void *)((char *) *refcount_table + refblock_index * s->cluster_size); ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE, on_disk_refblock, s->cluster_sectors); if (ret < 0) { fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret)); goto fail; } /* Go to the end of this refblock */ cluster = refblock_start + s->refcount_block_size - 1; } if (reftable_offset < 0) { uint64_t post_refblock_start, reftable_clusters; post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size); reftable_clusters = size_to_clusters(s, reftable_size * sizeof(uint64_t)); /* Not pretty but simple */ if (first_free_cluster < post_refblock_start) { first_free_cluster = post_refblock_start; } reftable_offset = alloc_clusters_imrt(bs, reftable_clusters, refcount_table, nb_clusters, &first_free_cluster); if (reftable_offset < 0) { fprintf(stderr, \"ERROR allocating reftable: %s\\n\", strerror(-reftable_offset)); res->check_errors++; ret = reftable_offset; goto fail; } goto write_refblocks; } assert(on_disk_reftable); for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { cpu_to_be64s(&on_disk_reftable[refblock_index]); } ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset, reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret)); goto fail; } assert(reftable_size < INT_MAX / sizeof(uint64_t)); ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable, reftable_size * sizeof(uint64_t)); if (ret < 0) { fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret)); goto fail; } /* Enter new reftable into the image header */ reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset); reftable_offset_and_clusters.reftable_clusters = cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t))); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), &reftable_offset_and_clusters, sizeof(reftable_offset_and_clusters)); if (ret < 0) { fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret)); goto fail; } for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) { be64_to_cpus(&on_disk_reftable[refblock_index]); } s->refcount_table = on_disk_reftable; s->refcount_table_offset =", "ground_truth": "YES", "predict": " reftable_offset; s->refcount_table_clusters = reftable_size; s->refcount_table_size = reftable_size * sizeof(uint64_t); s->refcount_block_cache = NULL; return 0; fail: if (on_disk_reftable) { g_free(on_disk_reftable); } return ret; }"}, {"ID": 1388, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int sap_write_header(AVFormatContext *s) { struct SAPState *sap = s->priv_data; char host[1024], path[1024], url[1024], announce_addr[50] = \"\"; char *option_list; int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255; AVFormatContext **contexts = NULL; int ret = 0; struct sockaddr_storage localaddr; socklen_t addrlen = sizeof(localaddr); int udp_fd; AVDictionaryEntry* title = av_dict_get(s->metadata, \"title\", NULL, 0); if (!ff_network_init()) return AVERROR(EIO); /* extract hostname and port */ av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port, path, sizeof(path), s->filename); if (base_port < 0) base_port = 5004; /* search for options */ option_list = strrchr(path, '?'); if (option_list) { char buf[50]; if (av_find_info_tag(buf, sizeof(buf), \"announce_port\", option_list)) { port = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), \"same_port\", option_list)) { same_port = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), \"ttl\", option_list)) { ttl = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), \"announce_addr\", option_list)) { av_strlcpy(announce_addr, buf, sizeof(announce_addr)); } } if (!announce_addr[0]) { struct addrinfo hints = { 0 }, *ai = NULL; hints.ai_family = AF_UNSPEC; if (getaddrinfo(host, NULL, &hints, &ai)) { av_log(s, AV_LOG_ERROR, \"Unable to resolve %s\\n\", host); ret = AVERROR(EIO); goto fail; } if (ai->ai_family == AF_INET) { /* Also known as sap.mcast.net */ av_strlcpy(announce_addr, \"224.2.127.254\", sizeof(announce_addr)); #if HAVE_STRUCT_SOCKADDR_IN6 } else if (ai->ai_family == AF_INET6) { /* With IPv6, you can use the same destination in many different * multicast subnets, to choose how far you want it routed. * This one is intended to be routed globally. */ av_strlcpy(announce_addr, \"ff0e::2:7ffe\", sizeof(announce_addr)); #endif } else { freeaddrinfo(ai); av_log(s, AV_LOG_ERROR, \"Host %s resolved to unsupported \" \"address family\\n\", host); ret = AVERROR(EIO); goto fail; } freeaddrinfo(ai); } sap->protocols = ffurl_get_protocols(NULL, NULL); if (!sap->protocols) { ret = AVERROR(ENOMEM); goto fail; } contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams); if (!contexts) { ret = AVERROR(ENOMEM); goto fail; } s->start_time_realtime = av_gettime(); for (i = 0; i < s->nb_streams; i++) { URLContext *fd; ff_url_join(url, sizeof(url), \"rtp\", NULL, host, base_port, \"?ttl=%d\", ttl); if (!same_port) base_port += 2; ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i); if (ret < 0) goto fail; s->streams[i]->priv_data = contexts[i]; s->streams[i]->time_base = contexts[i]->streams[0]->time_base; av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename)); } if (s->nb_streams > 0 && title) av_dict_set(&contexts[0]->metadata, \"title\", title->value, 0); ff_url_join(url, sizeof(url), \"udp\", NULL, announce_addr, port, \"?ttl=%d&connect=1\", ttl); ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } udp_fd = ffurl_get_file_handle(sap->ann_fd); if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) { ret = AVERROR(EIO); goto fail; } if (localaddr.ss_family != AF_INET #if HAVE_STRUCT_SOCKADDR_IN6 && localaddr.ss_family != AF_INET6 #endif ) { av_log(s, AV_LOG_ERROR, \"Unsupported protocol family\\n\"); ret = AVERROR(EIO); goto fail; } sap->ann_size = 8192; sap->ann = av_mallocz(sap->ann_size); if (!sap->ann) { ret = AVERROR(EIO); goto fail; } sap->ann[pos] = (1 << 5); #if HAVE_STRUCT_SOCKADDR_IN6 if (localaddr.ss_family == AF_INET6) sap->ann[pos] |= 0x10; #endif pos++; sap->ann[pos++] = 0; /* Authentication length */ AV_WB16(&sap->ann[pos], av_get_random_seed()); pos += 2; if (localaddr.ss_family == AF_INET) { memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr, sizeof(struct in_addr)); pos += sizeof(struct in_addr); #if HAVE_STRUCT_SOCKADDR_IN6 } else { memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr, sizeof(struct in6_addr)); pos += sizeof(struct in6_addr); #endif } av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos); pos += strlen(&sap->ann[pos]) + 1; if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos], sap->ann_size - pos)) { ret = AVERROR_INVALIDDATA; goto fail; } av_freep(&contexts); av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]); pos += strlen(&sap->ann[pos]); sap->ann_size = pos; if (sap->ann_size > sap->ann_fd->max_packet_size) { av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \" \"packet\\n\"); goto fail; } return 0; fail: av_free(contexts); sap_write_close(s); return ret; }", "ground_truth": "YES", "predict": ""}, {"ID": 1425, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, AVFrame *picture) { int compno, reslevelno, bandno; int x, y; uint8_t *line; Jpeg2000T1Context t1; /* Loop on tile components */ for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; /* Loop on resolution levels */ for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) { Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno; /* Loop on bands */ for (bandno = 0; bandno < rlevel->nbands; bandno++) { int nb_precincts, precno; Jpeg2000Band *band = rlevel->band + bandno; int cblkno = 0, bandpos; bandpos = bandno + (reslevelno > 0); if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y; /* Loop on precincts */ for (precno = 0; precno < nb_precincts; precno++) { Jpeg2000Prec *prec = band->prec + precno; /* Loop on codeblocks */ for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) { int x, y; Jpeg2000Cblk *cblk = prec->cblk + cblkno; decode_cblk(s, codsty, &t1, cblk, cblk->coord[0][1] - cblk->coord[0][0], cblk->coord[1][1] - cblk->coord[1][0], bandpos); x = cblk->coord[0][0]; y = cblk->coord[1][0]; if (codsty->transform == FF_DWT97) dequantization_float(x, y, cblk, comp, &t1, band); else dequantization_int(x, y, cblk, comp, &t1, band); } /* end cblk */ } /*end prec */ } /* end band */ } /* end reslevel */ /* inverse DWT */ ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data); } /*end comp */ /* inverse MCT transformation */ if (tile->codsty[0].mct) mct_decode(s, tile); if (s->cdef[0] < 0) { for (x = 0; x < s->ncomponents; x++) s->cdef[x] = x + 1; if ((s->ncomponents & 1) == 0) s->cdef[s->ncomponents-1] = 0; } if (s->precision <= 8) { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; line = picture->data[plane] + y * picture->linesize[plane]; for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint8_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = line + x * pixelsize + compno*!planar; if (codsty->transform == FF_DWT97) { for (; x < w; x += s->cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s->cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); i_datap++; dst += pixelsize; } } line += picture->linesize[plane]; } } } else { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; uint16_t *linel; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1); for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint16_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = linel + (x * pixelsize + compno*!planar); if (codsty->transform == FF_DWT97) { for (; x < w; x += s-> cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.", "ground_truth": "NO", "predict": "1.2 */ val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s->cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); i_datap++; dst += pixelsize; } } linel += picture->linesize[plane] >> 1; } } } return 0; }"}, {"ID": 1502, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst, unsigned int width, unsigned int height, int lumStride, int chromStride, int srcStride) { unsigned y; const unsigned chromWidth= width>>1; for(y=0; y<height; y+=2) { #ifdef HAVE_MMX asm volatile( \"xor %%\"REG_a\", %%\"REG_a\" \\n\\t\" \"pcmpeqw %%mm7, %%mm7 \\n\\t\" \"psrlw $8, %%mm7 \\n\\t\" // FF,00,FF,00... \".balign 16 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REG_a\", 4) \\n\\t\" \"movq (%0, %%\"REG_a\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4) \"movq %%mm0, %%mm2 \\n\\t\" // YUYV YUYV(0) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(4) \"psrlw $8, %%mm0 \\n\\t\" // U0V0 U0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(4) \"packuswb %%mm1, %%mm0 \\n\\t\" // UVUV UVUV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(0) MOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\" \"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(8) \"movq %%mm2, %%mm4 \\n\\t\" // YUYV YUYV(12) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(8) \"psrlw $8, %%mm2 \\n\\t\" // U0V0 U0V0(12) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm4 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm2, %%mm1 \\n\\t\" // UVUV UVUV(8) \"packuswb %%mm4, %%mm3 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\" \"movq %%mm0, %%mm2 \\n\\t\" // UVUV UVUV(0) \"movq %%mm1, %%mm3 \\n\\t\" // UVUV UVUV(8) \"psrlw $8, %%mm0 \\n\\t\" // V0V0 V0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // V0V0 V0V0(8) \"pand %%mm7, %%mm2 \\n\\t\" // U0U0 U0U0(0) \"pand %%mm7, %%mm3 \\n\\t\" // U0U0 U0U0(8) \"packuswb %%mm1, %%mm0 \\n\\t\" // VVVV VVVV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // UUUU UUUU(0) MOVNTQ\" %%mm0, (%3, %%\"REG_a\") \\n\\t\" MOVNTQ\" %%mm2, (%2, %%\"REG_a\") \\n\\t\" \"add $8, %%\"REG_a\" \\n\\t\" \"cmp %4, %%\"REG_a\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth) : \"memory\", \"%\"REG_a ); ydst += lumStride; src += srcStride; asm volatile( \"xor %%\"REG_a\", %%\"REG_a\" \\n\\t\" \".balign 16 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REG_a\", 4) \\n\\t\" \"movq (%0, %%\"REG_a\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4) \"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12) \"pand %%mm7, %%mm0 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm1 \\n\\t\" // Y0Y0 Y0Y0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm1, %%mm0 \\n\\t\" // YYYY YYYY(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\" MOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\" \"add $8, %%\"REG_a\" \\n\\t\" \"cmp %4, %%\"REG_a\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth) : \"memory\", \"%\"REG_a ); #else unsigned i; for(i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride; for(i=0; i<", "ground_truth": "YES", "predict": "chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; #endif } }"}, {"ID": 1528, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off, BlockDriverState *bs, uint32_t sector_len, int nb_blocs, int nb_mappings, int width, uint16_t id0, uint16_t id1, uint16_t id2, uint16_t id3, uint16_t unlock_addr0, uint16_t unlock_addr1) { pflash_t *pfl; int32_t chip_len; chip_len = sector_len * nb_blocs; /* XXX: to be fixed */ #if 0 if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) && total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024)) return NULL; #endif pfl = qemu_mallocz(sizeof(pflash_t)); /* FIXME: Allocate ram ourselves. */ pfl->storage = qemu_get_ram_ptr(off); pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops, pfl); pfl->off = off; pfl->base = base; pfl->chip_len = chip_len; pfl->mappings = nb_mappings; pflash_register_memory(pfl, 1); pfl->bs = bs; if (pfl->bs) { /* read the initial flash content */ bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9); } #if 0 /* XXX: there should be a bit to set up read-only, * the same way the hardware does (with WP pin). */ pfl->ro = 1; #else pfl->ro = 0; #endif pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl); pfl->sector_len = sector_len; pfl->width = width; pfl->wcycle = 0; pfl->cmd = 0; pfl->status = 0; pfl->ident[0] = id0; pfl->ident[1] = id1; pfl->ident[2] = id2; pfl->ident[3] = id3; pfl->unlock_addr[0] = unlock_addr0; pfl->unlock_addr[1] = unlock_addr1; /* Hardcoded CFI table (mostly from SG29 Spansion flash) */ pfl->cfi_len = 0x52; /* Standard \"QRY\" string */ pfl->cfi_table[0x10] = 'Q'; pfl->cfi_table[0x11] = 'R'; pfl->cfi_table[0x12] = 'Y'; /* Command set (AMD/Fujitsu) */ pfl->cfi_table[0x13] = 0x02; pfl->cfi_table[0x14] = 0x00; /* Primary extended table address */ pfl->cfi_table[0x15] = 0x31; pfl->cfi_table[0x16] = 0x00; /* Alternate command set (none) */ pfl->cfi_table[0x17] = 0x00; pfl->cfi_table[0x18] = 0x00; /* Alternate extended table (none) */ pfl->cfi_table[0x19] = 0x00; pfl->cfi_table[0x1A] = 0x00; /* Vcc min */ pfl->cfi_table[0x1B] = 0x27; /* Vcc max */ pfl->cfi_table[0x1C] = 0x36; /* Vpp min (no Vpp pin) */ pfl->cfi_table[0x1D] = 0x00; /* Vpp max (no Vpp pin) */ pfl->cfi_table[0x1E] = 0x00; /* Reserved */ pfl->cfi_table[0x1F] = 0x07; /* Timeout for min size buffer write (NA) */ pfl->cfi_table[0x20] = 0x00; /* Typical timeout for block erase (512 ms) */ pfl->cfi_table[0x21] = 0x09; /* Typical timeout for full chip erase (4096 ms) */ pfl->cfi_table[0x22] = 0x0C; /* Reserved */ pfl->cfi_table[0x23] = 0x01; /* Max timeout for buffer write (NA) */ pfl->cfi_table[0x24] = 0x00; /* Max timeout for block erase */ pfl->cfi_table[0x25] = 0x0A; /* Max timeout for chip erase */ pfl->cfi_table[0x26] = 0x0D; /* Device size */ pfl->cfi_table[0x27] = ctz32(chip_len); /* Flash device interface (8 & 16 bits) */ pfl->cfi_table[0x28] = 0x02; pfl->cfi_table[0x29] = 0x00; /* Max number of bytes in multi-bytes write */ /* XXX: disable buffered write as it's not supported */ // pfl->cfi_table[0x2A] = 0x05; pfl->cfi_table[0x2A] = 0x00; pfl->cfi_table[0x2B] = 0x00; /* Number of erase block regions (uniform) */ pfl->cfi_table[0x2C] = 0x01; /* Erase block region 1 */ pfl->cfi_table[0x2D] = nb_blocs - 1; pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8; pfl->cfi_table[0x2F] = sector_len >> 8; pfl->cfi_table[0x30] = sector_len >> 16; /* Extended */ pfl->cfi_table[0x31] = 'P'; pfl->cfi_table[0x32] = 'R'; pfl->cfi_table[0x33] = 'I'; pfl->cfi_table[0x34] = '1'; pfl->cfi_table[0x35] = '0'; pfl->cfi_table[0x36] = 0x00; pfl->cfi_table[0x37] = 0x00; pfl->cfi_table[0x38] = 0x00; pfl->cfi_table[0x39] = 0x00; pfl->cfi_table[0x3a] = 0x00; pfl->cfi_table[0x3b] = 0x00; pfl->cfi_table[0x3c]", "ground_truth": "NO", "predict": " = 0x00; pfl->cfi_table[0x3d] = 0x00; pfl->cfi_table[0x3e] = 0x00; pfl->cfi_table[0x3f] = 0x00; pfl->cfi_table[0x40] = 0x00; pfl->cfi_table[0x41] = 0x00; pfl->cfi_table[0x42] = 0x00; pfl->cfi_table[0x43] = 0x00; pfl->cfi_table[0x44] = 0x00; pfl->cfi_table[0x45] = 0x00; pfl->cfi_table[0x46] = 0x00; pfl->cfi_table[0"}, {"ID": 1548, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int decode_thread(void *arg) { VideoState *is = arg; AVFormatContext *ic; int err, i, ret, video_index, audio_index, subtitle_index; AVPacket pkt1, *pkt = &pkt1; AVFormatParameters params, *ap = &params; video_index = -1; audio_index = -1; subtitle_index = -1; is->video_stream = -1; is->audio_stream = -1; is->subtitle_stream = -1; global_video_state = is; url_set_interrupt_cb(decode_interrupt_cb); memset(ap, 0, sizeof(*ap)); ap->width = frame_width; ap->height= frame_height; ap->time_base= (AVRational){1, 25}; ap->pix_fmt = frame_pix_fmt; err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } is->ic = ic; if(genpts) ic->flags |= AVFMT_FLAG_GENPTS; err = av_find_stream_info(ic); if (err < 0) { fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename); ret = -1; goto fail; } if(ic->pb) ic->pb->eof_reached= 0; //FIXME hack, ffplay maybe should not use url_feof() to test for the end /* if seeking requested, we execute it */ if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; /* add the stream start time */ if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD); if (ret < 0) { fprintf(stderr, \"%s: could not seek to position %0.3f\\n\", is->filename, (double)timestamp / AV_TIME_BASE); } } for(i = 0; i < ic->nb_streams; i++) { AVCodecContext *enc = ic->streams[i]->codec; ic->streams[i]->discard = AVDISCARD_ALL; switch(enc->codec_type) { case CODEC_TYPE_AUDIO: if ((audio_index < 0 || wanted_audio_stream-- > 0) && !audio_disable) audio_index = i; break; case CODEC_TYPE_VIDEO: if ((video_index < 0 || wanted_video_stream-- > 0) && !video_disable) video_index = i; break; case CODEC_TYPE_SUBTITLE: if (wanted_subtitle_stream-- >= 0 && !video_disable) subtitle_index = i; break; default: break; } } if (show_status) { dump_format(ic, 0, is->filename, 0); dump_stream_info(ic); } /* open the streams */ if (audio_index >= 0) { stream_component_open(is, audio_index); } if (video_index >= 0) { stream_component_open(is, video_index); } else { if (!display_disable) is->show_audio = 1; } if (subtitle_index >= 0) { stream_component_open(is, subtitle_index); } if (is->video_stream < 0 && is->audio_stream < 0) { fprintf(stderr, \"%s: could not open codecs\\n\", is->filename); ret = -1; goto fail; } for(;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) { /* wait 10 ms to avoid trying to get another packet */ /* XXX: horrible */ SDL_Delay(10); continue; } #endif if (is->seek_req) { int stream_index= -1; int64_t seek_target= is->seek_pos; if (is-> video_stream >= 0) stream_index= is-> video_stream; else if(is-> audio_stream >= 0) stream_index= is-> audio_stream; else if(is->subtitle_stream >= 0) stream_index= is->subtitle_stream; if(stream_index>=0){ seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q, ic->streams[stream_index]->time_base); } ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags); if (ret < 0) { fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename); }else{ if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } } is->seek_req = 0; } /* if the queue are full, no need to read more */ if (is->audioq.size > MAX_AUDIOQ_SIZE || is->videoq.size > MAX_VIDEOQ_SIZE || is->subtitleq.size > MAX_SUBTITLEQ_SIZE) { /* wait 10 ms */ SDL_Delay(10); continue; } if(url_feof(ic->pb)) { av_init_packet(pkt); pkt->data=NULL; pkt->size=0; pkt->stream_index= is->video_stream; packet_queue_put(&is->videoq, pkt); continue; } ret = av_read_frame(ic, pkt); if (ret < 0) { if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) { SDL_Delay(100); /* wait for user event */ continue; } else break; } if (pkt->stream_index == is->audio_stream) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream) { packet_queue_put(&is->subtitleq, pkt); } else { av_free_packet(pkt); } } /* wait until the end */ while (!is->abort_request) { SDL_Delay(100); } ret = 0; fail: /* disable interrupting */ global_video_state = NULL; /* close each stream */ if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); if (is->ic) { av_close_input_file(is->ic); is->ic = NULL; /* safety */ } url_set_interrupt", "ground_truth": "NO", "predict": "_cb(NULL); return ret; }"}, {"ID": 1598, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx, int mm_flags) { const int bit_depth = avctx->bits_per_raw_sample; const int high_bit_depth = bit_depth > 8; c->prefetch = prefetch_mmx2; if (!high_bit_depth) { c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2; c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2; c->avg_pixels_tab[0][0] = avg_pixels16_mmx2; c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2; c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2; c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2; c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2; c->avg_pixels_tab[1][0] = avg_pixels8_mmx2; c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2; c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2; } if (!(avctx->flags & CODEC_FLAG_BITEXACT)) { if (!high_bit_depth) { c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2; c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2; c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2; c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2; c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2; c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2; } if (CONFIG_VP3_DECODER && HAVE_YASM) { c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2; c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2; } } if (CONFIG_VP3_DECODER && HAVE_YASM) c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2; if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 || avctx->codec_id == CODEC_ID_THEORA)) { c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2; c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2; } if (CONFIG_H264QPEL) { SET_QPEL_FUNCS(put_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(put_qpel, 1, 8, mmx2, ); SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(put_no_rnd_qpel, 1, 8, mmx2, ); SET_QPEL_FUNCS(avg_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(avg_qpel, 1, 8, mmx2, ); if (!high_bit_depth) { SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(put_h264_qpel, 1, 8, mmx2, ); SET_QPEL_FUNCS(put_h264_qpel, 2, 4, mmx2, ); SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(avg_h264_qpel, 1, 8, mmx2, ); SET_QPEL_FUNCS(avg_h264_qpel, 2, 4, mmx2, ); } else if (bit_depth == 10) { #if HAVE_YASM #if!ARCH_X86_64 SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_); SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_); SET_QPEL_FUNCS(put_h264_qpel, 1, 8, 10_mmxext, ff_); SET_QPEL_FUNCS(avg_h264_qpel, 1, 8, 10_mmxext, ff_); #endif SET_QPEL_FUNCS(put_h264_qpel, 2, 4, 10_mmxext, ff_); SET_QPEL_FUNCS(avg_h264_qpel, 2, 4, 10_mmxext, ff_); #endif } SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(put_2tap_qpel, 1, 8, mmx2, ); SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, ); SET_QPEL_FUNCS(avg_2tap_qpel, 1, 8, mmx2, ); } #if HAVE_YASM if (!high_bit_depth && CONFIG_H264CHROMA) { c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd; c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2; c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2; c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2; } if (bit_depth == 10 && CONFIG_H264CHROMA) { c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext; c->avg_h264_chroma_pixels", "ground_truth": "NO", "predict": "_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext; } #endif } if (CONFIG_H264DSP) { c->h264_v_loop_filter = ff_h264_v_loop_filter_mmx2; c->h264_h_loop_filter = ff_h264_h_loop_filter_mmx2; c->h264_v_loop_filter_chroma = ff_h264_v_loop_filter_chroma_mmx2; c->h264_h_loop_filter_chroma = ff_h264_h_loop_filter_chroma_mmx2; c->h264_weight_h264_pixels_tab[0] = ff_h264_weight_h264_pixels_mmx2;"}, {"ID": 1599, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->priv_data; VAEncSequenceParameterBufferH264 *vseq = ctx->codec_sequence_params; VAEncPictureParameterBufferH264 *vpic = ctx->codec_picture_params; VAAPIEncodeH264Context *priv = ctx->priv_data; VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params; int i; { vseq->seq_parameter_set_id = 0; vseq->level_idc = avctx->level; vseq->max_num_ref_frames = 2; vseq->picture_width_in_mbs = priv->mb_width; vseq->picture_height_in_mbs = priv->mb_height; vseq->seq_fields.bits.chroma_format_idc = 1; vseq->seq_fields.bits.frame_mbs_only_flag = 1; vseq->seq_fields.bits.direct_8x8_inference_flag = 1; vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4; vseq->seq_fields.bits.pic_order_cnt_type = 0; if (ctx->input_width != ctx->aligned_width || ctx->input_height != ctx->aligned_height) { vseq->frame_cropping_flag = 1; vseq->frame_crop_left_offset = 0; vseq->frame_crop_right_offset = (ctx->aligned_width - ctx->input_width) / 2; vseq->frame_crop_top_offset = 0; vseq->frame_crop_bottom_offset = (ctx->aligned_height - ctx->input_height) / 2; } else { vseq->frame_cropping_flag = 0; } vseq->vui_parameters_present_flag = 1; if (avctx->sample_aspect_ratio.num != 0) { vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1; // There is a large enum of these which we could support // individually rather than using the generic X/Y form? if (avctx->sample_aspect_ratio.num == avctx->sample_aspect_ratio.den) { vseq->aspect_ratio_idc = 1; } else { vseq->aspect_ratio_idc = 255; // Extended SAR. vseq->sar_width = avctx->sample_aspect_ratio.num; vseq->sar_height = avctx->sample_aspect_ratio.den; } } if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED || avctx->color_trc != AVCOL_TRC_UNSPECIFIED || avctx->colorspace != AVCOL_SPC_UNSPECIFIED) { mseq->video_signal_type_present_flag = 1; mseq->video_format = 5; // Unspecified. mseq->video_full_range_flag = 0; mseq->colour_description_present_flag = 1; // These enums are derived from the standard and hence // we can just use the values directly. mseq->colour_primaries = avctx->color_primaries; mseq->transfer_characteristics = avctx->color_trc; mseq->matrix_coefficients = avctx->colorspace; } vseq->bits_per_second = avctx->bit_rate; vseq->vui_fields.bits.timing_info_present_flag = 1; if (avctx->framerate.num > 0 && avctx->framerate.den > 0) { vseq->num_units_in_tick = avctx->framerate.num; vseq->time_scale = 2 * avctx->framerate.den; mseq->fixed_frame_rate_flag = 1; } else { vseq->num_units_in_tick = avctx->time_base.num; vseq->time_scale = 2 * avctx->time_base.den; mseq->fixed_frame_rate_flag = 0; } if (ctx->va_rc_mode == VA_RC_CBR) { priv->send_timing_sei = 1; mseq->nal_hrd_parameters_present_flag = 1; mseq->cpb_cnt_minus1 = 0; // Try to scale these to a sensible range so that the // golomb encode of the value is not overlong. mseq->bit_rate_scale = av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4); mseq->bit_rate_value_minus1[0] = (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1; mseq->cpb_size_scale = av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4); mseq->cpb_size_value_minus1[0] = (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1; // CBR mode isn't actually available here, despite naming. mseq->cbr_flag[0] = 0; mseq->initial_cpb_removal_delay_length_minus1 = 23; mseq->cpb_removal_delay_length_minus1 = 23; mseq->dpb_output_delay_length_minus1 = 7; mseq->time_offset_length = 0; // This calculation can easily overflow 32 bits. mseq->initial_cpb_removal_delay = 90000 * (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness / priv->hrd_params.hrd.buffer_size; mseq->initial_cpb_removal_delay_offset = 0; } else { priv->send_timing_sei = 0; mseq->nal_hrd_parameters_present_flag = 0; } vseq->intra_period = ctx->p_per_i * (ctx->b_per_p + 1); vseq->intra_idr_period = vseq->intra_period; vseq->ip_period = ctx->b_per_p + 1; } { vpic->CurrPic.picture_id = VA_INVALID_ID; vpic->CurrPic.flags = VA_PICTURE_H264_INVALID; for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) { vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID; vpic->ReferenceFrames[i].flags = VA_PICTURE_H264_INVALID; } vpic->coded_buf = VA_INVALID_ID; vpic->pic_parameter_set_id = 0; vpic->seq_parameter_set_id = 0; vpic->num_ref_idx_l0_active_minus1 = 0; vpic->num_ref_idx_l1_active_minus1 = 0; vpic->pic_fields.bits.entropy_coding_mode_flag = ((avctx->profile & 0xff) != 66); vpic->pic_fields.bits.weighted_pred_flag = 0; vpic->", "ground_truth": "NO", "predict": "pic_fields.bits.weighted_bipred_idc = 0; vpic->pic_fields.bits.transform_8x8_mode_flag = 0; vpic->pic_fields.bits.field_pic_flag = 0; vpic->pic_fields.bits.constrained_intra_pred_flag = 0; vpic->pic_fields.bits.pic_order_present_flag = 0; vpic->pic_fields.bits.deblocking_filter_control_present_flag = 1; vpic->pic_fields.bits.redundant_pic_cnt_present_flag = 0; vpic->frame_num = 0; vpic->pic_init_qp = 26; vpic->chroma_qp_index_offset = 0; vpic->second_chroma_qp_index_offset = 0; vpic->pic_fields.bits.reference_pic_flag = 0;"}, {"ID": 1665, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int read_all) { char buf[256]; uint32_t version; int ret; /* ra type header */ version = avio_rb16(pb); /* version */ if (version == 3) { unsigned bytes_per_minute; int header_size = avio_rb16(pb); int64_t startpos = avio_tell(pb); avio_skip(pb, 8); bytes_per_minute = avio_rb16(pb); avio_skip(pb, 4); rm_read_metadata(s, 0); if ((startpos + header_size) >= avio_tell(pb) + 2) { // fourcc (should always be \"lpcJ\") avio_r8(pb); get_str8(pb, buf, sizeof(buf)); } // Skip extra header crap (this should never happen) if ((startpos + header_size) > avio_tell(pb)) avio_skip(pb, header_size + startpos - avio_tell(pb)); if (bytes_per_minute) st->codec->bit_rate = 8LL * bytes_per_minute / 60; st->codec->sample_rate = 8000; st->codec->channels = 1; st->codec->channel_layout = AV_CH_LAYOUT_MONO; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = AV_CODEC_ID_RA_144; ast->deint_id = DEINT_ID_INT0; } else { int flavor, sub_packet_h, coded_framesize, sub_packet_size; int codecdata_length; unsigned bytes_per_minute; /* old version (4) */ avio_skip(pb, 2); /* unused */ avio_rb32(pb); /*.ra4 */ avio_rb32(pb); /* data size */ avio_rb16(pb); /* version2 */ avio_rb32(pb); /* header size */ flavor= avio_rb16(pb); /* add codec info / flavor */ ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */ avio_rb32(pb); /*??? */ bytes_per_minute = avio_rb32(pb); if (version == 4) { if (bytes_per_minute) st->codec->bit_rate = 8LL * bytes_per_minute / 60; } avio_rb32(pb); /*??? */ ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */ st->codec->block_align= avio_rb16(pb); /* frame size */ ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */ avio_rb16(pb); /*??? */ if (version == 5) { avio_rb16(pb); avio_rb16(pb); avio_rb16(pb); } st->codec->sample_rate = avio_rb16(pb); avio_rb32(pb); st->codec->channels = avio_rb16(pb); if (version == 5) { ast->deint_id = avio_rl32(pb); avio_read(pb, buf, 4); buf[4] = 0; } else { get_str8(pb, buf, sizeof(buf)); /* desc */ ast->deint_id = AV_RL32(buf); get_str8(pb, buf, sizeof(buf)); /* desc */ } st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(buf); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); switch (st->codec->codec_id) { case AV_CODEC_ID_AC3: st->need_parsing = AVSTREAM_PARSE_FULL; break; case AV_CODEC_ID_RA_288: st->codec->extradata_size= 0; ast->audio_framesize = st->codec->block_align; st->codec->block_align = coded_framesize; break; case AV_CODEC_ID_COOK: st->need_parsing = AVSTREAM_PARSE_HEADERS; case AV_CODEC_ID_ATRAC3: case AV_CODEC_ID_SIPR: if (read_all) { codecdata_length = 0; } else { avio_rb16(pb); avio_r8(pb); if (version == 5) avio_r8(pb); codecdata_length = avio_rb32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\"); return -1; } } ast->audio_framesize = st->codec->block_align; if (st->codec->codec_id == AV_CODEC_ID_SIPR) { if (flavor > 3) { av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\", flavor); return -1; } st->codec->block_align = ff_sipr_subpk_size[flavor]; } else { if(sub_packet_size <= 0){ av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\"); return -1; } st->codec->block_align = ast->sub_packet_size; } if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0) return ret; break; case AV_CODEC_ID_AAC: avio_rb16(pb); avio_r8(pb); if (version == 5) avio_r8(pb); codecdata_length = avio_rb32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\"); return -1; } if (codecdata_length >= 1) { avio_r8(pb); if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0) return ret; } break; default: av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name)); } if (ast->deint_id == DEINT_ID_INT4 || ast->deint_id == DEINT_ID_GENR || ast->deint_id == DEINT_ID_SIPR) { if (st->codec->block_align <= 0 || ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX || ast->audio_framesize * sub_packet_h < st->codec->block_align) return AVERROR_INVALIDDATA; if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0) return AVERROR(ENOMEM); } switch (ast->deint_id) { case DEINT_ID_INT4: if", "ground_truth": "YES", "predict": " (st->codec->codec_id == AV_CODEC_ID_COOK) { if (sub_packet_h != 1) return AVERROR_INVALIDDATA; } else if (st->codec->codec_id == AV_CODEC_ID_SIPR) { if (sub_packet_h != 1) return AVERROR_INVALIDDATA; } else if (st->codec->codec_id == AV_CODEC_ID_AAC) { if (sub_packet_h != 1) return AVERROR_INVALIDDATA; } else if (sub_packet_h != 4) return AVERROR_INVALIDDATA; break; case DEINT_ID_GENR: if (st->codec->codec_id == AV_CODEC_ID_COOK) { if (sub_packet_h != 1) return AVERROR_INVALIDDATA; } else if (st->codec->codec_id == AV_CODEC_ID_SIPR) { if ("}, {"ID": 1777, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static inline void rv34_mc(RV34DecContext *r, const int block_type, const int xoff, const int yoff, int mv_off, const int width, const int height, int dir, const int thirdpel, int weighted, qpel_mc_func (*qpel_mc)[16], h264_chroma_mc_func (*chroma_mc)) { MpegEncContext *s = &r->s; uint8_t *Y, *U, *V, *srcY, *srcU, *srcV; int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y; int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off; int is16x16 = 1; if(thirdpel){ int chroma_mx, chroma_my; mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24); my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24); lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3; ly = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) % 3; chroma_mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2; chroma_my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2; umx = (chroma_mx + (3 << 24)) / 3 - (1 << 24); umy = (chroma_my + (3 << 24)) / 3 - (1 << 24); uvmx = chroma_coeffs[(chroma_mx + (3 << 24)) % 3]; uvmy = chroma_coeffs[(chroma_my + (3 << 24)) % 3]; }else{ int cx, cy; mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] >> 2; my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] >> 2; lx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] & 3; ly = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] & 3; cx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2; cy = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2; umx = cx >> 2; umy = cy >> 2; uvmx = (cx & 3) << 1; uvmy = (cy & 3) << 1; //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3 if(uvmx == 6 && uvmy == 6) uvmx = uvmy = 4; } dxy = ly*4 + lx; srcY = dir ? s->next_picture_ptr->f.data[0] : s->last_picture_ptr->f.data[0]; srcU = dir ? s->next_picture_ptr->f.data[1] : s->last_picture_ptr->f.data[1]; srcV = dir ? s->next_picture_ptr->f.data[2] : s->last_picture_ptr->f.data[2]; src_x = s->mb_x * 16 + xoff + mx; src_y = s->mb_y * 16 + yoff + my; uvsrc_x = s->mb_x * 8 + (xoff >> 1) + umx; uvsrc_y = s->mb_y * 8 + (yoff >> 1) + umy; srcY += src_y * s->linesize + src_x; srcU += uvsrc_y * s->uvlinesize + uvsrc_x; srcV += uvsrc_y * s->uvlinesize + uvsrc_x; if( (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4 || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){ uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize; srcY -= 2 + 2*s->linesize; s->dsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6, src_x - 2, src_y - 2, s->h_edge_pos, s->v_edge_pos); srcY = s->edge_emu_buffer + 2 + 2*s->linesize; s->dsp.emulated_edge_mc(uvbuf , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1); s->dsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1, uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1); srcU = uvbuf; srcV = uvbuf + 16; } if(!weighted){ Y = s->dest[0] + xoff + yoff *s->linesize; U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize; V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize; }else{ Y = r->tmp_b_block_y [dir] + xoff + yoff *s->linesize; U = r->tmp_b_block_uv[dir*2] + (xoff>>1) + (yoff>>1)*s->uvlinesize; V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize; } if(block_type == RV34_MB_P_16x8){ qpel_mc[1][dxy](Y, srcY, s->linesize); Y += 8; srcY += 8; }else if(block_type == RV34_MB_P_8x16){ qpel_mc[1][dxy](Y, srcY, s->linesize); Y += 8 * s->linesize; srcY += 8 * s->linesize; } is16x16 = (", "ground_truth": "YES", "predict": "block_type == RV34_MB_P_16x16); if(block_type == RV34_MB_P_16x16 || block_type == RV34_MB_P_16x8 || block_type == RV34_MB_P_8x16){ qpel_mc[0][dxy](Y, srcY, s->linesize); if(is16x16){ qpel_mc[0][dxy](Y + 8, srcY + 8, s->linesize); } } else{ qpel_mc[0][dxy](Y, srcY, s->linesize); } if(block_type == RV34_MB_P_16x16 || block_type == RV34_MB_P_16x8 || block_type == RV34_MB_P_8x16){ chroma_"}, {"ID": 1901, "prompt": "Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n    ### Instruction:\n    Is there a defect in the Code, and respond to YES or NO.\n\n    ### Input:\n    static int rtsp_read_header(AVFormatContext *s, AVFormatParameters *ap) { RTSPState *rt = s->priv_data; char host[1024], path[1024], tcpname[1024], cmd[2048]; URLContext *rtsp_hd; int port, i, ret, err; RTSPHeader reply1, *reply = &reply1; unsigned char *content = NULL; AVStream *st; RTSPStream *rtsp_st; int protocol_mask; rtsp_abort_req = 0; /* extract hostname and port */ url_split(NULL, 0, host, sizeof(host), &port, path, sizeof(path), s->filename); if (port < 0) port = RTSP_DEFAULT_PORT; /* open the tcp connexion */ snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port); if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0) return AVERROR_IO; rt->rtsp_hd = rtsp_hd; rt->seq = 0; /* describe the stream */ snprintf(cmd, sizeof(cmd), \"DESCRIBE %s RTSP/1.0\\r\\n\" \"Accept: application/sdp\\r\\n\", s->filename); rtsp_send_cmd(s, cmd, reply, &content); if (!content) { err = AVERROR_INVALIDDATA; goto fail; } if (reply->status_code != RTSP_STATUS_OK) { err = AVERROR_INVALIDDATA; goto fail; } /* now we got the SDP description, we parse it */ ret = sdp_parse(s, (const char *)content); av_freep(&content); if (ret < 0) { err = AVERROR_INVALIDDATA; goto fail; } protocol_mask = rtsp_default_protocols; /* for each stream, make the setup request */ /* XXX: we assume the same server is used for the control of each RTSP stream */ for(i=0;i<s->nb_streams;i++) { char transport[2048]; AVInputFormat *fmt; st = s->streams[i]; rtsp_st = st->priv_data; /* compute available transports */ transport[0] = '\\0'; /* RTP/UDP */ if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) { char buf[256]; int j; /* first try in specified port range */ if (rtsp_rtp_port_min != 0) { for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) { snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j); if (!av_open_input_file(&rtsp_st->ic, buf, &rtp_demux, 0, NULL)) goto rtp_opened; } } /* then try on any port */ if (av_open_input_file(&rtsp_st->ic, \"rtp://\", &rtp_demux, 0, NULL) < 0) { err = AVERROR_INVALIDDATA; goto fail; } rtp_opened: port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb)); if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/UDP;unicast;client_port=%d-%d\", port, port + 1); } /* RTP/TCP */ if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) { if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/TCP\"); } if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) { if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/UDP;multicast\"); } snprintf(cmd, sizeof(cmd), \"SETUP %s RTSP/1.0\\r\\n\" \"Transport: %s\\r\\n\", rtsp_st->control_url, transport); rtsp_send_cmd(s, cmd, reply, NULL); if (reply->status_code != RTSP_STATUS_OK || reply->nb_transports != 1) { err = AVERROR_INVALIDDATA; goto fail; } /* XXX: same protocol for all streams is required */ if (i > 0) { if (reply->transports[0].protocol != rt->protocol) { err = AVERROR_INVALIDDATA; goto fail; } } else { rt->protocol = reply->transports[0].protocol; } /* close RTP connection if not choosen */ if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP && (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) { av_close_input_file(rtsp_st->ic); rtsp_st->ic = NULL; } switch(reply->transports[0].protocol) { case RTSP_PROTOCOL_RTP_TCP: fmt = &rtp_demux; if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) { err = AVERROR_INVALIDDATA; goto fail; } rtsp_st->interleaved_min = reply->transports[0].interleaved_min; rtsp_st->interleaved_max = reply->transports[0].interleaved_max; break; case RTSP_PROTOCOL_RTP_UDP: { char url[1024]; /* XXX: also use address if specified */ snprintf(url, sizeof(url), \"rtp://%s:%d\", host, reply->transports[0].server_port_min); if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) { err = AVERROR_INVALIDDATA; goto fail; } } break; case RTSP_PROTOCOL_RTP_UDP_MULTICAST: { char url[1024]; int ttl; fmt = &rtp_demux; ttl = reply->transports[0].ttl; if (!ttl) ttl = 16; snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", host, reply->transports[0].server_port_min, ttl); if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) { err = AVERROR_INVALIDDATA; goto fail; } } break; } } /* use callback if available to extend setup */ if (ff_rtsp_callback) { if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, NULL, 0, rt->last_reply) < 0) { err = AVERROR_INVALIDDATA; goto fail; } } /* start playing */ snprintf(cmd, sizeof(cmd), \"PLAY %s RTSP/1.0\\r\\n\" \"Range: npt=0-\\r\\n\", s->filename); rtsp_send_cmd(s, cmd, reply, NULL); if (reply->status_code != RTSP_STATUS_OK) { err =", "ground_truth": "NO", "predict": " AVERROR_INVALIDDATA; goto fail; } /* use callback if available to extend play */ if (ff_rtsp_callback) { if (ff_rtsp_callback(RTSP_ACTION_CLIENT_PLAY, rt->session_id, NULL, 0, rt->last_reply) < 0) { err = AVERROR_INVALIDDATA; goto fail; } } return 0; fail: if (content) av_freep(&content); if (rtsp_hd) url_close(rtsp_hd); return err; }"}]