[{"ID": 42, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected void innerProcess(CrawlURI curi) throws InterruptedException { if (!curi.isHttpTransaction()) { return; } if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) { return; } long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue(); try { maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue(); } catch (AttributeNotFoundException e) { logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString()); } if (maxsize < curi.getContentSize() && maxsize > -1) { return; } String regexpr = \"\"; try { regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR); } catch (AttributeNotFoundException e2) { logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString()); return; } ReplayCharSequence cs = null; try { cs = curi.getHttpRecorder().getReplayCharSequence(); } catch (Exception e) { curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage()); logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName()); return; } MessageDigest digest = null; try { digest = MessageDigest.getInstance(\"SHA1\"); } catch (NoSuchAlgorithmException e1) { e1.printStackTrace(); return; } digest.reset(); String s = null; if (regexpr.length() == 0) { s = cs.toString(); } else { Matcher m = TextUtils.getMatcher(regexpr, cs); s = m.replaceAll(\" \"); } digest.update(s.getBytes()); byte[] newDigestValue = digest.digest(); if (logger.isLoggable(Level.FINEST)) { logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue)); } curi.setContentDigest(newDigestValue); }. \nCode2: public static TopicMap getTopicMap(URL url) { String baseURI = url.toString(); InputStream inputStream = null; try { inputStream = url.openStream(); } catch (IOException e) { e.printStackTrace(); } return getTopicMap(inputStream, baseURI); }. \n### Response:", "ground_truth": "NO", "predict": "public static TopicMap getTopicMap(InputStream inputStream, String baseURI) { \n     TopicMap result = new TopicMapImpl(); \n     try { \n         Document document = new Document(inputStream); \n         result.addDocument(document, baseURI); \n     } catch (IOException e) { \n         e.printStackTrace(); \n     } \n     return result;\n}"}, {"ID": 637, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void actualizar() throws SQLException, ClassNotFoundException, Exception { Connection conn = null; PreparedStatement ms = null; registroActualizado = false; try { conn = ToolsBD.getConn(); conn.setAutoCommit(false); Date fechaSystem = new Date(); DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\"); int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem)); DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\"); DateFormat sss = new SimpleDateFormat(\"S\"); String ss = sss.format(fechaSystem); if (ss.length() > 2) { ss = ss.substring(0, 2); } int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss); ms = conn.prepareStatement(SENTENCIA_UPDATE); ms.setString(1, descartadoEntrada); ms.setString(2, usuarioEntrada); ms.setString(3, motivosDescarteEntrada); ms.setInt(4, Integer.parseInt(anoOficio)); ms.setInt(5, Integer.parseInt(oficinaOficio)); ms.setInt(6, Integer.parseInt(numeroOficio)); ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0); ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0); ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0); int afectados = ms.executeUpdate(); if (afectados > 0) { registroActualizado = true; } else { registroActualizado = false; } conn.commit(); } catch (Exception ex) { System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage()); ex.printStackTrace(); registroActualizado = false; errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage()); try { if (conn != null) conn.rollback(); } catch (SQLException sqle) { throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle); } throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex); } finally { ToolsBD.closeConn(conn, ms, null); } }. \nCode2: @Override public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException { String uniqueName = path.getBaseName(); URL url = buildURL(uniqueName); URLContent content = new URLContent(url, this.getName(), uniqueName); content.setUniqueName(uniqueName); content.setReadable(true); content.setWritable(writable); content.setExists(true); try { URLConnection connection = url.openConnection(); String mimeType = connection.getContentType(); content.setMimeType(mimeType); content.setWritable(true); } catch (IOException ex) { throw new ContentException(\"unable to obtain mime type of \" + url, ex); } return content; }. \n### Response:", "ground_truth": "NO", "predict": "@Override public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException { String uniqueName = path.getBaseName(); URL url = buildURL(uniqueName); URLContent content = new URLContent(url, this.getName(), uniqueName); content.setUniqueName(uniqueName); content.setReadable(true); content.setWritable(writable); content.setExists(true); try { URLConnection connection = url.openConnection(); String mimeType = connection.getContentType(); content.setMimeType(mimeType); content.setWritable(true); } catch (IOException ex) { throw new ContentException(\"unable to obtain mime type of \" + url, ex); } return content; }. \n@Override public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException { String uniqueName = path.getBaseName(); URL"}, {"ID": 685, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void upgradeSchema() throws IOException { Statement stmt = null; try { int i = getSchema(); LOG.info(\"DB is currently at schema \" + i); if (i < SCHEMA_VERSION) { LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION); conn.setAutoCommit(false); stmt = conn.createStatement(); while (i < SCHEMA_VERSION) { String qry; switch(i) { case 1: qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; } i++; } conn.commit(); } } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e2) { LOG.error(SQL_ERROR, e2); } LOG.fatal(SQL_ERROR, e); throw new IOException(\"Error upgrading data store\", e); } finally { try { if (stmt != null) stmt.close(); conn.setAutoCommit(true); } catch (SQLException e) { LOG.error(SQL_ERROR, e); throw new IOException(\"Unable to cleanup SQL resources\", e); } } }. \nCode2: @Override public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException { final Connection connection = this.getConnection(); try { connection.setAutoCommit(false); String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id = \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \"; if (contextName != null) { queryString = queryString + \" context_name LIKE ? AND \"; } if (dateFrom != null) { queryString = queryString + \" start_timestamp >= ? AND \"; } if (dateTo != null) { queryString = queryString + \" start_timestamp <= ? AND \"; } queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString); final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString); int indexCounter = 1; if (contextName != null) { preparedStatement.setString(indexCounter, contextName); indexCounter = indexCounter + 1; } if (dateFrom != null) { preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime())); indexCounter = indexCounter + 1; } if (dateTo != null) { preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime())); indexCounter = indexCounter + 1; } preparedStatement.executeUpdate(); preparedStatement.close(); connection.commit(); } catch (final SQLException e) { try { connection.rollback(); } catch (final SQLException ex) { JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex); } JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage()); throw new DatabaseException(\"Error deleting JVM statistics.\", e); } finally { this.releaseConnection(connection); } }. \n### Response:", "ground_truth": "YES", "predict": "@Override public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException { final Connection connection = this.getConnection(); try { connection.setAutoCommit(false); String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id = \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \"; if (contextName != null) { queryString = queryString + \" context_name LIKE ? AND \"; } if (dateFrom != null) { queryString = queryString + \" start_timestamp >= ? AND \"; } if (dateTo != null) { query"}, {"ID": 996, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) { log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); outageUpdater.setString(4, ipAddr); outageUpdater.setLong(5, serviceID); outageUpdater.executeUpdate(); outageUpdater.close(); try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } else { log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\"); } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \nCode2: public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) { int intResult = 0; String sql = \"UPDATE torneo\" + \" SET numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "YES", "predict": "true!!!!!!!!!!!!!!"}, {"ID": 1280, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception { DBOperation dbo = null; Connection connection = null; PreparedStatement preStm = null; String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\"; String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\"; try { dbo = createDBOperation(); connection = dbo.getConnection(); connection.setAutoCommit(false); preStm = connection.prepareStatement(cleanSql); int dCount = preStm.executeUpdate(); String sHaveIns = \",\"; preStm = connection.prepareStatement(sql); for (int j = 0; j < checkId.length; j++) { if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) { preStm.setInt(1, Integer.parseInt(userId)); preStm.setInt(2, Integer.parseInt(checkId[j])); preStm.setInt(3, Integer.parseInt(checkType)); preStm.setInt(4, Integer.parseInt(objType)); preStm.executeUpdate(); sHaveIns += checkId[j] + \",\"; } } connection.commit(); } catch (Exception ex) { log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \"); try { connection.rollback(); } catch (SQLException e) { throw e; } throw ex; } finally { close(null, null, preStm, connection, dbo); } }. \nCode2: @Override public void incluir(Igreja igreja) throws Exception { Connection connection = criaConexao(false); String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\"; String sql2 = \"SELECT MAX(idlocal) FROM Local\"; PreparedStatement stmt = null; PreparedStatement stmt2 = null; ResultSet rs = null; try { stmt = connection.prepareStatement(sql); stmt2 = connection.prepareStatement(sql2); rs = stmt2.executeQuery(); stmt.setInt(1, rs.getInt(\"max\")); stmt.setBoolean(2, igreja.getPossuiSalao()); int retorno = stmt.executeUpdate(); if (retorno == 0) { connection.rollback(); throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\"); } connection.commit(); } catch (SQLException e) { connection.rollback(); throw e; } finally { try { stmt.close(); stmt2.close(); rs.close(); this.fechaConexao(); } catch (SQLException e) { throw e; } } }. \n### Response:", "ground_truth": "YES", "predict": "@Override public void incluir(Igreja igreja) throws Exception { Connection connection = criaConexao(false); String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\"; String sql2 = \"SELECT MAX(idlocal) FROM Local\"; PreparedStatement stmt = null; PreparedStatement stmt2 = null; ResultSet rs = null; try { stmt = connection.prepareStatement(sql); stmt2 = connection.prepareStatement(sql2); rs = stmt2.executeQuery(); stmt.setInt(1, rs.getInt(\"max\")); stmt.setBoolean(2, igreja.getPossuiSalao()); int retorno = stmt.executeUpdate(); if (retorno == 0) { connection.rollback(); throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no ban"}, {"ID": 1418, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void testSimpleQuery() throws Exception { JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\"); assertNotNull(dummySource); OutputStream os = ((ModifiableSource) dummySource).getOutputStream(); assertNotNull(os); String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\"; os.write(dummyContent.getBytes()); os.flush(); os.close(); JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\"); assertNotNull(source); os = ((ModifiableSource) source).getOutputStream(); assertNotNull(os); String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\"; os.write(content.getBytes()); os.flush(); os.close(); QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\"); assertNotNull(qResult); Collection results = qResult.getChildren(); assertEquals(1, results.size()); Iterator it = results.iterator(); JCRNodeSource rSrc = (JCRNodeSource) it.next(); InputStream rSrcIn = rSrc.getInputStream(); ByteArrayOutputStream actualOut = new ByteArrayOutputStream(); IOUtils.copy(rSrcIn, actualOut); rSrcIn.close(); assertEquals(content, actualOut.toString()); actualOut.close(); rSrc.delete(); }. \nCode2: @Test public void testCopy_readerToWriter_nullIn() throws Exception { ByteArrayOutputStream baout = new ByteArrayOutputStream(); OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true); Writer writer = new OutputStreamWriter(baout, \"US-ASCII\"); try { IOUtils.copy((Reader) null, writer); fail(); } catch (NullPointerException ex) { } }. \n### Response:", "ground_truth": "YES", "predict": "@Test public void testCopy_readerToWriter_nullIn() throws Exception { ByteArrayOutputStream baout = new ByteArrayOutputStream(); OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true); Writer writer = new OutputStreamWriter(baout, \"US-ASCII\"); try { IOUtils.copy((Reader) null, writer); fail(); } catch (NullPointerException ex) { } }. \n@Test public void testCopy_writerToReader_nullIn() throws Exception { InputStream in = new YellOnFlushAndCloseInputStreamTest(true, true); Reader reader = new InputStreamReader(in); try { IOUtils.copy(reader, (Writer) null); fail(); } catch (NullPointerException ex) { } }. \n@Test public void testCopy_writerToReader_nullOut() throws Exception { InputStream in = new YellOnFlushAndCloseInputStreamTest(true"}, {"ID": 1920, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private JButton getButtonSonido() { if (buttonSonido == null) { buttonSonido = new JButton(); buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\")); buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\"))); buttonSonido.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent e) { JFileChooser fc = new JFileChooser(); fc.addChoosableFileFilter(new SoundFilter()); int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\")); if (returnVal == JFileChooser.APPROVE_OPTION) { File file = fc.getSelectedFile(); String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName(); String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName(); try { FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(rutaGlobal, true); FileChannel canalFuente = fis.getChannel(); FileChannel canalDestino = fos.getChannel(); canalFuente.transferTo(0, canalFuente.size(), canalDestino); fis.close(); fos.close(); imagen.setSonidoURL(rutaRelativa); System.out.println(rutaGlobal + \" \" + rutaRelativa); buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\"))); gui.getAudio().reproduceAudio(imagen); } catch (IOException ex) { ex.printStackTrace(); } } else { } } }); } return buttonSonido; }. \nCode2: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null && stableBuild != null) { doVersionCheck(view, stableBuild, develBuild); } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \n### Response:", "ground_truth": "NO", "predict": "public static void doVersionCheck(View view, String stableBuild, String develBuild) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null && stableBuild != null) { doVersionCheck(view, stableBuild, develBuild); } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString"}]