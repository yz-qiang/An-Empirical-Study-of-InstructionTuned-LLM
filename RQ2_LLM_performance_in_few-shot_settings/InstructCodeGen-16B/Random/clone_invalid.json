[{"ID": 128, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static boolean copyFile(final File src, final File dest, long extent, final boolean overwrite) throws FileNotFoundException, IOException { boolean result = false; if (LOGGER.isLoggable(Level.FINE)) { LOGGER.fine(\"Copying file \" + src + \" to \" + dest + \" extent \" + extent + \" exists \" + dest.exists()); } if (dest.exists()) { if (overwrite) { dest.delete(); LOGGER.finer(dest.getAbsolutePath() + \" removed before copy.\"); } else { return result; } } FileInputStream fis = null; FileOutputStream fos = null; FileChannel fcin = null; FileChannel fcout = null; try { fis = new FileInputStream(src); fos = new FileOutputStream(dest); fcin = fis.getChannel(); fcout = fos.getChannel(); if (extent < 0) { extent = fcin.size(); } long trans = fcin.transferTo(0, extent, fcout); if (trans < extent) { result = false; } result = true; } catch (IOException e) { String message = \"Copying \" + src.getAbsolutePath() + \" to \" + dest.getAbsolutePath() + \" with extent \" + extent + \" got IOE: \" + e.getMessage(); if (e.getMessage().equals(\"Invalid argument\")) { LOGGER.severe(\"Failed copy, trying workaround: \" + message); workaroundCopyFile(src, dest); } else { IOException newE = new IOException(message); newE.setStackTrace(e.getStackTrace()); throw newE; } } finally { if (fcin != null) { fcin.close(); } if (fcout != null) { fcout.close(); } if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } return result; }. \nCode2: public static final boolean checkForUpdate(final String currentVersion, final String updateURL, boolean noLock) throws Exception { try { final String parentFDTConfDirName = System.getProperty(\"user.home\") + File.separator + \".fdt\"; final String fdtUpdateConfFileName = \"update.properties\"; final File confFile = createOrGetRWFile(parentFDTConfDirName, fdtUpdateConfFileName); if (confFile != null) { long lastCheck = 0; Properties updateProperties = new Properties(); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(confFile); updateProperties.load(fis); final String lastCheckProp = (String) updateProperties.get(\"LastCheck\"); lastCheck = 0; if (lastCheckProp != null) { try { lastCheck = Long.parseLong(lastCheckProp); } catch (Throwable t) { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"Got exception parsing LastCheck param\", t); } lastCheck = 0; } } } catch (Throwable t) { logger.log(Level.WARNING, \"Cannot load update properties file: \" + confFile, t); } finally { closeIgnoringExceptions(fos); closeIgnoringExceptions(fis); } final long now = System.currentTimeMillis(); boolean bHaveUpdates = false; checkAndSetInstanceID(updateProperties); if (lastCheck + FDT.UPDATE_PERIOD < now) { lastCheck = now; try { logger.log(\"\\n\\nChecking for remote updates ... This may be disabled using -noupdates flag.\"); bHaveUpdates = updateFDT(currentVersion, updateURL, false, noLock); if (bHaveUpdates) { logger.log(\"FDT may be updated using: java -jar fdt.jar -update\"); } else { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"No updates available\"); } } } catch (Throwable t) { if (logger.isLoggable(Level.FINE)) { logger.log(Level.WARNING, \"Got exception\", t); } } updateProperties.put(\"LastCheck\", \"\" + now); try { fos = new FileOutputStream(confFile); updateProperties.store(fos, null); } catch (Throwable t1) { logger.log(Level.WARNING, \"Cannot store update properties file\", t1); } finally { closeIgnoringExceptions(fos); } return bHaveUpdates; } } else { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \" [ checkForUpdate ] Cannot read or write the update conf file: \" + parentFDTConfDirName + File.separator + fdtUpdateConfFileName); } return false; } } catch (Throwable t) { logger.log(Level.WARNING, \"Got exception checking for updates\", t); } return false; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException { ProgramProfilingMessageSymbol profilingMessageSymbol = null; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\"; connection = DriverManager.getConnection(CONN_STR); statement = connection.createStatement(); statement.executeUpdate(query); query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID = \" + programMessageSymbolID; resultSet = statement.executeQuery(query); if (!resultSet.next()) { connection.rollback(); String msg = \"Attempt to create program profiling message \" + \"symbol failed.\"; log.error(msg); throw new AdaptationException(msg); } profilingMessageSymbol = getProfilingMessageSymbol(resultSet); connection.commit(); } catch (SQLException ex) { try { connection.rollback(); } catch (Exception e) { } String msg = \"SQLException in createNewProfilingMessageSymbol\"; log.error(msg, ex); throw new AdaptationException(msg, ex); } finally { try { resultSet.close(); } catch (Exception ex) { } try { statement.close(); } catch (Exception ex) { } try { connection.close(); } catch (Exception ex) { } } return profilingMessageSymbol; }. \nCode2: public void Load(String fname) throws Exception { File f = null; try { if (\"\".equals(fname) || fname == null) throw new Exception(); System.out.println(\"Loading mapfile \" + fname); } catch (Exception e) { throw new Exception(\"File not found\"); } aType = null; fieldtype.clear(); creatures.clear(); aElement = new String(\"\"); content = null; Ax = -1; Ay = -1; aTemplate = -1; SAXParserFactory factory = SAXParserFactory.newInstance(); data_read = 0; URL url = this.game.mainClass.getClassLoader().getResource(fname); if (url == null) { throw new Exception(\"Can't load map from : \" + fname); } try { SAXParser parser = factory.newSAXParser(); parser.parse(url.openStream(), this);", "ground_truth": "NO", "predict": " } catch (Exception ex) { throw new Exception(\"Error parsing map file: \" + ex.getMessage()); } finally { url.close(); } }. \nCode3: public void Save(String fname) throws Exception { File f = null; try { if (\"\".equals(fname) || fname == null) throw new Exception(); System.out.println(\"Saving mapfile \" + fname); } catch (Exception e) { throw new Exception(\"File not found\"); } aType = null; fieldtype.clear(); creatures.clear(); aElement = new String(\"\"); content = null; Ax = -1; Ay = -1; aTemplate = -1; SAXParserFactory factory = SAXParserFactory.newInstance(); data_read = 0; URL url = this.game.mainClass.getClassLoader().getResource(fname); if (url == null) { throw new Exception(\"Can't save map to : \" + fname); } try { SAXParser parser"}, {"ID": 209, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static InputStream call(String serviceUrl, Map parameters) throws IOException, RestException { StringBuffer urlString = new StringBuffer(serviceUrl); String query = RestClient.buildQueryString(parameters); HttpURLConnection conn; if ((urlString.length() + query.length() + 1) > MAX_URI_LENGTH_FOR_GET) { URL url = new URL(urlString.toString()); conn = (HttpURLConnection) url.openConnection(); conn.setRequestProperty(\"User-Agent\", USER_AGENT_STRING); conn.setRequestMethod(\"POST\"); conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); conn.setDoOutput(true); conn.getOutputStream().write(query.getBytes()); } else { if (query.length() > 0) { urlString.append(\"?\").append(query); } URL url = new URL(urlString.toString()); conn = (HttpURLConnection) url.openConnection(); conn.setRequestProperty(\"User-Agent\", USER_AGENT_STRING); conn.setRequestMethod(\"GET\"); } int responseCode = conn.getResponseCode(); if (HttpURLConnection.HTTP_OK != responseCode) { ByteArrayOutputStream errorBuffer = new ByteArrayOutputStream(); int read; byte[] readBuffer = new byte[ERROR_READ_BUFFER_SIZE]; InputStream errorStream = conn.getErrorStream(); while (-1 != (read = errorStream.read(readBuffer))) { errorBuffer.write(readBuffer, 0, read); } throw new RestException(\"Request failed, HTTP \" + responseCode + \": \" + conn.getResponseMessage(), errorBuffer.toByteArray()); } return conn.getInputStream(); }. \nCode2: private void updateSystem() throws IOException { String stringUrl=\"http://code.google.com/p/senai-pe-cronos/downloads/list\"; try { url = new URL(stringUrl); } catch (MalformedURLException ex) { ex.printStackTrace(); } InputStream is = url.openStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String linha = br.readLine(); while (linha != null) { linha = br.readLine(); if(linha.contains(\"/files/updateCronos-0-\")){ String[] s=linha.split(\"-\"); String[] v=s[4].split(\".exe\"); versao=v[0]; println(\"----\"+versao); break; } } stringUrl=\"http://senai-pe-cronos.googlecode.com/files/updateCronos-0-\"+versao+\".exe\"; UpdateCronos update=new UpdateCronos(); try { url = new URL(stringUrl); } catch (MalformedURLException ex) { ex.printStackTrace(); } System.out.println(\"vers\u00e3o:\"+versao); if(Integer.parseInt(versao)>version){ File f = update.gravaArquivoDeURL(url,System.getProperty(\"user.dir\"),String.valueOf(version),versao); if(update.isS()) { Runtime.getRuntime().exec(location+\"\\\\update.exe\"); System.exit(0); } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) { log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); outageUpdater.setString(4, ipAddr); outageUpdater.setLong(5, serviceID); outageUpdater.executeUpdate(); outageUpdater.close(); try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } else { log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\"); } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \nCode2: public String encrypt(String password) throws Exception { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(password.getBytes()); BigInteger hash = new BigInteger(1, md5.digest()); String hashword = hash.toString(16); return hashword; }. \n### Response:", "ground_truth": "NO", "predict": "public String encrypt(String password) throws Exception { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(password.getBytes()); BigInteger hash = new BigInteger(1, md5.digest()); String hashword = hash.toString(16); return hashword; }. \n\npublic String decrypt(String hashword) throws Exception { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(hashword.getBytes()); BigInteger hash = new BigInteger(1, md5.digest()); String password = hash.toString(16); return password; }. \n\npublic String decrypt(String hashword) throws Exception { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(hashword.getBytes()); BigInteger hash = new BigInteger(1, md5.digest()); String password = hash.toString(16); return password; }. \n\n"}, {"ID": 213, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getHtml(String path) throws Exception { URL url = new URL(path); URLConnection conn = url.openConnection(); conn.setDoOutput(true); InputStream inputStream = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(inputStream, \"UTF-8\"); StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(isr); String inputLine; while ((inputLine = in.readLine()) != null) { sb.append(inputLine); } String result = sb.toString(); return result; }. \nCode2: public MapInfo getMap(double latitude, double longitude, double wanted_mapblast_scale, int image_width, int image_height, String file_path_wo_extension, ProgressListener progress_listener) throws IOException { try { if (web_request_ == null) { web_request_ = new HttpRequester(HOST_NAME); } int zoom_index = getZoomLevelIndex(wanted_mapblast_scale); int google_zoom_level = GOOGLE_ZOOM_LEVELS[zoom_index]; double mapblast_scale = POSSIBLE_GOOGLE_SCALES[zoom_index]; Tile tile = new Tile(latitude, longitude, google_zoom_level); SimplePoint coords = tile.getTileLatLong(); SimplePoint google_xy = tile.getTileCoord(); MapInfo map_info = new MapInfo(); map_info.setLatitude(coords.getX()); map_info.setLongitude(coords.getY()); map_info.setScale((float) mapblast_scale); map_info.setWidth(256); map_info.setHeight(256); map_info.setFilename(file_path_wo_extension + \"png\"); Object[] params = new Object[] { new Integer(google_xy.getX()), new Integer(google_xy.getY()), new Integer(google_zoom_level) }; MessageFormat message_format = new MessageFormat(GOOGLE_MAPS_URL, Locale.US); String url_string = message_format.format(params); URL url = new URL(url_string); if (Debug.DEBUG) Debug.println(\"map_download\", \"loading map from url: \" + url); URLConnection connection = url.openConnection(); if (resources_.getBoolean(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_USE)) { String proxy_userid = resources_.getString(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_USERNAME); String proxy_password = resources_.getString(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_PASSWORD); String auth_string = proxy_userid + \":\" + proxy_password; auth_string = \"Basic \" + new sun.misc.BASE64Encoder().encode(auth_string.getBytes()); connection.setRequestProperty(\"Proxy-Authorization\", auth_string); } connection.connect(); String mime_type = connection.getContentType().toLowerCase(); if (!mime_type.startsWith(\"image\")) { if (mime_type.startsWith(\"text\")) { HTMLViewerFrame viewer = new HTMLViewerFrame(url); viewer.setSize(640, 480); viewer.setTitle(\"ERROR on loading url: \" + url); viewer.setVisible(true); throw new IOException(\"Invalid mime type (expected 'image/*'): received \" + mime_type + \"\\nPage is displayed in HTML frame.\"); } throw new IOException(\"Invalid mime type (expected 'image/*'): received \" + mime_type); } int content_length = connection.getContentLength(); if (content_length < 0) progress_listener.actionStart(PROGRESS_LISTENER_ID, 0, Integer.MIN_VALUE); else progress_listener.actionStart(PROGRESS_LISTENER_ID, 0, content_length); String extension = mime_type.substring(mime_type.indexOf('/') + 1); String filename = file_path_wo_extension + extension; FileOutputStream out = new FileOutputStream(filename); byte[] buffer = new byte[BUFFER_SIZE]; BufferedInputStream in = new BufferedInputStream(connection.getInputStream(), BUFFER_SIZE); int sum_bytes = 0; int num_bytes = 0; while ((num_bytes = in.read(buffer)) != -1) { out.write(buffer, 0, num_bytes); sum_bytes += num_bytes; progress_listener.actionProgress(PROGRESS_LISTENER_ID, sum_bytes); } progress_listener.actionEnd(PROGRESS_LISTENER_ID); in.close(); out.close(); return (map_info); } catch (NoRouteToHostException nrhe) { nrhe.printStackTrace(); progress_listener.actionEnd(PROGRESS_LISTENER_ID); String message = nrhe.getMessage() + \":\\n\" + resources_.getString(DownloadMouseModeLayer.KEY_LOCALIZE_MESSAGE_DOWNLOAD_ERROR_NO_ROUTE_TO_HOST_MESSAGE); throw new IOException(message); } catch (FileNotFoundException fnfe) { fnfe.printStackTrace(); progress_listener.actionEnd(PROGRESS_LISTENER_ID); String message = fnfe.getMessage() + \":\\n\" + resources_.getString(DownloadMouseModeLayer.KEY_LOCALIZE_MESSAGE_DOWNLOAD_ERROR_FILE_NOT_FOUND_MESSAGE); throw new IOException(message); } catch (Exception e) { progress_listener.actionEnd(PROGRESS_LISTENER_ID); e.printStackTrace(); String message = e.getMessage(); if (message == null) { Throwable cause = e.getCause(); if (cause != null) message = cause.getMessage(); } throw new IOException(message); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\"); logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString); URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString); logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile()); HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection(); HttpURLConnection.setFollowRedirects(false); httpURLConnection.connect(); response.setStatus(httpURLConnection.getResponseCode()); logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\"); logger.debug(\"[headers]\"); for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) { if (header.getKey() != null) { for (String value : header.getValue()) { if (value != null) { logger.debug(header.getKey() + \": \" + value); if (!header.getKey().equals(\"Server\") && !header.getKey().equals", "ground_truth": "NO", "predict": "(\"Date\") && !header.getKey().equals(\"Content-Type\")) { response.setHeader(header.getKey(), value); } } } } } logger.debug(\"[body]\"); InputStream in = httpURLConnection.getInputStream(); BufferedReader inBR = new BufferedReader(new InputStreamReader(in)); StringBuilder sb = new StringBuilder(); while ((String line = inBR.readLine()) != null) { sb.append(line); } String body = sb.toString(); logger.debug(\"body: \" + body); response.setContentType(\"text/html\"); response.setContentLength(body.length()); response.getOutputStream().write(body.getBytes(\"UTF-8\")); response.getOutputStream().flush(); } }. \n\nCode2:public String getHtml(String path) throws Exception { URL url = new URL(path); URLConnection conn = url.openConnection(); conn.setDoOutput(true);"}, {"ID": 219, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static boolean copyDataToNewTable(EboContext p_eboctx, String srcTableName, String destTableName, String where, boolean log, int mode) throws boRuntimeException { srcTableName = srcTableName.toUpperCase(); destTableName = destTableName.toUpperCase(); Connection cn = null; Connection cndef = null; boolean ret = false; try { boolean srcexists = false; boolean destexists = false; final InitialContext ic = new InitialContext(); cn = p_eboctx.getConnectionData(); cndef = p_eboctx.getConnectionDef(); PreparedStatement pstm = cn.prepareStatement(\"SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?\"); pstm.setString(1, srcTableName); ResultSet rslt = pstm.executeQuery(); if (rslt.next()) { srcexists = true; } rslt.close(); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { destexists = true; } if (!destexists) { rslt.close(); pstm.close(); pstm = cn.prepareStatement(\"SELECT VIEW_NAME FROM USER_VIEWS WHERE VIEW_NAME=?\"); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { CallableStatement cstm = cn.prepareCall(\"DROP VIEW \" + destTableName); cstm.execute(); cstm.close(); } } rslt.close(); pstm.close(); if (srcexists &&!destexists) { if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"CREATING_AND_COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage(\"TO\") + \" [\" + destTableName + \"]\"); } CallableStatement cstm = cn.prepareCall(\"CREATE TABLE \" + destTableName + \" AS SELECT * FROM \" + srcTableName + \" \" + (((. \nCode2: public void testRevcounter() throws ServiceException, IOException { JCRNodeSource emptySource = loadTestSource(); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } String testSourceUri = BASE_URL + \"users/lars.trieloff?revision=1.1\"; JCRNodeSource secondSource = (JCRNodeSource) resolveSource(testSourceUri); System.out.println(\"Created at: \" + secondSource.getSourceRevision()); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } System.out.println(\"Read again at:\" + secondSource.getSourceRevision()); assertNotNull(emptySource.getSourceRevision()); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public FileChooserTestFrame() throws HeadlessException, MalformedURLException { super(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent aEvent) { System.exit(0); } }); Dimension dim = getToolkit().getScreenSize(); Rectangle abounds = getBounds(); setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2); setVisible(true); URL url = new URL(\"ftp://cendantstp/\"); char[] password = \"spnr\".toCharArray(); PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password); FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication); JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setMultiSelectionEnabled(true); File[] selectedFiles = null; if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) { selectedFiles = fileChooser.getSelectedFiles(); for (int i = 0; i < selectedFiles.length; i++) { if (selectedFiles[i] instanceof FTPFileFile) { FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i]; logger.fine(ftpFile.getName()); logger.fine(ftpFile.getPath()); } else { logger.fine(selectedFiles[i].toString()); logger.fine(selectedFiles[i].getAbsolutePath()); } } } remoteFileSystemView.disconnect(); try { if (null!= selectedFiles) { FTPClient ftpClient = new FTPClient(); InetAddress inetAddress = InetAddress.getByName(url.getHost()); ftpClient.connect(inetAddress); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) { throw new FTPBrowseException(ftpClient.getReplyString()); } if (null!= passwordAuthentication) { ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append. \nCode2: public static String encryptPassword(String plainPassword) { StringBuffer sb = new StringBuffer(); try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(plainPassword.getBytes()); byte[] digestBytes = messageDigest.digest(); String hex = null; for (int i = 0; i < digestBytes.length; i++) { hex = Integer.toHexString(0xFF & digestBytes[i]); if (hex.length() < 2) sb.append(\"0\"); sb.append(hex); } } catch (Exception ex) { System.out.println(ex.getMessage()); } return new String(sb); }. \n### Response:", "ground_truth": "NO", "predict": "public static String encryptPassword(String plainPassword) { StringBuffer sb = new StringBuffer(); try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(plainPassword.getBytes()); byte[] digestBytes = messageDigest.digest(); String hex = null; for (int i = 0; i < digestBytes.length; i++) { hex = Integer.toHexString(0xFF & digestBytes[i]); if (hex.length() < 2) sb.append(\"0\"); sb.append(hex); } } catch (Exception ex) { System.out.println(ex.getMessage()); } return new String(sb); \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 256, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void doConvert(HttpServletResponse response, ConversionRequestResolver rr, EGE ege, ConversionsPath cpath) throws FileUploadException, IOException, RequestResolvingException, EGEException, FileNotFoundException, ConverterException, ZipException { InputStream is = null; OutputStream os = null; if (ServletFileUpload.isMultipartContent(rr.getRequest())) { ServletFileUpload upload = new ServletFileUpload(); FileItemIterator iter = upload.getItemIterator(rr.getRequest()); while (iter.hasNext()) { FileItemStream item = iter.next(); if (!item.isFormField()) { is = item.openStream(); applyConversionsProperties(rr.getConversionProperties(), cpath); DataBuffer buffer = new DataBuffer(0, EGEConstants.BUFFER_TEMP_PATH); String alloc = buffer.allocate(is); InputStream ins = buffer.getDataAsStream(alloc); is.close(); try { ValidationResult vRes = ege.performValidation(ins, cpath.getInputDataType()); if (vRes.getStatus().equals(ValidationResult.Status.FATAL)) { ValidationServlet valServ = new ValidationServlet(); valServ.printValidationResult(response, vRes); try { ins.close(); } finally { buffer.removeData(alloc, true); } return; } } catch (ValidatorException vex) { LOGGER.warn(vex.getMessage()); } finally { try { ins.close(); } catch (Exception ex) { } } File zipFile = null; FileOutputStream fos = null; String newTemp = UUID.randomUUID().toString(); IOResolver ior = EGEConfigurationManager.getInstance().getStandardIOResolver(); File buffDir = new File(buffer.getDataDir(alloc)); zipFile = new File(EGEConstants.BUFFER_TEMP_PATH + File.separator + newTemp + EZP_EXT); fos = new FileOutputStream(zipFile); ior.compressData(buffDir, fos); ins = new FileInputStream(zipFile); File szipFile = new File(EGEConstants.BUFFER_TEMP_PATH + File.separator + newTemp + ZIP_EXT); fos = new FileOutputStream(szipFile); try { try { ege.performConversion(ins, fos, cpath); } finally { fos.close(); } boolean isComplex = EGEIOUtils.isComplexZip(szipFile); response.setContentType(APPLICATION_OCTET_STREAM); String fN = item.getName().substring(0, item.getName().lastIndexOf(\".\")); if (isComplex) { String fileExt; if (cpath.getOutputDataType().getMimeType().equals(APPLICATION_MSWORD)) { fileExt = DOCX_EXT; } else { fileExt = ZIP_EXT; } response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fN + fileExt + \"\\\"\"); FileInputStream fis = new FileInputStream(szipFile); os = response.getOutputStream(); try { EGEIOUtils.copyStream(fis, os); } finally { fis.close(); } } else { String fileExt = getMimeExtensionProvider().getFileExtension(cpath.getOutputDataType().getMimeType()); response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fN + fileExt + \"\\\"\"); os = response.getOutputStream(); EGEIOUtils.unzipSingleFile(new ZipFile(szipFile), os); } } finally { ins.close(); if (os != null) { os.flush(); os.close(); } buffer.clear(true); szipFile.delete(); if (zipFile != null) { zipFile.delete(); } } } } } else { response.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } }. \nCode2: private static void copy(String fromFileName, String toFileName) throws IOException { File fromFile = new File(fromFileName); File toFile = new File(toFileName); if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName); if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName); if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) throw new IOException(\"FileCopy: destination file is unwriteable: \" + toFileName); System.out.flush(); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String response = in.readLine(); if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new IOException(\"FileCopy: existing file was not overwritten.\"); } else { String parent = toFile.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent); if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent); if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(fromFile); to = new FileOutputStream(toFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); } finally { if (from != null) try { from.close(); } catch (IOException e) { ; } if (to != null) try { to.close(); } catch (IOException e) { ; } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getSHA256Checksum(String source) { String checksum = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); md.update(source.getBytes()); byte[] byteData = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } System.out.println(\"Hex format : \" + sb.toString()); StringBuffer hexString = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) { hexString.append('0'); } hexString.append(hex); } checksum = hexString.toString(); } catch (NoSuchAlgorithmException ex) { Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex); } return checksum; }. \nCode2: public static void copyFile", "ground_truth": "NO", "predict": "(String fromFileName, String toFileName) throws IOException { File fromFile = new File(fromFileName); File toFile = new File(toFileName); if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName); if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName); if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) throw new IOException(\"FileCopy: destination file is unwriteable: \" + toFileName); System.out.flush(); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String response"}, {"ID": 269, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private File downloadPDB(String pdbId) { File tempFile = new File(path + \"/\" + pdbId + \".pdb.gz\"); File pdbHome = new File(path); if (!pdbHome.canWrite()) { System.err.println(\"can not write to \" + pdbHome); return null; } String ftp = String.format(\"ftp://ftp.ebi.ac.uk/pub/databases/msd/pdb_uncompressed/pdb%s.ent\", pdbId.toLowerCase()); System.out.println(\"Fetching \" + ftp); try { URL url = new URL(ftp); InputStream conn = url.openStream(); System.out.println(\"writing to \" + tempFile); FileOutputStream outPut = new FileOutputStream(tempFile); GZIPOutputStream gzOutPut = new GZIPOutputStream(outPut); PrintWriter pw = new PrintWriter(gzOutPut); BufferedReader fileBuffer = new BufferedReader(new InputStreamReader(conn)); String line; while ((line = fileBuffer.readLine()) != null) { pw.println(line); } pw.flush(); pw.close(); outPut.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); return null; } return tempFile; }. \nCode2: private static List lookupForImplementations(final Class clazz, final ClassLoader loader, final String[] defaultImplementations, final boolean onlyFirst, final boolean returnInstances) throws ClassNotFoundException { if (clazz == null) { throw new IllegalArgumentException(\"Argument 'clazz' cannot be null!\"); } ClassLoader classLoader = loader; if (classLoader == null) { classLoader = clazz.getClassLoader(); } String interfaceName = clazz.getName(); ArrayList tmp = new ArrayList(); ArrayList toRemove = new ArrayList(); String className = System.getProperty(interfaceName); if (className != null && className.trim().length() > 0) { tmp.add(className.trim()); } Enumeration en = null; try { en = classLoader.getResources(\"META-INF/services/\" + clazz.getName()); } catch (IOException e) { e.printStackTrace(); } while (en != null && en.hasMoreElements()) { URL url = (URL) en.nextElement(); InputStream is = null; try { is = url.openStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); String line; do { line = reader.readLine(); boolean remove = false; if (line != null) { if (line.startsWith(\"#-\")) { remove = true; line = line.substring(2); } int pos = line.indexOf('#'); if (pos >= 0) { line = line.substring(0, pos); } line = line.trim(); if (line.length() > 0) { if (remove) { toRemove.add(line); } else { tmp.add(line); } } } } while (line != null); } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } if (defaultImplementations != null) { for (int i = 0; i < defaultImplementations.length; i++) { tmp.add(defaultImplementations[i].trim()); } } if (!clazz.isInterface()) { int m = clazz.getModifiers(); if (!Modifier.isAbstract(m) && Modifier.isPublic(m) && !Modifier.isStatic(m)) { tmp.add(interfaceName); } } tmp.removeAll(toRemove); ArrayList res = new ArrayList(); for (Iterator it = tmp.iterator(); it.hasNext(); ) { className = (String) it.next(); try { Class c = Class.forName(className, false, classLoader); if (c != null) { if (clazz.isAssignableFrom(c)) { if (returnInstances) { Object o = null; try { o = c.newInstance(); } catch (Throwable e) { e.printStackTrace(); } if (o != null) { res.add(o); if (onlyFirst) { return res; } } } else { res.add(c); if (onlyFirst) { return res; } } } else { logger.warning(\"MetaInfLookup: Class '\" + className + \"' is not a subclass of class : \" + interfaceName); } } } catch (ClassNotFoundException e) { logger.log(Level.WARNING, \"Cannot create implementation of interface: \" + interfaceName, e); } } if (res.size() == 0) { throw new ClassNotFoundException(\"Cannot find any implemnetation of class \" + interfaceName); } return res; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void unzipModel(String filename, String tempdir) throws EDITSException { try { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(filename); int BUFFER = 2048; ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { int count; byte data[] = new byte[BUFFER]; FileOutputStream fos = new FileOutputStream(tempdir + entry.getName()); dest = new BufferedOutputStream(fos, BUFFER); while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count); dest.flush(); dest.close(); } zis.close(); } catch (Exception e) { throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage()); } }. \nCode2: private synchronized void loadDDL() throws IOException { try { conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close(); } catch (SQLException e) { Statement stmt = null; if (!e.getMessage().matches(ERR_MISSING_TABLE)) { e.printStackTrace(System.out); throw new IOException(\"Error on initial data store read\"); } String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" }; try { conn.setAutoCommit(false); stmt = conn.createStatement(); for (String q : qry) stmt.executeUpdate(q); conn.commit(); } catch (SQLException e2) { try { conn.rollback(); } catch (SQLException e3) { e3.printStackTrace(System.out); } e2.printStackTrace(new PrintWriter(System.out)); throw new IOException(\"Error initializing data store\"); } finally { if (stmt != null) { try { stmt.close(); } catch (SQLException e4) { e4.printStackTrace(System.out", "ground_truth": "NO", "predict": "); } } } }. \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 280, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void replaceEntityMappings(File signserverearpath, File entityMappingXML) throws ZipException, IOException { ZipInputStream earFile = new ZipInputStream(new FileInputStream(signserverearpath)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ZipOutputStream tempZip = new ZipOutputStream(baos); ZipEntry next = earFile.getNextEntry(); while (next != null) { ByteArrayOutputStream content = new ByteArrayOutputStream(); byte[] data = new byte[30000]; int numberread; while ((numberread = earFile.read(data)) != -1) { content.write(data, 0, numberread); } if (next.getName().equals(\"signserver-ejb.jar\")) { content = replaceEntityMappings(content, entityMappingXML); next = new ZipEntry(\"signserver-ejb.jar\"); } tempZip.putNextEntry(next); tempZip.write(content.toByteArray()); next = earFile.getNextEntry(); } earFile.close(); tempZip.close(); FileOutputStream fos = new FileOutputStream(signserverearpath); fos.write(baos.toByteArray()); fos.close(); }. \nCode2: public DataSet guessAtUnknowns(String filename) { TasselFileType guess = TasselFileType.Sequence; DataSet tds = null; try { BufferedReader br = null; if (filename.startsWith(\"http\")) { URL url = new URL(filename); br = new BufferedReader(new InputStreamReader(url.openStream())); } else { br = new BufferedReader(new FileReader(filename)); } String line1 = br.readLine().trim(); String[] sval1 = line1.split(\"\\\\s\"); String line2 = br.readLine().trim(); String[] sval2 = line2.split(\"\\\\s\"); boolean lociMatchNumber = false; if (!sval1[0].startsWith(\"<\") && (sval1.length == 2) && (line1.indexOf(':') < 0)) { int countLoci = Integer.parseInt(sval1[1]); if (countLoci == sval2.length) { lociMatchNumber = true; } } if (sval1[0].equalsIgnoreCase(\"<Annotated>\")) { guess = TasselFileType.Annotated; } else if (line1.startsWith(\"<\") || line1.startsWith(\"#\")) { boolean isTrait = false; boolean isMarker = false; boolean isNumeric = false; boolean isMap = false; Pattern tagPattern = Pattern.compile(\"[<>\\\\s]+\"); String[] info1 = tagPattern.split(line1); String[] info2 = tagPattern.split(line2); if (info1.length > 1) { if (info1[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info1[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info1[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info1[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } if (info2.length > 1) { if (info2[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info2[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info2[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info2[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } else { guess = null; String inline = br.readLine(); while (guess == null && inline != null && (inline.startsWith(\"#\") || inline.startsWith(\"<\"))) { if (inline.startsWith(\"<\")) { String[] info = tagPattern.split(inline); if (info[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } } } if (isTrait || (isMarker && isNumeric)) { guess = TasselFileType.Phenotype; } else if (isMarker) { guess = TasselFileType.Polymorphism; } else if (isMap) { guess = TasselFileType.GeneticMap; } else { throw new IOException(\"Improperly formatted header. Data will not be imported.\"); } } else if ((line1.startsWith(\">\")) || (line1.startsWith(\";\"))) { guess = TasselFileType.Fasta; } else if (sval1.length == 1) { guess = TasselFileType.SqrMatrix; } else if (line1.indexOf(':') > 0) { guess = TasselFileType.Polymorphism; } else if ((sval1.length == 2) && (lociMatchNumber)) { guess = TasselFileType.Polymorphism; } else if ((line1.startsWith(\"#Nexus\")) || (line1.startsWith(\"#NEXUS\")) || (line1.startsWith(\"CLUSTAL\")) || ((sval1.length == 2) && (sval2.length == 2))) { guess = TasselFileType.Sequence; } else if (sval1.length == 3) { guess = TasselFileType.Numerical; } myLogger.info(\"guessAtUnknowns: type: \" + guess); tds = processDatum(filename, guess); br.close(); } catch (Exception e) { } return tds; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String md5(String text) { String encrypted = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(text.getBytes()); encrypted = hex(md.digest()); } catch (NoSuchAlgorithmException nsaEx) { } return encrypted; }. \nCode2: private void unzip(File filename) throws ZipException, IOException { ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename))); ZipEntry entry = null; boolean first_entry = true; while ((entry = in.getNextEntry()) != null) { if (first_entry) { if (!entry.isDirectory()) { File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length())); if (!subdir.exists()) { subdir.mkdir(); dir = subdir; } } first_entry = false; } if (entry.isDirectory()) { FileUtils.forceMkdir(new File(dir + File.separator + entry.getName())); } else { File outfile = new File(dir + File.separator + entry.getName()); File outdir = new File(outfile.getAbsolutePath().substring(0,", "ground_truth": "NO", "predict": " outfile.getAbsolutePath().length() - outfile.getName().length()) + \"___\"); if (!outdir.exists()) { outdir.mkdir(); } outfile.copyTo(outdir.getAbsolutePath() + File.separator + entry.getName()); } } }. \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 285, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getTextData() { if (tempFileWriter != null) { try { tempFileWriter.flush(); tempFileWriter.close(); FileReader in = new FileReader(tempFile); StringWriter out = new StringWriter(); int len; char[] buf = new char[BUFSIZ]; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); out.close(); in.close(); return out.toString(); } catch (IOException ioe) { Logger.instance().log(Logger.ERROR, LOGGER_PREFIX, \"XMLTextData.getTextData\", ioe); return \"\"; } } else if (textBuffer != null) return textBuffer.toString(); else return null; }. \nCode2: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override public void doIt() { try { Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\"); if (mode.equals(\"FTP\")) { FTPClient client = new FTPClient(); client.connect(Constants.ftpHost); client.login(Constants.ftpUser, Constants.ftpPass); client.changeDirectory(Constants.ftpDir); File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName); client.download(\"GT99_A09.rar\", ff); client.disconnect(false); Shared.prepareMovements(ff); } else if (mode.equals(\"File\")) { JFileChooser jfc = new JFileChooser(); FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\"); jfc.setFileFilter(f); int selection = jfc.showOpenDialog(Shared.getMyMainWindows()); if (selection == JFileChooser.APPROVE_OPTION) { Shared.prepareMovements(jfc.getSelectedFile()); } else { return; } } Shared.updateMovements(); if (Shared.isHadMovements()) { MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\"); msg.show(Shared.getMyMainWindows()); } else { MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\"); msg.show(Shared.getMyMainWindows()); } } catch (Exception ex) { MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex); msg.show(Shared.getMyMainWindows()); } }. \nCode2: public static String installOvalDefinitions(final String xml_location) { InputStream in_stream = null; try { URL url = _toURL(xml_location); if (url == null) { in_stream = new FileInputStream(xml_location); } else { in_stream = url.openStream(); } } catch (IOException ex) { throw new OvalException(ex); } Class<OvalDefinitions> type = OvalDefinitions.class; OvalDefinitions object = _unmarshalObject(type, in_stream); String pid = _getDatastore().save(type, object); return pid; }. \n### Response:", "ground_truth": "NO", "predict": "@Override public void doIt() { try { Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\"); if (mode.equals(\"FTP\")) { FTPClient client = new FTPClient(); client.connect(Constants.ftpHost); client.login(Constants.ftpUser, Constants.ftpPass); client.changeDirectory(Constants.ftpDir); File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName); client.download(\"GT99_A09.rar\", ff); client.disconnect(false); Shared.prepareMovements(ff); } else if (mode.equals(\"File\")) { JFileChooser jfc = new JFileChooser(); FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\"); jfc.setFileFilter(f); int selection"}, {"ID": 391, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void prepareOutput(HttpServletRequest req) { EaasyStreet.logTrace(METHOD_IN + className + OUTPUT_METHOD); super.prepareOutput(req); String content = Constants.EMPTY_STRING; String rawContent = null; List parts = null; try { URL url = new URL(sourceUrl); BufferedReader input = new BufferedReader(new InputStreamReader(url.openStream())); String line = \"\"; StringBuffer buffer = new StringBuffer(); while ((line = input.readLine()) != null) { buffer.append(line); buffer.append(Constants.LF); } rawContent = buffer.toString(); } catch (FileNotFoundException nf) { req.setAttribute(Constants.RAK_SYSTEM_ACTION, Constants.SYSTEM_ACTION_BACK); EaasyStreet.handleSafeEvent(req, new Event(Constants.EAA0012I, new String[] { \"URL\", nf.getMessage(), nf.toString() })); } catch (Exception e) { req.setAttribute(Constants.RAK_SYSTEM_ACTION, Constants.SYSTEM_ACTION_BACK); EaasyStreet.handleSafeEvent(req, new Event(Constants.EAA0012I, new String[] { \"URL\", e.getMessage(), e.toString() })); } if (rawContent != null) { if (startDelimiter != null) { parts = StringUtils.split(rawContent, startDelimiter); if (parts != null && parts.size() > 1) { rawContent = (String) parts.get(1); if (parts.size() > 2) { for (int x = 2; x < parts.size(); x++) { rawContent += startDelimiter; rawContent += parts.get(x); } } } else { rawContent = null; } } } if (rawContent != null) { if (endDelimiter != null) { parts = StringUtils.split(rawContent, endDelimiter); if (parts != null && parts.size() > 0) { rawContent = (String) parts.get(0); } else { rawContent = null; } } } if (rawContent != null) { if (replacementValues != null && !replacementValues.isEmpty()) { for (int x = 0; x < replacementValues.size(); x++) { LabelValueBean bean = (LabelValueBean) replacementValues.get(x); rawContent = StringUtils.replace(rawContent, bean.getLabel(), bean.getValue()); } } } if (rawContent != null) { content = rawContent; } req.setAttribute(getFormName(), content); EaasyStreet.logTrace(METHOD_OUT + className + OUTPUT_METHOD); }. \nCode2: public void elimina(Pedido pe) throws errorSQL, errorConexionBD { System.out.println(\"GestorPedido.elimina()\"); int id = pe.getId(); String sql; Statement stmt = null; try { gd.begin(); sql = \"DELETE FROM pedido WHERE id=\" + id; System.out.println(\"Ejecutando: \" + sql); stmt = gd.getConexion().createStatement(); stmt.executeUpdate(sql); System.out.println(\"executeUpdate\"); gd.commit(); System.out.println(\"commit\"); stmt.close(); } catch (SQLException e) { gd.rollback(); throw new errorSQL(e.toString()); } catch (errorConexionBD e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } catch (errorSQL e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void actionPerformed(ActionEvent e) { if (\"register\".equals(e.getActionCommand())) { buttonClicked = \"register\"; try { String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\"); URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\"); URLConnection conn = url.openConnection(); conn.setDoInput(true); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = rd.readLine()) != null) { } rd.close(); wr.close(); } catch (Exception ex) { } setVisible(false); } else if (\"cancel\".equals(e.getActionCommand())) { buttonClicked = \"cancel\"; setVisible(false); } else if (\"never\".equals(e.getActionCommand())) { buttonClicked = \"never\"; setVisible(false); } }. \nCode2: public boolean update(String dbName, Query[] queries) throws ServiceException { Connection con = null; PreparedStatement pstmt = null; int rows = 0; try { con = getDbConnection().getConnection(dbName); con.setAutoCommit(false); for (int i = 0; i < queries.length; i++) { Query query = queries[i]; System.out.println(query.getSql()); pstmt = con.prepareStatement(query.getSql()); addParametersToQuery(query, pstmt); rows += pstmt.executeUpdate(); } con.commit(); return rows > 0; } catch (DbException e) { log.error(\"[DAOService::update] \" + e.getMessage(), e); log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e); try { con.rollback(); } catch (SQLException e1) { log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e); throw new ServiceException(e.getMessage()); } throw new ServiceException(e.getMessage()); } catch (SQLException e) { log.error(\"[DAOService::update] \" + e.getMessage(), e); try { con.", "ground_truth": "NO", "predict": "rollback(); } catch (SQLException e1) { log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e); throw new ServiceException(e.getMessage()); } throw new ServiceException(e.getMessage()); } catch (ServiceException e) { log.error(\"[DAOService::update] \" + e.getMessage(), e); throw e; } finally { if (pstmt != null) { pstmt.close(); } if (con != null) { con.close(); } } return false; }. \nCode2: public void addParametersToQuery(Query query, PreparedStatement pstmt) { for (int i = 0; i < query.getParameters().length; i++) { Parameter param = query.getParameters()[i]; pstmt.setObject(i + 1, param.getValue(), param.getType()); } }. \nCode2"}, {"ID": 395, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null && stableBuild != null) { doVersionCheck(view, stableBuild, develBuild); } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \nCode2: public void loadScripts() { org.apache.batik.script.Window window = null; NodeList scripts = document.getElementsByTagNameNS(SVGConstants.SVG_NAMESPACE_URI, SVGConstants.SVG_SCRIPT_TAG); int len = scripts.getLength(); if (len == 0) { return; } for (int i = 0; i < len; i++) { Element script = (Element) scripts.item(i); String type = script.getAttributeNS(null, SVGConstants.SVG_TYPE_ATTRIBUTE); if (type.length() == 0) { type = SVGConstants.SVG_SCRIPT_TYPE_DEFAULT_VALUE; } if (type.equals(SVGConstants.SVG_SCRIPT_TYPE_JAVA)) { try { String href = XLinkSupport.getXLinkHref(script); ParsedURL purl = new ParsedURL(XMLBaseSupport.getCascadedXMLBase(script), href); checkCompatibleScriptURL(type, purl); DocumentJarClassLoader cll; URL docURL = null; try { docURL = new URL(docPURL.toString()); } catch (MalformedURLException mue) { } cll = new DocumentJarClassLoader(new URL(purl.toString()), docURL); URL url = cll.findResource(\"META-INF/MANIFEST.MF\"); if (url == null) { continue; } Manifest man = new Manifest(url.openStream()); String sh; sh = man.getMainAttributes().getValue(\"Script-Handler\"); if (sh != null) { ScriptHandler h; h = (ScriptHandler) cll.loadClass(sh).newInstance(); if (window == null) { window = createWindow(); } h.run(document, window); } sh = man.getMainAttributes().getValue(\"SVG-Handler-Class\"); if (sh != null) { EventListenerInitializer initializer; initializer = (EventListenerInitializer) cll.loadClass(sh).newInstance(); if (window == null) { window = createWindow(); } initializer.initializeEventListeners((SVGDocument) document); } } catch (Exception e) { if (userAgent != null) { userAgent.displayError(e); } } continue; } Interpreter interpreter = getInterpreter(type); if (interpreter == null) continue; try { String href = XLinkSupport.getXLinkHref(script); String desc = null; Reader reader; if (href.length() > 0) { desc = href; ParsedURL purl = new ParsedURL(XMLBaseSupport.getCascadedXMLBase(script), href); checkCompatibleScriptURL(type, purl); reader = new InputStreamReader(purl.openStream()); } else { checkCompatibleScriptURL(type, docPURL); DocumentLoader dl = bridgeContext.getDocumentLoader(); Element e = script; SVGDocument d = (SVGDocument) e.getOwnerDocument(); int line = dl.getLineNumber(script); desc = Messages.formatMessage(INLINE_SCRIPT_DESCRIPTION, new Object[] { d.getURL(), \"<\" + script.getNodeName() + \">\", new Integer(line) }); Node n = script.getFirstChild(); if (n != null) { StringBuffer sb = new StringBuffer(); while (n != null) { if (n.getNodeType() == Node.CDATA_SECTION_NODE || n.getNodeType() == Node.TEXT_NODE) sb.append(n.getNodeValue()); n = n.getNextSibling(); } reader = new StringReader(sb.toString()); } else { continue; } } interpreter.evaluate(reader, desc); } catch (IOException e) { if (userAgent != null) { userAgent.displayError(e); } return; } catch (InterpreterException e) { System.err.println(\"InterpExcept: \" + e); handleInterpreterException(e); return; } catch (SecurityException e) { if (userAgent != null) { userAgent.displayError(e); } } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException { URL url = new URL(app.getUrl() + request.getRequestURI()); s_log.debug(\"Redirecting to \" + url); URLConnection urlConnection = url.openConnection(); Map<String, List<String>> fields = urlConnection.getHeaderFields(); for (String key : fields.keySet()) { StringBuffer values = new StringBuffer(); boolean comma = false; for (String value : fields.get(key)) { if (comma) { values.append(\", \"); } values.append(value); comma = true; } if (key != null) { response.setHeader(key, values.toString()); } else { response.setStatus(Integer.parseInt(values.toString().split(\" \")[1])); } } InputStream in = urlConnection.getInputStream(); try { ServletOutputStream out = response.getOutputStream(); byte[] buff = new byte[1024]; int len; while ((len = in.read(buff)) != -1) { out.write(buff, 0, len); } } finally { in.close(); } }. \nCode2: public boolean update(String dbName, Query[] queries) throws ServiceException { Connection con = null; PreparedStatement pstmt = null; int rows = 0; try { con = getDbConnection().getConnection(dbName); con.setAutoCommit(false); for (int i = 0; i < queries.length; i++) { Query query = queries[i]; System.out.println(query.getSql()); pstmt = con.prepareStatement(query.getSql()); addParametersToQuery(query, pstmt); rows += pstmt.executeUpdate(); } con.commit(); return rows > 0; } catch (DbException e) { log.error(\"[DAOService::update] \" + e.getMessage(), e); log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e); try { con.rollback(); } catch (SQLException e1) { log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e); throw new ServiceException(e.getMessage()); } throw new ServiceException(e.get", "ground_truth": "NO", "predict": "Message()); } catch (Exception e) { log.error(\"[DAOService::update] Errore durante l'update \" + e.getMessage(), e); throw new ServiceException(e.getMessage()); } finally { if (con != null) { con.close(); } } return false; }. \n\npublic boolean update(String dbName, String sql) throws ServiceException { Connection con = null; PreparedStatement pstmt = null; int rows = 0; try { con = getDbConnection().getConnection(dbName); con.setAutoCommit(false); pstmt = con.prepareStatement(sql); addParametersToQuery(null, pstmt); rows += pstmt.executeUpdate(); con.commit(); return rows > 0; } catch (DbException e) { log.error(\"[DAOService::update] \" + e.getMessage(), e); log.error(\"[DAOService::update] Execute rollback \""}, {"ID": 428, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private int mergeFiles(Merge merge) throws MojoExecutionException { String encoding = DEFAULT_ENCODING; if (merge.getEncoding()!= null && merge.getEncoding().length() > 0) { encoding = merge.getEncoding(); } int numMergedFiles = 0; Writer ostream = null; FileOutputStream fos = null; try { fos = new FileOutputStream(merge.getTargetFile(), true); ostream = new OutputStreamWriter(fos, encoding); BufferedWriter output = new BufferedWriter(ostream); for (String orderingName : this.orderingNames) { List<File> files = this.orderedFiles.get(orderingName); if (files!= null) { getLog().info(\"Appending: \" + files.size() + \" files that matched the name: \" + orderingName + \" to the target file: \" + merge.getTargetFile().getAbsolutePath() + \"...\"); for (File file : files) { String fileName = file.getName(); getLog().info(\"Appending file: \" + fileName + \" to the target file: \" + merge.getTargetFile().getAbsolutePath() + \"...\"); InputStream input = null; try { input = new FileInputStream(file); if (merge.getSeparator()!= null && merge.getSeparator().trim().length() > 0) { String replaced = merge.getSeparator().trim(); replaced = replaced.replace(\"\\n\", \"\"); replaced = replaced.replace(\"\\t\", \"\"); replaced = replaced.replace(\"#{file.name}\", fileName); replaced = replaced.replace(\"#{parent.name}\", file.getParentFile()!= null? file.getParentFile().getName() : \"\"); replaced = replaced.replace(\"\\\\n\", \"\\n\"); replaced = replaced.replace(\"\\\\t\", \"\\t\"); getLog().debug(\"Appending separator: \" + replaced); IOUtils.copy(new StringReader(replaced), output); } IOUtils.copy(input, output, encoding); } catch (IOException ioe) { throw new MojoExecutionException(\"Failed to append file: \" + fileName + \" to output file\", ioe);. \nCode2: public ValidationReport validate(OriginalDeployUnitDescription unit) throws UnitValidationException { ValidationReport vr = new DefaultValidationReport(); errorHandler = new SimpleErrorHandler(vr); vr.setFileUri(unit.getAbsolutePath()); SAXParser parser; SAXReader reader = null; try { parser = factory.newSAXParser(); reader = new SAXReader(parser.getXMLReader()); reader.setValidation(false); reader.setErrorHandler(this.errorHandler); } catch (ParserConfigurationException e) { throw new UnitValidationException(\"The configuration of parser is illegal.\", e); } catch (SAXException e) { String m = \"Something is wrong when register schema\"; logger.error(m, e); throw new UnitValidationException(m, e); } ZipInputStream zipInputStream; InputStream tempInput = null; try { tempInput = new FileInputStream(unit.getAbsolutePath()); } catch (FileNotFoundException e1) { String m = String.format(\"The file [%s] don't exist.\", unit.getAbsolutePath()); logger.error(m, e1); throw new UnitValidationException(m, e1); } zipInputStream = new ZipInputStream(tempInput); ZipEntry zipEntry = null; try { zipEntry = zipInputStream.getNextEntry(); if (zipEntry == null) { String m = String.format(\"Error when get zipEntry. Maybe the [%s] is not zip file!\", unit.getAbsolutePath()); logger.error(m); throw new UnitValidationException(m); } while (zipEntry!= null) { if (configFiles.contains(zipEntry.getName())) { byte[] extra = new byte[(int) zipEntry.getSize()]; zipInputStream.read(extra); File file = File.createTempFile(\"temp\", \"extra\"); file.deleteOnExit(); logger.info(\"[TempFile:]\" + file.getAbsoluteFile()); ByteArrayInputStream byteInputStream = new ByteArrayInputStream(extra); FileOutputStream tempFileOutputStream = new FileOutputStream(file); IOUtils.copy(byteInputStream, tempFileOutputStream); tempFileOutputStream.flush(); IOUtils.closeQuietly. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void loadDDL() throws IOException { try { conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close(); } catch (SQLException e) { Statement stmt = null; if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) { LOG.fatal(SQL_ERROR, e); throw new IOException(\"Error on initial data store read\", e); } String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" }; try { conn.setAutoCommit(false); stmt = conn.createStatement(); for (String q : qry) stmt.executeUpdate(q); conn.commit(); } catch (SQLException e2) { try { conn.rollback(); } catch (SQLException e3) { LOG.fatal(SQL_ERROR, e3); } LOG.fatal(SQL_ERROR, e2); throw new IOException(\"Error initializing data store\", e2); } finally { if (stmt!= null) { try { stmt.close(); } catch (SQLException e4) { LOG.fatal(SQL_ERROR, e4); throw new IOException(\"Unable to cleanup data store resources\", e4); } } try { conn.setAutoCommit(true); } catch (SQLException e3) { LOG.fatal(SQL_ERROR, e3); throw new IOException(\"Unable to reset data store auto commit\", e3); } } } return; }. \nCode2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer", "ground_truth": "NO", "predict": "(); for (int i = 0; i < array.length; i++) { sb.append(Integer.toHexString(array[i])); } value = sb.toString(); } catch (Exception e) { System.out.println(\"Error: \" + e); } }. \nCode2: public static String getGUID(boolean secure) { getRandomGUID(secure); return value; }. \nCode2: public static String getGUID(boolean secure, Random rand) { getRandomGUID(secure, rand); return value; }. \nCode2: public static String getGUID(boolean secure, Random rand, String s_id) { getRandomGUID(secure, rand, s_id); return value; }. \nCode2: public static String getGUID(boolean secure, Random rand, String s_id, long time, long rand) { getRandomGUID(secure, rand, s_id, time"}, {"ID": 435, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override protected String doInBackground(Location... params) { if (params == null || params.length == 0 || params[0] == null) { return null; } Location location = params[0]; String address = \"\"; String cachedAddress = DataService.GetInstance(mContext).getAddressFormLocationCache(location.getLatitude(), location.getLongitude()); if (!TextUtils.isEmpty(cachedAddress)) { address = cachedAddress; } else { StringBuilder jsonText = new StringBuilder(); HttpClient client = new DefaultHttpClient(); String url = String.format(GoogleMapAPITemplate, location.getLatitude(), location.getLongitude()); HttpGet httpGet = new HttpGet(url); try { HttpResponse response = client.execute(httpGet); StatusLine statusLine = response.getStatusLine(); int statusCode = statusLine.getStatusCode(); if (statusCode == 200) { HttpEntity entity = response.getEntity(); InputStream content = entity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(content)); String line; while ((line = reader.readLine()) != null) { jsonText.append(line); } JSONObject result = new JSONObject(jsonText.toString()); String status = result.getString(GoogleMapStatusSchema.status); if (GoogleMapStatusCodes.OK.equals(status)) { JSONArray addresses = result.getJSONArray(GoogleMapStatusSchema.results); if (addresses.length() > 0) { address = addresses.getJSONObject(0).getString(GoogleMapStatusSchema.formatted_address); if (!TextUtils.isEmpty(currentBestLocationAddress)) { DataService.GetInstance(mContext).updateAddressToLocationCache(location.getLatitude(), location.getLongitude(), currentBestLocationAddress); } } } } else { Log.e(\"Error\", \"Failed to get address via google map API.\"); } } catch (ClientProtocolException e) { e.printStackTrace(); Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } catch (IOException e) { Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } catch (JSONException e) { Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } } return address; }. \nCode2: private void handleNodeUp(long eventID, long nodeID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1) { log.warn(EventConstants.NODE_UP_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid: \" + eventID + \"/\" + nodeID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); int count = 0; if (openOutageExists(dbConn, nodeID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGES_FOR_NODE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); count = outageUpdater.executeUpdate(); outageUpdater.close(); } else { log.warn(\"\\'\" + EventConstants.NODE_UP_EVENT_UEI + \"\\' for \" + nodeID + \" no open record.\"); } try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeUp closed \" + count + \" outages for nodeid \" + nodeID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeUp could not be recorded for nodeId: \" + nodeID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public FileChooserTestFrame() throws HeadlessException, MalformedURLException { super(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent aEvent) { System.exit(0); } }); Dimension dim = getToolkit().getScreenSize(); Rectangle abounds = getBounds(); setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2); setVisible(true); URL url = new URL(\"ftp://cendantstp/\"); char[] password = \"spnr\".toCharArray(); PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password); FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication); JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setMultiSelectionEnabled(true); File[] selectedFiles = null; if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) { selectedFiles = fileChooser.getSelectedFiles(); for (int i = 0; i < selectedFiles.length; i++) { if (selectedFiles[i] instanceof FTPFileFile) { FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i]; logger.fine(ftpFile.getName()); logger.fine(ftpFile.getPath()); } else { logger.fine(selectedFiles[i].toString()); logger.fine(selectedFiles[i].getAbsolutePath()); } } } remoteFileSystemView.disconnect(); try { if (null != selectedFiles) { FTPClient ftpClient = new FTPClient(); InetAddress inetAddress = InetAddress.getByName(url.getHost()); ftpClient.connect(inetAddress); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) { throw new FTPBrowseException(ftpClient.getReplyString()); } if (null != passwordAuthentication) { ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString()); } for (int i = 0; i < selectedFiles.length; i++) { FTPFileFile file = (FTPFileFile) selectedFiles[i]; logger.fine(file.getPath()); FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\")); logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos)); fos.close(); } } } catch (UnknownHostException e) { e.printStackTrace(); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e", "ground_truth": "NO", "predict": ") { e.printStackTrace(); } catch (FTPException e) { e.printStackTrace(); } catch (FTPBrowseException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } }. \nCode2:public class FileChooserTestFrame extends JFrame { \n     public static void main(String[] args) { \n         JFrame frame = new FileChooserTestFrame(); \n         frame.setVisible(true); \n     } \n     public JPanel getContentPane() { \n         JPanel contentPane = new JPanel(); \n         contentPane.setLayout(new FlowLayout()); \n         contentPane.add(new JLabel(\"This is the content of the frame.\")); \n         return contentPane; \n     }\n}"}, {"ID": 457, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String[] args) { boolean rotateLeft = false; boolean rotateRight = false; boolean exclude = false; boolean reset = false; float quality = 0f; int thumbArea = 12000; for (int i = 0; i < args.length; i++) { if (args[i].equals(\"-rotl\")) rotateLeft = true; else if (args[i].equals(\"-rotr\")) rotateRight = true; else if (args[i].equals(\"-exclude\")) exclude = true; else if (args[i].equals(\"-reset\")) reset = true; else if (args[i].equals(\"-quality\")) quality = Float.parseFloat(args[++i]); else if (args[i].equals(\"-area\")) thumbArea = Integer.parseInt(args[++i]); else { File f = new File(args[i]); try { Tools t = new Tools(f); if (exclude) { URL url = t.getClass().getResource(\"exclude.jpg\"); InputStream is = url.openStream(); File dest = t.getExcludeFile(); OutputStream os = new FileOutputStream(dest); byte[] buf = new byte[1024]; int len; while ((len = is.read(buf)) > 0) os.write(buf, 0, len); os.close(); is.close(); t.getOutFile().delete(); t.getThumbFile().delete(); System.exit(0); } if (reset) { t.getOutFile().delete(); t.getThumbFile().delete(); t.getExcludeFile().delete(); System.exit(0); } if (quality > 0) t.setQuality(quality); if (t.getType() == Tools.THUMB || t.getType() == Tools.EXCLUDE) t.load(t.getBaseFile()); else t.load(t.getSourceFile()); File out = t.getOutFile(); if (rotateLeft) t.rotateLeft(); else if (rotateRight) t.rotateRight(); t.save(out); t.getExcludeFile().delete(); t.getThumbFile().delete(); System.exit(0); } catch (Throwable e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, \"The operation could not be performed\", \"JPhotoAlbum\", JOptionPane.ERROR_MESSAGE); System.exit(1); } } } }. \nCode2: public static final String crypt(final String password, String salt, final String magic) { if (password == null) throw new IllegalArgumentException(\"Null password!\"); if (salt == null) throw new IllegalArgumentException(\"Null salt!\"); if (magic == null) throw new IllegalArgumentException(\"Null salt!\"); byte finalState[]; long l; MessageDigest ctx, ctx1; try { ctx = MessageDigest.getInstance(\"md5\"); ctx1 = MessageDigest.getInstance(\"md5\"); } catch (final NoSuchAlgorithmException ex) { System.err.println(ex); return null; } if (salt.startsWith(magic)) { salt = salt.substring(magic.length()); } if (salt.indexOf('$') != -1) { salt = salt.substring(0, salt.indexOf('$')); } if (salt.length() > 8) { salt = salt.substring(0, 8); } ctx.update(password.getBytes()); ctx.update(magic.getBytes()); ctx.update(salt.getBytes()); ctx1.update(password.getBytes()); ctx1.update(salt.getBytes()); ctx1.update(password.getBytes()); finalState = ctx1.digest(); for (int pl = password.length(); pl > 0; pl -= 16) { ctx.update(finalState, 0, pl > 16 ? 16 : pl); } clearbits(finalState); for (int i = password.length(); i != 0; i >>>= 1) { if ((i & 1) != 0) { ctx.update(finalState, 0, 1); } else { ctx.update(password.getBytes(), 0, 1); } } finalState = ctx.digest(); for (int i = 0; i < 1000; i++) { try { ctx1 = MessageDigest.getInstance(\"md5\"); } catch (final NoSuchAlgorithmException e0) { return null; } if ((i & 1) != 0) { ctx1.update(password.getBytes()); } else { ctx1.update(finalState, 0, 16); } if ((i % 3) != 0) { ctx1.update(salt.getBytes()); } if ((i % 7) != 0) { ctx1.update(password.getBytes()); } if ((i & 1) != 0) { ctx1.update(finalState, 0, 16); } else { ctx1.update(password.getBytes()); } finalState = ctx1.digest(); } final StringBuffer result = new StringBuffer(); result.append(magic); result.append(salt); result.append(\"$\"); l = (bytes2u(finalState[0]) << 16) | (bytes2u(finalState[6]) << 8) | bytes2u(finalState[12]); result.append(to64(l, 4)); l = (bytes2u(finalState[1]) << 16) | (bytes2u(finalState[7]) << 8) | bytes2u(finalState[13]); result.append(to64(l, 4)); l = (bytes2u(finalState[2]) << 16) | (bytes2u(finalState[8]) << 8) | bytes2u(finalState[14]); result.append(to64(l, 4)); l = (bytes2u(finalState[3]) << 16) | (bytes2u(finalState[9]) << 8) | bytes2u(finalState[15]); result.append(to64(l, 4)); l = (bytes2u(finalState[4]) << 16) | (bytes2u(finalState[10]) << 8) | bytes2u(finalState[5]); result.append(to64(l, 4)); l = bytes2u(finalState[11]); result.append(to64(l, 2)); clearbits(finalState); return result.toString(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String generateStackHashKey() { Exception e = null; try { throw new Exception(); } catch (Exception ex) { e = ex; } MessageDigest digest; try { digest = java.security.MessageDigest.getInstance(\"MD5\"); digest.update(getStackTrace(e).getBytes()); byte[] hash = digest.digest(); String rtn = Base64.encode(new String(hash)); if (keys.contains(rtn)) { return generatedIterStackHashKey(rtn); } keys.add(rtn); return rtn; } catch (NoSuchAlgorithmException ex) { throw new RuntimeException(ex); } }. \nCode2: public void run(IAction action) { int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle(); Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE); GraphicalViewer viewer = new ScrollingGraphicalViewer(); viewer.createControl(shell); viewer.setEditDomain(new DefaultEditDomain(null)); viewer.setRootEdit", "ground_truth": "NO", "predict": "Part(new DefaultRootEditPart(viewer.getControl())); viewer.setSelection(new StructuredSelection(new Object[]{action.getSource()}, true)); viewer.getControl().addFocusListener(new FocusListener() { @Override public void focusGained(FocusEvent e) { action.run(); } @Override public void focusLost(FocusEvent e) { } }); shell.setVisible(true); }. \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 458, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \nCode2: private void trySend(Primitive p) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); try { mSerializer.serialize(p, out); } catch (SerializerException e) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.SERIALIZER_ERROR, \"Internal serializer error, primitive: \" + p.getType()); out.close(); return; } HttpPost req = new HttpPost(mPostUri); req.addHeader(mContentTypeHeader); if (mMsisdnHeader != null) { req.addHeader(mMsisdnHeader); } ByteArrayEntity entity = new ByteArrayEntity(out.toByteArray()); req.setEntity(entity); mLastActive = SystemClock.elapsedRealtime(); if (Log.isLoggable(ImpsLog.TAG, Log.DEBUG)) { long sendBytes = entity.getContentLength() + 176; ImpsLog.log(mConnection.getLoginUserName() + \" >> \" + p.getType() + \" HTTP payload approx. \" + sendBytes + \" bytes\"); } if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { ImpsLog.dumpRawPacket(out.toByteArray()); ImpsLog.dumpPrimitive(p); } HttpResponse res = mHttpClient.execute(req); StatusLine statusLine = res.getStatusLine(); HttpEntity resEntity = res.getEntity(); InputStream in = resEntity.getContent(); if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { Log.d(ImpsLog.PACKET_TAG, statusLine.toString()); Header[] headers = res.getAllHeaders(); for (Header h : headers) { Log.d(ImpsLog.PACKET_TAG, h.toString()); } int len = (int) resEntity.getContentLength(); if (len > 0) { byte[] content = new byte[len]; int offset = 0; int bytesRead = 0; do { bytesRead = in.read(content, offset, len); offset += bytesRead; len -= bytesRead; } while (bytesRead > 0); in.close(); ImpsLog.dumpRawPacket(content); in = new ByteArrayInputStream(content); } } try { if (statusLine.getStatusCode() != HttpURLConnection.HTTP_OK) { mTxManager.notifyErrorResponse(p.getTransactionID(), statusLine.getStatusCode(), statusLine.getReasonPhrase()); return; } if (resEntity.getContentLength() == 0) { if ((p.getTransactionMode() != TransactionMode.Response) && !p.getType().equals(ImpsTags.Polling_Request)) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.ILLEGAL_SERVER_RESPONSE, \"bad response from server\"); } return; } Primitive response = mParser.parse(in); if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { ImpsLog.dumpPrimitive(response); } if (Log.isLoggable(ImpsLog.TAG, Log.DEBUG)) { long len = 2 + resEntity.getContentLength() + statusLine.toString().length() + 2; Header[] headers = res.getAllHeaders(); for (Header header : headers) { len += header.getName().length() + header.getValue().length() + 4; } ImpsLog.log(mConnection.getLoginUserName() + \" << \" + response.getType() + \" HTTP payload approx. \" + len + \"bytes\"); } if (!mReceiveQueue.offer(response)) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.UNKNOWN_ERROR, \"receiving queue full\"); } } catch (ParserException e) { ImpsLog.logError(e); mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.PARSER_ERROR, \"Parser error, received a bad response from server\"); } finally { resEntity.consumeContent(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static byte[] getJarEntry(String jarName, String entry, int port) { byte[] b = null; try { String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName()); String protocol = \"http://\"; int x = codebase.indexOf(protocol) + protocol.length(); String s2 = codebase.substring(x); int x2 = s2.indexOf('/'); String downloadHost = s2.substring(0, x2); if (downloadHost.indexOf(':') == -1) { downloadHost += \":\" + port; } URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry); JarURLConnection jurl = (JarURLConnection) url.openConnection(); JarEntry je = jurl.getJarEntry(); InputStream is = jurl.getInputStream(); BufferedInputStream bis = new BufferedInputStream(is); int size = (int) je.getSize(); b = new byte[size]; int rb = 0; int chunk = 0; while ((size - rb) > 0) { chunk = bis.read(b, rb, size - rb); if (chunk == -1) { break; } rb += chunk; } bis.close(); is.close(); bis = null; is = null; url = null; jurl = null; } catch (UnknownHostException e) { e.printStackTrace(); return null; } catch (IOException e) { e.printStackTrace(); return null; } return b; }. \nCode2: public static void main(String[] args) throws Exception { FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes())); fc.close(); fc = new FileInputStream(\"data2.txt\").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); buff.rewind(); String encoding = System.getProperty(\"file.encoding\"); System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff)); fc = new FileOutputStream(\"data2.txt\").getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\"))); fc.close(); fc = new FileInputStream(\"data2.txt\").getChannel(); buff.clear(); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); fc = new FileOutputStream(\"data2.txt\").getChannel(); buff = ByteBuffer.allocate(24); buff.asCharBuffer().put(\"Some text\"); fc.write(buff); fc.close(); fc = new FileInput", "ground_truth": "NO", "predict": "Stream(\"data2.txt\").getChannel(); buff.clear(); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); }. \n\n// Output: Some text!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 462, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public DialogSongList(JFrame frame) { super(frame, \"Menu_SongList\", \"songList\"); setMinimumSize(new Dimension(400, 200)); JPanel panel, spanel; Container contentPane; (contentPane = getContentPane()).add(songSelector = new SongSelector(configKey, null, true)); songSelector.setSelectionAction(new Runnable() { public void run() { final Item<URL, MidiFileInfo> item = songSelector.getSelectedInfo(); if (item != null) { try { selection = new File(item.getKey().toURI()); author.setEnabled(true); title.setEnabled(true); difficulty.setEnabled(true); save.setEnabled(true); final MidiFileInfo info = item.getValue(); author.setText(info.getAuthor()); title.setText(info.getTitle()); Util.selectKey(difficulty, info.getDifficulty()); return; } catch (Exception e) { } } selection = null; author.setEnabled(false); title.setEnabled(false); difficulty.setEnabled(false); save.setEnabled(false); } }); contentPane.add(panel = new JPanel(), BorderLayout.SOUTH); panel.setLayout(new BorderLayout()); JScrollPane scrollPane; panel.add(scrollPane = new JScrollPane(spanel = new JPanel()), BorderLayout.NORTH); scrollPane.setPreferredSize(new Dimension(0, 60)); Util.addLabeledComponent(spanel, \"Lbl_Author\", author = new JTextField(10)); Util.addLabeledComponent(spanel, \"Lbl_Title\", title = new JTextField(14)); Util.addLabeledComponent(spanel, \"Lbl_Difficulty\", difficulty = new JComboBox()); difficulty.addItem(new Item<Byte, String>((byte) -1, \"\")); for (Map.Entry<Byte, String> entry : SongSelector.DIFFICULTIES.entrySet()) { final String value = entry.getValue(); difficulty.addItem(new Item<Byte, String>(entry.getKey(), Util.getMsg(value, value), value)); } spanel.add(save = new JButton()); Util.updateButtonText(save, \"Save\"); save.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { final File selected = MidiSong.setMidiFileInfo(selection, author.getText(), title.getText(), getAsByte(difficulty)); SongSelector.refresh(); try { songSelector.setSelected(selected == null ? null : selected.toURI().toURL()); } catch (MalformedURLException ex) { } } }); author.setEnabled(false); title.setEnabled(false); difficulty.setEnabled(false); save.setEnabled(false); JButton button; panel.add(spanel = new JPanel(), BorderLayout.WEST); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Import\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { final File inputFile = KeyboardHero.midiFile(); try { if (inputFile == null) return; final File dir = (new File(Util.DATA_FOLDER + MidiSong.MIDI_FILES_DIR)); if (dir.exists()) { if (!dir.isDirectory()) { Util.error(Util.getMsg(\"Err_MidiFilesDirNotDirectory\"), dir.getParent()); return; } } else if (!dir.mkdirs()) { Util.error(Util.getMsg(\"Err_CouldntMkDir\"), dir.getParent()); return; } File outputFile = new File(dir.getPath() + File.separator + inputFile.getName()); if (!outputFile.exists() || KeyboardHero.confirm(\"Que_FileExistsOverwrite\")) { final FileChannel inChannel = new FileInputStream(inputFile).getChannel(); inChannel.transferTo(0, inChannel.size(), new FileOutputStream(outputFile).getChannel()); } } catch (Exception ex) { Util.getMsg(Util.getMsg(\"Err_CouldntImportSong\"), ex.toString()); } SongSelector.refresh(); } }); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Delete\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if (KeyboardHero.confirm(Util.getMsg(\"Que_SureToDelete\"))) { try { new File(songSelector.getSelectedFile().toURI()).delete(); } catch (Exception ex) { Util.error(Util.getMsg(\"Err_CouldntDeleteFile\"), ex.toString()); } SongSelector.refresh(); } } }); panel.add(spanel = new JPanel(), BorderLayout.CENTER); spanel.setLayout(new FlowLayout()); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Close\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { close(); } }); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Play\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Game.newGame(songSelector.getSelectedFile()); close(); } }); panel.add(spanel = new JPanel(), BorderLayout.EAST); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Refresh\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SongSelector.refresh(); } }); getRootPane().setDefaultButton(button); instance = this; }. \nCode2: public static Element retrieveFromCache(String cacheName, Object key) { URL url = null; HttpURLConnection connection = null; InputStream is = null; OutputStream os = null; int result = 0; StringBuilder sb = null; Element cacheElement = null; try { url = new URL(EHCACHE_SERVER_BASE + \"/\" + cacheName + \"/\" + key); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.connect(); is = connection.getInputStream(); byte[] response = new byte[4096]; result = is.read(response); while (result != -1) { sb.append(response); result = is.read(response); } if (is != null) { try { is.close(); } catch (Exception ignore) { } } if (connection != null) { connection.disconnect(); } cacheElement = new Element(key, sb.toString()); } catch (Exception e) { e.printStackTrace(); } finally { if (os != null) { try { os.close(); } catch (Exception ignore) { } } if (is != null) { try { is.close(); } catch (Exception ignore) { } } if (connection != null) { connection.disconnect(); } } return cacheElement; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static boolean existsURL(String urlStr) { try { URL url = ProxyURLFactory.createHttpUrl(urlStr); HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.connect(); int responseCode = con.getResponseCode(); con.disconnect(); return !(responseCode == H", "ground_truth": "NO", "predict": "ttpResponseCodes.NOT_FOUND); } catch (Exception ex) { return false; } }. \n\nCode2:public static boolean existsURL(String urlStr) { try { URL url = new URL(urlStr); HttpURLConnection con = (HttpURLConnection) url.openConnection(); con.connect(); int responseCode = con.getResponseCode(); con.disconnect(); return !(responseCode == HttpResponseCodes.NOT_FOUND); } catch (Exception ex) { return false; } }. \n\n// Result: YES."}, {"ID": 486, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected void download(URL url, File destination, long beginRange, long endRange, long totalFileSize, boolean appendToFile) throws DownloadException { System.out.println(\" DOWNLOAD REQUEST RECEIVED \" + url.toString() + \" \\n\\tbeginRange : \" + beginRange + \" - EndRange \" + endRange + \" \\n\\t to -> \" + destination.getAbsolutePath()); try { if (destination.exists() && !appendToFile) { destination.delete(); } if (!destination.exists()) destination.createNewFile(); GetMethod get = new GetMethod(url.toString()); HttpClient httpClient = new HttpClient(); Header rangeHeader = new Header(); rangeHeader.setName(\"Range\"); rangeHeader.setValue(\"bytes=\" + beginRange + \"-\" + endRange); get.setRequestHeader(rangeHeader); httpClient.executeMethod(get); int statusCode = get.getStatusCode(); if (statusCode >= 400 && statusCode < 500) throw new DownloadException(\"The file does not exist in this location : message from server -> \" + statusCode + \" \" + get.getStatusText()); InputStream input = get.getResponseBodyAsStream(); OutputStream output = new FileOutputStream(destination, appendToFile); try { int length = IOUtils.copy(input, output); System.out.println(\" Length : \" + length); } finally { input.close(); output.flush(); output.close(); } } catch (Exception e) { e.printStackTrace(); logger.error(\"Unable to figure out the length of the file from the URL : \" + e.getMessage()); throw new DownloadException(\"Unable to figure out the length of the file from the URL : \" + e.getMessage()); } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String postRequest(String urlString, HashMap data) { String returnData = \"\"; try { URL url = new URL(urlString); URLConnection connection = url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); PrintWriter out = new PrintWriter(connection.getOutputStream()); Object[] keySet = data.keySet().toArray(); Object[] values = data.values().toArray(); for (int count = 0; count < keySet.length; count++) { out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count])); if ((count + 1) < keySet.length) out.print(\"&\"); } out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) { returnData += inputLine; } in.close(); } catch (Exception e) { e.printStackTrace(); returnData = null; } return (returnData); }. \nCode2: public static boolean loadContentFromURL(String fromURL, String toFile) { try { URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL); File file = new File(toFile); URLConnection ucon = url.openConnection(); InputStream is = ucon.getInputStream(); BufferedInputStream bis = new BufferedInputStream(is); ByteArrayBuffer baf = new ByteArrayBuffer(50); int current = 0; while ((current = bis.read()) != -1) { baf.append((byte) current); } File", "ground_truth": "NO", "predict": "OutputStream fos = new FileOutputStream(file); fos.write(baf.toByteArray()); fos.close(); } catch (Exception e) { e.printStackTrace(); return false; } return true; }. \n// Result: YES."}, {"ID": 487, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: final void saveProject(Project project, final File file) { if (projectsList.contains(project)) { if (project.isDirty() ||!file.getParentFile().equals(workspaceDirectory)) { try { if (!file.exists()) { if (!file.createNewFile()) throw new IOException(\"cannot create file \" + file.getAbsolutePath()); } File tmpFile = File.createTempFile(\"JFPSM\", \".tmp\"); ZipOutputStream zoStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file))); zoStream.setMethod(ZipOutputStream.DEFLATED); ZipEntry projectXMLEntry = new ZipEntry(\"project.xml\"); projectXMLEntry.setMethod(ZipEntry.DEFLATED); zoStream.putNextEntry(projectXMLEntry); CustomXMLEncoder encoder = new CustomXMLEncoder(new BufferedOutputStream(new FileOutputStream(tmpFile))); encoder.writeObject(project); encoder.close(); int bytesIn; byte[] readBuffer = new byte[1024]; FileInputStream fis = new FileInputStream(tmpFile); while ((bytesIn = fis.read(readBuffer))!= -1) zoStream.write(readBuffer, 0, bytesIn); fis.close(); ZipEntry entry; String floorDirectory; for (FloorSet floorSet : project.getLevelSet().getFloorSetsList()) for (Floor floor : floorSet.getFloorsList()) { floorDirectory = \"levelset/\" + floorSet.getName() + \"/\" + floor.getName() + \"/\"; for (MapType type : MapType.values()) { entry = new ZipEntry(floorDirectory + type.getFilename()); entry.setMethod(ZipEntry.DEFLATED); zoStream.putNextEntry(entry); ImageIO.write(floor.getMap(type).getImage(), \"png\", zoStream); } } final String tileDirectory = \"tileset/\"; for (Tile tile : project.getTileSet().getTilesList()) for (int textureIndex = 0; textureIndex < tile.getMaxTextureCount(); textureIndex++) if (tile.getTexture(textureIndex)!= null) { entry = new ZipEntry. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format!= FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen!= (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override protected String doInBackground(Void... params) { HttpClient httpClient = new DefaultHttpClient(); HttpContext localContext = new BasicHttpContext(); HttpPost httpPost = new HttpPost(urlFormated); try { MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE); for (int index = 0; index < POSTparamList.size(); index++) { if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) { entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue()))); } else { entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue())); } } httpPost.setEntity(entity); HttpResponse response = httpClient.execute(httpPost, localContext); return processAnswer(response); } catch (IOException e) { e.printStackTrace(); } return null; }. \nCode2: public ByteBuffer[] write(ByteBuffer[] byteBuffers) { if (!m_sslInitiated) { return m_writer.write(byteBuffers); } if (m_engine.getHandshakeStatus()!= SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) { if (!NIOUtils.isEmpty(byteBuffers)) { m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers)); byteBuffers = new ByteBuffer[0]; } ByteBuffer buffer = SSL_BUFFER.get(); ByteBuffer[] buffers = null; try { SSLEngineResult result = null; while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) { buffer.clear(); result = m_engine.wrap(byteBuffers, buffer); buffer.flip(); buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer)); } if (result == null) return null; if (result.getStatus()!= SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus()); reactToHandshakeStatus(result.getHandshakeStatus()); } catch (SSLException e) { throw new RuntimeException(e); } return buffers; } ByteBuffer buffer = SSL_BUFFER.get(); buffer.clear(); if (NIOUtils.isEmpty(byteBuffers)) { if (m_initialOutBuffer == null) return null; } else { byteBuffers = m_writer.write(byteBuffers); } if (m_initialOutBuffer!= null) { byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers); m_initialOutBuffer = null; } ByteBuffer[] encrypted = null; while (!NIOUtils.isEmpty(byteBuffers)) { buffer.clear(); try { m_engine.wrap(byteBuff", "ground_truth": "NO", "predict": "ers, buffer); encrypted = NIOUtils.concat(encrypted, buffer); } catch (SSLException e) { throw new RuntimeException(e); } byteBuffers = new ByteBuffer[0]; } return encrypted; }. \n}!!!!"}, {"ID": 501, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getTextData() { if (tempFileWriter != null) { try { tempFileWriter.flush(); tempFileWriter.close(); FileReader in = new FileReader(tempFile); StringWriter out = new StringWriter(); int len; char[] buf = new char[BUFSIZ]; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); out.close(); in.close(); return out.toString(); } catch (IOException ioe) { Logger.instance().log(Logger.ERROR, LOGGER_PREFIX, \"XMLTextData.getTextData\", ioe); return \"\"; } } else if (textBuffer != null) return textBuffer.toString(); else return null; }. \nCode2: public static void copyFile(File srcFile, File desFile) throws IOException { AssertUtility.notNull(srcFile); AssertUtility.notNull(desFile); FileInputStream fis = new FileInputStream(srcFile); FileOutputStream fos = new FileOutputStream(desFile); try { FileChannel srcChannel = fis.getChannel(); FileChannel dstChannel = fos.getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } finally { fis.close(); fos.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Test public void test_validate_tag_getTopAlbums() { try { SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\"); File schemaLocation = new File(\"tes.xsd\"); Schema schema = factory.newSchema(schemaLocation); Validator validator = schema.newValidator(); URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\"); InputStream inputStream = url.openStream(); Source source = new StreamSource(inputStream); validator.validate(source); } catch (IOException ex) { Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex); assertFalse(\"File not found\", true); } catch (SAXException ex) { Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex); assertFalse(\"Schema did not validate\", true); } assertTrue(true); }. \nCode2: public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) { int intResult = 0; String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "NO", "predict": "true.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 502, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { ejb.bprocess.OAIPMH.AutoHarvesterSession ahSession = home.create(); java.util.Vector vector = new java.util.Vector(1, 1); Integer libraryId = new Integer(1); String xmlstr = \"\"; String str = \"\"; String arr[] = new String[2]; String[] subarr = new String[4]; String mdPrefix = \"\", mdPrefixValue = \"\"; String from = \"\", fromValue = \"\"; String until = \"\", untilValue = \"\"; String set = \"\", setValue = \"\"; String oai_pmhRequest = request.getParameter(\"verb\"); String oai_pmhQuery = request.getQueryString(); String urlStr = \"\"; urlStr = \"http://\" + request.getServerName() + \":\" + request.getServerPort() + \"/newgenlibctxt/HarvestServlet\"; String attribute = oai_pmhQuery; String arguments = attribute.substring(attribute.indexOf(\"?\") + 1); StringTokenizer st = new StringTokenizer(arguments, \"&\"); int i = 0; int j = 0; int z = 0; int count = 0; String type = \"\"; while (st.hasMoreTokens()) { arr[i] = st.nextToken(); StringTokenizer subst = new StringTokenizer(arr[i], \"=\"); while (subst.hasMoreTokens()) { subarr[j] = subst.nextToken(); j++; } i++; count++; } int mdfCount = 0, fromCount = 0, untilCount = 0, setCount = 0; ListRecords lr = new ListRecords(); for (int k = 0; k < j; k += 2) { if (subarr[k].equals(\"from\")) { from = \"from\"; fromCount++; fromValue = subarr[k + 1]; fromValue = lr.validateDate(fromValue); } else if (subarr[k].equals(\"until\")) { until = \"until\"; untilCount++; untilValue = subarr[k + 1]; untilValue = lr.validateDate(untilValue); } } if. \nCode2: private static void ftpTest() { FTPClient f = new FTPClient(); try { f.connect(\"oscomak.net\"); System.out.print(f.getReplyString()); f.setFileType(FTPClient.BINARY_FILE_TYPE); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } String password = JOptionPane.showInputDialog(\"Enter password\"); if (password == null || password.equals(\"\")) { System.out.println(\"No password\"); return; } try { f.login(\"oscomak_pointrel\", password); System.out.print(f.getReplyString()); } catch (IOException e) { e.printStackTrace(); } try { String workingDirectory = f.printWorkingDirectory(); System.out.println(\"Working directory: \" + workingDirectory); System.out.print(f.getReplyString()); } catch (IOException e1) { e1.printStackTrace(); } try { f.enterLocalPassiveMode(); System.out.print(f.getReplyString()); System.out.println(\"Trying to list files\"); String[] fileNames = f.listNames(); System.out.print(f.getReplyString()); System.out.println(\"Got file list fileNames: \" + fileNames.length); for (String fileName : fileNames) { System.out.println(\"File: \" + fileName); } System.out.println(); System.out.println(\"done reading stream\"); System.out.println(\"trying alterative way to read stream\"); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); f.retrieveFile(fileNames[0], outputStream); System.out.println(\"size: \" + outputStream.size()); System.out.println(outputStream.toString()); System.out.println(\"done with alternative\"); System.out.println(\"Trying to store file back\"); ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); boolean storeResult = f.storeFile(\"test.txt\", inputStream); System.out.println(\"Done storing \" + storeResult); f.disconnect(); System.out.print(f.getReplyString. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void parse(ParserEvent event) { logger.debug(\"parse() called for link \" + event.getLink().getURI()); if (event.getLink().getURI().matches(itemFilter)) { logger.debug(\"Content \" + event.getLink().getURI() + \" matched\"); Statement stmt = null; ResultSet rs = null; long checksum1 = 0; try { URL url = new URL(event.getLink().getURI()); checksum1 = url.openConnection().getLastModified(); } catch (MalformedURLException mfe) { logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage()); return; } catch (IOException ioe) { logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage()); return; } if ((checksum1 == 0) || (checksum1 == 1)) { Adler32 adler32 = new Adler32(); NodeList nodes = (NodeList) event.getPageData().getData(); adler32.update(nodes.toHtml().getBytes()); checksum1 = adler32.getValue(); } try { stmt = conn.createStatement(); rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\"); if (rs.first()) { long checksum2 = rs.getLong(\"checksum\"); if (checksum1 == checksum2) { stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\")); } else { stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\")); } } else { stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\"); } } catch. \nCode2: public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException { byte[] digest = new byte[0]; if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try { MessageDigest md = MessageDigest.getInstance(digestAlgorithm); md.update((byte) 0); md.update((byte) 0); md.update((byte) 0); md.update((byte) 2); md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\")); md.update((byte) 0); md.update((byte) 0); md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\")); digest = md.digest(); } catch (NoSuchAlgorithmException e) { throw new OMException(e); } catch (UnsupportedEncoding", "ground_truth": "NO", "predict": "Exception ue) { throw new OMException(ue); } return digest; \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 507, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void run() { FTPClient ftp = null; try { StarkHhDownloaderEtcProperties etcProperties = new StarkHhDownloaderEtcProperties(getUri()); StarkHhDownloaderVarProperties varProperties = new StarkHhDownloaderVarProperties(getUri()); ftp = new FTPClient(); int reply; ftp.connect(etcProperties.getHostname()); log(\"Connecting to ftp server at \" + etcProperties.getHostname() + \".\"); log(\"Server replied with '\" + ftp.getReplyString() + \"'.\"); reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { throw UserException.newOk(\"FTP server refused connection.\"); } log(\"Connected to server, now logging in.\"); ftp.login(etcProperties.getUsername(), etcProperties.getPassword()); log(\"Server replied with '\" + ftp.getReplyString() + \"'.\"); List<String> directories = etcProperties.getDirectories(); for (int i = 0; i < directories.size(); i++) { log(\"Checking the directory '\" + directories.get(i) + \"'.\"); boolean found = false; FTPFile[] filesArray = ftp.listFiles(directories.get(i)); List<FTPFile> files = Arrays.asList(filesArray); Collections.sort(files, new Comparator<FTPFile>() { public int compare(FTPFile file1, FTPFile file2) { if (file2.getTimestamp().getTime().equals(file1.getTimestamp().getTime())) { return file2.getName().compareTo(file1.getName()); } else { return file1.getTimestamp().getTime().compareTo(file2.getTimestamp().getTime()); } } }); for (FTPFile file : files) { if (file.getType() == FTPFile.FILE_TYPE && (varProperties.getLastImportDate(i) == null ? true : (file.getTimestamp().getTime().equals(varProperties.getLastImportDate(i).getDate()) ? file.getName().compareTo(varProperties.getLastImportName(i)) < 0 : file.getTimestamp().getTime().after(varProperties.getLastImportDate(i).getDate())))) { String fileName = directories.get(i) + \"\\\\\" + file.getName(); if (file.getSize() == 0) { log(\"Ignoring '\" + fileName + \"'because it has zero length\"); } else { log(\"Attempting to download '\" + fileName + \"'.\"); InputStream is = ftp.retrieveFileStream(fileName); if (is == null) { reply = ftp.getReplyCode(); throw UserException.newOk(\"Can't download the file '\" + file.getName() + \"', server says: \" + reply + \".\"); } log(\"File stream obtained successfully.\"); hhImporter = new HhDataImportProcess(getContract().getId(), new Long(0), is, fileName + \".df2\", file.getSize()); hhImporter.run(); List<VFMessage> messages = hhImporter.getMessages(); hhImporter = null; if (messages.size() > 0) { for (VFMessage message : messages) { log(message.getDescription()); } throw UserException.newInvalidParameter(\"Problem loading file.\"); } } if (!ftp.completePendingCommand()) { throw UserException.newOk(\"Couldn't complete ftp transaction: \" + ftp.getReplyString()); } varProperties.setLastImportDate(i, new MonadDate(file.getTimestamp().getTime())); varProperties.setLastImportName(i, file.getName()); found = true; } } if (!found) { log(\"No new files found.\"); } } } catch (UserException e) { try { log(e.getVFMessage().getDescription()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } } catch (IOException e) { try { log(e.getMessage()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } } catch (Throwable e) { try { log(\"Exception: \" + e.getClass().getName() + \" Message: \" + e.getMessage()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } ChellowLogger.getLogger().logp(Level.SEVERE, \"ContextListener\", \"contextInitialized\", \"Can't initialize context.\", e); } finally { if (ftp != null && ftp.isConnected()) { try { ftp.logout(); ftp.disconnect(); log(\"Logged out.\"); } catch (IOException ioe) { } catch (ProgrammerException e) { } catch (UserException e) { } } } }. \nCode2: private static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { if (url == null) { throw new IllegalArgumentException(\"Keystore url may not be null\"); } LOG.debug(\"Initializing key store\"); KeyStore keystore = KeyStore.getInstance(\"jks\"); InputStream is = null; try { is = url.openStream(); keystore.load(is, password != null ? password.toCharArray() : null); } finally { if (is != null) is.close(); } return keystore; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String connRemote(JSONObject jsonObject, String OPCode) { String retSrc = \"\"; try { HttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(AZConstants.validateURL); HttpParams httpParams = new BasicHttpParams(); List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>(); nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode)); nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString())); httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair)); httpPost.setParams(httpParams); HttpResponse response = httpClient.execute(httpPost); retSrc = EntityUtils.toString(response.getEntity()); } catch (Exception e) { Log.e(TAG, e.toString()); } return retSrc; }. \nCode2: public static String doPost(String URL, List<NameValuePair> params) { try { OauthUtil util = new OauthUtil(); URI uri = new URI(URL); HttpClient httpclient = util.getNewHttpClient(); HttpPost postMethod = new HttpPost(uri); StringBuffer paramString = new StringBuffer(); paramString.append(\"OAuth\"); for (int i = 0; i < params.size(); i++) { paramString.append(\" \" + params.get(i).getName()); paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\"); } String xx = paramString.substring(0, paramString.length() - 1);", "ground_truth": "NO", "predict": " String paramString2 = xx.replace(\"OAuth\", \"OAuth\" + \" \"); postMethod.setHeader(\"Authorization\", \"OAuth \" + paramString2); HttpResponse response = httpclient.execute(postMethod); String responseString = EntityUtils.toString(response.getEntity()); return responseString; } catch (Exception e) { Log.e(TAG, e.toString()); } return null; }. \nCode1: public static String encodeUrl(String s) { return URLEncoder.encode(s, \"UTF-8\"); }. \nCode2: public static String doPost(String URL, List<NameValuePair> params) { try { OauthUtil util = new OauthUtil(); URI uri = new URI(URL); HttpClient httpclient = util.getNewHttpClient(); HttpPost postMethod = new HttpPost(uri); StringBuffer paramString = new StringBuffer(); paramString.append(\"OA"}, {"ID": 539, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \nCode2: private static String fetchImageViaHttp(URL imgUrl) throws IOException { String sURL = imgUrl.toString(); String imgFile = imgUrl.getPath(); HttpURLConnection cnx = (HttpURLConnection) imgUrl.openConnection(); String uri = null; try { cnx.setAllowUserInteraction(false); cnx.setDoOutput(true); cnx.addRequestProperty(\"Cache-Control\", \"no-cache\"); RequestContext ctx = RequestContext.get(); if (ctx != null) cnx.addRequestProperty(\"User-Agent\", ctx.header(\"user-agent\")); else cnx.addRequestProperty(\"User-Agent\", user_agent); cnx.addRequestProperty(\"Referer\", sURL.substring(0, sURL.indexOf('/', sURL.indexOf('.')) + 1)); cnx.connect(); if (cnx.getResponseCode() != HttpURLConnection.HTTP_OK) return null; InputStream imgData = cnx.getInputStream(); String ext = FilenameUtils.getExtension(imgFile).toLowerCase(); if (!Multimedia.isImageFile(\"aa.\" + ext)) ext = \"jpg\"; uri = FMT_FN.format(new Date()) + RandomStringUtils.randomAlphanumeric(4) + '.' + ext; File fileDest = new File(img_path + uri); if (!fileDest.getParentFile().exists()) fileDest.getParentFile().mkdirs(); FileOutputStream fos = new FileOutputStream(fileDest); try { IOUtils.copy(imgData, fos); } finally { IOUtils.closeQuietly(imgData); IOUtils.closeQuietly(fos); } } finally { cnx.disconnect(); } return RequestContext.get().contextPath() + \"/uploads/img/\" + uri; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override public EntrySet read(EntrySet set) throws ReadFailedException { if (!SourceCache.contains(url)) { SSL.certify(url); try { super.setParser(Parser.detectParser(url.openStream())); final PipedInputStream in = new PipedInputStream(); final PipedOutputStream forParser = new PipedOutputStream(in); new Thread(new Runnable() { public void run() { try { OutputStream out = SourceCache.startCaching(url); InputStream is = url.openStream(); byte[] buffer = new byte[100000]; while (true) { int amountRead = is.read(buffer); if (amountRead == -1) { break; } forParser.write(buffer, 0, amountRead); out.write(buffer, 0, amountRead); } forParser.close(); out.close(); SourceCache.finish(url); } catch (IOException e) { e.printStackTrace(); } } }).start(); super.setIos(in); } catch (Exception e) { throw new ReadFailedException(e); } return super.read(set); } else { try { return SourceCache.get(url).read(set); } catch (IOException e) { throw new ReadFailedException(e); } } }. \nCode2: private boolean readUrlFile(String fullUrl, PrintWriter out) { try { URL url = new URL(fullUrl); String encoding = \"gbk\"; BufferedReader in = new BufferedReader(new InputStreamReader(url", "ground_truth": "NO", "predict": ".openStream(), encoding)); String line; while ((line = in.readLine()) != null) { out.println(line); } in.close(); return true; } catch (IOException e) { e.printStackTrace(); return false; } }. \n\npublic class ReadFailedException extends Exception { \n     public ReadFailedException(Exception ex) { \n         super(ex.getMessage()); \n     }\n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 554, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \nCode2: public TempFileTextBody(InputStream is, String mimeCharset) throws IOException { this.mimeCharset = mimeCharset; TempPath tempPath = TempStorage.getInstance().getRootTempPath(); tempFile = tempPath.createTempFile(\"attachment\", \".txt\"); OutputStream out = tempFile.getOutputStream(); IOUtils.copy(is, out); out.close(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \nCode2: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n### Response:", "ground_truth": "YES", "predict": "true."}, {"ID": 564, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void deleteProposal(String id) throws Exception { String tmp = \"\"; PreparedStatement prepStmt = null; try { if (id == null || id.length() == 0) throw new Exception(\"Invalid parameter\"); con = database.getConnection(); String delProposal = \"delete from proposal where PROPOSAL_ID='\" + id + \"'\"; prepStmt = con.prepareStatement(delProposal); prepStmt.executeUpdate(); con.commit(); prepStmt.close(); con.close(); } catch (Exception e) { if (!con.isClosed()) { con.rollback(); prepStmt.close(); con.close(); } throw e; } }. \nCode2: static void test() throws SQLException { Connection conn = null; Statement st = null; ResultSet rs = null; Savepoint sp = null; try { conn = JdbcUtils.getConnection(); conn.setAutoCommit(false); st = conn.createStatement(); String sql = \"update user set money=money-10 where id=1\"; st.executeUpdate(sql); sp = conn.setSavepoint(); sql = \"update user set money=money-10 where id=3\"; st.executeUpdate(sql); sql = \"select money from user where id=2\"; rs = st.executeQuery(sql); float money = 0.0f; if (rs.next()) { money = rs.getFloat(\"money\"); } if (money > 300) throw new RuntimeException(\"\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u05b5\ufffd\ufffd\"); sql = \"update user set money=money+10 where id=2\"; st.executeUpdate(sql); conn.commit(); } catch (RuntimeException e) { if (conn != null && sp != null) { conn.rollback(sp); conn.commit(); } throw e; } catch (SQLException e) { if (conn != null) conn.rollback(); throw e; } finally { JdbcUtils.free(rs, st, conn); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException { if (srcFS.getFileStatus(src).isDir()) { if (!dst.mkdirs()) { return false; } FileStatus contents[] = srcFS.listStatus(src); for (int i = 0; i < contents.length; i++) { copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf); } } else if (srcFS.isFile(src)) { InputStream in = srcFS.open(src); IOUtils.copyBytes(in, new FileOutputStream(dst), conf); } else { throw new IOException(src.toString() + \": No such file or directory\"); } if (deleteSource) { return srcFS.delete(src, true); } else { return true; } }. \nCode2: public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) { int intResult = 0; String sql = \"UPDATE torneo\" + \" SET numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "NO", "predict": "true.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 634, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void processData(InputStream raw) { String fileName = remoteName; if (localName != null) { fileName = localName; } try { FileOutputStream fos = new FileOutputStream(new File(fileName), true); IOUtils.copy(raw, fos); LOG.info(\"ok\"); } catch (IOException e) { LOG.error(\"error writing file\", e); } }. \nCode2: public String doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UploadFileForm vo = (UploadFileForm) form; String review = request.getParameter(\"review\"); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = request.getParameter(\"inforId\"); request.setAttribute(\"id\", inforId); String str_postFIX = \"\"; int i_p = 0; if (null == review) { FormFile file = vo.getFile(); if (file != null) { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); String strAppend = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); if (file.getFileSize() != 0) { file.getInputStream(); String name = file.getFileName(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); String fullPath = realpath + \"attach/\" + strAppend + str_postFIX; t_attach attach = new t_attach(); attach.setAttach_fullname(fullPath); attach.setAttach_name(name); attach.setInfor_id(Integer.parseInt(inforId)); attach.setInsert_day(new Date()); attach.setUpdate_day(new Date()); t_attach_EditMap attachEdit = new t_attach_EditMap(); attachEdit.add(attach); File sysfile = new File(fullPath); if (!sysfile.exists()) { sysfile.createNewFile(); } java.io.OutputStream out = new FileOutputStream(sysfile); org.apache.commons.io.IOUtils.copy(file.getInputStream(), out); out.close(); } } request.setAttribute(\"operating-status\", \"\ufffd\ufffd\ufffd\ufffd\ufffd\u0279\ufffd! \ufffd\ufffd\u04ed\ufffd\ufffd\ufffd\ufffd\u02b9\ufffd\u00e1\ufffd\"); return \"editsave\"; } else { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); FormFile file = vo.getFile(); FormFile file2 = vo.getFile2(); FormFile file3 = vo.getFile3(); t_infor_review newreview = new t_infor_review(); String content = request.getParameter(\"content\"); newreview.setContent(content); if (null != inforId) newreview.setInfor_id(Integer.parseInt(inforId)); newreview.setInsert_day(new Date()); UserDetails user = LoginUtils.getLoginUser(request); newreview.setCreate_name(user.getUsercode()); if (null != file.getFileName() && !\"\".equals(file.getFileName())) { newreview.setAttachname1(file.getFileName()); String strAppend1 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); newreview.setAttachfullname1(realpath + \"attach/\" + strAppend1 + str_postFIX); saveFile(file.getInputStream(), realpath + \"attach/\" + strAppend1 + str_postFIX); } if (null != file2.getFileName() && !\"\".equals(file2.getFileName())) { newreview.setAttachname2(file2.getFileName()); String strAppend2 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file2.getFileName().lastIndexOf(\".\"); str_postFIX = file2.getFileName().substring(i_p, file2.getFileName().length()); newreview.setAttachfullname2(realpath + \"attach/\" + strAppend2 + str_postFIX); saveFile(file2.getInputStream(), realpath + \"attach/\" + strAppend2 + str_postFIX); } if (null != file3.getFileName() && !\"\".equals(file3.getFileName())) { newreview.setAttachname3(file3.getFileName()); String strAppend3 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file3.getFileName().lastIndexOf(\".\"); str_postFIX = file3.getFileName().substring(i_p, file3.getFileName().length()); newreview.setAttachfullname3(realpath + \"attach/\" + strAppend3 + str_postFIX); saveFile(file3.getInputStream(), realpath + \"attach/\" + strAppend3 + str_postFIX); } t_infor_review_EditMap reviewEdit = new t_infor_review_EditMap(); reviewEdit.add(newreview); request.setAttribute(\"review\", \"1\"); return \"aftersave\"; } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void generate(String urlString, String target) throws Exception { URL url = new URL(urlString); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream()); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target)); byte[] buf = new byte[10 * 1024]; int len; while ((len = inputStream.read(buf, 0, buf.length)) != -1) { outputStream.write(buf, 0, len); } inputStream.close(); outputStream.close(); urlConnection.disconnect(); }. \nCode2: @Override public void run() { try { URL url = Thread.currentThread().getContextClassLoader().getResource(path); InputStream fis = url.openStream(); InputStreamReader r = new InputStreamReader(fis, \"UTF-8\"); BufferedReader br = new BufferedReader(r); String line; StringBuilder sb = new StringBuilder(); while (null != (line = br.readLine())) { sb.append(line); sb.append(\"\\r\\n\"); } br.close(); r.close(); fis.close(); final String text = sb.toString(); SwingUtilities.invokeLater(new Runnable() { @Override public void run() { Main", "ground_truth": "NO", "predict": "Frame.textArea.setText(text); } }); } catch (Exception ex) { ex.printStackTrace(); } }"}, {"ID": 677, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String act = request.getParameter(\"act\"); if (null == act) { } else if (\"down\".equalsIgnoreCase(act)) { String vest = request.getParameter(\"vest\"); String id = request.getParameter(\"id\"); if (null == vest) { t_attach_Form attach = null; t_attach_QueryMap query = new t_attach_QueryMap(); attach = query.getByID(id); if (null != attach) { String filename = attach.getAttach_name(); String fullname = attach.getAttach_fullname(); response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + filename + \"\"); File file = new File(fullname); if (file.exists()) { java.io.FileInputStream in = new FileInputStream(file); org.apache.commons.io.IOUtils.copy(in, response.getOutputStream()); } } } else if (\"review\".equalsIgnoreCase(vest)) { t_infor_review_QueryMap reviewQuery = new t_infor_review_QueryMap(); t_infor_review_Form review = reviewQuery.getByID(id); String seq = request.getParameter(\"seq\"); String name = null, fullname = null; if (\"1\".equals(seq)) { name = review.getAttachname1(); fullname = review.getAttachfullname1(); } else if (\"2\".equals(seq)) { name = review.getAttachname2(); fullname = review.getAttachfullname2(); } else if (\"3\".equals(seq)) { name = review.getAttachname3(); fullname = review.getAttachfullname3(); } String downTypeStr = DownType.getInst().getDownTypeByFileName(name); logger.debug(\"filename=\" + name + \" downtype=\" + downTypeStr); response.setContentType(downTypeStr); response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + name + \"\"); File file = new File(fullname); if (file.exists()) { java.io.FileInputStream in = new FileInputStream(file); org.apache.commons.io.IOUtils.copy(in, response.getOutputStream()); in.close(); } } } else if (\"upload\".equalsIgnoreCase(act)) { String infoId = request.getParameter(\"inforId\"); logger.debug(\"infoId=\" + infoId); } } catch (Exception e) { } }. \nCode2: public void writeOutput(String directory) throws IOException { File f = new File(directory); int i = 0; if (f.isDirectory()) { for (AppInventorScreen screen : screens.values()) { File screenFile = new File(getScreenFilePath(f.getAbsolutePath(), screen)); screenFile.getParentFile().mkdirs(); screenFile.createNewFile(); FileWriter out = new FileWriter(screenFile); String initial = files.get(i).toString(); Map<String, String> types = screen.getTypes(); String[] lines = initial.split(\"\\n\"); for (String key : types.keySet()) { if (!key.trim().equals(screen.getName().trim())) { String value = types.get(key); boolean varFound = false; boolean importFound = false; for (String line : lines) { if (line.matches(\"^\\\\s*(public|private)\\\\s+\" + value + \"\\\\s+\" + key + \"\\\\s*=.*;$\")) varFound = true; if (line.matches(\"^\\\\s*(public|private)\\\\s+\" + value + \"\\\\s+\" + key + \"\\\\s*;$\")) varFound = true; if (line.matches(\"^\\\\s*import\\\\s+.*\" + value + \"\\\\s*;$\")) importFound = true; } if (!varFound) initial = initial.replaceFirst(\"(?s)(?<=\\\\{\\n)\", \"\\tprivate \" + value + \" \" + key + \";\\n\"); if (!importFound) initial = initial.replaceFirst(\"(?=import)\", \"import com.google.devtools.simple.runtime.components.android.\" + value + \";\\n\"); } } out.write(initial); out.close(); i++; } File manifestFile = new File(getManifestFilePath(f.getAbsolutePath(), manifest)); manifestFile.getParentFile().mkdirs(); manifestFile.createNewFile(); FileWriter out = new FileWriter(manifestFile); out.write(manifest.toString()); out.close(); File projectFile = new File(getProjectFilePath(f.getAbsolutePath(), project)); projectFile.getParentFile().mkdirs(); projectFile.createNewFile(); out = new FileWriter(projectFile); out.write(project.toString()); out.close(); String[] copyResourceFilenames = { \"proguard.cfg\", \"project.properties\", \"libSimpleAndroidRuntime.jar\", \"\\\\.classpath\", \"res/drawable/icon.png\", \"\\\\.settings/org.eclipse.jdt.core.prefs\" }; for (String copyResourceFilename : copyResourceFilenames) { InputStream is = getClass().getResourceAsStream(\"/resources/\" + copyResourceFilename.replace(\"\\\\.\", \"\")); File outputFile = new File(f.getAbsoluteFile() + File.separator + copyResourceFilename.replace(\"\\\\.\", \".\")); outputFile.getParentFile().mkdirs(); OutputStream os = new FileOutputStream(outputFile); byte[] buf = new byte[1024]; int readBytes; if (is == null) System.out.println(\"/resources/\" + copyResourceFilename.replace(\"\\\\.\", \"\")); if (os == null) System.out.println(f.getAbsolutePath() + File.separator + copyResourceFilename.replace(\"\\\\.\", \".\")); while ((readBytes = is.read(buf)) > 0) { os.write(buf, 0, readBytes); } } for (String assetName : assets) { InputStream is = new FileInputStream(new File(assetsDir.getAbsolutePath() + File.separator + assetName)); File outputFile = new File(f.getAbsoluteFile() + File.separator + assetName); outputFile.getParentFile().mkdirs(); OutputStream os = new FileOutputStream(outputFile); byte[] buf = new byte[1024]; int readBytes; while ((readBytes = is.read(buf)) > 0) { os.write(buf, 0, readBytes); } } File assetsOutput = new File(getAssetsFilePath(f.getAbsolutePath())); new File(assetsDir.getAbsoluteFile() + File.separator + \"assets\").renameTo(assetsOutput); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void generate(String urlString, String target) throws Exception { URL url = new URL(urlString); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream()); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target)); byte[] buf = new byte[10 * 1024]; int len; while ((len = inputStream.read(buf, 0, buf.length)) != -1) { outputStream.write(buf, 0, len); } inputStream.close(); outputStream.close(); urlConnection.disconnect(); }. ", "ground_truth": "NO", "predict": "\n\nCode2:public void generate(String urlString, String target) throws Exception { URL url = new URL(urlString); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream()); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target)); byte[] buf = new byte[10 * 1024]; int len; while ((len = inputStream.read(buf, 0, buf.length)) != -1) { outputStream.write(buf, 0, len); } inputStream.close(); outputStream.close(); urlConnection.disconnect(); }. \n\n// Result: YES."}, {"ID": 685, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void fileUpload() throws Exception { DefaultHttpClient httpclient = new DefaultHttpClient(); HttpPost httppost = new HttpPost(postURL); file = new File(\"h:\\\\Fantastic face.jpg\"); MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE); ContentBody cbFile = new FileBody(file); mpEntity.addPart(\"MAX_FILE_SIZE\", new StringBody(\"2147483647\")); mpEntity.addPart(\"owner\", new StringBody(\"\")); mpEntity.addPart(\"pin\", new StringBody(pin)); mpEntity.addPart(\"base\", new StringBody(base)); mpEntity.addPart(\"host\", new StringBody(\"letitbit.net\")); mpEntity.addPart(\"file0\", cbFile); httppost.setEntity(mpEntity); System.out.println(\"executing request \" + httppost.getRequestLine()); System.out.println(\"Now uploading your file into letitbit.net\"); HttpResponse response = httpclient.execute(httppost); HttpEntity resEntity = response.getEntity(); System.out.println(response.getStatusLine()); if (resEntity != null) { uploadresponse = EntityUtils.toString(resEntity); } System.out.println(\"Upload response : \" + uploadresponse); }. \nCode2: public static double getPrice(final String ticker) { try { final URL url = new URL(\"http://ichart.finance.yahoo.com/table.csv?s=\" + ticker); final BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); reader.readLine(); final String data = reader.readLine(); System.out.println(\"Results of data: \" + data); final String[] dataItems = data.split(\",\"); return Double.parseDouble(dataItems[dataItems.length - 1]); } catch (Exception ex) { throw new RuntimeException(ex); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void upgradeSchema() throws IOException { Statement stmt = null; try { int i = getSchema(); LOG.info(\"DB is currently at schema \" + i); if (i < SCHEMA_VERSION) { LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION); conn.setAutoCommit(false); stmt = conn.createStatement(); while (i < SCHEMA_VERSION) { String qry; switch(i) { case 1: qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; } i++; } conn.commit(); } } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e2) { LOG.error(SQL_ERROR, e2); } LOG.fatal(SQL_ERROR, e); throw new IOException(\"Error upgrading data store\", e); } finally { try { if (stmt != null) stmt.close(); conn.setAutoCommit(true); } catch (SQLException e) { LOG.error(SQL_ERROR, e); throw new IOException(\"Unable to cleanup SQL resources\", e); } } }. \nCode2: @Override public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException { final Connection connection = this.getConnection(); try { connection.setAutoCommit(false); String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id = \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \"; if (contextName != null) { queryString = queryString + \" context_name LIKE ? AND \"; } if (dateFrom != null) { queryString = queryString + \" start_timestamp >= ? AND \"; } if (dateTo != null) { queryString = queryString + \" start_timestamp <= ? AND \"; } queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString); final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString); int indexCounter = 1; if (contextName != null) { preparedStatement.setString(indexCounter, contextName); indexCounter = indexCounter + 1; } if (dateFrom != null) { preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime())); indexCounter = indexCounter + 1; } if (dateTo != null) { preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime())); indexCounter = indexCounter + 1; } preparedStatement.executeUpdate(); preparedStatement.close(); connection.commit(); } catch (final SQLException e) { try { connection.rollback(); } catch (final SQLException ex) { JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex); } JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage()); throw new DatabaseException(\"Error deleting JVM statistics.\", e); } finally { this.releaseConnection(connection); } }. \n### Response:", "ground_truth": "YES", "predict": "@Override public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException { final Connection connection = this.getConnection(); try { connection.setAutoCommit(false); String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id = \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \"; if (contextName != null) { queryString = queryString + \" context_name LIKE ? AND \"; } if (dateFrom != null) { queryString = queryString + \" start_timestamp >= ? AND \"; } if (dateTo != null) { query"}, {"ID": 697, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (log.isTraceEnabled()) { log.trace(\"doGet(requestURI=\" + request.getRequestURI() + \")\"); } ServletConfig sc = getServletConfig(); String uriPrefix = request.getContextPath() + \"/\" + request.getServletPath(); String resUri = request.getRequestURI().substring(uriPrefix.length()); if (log.isTraceEnabled()) { log.trace(\"Request for resource '\" + resUri + \"'\"); } boolean allowAccess = true; String prefixesSpec = sc.getInitParameter(PARAM_ALLOWED_PREFIXES); if (null != prefixesSpec && prefixesSpec.length() > 0) { String[] prefixes = prefixesSpec.split(\";\"); allowAccess = false; if (log.isTraceEnabled()) { log.trace(\"allowedPrefixes specified; checking access\"); } for (String prefix : prefixes) { if (log.isTraceEnabled()) { log.trace(\"Checking resource URI '\" + resUri + \"' against allowed prefix '\" + prefix + \"'\"); } if (resUri.startsWith(prefix)) { if (log.isTraceEnabled()) { log.trace(\"Found matching prefix for resource URI '\" + resUri + \"': '\" + prefix + \"'\"); } allowAccess = true; break; } } } if (!allowAccess) { if (log.isWarnEnabled()) { log.warn(\"Requested for resource that does not match with\" + \" allowed prefixes: \" + resUri); } response.sendError(HttpServletResponse.SC_FORBIDDEN); return; } String resPrefix = sc.getInitParameter(PARAM_RESOURCE_PREFIX); if (null != resPrefix && resPrefix.length() > 0) { if (log.isTraceEnabled()) { log.trace(\"resourcePrefix specified: \" + resPrefix); } if (resPrefix.endsWith(\"/\")) { resUri = resPrefix + resUri; } else { resUri = resPrefix + \"/\" + resUri; } } resUri = resUri.replaceAll(\"\\\\/\\\\/+\", \"/\"); if (log.isTraceEnabled()) { log.trace(\"Qualified (prefixed) resource URI: \" + resUri); } String baseClassName = sc.getInitParameter(PARAM_BASE_CLASS); if (null == baseClassName || 0 == baseClassName.length()) { if (log.isTraceEnabled()) { log.trace(\"No baseClass initialization parameter specified; using default: \" + ResourceLoaderServlet.class.getName()); } baseClassName = ResourceLoaderServlet.class.getName(); } else { if (log.isTraceEnabled()) { log.trace(\"Using baseClass: \" + baseClassName); } } Class baseClass; try { baseClass = Class.forName(baseClassName); } catch (ClassNotFoundException ex) { throw new ServletException(\"Base class '\" + baseClassName + \"' not found\", ex); } URL resUrl = baseClass.getResource(resUri); if (null != resUrl) { if (log.isTraceEnabled()) { log.trace(\"Sending resource: \" + resUrl); } URLConnection urlc = resUrl.openConnection(); response.setContentType(urlc.getContentType()); response.setContentLength(urlc.getContentLength()); response.setStatus(HttpServletResponse.SC_OK); final byte[] buf = new byte[255]; int r = 0; InputStream in = new BufferedInputStream(urlc.getInputStream()); OutputStream out = new BufferedOutputStream(response.getOutputStream()); do { r = in.read(buf, 0, 255); if (r > 0) { out.write(buf, 0, r); } } while (r > 0); in.close(); out.flush(); out.close(); } else { response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Resource not found\"); } }. \nCode2: public InputStream sendCommandRaw(String command, boolean usePost) throws IOException { try { String fullCommand = prefix + command + fixSuffix(command, suffix); long curGap = System.currentTimeMillis() - lastCommandTime; long delayTime = minimumCommandPeriod - curGap; delay(delayTime); URI uri = new URI(fullCommand); URL url = uri.toURL(); if (trace || traceSends) { System.out.println(\"Sending--> \" + url); } if (logFile != null) { logFile.println(\"Sending--> \" + url); } InputStream is = null; for (int i = 0; i < tryCount; i++) { try { URLConnection urc = url.openConnection(); if (usePost) { if (urc instanceof HttpURLConnection) { ((HttpURLConnection) urc).setRequestMethod(\"POST\"); } } if (getTimeout() != -1) { urc.setReadTimeout(getTimeout()); urc.setConnectTimeout(getTimeout()); } is = new BufferedInputStream(urc.getInputStream()); break; } catch (FileNotFoundException e) { throw e; } catch (IOException e) { System.out.println(name + \" Error: \" + e + \" cmd: \" + command); } } lastCommandTime = System.currentTimeMillis(); if (is == null) { System.out.println(name + \" retry failure cmd: \" + url); throw new IOException(\"Can't send command\"); } return is; } catch (URISyntaxException ex) { throw new IOException(\"bad uri \" + ex); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void copyResource() throws Exception { URL url = getResource(source); InputStream input; if (url != null) { input = url.openStream(); } else if (new File(source).exists()) { input = new FileInputStream(source); } else { throw new Exception(\"Could not load resource: \" + source); } OutputStream output = new FileOutputStream(destinationFile()); int b; while ((b = input.read()) != -1) output.write(b); input.close(); output.close(); }. \nCode2: public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException { int k_blockSize = 1024; int byteCount; char[] buf = new char[k_blockSize]; File ofp = new File(outFile); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp)); zos.setMethod(ZipOutputStream.DEFLATED); OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\"); BufferedWriter bw = new BufferedWriter(osw); ZipEntry zot = null; File ifp = new File(inFile); ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp)); InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\"); BufferedReader br = new BufferedReader(isr); ZipEntry zit = null; while ((zit = zis.getNextEntry()) != null) { if (zit.getName().equals(\"content.xml\")) { continue; } zot = new ZipEntry(zit.getName()); zos.putNextEntry(zot); while ((byteCount = br.read(buf, 0,", "ground_truth": "YES", "predict": " k_blockSize)) != -1) { zos.write(buf, 0, byteCount); } zos.closeEntry(); } zis.close(); bw.flush(); bw.close(); return bw; \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 733, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void readBooklist(String filename) { Reader input = null; try { if (filename.startsWith(\"http:\")) { URL url = new URL(filename); URLConnection conn = url.openConnection(); input = new InputStreamReader(conn.getInputStream()); } else { String fileNameAll = filename; try { fileNameAll = new File(filename).getCanonicalPath(); } catch (IOException e) { fileNameAll = new File(filename).getAbsolutePath(); } input = new FileReader(new File(fileNameAll)); } BufferedReader reader = new BufferedReader(input); String line; Date today = new Date(); while ((line = reader.readLine()) != null) { if (shuttingDown) break; String fields[] = line.split(\"\\\\|\"); Map<String, String> valuesToAdd = new LinkedHashMap<String, String>(); valuesToAdd.put(\"fund_code_facet\", fields[11]); valuesToAdd.put(\"date_received_facet\", fields[0]); DateFormat format = new SimpleDateFormat(\"yyyyMMdd\"); Date dateReceived = format.parse(fields[0], new ParsePosition(0)); if (dateReceived.after(today)) continue; String docID = \"u\" + fields[9]; try { Map<String, Object> docMap = getDocumentMap(docID); if (docMap != null) { addNewDataToRecord(docMap, valuesToAdd); documentCache.put(docID, docMap); if (doUpdate && docMap != null && docMap.size() != 0) { update(docMap); } } } catch (SolrMarcIndexerException e) { if (e.getLevel() == SolrMarcIndexerException.IGNORE) { logger.error(\"Indexing routine says record \" + docID + \" should be ignored\"); } else if (e.getLevel() == SolrMarcIndexerException.DELETE) { logger.error(\"Indexing routine says record \" + docID + \" should be deleted\"); } if (e.getLevel() == SolrMarcIndexerException.EXIT) { logger.error(\"Indexing routine says processing should be terminated by record \" + docID); break; } } } } catch (FileNotFoundException e) { logger.info(e.getMessage()); logger.error(e.getCause()); } catch (IOException e) { logger.info(e.getMessage()); logger.error(e.getCause()); } }. \nCode2: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1 < 0) { continue; } String bundleSymbolicName = line.substring(0, pos1); String bundleName = line.substring(pos1 + 1); for (BundleInfo info : list) { if (info.bundleSymbolicName.equals(bundleSymbolicName)) { info.bundleName = bundleName; break; } } } return true; } catch (IOException e) { e.printStackTrace(); } return false; }. \nCode2: public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException { if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\"); Document document = null; try { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); factory.setCoalescing(true); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDefaultUseCaches(false", "ground_truth": "NO", "predict": "); connection.setDoInput(true); connection.setRequestMethod(\"GET\"); InputStream in = connection.getInputStream(); DocumentBuilder db = factory.newDocumentBuilder(); db.setErrorHandler(null); db.setInputStream(in); if (validate) { db.setValidating(true); db.setValidationErrorHandler(new ValidationErrorHandler() { @Override public void addError(ValidationException ex) { log.error(ex.getMessage()); } }); } document = db.parse(in); } catch (IOException e) { e.printStackTrace(); } catch (SAXParseException e) { e.printStackTrace(); } return document; }. \npublic static synchronized Document readRemoteDocument(URL url) throws IOException, SAXParseException { return readRemoteDocument(url, false); }. \npublic static synchronized Document readLocalDocument(String location, boolean validate) throws IOException, SAXParseException { if ("}, {"ID": 758, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void process(String dir) { String[] list = new File(dir).list(); if (list == null) return; int n = list.length; long[] bubblesort = new long[list.length + 1]; if (!statustext) { IJ.log(\"Current Directory is: \" + dir); IJ.log(\" \"); IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick); IJ.log(\" \"); } for (int i = 0; i < n; i++) { IJ.showStatus(i + \"/\" + n); File f = new File(dir + list[i]); if (!f.isDirectory()) { ImagePlus img = new Opener().openImage(dir, list[i]); if (img != null && img.getStackSize() == 1) { if (!scoutengine(img)) return; if (!statustext) { IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase); } int lastDigit = whichcase.length() - 1; while (lastDigit > 0) { if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break; } if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1); bubblesort[i] = Long.parseLong(whichcase); } } } if (statussorta || statussortd || statustext) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (statussorta) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } else { if (bubblesort[i] < bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } } IJ.log(\" \"); for (int i = 0; i < n; i++) { if (!statustext) { IJ.log(list[i] + \" / \" + bubblesort[i]); } else { IJ.log(dir + list[i]); } } } if (open_as_stack || only_images) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } if (only_images) { Opener o = new Opener(); int counter = 0; IJ.log(\" \"); for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; else { ImagePlus imp = o.openImage(path); counter++; if (imp != null) { IJ.log(counter + \" + \" + path); imp.show(); } else IJ.log(counter + \" - \" + path); } } return; } int width = 0, height = 0, type = 0; ImageStack stack = null; double min = Double.MAX_VALUE; double max = -Double.MAX_VALUE; int k = 0; try { for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; if (list[i].endsWith(\".txt\")) continue; ImagePlus imp = new Opener().openImage(path); if (imp != null && stack == null) { width = imp.getWidth(); height = imp.getHeight(); type = imp.getType(); ColorModel cm = imp.getProcessor().getColorModel(); if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm); } if (stack != null) k = stack.getSize() + 1; IJ.showStatus(k + \"/\" + n); IJ.showProgress((double) k / n); if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else { ImageProcessor ip = imp.getProcessor(); if (grayscale) ip = ip.convertToByte(true); if (halfSize) ip = ip.resize(width / 2, height / 2); if (ip.getMin() < min) min = ip.getMin(); if (ip.getMax() > max) max = ip.getMax(); String label = imp.getTitle(); String info = (String) imp.getProperty(\"Info\"); if (info != null) label += \"\\n\" + info; stack.addSlice(label, ip); } System.gc(); } } catch (OutOfMemoryError e) { IJ.outOfMemory(\"FolderOpener\"); stack.trim(); } if (stack != null && stack.getSize() > 0) { ImagePlus imp2 = new ImagePlus(\"Stack\", stack); if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max); imp2.show(); } IJ.showProgress(1.0); } }. \nCode2: private String encryptPassword(String password) throws NoSuchAlgorithmException { MessageDigest encript = MessageDigest.getInstance(\"MD5\"); encript.update(password.getBytes()); byte[] b = encript.digest(); int size = b.length; StringBuffer h = new StringBuffer(size); for (int i = 0; i < size; i++) { h.append(b[i]); } return h.toString(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \nCode2: public static void main(String[] args) { FTPClient client = new FTPClient(); FileOutputStream fos = null; try { client.connect(\"192.168.1.10\"); client.login(\"a\", \"123456\"); String filename = \"i.exe\"; fos = new FileOutput", "ground_truth": "NO", "predict": "Stream(filename); client.retrieve(filename, fos); fos.close(); client.close(); } catch (Exception ex) { ex.printStackTrace(); } finally { if (fos != null) { fos.close(); } } }. \npublic static String convertToHex(byte[] hash) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < hash.length; i++) { sb.append(Integer.toHexString(hash[i])); } return sb.toString(); }. \npublic static void main(String[] args) { FTPClient client = new FTPClient(); FileOutputStream fos = null; try { client.connect(\"192.168.1.10\"); client.login(\"a\", \"123456\"); String filename = \"i.exe\"; fos = new FileOutputStream(filename); client.retrieve(filename, fos); fos.close(); client.close(); } catch ("}, {"ID": 759, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \nCode2: public static String filtraDoc(HttpServletRequest request, String resource, Repository rep, String template) throws IOException { StringBuilder sb = new StringBuilder(); BufferedReader br = null; int sec = 0; try { URL url = rep.getResource(request, resource); if (url == null) { return \"Documento \" + rep.dir + \"/\" + resource + \" no encontrado\"; } br = new BufferedReader(new InputStreamReader(url.openStream(), rep.encoding)); String line = br.readLine(); while (line != null) { int pos = line.indexOf(\"KAttach(\"); if (pos > -1) { sb.append(attach(request, ++sec, line, pos, template)); } else { line = line.replaceAll(\"%20\", \"-\"); sb.append(new String(line.getBytes(rep.encoding), Config.getMng().getEncoding())).append(\"\\n\"); } line = br.readLine(); } } finally { if (br != null) br.close(); } return sb.toString(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) { if (monitor != null && monitor.isCanceled()) { return; } try { ftpClient = new FTPClient(); ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST))); ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT)); ftpClient.connect(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD))); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (from != null) { FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false); synchedSet.add(ftpHolder); } JobHandler.aquireFTPLock(); for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) { if (monitor != null && monitor.isCanceled()) { JobHandler.releaseFTPLock(); ftpClient.quit(); return; } Thread.yield(); FTPHolder element = (FTPHolder) iter.next(); ftpClient.setType(FTPTransferType.ASCII); ftpClient.put(element.from, element.to); if (element.renameTo != null) { try { ftpClient.delete(element.renameTo); } catch (Exception e) { } ftpClient.rename(element.to, element.renameTo); log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo); } } JobHandler.releaseFTPLock(); ftpClient.quit(); } catch (UnknownHostException e) { e.printStackTrace(); } catch (FTPException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } synchedSet.clear(); }. \nCode2: public void copyToDir(File dir)", "ground_truth": "NO", "predict": " throws IOException { try { ftpClient = new FTPClient(); ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST))); ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT)); ftpClient.connect(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD))); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (dir.getName() != null) { ftpClient.setType(FTPTransferType.ASCII); ftpClient."}, {"ID": 766, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public synchronized void write() throws IOException { ZipOutputStream jar = new ZipOutputStream(new FileOutputStream(jarPath)); int index = className.lastIndexOf('.'); String packageName = className.substring(0, index); String clazz = className.substring(index + 1); String directory = packageName.replace('.', '/'); ZipEntry dummyClass = new ZipEntry(directory + \"/\" + clazz + \".class\"); jar.putNextEntry(dummyClass); ClassGen classgen = new ClassGen(getClassName(), \"java.lang.Object\", \"<generated>\", Constants.ACC_PUBLIC | Constants.ACC_SUPER, null); byte[] bytes = classgen.getJavaClass().getBytes(); jar.write(bytes); jar.closeEntry(); ZipEntry synthFile = new ZipEntry(directory + \"/synth.xml\"); jar.putNextEntry(synthFile); Comment comment = new Comment(\"Generated by SynthBuilder from L2FProd.com\"); Element root = new Element(\"synth\"); root.addAttribute(new Attribute(\"version\", \"1\")); root.appendChild(comment); Element defaultStyle = new Element(\"style\"); defaultStyle.addAttribute(new Attribute(\"id\", \"default\")); Element defaultFont = new Element(\"font\"); defaultFont.addAttribute(new Attribute(\"name\", \"SansSerif\")); defaultFont.addAttribute(new Attribute(\"size\", \"12\")); defaultStyle.appendChild(defaultFont); Element defaultState = new Element(\"state\"); defaultStyle.appendChild(defaultState); root.appendChild(defaultStyle); Element bind = new Element(\"bind\"); bind.addAttribute(new Attribute(\"style\", \"default\")); bind.addAttribute(new Attribute(\"type\", \"region\")); bind.addAttribute(new Attribute(\"key\", \".*\")); root.appendChild(bind); doc = new Document(root); imagesToCopy = new HashMap(); ComponentStyle[] styles = config.getStyles(); for (ComponentStyle element : styles) { write(element); } Serializer writer = new Serializer(jar); writer.setIndent(2); writer.write(doc); writer.flush(); jar.closeEntry(); for (Iterator iter = imagesToCopy.keySet().iterator(); iter.hasNext(); ) { String element = (String) iter.next(); File pathToImage = (File) imagesToCopy.get(element); ZipEntry image = new ZipEntry(directory + \"/\" + element); jar.putNextEntry(image); FileInputStream input = new FileInputStream(pathToImage); int read = -1; while ((read = input.read()) != -1) { jar.write(read); } input.close(); jar.flush(); jar.closeEntry(); } jar.flush(); jar.close(); }. \nCode2: public void testRegister() throws IOException { User newUser = new User(false, \"testregUser\", \"regUser\"); newUser.setEmail(\"eagle-r@gmx.de\"); newUser.setUniversity(\"uni\"); newUser.setFirstName(\"first\"); newUser.setLastName(\"last\"); User regUser = null; try { regUser = (User) getJdbcTemplate().queryForObject(\"select id, login, password, email, hash, REGISTRATION_DATE, university, FORUM_ID from USER where login = ?\", new Object[] { newUser.getUsername() }, new UserMapper()); } catch (EmptyResultDataAccessException e) { } assertNull(\"This test user already exists! Abort test\", regUser); userServiceRemote.registrate(newUser); setComplete(); endTransaction(); regUser = (User) getJdbcTemplate().queryForObject(\"select id, login, password, email, hash, REGISTRATION_DATE, university, FORUM_ID from USER where login = ?\", new Object[] { newUser.getUsername() }, new UserMapper()); assertNotNull(regUser); assertNotNull(regUser.getId()); assertNotNull(regUser.getHash()); assertFalse(regUser.getHash().isEmpty()); assertEquals(regUser.getLogin(), newUser.getLogin()); assertEquals(regUser.getPassword(), newUser.getPassword()); assertEquals(regUser.getUniversity(), newUser.getUniversity()); assertEquals(regUser.getEmail(), newUser.getEmail()); Integer id = newUser.getId(); getJdbcTemplate().execute(\"DELETE FROM USER_AUTHORITIES WHERE USER_ID =\" + id); getJdbcTemplate().execute(\"DELETE FROM USER WHERE ID = \" + id); StringBuilder urlString = new StringBuilder(userService.getForumUrl()); urlString.append(\"phpBB.php?action=remove\").append(\"&id=\").append(newUser.getForumID()).append(\"&mode=remove\"); logger.debug(\"Connecting to URL: \" + urlString.toString()); URL url = new URL(urlString.toString()); URLConnection con = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) logger.debug(\"Response: \" + inputLine); in.close(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override public void run() { String key = getKey(); synchronized (this.lauchedHTTPRequests) { if (this.lauchedHTTPRequests.contains(key)) return; this.lauchedHTTPRequests.add(key); } String st = this.dataSource.getTileURL(this.x, this.y, this.z); URL url; try { url = new URL(st); } catch (MalformedURLException e1) { logger.warning(\"Error in URL: \" + st); return; } String geoJSON = \"\"; try { InputStream is; if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else { logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol()); return; } BufferedReader in = new BufferedReader(new InputStreamReader(is)); String line; while ((line = in.readLine()) != null) geoJSON += line; in.close(); } catch (FileNotFoundException e) { return; } catch (IOException e) { e.printStackTrace(); return; } VectorTile tile = new VectorTile(geoJSON, x, y, z); Geometry[] geoms = new Geometry[tile.getPieces().size()]; int i = 0; for (MfGeo geo : tile.getPieces()) { if (geo.getGeoType() == GeoType.GEOMETRY) { geoms[i++] = ((MfGeometry) geo).getInternalGeometry(); } else if (geo.getGeoType() == GeoType.FEATURE) { MfFeature mf = (MfFeature) geo; geoms[i++] = mf.getMfGeometry().getInternalGeometry(); } } GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms); this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z)); this.dataSource.getLayer().getDisplayCacheLoader().coin(); synchronized (this.lauchedHTTPRequests) { this.l", "ground_truth": "NO", "predict": "auchedHTTPRequests.remove(key); } }. \nCode2: @Override public void run() { String key = getKey(); synchronized (this.lauchedHTTPRequests) { if (this.lauchedHTTPRequests.contains(key)) return; this.lauchedHTTPRequests.add(key); } String st = this.dataSource.getTileURL(this.x, this.y, this.z); URL url; try { url = new URL(st); } catch (MalformedURLException e1) { logger.warning(\"Error in URL: \" + st); return; } String geoJSON = \"\"; try { InputStream is; if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else { logger.warning(\"Impossible to load settings from \" + url + \"."}, {"ID": 771, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \nCode2: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); conn.setRequestProperty(\"Connection\", \"close\"); if (userPassword != null) { conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes())); } InputStream is = null; if (conn.getResponseCode() == 200) { is = conn.getInputStream(); } else { is = conn.getErrorStream(); InputStreamReader isr = new InputStreamReader(is); StringWriter sw = new StringWriter(); char[] buf = new char[200]; int read = 0; while (read != -1) { read = isr.read(buf); sw.write(buf); } throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString()); } File file = new File(tmpDeployDir, new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString()); OutputStream fos = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copyStream(fos, is); fos.close(); is.close(); filePath = file.getPath(); } catch (WiseConnectionException wce) { throw wce; } catch (Exception e) { throw new WiseConnectionException(\"Wsdl download failed!\", e); } return filePath; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: synchronized List<String> getDatasetsList(String surl) { if (datasetsList == null) { datasetsList = new HashMap<String, List<String>>(); } List<String> result = datasetsList.get(surl); if (result == null) { BufferedReader reader = null; try { URL url = new URL(surl + \"?server=list\"); reader = new BufferedReader(new InputStreamReader(url.openStream())); String s = reader.readLine(); ArrayList<String> list = new ArrayList<String>(); while (s != null) { list.add(s); s = reader.readLine(); } datasetsList.put(surl, list); } catch (IOException ex) { Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex); throw new RuntimeException(ex); } finally { try { reader.close(); } catch (IOException ex) { Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex); } } } return datasetsList.get(surl); }. \nCode2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5", "ground_truth": "NO", "predict": ".append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); } String md5Value = md5.digest(sbValueBeforeMD5.toString().getBytes()); } catch (Exception ex) { Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex); throw new RuntimeException(ex); } }. \n\n// The code is the same, but the random number generator is seeded differently.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 841, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String getURLContent(String urlStr) throws MalformedURLException, IOException { URL url = new URL(urlStr); log.info(\"url: \" + url); URLConnection conn = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); StringBuffer buf = new StringBuffer(); String inputLine; while ((inputLine = in.readLine()) != null) { buf.append(inputLine); } in.close(); return buf.toString(); }. \nCode2: public static Set<Municipality> getMunicipios(String pURL) { Set<Municipality> result = new HashSet<Municipality>(); String iniCuerr = \"<cuerr>\"; String finCuerr = \"</cuerr>\"; String iniDesErr = \"<des>\"; String finDesErr = \"</des>\"; String iniMun = \"<muni>\"; String finMun = \"</muni>\"; String iniNomMun = \"<nm>\"; String finNomMun = \"</nm>\"; String iniCarto = \"<carto>\"; String iniCodDelMEH = \"<cd>\"; String finCodDelMEH = \"</cd>\"; String iniCodMunMEH = \"<cmc>\"; String finCodMunMEH = \"</cmc>\"; String iniCodProvINE = \"<cp>\"; String finCodProvINE = \"</cp>\"; String iniCodMunINE = \"<cm>\"; String finCodMunINE = \"</cm>\"; boolean error = false; int ini, fin; try { URL url = new URL(pURL); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream())); String str; Municipality municipio; while ((str = br.readLine()) != null) { if (str.contains(iniCuerr)) { ini = str.indexOf(iniCuerr) + iniCuerr.length(); fin = str.indexOf(finCuerr); if (Integer.parseInt(str.substring(ini, fin)) > 0) error = true; } if (error) { if (str.contains(iniDesErr)) { ini = str.indexOf(iniDesErr) + iniDesErr.length(); fin = str.indexOf(finDesErr); throw (new Exception(str.substring(ini, fin))); } } else { if (str.contains(iniMun)) { municipio = new Municipality(); municipio.setCodemunicipalityine(0); municipio.setCodemunicipalitydgc(0); while ((str = br.readLine()) != null && !str.contains(finMun)) { if (str.contains(iniNomMun)) { ini = str.indexOf(iniNomMun) + iniNomMun.length(); fin = str.indexOf(finNomMun); municipio.setMuniName(str.substring(ini, fin).trim()); } if (str.contains(iniCarto)) { if (str.contains(\"URBANA\")) municipio.setIsurban(true); if (str.contains(\"RUSTICA\")) municipio.setIsrustic(true); } if (str.contains(iniCodDelMEH)) { ini = str.indexOf(iniCodDelMEH) + iniCodDelMEH.length(); fin = str.indexOf(finCodDelMEH); municipio.setCodemunicipalitydgc(municipio.getCodemunicipalitydgc() + Integer.parseInt(str.substring(ini, fin)) * 1000); } if (str.contains(iniCodMunMEH)) { ini = str.indexOf(iniCodMunMEH) + iniCodMunMEH.length(); fin = str.indexOf(finCodMunMEH); municipio.setCodemunicipalitydgc(municipio.getCodemunicipalitydgc() + Integer.parseInt(str.substring(ini, fin))); } if (str.contains(iniCodProvINE)) { ini = str.indexOf(iniCodProvINE) + iniCodProvINE.length(); fin = str.indexOf(finCodProvINE); municipio.setCodemunicipalityine(municipio.getCodemunicipalityine() + Integer.parseInt(str.substring(ini, fin)) * 1000); } if (str.contains(iniCodMunINE)) { ini = str.indexOf(iniCodMunINE) + iniCodMunINE.length(); fin = str.indexOf(finCodMunINE); municipio.setCodemunicipalityine(municipio.getCodemunicipalityine() + Integer.parseInt(str.substring(ini, fin))); } municipio.setDescription(); } result.add(municipio); } } } br.close(); } catch (Exception e) { System.err.println(e); } return result; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void loadDefaultSettings(final String configFileName) { InputStream in = null; OutputStream out = null; try { in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES); out = new FileOutputStream(configFileName); IOUtils.copy(in, out); } catch (final Exception e) { log.warn(\"Unable to pull out the default.\", e); throw new RuntimeException(e); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } }. \nCode2: public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException { LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\"); assert (file.exists() && file.isFile()); if (targetDirectory.exists() == false) { LOG.debug(\"Creating target directory.\"); if (targetDirectory.mkdirs() == false) { throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\"); } } ZipInputStream zipin = null; try { zipin = new ZipInputStream(new FileInputStream(file)); ZipEntry entry = null; while ((entry = zipin.getNextEntry()) != null) { LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\"); if (entry.isDirectory()) { LOG.debug(\"Skipping directory.\"); continue; } final File targetFile = new File(targetDirectory, entry.getName()); final File parentTargetFile = targetFile.getParentFile(); if (parentTargetFile.exists() == false) { LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\"); if (parentTargetFile.mkdirs() == false) { throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\"); } } InputStream input = null; FileOutputStream output = null; try { input = zipFile.getInputStream(entry); if (targetFile.createNewFile() == false) { throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\"); } output = new FileOutputStream(targetFile); int readBytes", "ground_truth": "YES", "predict": " = 0; while ((readBytes = input.read()) != -1) { output.write(readBytes); } output.close(); } catch (final Exception e) { throw new BusinessException(\"Error unzipping file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'!\", e); } finally { IOUtils.closeQuietly(input); IOUtils.closeQuietly(output); } }. \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 871, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Test public void testLargePut() throws Throwable { int size = CommonParameters.BLOCK_SIZE; InputStream is = new FileInputStream(_fileName); RepositoryFileOutputStream ostream = new RepositoryFileOutputStream(_nodeName, _putHandle, CommonParameters.local); int readLen = 0; int writeLen = 0; byte[] buffer = new byte[CommonParameters.BLOCK_SIZE]; while ((readLen = is.read(buffer, 0, size)) != -1) { ostream.write(buffer, 0, readLen); writeLen += readLen; } ostream.close(); CCNStats stats = _putHandle.getNetworkManager().getStats(); Assert.assertEquals(0, stats.getCounter(\"DeliverInterestFailed\")); }. \nCode2: public byte process(ProcessorContext<PublishRequest> context) throws InterruptedException, ProcessorException { logger.info(\"MapTileChacheTask:process\"); PublishRequest req = context.getItem().getEntity(); if (StringUtils.isEmpty(req.getBackMap())) return TaskState.STATE_TILE_CACHED; final PublicMapPost post; final GenericDAO<PublicMapPost> postDao = DAOFactory.createDAO(PublicMapPost.class); try { ReadOnlyTransaction.beginTransaction(); } catch (DatabaseException e) { logger.error(\"error\", e); throw new ProcessorException(e); } int numCachedTiles = 0; try { List<MapTile> backTiles = new ArrayList<MapTile>(); post = postDao.findUniqueByCriteria(Expression.eq(\"guid\", req.getPostGuid())); final LatLngRectangle bounds = new LatLngRectangle(new LatLngPoint(post.getSWLat(), post.getSWLon()), new LatLngPoint(post.getNELat(), post.getNELon())); final String backMapGuid = \"gst\"; final XFile dstDir = new XFile(new XFile(Configuration.getInstance().getPublicMapStorage().toString()), backMapGuid); dstDir.mkdir(); for (int z = Math.min(Tile.getOptimalZoom(bounds, 768), 9); z <= 17; z++) { final Tile tileStart = new Tile(bounds.getSouthWest().getLat(), bounds.getSouthWest().getLng(), z); final Tile tileEnd = new Tile(bounds.getNorthEast().getLat(), bounds.getNorthEast().getLng(), z); for (double y = tileEnd.getTileCoord().getY(); y <= tileStart.getTileCoord().getY(); y++) for (double x = tileStart.getTileCoord().getX(); x <= tileEnd.getTileCoord().getX(); x++) { NASAMapTile tile = new NASAMapTile((int) x, (int) y, z); XFile file = new XFile(dstDir, tile.toKeyString()); if (file.exists() && file.isFile()) continue; backTiles.add(tile); } } try { for (MapTile tile : backTiles) { InputStream in = null; OutputStream out = null; final URL url = new URL(tile.getPath()); try { final XFile outFile = new XFile(dstDir, tile.toKeyString()); final URLConnection conn = url.openConnection(); if (conn == null || !conn.getContentType().startsWith(\"image\")) throw new IllegalAccessException(\"onearth.jpl.nasa.gov service returns non-image file, \" + \"content-type='\" + conn.getContentType() + \"'\"); in = conn.getInputStream(); if (in != null) { out = new XFileOutputStream(outFile); IOUtils.copy(in, out); } else throw new IllegalStateException(\"opened stream is null\"); } finally { if (out != null) { out.flush(); out.close(); } if (in != null) in.close(); } if (++numCachedTiles % 100 == 0) { logger.info(numCachedTiles + \" tiles cached\"); } } } catch (Throwable e) { logger.error(\"map tile caching has failed: \", e); throw new ProcessorException(e); } } catch (ProcessorException e) { logger.error(\"map tile caching has failed: \", e); throw e; } catch (Throwable e) { logger.error(\"map tile caching has failed: \", e); throw new ProcessorException(e); } finally { ReadOnlyTransaction.closeTransaction(); logger.info(numCachedTiles + \" tiles cached\"); } return TaskState.STATE_TILE_CACHED; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String hashStringMD5(String string) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(string.getBytes()); byte byteData[] = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } StringBuffer hexString = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) hexString.append('0'); hexString.append(hex); } return hexString.toString(); }. \nCode2: private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception { Properties list = new Properties(); list.load(new FileInputStream(fileWithListOfImages)); long current = 0; long startTime = System.currentTimeMillis(); System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir); System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\"); System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\"); for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\"); } for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); URL url = new URL(uriPrefix + urlString); File file = new File(outputDir + \"/\" + imageNameToFileName(urlString)); current++; if (!file.exists()) { try { BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000); int c; while ((c = in.read()) != -1) { out.write(c); } out.close(); in.close(); System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \"); System.out.println(\"saved\"); } catch (Exception e) { System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage()); } } else", "ground_truth": "NO", "predict": " { System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", skipped\"); } System.out.println(\"Time taken: \" + (System.currentTimeMillis() - startTime) / 1000 + \" secs\"); }. \nprivate static String imageNameToFileName(String urlString) { String name = urlString.substring(urlString.lastIndexOf('/') + 1); return name.replace('-', '_'); }. \npublic static void main(String[] args) throws Exception { downloadImages(\"http://www.example.com/images/\", \"list.txt\", \"./output\"); }!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 932, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void unpackBundle() throws IOException { File useJarPath = null; if (DownloadManager.isWindowsVista()) { useJarPath = lowJarPath; File jarDir = useJarPath.getParentFile(); if (jarDir != null) { jarDir.mkdirs(); } } else { useJarPath = jarPath; } DownloadManager.log(\"Unpacking \" + this + \" to \" + useJarPath); InputStream rawStream = new FileInputStream(localPath); JarInputStream in = new JarInputStream(rawStream) { public void close() throws IOException { } }; try { File jarTmp = null; JarEntry entry; while ((entry = in.getNextJarEntry()) != null) { String entryName = entry.getName(); if (entryName.equals(\"classes.pack\")) { File packTmp = new File(useJarPath + \".pack\"); packTmp.getParentFile().mkdirs(); DownloadManager.log(\"Writing temporary .pack file \" + packTmp); OutputStream tmpOut = new FileOutputStream(packTmp); try { DownloadManager.send(in, tmpOut); } finally { tmpOut.close(); } jarTmp = new File(useJarPath + \".tmp\"); DownloadManager.log(\"Writing temporary .jar file \" + jarTmp); unpack(packTmp, jarTmp); packTmp.delete(); } else if (!entryName.startsWith(\"META-INF\")) { File dest; if (DownloadManager.isWindowsVista()) { dest = new File(lowJavaPath, entryName.replace('/', File.separatorChar)); } else { dest = new File(DownloadManager.JAVA_HOME, entryName.replace('/', File.separatorChar)); } if (entryName.equals(BUNDLE_JAR_ENTRY_NAME)) dest = useJarPath; File destTmp = new File(dest + \".tmp\"); boolean exists = dest.exists(); if (!exists) { DownloadManager.log(dest + \".mkdirs()\"); dest.getParentFile().mkdirs(); } try { DownloadManager.log(\"Using temporary file \" + destTmp); FileOutputStream out = new FileOutputStream(destTmp); try { byte[] buffer = new byte[2048]; int c; while ((c = in.read(buffer)) > 0) out.write(buffer, 0, c); } finally { out.close(); } if (exists) dest.delete(); DownloadManager.log(\"Renaming from \" + destTmp + \" to \" + dest); if (!destTmp.renameTo(dest)) { throw new IOException(\"unable to rename \" + destTmp + \" to \" + dest); } } catch (IOException e) { if (!exists) throw e; } } } if (jarTmp != null) { if (useJarPath.exists()) jarTmp.delete(); else if (!jarTmp.renameTo(useJarPath)) { throw new IOException(\"unable to rename \" + jarTmp + \" to \" + useJarPath); } } if (DownloadManager.isWindowsVista()) { DownloadManager.log(\"Using broker to move \" + name); if (!DownloadManager.moveDirWithBroker(DownloadManager.getKernelJREDir() + name)) { throw new IOException(\"unable to create \" + name); } DownloadManager.log(\"Broker finished \" + name); } DownloadManager.log(\"Finished unpacking \" + this); } finally { rawStream.close(); } if (deleteOnInstall) { localPath.delete(); } }. \nCode2: public static void concatenateOutput(File[] inputFiles, File outputFile) { int numberOfInputFiles = inputFiles.length; byte lf = (byte) '\\n'; try { FileOutputStream fos = new FileOutputStream(outputFile); FileChannel outfc = fos.getChannel(); System.out.println(\"Processing \" + inputFiles[0].getPath()); FileInputStream fis = new FileInputStream(inputFiles[0]); FileChannel infc = fis.getChannel(); int bufferCapacity = 100000; ByteBuffer bb = ByteBuffer.allocate(bufferCapacity); bb.clear(); while (infc.read(bb) > 0) { bb.flip(); outfc.write(bb); bb.clear(); } infc.close(); for (int f = 1; f < numberOfInputFiles; f++) { System.out.println(\"Processing \" + inputFiles[f].getPath()); fis = new FileInputStream(inputFiles[f]); infc = fis.getChannel(); bb.clear(); int bytesread = infc.read(bb); bb.flip(); byte b = bb.get(); while (b != lf) { b = bb.get(); } outfc.write(bb); bb.clear(); while (infc.read(bb) > 0) { bb.flip(); outfc.write(bb); bb.clear(); } infc.close(); } outfc.close(); } catch (IOException e) { e.printStackTrace(); System.exit(-1); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void retrieveFile(URL url, RSLink link) { link.setStatus(RSLink.STATUS_DOWNLOADING); HttpURLConnection httpConn = null; DataOutputStream outs = null; BufferedInputStream bins = null; BufferedOutputStream bouts = null; try { String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\"); httpConn = (HttpURLConnection) url.openConnection(); httpConn.setRequestMethod(\"POST\"); httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length)); httpConn.setRequestProperty(\"Content-Language\", \"en-US\"); httpConn.setDoOutput(true); httpConn.setDoInput(true); outs = new DataOutputStream(httpConn.getOutputStream()); outs.writeBytes(postData); outs.flush(); Pattern mimePattern = Pattern.compile(\".+/html.+\"); Matcher matcher = mimePattern.matcher(httpConn.getContentType()); if (matcher.find()) { log(\"Can not download, maybe all RS slots are busy!\"); return; } link.setSize(httpConn.getContentLength()); bins = new BufferedInputStream(httpConn.getInputStream(), 4096); bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096); link.setStatus(RSLink.STATUS_DOWNLOADING); link.setDown(0); byte[] byteBuffer = new byte[4096]; int count; while ((count = bins.read(byteBuffer)) != -1) { bouts.write(byteBuffer, 0, count); link.setDown(link.getDown() + count); if (!Main.start.get()) { link.setStatus(RSLink.STATUS_NOTHING); return; } } link.setStatus(RSLink.STATUS_DONE); } catch (IOException ex) { log(\"I/O Exception!\"); link.setStatus(RSLink.STATUS_NOTHING); } finally { try { if (outs != null) outs.close(); if (bouts != null) bouts.close(); if (bins != null) bins.close(); } catch (IOException ex) { J", "ground_truth": "NO", "predict": "OptionPane.showMessageDialog(null, ex.getMessage(), \"Error\", JOptionPane.WARNING_MESSAGE); } }. \nCode2: public static void retrieveFile(URL url, RSLink link) { link.setStatus(RSLink.STATUS_DOWNLOADING); HttpURLConnection httpConn = null; DataOutputStream outs = null; BufferedInputStream bins = null; BufferedOutputStream bouts = null; try { String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\"); httpConn = (HttpURLConnection) url.openConnection(); httpConn.setRequestMethod(\"POST\"); httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));"}, {"ID": 996, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String computeDigest(String str, String alg) { MessageDigest currentAlgorithm = null; try { currentAlgorithm = MessageDigest.getInstance(alg); } catch (NoSuchAlgorithmException e) { return str; } currentAlgorithm.reset(); currentAlgorithm.update(str.getBytes()); byte[] hash = currentAlgorithm.digest(); String d = \"\"; int usbyte = 0; for (int i = 0; i < hash.length; i++) { usbyte = hash[i] & 0xFF; if (usbyte < 16) d += \"0\" + Integer.toHexString(usbyte); else d += Integer.toHexString(usbyte); } return d.toUpperCase(); }. \nCode2: private void connect(URL url) throws IOException { String protocol = url.getProtocol(); if (!protocol.equals(\"http\")) throw new IllegalArgumentException(\"URL must use 'http:' protocol\"); int port = url.getPort(); if (port == -1) port = 80; fileName = url.getFile(); conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"POST\"); conn.setDoOutput(true); conn.setDoInput(true); toServer = new OutputStreamWriter(conn.getOutputStream()); fromServer = conn.getInputStream(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) { log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); outageUpdater.setString(4, ipAddr); outageUpdater.setLong(5, serviceID); outageUpdater.executeUpdate(); outageUpdater.close(); try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } else { log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\"); } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \nCode2: public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) { int intResult = 0; String sql = \"UPDATE torneo\" + \" SET numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "YES", "predict": "true.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1052, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void service(TranslationRequest request, TranslationResponse response) { try { Thread.sleep((long) Math.random() * 250); } catch (InterruptedException e1) { } hits.incrementAndGet(); String key = getKey(request); RequestResponse cachedResponse = cache.get(key); if (cachedResponse == null) { response.setEndState(new ResponseStateBean(ResponseCode.ERROR, \"response not found for \" + key)); return; } response.addHeaders(cachedResponse.getExpectedResponse().getHeaders()); response.setTranslationCount(cachedResponse.getExpectedResponse().getTranslationCount()); response.setFailCount(cachedResponse.getExpectedResponse().getFailCount()); if (cachedResponse.getExpectedResponse().getLastModified() != -1) { response.setLastModified(cachedResponse.getExpectedResponse().getLastModified()); } try { OutputStream output = response.getOutputStream(); InputStream input = cachedResponse.getExpectedResponse().getInputStream(); try { IOUtils.copy(input, output); } finally { IOUtils.closeQuietly(input); IOUtils.closeQuietly(output); } } catch (IOException e) { response.setEndState(new ResponseStateException(e)); return; } response.setEndState(cachedResponse.getExpectedResponse().getEndState()); }. \nCode2: protected long loadFromSource(long afterThisTime) { long startTime = System.currentTimeMillis(); QuoteDataSourceDescriptor quoteDataSourceDescriptor = (QuoteDataSourceDescriptor) dataSourceDescriptor; List<Quote> dataPool = dataPools.get(quoteDataSourceDescriptor.sourceSymbol); Calendar calendar = Calendar.getInstance(); calendar.clear(); SimpleDateFormat sdf = new SimpleDateFormat(quoteDataSourceDescriptor.dateFormat, Locale.US); Date fromDate = new Date(); Date toDate = new Date(); if (afterThisTime == FIRST_TIME_LOAD) { fromDate = quoteDataSourceDescriptor.fromDate; toDate = quoteDataSourceDescriptor.toDate; } else { calendar.setTimeInMillis(afterThisTime); fromDate = calendar.getTime(); } calendar.setTime(fromDate); int a = calendar.get(Calendar.MONTH); int b = calendar.get(Calendar.DAY_OF_MONTH); int c = calendar.get(Calendar.YEAR); calendar.setTime(toDate); int d = calendar.get(Calendar.MONTH); int e = calendar.get(Calendar.DAY_OF_MONTH); int f = calendar.get(Calendar.YEAR); BufferedReader dis; StringBuffer urlStr = new StringBuffer(); urlStr.append(\"http://table.finance.yahoo.com/table.csv\").append(\"?s=\"); urlStr.append(quoteDataSourceDescriptor.sourceSymbol); urlStr.append(\"&a=\" + a + \"&b=\" + b + \"&c=\" + c + \"&d=\" + d + \"&e=\" + e + \"&f=\" + f); urlStr.append(\"&g=d&ignore=.csv\"); try { URL url = new URL(urlStr.toString()); System.out.println(url); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setAllowUserInteraction(true); conn.setRequestMethod(\"GET\"); conn.setInstanceFollowRedirects(true); InputStreamReader isr = new InputStreamReader(conn.getInputStream()); dis = new BufferedReader(isr); String s = dis.readLine(); int iDateTime = 0; int iOpen = 1; int iHigh = 2; int iLow = 3; int iClose = 4; int iVolume = 5; int iAdjClose = 6; count = 0; calendar.clear(); while ((s = dis.readLine()) != null) { String[] items; items = s.split(\",\"); if (items.length < 6) { break; } Date date = null; try { date = sdf.parse(items[iDateTime].trim()); } catch (ParseException ex) { ex.printStackTrace(); continue; } calendar.clear(); calendar.setTime(date); long time = calendar.getTimeInMillis(); if (time <= afterThisTime) { continue; } Quote quote = new Quote(); quote.time = time; quote.open = Float.parseFloat(items[iOpen].trim()); quote.high = Float.parseFloat(items[iHigh].trim()); quote.low = Float.parseFloat(items[iLow].trim()); quote.close = Float.parseFloat(items[iClose].trim()); quote.volume = Float.parseFloat(items[iVolume].trim()) / 100f; quote.amount = -1; quote.close_adj = Float.parseFloat(items[iAdjClose].trim()); if (quote.high * quote.low * quote.close == 0) { quote = null; continue; } dataPool.add(quote); if (count == 0) { firstTime = time; } lastTime = time; setAscending((lastTime >= firstTime) ? true : false); count++; } } catch (Exception ex) { System.out.println(\"Error in Reading File: \" + ex.getMessage()); } long newestTime = (lastTime >= firstTime) ? lastTime : firstTime; return newestTime; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static File getZipAsFile(DigitalObject digOb) { String folderName = randomizeFileName(getFolderNameFromDigObject(digOb)); File tmpFolder = new File(utils_tmp, folderName); File zip = null; try { FileUtils.forceMkdir(tmpFolder); zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null)); FileOutputStream out = new FileOutputStream(zip); IOUtils.copyLarge(digOb.getContent().getInputStream(), out); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return zip; }. \nCode2: public static String generate(boolean secure, boolean sep) throws UnknownHostException { MessageDigest messagedigest; StringBuilder stringbuffer = new StringBuilder(); try { messagedigest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException nosuchalgorithmexception) { throw new RuntimeException(nosuchalgorithmexception); } StringBuffer stringbuffer2; InetAddress inetaddress = InetAddress.getLocalHost(); long l = System.currentTimeMillis(); long l1 = 0L; if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong(); stringbuffer.append(inetaddress.toString()); stringbuffer.append(\":\"); stringbuffer.append(Long.toString(l)); stringbuffer.append(\":\"); stringbuffer.append(Long.toString(l1)); messagedigest.update(stringbuffer.toString().getBytes()); byte abyte0[] = messagedigest.digest(); StringBuffer stringbuffer1 = new StringBuffer(); for (int i = 0; i < abyte0.length; i++) { int j = abyte0[i] & 0xff; if (j < 16) stringbuffer1.append('0'); stringbuffer1.append(Integer.toHexString(j)); } String s = stringbuffer1.to", "ground_truth": "NO", "predict": "String(); if (sep) { stringbuffer2 = new StringBuffer(); for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == ':') { stringbuffer2.append(\"\\\\x3a\"); } else { stringbuffer2.append(s.charAt(i)); } } s = stringbuffer2.toString(); } return s; \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1090, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void serializeWithClass(Class theClass, int count, String comment) { for (int c = 0; c < 10; c++) { if (c == 9) { beginAction(1, \"persistence write/read\", count, comment); } String tempFile = \".tmp.archive\"; SerializeClassInterface theInstance = null; try { theInstance = (SerializeClassInterface) theClass.newInstance(); } catch (Exception e) { e.printStackTrace(); } if (theInstance == null) { System.err.println(\"error: Couldn't initialize class to \" + \"be serialized!\"); return; } reset(); for (int i = 0; i < count; i++) { try { FileOutputStream fout = new FileOutputStream(tempFile); BufferedOutputStream bout = new BufferedOutputStream(fout); ObjectOutputStream oout = new ObjectOutputStream(bout); oout.writeObject(theInstance); oout.flush(); oout.close(); } catch (IOException ioe) { System.err.println(\"serializing: \" + tempFile + \":\" + ioe.toString()); } try { FileInputStream fin = new FileInputStream(tempFile); BufferedInputStream bin = new BufferedInputStream(fin); ObjectInputStream oin = new ObjectInputStream(bin); theInstance = (SerializeClassInterface) oin.readObject(); oin.close(); } catch (Exception e) { System.err.println(\"deserializing: \" + tempFile + \":\" + e.toString()); break; } proceed(); } reset(); if (c == 9) { endAction(); } } }. \nCode2: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { s. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) { try { System.out.println(\"Testing \" + mapSource.toString()); int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2); MapSpace mapSpace = mapSource.getMapSpace(); int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize(); int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize(); url = new URL(mapSource.getTileUrl(zoom, tilex, tiley)); System.out.println(\"Sample url: \" + url); c = (HttpURLConnection) url.openConnection(); System.out.println(\"Connecting...\"); c.connect(); System.out.println(\"Connection established - response HTTP \" + c.getResponseCode()); if (c.getResponseCode()!= 200) return; String contentType = c.getContentType(); System.out.print(\"Image format : \"); if (\"image/png\".equals(contentType)) System.out.println(\"png\"); else if (\"image/jpeg\".equals(contentType)) System.out.println(\"jpg\"); else System.out.println(\"unknown\"); String eTag = c.getHeaderField(\"ETag\"); boolean eTagSupported = (eTag!= null); if (eTagSupported) { System.out.println(\"eTag : \" + eTag); testIfNoneMatch(); } else System.out.println(\"eTag : -\"); long date = c.getDate(); if (date == 0) System.out.println(\"Date time : -\"); else System.out.println(\"Date time : \" + new Date(date)); long exp = c.getExpiration(); if (exp == 0) System.out.println(\"Expiration time : -\"); else System.out.println(\"Expiration time : \" + new Date(exp)); long modified = c.getLastModified(); if (modified == 0) System.out.println(\"Last modified time : not set\"); else System.out.println(\"Last modified time : \" + new Date(modified)); testIfMod. \nCode2: public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) { int intResult = 0; String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \", color = \" + color + \", flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "NO", "predict": "true!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1104, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String args[]) { try { URL url = new URL(\"http://dev.activeanalytics.ca/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=17&m=2&s=16&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=0&m=22&s=1&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3A%2F%2Flyricscatcher.sourceforge.net%2Fcomputeracces.html&action_name=&idsite=1&res=1440x900&h=0&m=28&s=36&fla=1&dir=1&qt=1&realp=0&pdf=1&wma=1&java=1&cookie=1&title=&urlref=\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \nCode2: private static String fetchUrl(String url, boolean keepLineEnds) throws IOException, MalformedURLException { URLConnection destConnection = (new URL(url)).openConnection(); BufferedReader br; String inputLine; StringBuffer doc = new StringBuffer(); String contentEncoding; destConnection.setRequestProperty(\"Accept-Encoding\", \"gzip\"); if (proxyAuth != null) destConnection.setRequestProperty(\"Proxy-Authorization\", proxyAuth); destConnection.connect(); contentEncoding = destConnection.getContentEncoding(); if ((contentEncoding != null) && contentEncoding.equals(\"gzip\")) { br = new BufferedReader(new InputStreamReader(new GZIPInputStream(destConnection.getInputStream()))); } else { br = new BufferedReader(new InputStreamReader(destConnection.getInputStream())); } while ((inputLine = br.readLine()) != null) { if (keepLineEnds) doc.append(inputLine + \"\\n\"); else doc.append(inputLine); } br.close(); return doc.toString(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @TestProperties(name = \"Simple test for adding different image files to report as link\") public void testAddLinkToImage() throws Exception { InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\"); report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\"))); report.addLink(\"Link to JPG\", \"splash.jpg\"); report.addLink(\"Link to PNG\", \"blue.png\"); report.addLink(\"Link to GIF\", \"classDir.gif\"); }. \nCode2: public void deleteAuthors() throws Exception { if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\"); String[] pids = proposalIds.split(\",\"); String[] uids = usrIds.split(\",\"); int pnum = pids.length; int unum = uids.length; if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\"); int i, j; PreparedStatement prepStmt = null; try { con = database.getConnection(); con.setAutoCommit(false); String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\"; prepStmt = con.prepareStatement(pStr); for (i = 0; i < pnum; i++) { for (j = 0; j < unum; j++) { if (!uids[j].equals(userId)) { prepStmt.setString(1, pids[i]); prepStmt.setString(2, uids[j]); prepStmt.executeUpdate(); } } } con.commit(); } catch (Exception e) { if (!con.isClosed()) { con.rollback(); prepStmt.close();", "ground_truth": "NO", "predict": " con.close(); } throw e; } finally { prepStmt.close(); con.close(); } }. \n}"}, {"ID": 1137, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void loadDBpediaOntology() { try { URL url = new URL(\"http://downloads.dbpedia.org/3.6/dbpedia_3.6.owl.bz2\"); InputStream is = new BufferedInputStream(url.openStream()); CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is); dbPediaOntology = OWLManager.createOWLOntologyManager().loadOntologyFromOntologyDocument(in); reasoner = PelletReasonerFactory.getInstance().createNonBufferingReasoner(dbPediaOntology); reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (CompressorException e) { e.printStackTrace(); } catch (OWLOntologyCreationException e) { e.printStackTrace(); } }. \nCode2: @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.listview); HttpGet request = new HttpGet(SERVICE_URI + \"/json/getroutes/1\"); request.setHeader(\"Accept\", \"application/json\"); request.setHeader(\"Content-type\", \"application/json\"); DefaultHttpClient httpClient = new DefaultHttpClient(); String theString = new String(\"\"); try { HttpResponse response = httpClient.execute(request); HttpEntity responseEntity = response.getEntity(); InputStream stream = responseEntity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); Vector<String> vectorOfStrings = new Vector<String>(); String tempString = new String(); String tempStringAgent = new String(); String tempStringClient = new String(); String tempStringRoute = new String(); String tempStringZone = new String(); StringBuilder builder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { builder.append(line); } stream.close(); theString = builder.toString(); JSONObject json = new JSONObject(theString); Log.i(\"_GetClient_\", \"<jsonobject> \\n \" + json.toString() + \" \\n </jsonobject>\"); this.dm = new DataManipulator(this); JSONArray nameArray = json.getJSONArray(\"GetRoutesByAgentResult\"); for (int i = 0; i < nameArray.length(); i++) { tempStringAgent = nameArray.getJSONObject(i).getString(\"Agent\"); tempStringClient = nameArray.getJSONObject(i).getString(\"Client\"); tempStringRoute = nameArray.getJSONObject(i).getString(\"Route\"); tempStringZone = nameArray.getJSONObject(i).getString(\"Zone\"); Log.i(\"_GetClient_\", \"<Agent\" + i + \">\" + tempStringAgent + \"</Agent\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Client\" + i + \">\" + tempStringClient + \"</Client\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Route\" + i + \">\" + tempStringRoute + \"</Route\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Zone\" + i + \">\" + tempStringZone + \"</Zone\" + i + \">\\n\"); this.dm.insertIntoClients(tempStringAgent, tempStringClient, tempStringRoute, tempStringZone); tempString = nameArray.getJSONObject(i).getString(\"Client\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Route\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Zone\"); vectorOfStrings.add(new String(tempString)); } int orderCount = vectorOfStrings.size(); String[] orderTimeStamps = new String[orderCount]; vectorOfStrings.copyInto(orderTimeStamps); setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, orderTimeStamps)); } catch (Exception e) { e.printStackTrace(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1 < 0) { continue; } String bundleSymbolicName = line.substring(0, pos1); String bundleName = line.substring(pos1 + 1); for (BundleInfo info : list) { if (info.bundleSymbolicName.equals(bundleSymbolicName)) { info.bundleName = bundleName; break; } } } return true; } catch (IOException e) { e.printStackTrace(); } return false; }. \nCode2: public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception { pAndamento.delimitarIntervaloDeVariacao(0, 49); WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento); pAndamento.delimitarIntervaloDeVariacao(50, 100); if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) { String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\"; OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql); stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE); int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length; try { int quantidadeDeRegistrosImportados = 0; int numeroDoRegistro = 0; for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) { ++numeroDoRegistro; stmtDestino.clearParameters(); int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia(); Calendar calendario = Calendar.getInstance(); calendario.clear(); calendario.set(ano, mes, dia); java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis()); BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor(); stmtDestino.setDateAtName(\"DATA\", vDATA); stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO); int contagemDasInsercoes = stmtDestino.executeUpdate(); quantidadeDeRegistrosImportados++; double percentualCompleto = (double) quantidadeDeRegist", "ground_truth": "NO", "predict": "rosImportados / (double) quantidadeDeRegistrosASeremImportados * 100; if (contagemDasInsercoes > 0) { System.out.println(\"Importacao de \" + quantidadeDeRegistrosImportados + \" registros de \" + quantidadeDeRegistrosASeremImportados + \" registros, com \" + (int) (percentualCompleto) + \"% de importacao.\"); } else { System.out.println(\"Nao foram importados registros.\"); } } catch (SQLException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } }. \npublic void obterCotacoesPendentesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception { pAndamento.delimitarIntervaloDeVariacao(0, 49"}, {"ID": 1139, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public ActionForward dbExecute(ActionMapping pMapping, ActionForm pForm, HttpServletRequest pRequest, HttpServletResponse pResponse) throws DatabaseException { String email = pRequest.getParameter(\"email\"); MessageDigest md; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { throw new DatabaseException(\"Could not hash password for storage: no such algorithm\"); } md.update(pRequest.getParameter(\"password\").getBytes()); String password = (new BASE64Encoder()).encode(md.digest()); String remember = pRequest.getParameter(\"rememberLogin\"); User user = database.acquireUserByEmail(email); if (user == null || user.equals(User.anonymous()) || !user.getActive()) { return pMapping.findForward(\"invalid\"); } else if (user.getPassword().equals(password)) { pRequest.getSession().setAttribute(\"login\", user); if (remember != null) { Cookie usercookie = new Cookie(\"bib.username\", email); Cookie passcookie = new Cookie(\"bib.password\", password.toString()); usercookie.setPath(\"/\"); passcookie.setPath(\"/\"); usercookie.setMaxAge(60 * 60 * 24 * 365); passcookie.setMaxAge(60 * 60 * 24 * 365); pResponse.addCookie(usercookie); pResponse.addCookie(passcookie); } return pMapping.findForward(\"success\"); } else { return pMapping.findForward(\"invalid\"); } }. \nCode2: public static void main(String[] a) { ArrayList<String> allFilesToBeCopied = new ArrayList<String>(); new File(outputDir).mkdirs(); try { FileReader fis = new FileReader(completeFileWithDirToCathFileList); BufferedReader bis = new BufferedReader(fis); String line = \"\"; String currentCombo = \"\"; while ((line = bis.readLine()) != null) { String[] allEntries = line.split(\"\\\\s+\"); String fileName = allEntries[0]; String thisCombo = allEntries[1] + allEntries[2] + allEntries[3] + allEntries[4]; if (currentCombo.equals(thisCombo)) { } else { System.out.println(\"merke: \" + fileName); allFilesToBeCopied.add(fileName); currentCombo = thisCombo; } } System.out.println(allFilesToBeCopied.size()); for (String file : allFilesToBeCopied) { try { FileChannel srcChannel = new FileInputStream(CathDir + file).getChannel(); FileChannel dstChannel = new FileOutputStream(outputDir + file).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException e) { e.printStackTrace(); } } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException { File f = new File(path); String entryName = base + f.getName(); FileInputStream goIn = new FileInputStream(f); TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName); taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU); taro.putArchiveEntry(tarEntry); if (f.isFile()) { IOUtils.copy(goIn, taro); taro.closeArchiveEntry(); } else { taro.closeArchiveEntry(); File[] children = f.listFiles(); if (children != null) { for (File child : children) { addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\"); } } } taro.close(); goIn.close(); }. \nCode2: public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) { int intResult = 0; String sql = \"UPDATE torneo\" + \" SET numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "NO", "predict": "true.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1163, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void copyFile(File in, File out) throws IOException { FileChannel inChannel = new FileInputStream(in).getChannel(); FileChannel outChannel = new FileOutputStream(out).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } catch (IOException e) { throw e; } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } }. \nCode2: public void testEmptyBlock_01() throws Exception { EXISchema corpus = EXISchemaFactoryTestUtil.getEXISchema(\"/compression/emptyBlock_01.xsd\", getClass(), m_compilerErrors); Assert.assertEquals(0, m_compilerErrors.getTotalCount()); GrammarCache grammarCache = new GrammarCache(corpus, GrammarOptions.STRICT_OPTIONS); Transmogrifier encoder = new Transmogrifier(); EXIDecoder decoder = new EXIDecoder(31); Scanner scanner; InputSource inputSource; encoder.setOutputOptions(HeaderOptionsOutputType.lessSchemaId); encoder.setAlignmentType(AlignmentType.compress); encoder.setBlockSize(1); encoder.setEXISchema(grammarCache); ByteArrayOutputStream baos = new ByteArrayOutputStream(); encoder.setOutputStream(baos); URL url = resolveSystemIdAsURL(\"/compression/emptyBlock_01.xml\"); inputSource = new InputSource(url.toString()); inputSource.setByteStream(url.openStream()); byte[] bts; int n_events; encoder.encode(inputSource); bts = baos.toByteArray(); decoder.setEXISchema(grammarCache); decoder.setInputStream(new ByteArrayInputStream(bts)); scanner = decoder.processHeader(); ArrayList<EXIEvent> exiEventList = new ArrayList<EXIEvent>(); EXIEvent exiEvent; n_events = 0; while ((exiEvent = scanner.nextEvent()) != null) { ++n_events; exiEventList.add(exiEvent); } Assert.assertEquals(11, n_events); Assert.assertEquals(1, ((ChannellingScanner) scanner).getBlockCount()); EventType eventType; EventTypeList eventTypeList; int pos = 0; exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SD, exiEvent.getEventVariety()); eventType = exiEvent.getEventType(); Assert.assertSame(exiEvent, eventType); Assert.assertEquals(0, eventType.getIndex()); eventTypeList = eventType.getEventTypeList(); Assert.assertNull(eventTypeList.getEE()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"root\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"parent\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"child\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_CH, exiEvent.getEventVariety()); Assert.assertEquals(\"42\", exiEvent.getCharacters().makeString()); int tp = ((EventTypeSchema) exiEvent.getEventType()).getSchemaSubstance(); Assert.assertEquals(EXISchemaConst.UNSIGNED_BYTE_TYPE, corpus.getSerialOfType(tp)); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"adjunct\", exiEvent.getName()); Assert.assertEquals(\"\", exiEvent.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_ED, exiEvent.getEventVariety()); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException { final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder(); final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath); final Multimap<String, String> proteins = HashMultimap.create(); for (final String query : queries) { HttpURLConnection connection = null; try { final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\"); final URL url = new URL(String.format(__urlTempl2, encoded, taxon)); connection = (HttpURLConnection) url.openConnection(); connection.setConnectTimeout(__connTimeout); connection.setReadTimeout(__readTimeout); connection.setRequestProperty(\"Connection\", \"close\"); connection.connect(); final InputStream stream = connection.getInputStream(); final Document doc = parser.parse(stream); final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET); if (nodes != null) { final int n = nodes.getLength(); for (int i = 0; i < n; i++) { final Node node = nodes.item(i); proteins.put(node.getTextContent().trim(), query.trim()); } } } catch (final Exception ex) { continue; } finally { if (connection != null) connection.disconnect(); } } return proteins; }. \nCode2: public static String encryptPassword(String plainPassword) { StringBuffer sb = new StringBuffer(); try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(plainPassword.getBytes()); byte[] digestBytes = messageDigest.digest(); String hex = null; for (int i = 0; i < digestBytes.length; i++) { hex = Integer.toHexString(0xFF & digestBytes[i]); if (hex.length() < 2) sb", "ground_truth": "NO", "predict": ".append('0'); sb.append(hex); } } catch (Exception ex) { ex.printStackTrace(); } return sb.toString(); }. \n\n// Encrypt a password using the MD5 algorithm.\nString encryptPassword(String plainPassword) { StringBuffer sb = new StringBuffer(); try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(plainPassword.getBytes()); byte[] digestBytes = messageDigest.digest(); String hex = null; for (int i = 0; i < digestBytes.length; i++) { hex = Integer.toHexString(0xFF & digestBytes[i]); if (hex.length() < 2) sb.append('0'); sb.append(hex); } } catch (Exception ex) { ex.printStackTrace(); } return sb.toString(); }!!!!!!!!!!!!!!!"}, {"ID": 1183, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override public TDSScene loadScene(URL url) throws IOException, IncorrectFormatException, ParsingErrorException { boolean baseURLWasNull = setBaseURLFromModelURL(url); TDSScene scene = loadScene(url.openStream()); if (baseURLWasNull) { popBaseURL(); } return (scene); }. \nCode2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\"export_page\"); query = query.replace(\"[RANDOM_INT]\", \"\" + random.nextInt()); int statusCode = -1; GetMethod get = new GetMethod(query); if (log.isInfoEnabled()) log.info(\"getting all contacts ...\"); try { statusCode = client.executeMethod(get); if (statusCode != 200) throw new GmailException(\"In contacts export page: Status code expected: 200 -> Status code returned: \" + statusCode); } catch (HttpException e) { throw new GmailException(\"HttpException in contacts export page:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in contacts export page:\" + e.getMessage()); } finally { get.releaseConnection(); } if (log.isTraceEnabled()) log.trace(\"accessing contacts export page successful...\"); String query_post = properties.getString(\"outlook_export_page\"); PostMethod post = new PostMethod(query_post); post.addRequestHeader(\"Accept-Encoding\", \"gzip,deflate\"); post.addRequestHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.8\"); NameValuePair[] data = { new NameValuePair(\"at\", getCookie(\"GMAIL_AT\")), new NameValuePair(\"ecf\", \"o\"), new NameValuePair(\"ac\", \"Export Contacts\") }; post.setRequestBody(data); if (log.isTraceEnabled()) log.trace(\"getting contacts csv file...\"); try { statusCode = client.executeMethod(post); if (statusCode != 200) throw new GmailException(\"In csv file post: Status code expected: 200 -> Status code returned: \" + statusCode); if (log.isTraceEnabled()) log.trace(\"Gmail: csv charset: \" + post.getResponseCharSet()); GMAIL_OUTPUT_CHARSET = post.getResponseCharSet(); InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet()); CSVReader reader = new CSVReader(isr); List csvEntries = reader.readAll(); reader.close(); ArrayList<GmailContact> contacts = new ArrayList<GmailContact>(); MessageDigest m = MessageDigest.getInstance(\"MD5\"); if (log.isTraceEnabled()) log.trace(\"creating Gmail contacts...\"); for (int i = 1; i < csvEntries.size(); i++) { GmailContact contact = new GmailContact(); String[] value = (String[]) csvEntries.get(i); for (int j = 0; j < value.length; j++) { switch(j) { case 0: contact.setName(value[j]); break; case 1: contact.setEmail(value[j]); if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]); break; case 2: contact.setNotes(value[j]); break; case 3: contact.setEmail2(value[j]); break; case 4: contact.setEmail3(value[j]); break; case 5: contact.setMobilePhone(value[j]); break; case 6: contact.setPager(value[j]); break; case 7: contact.setCompany(value[j]); break; case 8: contact.setJobTitle(value[j]); break; case 9: contact.setHomePhone(value[j]); break; case 10: contact.setHomePhone2(value[j]); break; case 11: contact.setHomeFax(value[j]); break; case 12: contact.setHomeAddress(value[j]); break; case 13: contact.setBusinessPhone(value[j]); break; case 14: contact.setBusinessPhone2(value[j]); break; case 15: contact.setBusinessFax(value[j]); break; case 16: contact.setBusinessAddress(value[j]); break; case 17: contact.setOtherPhone(value[j]); break; case 18: contact.setOtherFax(value[j]); break; case 19: contact.setOtherAddress(value[j]); break; } } m.update(contact.toString().getBytes()); if (log.isTraceEnabled()) log.trace(\"setting Md5 Hash...\"); contact.setMd5Hash(new BigInteger(m.digest()).toString()); contacts.add(contact); } if (log.isTraceEnabled()) log.trace(\"Mapping contacts uid...\"); Collections.sort(contacts); ArrayList<GmailContact> idList = getAllContactsID(); for (int i = 0; i < idList.size(); i++) { contacts.get(i).setId(idList.get(i).getId()); } if (log.isInfoEnabled()) log.info(\"getting all contacts info successful...\"); return contacts; } catch (HttpException e) { throw new GmailException(\"HttpException in csv file post:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in csv file post:\" + e.getMessage()); } catch (NoSuchAlgorithmException e) { throw new GmailException(\"No such md5 algorithm \" + e.getMessage()); } finally { post.releaseConnection(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static Properties load(String propsName) { Properties props = new Properties(); URL url = ClassLoader.getSystemResource(propsName); try { props.load(url.openStream()); } catch (IOException e) { e.printStackTrace(); } return props; }. \nCode2: public static void main(String[] argv) { if (1 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).getChannel(); try { source.transferTo(0L, srclen, target); } finally { target.close(); } System.out.printf(\"Updated %s\\n\", tgt.getPath()); File[] deletes = Delete(src, tgt); if (null != deletes) { for (File del : deletes) { if (SVN) { if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } } if (SVN) SvnAdd(tgt); } } finally { source.close(); } } catch (Exception exc) {", "ground_truth": "NO", "predict": " exc.printStackTrace(); } } else { System.out.println(\"Usage: File.path [target]\"); } }. \nCode1: public static Properties load(String propsName) { Properties props = new Properties(); URL url = ClassLoader.getSystemResource(propsName); try { props.load(url.openStream()); } catch (IOException e) { e.printStackTrace(); } return props; }. \nCode2: public static void main(String[] argv) { if (2 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).get"}, {"ID": 1206, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String crypt(String password, String salt) { if (salt.startsWith(magic)) { salt = salt.substring(magic.length()); } int saltEnd = salt.indexOf('$'); if (saltEnd != -1) { salt = salt.substring(0, saltEnd); } if (salt.length() > 8) { salt = salt.substring(0, 8); } MessageDigest md5_1, md5_2; try { md5_1 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } md5_1.update(password.getBytes()); md5_1.update(magic.getBytes()); md5_1.update(salt.getBytes()); try { md5_2 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } md5_2.update(password.getBytes()); md5_2.update(salt.getBytes()); md5_2.update(password.getBytes()); byte[] md5_2_digest = md5_2.digest(); int md5Size = md5_2_digest.length; int pwLength = password.length(); for (int i = pwLength; i > 0; i -= md5Size) { md5_1.update(md5_2_digest, 0, i > md5Size ? md5Size : i); } md5_2.reset(); byte[] pwBytes = password.getBytes(); for (int i = pwLength; i > 0; i >>= 1) { if ((i & 1) == 1) { md5_1.update((byte) 0); } else { md5_1.update(pwBytes[0]); } } StringBuffer output = new StringBuffer(magic); output.append(salt); output.append(\"$\"); byte[] md5_1_digest = md5_1.digest(); byte[] saltBytes = salt.getBytes(); for (int i = 0; i < 1000; i++) { md5_2.reset(); if ((i & 1) == 1) { md5_2.update(pwBytes); } else { md5_2.update(md5_1_digest); } if (i % 3 != 0) { md5_2.update(saltBytes); } if (i % 7 != 0) { md5_2.update(pwBytes); } if ((i & 1) != 0) { md5_2.update(md5_1_digest); } else { md5_2.update(pwBytes); } md5_1_digest = md5_2.digest(); } int value; value = ((md5_1_digest[0] & 0xff) << 16) | ((md5_1_digest[6] & 0xff) << 8) | (md5_1_digest[12] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[1] & 0xff) << 16) | ((md5_1_digest[7] & 0xff) << 8) | (md5_1_digest[13] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[2] & 0xff) << 16) | ((md5_1_digest[8] & 0xff) << 8) | (md5_1_digest[14] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[3] & 0xff) << 16) | ((md5_1_digest[9] & 0xff) << 8) | (md5_1_digest[15] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[4] & 0xff) << 16) | ((md5_1_digest[10] & 0xff) << 8) | (md5_1_digest[5] & 0xff); output.append(cryptTo64(value, 4)); value = md5_1_digest[11] & 0xff; output.append(cryptTo64(value, 2)); md5_1 = null; md5_2 = null; md5_1_digest = null; md5_2_digest = null; pwBytes = null; saltBytes = null; password = salt = null; return output.toString(); }. \nCode2: private void copyFile(String from, String to) throws Exception { URL monitorCallShellScriptUrl = Thread.currentThread().getContextClassLoader().getResource(from); File inScriptFile = null; try { inScriptFile = new File(monitorCallShellScriptUrl.toURI()); } catch (URISyntaxException e) { throw e; } File outScriptFile = new File(to); FileChannel inChannel = new FileInputStream(inScriptFile).getChannel(); FileChannel outChannel = new FileOutputStream(outScriptFile).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } catch (IOException e) { throw e; } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } try { LinuxCommandExecutor cmdExecutor = new LinuxCommandExecutor(); cmdExecutor.setWorkingDirectory(workingDirectory); cmdExecutor.runCommand(\"chmod 777 \" + to); } catch (Exception e) { throw e; } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \nCode2: public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException { ConnectionProvider cp = null; Connection conn = null; ResultSet rs = null; PreparedStatement pstmt = null; PrivilegeFactory factory = PrivilegeFactory.getInstance(); Operation op = factory.createOperation(); try { cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE); conn = cp.getConnection(); try { pstmt = conn.prepareStatement(DEL_ROLE_PERM); pstmt.setString(1, roleid); pstmt.executeUpdate(); } catch (Exception e) { } if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) { return; } else { conn.setAutoCommit(false); pstmt = conn.prepareStatement(ADD_ROLE_PERM); Iterator role_perm_ir = role_perm_collect.iterator(); while (role_perm_ir.hasNext()) { RolePermission rolePerm = (RolePermission) role_perm_ir.next(); pstmt.setString(1, String.valueOf(rolePerm.getRoleid())); pstmt.setString(2, String.valueOf(rolePerm.getResourceid())); pstmt.setString(3, String.valueOf(rolePerm.get", "ground_truth": "NO", "predict": "Action())); pstmt.executeUpdate(); } conn.setAutoCommit(true); } catch (Exception e) { conn.rollback(); throw e; } finally { if (pstmt != null) { pstmt.close(); } if (conn != null) { conn.close(); } if (cp != null) { cp.close(); } } }. \nCode1: public static String cryptTo64(int value, int size) throws NoSuchAlgorithmException, UnsupportedEncodingException { StringBuffer output = new StringBuffer(); for (int i = 0; i < size; i++) { output.append(Base64.charAt(value & 0xFF)); value >>= 8; } return output.toString(); }. \nCode2: public static String cryptTo64(int value, int size) throws NoSuchAlgorithmException, UnsupportedEncodingException { StringBuffer output = new StringBuffer(); for (int i = 0; i < size; i++)"}, {"ID": 1209, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public ActionForward sendTrackback(ActionMapping mapping, ActionForm actionForm, HttpServletRequest request, HttpServletResponse response) throws RollerException { ActionForward forward = mapping.findForward(\"weblogEdit.page\"); ActionErrors errors = new ActionErrors(); WeblogEntryData entry = null; try { RollerRequest rreq = RollerRequest.getRollerRequest(request); if (rreq.isUserAuthorizedToEdit()) { WeblogEntryFormEx form = (WeblogEntryFormEx) actionForm; String entryid = form.getId(); if (entryid == null) { entryid = request.getParameter(RollerRequest.WEBLOGENTRYID_KEY); } RollerContext rctx = RollerContext.getRollerContext(request); WeblogManager wmgr = rreq.getRoller().getWeblogManager(); entry = wmgr.retrieveWeblogEntry(entryid); String title = entry.getTitle(); PageHelper pageHelper = PageHelper.createPageHelper(request, response); pageHelper.setSkipFlag(true); String excerpt = pageHelper.renderPlugins(entry); excerpt = StringUtils.left(Utilities.removeHTML(excerpt), 255); String url = rctx.createEntryPermalink(entry, request, true); String blog_name = entry.getWebsite().getName(); if (form.getTrackbackUrl() != null) { try { String data = URLEncoder.encode(\"title\", \"UTF-8\") + \"=\" + URLEncoder.encode(title, \"UTF-8\"); data += (\"&\" + URLEncoder.encode(\"excerpt\", \"UTF-8\") + \"=\" + URLEncoder.encode(excerpt, \"UTF-8\")); data += (\"&\" + URLEncoder.encode(\"url\", \"UTF-8\") + \"=\" + URLEncoder.encode(url, \"UTF-8\")); data += (\"&\" + URLEncoder.encode(\"blog_name\", \"UTF-8\") + \"=\" + URLEncoder.encode(blog_name, \"UTF-8\")); URL tburl = new URL(form.getTrackbackUrl()); URLConnection conn = tburl.openConnection(); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; StringBuffer resultBuff = new StringBuffer(); while ((line = rd.readLine()) != null) { resultBuff.append(Utilities.escapeHTML(line, true)); resultBuff.append(\"<br />\"); } ActionMessages resultMsg = new ActionMessages(); resultMsg.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"weblogEdit.trackbackResults\", resultBuff)); saveMessages(request, resultMsg); wr.close(); rd.close(); } catch (IOException e) { errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.trackback\", e)); } } else { errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.noTrackbackUrlSpecified\")); } form.setTrackbackUrl(null); } else { forward = mapping.findForward(\"access-denied\"); } } catch (Exception e) { mLogger.error(e); String msg = e.getMessage(); if (msg == null) { msg = e.getClass().getName(); } errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.general\", msg)); } if (!errors.isEmpty()) { saveErrors(request, errors); } request.setAttribute(\"model\", new WeblogEntryPageModel(request, response, mapping, (WeblogEntryFormEx) actionForm, WeblogEntryPageModel.EDIT_MODE)); return forward; }. \nCode2: public static String calculateHash(String data, String algorithm) { if (data == null) { return null; } algorithm = (algorithm == null ? INTERNAL : algorithm.toUpperCase()); if (algorithm.equals(PLAIN)) { return data; } if (algorithm.startsWith(\"{RSA}\")) { return encode(data, algorithm.substring(5), \"RSA\"); } try { MessageDigest md = MessageDigest.getInstance(algorithm); md.update(data.getBytes(\"UTF-8\")); return getHashString(md.digest()); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage()); return null; } catch (NoSuchAlgorithmException nsae) { logger.error(nsae.getMessage()); return null; } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @SuppressWarnings(\"unchecked\") public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException { StringBuilder json = new StringBuilder(); String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key; try { URL url = new URL(requestUrl.toString()); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; while ((inputLine = in.readLine()) != null) { json.append(inputLine); } in.close(); } catch (IOException e) { throw new GtugsException(e); } List<Event> events = new ArrayList<Event>(); JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString()); JSONArray results = (JSONArray) jsonObj.get(\"results\"); for (int i = 0; i < results.size(); i++) { JSONObject result = (JSONObject) results.get(i); Event e = new Event(); e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\"))); e.setCity((String) result.get(\"venue_city\")); e.setDescription((String) result.get(\"description\")); e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\"))); e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\"))); e.setName((String) result.get(\"name\")); Date myDate = null; String time = (String) result.get(\"time\"); try { myDate = meetupDateFormat.parse(time); e.setStartTime(timeDateFormat.format(myDate)); e.setEndTime(timeDateFormat.format(myDate)); e.setStartDate(myDate); e.setEndDate(myDate); String tz = tzDateFormat.format(myDate); if (tz != null && tz.startsWith(\"+\")) { tz = tz.substring(1); } e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100)); } catch (ParseException ex) { ex.printStackTrace(); continue; } e.setState((String) result.get(\"venue_state\")); StringBuilder addressBuilder = new StringBuilder(); if (result.get(\"venue_address1\") != null) { addressBuilder.append((String) result.get(\"venue_address1\") + \" \"); } if (result.get(\"venue_address2\") != null) { addressBuilder.append((String) result.get(\"venue_address2\") + \" \"); } if (result.get(\"venue_address3\") != null) { addressBuilder.append((String) result", "ground_truth": "NO", "predict": ".get(\"venue_address3\") + \" \"); } e.setAddress(addressBuilder.toString()); events.add(e); } return events; }. \n\nCode2: @SuppressWarnings(\"unchecked\") public List<Event> lookupPastEvents(String groupIdentifier) throws GtugsException { StringBuilder json = new StringBuilder(); String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key; try { URL url = new URL(requestUrl.toString()); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; while ((inputLine = in.readLine()) != null) { json.append(inputLine); } in.close(); } catch (IOException e) { throw new GtugsException(e); } List<Event> events = new ArrayList<Event>(); JSONObject jsonObj ="}, {"ID": 1235, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void find(String pckgname, Class tosubclass) { String name = new String(pckgname); if (!name.startsWith(\"/\")) { name = \"/\" + name; } name = name.replace('.', '/'); URL url = RTSI.class.getResource(name); System.out.println(name + \"->\" + url); if (url == null) return; File directory = new File(url.getFile()); if (directory.exists()) { String[] files = directory.list(); for (int i = 0; i < files.length; i++) { if (files[i].endsWith(\".class\")) { String classname = files[i].substring(0, files[i].length() - 6); try { Object o = Class.forName(pckgname + \".\" + classname).newInstance(); if (tosubclass.isInstance(o)) { System.out.println(classname); } } catch (ClassNotFoundException cnfex) { System.err.println(cnfex); } catch (InstantiationException iex) { } catch (IllegalAccessException iaex) { } } } } else { try { JarURLConnection conn = (JarURLConnection) url.openConnection(); String starts = conn.getEntryName(); JarFile jfile = conn.getJarFile(); Enumeration e = jfile.entries(); while (e.hasMoreElements()) { ZipEntry entry = (ZipEntry) e.nextElement(); String entryname = entry.getName(); if (entryname.startsWith(starts) && (entryname.lastIndexOf('/') <= starts.length()) && entryname.endsWith(\".class\")) { String classname = entryname.substring(0, entryname.length() - 6); if (classname.startsWith(\"/\")) classname = classname.substring(1); classname = classname.replace('/', '.'); try { Object o = Class.forName(classname).newInstance(); if (tosubclass.isInstance(o)) { System.out.println(classname.substring(classname.lastIndexOf('.') + 1)); } } catch (ClassNotFoundException cnfex) { System.err.println(cnfex); } catch (InstantiationException iex) { } catch (IllegalAccessException iaex) { } } } } catch (IOException ioex) { System.err.println(ioex); } } }. \nCode2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String transformByMD5(String password) throws XSServiceException { MessageDigest md5; byte[] output; StringBuffer bufferPass; try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e); throw new XSServiceException(\"Database error while saving user\"); } md5.reset(); md5.update(password.getBytes()); output = md5.digest(); bufferPass = new StringBuffer(); for (byte b : output) { bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b)); } return bufferPass.toString(); }. \nCode2: public static String hashStringMD5(String string) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(string.getBytes()); byte byteData[] = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } StringBuffer hexString = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) hexString.append('0'); hexString.append(hex); } return hexString.toString", "ground_truth": "YES", "predict": "(); \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1311, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String arg[]) { try { String readFile = arg[0]; String writeFile = arg[1]; java.io.FileInputStream ss = new java.io.FileInputStream(readFile); ManagedMemoryDataSource ms = new ManagedMemoryDataSource(ss, 1024 * 1024, \"foo/data\", true); javax.activation.DataHandler dh = new javax.activation.DataHandler(ms); java.io.InputStream is = dh.getInputStream(); java.io.FileOutputStream fo = new java.io.FileOutputStream(writeFile); byte[] buf = new byte[512]; int read = 0; do { read = is.read(buf); if (read > 0) { fo.write(buf, 0, read); } } while (read > -1); fo.close(); is.close(); } catch (java.lang.Exception e) { log.error(Messages.getMessage(\"exception00\"), e); } }. \nCode2: public static void getResponseAsStream(String _url, Object _stringOrStream, OutputStream _stream, Map<String, String> _headers, Map<String, String> _params, String _contentType, int _timeout) throws IOException { if (_url == null || _url.length() <= 0) throw new IllegalArgumentException(\"Url can not be null.\"); String temp = _url.toLowerCase(); if (!temp.startsWith(\"http://\") && !temp.startsWith(\"https://\")) _url = \"http://\" + _url; _url = encodeURL(_url); HttpMethod method = null; if (_stringOrStream == null && (_params == null || _params.size() <= 0)) method = new GetMethod(_url); else method = new PostMethod(_url); HttpMethodParams methodParams = ((HttpMethodBase) method).getParams(); if (methodParams == null) { methodParams = new HttpMethodParams(); ((HttpMethodBase) method).setParams(methodParams); } if (_timeout < 0) methodParams.setSoTimeout(0); else methodParams.setSoTimeout(_timeout); if (_contentType != null && _contentType.length() > 0) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"Content-Type\", _contentType); } if (_headers == null || !_headers.containsKey(\"User-Agent\")) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"User-Agent\", DEFAULT_USERAGENT); } if (_headers != null) { Iterator<Map.Entry<String, String>> iter = _headers.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); method.setRequestHeader((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof PostMethod && (_params != null && _params.size() > 0)) { Iterator<Map.Entry<String, String>> iter = _params.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); ((PostMethod) method).addParameter((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof EntityEnclosingMethod && _stringOrStream != null) { if (_stringOrStream instanceof InputStream) { RequestEntity entity = new InputStreamRequestEntity((InputStream) _stringOrStream); ((EntityEnclosingMethod) method).setRequestEntity(entity); } else { RequestEntity entity = new StringRequestEntity(_stringOrStream.toString(), _contentType, null); ((EntityEnclosingMethod) method).setRequestEntity(entity); } } HttpClient httpClient = new HttpClient(new org.apache.commons.httpclient.SimpleHttpConnectionManager()); httpClient.getParams().setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true); InputStream instream = null; try { int status = httpClient.executeMethod(method); if (status != HttpStatus.SC_OK) { LOG.warn(\"Http Satus:\" + status + \",Url:\" + _url); if (status >= 500 && status < 600) throw new IOException(\"Remote service<\" + _url + \"> respose a error, status:\" + status); } instream = method.getResponseBodyAsStream(); IOUtils.copy(instream, _stream); } catch (IOException err) { LOG.error(\"Failed to access \" + _url, err); throw err; } finally { IOUtils.closeQuietly(instream); if (method != null) method.releaseConnection(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void update(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try { dbo = (ERDBOperation) createDBOperation(); String url = \"\"; boolean flag = true; StringTokenizer st = null; conn = dbo.getConnection(); conn.setAutoCommit(false); ps = conn.prepareStatement(sqlInitial); rs = ps.executeQuery(); if (rs.next()) url = rs.getString(1); if (!url.equals(\"\")) { st = new StringTokenizer(url, \",\"); String sortDocId = \"\"; while (st.hasMoreTokens()) { if (flag) { sortDocId = \"'\" + st.nextToken() + \"'\"; flag = false; } else { sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\"; } } String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField; ps = conn.prepareStatement(sqlsort); rs = ps.executeQuery(); String sortURL = \"\"; boolean sortflag = true; while (rs.next()) { if (sortflag) { sortURL = rs.getString(1); sortflag = false; } else { sortURL = sortURL + \",\" + rs.getString(1); } } ps = conn.prepareStatement(sqlsortURL); ps.setString(1, sortURL); ps.executeUpdate(); } conn.commit(); } catch (Exception e) { e.printStackTrace(); try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { close(rs, null, ps, conn, dbo); } }. \nCode2: private InputStream getInputStream(String item) { InputStream is = null; URLConnection urlc = null; try { URL url = new URL(item); urlc = url.openConnection(); is = urlc.getInputStream(); current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() +", "ground_truth": "NO", "predict": " url.getPath(); } catch (IOException e) { e.printStackTrace(); } finally { if (urlc != null) { urlc.close(); } } return is; \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1353, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private EventSeries<PhotoEvent> loadIncomingEvents(long reportID) { EventSeries<PhotoEvent> events = new EventSeries<PhotoEvent>(); try { URL url = new URL(SERVER_URL + XML_PATH + \"reports.csv\"); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String str; while ((str = reader.readLine()) != null) { String[] values = str.split(\",\"); if (values.length == 2) { long id = Long.parseLong(values[0]); if (id == reportID) { long time = Long.parseLong(values[1]); events.addEvent(new PhotoEvent(time)); } } } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return events; }. \nCode2: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else { GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]); } } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void resolvePlugins() { try { File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR; File pluginsFile = new File(cacheDir, \"plugins.xml\"); if (!pluginsFile.exists()) { URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\"); InputStream is = pluginURL.openStream(); OutputStream os = FileUtils.openOutputStream(pluginsFile); IOUtils.copy(is, os); IOUtils.closeQuietly(os); IOUtils.closeQuietly(is); } resolvePlugins(pluginsFile.getAbsolutePath()); } catch (Exception e) { e.printStackTrace(); } }. \nCode2: public ArrayList<String> showTopLetters() { int[] tempArray = new int[engCountLetters.length]; char[] tempArrayLetters = new char[abcEng.length]; ArrayList<String> resultTopFiveLetters = new ArrayList<String>(); tempArray = engCountLetters.clone(); tempArrayLetters = abcEng.clone(); int tempCount; char tempLetters; for (int j = 0; j < (abcEng.length * abcEng.length); j++) { for (int i = 0; i < abcEng.length - 1; i++) { if (tempArray[i] > tempArray[i + 1]) { tempCount = tempArray[i]; tempLetters = tempArrayLetters[i]; tempArray[i] = tempArray[i + 1]; tempArrayLetters[i] = tempArrayLetters[i + 1]; tempArray[i + 1] = tempCount; tempArrayLetters[i + 1] = tempLetters; } } } for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) { resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]); } return resultTopFiveLetters; }. \n### Response:", "ground_truth": "NO", "predict": "public ArrayList<String> showTopLetters() { int[] tempArray = new int[engCountLetters.length]; char[] tempArrayLetters = new char[abcEng.length]; ArrayList<String> resultTopFiveLetters = new ArrayList<String>(); tempArray = engCountLetters.clone(); tempArrayLetters = abcEng.clone(); int tempCount; char tempLetters; for (int j = 0; j < (abcEng.length * abcEng.length); j++) { for (int i = 0; i < abcEng.length - 1; i++) { if (tempArray[i] > tempArray[i + 1]) { tempCount = tempArray[i]; tempLetters = tempArrayLetters[i]; tempArray[i] = tempArray[i + 1]; tempArrayLetters[i] = tempArrayLetters[i + 1]; tempArray[i + 1] = tempCount; tempArrayLetters[i"}, {"ID": 1364, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @org.junit.Test public void testReadWrite() throws Exception { final String reference = \"testString\"; final Reader reader = new StringReader(reference); final StringWriter osString = new StringWriter(); final Reader teeStream = new TeeReaderWriter(reader, osString); IOUtils.copy(teeStream, new NullWriter()); teeStream.close(); osString.toString(); }. \nCode2: public static File insertFileInto(File zipFile, File toInsert, String targetPath) { Zip64File zip64File = null; try { boolean compress = false; zip64File = new Zip64File(zipFile); FileEntry testEntry = getFileEntry(zip64File, targetPath); if (testEntry != null && testEntry.getMethod() == FileEntry.iMETHOD_DEFLATED) { compress = true; } processAndCreateFolderEntries(zip64File, parseTargetPath(targetPath, toInsert), compress); if (testEntry != null) { log.info(\"[insertFileInto] Entry exists: \" + testEntry.getName()); log.info(\"[insertFileInto] Will delete this entry before inserting: \" + toInsert.getName()); if (!testEntry.isDirectory()) { zip64File.delete(testEntry.getName()); } else { log.info(\"[insertFileInto] Entry is a directory. \" + \"Will delete all files contained in this entry and insert \" + toInsert.getName() + \"and all nested files.\"); if (!targetPath.contains(\"/\")) { targetPath = targetPath + \"/\"; } deleteFileEntry(zip64File, testEntry); log.info(\"[insertFileInto] Entry successfully deleted.\"); } log.info(\"[insertFileInto] Writing new Entry: \" + targetPath); EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile); IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } else { EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile); IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } log.info(\"[insertFileInto] Done! Added \" + toInsert.getName() + \" to zip.\"); zip64File.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new File(zip64File.getDiskFile().getFileName()); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static final String encryptPassword(String loginName, String password) { try { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(loginName.toUpperCase().getBytes(\"UTF-8\")); md5.update(password.getBytes(\"UTF-8\")); byte[] ba = md5.digest(); return byte2hex(ba); } catch (Exception e) { return password; } }. \nCode2: public static void copy(File in, File out) throws IOException { if (in.exists() && in != null && out != null) { if (!out.exists()) { if (in.isDirectory()) { out.mkdirs(); } else { out.createNewFile(); } } String source = in.isDirectory() ? \"directory\" : \"file\"; String target = out.isDirectory() ? \"directory\" : \"file\"; if (!source.equals(target)) { throw new IOException(\"Can't duplicate \" + source + \" as \" + target); } else { if (source.equals(\"directory\")) { File[] files = in.listFiles(); for (File file : files) { copy(file, new File(out, file.getName())); } } else { FileChannel inCh = new FileInputStream(in).getChannel(); FileChannel outCh = new FileOutputStream(out).get", "ground_truth": "NO", "predict": "Channel(); inCh.transferTo(outCh); inCh.close(); outCh.close(); } } } else { throw new IOException(\"Input and output files are null.\"); } }. \npublic static String byte2hex(byte[] bytes) { \n     StringBuilder sb = new StringBuilder(); \n     for (byte b : bytes) { \n         sb.append(Integer.toHexString(b)); \n     } \n     return sb.toString();\n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1368, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void write(File file) throws Exception { if (isInMemory()) { FileOutputStream fout = null; try { fout = new FileOutputStream(file); fout.write(get()); } finally { if (fout != null) { fout.close(); } } } else { File outputFile = getStoreLocation(); if (outputFile != null) { size = outputFile.length(); if (!outputFile.renameTo(file)) { BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(outputFile)); out = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copy(in, out); } finally { if (in != null) { try { in.close(); } catch (IOException e) { } } if (out != null) { try { out.close(); } catch (IOException e) { } } } } } else { throw new FileUploadException(\"Cannot write uploaded file to disk!\"); } } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException { HttpClient client = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(downloadUrl); final File outputFile = new File(destinationFile); createParentDirectories(outputFile); FileOutputStream outputStream; outputStream = new FileOutputStream(outputFile); final HttpResponse response = client.execute(httpGet); if (isInterrupted()) { outputStream.close(); return; } final HttpEntity entity = response.getEntity(); InputStream inputStream = null; try { if (entity != null) { inputStream = entity.getContent(); CopyStreamStatusCallback callback = new CopyStreamStatusCallback() { @Override public long getSkipBetweenUpdates() { return entity.getContentLength() * 2 / PERCENTAGE_BASE; } @Override public void onUpdate(final long copiedLength) { int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength()); handleUpdate(STATUS_DOWNLOADING, percentage); } }; copyStreams(inputStream, outputStream, callback); } } finally { try { outputStream.close(); if (inputStream != null) { inputStream.close(); } } catch (IOException e) { Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e); } } }. \nCode2: @Test public void testTrainingBackprop() throws IOException { File temp = File.createTempFile(\"fannj_\", \".tmp\"); temp.deleteOnExit(); IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp)); List<Layer> layers = new ArrayList<Layer>(); layers.add(Layer.create(2)); layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC)); layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC)); layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC)); Fann fann = new Fann(layers); Trainer trainer = new Trainer(fann); trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL); float desiredError = .001f; float mse = trainer.train(temp.", "ground_truth": "NO", "predict": "getAbsolutePath(), desiredError, 100); System.out.println(\"MSE: \" + mse); }!!!!!!!"}, {"ID": 1421, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static Photo createPhoto(String title, String userLogin, String pathToPhoto, String basePathImage) throws NoSuchAlgorithmException, IOException { String id = CryptSHA1.genPhotoID(userLogin, title); String extension = pathToPhoto.substring(pathToPhoto.lastIndexOf(\".\")); String destination = basePathImage + id + extension; FileInputStream fis = new FileInputStream(pathToPhoto); FileOutputStream fos = new FileOutputStream(destination); FileChannel fci = fis.getChannel(); FileChannel fco = fos.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) { int read = fci.read(buffer); if (read == -1) break; buffer.flip(); fco.write(buffer); buffer.clear(); } fci.close(); fco.close(); fos.close(); fis.close(); ImageIcon image; ImageIcon thumb; String destinationThumb = basePathImage + \"thumb/\" + id + extension; image = new ImageIcon(destination); int maxSize = 150; int origWidth = image.getIconWidth(); int origHeight = image.getIconHeight(); if (origWidth > origHeight) { thumb = new ImageIcon(image.getImage().getScaledInstance(maxSize, -1, Image.SCALE_SMOOTH)); } else { thumb = new ImageIcon(image.getImage().getScaledInstance(-1, maxSize, Image.SCALE_SMOOTH)); } BufferedImage bi = new BufferedImage(thumb.getIconWidth(), thumb.getIconHeight(), BufferedImage.TYPE_INT_RGB); Graphics g = bi.getGraphics(); g.drawImage(thumb.getImage(), 0, 0, null); try { ImageIO.write(bi, \"JPG\", new File(destinationThumb)); } catch (IOException ioe) { System.out.println(\"Error occured saving thumbnail\"); } Photo photo = new Photo(id); photo.setTitle(title); photo.basePathImage = basePathImage; return photo; }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected Document getRawResults(String urlString, Map args) throws Exception { int count = 0; Iterator keys = args.keySet().iterator(); while (keys.hasNext()) { String sep = count++ == 0 ? \"?\" : \"&\"; String name = (String) keys.next(); if (args.get(name) != null) { urlString += sep + name + \"=\" + args.get(name); } } URL url = new URL(urlString); URLConnection conn = url.openConnection(); conn.connect(); SAXBuilder builder = new SAXBuilder(); return builder.build(conn.getInputStream()); }. \nCode2: static Cipher createCipher(String passwd, int mode) throws Exception { PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\"); SecretKey key = keyFactory.generateSecret(keySpec); MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(\"input\".getBytes()); byte[] digest = md.digest(); byte[] salt = new byte[8]; for (int i = 0; i < 8; ++i) salt[i] = digest[i]; PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20); Cipher cipher = Cipher.getInstance(\"", "ground_truth": "NO", "predict": "PBEWithMD5AndDES\"); cipher.init(mode, key, paramSpec); return cipher; }. \n\ncreateCipher(\"password\", Cipher.ENCRYPT_MODE).doFinal(\"input\".getBytes()).equals(\"output\"); //true!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1422, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @HttpAction(name = \"map.saveOrUpdate\", method = { HttpAction.Method.post }, responseType = \"text/plain\") @HttpAuthentication(method = { HttpAuthentication.Method.WSSE }) public String saveOrUpdate(FileItem file, User user, MapOriginal map) throws HttpRpcException { File tmpFile; GenericDAO<MapOriginal> mapDao = DAOFactory.createDAO(MapOriginal.class); try { assert (file!= null); String jobid = null; if (file.getContentType().startsWith(\"image/\")) { tmpFile = File.createTempFile(\"gmap\", \"img\"); OutputStream out = new FileOutputStream(tmpFile); IOUtils.copy(file.getInputStream(), out); out.flush(); out.close(); map.setState(MapOriginal.MapState.UPLOAD); map.setUser(user); map.setMapPath(tmpFile.getPath()); map.setThumbnailUrl(\"/map/inproc.gif\"); map.setMimeType(file.getContentType()); mapDao.saveOrUpdate(map); jobid = PoolFactory.getClientPool().put(map, TaskState.STATE_MO_FINISH, MapOverrideStrategy.class); } return jobid; } catch (IOException e) { logger.error(e); throw ERROR_INTERNAL; } catch (DAOException e) { logger.error(e); throw ERROR_INTERNAL; } }. \nCode2: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { s. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \nCode2: private static File getZipAsFile(DigitalObject digOb) { String folderName = randomizeFileName(getFolderNameFromDigObject(digOb)); File tmpFolder = new File(utils_tmp, folderName); File zip = null; try { FileUtils.forceMkdir(tmpFolder); zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null)); FileOutputStream out = new FileOutputStream(zip); IOUtils.copyLarge(digOb.getContent().getInputStream(), out); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return zip; }. \n### Response:", "ground_truth": "YES", "predict": "public static File getZipAsFile(DigitalObject digOb) { String folderName = randomizeFileName(getFolderNameFromDigObject(digOb)); File tmpFolder = new File(utils_tmp, folderName); File zip = null; try { FileUtils.forceMkdir(tmpFolder); zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null)); FileOutputStream out = new FileOutputStream(zip); IOUtils.copyLarge(digOb.getContent().getInputStream(), out); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return zip; \n}"}, {"ID": 1465, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { try { String req1xml = jTextArea1.getText(); java.net.URL url = new java.net.URL(\"http://217.34.8.235:8080/newgenlibctxt/PatronServlet\"); java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection(); urlconn.setDoOutput(true); urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\"); java.io.OutputStream os = urlconn.getOutputStream(); java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32()); java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos); java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\"); System.out.println(req1xml); try { java.io.FileOutputStream pw = new java.io.FileOutputStream(\"C:/log.txt\"); pw.write(req1xml.getBytes()); pw.flush(); pw.close(); } catch (Exception exp) { exp.printStackTrace(); } dos.write(req1xml); dos.flush(); dos.close(); System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \" \" + urlconn.getContentType()); java.io.InputStream ios = urlconn.getInputStream(); java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32()); java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis); java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(gip)); String reqxml = \"\"; while (br.ready()) { String line = br.readLine(); reqxml += line; } try { java.. \nCode2: public String postDownloadRequest(String localFile) throws Exception { String responseString = \"\"; String requestString = \"\"; if (localFile == null) { error = true; errorStr = errorStr.concat(\"No local target for: \" + currentFile.getRelativePath() + \"\\n\"); return \"\"; } try { for (java.util.Iterator i = parameters.entrySet().iterator(); i.hasNext(); ) { java.util.Map.Entry e = (java.util.Map.Entry) i.next(); requestString = requestString + URLEncoder.encode((String) e.getKey(), \"UTF-8\") + \"=\" + URLEncoder.encode((String) e.getValue(), \"UTF-8\") + \"&\"; } URL url = new URL(urlString); URLConnection connection = url.openConnection(); HttpURLConnection httpConn = (HttpURLConnection) connection; httpConn.setRequestProperty(\"Content-Length\", String.valueOf(requestString.length())); httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpConn.setRequestMethod(\"POST\"); httpConn.setDoOutput(true); httpConn.setDoInput(true); connection.connect(); PrintWriter out = new PrintWriter(httpConn.getOutputStream()); out.println(requestString); out.close(); if (httpConn.HTTP_NOT_FOUND == httpConn.getResponseCode()) { error = true; errorStr = errorStr.concat(\"Cannot find file: \" + currentFile.getRelativePath() + \"\\n\"); return responseString; } String localFileName = new String(localFile); File f = new File(localFileName); File dir = new File(f.getParent()); dir.mkdirs(); FileOutputStream fis = new FileOutputStream(f); try { InputStream is = httpConn.getInputStream(); java.util.zip.GZIPInputStream gin = new java.util.zip.GZIPInputStream(new BufferedInputStream(is)); int temp; while ((temp = gin.read())!= -1) { fis.write(temp); } if (fis.getChannel().size() > 0) { f. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); conn.setRequestProperty(\"Connection\", \"close\"); if (userPassword!= null) { conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes())); } InputStream is = null; if (conn.getResponseCode() == 200) { is = conn.getInputStream(); } else { is = conn.getErrorStream(); InputStreamReader isr = new InputStreamReader(is); StringWriter sw = new StringWriter(); char[] buf = new char[200]; int read = 0; while (read!= -1) { read = isr.read(buf); sw.write(buf); } throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString()); } File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\")); if (!outputDir.exists()) { outputDir.mkdir(); wiseProperties.setProperty(\"wise.forceImportObject\", \"true\"); } File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString()); OutputStream fos = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copyStream(fos, is); fos.close(); is.close(); filePath = file.getPath(); } catch (WiseConnectionException wce) { throw wce; } catch (Exception e) { throw new WiseConnectionException(\"Wsdl download failed!\", e); } return filePath; }. \nCode2: private void handleURL() throws JspException, IOException { Map in_map = prepareInputMap(); String in_str = JSONTransformer.serialize(in_map); byte[] input = in_str.getBytes(\"UTF-8\"); HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection(); conn.setRequestMethod(\"POST\"); conn.setDoOutput(true); conn.setDoInput(true); conn.setUseCaches(false); conn.connect(); OutputStream os = conn.getOutputStream(); os.write(input); os.close(); InputStream is = conn.getInputStream(); InputStreamReader reader = new InputStreamReader(is, \"UTF-8\"); StringBuffer s_buf = new StringBuffer(); char[] tmp_buf = new char[1024]; int count; while ((count = reader.read(tmp_buf))!= -1) { if", "ground_truth": "NO", "predict": " (count > 0) { s_buf.append(tmp_buf, 0, count); } } String response = s_buf.toString(); reader.close(); is.close(); conn.close(); throw new JspException(\"Error: \" + response); }. \nCode2: private void handleURL() throws JspException, IOException { Map in_map = prepareInputMap(); String in_str = JSONTransformer.serialize(in_map); byte[] input = in_str.getBytes(\"UTF-8\"); HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection(); conn.setRequestMethod(\"POST\"); conn.setDoOutput(true); conn.setDoInput(true); conn.setUseCaches(false); conn.connect(); OutputStream os = conn.getOutputStream(); os.write(input); os.close(); InputStream is = conn.getInputStream(); InputStreamReader reader = new InputStreamReader(is, \"UTF"}, {"ID": 1467, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void onMessage(Message message) { LOG.debug(\"onMessage\"); DownloadMessage downloadMessage; try { downloadMessage = new DownloadMessage(message); } catch (JMSException e) { LOG.error(\"JMS error: \" + e.getMessage(), e); return; } String caName = downloadMessage.getCaName(); boolean update = downloadMessage.isUpdate(); LOG.debug(\"issuer: \" + caName); CertificateAuthorityEntity certificateAuthority = this.certificateAuthorityDAO.findCertificateAuthority(caName); if (null == certificateAuthority) { LOG.error(\"unknown certificate authority: \" + caName); return; } if (!update && Status.PROCESSING != certificateAuthority.getStatus()) { LOG.debug(\"CA status not marked for processing\"); return; } String crlUrl = certificateAuthority.getCrlUrl(); if (null == crlUrl) { LOG.warn(\"No CRL url for CA \" + certificateAuthority.getName()); certificateAuthority.setStatus(Status.NONE); return; } NetworkConfig networkConfig = this.configurationDAO.getNetworkConfig(); HttpClient httpClient = new HttpClient(); if (null != networkConfig) { httpClient.getHostConfiguration().setProxy(networkConfig.getProxyHost(), networkConfig.getProxyPort()); } HttpClientParams httpClientParams = httpClient.getParams(); httpClientParams.setParameter(\"http.socket.timeout\", new Integer(1000 * 20)); LOG.debug(\"downloading CRL from: \" + crlUrl); GetMethod getMethod = new GetMethod(crlUrl); getMethod.addRequestHeader(\"User-Agent\", \"jTrust CRL Client\"); int statusCode; try { statusCode = httpClient.executeMethod(getMethod); } catch (Exception e) { downloadFailed(caName, crlUrl); throw new RuntimeException(); } if (HttpURLConnection.HTTP_OK != statusCode) { LOG.debug(\"HTTP status code: \" + statusCode); downloadFailed(caName, crlUrl); throw new RuntimeException(); } String crlFilePath; File crlFile = null; try { crlFile = File.createTempFile(\"crl-\", \".der\"); InputStream crlInputStream = getMethod.getResponseBodyAsStream(); OutputStream crlOutputStream = new FileOutputStream(crlFile); IOUtils.copy(crlInputStream, crlOutputStream); IOUtils.closeQuietly(crlInputStream); IOUtils.closeQuietly(crlOutputStream); crlFilePath = crlFile.getAbsolutePath(); LOG.debug(\"temp CRL file: \" + crlFilePath); } catch (IOException e) { downloadFailed(caName, crlUrl); if (null != crlFile) { crlFile.delete(); } throw new RuntimeException(e); } try { this.notificationService.notifyHarvester(caName, crlFilePath, update); } catch (JMSException e) { crlFile.delete(); throw new RuntimeException(e); } }. \nCode2: public void save() { final JFileChooser fc = new JFileChooser(); fc.setFileFilter(new FileFilter() { public String getDescription() { return \"PDF File\"; } public boolean accept(File f) { return f.isDirectory() || f.getName().toLowerCase().endsWith(\".pdf\"); } }); if (fc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) { return; } File targetFile = fc.getSelectedFile(); if (!targetFile.getName().toLowerCase().endsWith(\".pdf\")) { targetFile = new File(targetFile.getParentFile(), targetFile.getName() + \".pdf\"); } if (targetFile.exists()) { if (JOptionPane.showConfirmDialog(this, \"Do you want to overwrite the file?\") != JOptionPane.YES_OPTION) { return; } } try { final InputStream is = new FileInputStream(filename); try { final OutputStream os = new FileOutputStream(targetFile); try { final byte[] buffer = new byte[32768]; for (int read; (read = is.read(buffer)) != -1; ) { os.write(buffer, 0, read); } } finally { os.close(); } } finally { is.close(); } } catch (IOException e) { e.printStackTrace(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public Vector parse(String link) { addMessage(\"Parsing: \" + link); links.removeAllElements(); URLConnection conn = null; Reader rd = null; EditorKit kit = new HTMLEditorKit(); Document doc = kit.createDefaultDocument(); doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE); URL url = null; try { url = new URL(link); } catch (MalformedURLException err) { System.out.println(\"Malformed URL\"); return links; } try { conn = new URL(link).openConnection(); rd = new InputStreamReader(conn.getInputStream()); } catch (Exception err) { err.printStackTrace(); return links; } try { kit.read(rd, doc, 0); ElementIterator it = new ElementIterator(doc); javax.swing.text.Element elem; while ((elem = it.next()) != null) { SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A); if (s != null) { if (s.toString().indexOf(\"script\") >= 0) continue; String lnk = \"\"; try { lnk = s.getAttribute(HTML.Attribute.HREF).toString(); } catch (Exception err) { continue; } int j = 0; if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j); URL urlLink = new URL(url, lnk); if (!url.getHost().equals(urlLink.getHost())) continue; String str = urlLink.toString(); if (!str.startsWith(\"http\")) continue; if (str.endsWith(\".pdf\")) { continue; } for (int i = 0; i < leaveSuffix.length; i++) { if ((str.endsWith(leaveSuffix[i]))) continue; } boolean skip = false; for (int i = 0; i < suffix.length; i++) { if ((str.endsWith(suffix[i]))) skip = true; } if (!skip) { try { conn = urlLink.openConnection(); } catch (Exception err) { } String contentType = null; if (contentType == null) contentType = conn.getContentType(); if (contentType.equals(\"application/pdf\")) { continue; } else if (!contentType.equals(\"text/html\")) { continue; } } if (!links.contains(urlLink.toString())) { links.addElement(urlLink.toString()); } } } } catch (Exception e) { e.printStackTrace(); } return links; }. \nCode2: public static void copyFile(File srcFile, File destFile) throws IOException { if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath()); if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile", "ground_truth": "NO", "predict": ".getAbsolutePath()); if (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath())) throw new IllegalArgumentException(\"Source and destination are the same file: \" + srcFile.getAbsolutePath()); FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(srcFile); out = new FileOutputStream(destFile); } catch (IOException err) { err.printStackTrace(); } finally { if (in != null) in.close(); if (out != null) out.close(); } }. \npublic static void copyFile(String srcFile, String destFile) throws IOException { copyFile(new File(srcFile), new File(destFile)); }. \npublic static void copyFile(String srcFile, String destFile, boolean preserve) throws IOException { copyFile(new File(srcFile), new File(destFile), preserve); }. \npublic static void"}, {"ID": 1470, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void createResource(String resourceUri, boolean publish, User user) throws IOException { PermissionAPI perAPI = APILocator.getPermissionAPI(); Logger.debug(this.getClass(), \"createResource\"); resourceUri = stripMapping(resourceUri); String hostName = getHostname(resourceUri); String path = getPath(resourceUri); String folderName = getFolderName(path); String fileName = getFileName(path); fileName = deleteSpecialCharacter(fileName); if (fileName.startsWith(\".\")) { return; } Host host = HostFactory.getHostByHostName(hostName); Folder folder = FolderFactory.getFolderByPath(folderName, host); boolean hasPermission = perAPI.doesUserHavePermission(folder, PERMISSION_WRITE, user, false); if (hasPermission) { if (!checkFolderFilter(folder, fileName)) { throw new IOException(\"The file doesn't comply the folder's filter\"); } if (host.getInode() != 0 && folder.getInode() != 0) { File file = new File(); file.setTitle(fileName); file.setFileName(fileName); file.setShowOnMenu(false); file.setLive(publish); file.setWorking(true); file.setDeleted(false); file.setLocked(false); file.setModDate(new Date()); String mimeType = FileFactory.getMimeType(fileName); file.setMimeType(mimeType); String author = user.getFullName(); file.setAuthor(author); file.setModUser(author); file.setSortOrder(0); file.setShowOnMenu(false); try { Identifier identifier = null; if (!isResource(resourceUri)) { WebAssetFactory.createAsset(file, user.getUserId(), folder, publish); identifier = IdentifierCache.getIdentifierFromIdentifierCache(file); } else { File actualFile = FileFactory.getFileByURI(path, host, false); identifier = IdentifierCache.getIdentifierFromIdentifierCache(actualFile); WebAssetFactory.createAsset(file, user.getUserId(), folder, identifier, false, false); WebAssetFactory.publishAsset(file); String assetsPath = FileFactory.getRealAssetsRootPath(); new java.io.File(assetsPath).mkdir(); java.io.File workingIOFile = FileFactory.getAssetIOFile(file); DotResourceCache vc = CacheLocator.getVeloctyResourceCache(); vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingIOFile.getPath()); if (file != null && file.getInode() > 0) { byte[] currentData = new byte[0]; FileInputStream is = new FileInputStream(workingIOFile); int size = is.available(); currentData = new byte[size]; is.read(currentData); java.io.File newVersionFile = FileFactory.getAssetIOFile(file); vc.remove(ResourceManager.RESOURCE_TEMPLATE + newVersionFile.getPath()); FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel(); ByteBuffer currentDataBuffer = ByteBuffer.allocate(currentData.length); currentDataBuffer.put(currentData); currentDataBuffer.position(0); channelTo.write(currentDataBuffer); channelTo.force(false); channelTo.close(); } java.util.List<Tree> parentTrees = TreeFactory.getTreesByChild(file); for (Tree tree : parentTrees) { Tree newTree = TreeFactory.getTree(tree.getParent(), file.getInode()); if (newTree.getChild() == 0) { newTree.setParent(tree.getParent()); newTree.setChild(file.getInode()); newTree.setRelationType(tree.getRelationType()); newTree.setTreeOrder(0); TreeFactory.saveTree(newTree); } } } List<Permission> permissions = perAPI.getPermissions(folder); for (Permission permission : permissions) { Permission filePermission = new Permission(); filePermission.setPermission(permission.getPermission()); filePermission.setRoleId(permission.getRoleId()); filePermission.setInode(identifier.getInode()); perAPI.save(filePermission); } } catch (Exception ex) { Logger.debug(this, ex.toString()); } } } else { throw new IOException(\"You don't have access to add that folder/host\"); } }. \nCode2: private File tmpFileFromURL(String name) { if (name == null) { System.out.println(\"ERROR: the provided URL is invalid, aborting download!\"); return null; } try { final URL url = new URL(name); final InputStream in = url.openStream(); final URLConnection conn = url.openConnection(); final int total = conn.getContentLength(); final String contentType = conn.getContentType(); logger.fine(\"DOWNLOADING Content-type: \" + contentType); if (contentType.trim().toLowerCase().indexOf(\"html\") != -1) { return tmpFileFromURL(extractRedirectURL(in)); } final FileManager fileManager = system.getFileManager(); final File dest = fileManager.createTmpModuleFile(); final FileOutputStream out = new FileOutputStream(dest); final byte[] buf = new byte[2048]; logger.fine(\"Total number of bytes to download: \" + total); int len, current = 0; progress(new ProgressEvent(this, \"Downloading \" + name, 0)); while ((len = in.read(buf)) > 0) { current += len; progress(new ProgressEvent(this, \"Downloading \" + name, (int) ((current * 100.0) / total))); out.write(buf, 0, len); out.flush(); } in.close(); out.flush(); out.close(); return dest; } catch (IOException ex) { progress(new ProgressEvent(\" ERROR: downloading of \" + name + \" failed. URL does not exist!\")); return null; } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected String getRequestContent(String urlText) throws Exception { URL url = new URL(urlText); HttpURLConnection urlcon = (HttpURLConnection) url.openConnection(); urlcon.connect(); BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream())); String line = reader.readLine(); reader.close(); urlcon.disconnect(); return line; }. \nCode2: private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception { String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath(); log.println(\"Concat files into: \" + outputFile); OutputStream out = new FileOutputStream(absPath + outputFile); byte[] buffer = new byte[4096]; int readBytes; for (String file : inputFiles) { log.println(\" Read: \" + file); InputStream in = new FileInputStream(absPath + file); while ((readBytes = in.read(buffer)) != -1) { out.write(buffer, 0, readBytes); } in.close(); } out.close(); if (compress) { long normalSize = new File(absPath + outputFile).length(); ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\"); builder.directory(new File(absPath)); Process process =", "ground_truth": "NO", "predict": " builder.start(); log.println(\"Compressing: \" + outputFile + \" to \" + outputFile + \".size=\" + normalSize); while (process.poll() == null) { log.println(\" Compressing: \" + outputFile + \" to \" + outputFile + \".size=\" + new File(absPath + outputFile).length()); } log.println(\"Compressing: \" + outputFile + \" to \" + outputFile + \".size=\" + new File(absPath + outputFile).length()); } }. \nCode1: public void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception { String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath(); log.println(\"Concat files into: \" + outputFile); OutputStream out = new FileOutputStream(absPath + outputFile); byte[] buffer = new byte[4096]; int readBytes; for (String file : inputFiles) { log.println"}, {"ID": 1481, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String readTemplateToString(String fileName) { URL url = null; url = classLoader.getResource(fileName); StringBuffer content = new StringBuffer(); if (url == null) { String error = \"Template file could not be found: \" + fileName; throw new RuntimeException(error); } try { BufferedReader breader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); String strLine = \"\"; while ((strLine = breader.readLine()) != null) { content.append(strLine).append(\"\\n\"); } breader.close(); } catch (Exception e) { throw new RuntimeException(\"Problem while loading file: \" + fileName); } return content.toString(); }. \nCode2: @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.listview); HttpGet request = new HttpGet(SERVICE_URI + \"/json/getroutes/1\"); request.setHeader(\"Accept\", \"application/json\"); request.setHeader(\"Content-type\", \"application/json\"); DefaultHttpClient httpClient = new DefaultHttpClient(); String theString = new String(\"\"); try { HttpResponse response = httpClient.execute(request); HttpEntity responseEntity = response.getEntity(); InputStream stream = responseEntity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); Vector<String> vectorOfStrings = new Vector<String>(); String tempString = new String(); String tempStringAgent = new String(); String tempStringClient = new String(); String tempStringRoute = new String(); String tempStringZone = new String(); StringBuilder builder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { builder.append(line); } stream.close(); theString = builder.toString(); JSONObject json = new JSONObject(theString); Log.i(\"_GetClient_\", \"<jsonobject>\\n\" + json.toString() + \"\\n</jsonobject>\"); this.dm = new DataManipulator(this); JSONArray nameArray = json.getJSONArray(\"GetRoutesByAgentResult\"); for (int i = 0; i < nameArray.length(); i++) { tempStringAgent = nameArray.getJSONObject(i).getString(\"Agent\"); tempStringClient = nameArray.getJSONObject(i).getString(\"Client\"); tempStringRoute = nameArray.getJSONObject(i).getString(\"Route\"); tempStringZone = nameArray.getJSONObject(i).getString(\"Zone\"); Log.i(\"_GetClient_\", \"<Agent\" + i + \">\" + tempStringAgent + \"</Agent\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Client\" + i + \">\" + tempStringClient + \"</Client\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Route\" + i + \">\" + tempStringRoute + \"</Route\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Zone\" + i + \">\" + tempStringZone + \"</Zone\" + i + \">\\n\"); tempString = nameArray.getJSONObject(i).getString(\"Client\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Route\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Zone\"); vectorOfStrings.add(new String(tempString)); } int orderCount = vectorOfStrings.size(); String[] orderTimeStamps = new String[orderCount]; vectorOfStrings.copyInto(orderTimeStamps); setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, orderTimeStamps)); } catch (Exception e) { e.printStackTrace(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void copy(String from_name, String to_name) throws IOException { File from_file = new File(from_name); File to_file = new File(to_name); if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name); if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name); if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name); if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName()); if (to_file.exists()) { if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name); } else { String parent = to_file.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent); if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent); if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(from_file); to = new FileOutputStream(to_file); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } } finally { if (from != null) { try { from.close(); } catch (IOException e) { e.printStackTrace(); } } if (to != null) { try { to.close(); } catch (IOException e) { e.printStackTrace(); } } } }. \nCode2: public static void main(String[] argv) { if (1 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).getChannel(); try { source.transferTo(0L, srclen, target); } finally { target.close(); } System.out.printf(\"Updated %s\\n\", tgt.getPath()); File[] deletes = Delete(src, tgt); if (null != deletes) { for (File del : deletes) { if (SVN) { if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } } if (SVN) SvnAdd(tgt); } } finally { source.close(); } } catch (Exception exc) { exc.printStackTrace(); System.exit(1); } } } System.exit(0); } else { System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]); System.exit(1); } } else { usage(); System.exit(1); } }. ", "ground_truth": "YES", "predict": "\n\npublic static void Source(String path) { File file = new File(path); if (file.exists()) { if (file.isDirectory()) { for (File f : file.listFiles()) { if (f.getName().startsWith(\".\")) continue; Source(f.getPath()); } } else { if (file.isFile()) { if (file.getName().startsWith(\".\")) continue; Source(file.getPath()); } else { System.err.printf(\"Source: '%s' is not a file or directory\\n\", path); System.exit(1); } } } else { System.err.printf(\"Source: '%s' does not exist\\n\", path); System.exit(1); } }. \n\npublic static void Target(File src, String[] targets) { if (null != targets) { for (String tgt : targets) { File target = new File(tgt); if (target.exists())"}, {"ID": 1484, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String[] args) { Option optHelp = new Option(\"h\", \"help\", false, \"print this message\"); Option optCerts = new Option(\"c\", \"cert\", true, \"use external semicolon separated X.509 certificate files\"); optCerts.setArgName(\"certificates\"); Option optPasswd = new Option(\"p\", \"password\", true, \"set password for opening PDF\"); optPasswd.setArgName(\"password\"); Option optExtract = new Option(\"e\", \"extract\", true, \"extract signed PDF revisions to given folder\"); optExtract.setArgName(\"folder\"); Option optListKs = new Option(\"lk\", \"list-keystore-types\", false, \"list keystore types provided by java\"); Option optListCert = new Option(\"lc\", \"list-certificates\", false, \"list certificate aliases in a KeyStore\"); Option optKsType = new Option(\"kt\", \"keystore-type\", true, \"use keystore type with given name\"); optKsType.setArgName(\"keystore_type\"); Option optKsFile = new Option(\"kf\", \"keystore-file\", true, \"use given keystore file\"); optKsFile.setArgName(\"file\"); Option optKsPass = new Option(\"kp\", \"keystore-password\", true, \"password for keystore file (look on -kf option)\"); optKsPass.setArgName(\"password\"); Option optFailFast = new Option(\"ff\", \"fail-fast\", true, \"flag which sets the Verifier to exit with error code on the first validation failure\"); final Options options = new Options(); options.addOption(optHelp); options.addOption(optCerts); options.addOption(optPasswd); options.addOption(optExtract); options.addOption(optListKs); options.addOption(optListCert); options.addOption(optKsType); options.addOption(optKsFile); options.addOption(optKsPass); options.addOption(optFailFast); CommandLine line = null; try { CommandLineParser parser = new PosixParser(); line = parser.parse(options, args); } catch (ParseException exp) { System.err.println(\"Illegal command used: \" + exp.getMessage()); System.exit(-1); } final boolean failFast = line.hasOption(\"ff\"); final String[] tmpArgs = line.getArgs(); if (line.hasOption(\"h\") || args == null || args.length == 0) { HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(70, \"java -jar Verifier.jar [file1.pdf [file2.pdf ...]]\", \"JSignPdf Verifier is a command line tool for verifying signed PDF documents.\", options, null, true); } else if (line.hasOption(\"lk\")) { for (String tmpKsType : KeyStoreUtils.getKeyStores()) { System.out.println(tmpKsType); } } else if (line.hasOption(\"lc\")) { for (String tmpCert : KeyStoreUtils.getCertAliases(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\"))) { System.out.println(tmpCert); } } else { final VerifierLogic tmpLogic = new VerifierLogic(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\")); tmpLogic.setFailFast(failFast); if (line.hasOption(\"c\")) { String tmpCertFiles = line.getOptionValue(\"c\"); for (String tmpCFile : tmpCertFiles.split(\";\")) { tmpLogic.addX509CertFile(tmpCFile); } } byte[] tmpPasswd = null; if (line.hasOption(\"p\")) { tmpPasswd = line.getOptionValue(\"p\").getBytes(); } String tmpExtractDir = null; if (line.hasOption(\"e\")) { tmpExtractDir = new File(line.getOptionValue(\"e\")).getPath(); } for (String tmpFilePath : tmpArgs) { System.out.println(\"Verifying \" + tmpFilePath); final File tmpFile = new File(tmpFilePath); if (!tmpFile.canRead()) { System.err.println(\"Couln't read the file. Check the path and permissions.\"); if (failFast) { System.exit(-1); } continue; } final VerificationResult tmpResult = tmpLogic.verify(tmpFilePath, tmpPasswd); if (tmpResult.getException() != null) { tmpResult.getException().printStackTrace(); System.exit(-1); } else { System.out.println(\"Total revisions: \" + tmpResult.getTotalRevisions()); for (SignatureVerification tmpSigVer : tmpResult.getVerifications()) { System.out.println(tmpSigVer.toString()); if (tmpExtractDir != null) { try { File tmpExFile = new File(tmpExtractDir + \"/\" + tmpFile.getName() + \"_\" + tmpSigVer.getRevision() + \".pdf\"); System.out.println(\"Extracting to \" + tmpExFile.getCanonicalPath()); FileOutputStream tmpFOS = new FileOutputStream(tmpExFile.getCanonicalPath()); InputStream tmpIS = tmpLogic.extractRevision(tmpFilePath, tmpPasswd, tmpSigVer.getName()); IOUtils.copy(tmpIS, tmpFOS); tmpIS.close(); tmpFOS.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } if (failFast && SignatureVerification.isError(tmpResult.getVerificationResultCode())) { System.exit(tmpResult.getVerificationResultCode()); } } } } }. \nCode2: public void unzip(String zipFileName, String outputDirectory) throws Exception { ZipInputStream in = new ZipInputStream(new FileInputStream(zipFileName)); ZipEntry z; while ((z = in.getNextEntry()) != null) { System.out.println(\"unziping \" + z.getName()); if (z.isDirectory()) { String name = z.getName(); name = name.substring(0, name.length() - 1); File f = new File(outputDirectory + File.separator + name); f.mkdir(); System.out.println(\"mkdir \" + outputDirectory + File.separator + name); } else { File f = new File(outputDirectory + File.separator + z.getName()); f.createNewFile(); FileOutputStream out = new FileOutputStream(f); int b; while ((b = in.read()) != -1) out.write(b); out.close(); } } in.close(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static final synchronized String hash(String data) { if (digest == null) { try { digest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException nsae) { System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\"); nsae.printStackTrace(); } } digest.update(data.getBytes()); return toHex(digest.digest()); }. \nCode2: static Cipher createCipher(String passwd, int mode) throws Exception { PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\"); SecretKey", "ground_truth": "YES", "predict": " key = keyFactory.generateSecretKey(keySpec); return Cipher.getInstance(\"DES\"); }. \n\nstatic String toHex(byte[] data) { StringBuilder sb = new StringBuilder(); for (byte b : data) { sb.append(Integer.toHexString(b)); } return sb.toString(); }. \n\nstatic String hash(String data) { return toHex(hash(data.getBytes(\"utf-8\"))); }. \n\nstatic String hash(String data, String passwd) { return hash(data.getBytes(\"utf-8\"), passwd.getBytes(\"utf-8\")); }. \n\nstatic String hash(String data, String passwd, int mode) { return hash(data.getBytes(\"utf-8\"), passwd.getBytes(\"utf-8\"), mode); }. \n\nstatic String hash(byte[] data, String passwd, int mode) { return hash(data,"}, {"ID": 1486, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override public void run() { long timeout = 10 * 1000L; long start = (new Date()).getTime(); try { InputStream is = socket.getInputStream(); boolean available = false; while (!available && !socket.isClosed()) { try { if (is.available() != 0) { available = true; } else { Thread.sleep(100); } } catch (Exception e) { LOG.error(\"Error checking socket\", e); } long curr = (new Date()).getTime(); if ((curr - start) >= timeout) { break; } } if (socket.isClosed()) { } else { tmpFile = File.createTempFile(\"ftp\", \"dat\", new File(\"./tmp\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile)); IOUtils.copy(is, bos); bos.flush(); bos.close(); } String msg = FtpResponse.ReadComplete.asString() + ClientCommand.SP + \"Read Complete\" + ClientCommand.CRLF; List<String> list = new ArrayList<String>(); list.add(msg); ClientResponse response = new ClientResponse(list); ftpClient.notifyListeners(response); } catch (Exception e) { LOG.error(\"Error reading server response\", e); } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public boolean getContent(String userId, String latestMsgId) { try { String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId; URL url = new URL(targetUrl); InputStream in = url.openStream(); ArrayList<MessageObj> list; if (in != null) { MessageListDOMParser parser = new MessageListDOMParser(); list = (ArrayList<MessageObj>) parser.parseXML(in); TransactionDAO dao = new TransactionDAO(); dao.insert(list); } return true; } catch (Exception e) { e.printStackTrace(); return false; } }. \nCode2: public void setImg() { JFileChooser jFileChooser1 = new JFileChooser(); String separator = \"\"; if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) { setPath(jFileChooser1.getSelectedFile().getPath()); separator = jFileChooser1.getSelectedFile().separator; File dirImg = new File(\".\" + separator + \"images\"); if (!dirImg.exists()) { dirImg.mkdir(); } int index = getPath().lastIndexOf(separator); String imgName = getPath().substring(index); String newPath = dirImg + imgName; try { File inputFile = new File(getPath()); File outputFile = new File(newPath); if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) { FileInputStream in = new FileInputStream(inputFile); FileOutputStream out = new FileOutputStream(outputFile); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } } catch (Exception ex) { ex.printStackTrace(); LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled()); JOptionPane.showMessageDialog(null", "ground_truth": "NO", "predict": ", ex.getMessage(), \"Error\", JOptionPane.WARNING_MESSAGE); } }. \npublic void setPath(String path) { path = path.replaceAll(\"\\\\\\\\\", \"/\"); getPath().setText(path); }. \npublic String getPath() { return path.getText(); }. \npublic void setImgName(String name) { getPath().setText(getPath().getText() + name); }. \npublic String getImgName() { return getPath().getText().substring(getPath().lastIndexOf(\"/\") + 1); }. \npublic void setImgSize(int width, int height) { getImgSize().setText(String.valueOf(width) + \"x\" + String.valueOf(height)); }. \npublic String getImgSize() { return getImgSize().getText(); }. \npublic void setImgFormat(String format) { get"}, {"ID": 1531, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void copyFile(String f_in, String f_out, boolean remove) throws FileNotFoundException, IOException { if (remove) { PogoString readcode = new PogoString(PogoUtil.readFile(f_in)); readcode = PogoUtil.removeLogMessages(readcode); PogoUtil.writeFile(f_out, readcode.str); } else { FileInputStream fid = new FileInputStream(f_in); FileOutputStream fidout = new FileOutputStream(f_out); int nb = fid.available(); byte[] inStr = new byte[nb]; if (fid.read(inStr) > 0) fidout.write(inStr); fid.close(); fidout.close(); } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static List runITQLQuery(String itqlQuery) throws Exception { String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\"); String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery; logger.debug(\"url for risearch query: \" + url); URL urlObject = new URL(url); HttpURLConnection con = (HttpURLConnection) urlObject.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); logger.debug(\"response code: \" + con.getResponseCode()); if (con.getResponseCode() != 200 && con.getResponseCode() != 302) { throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url); } ArrayList arrayList = new ArrayList(); String inputLine; int counter = 0; while ((inputLine = br.readLine()) != null) { logger.debug(\"reading line:\" + inputLine); if (inputLine.indexOf(\"<html>\") >= 0) { logger.error(\"problem quering the relationship\"); throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery); } if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) { logger.debug(\"adding line:\" + inputLine); inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1); arrayList.add(inputLine); logger.debug(\"found relationship to item: \" + inputLine); } counter++; } br.close(); logger.debug(\"num relationships found: \" + arrayList.size()); return arrayList; }. \nCode2: private final String createMD5(String pwd) throws Exception { MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone(); md.update(pwd.getBytes(\"UTF-8\")); byte[] pd = md.digest(); StringBuffer app = new StringBuffer(); for (int i = 0; i < pd.length; i++) { String s2 = Integer.toHexString(pd[i] & 0xFF); app.append((s2.length() == 1) ? \"0\" + s2 : s2); } return app.toString(); }. ", "ground_truth": "NO", "predict": "\nCode1: private static String createMD5(String pwd) throws Exception { MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone(); md.update(pwd.getBytes(\"UTF-8\")); byte[] pd = md.digest(); StringBuffer app = new StringBuffer(); for (int i = 0; i < pd.length; i++) { String s2 = Integer.toHexString(pd[i] & 0xFF); app.append((s2.length() == 1) ? \"0\" + s2 : s2); } return app.toString(); }. \nCode2: private static String createMD5(String pwd) throws Exception { MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone(); md.update(pwd.getBytes(\"UTF-8\")); byte[] pd = md.digest(); StringBuffer app = new StringBuffer();"}, {"ID": 1602, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public ActualTask(TEditor editor, TIGDataBase dataBase, String directoryPath, String myImagesBehaviour) { File myDirectory = new File(directoryPath); String[] list = myDirectory.list(); File fileXML = new File(directoryPath + \"images.xml\"); SAXBuilder builder = new SAXBuilder(false); try { Document docXML = builder.build(fileXML); Element root = docXML.getRootElement(); List images = root.getChildren(\"image\"); Iterator j = images.iterator(); int i = 0; TIGDataBase.activateTransactions(); while (j.hasNext() && !stop && !cancel) { current = i; i++; Element image = (Element) j.next(); String name = image.getAttributeValue(\"name\"); List categories = image.getChildren(\"category\"); Iterator k = categories.iterator(); if (exists(list, name)) { String pathSrc = directoryPath.concat(name); String pathDst = System.getProperty(\"user.dir\") + File.separator + \"images\" + File.separator + name.substring(0, 1).toUpperCase() + File.separator; String folder = System.getProperty(\"user.dir\") + File.separator + \"images\" + File.separator + name.substring(0, 1).toUpperCase(); if (myImagesBehaviour.equals(TLanguage.getString(\"TIGImportDBDialog.REPLACE_IMAGES\"))) { Vector<Vector<String>> aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.'))); if (aux.size() != 0) { int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.'))); TIGDataBase.deleteAsociatedOfImage(idImage); } pathDst = pathDst.concat(name); } if (myImagesBehaviour.equals(TLanguage.getString(\"TIGImportDBDialog.ADD_IMAGES\"))) { Vector aux = new Vector(); aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.'))); int fileCount = 0; if (aux.size() != 0) { while (aux.size() != 0) { fileCount++; aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.')) + \"_\" + fileCount); } pathDst = pathDst + name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length()); name = name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length()); } else { pathDst = pathDst.concat(name); } } String pathThumbnail = (pathDst.substring(0, pathDst.lastIndexOf(\".\"))).concat(\"_th.jpg\"); File newDirectoryFolder = new File(folder); if (!newDirectoryFolder.exists()) { newDirectoryFolder.mkdirs(); } try { FileChannel srcChannel = new FileInputStream(pathSrc).getChannel(); FileChannel dstChannel = new FileOutputStream(pathDst).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException exc) { System.out.println(exc.getMessage()); System.out.println(exc.toString()); } TIGDataBase.insertImageDB(name.substring(0, name.lastIndexOf('.')), name); int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.'))); while (k.hasNext()) { Element category = (Element) k.next(); int idCategory = TIGDataBase.insertConceptDB(category.getValue()); TIGDataBase.insertAsociatedDB(idCategory, idImage); } } else { errorImages = errorImages + System.getProperty(\"line.separator\") + name; } } TIGDataBase.executeQueries(); current = lengthOfTask; } catch (JDOMException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \nCode2: @SuppressWarnings(\"unchecked\") protected void handleRequest(HttpServletRequest req, HttpServletResponse resp, boolean isPost) throws ServletException, IOException { HttpClient httpclient = WebReader.getHttpClient(); try { StringBuffer sb = new StringBuffer(); sb.append(targetServer); sb.append(req.getRequestURI()); if (req.getQueryString() != null) { sb.append(\"?\" + req.getQueryString()); } HttpRequestBase targetRequest = null; if (isPost) { HttpPost post = new HttpPost(sb.toString()); Enumeration<String> paramNames = req.getParameterNames(); String paramName = null; List<NameValuePair> params = new ArrayList<NameValuePair>(); while (paramNames.hasMoreElements()) { paramName = paramNames.nextElement(); params.add(new BasicNameValuePair(paramName, req.getParameterValues(paramName)[0])); } post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8)); targetRequest = post; } else { System.out.println(\"GET\"); HttpGet get = new HttpGet(sb.toString()); targetRequest = get; } HttpResponse targetResponse = httpclient.execute(targetRequest); HttpEntity entity = targetResponse.getEntity(); InputStream input = entity.getContent(); OutputStream output = resp.getOutputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(input)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output)); String line = reader.readLine(); while (line != null) { writer.write(line + \"\\n\"); line = reader.readLine(); } reader.close(); writer.close(); } finally { WebReader.returnHttpClient(httpclient); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String[] args) throws Exception { if (args.length != 2) { System.out.println(\"arguments: sourcefile destfile\"); System.exit(1); } FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while (in.read(buffer) != -1) { buffer.flip(); out.write(buffer); buffer.clear(); } }. \nCode2: String fetch_pls(String pls) { InputStream pstream = null; if (pls.startsWith(\"http://\")) { try { URL url = null; if (running_as_applet) { url = new URL(getCodeBase(), pls); } else { url = new URL(pls); } URLConnection urlc = url.openConnection(); pstream = urlc.getInputStream(); } catch (Exception ee) { System.err.println(ee); return null; } } if (pstream == null && !running_as_applet) { try { pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator", "ground_truth": "NO", "predict": "\") + pls); } catch (Exception ee) { System.err.println(ee); return null; } } return fetch_pls_stream(pstream);\n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1605, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected int insertRecord(PutMetadataRequest request, PutMetadataInfo info) throws ImsServiceException, SQLException { Connection con = null; boolean autoCommit = true; PreparedStatement st = null; ResultSet rs = null; int nRows = 0; String sXml = info.getXml(); String sUuid = info.getUuid(); String sName = info.getName(); String sThumbnailBinary = info.getThumbnailBinary(); String sTable = this.getResourceTableName(); String sDataTable = this.getResourceDataTableName(); long id = doesRecordExist(sTable, sUuid); try { ManagedConnection mc = returnConnection(); con = mc.getJdbcConnection(); autoCommit = con.getAutoCommit(); con.setAutoCommit(false); if (id < 0) { StringBuffer sql = new StringBuffer(); sql.append(\"INSERT INTO \").append(sTable); sql.append(\" (\"); sql.append(\"DOCUUID,\"); sql.append(\"TITLE,\"); sql.append(\"OWNER\"); sql.append(\")\"); sql.append(\" VALUES(?,?,?)\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); int n = 1; st.setString(n++, sUuid); st.setString(n++, sName); st.setInt(n++, this.publisher.getLocalID()); nRows = st.executeUpdate(); closeStatement(st); if (nRows > 0) { if (getIsDbCaseSensitive(this.getRequestContext())) { st = con.prepareStatement(\"SELECT id FROM \" + sTable + \" WHERE UPPER(docuuid)=?\"); } else { st = con.prepareStatement(\"SELECT id FROM \" + sTable + \" WHERE docuuid=?\"); } st.setString(1, sUuid.toUpperCase()); rs = st.executeQuery(); rs.next(); id = rs.getLong(1); closeStatement(st); request.setActionStatus(ImsRequest.ACTION_STATUS_OK); sql = new StringBuffer(); sql.append(\"INSERT INTO \").append(sDataTable); sql.append(\" (DOCUUID,ID,XML)\"); sql.append(\" VALUES(?,?,?)\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); st.setString(1, sUuid); st.setLong(2, id); st.setString(3, sXml); st.executeUpdate(); } } else { this.authorize(request, sUuid); StringBuffer sql = new StringBuffer(); sql.append(\"UPDATE \").append(sTable); sql.append(\" SET \"); if (!request.getLockTitle()) { sql.append(\"TITLE=?, \"); } sql.append(\"OWNER=?, \"); sql.append(\"UPDATEDATE=?\"); sql.append(\" WHERE DOCUUID=?\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); int n = 1; if (!request.getLockTitle()) { st.setString(n++, sName); } st.setInt(n++, this.publisher.getLocalID()); st.setTimestamp(n++, new Timestamp(System.currentTimeMillis())); st.setString(n++, sUuid); nRows = st.executeUpdate(); if (nRows > 0) { request.setActionStatus(ImsRequest.ACTION_STATUS_REPLACED); } closeStatement(st); sql = new StringBuffer(); if (doesRecordExist(sDataTable, sUuid) >= 0) { sql.append(\"UPDATE \").append(sDataTable); sql.append(\" SET DOCUUID=?, XML=?, THUMBNAIL=?\"); sql.append(\" WHERE ID=?\"); } else { sql.append(\"INSERT INTO \").append(sDataTable); sql.append(\" (DOCUUID, XML,THUMBNAIL,ID)\"); sql.append(\" VALUES(?,?,?,?)\"); } logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); st.setString(1, sUuid); st.setString(2, sXml); st.setBytes(3, null); st.setLong(4, id); st.executeUpdate(); } con.commit(); } catch (ImsServiceException ex) { if (con != null) { con.rollback(); } throw ex; } catch (SQLException ex) { if (con != null) { con.rollback(); } throw ex; } finally { closeResultSet(rs); closeStatement(st); if (con != null) { con.setAutoCommit(autoCommit); } } if ((sThumbnailBinary != null) && (sThumbnailBinary.length() > 0)) { this.updateThumbnail(sThumbnailBinary, sUuid); } return nRows; }. \nCode2: public void writeTo(OutputStream out) throws IOException { if (!closed) { throw new IOException(\"Stream not closed\"); } if (isInMemory()) { memoryOutputStream.writeTo(out); } else { FileInputStream fis = new FileInputStream(outputFile); try { IOUtils.copy(fis, out); } finally { IOUtils.closeQuietly(fis); } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException { String fullname = System.mapLibraryName(name); String path = \"native/\" + sysName + \"/\" + fullname; URL url = Thread.currentThread().getContextClassLoader().getResource(path); if (url == null) { if (!warning) { logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname }); } return; } URLConnection conn = url.openConnection(); InputStream in = conn.getInputStream(); File targetFile = new File(getExtractionDir(), fullname); OutputStream out = null; try { if (targetFile.exists()) { long targetLastModified = targetFile.lastModified(); long sourceLastModified = conn.getLastModified(); if (targetLastModified + 1000 > sourceLastModified) { logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname); return; } } out = new FileOutputStream(targetFile); int len; while ((len = in.read(buf)) > 0) { out.write(buf, 0, len); } in.close(); in = null; out.close(); out = null; targetFile.setLastModified(conn.getLastModified()); } catch (FileNotFoundException ex) { if (ex.getMessage().contains(\"used by another process\")) { return; } throw ex; } finally { if (load) { System.load(targetFile.getAbsolutePath()); } if (in != null) { in.close(); } if (out != null) { out.close(); } } logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile }); }. \nCode2: public static byte[] loadURLToBuffer(URL url) throws IOException { byte[] buf = new byte[4096]; byte[] data = null; byte[] temp = null; int iCount = 0; int iTotal = 0; Buffered", "ground_truth": "NO", "predict": "InputStream in = null; try { in = new BufferedInputStream(url.openStream()); } catch (IOException ex) { throw ex; } while ((temp = in.read(buf)) != null) { if (iCount == 0) { data = new byte[temp.length]; } System.arraycopy(temp, 0, data, iTotal, temp.length); iTotal += temp.length; iCount++; } return data; } finally { if (in != null) { in.close(); } }. \nCode1: public static URL loadURL(String urlString) throws IOException { URL url = new URL(urlString); return url; }. \nCode2: public static URL loadURL(String urlString) throws IOException { URL url = new URL(urlString); return url; }. \nCode2: public static URL loadURL(String urlString) throws IOException { URL url = new URL(urlString); return url; }. \nCode"}, {"ID": 1610, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Algorithm(name = \"EXT\") public void execute() { Connection conn = null; try { Class.forName(jdbcDriver).newInstance(); conn = DriverManager.getConnection(jdbcUrl, username, password); conn.setAutoCommit(false); l.debug(\"Connected to the database\"); Statement stmt = conn.createStatement(); l.debug(sql); ResultSet rs = stmt.executeQuery(sql); List<Map<String, String>> res = DbUtil.listFromRS(rs); if (null != res && !res.isEmpty()) { docs = new ArrayList<Doc>(); List<String> keys = new ArrayList<String>(); for (Map<String, String> map : res) { docs.add(convert(map)); String key = map.get(pk); keys.add(key); } String sql2 = updateSQL + \" where \" + pk + \" in (\" + CollectionUtil.toString(keys) + \")\"; l.debug(sql2); stmt.executeUpdate(sql2); conn.commit(); } } catch (Exception e) { l.error(e.getMessage(), e); if (null != conn) { try { conn.rollback(); } catch (Exception ex) { l.error(ex.getMessage(), ex); } } throw new RuntimeException(e.getMessage()); } finally { try { if (null != conn) { conn.close(); l.debug(\"Disconnected from database\"); } } catch (Exception ex) { l.error(ex.getMessage(), ex); } } if (null != docs && !docs.isEmpty()) { triggerEvent(\"EO\"); } else { triggerEvent(\"EMPTY\"); } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private String executePost(String targetURL, String urlParameters) { URL url; HttpURLConnection connection = null; try { url = new URL(targetURL); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"POST\"); connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length)); connection.setRequestProperty(\"Content-Language\", \"en-US\"); connection.setUseCaches(false); connection.setDoInput(true); connection.setDoOutput(true); DataOutputStream wr = new DataOutputStream(connection.getOutputStream()); wr.writeBytes(urlParameters); wr.flush(); wr.close(); InputStream is = connection.getInputStream(); BufferedReader rd = new BufferedReader(new InputStreamReader(is)); String line; StringBuffer response = new StringBuffer(); while ((line = rd.readLine()) != null) { response.append(line); response.append('\\r'); } rd.close(); return response.toString(); } catch (Exception e) { e.printStackTrace(); return null; } finally { if (connection != null) { connection.disconnect(); } } }. \nCode2: private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException { InputStream inStream = null; OutputStream outStream = null; try { inStream = MatsimResource.getAsInputStream(resourceFilename); outStream = new FileOutputStream(destinationFilename); IOUtils.copyStream(inStream, outStream); } finally { if (inStream != null) { try { inStream.close(); } catch (IOException e", "ground_truth": "NO", "predict": ") { e.printStackTrace(); } } if (outStream != null) { try { outStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }. \n\n// Output: \n// The resource file is copied to the output file.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1622, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void write(File file) throws Exception { if (getGEDCOMFile() != null) { size = getGEDCOMFile().length(); if (!getGEDCOMFile().renameTo(file)) { BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(getGEDCOMFile())); out = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copy(in, out); } finally { if (in != null) { try { in.close(); } catch (IOException e) { } } if (out != null) { try { out.close(); } catch (IOException e) { } } } } } else { throw new FileUploadException(\"Cannot write uploaded file to disk!\"); } }. \nCode2: public static JSONObject fromUrl(String url) throws Throwable { Validate.notEmpty(url); InputStream stream = null; HttpClient httpclient = null; try { httpclient = new DefaultHttpClient(); HttpGet httpget = new HttpGet(url); HttpResponse response = httpclient.execute(httpget); if (response != null) { HttpEntity entity = response.getEntity(); if (entity != null) { try { stream = entity.getContent(); return fromStream(stream); } finally { try { if (stream != null) stream.close(); } catch (Exception ex) { } } } } } catch (Throwable tr) { Logger.e(TAG, \"fromUrl\", tr); throw tr; } finally { if (httpclient != null) httpclient.getConnectionManager().shutdown(); } return null; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void testSimpleQuery() throws Exception { JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\"); assertNotNull(dummySource); OutputStream os = ((ModifiableSource) dummySource).getOutputStream(); assertNotNull(os); String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\"; os.write(dummyContent.getBytes()); os.flush(); os.close(); JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\"); assertNotNull(source); os = ((ModifiableSource) source).getOutputStream(); assertNotNull(os); String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\"; os.write(content.getBytes()); os.flush(); os.close(); QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\"); assertNotNull(qResult); Collection results = qResult.getChildren(); assertEquals(1, results.size()); Iterator it = results.iterator(); JCRNodeSource rSrc = (JCRNodeSource) it.next(); InputStream rSrcIn = rSrc.getInputStream(); ByteArrayOutputStream actualOut = new ByteArrayOutputStream(); IOUtils.copy(rSrcIn, actualOut); rSrcIn.close(); assertEquals(content, actualOut.toString()); actualOut.close(); rSrc.delete(); }. \nCode2: public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) { int intResult = 0; String sql = \"UPDATE torneo\" + \" SET numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n### Response:", "ground_truth": "NO", "predict": "true.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1625, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public IOCacheArray(final File file, int capacity, final IIOCacheArrayObjectMaker iomaker, int chunkSize, String name) { super(capacity, null, chunkSize, name); generator = new ICacheArrayObjectMaker() { FileOutputStream outStream; FileInputStream inStream; FileChannel outChannel; FileChannel inChannel; boolean inited = false; private synchronized void init() { if (!inited) { try { outStream = new FileOutputStream(file); inStream = new FileInputStream(file); outChannel = outStream.getChannel(); inChannel = inStream.getChannel(); } catch (FileNotFoundException foe) { Logging.errorln(\"IOCacheArray constuctor error: Could not open file \" + file + \". Exception \" + foe); Logging.errorln(\"outStream \" + outStream + \" inStream \" + inStream + \" outchan \" + outChannel + \" inchannel \" + inChannel); } } inited = true; } public Object make(int itemIndex, int baseIndex, Object[] data) { init(); return iomaker.read(inChannel, itemIndex, baseIndex, data); } public boolean flush(int baseIndex, Object[] data) { init(); return iomaker.write(outChannel, baseIndex, data); } public CacheArrayBlockSummary summarize(int baseIndex, Object[] data) { init(); return iomaker.summarize(baseIndex, data); } }; }. \nCode2: public Vector split() { File nextFile = new File(filename); long fileSize = nextFile.length(); long parts = fileSize / splitSize; Vector vec = new Vector(new Long(parts).intValue()); if (debug) { System.out.println(\"File: \" + nextFile.getName() + \"\\nfileSize: \" + fileSize + \"\\nsplitSize: \" + splitSize + \"\\nparts: \" + parts); } if (fileSize % splitSize > 0) { parts++; } try { FileInputStream fis = new FileInputStream(nextFile); DataInputStream dis = new DataInputStream(fis); long bytesRead = 0; File destinationDirectory = new File(nextFile.getParent()); if (!destinationDirectory.exists()) { destinationDirectory.mkdir(); } for (long k = 0; k < parts; k++) { if (debug) { System.out.println(\"Splitting parts: \" + nextFile.getName() + \" into part \" + k); } String filePartName = nextFile.getName(); filePartName = filePartName + \".\" + String.valueOf(k); File outputFile = new File(destinationDirectory, filePartName); FileOutputStream fos = new FileOutputStream(outputFile); DataOutputStream dos = new DataOutputStream(fos); long bytesWritten = 0; while ((bytesWritten < splitSize) && (bytesRead < fileSize)) { dos.writeByte(dis.readByte()); bytesRead++; bytesWritten++; } dos.close(); vec.addElement(outputFile.getAbsolutePath()); if (debug) { System.out.println(\"Wrote \" + bytesWritten + \" bytes.\" + outputFile.getName() + \" created.\"); } } } catch (FileNotFoundException fnfe) { System.err.println(\"FileNotFoundException: \" + fnfe.getMessage()); vec = null; } catch (IOException ioe) { System.err.println(\"IOException: \" + ioe.getMessage()); vec = null; } return vec; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void run() { URL url; try { url = new URL(Config.UPDATE_SITE_URL); InputStream is = url.openStream(); Writer writer = new StringWriter(); char[] buffer = new char[1024]; Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); int n; while ((n = reader.read(buffer)) != -1) { writer.write(buffer, 0, n); } String updatePage = writer.toString(); is.close(); writer.close(); System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage); int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10; int pos2 = updatePage.indexOf(\"[/ANA-CABV]\"); int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13; int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\"); String currentVersion = updatePage.substring(pos1, pos2); currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion); if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) { downloadButton.setEnabled(true); label0.setText(mw.getLangMap().get(\"Update_Avalaible\")); } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\")); downloadURL = updatePage.substring(pos3, pos4); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \nCode2: @Override public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception { if (query == null) { return null; } String encodedQuery = \"\"; try { encodedQuery = URLEncoder.encode(query, \"UTF-8\"); } catch (UnsupportedEncodingException e) { throw e; } final int startAt = 0; final int pageNr = (startAt - 1) / 30; final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE)); HttpParams httpparams = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT); HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT); DefaultHttpClient httpclient = new DefaultHttpClient(httpparams); httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\"); HttpGet httpget = new HttpGet(url); HttpResponse response = httpclient.execute(httpget); InputStream instream = response.getEntity().getContent(); String html = HttpHelper.ConvertStreamToString(instream); instream.close(); return parseHtml(html); }. \n### Response:", "ground_truth": "NO", "predict": "@Override public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception { if (query == null) { return null; } String encodedQuery = \"\"; try { encodedQuery = URLEncoder.encode(query, \"UTF-8\"); } catch (UnsupportedEncodingException e) { throw e; } final int startAt = 0; final int pageNr = (startAt - 1) / 30; final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE)); HttpParams httpparams = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT); HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT); DefaultHttpClient httpclient = new DefaultHttpClient"}, {"ID": 1629, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void doRender() throws IOException { File file = new File(fileName); if (!file.exists()) { logger.error(\"Static resource not found: \" + fileName); isNotFound = true; return; } if (fileName.endsWith(\"xml\") || fileName.endsWith(\"asp\")) servletResponse.setContentType(\"text/xml\"); else if (fileName.endsWith(\"css\")) servletResponse.setContentType(\"text/css\"); else if (fileName.endsWith(\"js\")) servletResponse.setContentType(\"text/javascript\"); InputStream in = null; try { in = new FileInputStream(file); IOUtils.copy(in, servletResponse.getOutputStream()); logger.debug(\"Static resource rendered: \".concat(fileName)); } catch (FileNotFoundException e) { logger.error(\"Static resource not found: \" + fileName); isNotFound = true; } finally { IOUtils.closeQuietly(in); } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format!= FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen!= (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME); while (urls.hasMoreElements()) { URL url = urls.nextElement(); log.debug(\"Found: \" + url); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String className = null; while ((className = reader.readLine())!= null) { className = className.trim(); if (!\"\".equals(className) &&!className.startsWith(\"#\")) { log.debug(\"Found class: \" + className); Class<?> clazz = classLoader.loadClass(className); addClass(clazz); } } } } catch (IOException e) { e.printStackTrace(); log.error(e); } catch (ClassNotFoundException e) { e.printStackTrace(); log.error(e); } }. \nCode2: private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) { try { File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile); FileChannel inC = new FileInputStream(inFile).getChannel(); File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName); FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel(); File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName); FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel(); int fileSize = (int) inC.size(); int totalNoDataRows = fileSize / 7; ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize); int startIndex = 1, count = 0; short currentMovie = 1; while (mappedBuffer.hasRemaining()) { count++; short movieName = mappedBuffer.getShort(); int customer = mappedBuffer.getInt(); byte rating = mappedBuffer.get(); if (movieName!= currentMovie) { ByteBuffer outBuf1 = ByteBuffer.allocate(10); outBuf1.putShort(currentMovie); outBuf1.putInt(startIndex); outBuf1.putInt(count - 1); outBuf1.flip(); outC1.write(outBuf1); currentMovie = movieName; startIndex = count; } ByteBuffer outBuf2 = ByteBuffer.allocate(5); outBuf2.putInt(customer); outBuf2.put(rating); outBuf2.flip(); outC2.write(outBuf2); } ByteBuffer endOfIndexFile = ByteBuffer.allocate(10); endOfIndexFile.putShort(currentMovie); endOfIndexFile.putInt(startIndex); endOfIndexFile.putInt(100480506); endOfIndexFile.flip(); outC1.write(endOfIndexFile); outC1.close(); outC2. \n### Response:", "ground_truth": "NO", "predict": "true. \n\n// Code1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME); while (urls.hasMoreElements()) { URL url = urls.nextElement(); log.debug(\"Found: \" + url); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String className = null; while ((className = reader.readLine())!= null) { className = className.trim(); if (!\"\".equals(className) &&!className.startsWith(\"#\")) { log.debug(\"Found class: \" + className); Class<?> clazz = classLoader.loadClass(className);"}, {"ID": 1651, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public int addRecipe(Recipe recipe) throws Exception { PreparedStatement pst1 = null; PreparedStatement pst2 = null; ResultSet rs = null; int retVal = -1; try { conn = getConnection(); pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\"); pst1.setString(1, recipe.getName()); pst1.setString(2, recipe.getInstructions()); pst1.setInt(3, recipe.getCategoryId()); if (pst1.executeUpdate() > 0) { pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\"); pst2.setString(1, recipe.getName()); pst2.setString(2, recipe.getInstructions()); pst2.setInt(3, recipe.getCategoryId()); rs = pst2.executeQuery(); conn.commit(); if (rs.next()) { int id = rs.getInt(1); addIngredients(recipe, id); MainFrame.recipePanel.update(); retVal = id; } else { retVal = -1; } } else { retVal = -1; } conn.commit(); } catch (Exception e) { conn.rollback(); MainFrame.appendStatusText(\"Can't add recipe, the exception was \" + e.getMessage()); } finally { try { if (rs != null) rs.close(); rs = null; if (pst1 != null) pst1.close(); pst1 = null; if (pst2 != null) pst2.close(); pst2 = null; } catch (SQLException sqle) { MainFrame.appendStatusText(\"Can't close database connection.\"); } } return retVal; }. \nCode2: protected Object insertSingle(Object name, Object fact) throws SQLException { DFAgentDescription dfd = (DFAgentDescription) fact; AID agentAID = dfd.getName(); String agentName = agentAID.getName(); DFAgentDescription dfdToReturn = null; String batchErrMsg = \"\"; Connection conn = getConnectionWrapper().getConnection(); PreparedStatements pss = getPreparedStatements(); try { dfdToReturn = (DFAgentDescription) removeSingle(dfd.getName()); Date leaseTime = dfd.getLeaseTime(); long lt = (leaseTime != null ? leaseTime.getTime() : -1); String descrId = getGUID(); pss.stm_insAgentDescr.setString(1, descrId); pss.stm_insAgentDescr.setString(2, agentName); pss.stm_insAgentDescr.setString(3, String.valueOf(lt)); pss.stm_insAgentDescr.executeUpdate(); saveAID(agentAID); Iterator iter = dfd.getAllLanguages(); if (iter.hasNext()) { pss.stm_insLanguage.clearBatch(); while (iter.hasNext()) { pss.stm_insLanguage.setString(1, descrId); pss.stm_insLanguage.setString(2, (String) iter.next()); pss.stm_insLanguage.addBatch(); } pss.stm_insLanguage.executeBatch(); } iter = dfd.getAllOntologies(); if (iter.hasNext()) { pss.stm_insOntology.clearBatch(); while (iter.hasNext()) { pss.stm_insOntology.setString(1, descrId); pss.stm_insOntology.setString(2, (String) iter.next()); pss.stm_insOntology.addBatch(); } pss.stm_insOntology.executeBatch(); } iter = dfd.getAllProtocols(); if (iter.hasNext()) { pss.stm_insProtocol.clearBatch(); while (iter.hasNext()) { pss.stm_insProtocol.setString(1, descrId); pss.stm_insProtocol.setString(2, (String) iter.next()); pss.stm_insProtocol.addBatch(); } pss.stm_insProtocol.executeBatch(); } saveServices(descrId, dfd.getAllServices()); regsCnt++; if (regsCnt > MAX_REGISTER_WITHOUT_CLEAN) { regsCnt = 0; clean(); } conn.commit(); } catch (SQLException sqle) { try { conn.rollback(); } catch (SQLException se) { logger.log(Logger.SEVERE, \"Rollback for incomplete insertion of DFD for agent \" + dfd.getName() + \" failed.\", se); } throw sqle; } return dfdToReturn; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static List<Properties> findExtensions() { URL url = null; try { List<Properties> extensions = new ArrayList<Properties>(); Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\"); while (res.hasMoreElements()) { url = res.nextElement(); Properties prop = new Properties(); prop.load(url.openStream()); extensions.add(prop); } return extensions; } catch (IOException ioe) { String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm(); throw new RuntimeException(msg, ioe); } }. \nCode2: protected Control createDialogArea(Composite parent) { Composite composite = (Composite) super.createDialogArea(parent); setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\")); setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\")); Composite content = new Composite(composite, SWT.NONE); content.setLayoutData(new GridData(GridData.FILL_BOTH)); final int ncol = 1; GridLayout layout = new GridLayout(1, false); layout.numColumns = ncol; content.setLayout(layout); Browser browser = null; Text text = null; try { browser = new Browser(content, SWT.NONE); browser.setLayoutData(new GridData(GridData.FILL_BOTH)); } catch (Throwable t) { text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL); text.setLayoutData(new GridData(GridData.FILL_BOTH)); } URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\"); InputStream in = null; BufferedReader r = null; StringBuffer sb = new StringBuffer(); try { in = url.openStream(); r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\")); String line; while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\"); } catch (IOException e) { e.printStackTrace(); } finally { if (r != null) { try { r.close(); } catch (IOException e) { } } if (in != null) { try { in.close(); } catch (IOException e) { } } } if (browser != null", "ground_truth": "NO", "predict": ") { browser.dispose(); } if (text != null) { text.dispose(); } } return sb.toString(); }. \nCode1: private static List<Properties> findExtensions() { URL url = null; try { List<Properties> extensions = new ArrayList<Properties>(); Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\"); while (res.hasMoreElements()) { url = res.nextElement(); Properties prop = new Properties(); prop.load(url.openStream()); extensions.add(prop); } return extensions; } catch (IOException ioe) { String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm(); throw new RuntimeException(msg, ioe); } }. \nCode2: protected Control createDialogArea(Composite parent) { Composite composite ="}, {"ID": 1657, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void extractZip(Resource zip, FileObject outputDirectory) { ZipInputStream zis = null; try { zis = new ZipInputStream(zip.getResourceURL().openStream()); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { String[] pathElements = entry.getName().split(\"/\"); FileObject extractDir = outputDirectory; for (int i = 0; i < pathElements.length - 1; i++) { String pathElementName = pathElements[i]; FileObject pathElementFile = extractDir.resolveFile(pathElementName); if (!pathElementFile.exists()) { pathElementFile.createFolder(); } extractDir = pathElementFile; } String fileName = entry.getName(); if (fileName.endsWith(\"/\")) { fileName = fileName.substring(0, fileName.length() - 1); } if (fileName.contains(\"/\")) { fileName = fileName.substring(fileName.lastIndexOf('/') + 1); } if (entry.isDirectory()) { extractDir.resolveFile(fileName).createFolder(); } else { FileObject file = extractDir.resolveFile(fileName); file.createFile(); int size = (int) entry.getSize(); byte[] unpackBuffer = new byte[size]; zis.read(unpackBuffer, 0, size); InputStream in = null; OutputStream out = null; try { in = new ByteArrayInputStream(unpackBuffer); out = file.getContent().getOutputStream(); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } } } } catch (IOException e2) { throw new RuntimeException(e2); } finally { IOUtils.closeQuietly(zis); } }. \nCode2: public static File extract(File source, String filename, File target) { if (source.exists() == false || filename == null || filename.trim().length() < 1 || target == null) return null; boolean isDirectory = (filename.lastIndexOf(\"/\") == filename.length() - 1); try { Map contents = (Map) jarContents.get(source.getPath()); if (contents == null) { contents = new HashMap(); jarContents.put(source.getPath(), contents); ZipInputStream input = new ZipInputStream(new FileInputStream(source)); ZipEntry zipEntry = null; while ((zipEntry = input.getNextEntry()) != null) { if (zipEntry.isDirectory()) continue; contents.put(zipEntry.getName(), zipEntry); } input.close(); } if (isDirectory) { Iterator it = contents.keySet().iterator(); while (it.hasNext()) { String next = (String) it.next(); if (next.startsWith(filename)) { ZipEntry zipEntry = (ZipEntry) contents.get(next); int n = filename.length(); File newTarget = new File(target, zipEntry.getName().substring(n)); extract(source, next, newTarget); } } return target; } ZipEntry entry = (ZipEntry) contents.get(filename); ZipFile input = new ZipFile(source); InputStream in = input.getInputStream(entry); target.getParentFile().mkdirs(); int bytesRead; byte[] buffer = new byte[1024]; FileOutputStream output = new FileOutputStream(target); while ((bytesRead = in.read(buffer)) != -1) output.write(buffer, 0, bytesRead); output.close(); input.close(); return target; } catch (Exception ex) { ex.printStackTrace(); } return null; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @TestProperties(name = \"Simple test for adding different image files to report as link\") public void testAddLinkToImage() throws Exception { InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\"); report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\"))); report.addLink(\"Link to JPG\", \"splash.jpg\"); report.addLink(\"Link to PNG\", \"blue.png\"); report.addLink(\"Link to GIF\", \"classDir.gif\"); }. \nCode2: public static String getMessageDigest(String input) { if (input == null) { log.warn(\"Returning SHA-1 null value for null input\"); return null; } try { MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); md.update(input.getBytes(\"UTF-8\")); byte[] bytes = md.digest(); return new BASE64Encoder().encode(bytes); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(e.getMessage()); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e.getMessage()); } }. \n### Response:", "ground_truth": "NO", "predict": "@TestProperties(name = \"Simple test for adding different image files to report as link\") public void testAddLinkToImage() throws Exception { InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\"); report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\"))); in = this.getClass().getClassLoader().getResourceAs"}, {"ID": 1669, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \nCode2: public static String MD5(String str, String encoding) { MessageDigest messageDigest = null; try { messageDigest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } messageDigest.reset(); try { messageDigest.update(str.getBytes(encoding)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } byte[] byteArray = messageDigest.digest(); StringBuffer md5StrBuff = new StringBuffer(); for (int i = 0; i < byteArray.length; i++) { if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i])); } return md5StrBuff.toString(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void run() { long time = System.currentTimeMillis(); logger.info(\"Version: \" + version); String hostname = properties.getProperty(\"mercuriushost\"); String protocol = properties.getProperty(\"mercuriusprotocol\"); String port = properties.getProperty(\"mercuriusport\"); String path = properties.getProperty(\"mercuriuspath\"); String action = properties.getProperty(\"mercuriusaction\"); logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time)); String xml = timexfrmk.getUnsynchedSessionsXMLFormat(); logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time)); if (timexfrmk.getSessionCount() > 0) { try { logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time)); String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\"); if (isAdminFeedKeySet()) { data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\"); logger.debug(\"Using adminfeedkey to authenticate\"); } else { Authenticator.setDefault(new CustomAuthenticator(user, password)); logger.debug(\"Using user/pwd to authenticate\"); } String u = protocol + \"://\" + hostname + \":\" + port + path; logger.debug(\"Posting xml data to: \" + u); URL url = new URL(u); URLConnection conn = url.openConnection(); conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; StringBuffer s = new StringBuffer(); while ((line = rd.readLine()) != null) { s.append(line); } if (s.length() > 0) { logger.debug(s.toString()); if (s.toString().indexOf(\"Result:\") != -1) { logger.info(s.toString().substring(s.toString().indexOf(\"Result:\"))); if (s.toString().indexOf(\"Result: Successful\") != -1) { timexfrmk.updateSessionsStatus(); } } else { logger.error(s.toString()); } } else { logger.info(\"No data returned\"); } wr.close(); rd.close(); } catch (MalformedURLException e) { logger.error(e); logger.trace(e, e); } catch (IOException e) { logger.error(e); logger.trace(e, e); } catch (Exception e) { logger.error(e); logger.trace(e, e); } } else { logger.info(\"There is nothing", "ground_truth": "NO", "predict": " to do\"); }!!!!!!!!!!!!!!!!!!"}, {"ID": 1706, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Action(value = \"ajaxFileUploads\", results = { }) public void ajaxFileUploads() throws IOException { String extName = \"\"; String newFilename = \"\"; String nowTimeStr = \"\"; String realpath = \"\"; if (Validate.StrNotNull(this.getImgdirpath())) { realpath = \"Uploads/\" + this.getImgdirpath() + \"/\"; } else { realpath = this.isexistdir(); } SimpleDateFormat sDateFormat; Random r = new Random(); String savePath = ServletActionContext.getServletContext().getRealPath(\"\"); savePath = savePath + realpath; HttpServletResponse response = ServletActionContext.getResponse(); int rannum = (int) (r.nextDouble() * (99999 - 1000 + 1)) + 10000; sDateFormat = new SimpleDateFormat(\"yyyyMMddHHmmss\"); nowTimeStr = sDateFormat.format(new Date()); String filename = request.getHeader(\"X-File-Name\"); if (filename.lastIndexOf(\".\") >= 0) { extName = filename.substring(filename.lastIndexOf(\".\")); } newFilename = nowTimeStr + rannum + extName; PrintWriter writer = null; InputStream is = null; FileOutputStream fos = null; try { writer = response.getWriter(); } catch (IOException ex) { log.debug(ImgTAction.class.getName() + \"has thrown an exception:\" + ex.getMessage()); } try { is = request.getInputStream(); fos = new FileOutputStream(new File(savePath + newFilename)); IOUtils.copy(is, fos); response.setStatus(response.SC_OK); writer.print(\"{success:'\" + realpath + newFilename + \"'}\"); } catch (FileNotFoundException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log.debug(ImgTAction.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } catch (IOException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log.debug(ImgTAction.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } finally { try { this.setImgdirpath(null); fos.close(); is.close(); } catch (IOException ignored) { } } writer.flush(); writer.close(); }. \nCode2: private void addEMInformation() { try { long emDate = System.currentTimeMillis(); if (_local == true) { File emFile = new File(\"emprotz.dat\"); if (!emFile.exists()) { return; } emDate = emFile.lastModified(); } if (emDate > this._emFileDate) { this._emFileDate = emDate; this._emDate = emDate; for (int ii = 0; ii < this._projectInfo.size(); ii++) { Information info = getInfo(ii); if (info != null) { info._emDeadline = null; info._emFrames = null; info._emValue = null; } } Reader reader = null; if (_local == true) { reader = new FileReader(\"emprotz.dat\"); } else { StringBuffer urlName = new StringBuffer(); urlName.append(\"http://home.comcast.net/\"); urlName.append(\"~wxdude1/emsite/download/\"); urlName.append(\"emprotz.zip\"); try { URL url = new URL(urlName.toString()); InputStream stream = url.openStream(); ZipInputStream zip = new ZipInputStream(stream); zip.getNextEntry(); reader = new InputStreamReader(zip); } catch (MalformedURLException mue) { mue.printStackTrace(); } } BufferedReader file = new BufferedReader(reader); try { String line1 = null; int count = 0; while ((line1 = file.readLine()) != null) { String line2 = (line1 != null) ? file.readLine() : null; String line3 = (line2 != null) ? file.readLine() : null; String line4 = (line3 != null) ? file.readLine() : null; count++; if ((count > 1) && (line1 != null) && (line2 != null) && (line3 != null) && (line4 != null)) { if (line1.length() > 2) { int posBegin = line1.indexOf(\"\\\"\", 0); int posEnd = line1.indexOf(\"\\\"\", posBegin + 1); if ((posBegin >= 0) && (posEnd >= 0)) { String project = line1.substring(posBegin + 1, posEnd - posBegin); int projectNum = Integer.parseInt(project); Integer deadline = Integer.valueOf(line2.trim()); Double value = Double.valueOf(line3.trim()); Integer frames = Integer.valueOf(line4.trim()); Information info = getInfo(projectNum); if (info == null) { info = createInfo(projectNum); } if (info._emValue == null) { info._emDeadline = deadline; info._emFrames = frames; info._emValue = value; } } } } } } catch (Exception e) { e.printStackTrace(); } finally { file.close(); } } } catch (FileNotFoundException e) { } catch (IOException e) { } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else { GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]); } } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \nCode2: public ArrayList<String> showTopLetters() { int[] tempArray = new int[engCountLetters.length]; char[] tempArrayLetters = new char[abcEng.length]; ArrayList<String> resultTopFiveLetters = new ArrayList<String>(); tempArray = engCountLetters.clone(); tempArrayLetters = abcEng.clone(); int tempCount; char tempLetters; for (int j = 0; j < (abcEng.length * abcEng.length); j++) { for (int i = 0; i < abcEng.length - 1; i++) { if (tempArray[i] > tempArray[i + 1]) { tempCount = tempArray[i]; tempLetters = tempArrayLetters[i]; tempArray[i] = tempArray[i + 1]; temp", "ground_truth": "NO", "predict": "Array[i + 1] = tempCount; tempArrayLetters[i] = tempArrayLetters[i + 1]; tempArrayLetters[i + 1] = tempLetters; } } } for (int i = 0; i < abcEng.length; i++) { if (tempArray[i] > 0) { resultTopFiveLetters.add(abcEng.charAt(i) + \": \" + tempArray[i]); } } return resultTopFiveLetters; \n}"}, {"ID": 1709, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private static void unzipEntry(final ZipFile zipfile, final ZipEntry entry, final File outputDir) throws IOException { if (entry.isDirectory()) { createDir(new File(outputDir, entry.getName())); return; } File outputFile = new File(outputDir, entry.getName()); if (!outputFile.getParentFile().exists()) { createDir(outputFile.getParentFile()); } BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile)); try { IOUtils.copy(inputStream, outputStream); } finally { outputStream.close(); inputStream.close(); } }. \nCode2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\"export_page\"); query = query.replace(\"[RANDOM_INT]\", \"\" + random.nextInt()); int statusCode = -1; GetMethod get = new GetMethod(query); if (log.isInfoEnabled()) log.info(\"getting all contacts ...\"); try { statusCode = client.executeMethod(get); if (statusCode != 200) throw new GmailException(\"In contacts export page: Status code expected: 200 -> Status code returned: \" + statusCode); } catch (HttpException e) { throw new GmailException(\"HttpException in contacts export page:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in contacts export page:\" + e.getMessage()); } finally { get.releaseConnection(); } if (log.isTraceEnabled()) log.trace(\"accessing contacts export page successful...\"); String query_post = properties.getString(\"outlook_export_page\"); PostMethod post = new PostMethod(query_post); post.addRequestHeader(\"Accept-Encoding\", \"gzip,deflate\"); post.addRequestHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.8\"); NameValuePair[] data = { new NameValuePair(\"at\", getCookie(\"GMAIL_AT\")), new NameValuePair(\"ecf\", \"o\"), new NameValuePair(\"ac\", \"Export Contacts\") }; post.setRequestBody(data); if (log.isTraceEnabled()) log.trace(\"getting contacts csv file...\"); try { statusCode = client.executeMethod(post); if (statusCode != 200) throw new GmailException(\"In csv file post: Status code expected: 200 -> Status code returned: \" + statusCode); if (log.isTraceEnabled()) log.trace(\"Gmail: csv charset: \" + post.getResponseCharSet()); GMAIL_OUTPUT_CHARSET = post.getResponseCharSet(); InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet()); CSVReader reader = new CSVReader(isr); List csvEntries = reader.readAll(); reader.close(); ArrayList<GmailContact> contacts = new ArrayList<GmailContact>(); MessageDigest m = MessageDigest.getInstance(\"MD5\"); if (log.isTraceEnabled()) log.trace(\"creating Gmail contacts...\"); for (int i = 1; i < csvEntries.size(); i++) { GmailContact contact = new GmailContact(); String[] value = (String[]) csvEntries.get(i); for (int j = 0; j < value.length; j++) { switch(j) { case 0: contact.setName(value[j]); break; case 1: contact.setEmail(value[j]); if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]); break; case 2: contact.setNotes(value[j]); break; case 3: contact.setEmail2(value[j]); break; case 4: contact.setEmail3(value[j]); break; case 5: contact.setMobilePhone(value[j]); break; case 6: contact.setPager(value[j]); break; case 7: contact.setCompany(value[j]); break; case 8: contact.setJobTitle(value[j]); break; case 9: contact.setHomePhone(value[j]); break; case 10: contact.setHomePhone2(value[j]); break; case 11: contact.setHomeFax(value[j]); break; case 12: contact.setHomeAddress(value[j]); break; case 13: contact.setBusinessPhone(value[j]); break; case 14: contact.setBusinessPhone2(value[j]); break; case 15: contact.setBusinessFax(value[j]); break; case 16: contact.setBusinessAddress(value[j]); break; case 17: contact.setOtherPhone(value[j]); break; case 18: contact.setOtherFax(value[j]); break; case 19: contact.setOtherAddress(value[j]); break; } } m.update(contact.toString().getBytes()); if (log.isTraceEnabled()) log.trace(\"setting Md5 Hash...\"); contact.setMd5Hash(new BigInteger(m.digest()).toString()); contacts.add(contact); } if (log.isTraceEnabled()) log.trace(\"Mapping contacts uid...\"); Collections.sort(contacts); ArrayList<GmailContact> idList = getAllContactsID(); for (int i = 0; i < idList.size(); i++) { contacts.get(i).setId(idList.get(i).getId()); } if (log.isInfoEnabled()) log.info(\"getting all contacts info successful...\"); return contacts; } catch (HttpException e) { throw new GmailException(\"HttpException in csv file post:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in csv file post:\" + e.getMessage()); } catch (NoSuchAlgorithmException e) { throw new GmailException(\"No such md5 algorithm \" + e.getMessage()); } finally { post.releaseConnection(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { String code = \"\"; UserFunction function = null; ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\"); try { URL url = new URL(codeBase, directoryAndFile); InputStream in = url.openStream(); BufferedReader inReader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = inReader.readLine()) != null) { code += line + \"\\n\"; } inReader.close(); } catch (Exception e) { Errors.throwMathLibException(\"MFileLoader: m-file exception via web\"); } ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\"); FunctionParser funcParser = new FunctionParser(); function = funcParser.parseFunction(code); function.setName(mFileName); ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\"); return function; }. \nCode2: private String getPrefsKey(String key) { try { if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\"); MD5.reset(); MD5.update(key.getBytes(\"UTF-8", "ground_truth": "NO", "predict": "\")); return MD5.digest().toString(); } catch (Exception e) { throw new GmailException(\"MD5 error: \" + e.getMessage()); } }. \nCode3: public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { String code = \"\"; UserFunction function = null; ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\"); try { URL url = new URL(codeBase, directoryAndFile); InputStream in = url.openStream(); BufferedReader inReader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = inReader.readLine()) != null) { code += line + \"\\n\"; } inReader.close(); } catch (Exception e) { Errors.throwMathLibException(\"MFileLoader: m-file exception via web\"); } ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\""}, {"ID": 1745, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: private InputStream callService(String text) { InputStream in = null; try { URL url = new URL(SERVLET_URL); URLConnection conn = url.openConnection(); HttpURLConnection httpConn = (HttpURLConnection) conn; httpConn.setRequestMethod(\"POST\"); httpConn.setDoInput(true); httpConn.setDoOutput(true); httpConn.connect(); DataOutputStream dataStream = new DataOutputStream(conn.getOutputStream()); dataStream.writeBytes(text); dataStream.flush(); dataStream.close(); int responseCode = httpConn.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) { in = httpConn.getInputStream(); } } catch (Exception ex) { ex.printStackTrace(); } return in; }. \nCode2: public boolean saveNote(NoteData n) { String query; try { conn.setAutoCommit(false); Statement stmt = null; ResultSet rset = null; stmt = conn.createStatement(); query = \"select * from notes where noteid = \" + n.getID(); rset = stmt.executeQuery(query); if (rset.next()) { query = \"UPDATE notes SET title = '\" + escapeCharacters(n.getTitle()) + \"', keywords = '\" + escapeCharacters(n.getKeywords()) + \"' WHERE noteid = \" + n.getID(); try { stmt.executeUpdate(query); } catch (SQLException e) { e.printStackTrace(); conn.rollback(); conn.setAutoCommit(true); return false; } LinkedList<FieldData> fields = n.getFields(); ListIterator<FieldData> iter = fields.listIterator(0); FieldData f = null; PreparedStatement pstmt = conn.prepareStatement(\"UPDATE fielddata SET data = ? WHERE noteid = ? AND fieldid = ?\"); try { while (iter.hasNext()) { f = iter.next(); if (f instanceof FieldDataImage) { System.out.println(\"field is an image.\"); pstmt.setBytes(1, ((FieldDataImage) f).getDataBytes()); } else { System.out.println(\"field is not an image\"); pstmt.setString(1, f.getData()); } pstmt.setInt(2, n.getID()); pstmt.setInt(3, f.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } query = \"DELETE FROM links WHERE (note1id = \" + n.getID() + \" OR note2id = \" + n.getID() + \")\"; try { stmt.execute(query); } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } Vector<Link> associations = n.getAssociations(); ListIterator<Link> itr = associations.listIterator(); Link association = null; pstmt = conn.prepareStatement(\"INSERT INTO links (note1id, note2id) VALUES (?, ?)\"); try { while (itr.hasNext()) { association = itr.next(); pstmt.setInt(1, n.getID()); pstmt.setInt(2, association.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } } else { query = \"INSERT INTO notes (templateid, title, keywords) VALUES (\" + n.getTemplate().getID() + \", '\" + escapeCharacters(n.getTitle()) + \"', '\" + escapeCharacters(n.getKeywords()) + \"')\"; try { stmt.executeUpdate(query); } catch (SQLException e) { e.printStackTrace(); conn.rollback(); conn.setAutoCommit(true); return false; } LinkedList<FieldData> fields = n.getFields(); ListIterator<FieldData> iter = fields.listIterator(0); FieldData f = null; n.setID(Integer.parseInt(executeMySQLGet(\"SELECT LAST_INSERT_ID()\"))); PreparedStatement pstmt; try { pstmt = conn.prepareStatement(\"INSERT INTO fielddata (noteid, fieldid, data) VALUES (?,?,?)\"); while (iter.hasNext()) { f = iter.next(); if (f instanceof FieldDataImage) { System.out.println(\"field is an image.\"); pstmt.setBytes(3, ((FieldDataImage) f).getDataBytes()); } else { System.out.println(\"field is not an image\"); pstmt.setString(3, f.getData()); } pstmt.setInt(1, n.getID()); pstmt.setInt(2, f.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } Vector<Link> assoc = n.getAssociations(); Iterator<Link> itr = assoc.listIterator(); Link l = null; pstmt = conn.prepareStatement(\"INSERT INTO links (note1id, note2id) VALUES (?,?)\"); try { while (itr.hasNext()) { l = itr.next(); pstmt.setInt(1, n.getID()); pstmt.setInt(2, l.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } } conn.commit(); conn.setAutoCommit(true); } catch (SQLException ex) { ex.printStackTrace(); return false; } return true; }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static final void main(String[] args) throws Exception { HttpClient httpclient = new DefaultHttpClient(); HttpGet httpget = new HttpGet(\"http://www.apache.org/\"); System.out.println(\"executing request \" + httpget.getURI()); HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) { System.out.println(\"Response content length: \" + entity.getContentLength()); } System.out.println(\"----------------------------------------\"); httpget.abort(); }. \nCode2: public FTPFile[] connect() { if (ftpe == null) { ftpe = new FTPEvent(this); } if (ftp == null) { ftp = new FTPClient(); } else if (ftp.isConnected()) { path = \"\"; try { ftp.disconnect(); } catch (IOException e1) { log.error(\"could not disconnect -\" + e1.getMessage()); } } currentDir = new FTPFile[0]; log.debug(\"try to connect\"); try { int reply; ftp.connect(ftpsite); reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); log.error(\"FTP server refused connection.\"); } } catch (IOException e) { log.error(\"FTPConnection error: \" + e.getMessage", "ground_truth": "NO", "predict": "()); } if (ftp.isConnected()) { log.debug(\"connected\"); } else { log.error(\"could not connect\"); } return currentDir; \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1753, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void decompress(final File file, final File folder, final boolean deleteZipAfter) throws IOException { final ZipInputStream zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(file.getCanonicalFile()))); ZipEntry ze; try { while (null != (ze = zis.getNextEntry())) { final File f = new File(folder.getCanonicalPath(), ze.getName()); if (f.exists()) f.delete(); if (ze.isDirectory()) { f.mkdirs(); continue; } f.getParentFile().mkdirs(); final OutputStream fos = new BufferedOutputStream(new FileOutputStream(f)); try { try { final byte[] buf = new byte[8192]; int bytesRead; while (-1 != (bytesRead = zis.read(buf))) fos.write(buf, 0, bytesRead); } finally { fos.close(); } } catch (final IOException ioe) { f.delete(); throw ioe; } } } finally { zis.close(); } if (deleteZipAfter) file.delete(); }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\"); logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString); URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString); logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile()); HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection(); HttpURLConnection.setFollowRedirects(false); httpURLConnection.connect(); response.setStatus(httpURLConnection.getResponseCode()); logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\"); logger.debug(\"[headers]\"); for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) { if (header.getKey() != null) { for (String value : header.getValue()) { if (value != null) { logger.debug(header.getKey() + \": \" + value); if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) { response.addHeader(header.getKey(), value); } } } } } logger.debug(\"[/headers]\"); InputStream inputStream = httpURLConnection.getInputStream(); OutputStream outputStream = response.getOutputStream(); IOUtils.copy(inputStream, outputStream); }. \nCode2: protected Document getRawResults(String urlString, Map args) throws Exception { int count = 0; Iterator keys = args.keySet().iterator(); while (keys.hasNext()) { String sep = count++ == 0 ? \"?\" : \"&\"; String name = (String) keys.next(); if (args.get(name) != null) { urlString += sep + name + \"=\" + args.get(name); } } URL url = new URL(urlString); URLConnection conn = url.openConnection(); conn.connect(); SAXBuilder builder = new SAXBuilder(); return builder.build(conn.", "ground_truth": "NO", "predict": "getInputStream()); }. \nMap<String, String> args = new HashMap<String, String>(); \nargs.put(\"id\", \"12345\"); \nargs.put(\"name\", \"John Doe\"); \nString urlString = \"http://example.com/?id=12345&name=John+Doe\"; \nDocument doc = getRawResults(urlString, args); \n// ..."}, {"ID": 1760, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void delUser(User user) throws SQLException, IOException, ClassNotFoundException { String dbUserID; String stockSymbol; Statement stmt = con.createStatement(); try { con.setAutoCommit(false); dbUserID = user.getUserID(); if (getUser(dbUserID) != null) { ResultSet rs1 = stmt.executeQuery(\"SELECT userID, symbol \" + \"FROM UserStocks WHERE userID = '\" + dbUserID + \"'\"); while (rs1.next()) { try { stockSymbol = rs1.getString(\"symbol\"); delUserStocks(dbUserID, stockSymbol); } catch (SQLException ex) { throw new SQLException(\"Deletion of user stock holding failed: \" + ex.getMessage()); } } try { stmt.executeUpdate(\"DELETE FROM Users WHERE \" + \"userID = '\" + dbUserID + \"'\"); } catch (SQLException ex) { throw new SQLException(\"User deletion failed: \" + ex.getMessage()); } } else throw new IOException(\"User not found in database - cannot delete.\"); try { con.commit(); } catch (SQLException ex) { throw new SQLException(\"Transaction commit failed: \" + ex.getMessage()); } } catch (SQLException ex) { try { con.rollback(); } catch (SQLException sqx) { throw new SQLException(\"Transaction failed then rollback failed: \" + sqx.getMessage()); } throw new SQLException(\"Transaction failed; was rolled back: \" + ex.getMessage()); } stmt.close(); }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void insertDocumentToURL(String file, String target) throws IOException { InputStream is = null; OutputStream os = null; try { is = new FileInputStream(file); final URL url = new URL(target); final URLConnection connection = url.openConnection(); os = connection.getOutputStream(); TestTools.copyStream(is, os); } finally { if (is != null) { is.close(); } if (os != null) { os.close(); } } }. \nCode2: public static void copyFromTo(File srcFile, File destFile) { FileChannel in = null, out = null; FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(srcFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + srcFile.toString()); System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\"); System.exit(-1); } try { fos = new FileOutputStream(destFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + destFile.toString()); System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\"); System.exit(-1); } try { in = fis.getChannel(); out = fos.getChannel(); in.transferTo(0, in.size(), out); fos.flush(); fos.close(); out.close(); fis.close(); in.close(); System.out.println(\"Completed copying \" + srcFile.toString() + \" to", "ground_truth": "NO", "predict": " \" + destFile.toString()); } catch (IOException ioe) { System.out.println(\"Error copying file: \" + ioe.getMessage()); System.exit(-1); } }. \n}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1790, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: static void copy(String src, String dest) throws IOException { File ifp = new File(src); File ofp = new File(dest); if (ifp.exists() == false) { throw new IOException(\"file '\" + src + \"' does not exist\"); } FileInputStream fis = new FileInputStream(ifp); FileOutputStream fos = new FileOutputStream(ofp); byte[] b = new byte[1024]; while (fis.read(b) > 0) fos.write(b); fis.close(); fos.close(); }. \nCode2: public void upload() throws UnknownHostException, SocketException, FTPConnectionClosedException, LoginFailedException, DirectoryChangeFailedException, CopyStreamException, RefusedConnectionException, IOException { final int NUM_XML_FILES = 2; final String META_XML_SUFFIX = \"_meta.xml\"; final String FILES_XML_SUFFIX = \"_files.xml\"; final String username = getUsername(); final String password = getPassword(); if (getFtpServer() == null) { throw new IllegalStateException(\"ftp server not set\"); } if (getFtpPath() == null) { throw new IllegalStateException(\"ftp path not set\"); } if (username == null) { throw new IllegalStateException(\"username not set\"); } if (password == null) { throw new IllegalStateException(\"password not set\"); } final String metaXmlString = serializeDocument(getMetaDocument()); final String filesXmlString = serializeDocument(getFilesDocument()); final byte[] metaXmlBytes = metaXmlString.getBytes(); final byte[] filesXmlBytes = filesXmlString.getBytes(); final int metaXmlLength = metaXmlBytes.length; final int filesXmlLength = filesXmlBytes.length; final Collection files = getFiles(); final int totalFiles = NUM_XML_FILES + files.size(); final String[] fileNames = new String[totalFiles]; final long[] fileSizes = new long[totalFiles]; final String metaXmlName = getIdentifier() + META_XML_SUFFIX; fileNames[0] = metaXmlName; fileSizes[0] = metaXmlLength; final String filesXmlName = getIdentifier() + FILES_XML_SUFFIX; fileNames[1] = filesXmlName; fileSizes[1] = filesXmlLength; int j = 2; for (Iterator i = files.iterator(); i.hasNext(); ) { final ArchiveFile f = (ArchiveFile) i.next(); fileNames[j] = f.getRemoteFileName(); fileSizes[j] = f.getFileSize(); j++; } for (int i = 0; i < fileSizes.length; i++) { _fileNames2Progress.put(fileNames[i], new UploadFileProgress(fileSizes[i])); _totalUploadSize += fileSizes[i]; } FTPClient ftp = new FTPClient(); try { if (isCancelled()) { return; } ftp.enterLocalPassiveMode(); if (isCancelled()) { return; } ftp.connect(getFtpServer()); final int reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { throw new RefusedConnectionException(getFtpServer() + \"refused FTP connection\"); } if (isCancelled()) { return; } if (!ftp.login(username, password)) { throw new LoginFailedException(); } try { if (!ftp.changeWorkingDirectory(getFtpPath())) { if (!isFtpDirPreMade() && !ftp.makeDirectory(getFtpPath())) { throw new DirectoryChangeFailedException(); } if (isCancelled()) { return; } if (!ftp.changeWorkingDirectory(getFtpPath())) { throw new DirectoryChangeFailedException(); } } if (isCancelled()) { return; } connected(); uploadFile(metaXmlName, new ByteArrayInputStream(metaXmlBytes), ftp); uploadFile(filesXmlName, new ByteArrayInputStream(filesXmlBytes), ftp); if (isCancelled()) { return; } ftp.setFileType(FTP.BINARY_FILE_TYPE); for (final Iterator i = files.iterator(); i.hasNext(); ) { final ArchiveFile f = (ArchiveFile) i.next(); uploadFile(f.getRemoteFileName(), new FileInputStream(f.getIOFile()), ftp); } } catch (InterruptedIOException ioe) { return; } finally { ftp.logout(); } } finally { try { ftp.disconnect(); } catch (IOException e) { } } if (isCancelled()) { return; } checkinStarted(); if (isCancelled()) { return; } checkin(); if (isCancelled()) { return; } checkinCompleted(); }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public List load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace(\"load \" + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = \"MbeansDescriptorsDynamicMBeanSource\"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString(); type = param; inputsource = url.openStream(); if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof File) { location = ((File) source).getAbsolutePath(); inputsource = new FileInputStream((File) source); type = param; if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof InputStream) { type = param; inputsource = source; } else if (source instanceof Class) { location = ((Class) source).getName(); type = param; inputsource = source; if (sourceType == null) { sourceType = \"MbeansDescriptorsIntrospectionSource\"; } } if (sourceType == null) { sourceType = \"MbeansDescriptorsDigesterSource\"; } ModelerSource ds = getModelerSource(sourceType); List mbeans = ds.loadDescriptors(this, location, type, inputsource); return mbeans; }. \nCode2: @Test public void test_validate_geo_getEvents() { try { SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\"); File schemaLocation = new File(\"tes.xsd\"); Schema schema = factory.newSchema(schemaLocation); Validator validator = schema.newValidator(); URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\"); InputStream inputStream = url.openStream(); Source source = new StreamSource(inputStream); validator.validate(source); } catch (IOException ex) { Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex); assertFalse(\"File not found\", true); } catch (SAXException ex) { Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex", "ground_truth": "NO", "predict": "); assertFalse(\"File not found\", true); } catch (Exception ex) { Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex); assertFalse(\"File not found\", true); } }. \npublic List load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace(\"load \" + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = \"MbeansDescriptorsDynamicMBeanSource\"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString(); type = param; inputsource = url.openStream(); if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof File) { location = ((File)"}, {"ID": 1846, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void main(String[] args) { try { String completePath = null; String predictionFileName = null; if (args.length == 2) { completePath = args[0]; predictionFileName = args[1]; } else { System.out.println(\"Please provide complete path to training_set parent folder as an argument. EXITING\"); System.exit(0); } File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); ByteBuffer mappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); MovieLimitsTHash = new TShortObjectHashMap(17770, 1); int i = 0, totalcount = 0; short movie; int startIndex, endIndex; TIntArrayList a; while (mappedfile.hasRemaining()) { movie = mappedfile.getShort(); startIndex = mappedfile.getInt(); endIndex = mappedfile.getInt(); a = new TIntArrayList(2); a.add(startIndex); a.add(endIndex); MovieLimitsTHash.put(movie, a); } inC.close(); mappedfile = null; System.out.println(\"Loaded movie index hash\"); inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustIndexFileName); inC = new FileInputStream(inputFile).getChannel(); filesize = (int) inC.size(); mappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); CustomerLimitsTHash = new TIntObjectHashMap(480189, 1); int custid; while (mappedfile.hasRemaining()) { custid = mappedfile.getInt(); startIndex = mappedfile.getInt(); endIndex = mappedfile.getInt(); a = new TIntArrayList(2); a.add(startIndex); a.add(endIndex); CustomerLimitsTHash.put(custid, a); } inC.close(); mappedfile = null; System.out.println(\"Loaded customer index hash\"); MoviesAndRatingsPerCustomer = InitializeMovieRatingsForCustomerHashMap(completePath, CustomerLimitsTHash); System.out.println(\"Populated MoviesAndRatingsPerCustomer hashmap\"); File outfile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + predictionFileName); FileChannel out = new FileOutputStream(outfile, true).getChannel(); inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"formattedProbeData.txt\"); inC = new FileInputStream(inputFile).getChannel(); filesize = (int) inC.size(); ByteBuffer probemappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); int custAndRatingSize = 0; TIntByteHashMap custsandratings = new TIntByteHashMap(); int ignoreProcessedRows = 0; int movieViewershipSize = 0; while (probemappedfile.hasRemaining()) { short testmovie = probemappedfile.getShort(); int testCustomer = probemappedfile.getInt(); if ((CustomersAndRatingsPerMovie != null) && (CustomersAndRatingsPerMovie.containsKey(testmovie))) { } else { CustomersAndRatingsPerMovie = InitializeCustomerRatingsForMovieHashMap(completePath, testmovie); custsandratings = (TIntByteHashMap) CustomersAndRatingsPerMovie.get(testmovie); custAndRatingSize = custsandratings.size(); } TShortByteHashMap testCustMovieAndRatingsMap = (TShortByteHashMap) MoviesAndRatingsPerCustomer.get(testCustomer); short[] testCustMovies = testCustMovieAndRatingsMap.keys(); float finalPrediction = 0; finalPrediction = predictRating(testCustomer, testmovie, custsandratings, custAndRatingSize, testCustMovies, testCustMovieAndRatingsMap); System.out.println(\"prediction for movie: \" + testmovie + \" for customer \" + testCustomer + \" is \" + finalPrediction); ByteBuffer buf = ByteBuffer.allocate(11); buf.putShort(testmovie); buf.putInt(testCustomer); buf.putFloat(finalPrediction); buf.flip(); out.write(buf); buf = null; testCustMovieAndRatingsMap = null; testCustMovies = null; } } catch (Exception e) { e.printStackTrace(); } }. \nCode2: public void fileCopy(File inFile, File outFile) { try { FileInputStream in = new FileInputStream(inFile); FileOutputStream out = new FileOutputStream(outFile); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } catch (IOException e) { System.err.println(\"Hubo un error de entrada/salida!!!\"); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static boolean check(String urlStr) { try { URL url = new URL(urlStr); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setConnectTimeout(2000); urlConnection.getContent(); } catch (Exception e) { logger.error(\"There is no internet connection\", e); return false; } return true; }. \nCode2: public void update(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try { dbo = (ERDBOperation) createDBOperation(); String url = \"\"; boolean flag = true; StringTokenizer st = null; conn = dbo.getConnection(); conn.setAutoCommit(false); ps = conn.prepareStatement(sqlInitial); rs = ps.executeQuery(); if (rs.next()) url = rs.getString(1); if (!url.equals(\"\")) { st = new StringTokenizer(url, \",\"); String sortDocId = \"\"; while (st.hasMoreTokens()) { if (flag) { sortDocId = \"'\" + st.nextToken() + \"'\"; flag = false; } else { sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\"; } } String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField; ps = conn.prepareStatement(sqlsort); rs = ps.executeQuery(); String sortURL = \"\"; boolean sortflag = true; while (rs.next()) { if (sortflag) { sortURL = rs.getString(1); sortflag = false; } else { sortURL = sortURL + \",\" + rs.getString(1); } } ps = conn.prepareStatement(sqlsortURL", "ground_truth": "NO", "predict": "); rs = ps.executeQuery(); } } catch (SQLException e) { logger.error(\"Error while sorting the document\", e); } finally { conn.close(); } }. \nCode1: public static String getSortURL(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try"}, {"ID": 1852, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static void copy(File from_file, File to_file) throws IOException { if (!from_file.exists()) { throw new IOException(\"FileCopy: no such source file: \" + from_file.getPath()); } if (!from_file.isFile()) { throw new IOException(\"FileCopy: can't copy directory: \" + from_file.getPath()); } if (!from_file.canRead()) { throw new IOException(\"FileCopy: source file is unreadable: \" + from_file.getPath()); } if (to_file.isDirectory()) { to_file = new File(to_file, from_file.getName()); } if (to_file.exists()) { if (!to_file.canWrite()) { throw new IOException(\"FileCopy: destination file is unwriteable: \" + to_file.getPath()); } int choice = JOptionPane.showConfirmDialog(null, \"Overwrite existing file \" + to_file.getPath(), \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE); if (choice != JOptionPane.YES_OPTION) { throw new IOException(\"FileCopy: existing file was not overwritten.\"); } } else { String parent = to_file.getParent(); if (parent == null) { parent = Globals.getDefaultPath(); } File dir = new File(parent); if (!dir.exists()) { throw new IOException(\"FileCopy: destination directory doesn't exist: \" + parent); } if (dir.isFile()) { throw new IOException(\"FileCopy: destination is not a directory: \" + parent); } if (!dir.canWrite()) { throw new IOException(\"FileCopy: destination directory is unwriteable: \" + parent); } } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(from_file); to = new FileOutputStream(to_file); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } } finally { if (from != null) { try { from.close(); } catch (IOException e) { } } if (to != null) { try { to.close(); } catch (IOException e) { } } } }. \nCode2: public static void main(String[] args) { if (args.length <= 0) { System.out.println(\" *** SQL script generator and executor ***\"); System.out.println(\" You must specify name of the file with SQL script data\"); System.out.println(\" Fisrt rows of this file must be:\"); System.out.println(\" 1) JDBC driver class for your DBMS\"); System.out.println(\" 2) URL for your database instance\"); System.out.println(\" 3) user in that database (with administrator priviliges)\"); System.out.println(\" 4) password of that user\"); System.out.println(\" Next rows can have: '@' before schema to create,\"); System.out.println(\" '#' before table to create, '&' before table to insert,\"); System.out.println(\" '$' before trigger (inverse 'FK on delete cascade') to create,\"); System.out.println(\" '>' before table to drop, '<' before schema to drop.\"); System.out.println(\" Other rows contain parameters of these actions:\"); System.out.println(\" for & action each parameter is a list of values,\"); System.out.println(\" for @ -//- is # acrion, for # -//- is column/constraint \"); System.out.println(\" definition or $ action. $ syntax to delete from table:\"); System.out.println(\" fullNameOfTable:itsColInWhereClause=matchingColOfThisTable\"); System.out.println(\" '!' before row means that it is a comment.\"); System.out.println(\" If some exception is occured, all script is rolled back.\"); System.out.println(\" If you specify 2nd command line argument - file name too -\"); System.out.println(\" connection will be established but all statements will\"); System.out.println(\" be saved in that output file and not transmitted to DB\"); System.out.println(\" If you specify 3nd command line argument - connect_string -\"); System.out.println(\" connect information will be added to output file\"); System.out.println(\" in the form 'connect user/password@connect_string'\"); System.exit(0); } try { String[] info = new String[4]; BufferedReader reader = new BufferedReader(new FileReader(new File(args[0]))); Writer writer = null; try { for (int i = 0; i < 4; i++) info[i] = reader.readLine(); try { Class.forName(info[0]); Connection connection = DriverManager.getConnection(info[1], info[2], info[3]); SQLScript script = new SQLScript(connection); if (args.length > 1) { writer = new FileWriter(args[1]); if (args.length > 2) writer.write(\"connect \" + info[2] + \"/\" + info[3] + \"@\" + args[2] + script.statementTerminator); } try { System.out.println(script.executeScript(reader, writer) + \" updates has been performed during script execution\"); } catch (SQLException e4) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Script execution error: \" + e4); } connection.close(); } catch (Exception e3) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Connection error: \" + e3); } } catch (IOException e2) { System.out.println(\"Error in file \" + args[0]); } } catch (FileNotFoundException e1) { System.out.println(\"File \" + args[0] + \" not found\"); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException { byte[] hash; try { MessageDigest digest = MessageDigest.getInstance(\"SHA-256\"); digest.reset(); digest.update(PasswordSalt.getBytes(\"UTF-16\")); hash = digest.digest(passwordHash.getBytes(\"UTF-16\")); return bytesToHex(hash); } catch (NoSuchAlgorithmException ex) { throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\"); } catch (UnsupportedEncodingException ex) { throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\"); } }. \nCode2: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else { GUIUtilities.message(view, \"version", "ground_truth": "NO", "predict": " \" + version + \" is up to date\"); view.hideWaitCursor(); } } else { GUIUtilities.message(view, \"version check failed\"); view.hideWaitCursor(); } } catch (IOException ex) { view.hideWaitCursor(); GUIUtilities.message(view, ex.getMessage()); } }. \n\npublic static void newVersionAvailable(View view, String version, URL url) { view.showInfoMessageDialog(\"New version available\", \"Version \" + version + \" is available at \" + url); }!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"}, {"ID": 1865, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void write(File file) throws Exception { if (isInMemory()) { FileOutputStream fout = null; try { fout = new FileOutputStream(file); fout.write(get()); } finally { if (fout != null) { fout.close(); } } } else { File outputFile = getStoreLocation(); if (outputFile != null) { size = outputFile.length(); if (!outputFile.renameTo(file)) { BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(outputFile)); out = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copy(in, out); } finally { if (in != null) { try { in.close(); } catch (IOException e) { } } if (out != null) { try { out.close(); } catch (IOException e) { } } } } } else { throw new FileUploadException(\"Cannot write uploaded file to disk!\"); } } }. \nCode2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: @SuppressWarnings(\"unchecked\") private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException { String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag; if (cache.containsKey(key)) { return (ReaderFeed) cache.get(key); } List<Post> postList = new ArrayList<Post>(); URL url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.setRequestProperty(\"Cookie\", \"SID=\" + sid); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); SAXBuilder builder = new SAXBuilder(false); Document doc = builder.build(reader); Element root = doc.getRootElement(); Namespace grNamespace = root.getNamespace(\"gr\"); Namespace namespace = root.getNamespace(); String newflag = root.getChildText(\"continuation\", grNamespace); String title = root.getChildText(\"title\", namespace); String subTitle = root.getChildText(\"subtitle\", namespace); List<Element> entryList = root.getChildren(\"entry\", namespace); DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"); for (Element e : entryList) { Post post = new Post(); post.setTitle(e.getChildText(\"title\", namespace)); try { post.setDate(sdf.parse(e.getChildText(\"published\", namespace))); } catch (ParseException e1) { } post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\")); post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace)); String content = e.getChildText(\"content\", namespace); if (StringUtils.isEmpty(content)) { content = e.getChildText(\"description\", namespace); } if (StringUtils.isEmpty(content)) { content = e.getChildText(\"summary\", namespace); } post.setContent(content); postList.add(post); } ReaderFeed readerFeed = new ReaderFeed(); readerFeed.setTitle(title); readerFeed.setSubTitle(subTitle); readerFeed.setFlag(newflag); readerFeed.setPostList(postList", "ground_truth": "NO", "predict": "); cache.put(key, readerFeed); return readerFeed; }. \nCode2: @SuppressWarnings(\"unchecked\") private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException { String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag; if (cache.containsKey(key)) { return (ReaderFeed) cache.get(key); } List<Post> postList = new ArrayList<Post>(); URL url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.setRequestProperty(\"Cookie\", \"SID=\" + sid); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); SAXBuilder builder = new SAXBuilder(false); Document doc = builder.build(reader); Element root ="}, {"ID": 1901, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public static int fileUpload(long lngFileSize, InputStream inputStream, String strFilePath, String strFileName) throws IOException { String SEPARATOR = System.getProperty(\"file.separator\"); if (lngFileSize > (10 * 1024 * 1024)) { return -1; } InputStream is = null; FileOutputStream fos = null; try { File dir = new File(strFilePath); if (!dir.exists()) dir.mkdirs(); is = inputStream; fos = new FileOutputStream(new File(strFilePath + SEPARATOR + strFileName)); IOUtils.copy(is, fos); } catch (Exception ex) { return -2; } finally { try { fos.close(); is.close(); } catch (Exception ex2) { } } return 0; }. \nCode2: public void _saveWebAsset(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form, User user, String subcmd) throws WebAssetException, Exception { long maxsize = 50; long maxwidth = 3000; long maxheight = 3000; long minheight = 10; ActionRequestImpl reqImpl = (ActionRequestImpl) req; HttpServletRequest httpReq = reqImpl.getHttpServletRequest(); try { UploadPortletRequest uploadReq = PortalUtil.getUploadPortletRequest(req); String parent = ParamUtil.getString(req, \"parent\"); int countFiles = ParamUtil.getInteger(req, \"countFiles\"); int fileCounter = 0; Folder folder = (Folder) InodeFactory.getInode(parent, Folder.class); _checkUserPermissions(folder, user, PERMISSION_WRITE); String userId = user.getUserId(); String customMessage = \"Some file does not match the filters specified by the folder: \"; boolean filterError = false; for (int k = 0; k < countFiles; k++) { File file = new File(); String title = ParamUtil.getString(req, \"title\" + k); String friendlyName = ParamUtil.getString(req, \"friendlyName\" + k); Date publishDate = new Date(); String fileName = ParamUtil.getString(req, \"fileName\" + k); fileName = checkMACFileName(fileName); if (!FolderFactory.matchFilter(folder, fileName)) { customMessage += fileName + \", \"; filterError = true; continue; } if (fileName.length() > 0) { String mimeType = FileFactory.getMimeType(fileName); String URI = folder.getPath() + fileName; String suffix = UtilMethods.getFileExtension(fileName); file.setTitle(title); file.setFileName(fileName); file.setFriendlyName(friendlyName); file.setPublishDate(publishDate); file.setModUser(userId); InodeFactory.saveInode(file); String filePath = FileFactory.getRealAssetsRootPath(); new java.io.File(filePath).mkdir(); java.io.File uploadedFile = uploadReq.getFile(\"uploadedFile\" + k); Logger.debug(this, \"bytes\" + uploadedFile.length()); file.setSize((int) uploadedFile.length() - 2); file.setMimeType(mimeType); Host host = HostFactory.getCurrentHost(httpReq); Identifier ident = IdentifierFactory.getIdentifierByURI(URI, host); String message = \"\"; if ((FileFactory.existsFileName(folder, fileName))) { InodeFactory.deleteInode(file); message = \"The uploaded file \" + fileName + \" already exists in this folder\"; SessionMessages.add(req, \"custommessage\", message); } else { String fileInodePath = String.valueOf(file.getInode()); if (fileInodePath.length() == 1) { fileInodePath = fileInodePath + \"0\"; } fileInodePath = fileInodePath.substring(0, 1) + java.io.File.separator + fileInodePath.substring(1, 2); new java.io.File(filePath + java.io.File.separator + fileInodePath.substring(0, 1)).mkdir(); new java.io.File(filePath + java.io.File.separator + fileInodePath).mkdir(); java.io.File f = new java.io.File(filePath + java.io.File.separator + fileInodePath + java.io.File.separator + file.getInode() + \".\" + suffix); java.io.FileOutputStream fout = new java.io.FileOutputStream(f); FileChannel outputChannel = fout.getChannel(); FileChannel inputChannel = new java.io.FileInputStream(uploadedFile).getChannel(); outputChannel.transferFrom(inputChannel, 0, inputChannel.size()); outputChannel.force(false); outputChannel.close(); inputChannel.close(); Logger.debug(this, \"SaveFileAction New File in =\" + filePath + java.io.File.separator + fileInodePath + java.io.File.separator + file.getInode() + \".\" + suffix); if (suffix.equals(\"jpg\") || suffix.equals(\"gif\")) { com.dotmarketing.util.Thumbnail.resizeImage(filePath + java.io.File.separator + fileInodePath + java.io.File.separator, String.valueOf(file.getInode()), suffix); int height = javax.imageio.ImageIO.read(f).getHeight(); file.setHeight(height); Logger.debug(this, \"File height=\" + height); int width = javax.imageio.ImageIO.read(f).getWidth(); file.setWidth(width); Logger.debug(this, \"File width=\" + width); long size = (f.length() / 1024); WebAssetFactory.createAsset(file, userId, folder); } else { WebAssetFactory.createAsset(file, userId, folder); } WorkingCache.addToWorkingAssetToCache(file); _setFilePermissions(folder, file, user); fileCounter += 1; if ((subcmd != null) && subcmd.equals(com.dotmarketing.util.Constants.PUBLISH)) { try { PublishFactory.publishAsset(file, httpReq); if (fileCounter > 1) { SessionMessages.add(req, \"message\", \"message.file_asset.save\"); } else { SessionMessages.add(req, \"message\", \"message.fileupload.save\"); } } catch (WebAssetException wax) { Logger.error(this, wax.getMessage(), wax); SessionMessages.add(req, \"error\", \"message.webasset.published.failed\"); } } } } } if (filterError) { customMessage = customMessage.substring(0, customMessage.lastIndexOf(\",\")); SessionMessages.add(req, \"custommessage\", customMessage); } } catch (IOException e) { Logger.error(this, \"Exception saving file: \" + e.getMessage()); throw new ActionException(e.getMessage()); } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) { HttpResponse response = null; try { HttpParams httpParams = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpParams, maxTime); HttpConnectionParams.setSoTimeout(httpParams, maxTime); httpclient = new DefaultHttp", "ground_truth": "NO", "predict": "Client(httpParams); HttpRequest httpRequestBase = (HttpRequest) httpRequest; HttpResponse httpResponse = httpclient.execute(httpRequestBase); } catch (Exception ex) { Logger.error(this, ex.getMessage()); response = HttpResponse.createFailureResponse(ex); } return response; }. \n\nCode2:public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) { HttpResponse response = null; try { HttpParams httpParams = new BasicHttpParams(); HttpConnectionParams.setConnectionTimeout(httpParams, maxTime); HttpConnectionParams.setSoTimeout(httpParams, maxTime); httpclient = new DefaultHttpClient(httpParams); HttpRequest httpRequestBase = (HttpRequest) httpRequest; HttpResponse httpResponse = httpclient.execute(httpRequestBase); } catch (Exception ex) { Logger.error(this, ex.getMessage()); response = HttpResponse."}, {"ID": 1923, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected URLConnection openURLConnection() throws IOException { final String locator = getMediaLocator(); if (locator == null) { return null; } final URL url; try { url = new URL(locator); } catch (MalformedURLException ex) { throw new IllegalArgumentException(ex); } final URLConnection connection = url.openConnection(); connection.connect(); return connection; }. \nCode2: protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { Session session = HibernateUtil.getInstance().getSession(); response.setBufferSize(65536); ServletOutputStream outStream = response.getOutputStream(); File file = null; FileData fileData = null; try { String fileParameter = request.getParameter(\"file\"); String disposition = request.getParameter(\"disposition\"); if (fileParameter == null || fileParameter.equals(\"\")) { String pi = request.getPathInfo(); int lastSlashIndex = pi.lastIndexOf(\"/\") + 1; fileParameter = pi.substring(lastSlashIndex, pi.indexOf(\"_\", pi.lastIndexOf(\"/\"))); } if (fileParameter == null || fileParameter.equals(\"\")) { response.sendError(HttpServletResponse.SC_BAD_REQUEST); response.setStatus(HttpServletResponse.SC_BAD_REQUEST); response.flushBuffer(); Logger.log(\"file parameter not specified\"); return; } if (disposition == null || disposition.equals(\"\")) { String pi = request.getPathInfo(); String filename = pi.substring(pi.lastIndexOf(\"/\") + 1); int underscoreIndex = filename.indexOf(\"_\") + 1; disposition = filename.substring(underscoreIndex, filename.indexOf(\"_\", underscoreIndex)); } file = (File) session.load(File.class, new Long(fileParameter)); Logger.log(\"Content requested=\" + file.getName() + \":\" + fileParameter + \" Referral: \" + request.getParameter(\"referer\")); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); long fileDate = file.getLastModifiedDate() - (file.getLastModifiedDate() % 1000); if (fileDate <= ifModifiedSince) { response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); if (\"attachment\".equals(disposition)) { response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\"); } else { response.setHeader(\"Content-Disposition\", \"inline; filename=\\\"\" + file.getName() + \"\\\"\"); } response.setContentType(file.getContentType()); response.setHeader(\"Content-Description\", file.getName()); response.setDateHeader(\"Last-Modified\", file.getLastModifiedDate()); response.setDateHeader(\"Expires\", System.currentTimeMillis() + 31536000000L); response.setContentLength((int) file.getSize()); response.flushBuffer(); Logger.log(\"Conditional GET: \" + file.getName()); return; } User authUser = baseService.getAuthenticatedUser(session, request, response); if (!SecurityHelper.doesUserHavePermission(session, authUser, file, Permission.PERM.READ)) { response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden\"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.flushBuffer(); Logger.log(\"Forbidden content requested: \" + fileParameter); return; } String contentType = file.getContentType(); response.setContentType(contentType); if (\"attachment\".equals(disposition)) { response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\"); } else { response.setHeader(\"Content-Disposition\", \"inline; filename=\\\"\" + file.getName() + \"\\\"\"); } String name = file.getName(); response.setHeader(\"Content-Description\", name); response.setDateHeader(\"Last-Modified\", file.getLastModifiedDate()); response.setDateHeader(\"Expires\", System.currentTimeMillis() + 31536000000L); response.setContentLength((int) file.getSize()); java.io.File possibleDataFile = new java.io.File(BaseSystem.getTempDir() + file.getNameOnDisk()); if (possibleDataFile.exists()) { Logger.log(\"File exists in \" + BaseSystem.getTempDir() + \" pulling \" + possibleDataFile.getName()); FileInputStream fileInputStream = new FileInputStream(possibleDataFile); try { IOUtils.copy(fileInputStream, outStream); } finally { try { fileInputStream.close(); } catch (Throwable t) { } } } else { List<FileData> fileDataList = HibernateUtil.getInstance().executeQuery(session, \"from \" + FileData.class.getSimpleName() + \" where permissibleObject.id = \" + file.getId()); if (fileDataList.size() == 0) { response.sendError(HttpServletResponse.SC_NOT_FOUND); response.setStatus(HttpServletResponse.SC_NOT_FOUND); Logger.log(\"Requested content not found: \" + fileParameter); response.flushBuffer(); return; } fileData = (FileData) fileDataList.get(0); FileOutputStream fileOutputStream = null; try { java.io.File tmpDir = new java.io.File(BaseSystem.getTempDir()); tmpDir.mkdirs(); fileOutputStream = new FileOutputStream(possibleDataFile); IOUtils.write(fileData.getData(), fileOutputStream); } catch (Throwable t) { Logger.log(t); } finally { try { fileOutputStream.close(); } catch (Throwable t) { } } IOUtils.write(fileData.getData(), outStream); } } catch (Throwable t) { Logger.log(t); try { response.sendError(HttpServletResponse.SC_NOT_FOUND); response.setStatus(HttpServletResponse.SC_NOT_FOUND); response.flushBuffer(); } catch (Throwable tt) { } try { response.reset(); response.resetBuffer(); } catch (Throwable tt) { } } finally { file = null; fileData = null; try { outStream.flush(); } catch (Throwable t) { } try { outStream.close(); } catch (Throwable t) { } try { session.close(); } catch (Throwable t) { } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public String getSHA256Checksum(String source) { String checksum = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); md.update(source.getBytes()); byte[] byteData = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } System.out.println(\"Hex format : \" + sb.toString()); StringBuffer hexString = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) { hexString.append('0'); } hex", "ground_truth": "NO", "predict": "String.append(hex); } checksum = hexString.toString(); } catch (Exception ex) { Logger.log(ex); } return checksum; \n}"}, {"ID": 1934, "prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request. \n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: public void testAddFiles() throws Exception { File original = ZipPlugin.getFileInPlugin(new Path(\"testresources/test.zip\")); File copy = new File(original.getParentFile(), \"1test.zip\"); InputStream in = null; OutputStream out = null; try { in = new FileInputStream(original); out = new FileOutputStream(copy); byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); } finally { Util.close(in); Util.close(out); } ArchiveFile archive = new ArchiveFile(ZipPlugin.createArchive(copy.getPath())); archive.addFiles(new String[] { ZipPlugin.getFileInPlugin(new Path(\"testresources/add.txt\")).getPath() }, new NullProgressMonitor()); IArchive[] children = archive.getChildren(); boolean found = false; for (IArchive child : children) { if (child.getLabel(IArchive.NAME).equals(\"add.txt\")) found = true; } assertTrue(found); copy.delete(); }. \nCode2: public void run() { LogPrinter.log(Level.FINEST, \"Started Download at : {0, date, long}\", new Date()); if (!PipeConnected) { throw new IllegalStateException(\"You should connect the pipe before with getInputStream()\"); } InputStream ins = null; if (IsAlreadyDownloaded) { LogPrinter.log(Level.FINEST, \"The file already Exists open and foward the byte\"); try { ContentLength = (int) TheAskedFile.length(); ContentType = URLConnection.getFileNameMap().getContentTypeFor(TheAskedFile.getName()); ins = new FileInputStream(TheAskedFile); byte[] buffer = new byte[BUFFER_SIZE]; int read = ins.read(buffer); while (read >= 0) { Pipe.write(buffer, 0, read); read = ins.read(buffer); } } catch (IOException e) { e.printStackTrace(); } finally { if (ins != null) { try { ins.close(); } catch (IOException e) { } } } } else { LogPrinter.log(Level.FINEST, \"the file does not exist locally so we try to download the thing\"); File theDir = TheAskedFile.getParentFile(); if (!theDir.exists()) { theDir.mkdirs(); } for (URL url : ListFastest) { FileOutputStream fout = null; boolean OnError = false; long timestart = System.currentTimeMillis(); long bytecount = 0; try { URL newUrl = new URL(url.toString() + RequestedFile); LogPrinter.log(Level.FINEST, \"the download URL = {0}\", newUrl); URLConnection conn = newUrl.openConnection(); ContentType = conn.getContentType(); ContentLength = conn.getContentLength(); ins = conn.getInputStream(); fout = new FileOutputStream(TheAskedFile); byte[] buffer = new byte[BUFFER_SIZE]; int read = ins.read(buffer); while (read >= 0) { fout.write(buffer, 0, read); Pipe.write(buffer, 0, read); read = ins.read(buffer); bytecount += read; } Pipe.flush(); } catch (IOException e) { OnError = true; } finally { if (ins != null) { try { ins.close(); } catch (IOException e) { } } if (fout != null) { try { fout.close(); } catch (IOException e) { } } } long timeend = System.currentTimeMillis(); if (OnError) { continue; } else { long timetook = timeend - timestart; BigDecimal speed = new BigDecimal(bytecount).multiply(new BigDecimal(1000)).divide(new BigDecimal(timetook), MathContext.DECIMAL32); for (ReportCalculatedStatistique report : Listener) { report.reportUrlStat(url, speed, timetook); } break; } } } LogPrinter.log(Level.FINEST, \"download finished at {0,date,long}\", new Date()); if (Pipe != null) { try { Pipe.close(); } catch (IOException e) { e.printStackTrace(); } } }. \n### Response:YES. \n\n### Instruction: Is there a clone relation between the Code1 and Code2, and respond to YES or NO. \nCode1: protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException { ServletContext servletContext = this.getServletConfig().getServletContext(); WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); String szUrl = request.getParameter(\"url\"); System.out.println(szUrl); URL url; InputStream is = null; ServletOutputStream sout = null; try { url = new URL(szUrl); HttpURLConnection con = (HttpURLConnection) url.openConnection(); Enumeration hNames = request.getHeaderNames(); while (hNames.hasMoreElements()) { String txt = hNames.nextElement().toString(); con.setRequestProperty(txt, request.getHeader(txt)); } con.setRequestProperty(\"host\", url.getHost()); con.setRequestProperty(\"refer\", szUrl); con.setRequestMethod(method); con.setDoOutput(true); con.setDoInput(true); InputStreamReader inBody = new InputStreamReader(request.getInputStream()); char bufCh[] = new char[1024]; int r; OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream()); while ((r = inBody.read(bufCh)) != -1) { System.out.println(bufCh); outReq.write(bufCh, 0, r); } outReq.flush(); outReq.close(); inBody.close(); System.out.println(con.getResponseCode()); System.out.println(con.getResponseMessage()); if (con.getResponseCode() == con.HTTP_OK) { response.setContentType(con.getContentType()); response.addHeader(\"Content-Encoding\", con.getContentEncoding()); sout = response.getOutputStream(); is = con.getInputStream(); byte buff[] = new byte[1024]; while ((r = is.read(buff)) != -1) { sout.write(buff, 0, r); System.out.print(buff); } sout.flush(); is.close(); sout.close(); } else { response.sendError(con.getResponseCode(), con.getResponseMessage()); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \nCode2: private String getHTML(String pageURL, String encoding, String dirPath) throws IOException { StringBuilder pageHTML = new StringBuilder(); HttpURLConnection connection = null; try { URL url = new URL(pageURL); connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty(\"User-Agent\", \"MSIE 7.0\"); connection.connect(); BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), encoding)); String line = null; while ((line = br.readLine()) != null) { pageHTML.append(line); pageHTML.append(\"\\r\\n\"); } } catch (Exception e) { e.printStackTrace(); } finally { connection.disconnect(); } if (dirPath != null) { File file = new File(dirPath); BufferedWriter", "ground_truth": "YES", "predict": " bw = new BufferedWriter(new FileWriter(file.getPath() + \"/index.html\")); bw.write(pageHTML.toString()); bw.flush(); bw.close(); } return pageHTML.toString(); }. \nCode1: public void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException { ServletContext servletContext = this.getServletConfig().getServletContext(); WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); String szUrl = request.getParameter(\"url\"); System.out.println(szUrl); URL url; InputStream is = null; ServletOutputStream sout = null; try { url = new URL(szUrl); HttpURLConnection con = (HttpURLConnection) url.openConnection(); Enumeration hNames = request.getHeaderNames(); while (hNames.hasMore"}]