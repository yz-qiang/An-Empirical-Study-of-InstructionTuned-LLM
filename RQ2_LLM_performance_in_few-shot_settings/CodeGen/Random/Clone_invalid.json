[
    {
        "ID": 2,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public DefaultMainControl(@NotNull final FileFilter scriptFileFilter, @NotNull final String scriptExtension, @NotNull final String scriptName, final int spellType, @Nullable final String spellFile, @NotNull final String scriptsDir, final ErrorView errorView, @NotNull final EditorFactory<G, A, R> editorFactory, final boolean forceReadFromFiles, @NotNull final GlobalSettings globalSettings, @NotNull final ConfigSourceFactory configSourceFactory, @NotNull final PathManager pathManager, @NotNull final GameObjectMatchers gameObjectMatchers, @NotNull final GameObjectFactory<G, A, R> gameObjectFactory, @NotNull final ArchetypeTypeSet archetypeTypeSet, @NotNull final ArchetypeSet<G, A, R> archetypeSet, @NotNull final ArchetypeChooserModel<G, A, R> archetypeChooserModel, @NotNull final AutojoinLists<G, A, R> autojoinLists, @NotNull final AbstractMapManager<G, A, R> mapManager, @NotNull final PluginModel<G, A, R> pluginModel, @NotNull final DelegatingMapValidator<G, A, R> validators, @NotNull final ScriptedEventEditor<G, A, R> scriptedEventEditor, @NotNull final AbstractResources<G, A, R> resources, @NotNull final Spells<NumberSpell> numberSpells, @NotNull final Spells<GameObjectSpell<G, A, R>> gameObjectSpells, @NotNull final PluginParameterFactory<G, A, R> pluginParameterFactory, @NotNull final ValidatorPreferences validatorPreferences, @NotNull final MapWriter<G, A, R> mapWriter) { final XmlHelper xmlHelper; try { xmlHelper = new XmlHelper(); } catch (final ParserConfigurationException ex) { log.fatal(\"Cannot create XML parser: \" + ex.getMessage()); throw new MissingResourceException(\"Cannot create XML parser: \" + ex.getMessage(), null, null); } final AttributeRangeChecker<G, A, R> attributeRangeChecker = new AttributeRangeChecker<G, A, R>(validatorPreferences); final EnvironmentChecker<G, A, R> environmentChecker = new EnvironmentChecker<G, A, R>(validatorPreferences); final DocumentBuilder documentBuilder = xmlHelper.getDocumentBuilder(); try { final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), \"GameObjectMatchers.xml\"); final ErrorViewCollector gameObjectMatchersErrorViewCollector = new ErrorViewCollector(errorView, url); try { documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(gameObjectMatchersErrorViewCollector, ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID)); try { final GameObjectMatchersParser gameObjectMatchersParser = new GameObjectMatchersParser(documentBuilder, xmlHelper.getXPath()); gameObjectMatchersParser.readGameObjectMatchers(url, gameObjectMatchers, gameObjectMatchersErrorViewCollector); } finally { documentBuilder.setErrorHandler(null); } } catch (final IOException ex) { gameObjectMatchersErrorViewCollector.addWarning(ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID, ex.getMessage()); } final ValidatorFactory<G, A, R> validatorFactory = new ValidatorFactory<G, A, R>(validatorPreferences, gameObjectMatchers, globalSettings, mapWriter); loadValidators(validators, validatorFactory, errorView); editorFactory.initMapValidators(validators, gameObjectMatchersErrorViewCollector, globalSettings, gameObjectMatchers, attributeRangeChecker, validatorPreferences); validators.addValidator(attributeRangeChecker); validators.addValidator(environmentChecker); } catch (final FileNotFoundException ex) { errorView.addWarning(ErrorViewCategory.GAMEOBJECTMATCHERS_FILE_INVALID, \"GameObjectMatchers.xml: \" + ex.getMessage()); } final GameObjectMatcher shopSquareMatcher = gameObjectMatchers.getMatcher(\"system_shop_square\", \"shop_square\"); if (shopSquareMatcher != null) { final GameObjectMatcher noSpellsMatcher = gameObjectMatchers.getMatcher(\"system_no_spells\", \"no_spells\"); if (noSpellsMatcher != null) { final GameObjectMatcher blockedMatcher = gameObjectMatchers.getMatcher(\"system_blocked\", \"blocked\"); validators.addValidator(new ShopSquareChecker<G, A, R>(validatorPreferences, shopSquareMatcher, noSpellsMatcher, blockedMatcher)); } final GameObjectMatcher paidItemMatcher = gameObjectMatchers.getMatcher(\"system_paid_item\"); if (paidItemMatcher != null) { validators.addValidator(new PaidItemShopSquareChecker<G, A, R>(validatorPreferences, shopSquareMatcher, paidItemMatcher)); } } Map<String, TreasureTreeNode> specialTreasureLists; try { final URL url = IOUtils.getResource(globalSettings.getConfigurationDirectory(), \"TreasureLists.xml\"); final ErrorViewCollector treasureListsErrorViewCollector = new ErrorViewCollector(errorView, url); try { final InputStream inputStream = url.openStream(); try { documentBuilder.setErrorHandler(new ErrorViewCollectorErrorHandler(treasureListsErrorViewCollector, ErrorViewCategory.TREASURES_FILE_INVALID)); try { final Document specialTreasureListsDocument = documentBuilder.parse(new InputSource(inputStream)); specialTreasureLists = TreasureListsParser.parseTreasureLists(specialTreasureListsDocument); } finally { documentBuilder.setErrorHandler(null); } } finally { inputStream.close(); } } catch (final IOException ex) { treasureListsErrorViewCollector.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, ex.getMessage()); specialTreasureLists = Collections.emptyMap(); } catch (final SAXException ex) { treasureListsErrorViewCollector.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, ex.getMessage()); specialTreasureLists = Collections.emptyMap(); } } catch (final FileNotFoundException ex) { errorView.addWarning(ErrorViewCategory.TREASURES_FILE_INVALID, \"TreasureLists.xml: \" + ex.getMessage()); specialTreasureLists = Collections.emptyMap(); } final ConfigSource configSource = forceReadFromFiles ? configSourceFactory.getFilesConfigSource() : configSourceFactory.getConfigSource(globalSettings.getConfigSourceName()); treasureTree = TreasureLoader.parseTreasures(errorView, specialTreasureLists, configSource, globalSettings); final Archetype",
        "ground_truth": "NO",
        "predict": "Tree<G, A, R> archetypeTree = ArchetypeLoader.parseArchetypes(errorView, archetypeTypeSet, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource, globalSettings, pathManager, gameObjectMatchers, gameObjectFactory, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource, globalSettings, pathManager, gameObjectMatchers, gameObjectFactory, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource, globalSettings, pathManager, gameObjectMatchers, gameObjectFactory, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource, globalSettings, pathManager, gameObjectMatchers, gameObjectFactory, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource, globalSettings, pathManager, gameObjectMatchers, gameObjectFactory, archetypeSet, archetypeChooserModel, autojoinLists, mapManager, configSource,"
    },
    {
        "ID": 8,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void load(Runestone stone) throws RunesExceptionRuneExecution, RunesExceptionNoSuchContent { final Tokeniser tokeniser = stone.<Tokeniser>getContent(\"tokeniser\").iterator().next(); rules = new HashMap<Node, List<GazRule>>(); System.out.println(\"Loading Gaz from: \" + _url); if (_url == null) return; BufferedReader typesIn = null, entryIn = null; try { typesIn = new BufferedReader(new InputStreamReader(_url.openStream())); String tData = typesIn.readLine(); while (tData != null) { Map<String, Map> gaz = new HashMap<String, Map>(); String[] data = tData.split(\":\"); URL listURL = new URL(_url, data[0]); System.err.println(\"Loading from \" + listURL); entryIn = new BufferedReader(new InputStreamReader(listURL.openStream())); String entry = entryIn.readLine(); while (entry != null) { entry = entry.trim(); if (!entry.equals(\"\")) { final List<Token> tokens; try { tokens = tokeniser.tokenise(entry); } catch (IOException e) { throw new RunesExceptionRuneExecution(e, this); } Map<String, Map> m = gaz; for (Token t : tokens) { String token = t.getString(); if (_case_insensitive_gazetteer) token = token.toLowerCase(); @SuppressWarnings(\"unchecked\") Map<String, Map> next = m.get(token); if (next == null) next = new HashMap<String, Map>(); m.put(token, next); m = next; } m.put(STOP, null); } entry = entryIn.readLine(); } for (Map.Entry<String, Map> er : gaz.entrySet()) { NodeAbstract start = new NodeStringImpl(TOKEN_TYPE, null); if (_case_insensitive_gazetteer) { start.addFeature(TOKEN_HAS_STRING, new NodeRegExpImpl(TOKEN_STRING, \"(?i:\" + er.getKey().toLowerCase() + \")\")); } else { start.addFeature(TOKEN_HAS_STRING, new NodeStringImpl(TOKEN_STRING, er.getKey())); } @SuppressWarnings(\"unchecked\") Transition transition = mapToTransition(er.getValue()); String major = data[1]; String minor = (data.length == 3 ? data[2] : null); GazRule gr = new GazRule(major, minor, transition); List<GazRule> rl = rules.get(start); if (rl == null) rl = new ArrayList<GazRule>(); rl.add(gr); rules.put(start, rl); } entryIn.close(); System.err.println(rules.size()); tData = typesIn.readLine(); } } catch (IOException e) { throw new RunesExceptionRuneExecution(e, this); } finally { try { if (typesIn != null) typesIn.close(); } catch (IOException e) { } try { if (entryIn != null) entryIn.close(); } catch (IOException e) { } } }. \n Code2: public static void copyFile(File src, File dest) throws IOException { log.debug(\"Copying file: '\" + src + \"' to '\" + dest + \"'\"); FileChannel srcChannel = new FileInputStream(src).getChannel(); FileChannel dstChannel = new FileOutputStream(dest).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Vector parse(String link) { addMessage(\"Parsing: \" + link); links.removeAllElements(); URLConnection conn = null; Reader rd = null; EditorKit kit = new HTMLEditorKit(); Document doc = kit.createDefaultDocument(); doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE); URL url = null; try { url = new URL(link); } catch (MalformedURLException err) { System.out.println(\"Malformed URL\"); return links; } try { conn = new URL(link).openConnection(); rd = new InputStreamReader(conn.getInputStream()); } catch (Exception err) { err.printStackTrace(); return links; } try { kit.read(rd, doc, 0); ElementIterator it = new ElementIterator(doc); javax.swing.text.Element elem; while ((elem = it.next()) != null) { SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A); if (s != null) { if (s.toString().indexOf(\"script\") >= 0) continue; String lnk = \"\"; try { lnk = s.getAttribute(HTML.Attribute.HREF).toString(); } catch (Exception err) { continue; } int j = 0; if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j); URL urlLink = new URL(url, lnk); if (!url.getHost().equals(urlLink.getHost())) continue; String str = urlLink.toString(); if (!str.startsWith(\"http\")) continue; if (str.endsWith(\".pdf\")) { continue; } for (int i = 0; i < leaveSuffix.length; i++) { if ((str.endsWith(leaveSuffix[i]))) continue; } boolean skip = false; for (int i = 0; i < suffix.length; i++) { if ((str.endsWith(suffix[i]))) skip = true; } if (!skip) { try { conn = urlLink.openConnection(); } catch (Exception err) { } String contentType = null; if (contentType == null) contentType = conn.getContentType(); if (contentType.equals(\"application/pdf\")) { continue; } else if (!contentType.equals(\"text/html\")) { continue; } } if (!links.contains(urlLink.toString())) { links.addElement(urlLink.toString()); } } } } catch (Exception e) { e.printStackTrace(); } return links; }. \n Code2: @Test public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception { Exception e = new UnsuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req, ctx); verify(mockBackend);",
        "ground_truth": "NO",
        "predict": " assertEquals(resp, result); }. \n Code2: @Test public void returnsEnclosedResponseOnSuccessfulException() throws Exception { Exception e = new SuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req, ctx); verify(mockBackend); assertEquals(resp, result); }. \n Code2: @Test public void returnsEnclosedResponseOnUnsuccessfulExceptionWithContent() throws Exception { Exception e = new UnsuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req, ctx); verify(mockBackend); assertEquals(resp, result); }. \n Code2: @Test public void returnsEnclosedResponseOnSuccessfulExceptionWith"
    },
    {
        "ID": 9,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"static-access\") public void run() { while (true) { try { thisThread.sleep(10000); } catch (InterruptedException e) { System.out.print(\"no connection\"); } ++i; umat.flush(); umat = null; try { base = getDocumentBase(); username = getParameter(\"username\"); } catch (Exception e) { } String userdat = \"data/\" + username + \"_l.cod\"; URL url = null; try { url = new URL(base, userdat); } catch (MalformedURLException e1) { } InputStream in = null; try { in = url.openStream(); } catch (IOException e1) { } BufferedReader reader = null; try { reader = new BufferedReader(new InputStreamReader(in)); } catch (Exception r) { } try { String line = reader.readLine(); StringTokenizer tokenizer = new StringTokenizer(line, \" \"); int dim = Integer.parseInt(tokenizer.nextToken().trim().toLowerCase()); this.topol = tokenizer.nextToken().trim().toLowerCase(); xunit = Integer.parseInt(tokenizer.nextToken().trim().toLowerCase()); yunit = Integer.parseInt(tokenizer.nextToken().trim().toLowerCase()); @SuppressWarnings(\"unused\") String neigh = tokenizer.nextToken().trim().toLowerCase(); String label = null; labels = new String[xunit][yunit]; for (int e = 0; e < yunit; e++) { for (int r = 0; r < xunit; r++) { line = reader.readLine(); StringTokenizer tokenizer2 = new StringTokenizer(line, \" \"); for (int w = 0; w < dim; w++) { if (tokenizer2.countTokens() > 0) tokenizer2.nextToken(); } while (tokenizer2.countTokens() > 0) { label = tokenizer2.nextToken() + \" \"; } if (label == null) { labels[r][e] = \"none\"; } else { labels[r][e] = label; } label = null; } } reader.close(); if (topol.equals(\"hexa\")) { xposit = new int[xunit][yunit]; yposit = new int[xunit][yunit]; double divisor1 = xunit; double divisor2 = yunit; for (int p = 0; p < xunit; p++) { for (int q = 0; q < yunit; q++) { if (q % 2 == 0) { double nenner = (p * width); xposit[p][q] = (int) Math.round(nenner / divisor1); } if (q % 2 != 0) { double nenner = (width * 0.5) + (p * width); xposit[p][q] = (int) Math.round(nenner / divisor1); } yposit[p][q] = (int) Math.round(((height * 0.5) + q * height) / divisor2); } } } if (topol.equals(\"rect\")) { xposit = new int[xunit][yunit]; yposit = new int[xunit][yunit]; double divisor1 = xunit; double divisor2 = yunit; for (int p = 0; p < xunit; p++) { for (int q = 0; q < yunit; q++) { double nenner = (width * 0.5) + (p * width); xposit[p][q] = (int) Math.round((nenner / divisor1)); yposit[p][q] = (int) Math.round(((height * 0.5) + q * height) / divisor2); } } } } catch (IOException o) { } String userpng = \"images/\" + username + \".png\"; mt.removeImage(umat); umat = getImage(base, userpng); mt.addImage(umat, 0); try { mt.waitForID(0); } catch (InterruptedException i) { showStatus(\"Interrupted\"); } repaint(); } }. \n Code2: public static void copy(File from_file, File to_file) throws IOException { if (!from_file.exists()) { throw new IOException(\"FileCopy: no such source file: \" + from_file.getPath()); } if (!from_file.isFile()) { throw new IOException(\"FileCopy: can't copy directory: \" + from_file.getPath()); } if (!from_file.canRead()) { throw new IOException(\"FileCopy: source file is unreadable: \" + from_file.getPath()); } if (to_file.isDirectory()) { to_file = new File(to_file, from_file.getName()); } if (to_file.exists()) { if (!to_file.canWrite()) { throw new IOException(\"FileCopy: destination file is unwriteable: \" + to_file.getPath()); } int choice = JOptionPane.showConfirmDialog(null, \"Overwrite existing file \" + to_file.getPath(), \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE); if (choice != JOptionPane.YES_OPTION) { throw new IOException(\"FileCopy: existing file was not overwritten.\"); } } else { String parent = to_file.getParent(); if (parent == null) { parent = Globals.getDefaultPath(); } File dir = new File(parent); if (!dir.exists()) { throw new IOException(\"FileCopy: destination directory doesn't exist: \" + parent); } if (dir.isFile()) { throw new IOException(\"FileCopy: destination is not a directory: \" + parent); } if (!dir.canWrite()) { throw new IOException(\"FileCopy: destination directory is unwriteable: \" + parent); } } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(from_file); to = new FileOutputStream(to_file); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } } finally { if (from != null) { try { from.close(); } catch (IOException e) { } } if (to != null) { try { to.close(); } catch (IOException e) { } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void loadProperties() { if (properties == null) { properties = new Properties(); try { URL url = get",
        "ground_truth": "NO",
        "predict": "Class().getResource(\"/properties/properties.properties\"); properties.load(url.openStream()); } catch (IOException e) { } } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void saveProperties() { try { URL url = getClass().getResource(\"/properties/properties.properties\"); FileOutputStream out = new FileOutputStream(url.getPath()); properties.store(out, \"Properties\"); out.close(); } catch (IOException e) { } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void loadProperties() { if (properties == null) { properties = new Properties(); try { URL url = getClass().getResource(\"/properties/properties.properties\"); properties.load(url.openStream()); } catch (IO"
    },
    {
        "ID": 18,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public FlatFileFrame() { super(\"Specify Your Flat File Data\"); try { Class transferAgentClass = this.getStorageTransferAgentClass(); if (transferAgentClass == null) { throw new RuntimeException(\"Transfer agent class can not be null.\"); } Class[] parameterTypes = new Class[] { RepositoryStorage.class }; Constructor constr = transferAgentClass.getConstructor(parameterTypes); Object[] actualValues = new Object[] { this }; this.transferAgent = (RepositoryStorageTransferAgent) constr.newInstance(actualValues); } catch (Exception err) { throw new RuntimeException(\"Unable to instantiate transfer agent.\", err); } this.fmtlistener = new FormatTableModelListener(); this.map = new HashMap(); this.NoCallbackChangeMode = false; this.setSize(new Dimension(1000, 400)); this.setLayout(new GridLayout(1, 1)); this.Config = new FlatFileToolsConfig(); this.Config.initialize(); this.connectionHandler = new RepositoryConnectionHandler(this.Config); this.Connection = (FlatFileStorageConnectivity) this.connectionHandler.getConnection(\"default\"); this.Prefs = new FlatFileToolsPrefs(); this.Prefs.initialize(); SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\"); String formatted_date = formatter.format(new Date()); this.createdOnText = new JTextField(formatted_date); this.createdByText = new JTextField(this.Prefs.getConfigValue(\"createdby\")); this.reposListeners = new Vector(); this.removeFormatButton = new JButton(\"Remove\"); this.previewPanel = new DataSetPanel(new DataSet()); this.previewPanel.setEditable(false); this.chooser = new JFileChooser(); this.chooser.setMultiSelectionEnabled(true); this.enabledRadio = new JRadioButton(\"Enabled:\"); this.enabledRadio.setSelected(true); this.editPrefsButton = new JButton(\"Preferences...\"); this.editPrefsButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ev) { System.out.println(\"Making visible\"); prefsEditor.setVisible(true); } }); this.commentTextArea = new JTextArea(20, 8); this.commentTextArea.setText(\"No comment.\"); this.commentTextArea.setToolTipText(\"A detailed (possibly formatted) description including guidance to future developers of this set.\"); this.iconServer = new IconServer(); this.iconServer.setConfigFile(this.Prefs.getConfigValue(\"default\", \"iconmapfile\")); this.nicknameText = new IconifiedDomainNameTextField(new FlatFileFindNameDialog(Config, iconServer), this.iconServer); this.nicknameText.setPreferredSize(new Dimension(200, 25)); this.nicknameText.setText(this.Prefs.getConfigValue(\"default\", \"domainname\") + \".\"); this.nicknameText.setNameTextToolTipText(\"Right click to search the database.\"); this.uploadButton = new JButton(\"Upload\"); this.uploadButton.setToolTipText(\"Uploads current state to repository.\"); this.uploadButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent ev) { System.out.println(\"Trying to upload flat file spec...\"); try { String expname = getNickname(); int split = expname.lastIndexOf('.'); String domain = \"\"; String name = \"\"; String usersdomain = Prefs.getConfigValue(\"default\", \"domainname\"); if (split > 0) { domain = expname.substring(0, split); name = expname.substring(split + 1, expname.length()); } else { name = expname; } name = name.trim(); if (name.equals(\"\")) { JOptionPane.showMessageDialog(null, \"Cowardly refusing to upload with an empty flat file name...\"); return; } if (!domain.equals(usersdomain)) { int s = JOptionPane.showConfirmDialog(null, \"If you are not the original author, you may wish to switch the current domain name \" + domain + \" to \\nyour domain name \" + usersdomain + \". Would you like to do this?\\n (If you'll be using this domain often, you may want to set it in your preferences.)\", \"Potential WWW name-space clash!\", JOptionPane.YES_NO_CANCEL_OPTION); if (s == JOptionPane.YES_OPTION) { setNickname(usersdomain + \".\" + name); executeTransfer(); } if (s == JOptionPane.NO_OPTION) { executeTransfer(); } } else { executeTransfer(); } } catch (Exception err) { throw new RuntimeException(\"Problem uploading storage.\", err); } } }); this.repositoryView = new JButton(\"default\"); this.repositoryView.addActionListener(new ActionListener() { public void actionPerformed(java.awt.event.ActionEvent e) { repositoryEditor.setCurrentRepository(repositoryView.getText()); repositoryEditor.setVisible(true); } }); this.prefsEditor = new PrefsConfigFrame(this.Prefs); this.prefsEditor.setVisible(false); this.prefsEditor.addCloseListener(new ActionListener() { public void actionPerformed(ActionEvent ev) { prefsEditor.setVisible(false); } }); this.prefsEditor.addSelectListener(new ActionListener() { public void actionPerformed(ActionEvent ev) { prefsEditor.setVisible(false); } }); this.repositoryEditor = new ReposConfigFrame(this.Config); this.repositoryEditor.setVisible(false); this.repositoryEditor.addSelectListener(new SelectListener()); this.repositoryEditor.addCloseListener(new CloseListener()); this.addSources = new JButton(\"Source from file...\"); this.preview = new JButton(\"Preview\"); this.leastcolumn = new JSpinner(); this.columns2show = new JSpinner(); this.leastrow = new JSpinner(); this.rows2show = new JSpinner(); int rowCount = 10; JLabel sourceLabel = new JLabel(\"File Source\"); this.flatfilesource = new JTextField(); this.flatfilesource.setPreferredSize(new Dimension(200, 25)); this.flatfilesource.setMinimumSize(new Dimension(200, 25)); this.flatfilesource.setMaximumSize(new Dimension(200, 25)); this.isURLButton = new JRadioButton(\"URL\"); Box scrollBox = Box.createVerticalBox(); Box srcBox = Box.createHorizontalBox(); srcBox.add(this.addSources); srcBox.add(sourceLabel); srcBox.add(this.flatfilesource); srcBox.add(this.isURLButton); src",
        "ground_truth": "NO",
        "predict": "Box.add(this.repositoryView); srcBox.add(this.repositoryEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this.prefsEditor); srcBox.add(this"
    },
    {
        "ID": 22,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int down(String downLoadUrl, String saveUrl) { int status = 1; long fileSize = 0; int len = 0; byte[] bt = new byte[1024]; RandomAccessFile raFile = null; long totalSize = 0; URL url = null; HttpURLConnection httpConn = null; BufferedInputStream bis = null; try { url = new URL(downLoadUrl); httpConn = (HttpURLConnection) url.openConnection(); if (httpConn.getHeaderField(\"Content-Length\") == null) { status = 500; } else { totalSize = Long.parseLong(httpConn.getHeaderField(\"Content-Length\")); System.out.println(\"\u6587\u4ef6\u5927\u5c0f:\" + totalSize / 1000000 + \" M\"); httpConn.disconnect(); httpConn = (HttpURLConnection) url.openConnection(); fileSize = loadFileSize(saveUrl + BACK_SUFFIX); System.out.println(\"\u5df2\u4e0b\u8f7d:\" + fileSize / 1000000 + \" M\"); httpConn.setRequestProperty(\"RANGE\", \"bytes=\" + fileSize + \"-\"); httpConn.setRequestProperty(\"Accept\", \"image/gif,image/x-xbitmap,application/msword,*/*\"); raFile = new RandomAccessFile(saveUrl + BACK_SUFFIX, \"rw\"); raFile.seek(fileSize); bis = new BufferedInputStream(httpConn.getInputStream()); while ((len = bis.read(bt)) > 0) { raFile.write(bt, 0, len); float progress = 0.f; float downSize = raFile.length(); progress = downSize / totalSize; System.out.println(progress * 100 + \"%\" + \"\\t\\t\" + downSize / 1000000 + \"M\"); } } } catch (FileNotFoundException e) { status = 404; } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) bis.close(); if (raFile != null) raFile.close(); } catch (IOException e) { e.printStackTrace(); } } if (loadFileSize(saveUrl + BACK_SUFFIX) == totalSize) { fileRename(saveUrl + BACK_SUFFIX, saveUrl); } return status; }. \n Code2: public static void main(String args[]) { String url = \"jdbc:mySubprotocol:myDataSource\"; Connection con = null; Statement stmt; PreparedStatement updateSales; PreparedStatement updateTotal; String updateString = \"update COFFEES \" + \"set SALES = ? where COF_NAME = ?\"; String updateStatement = \"update COFFEES \" + \"set TOTAL = TOTAL + ? where COF_NAME = ?\"; String query = \"select COF_NAME, SALES, TOTAL from COFFEES\"; try { Class.forName(\"myDriver.ClassName\"); } catch (java.lang.ClassNotFoundException e) { System.err.print(\"ClassNotFoundException: \"); System.err.println(e.getMessage()); } try { con = DriverManager.getConnection(url, \"myLogin\", \"myPassword\"); updateSales = con.prepareStatement(updateString); updateTotal = con.prepareStatement(updateStatement); int[] salesForWeek = { 175, 150, 60, 155, 90 }; String[] coffees = { \"Colombian\", \"French_Roast\", \"Espresso\", \"Colombian_Decaf\", \"French_Roast_Decaf\" }; int len = coffees.length; con.setAutoCommit(false); for (int i = 0; i < len; i++) { updateSales.setInt(1, salesForWeek[i]); updateSales.setString(2, coffees[i]); updateSales.executeUpdate(); updateTotal.setInt(1, salesForWeek[i]); updateTotal.setString(2, coffees[i]); updateTotal.executeUpdate(); con.commit(); } con.setAutoCommit(true); updateSales.close(); updateTotal.close(); stmt = con.createStatement(); ResultSet rs = stmt.executeQuery(query); while (rs.next()) { String c = rs.getString(\"COF_NAME\"); int s = rs.getInt(\"SALES\"); int t = rs.getInt(\"TOTAL\"); System.out.println(c + \" \" + s + \" \" + t); } stmt.close(); con.close(); } catch (SQLException ex) { System.err.println(\"SQLException: \" + ex.getMessage()); if (con != null) { try { System.err.print(\"Transaction is being \"); System.err.println(\"rolled back\"); con.rollback(); } catch (SQLException excep) { System.err.print(\"SQLException: \"); System.err.println(excep.getMessage()); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void postData(String protocol, String host, String form, String data) throws Exception { if ((protocol == null) || (protocol.equals(\"\"))) { protocol = DEFAULT_PROTOCOL; } if ((host == null) || (host.equals(\"\"))) { host = DEFAULT_HOST; } if (form == null) { form = DEFAULT_FORM; } if (data == null) { throw new IllegalArgumentException(\"Invalid data\"); } URL url = new URL(protocol, host, form); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setDoInput(true); con.setUseCaches(false); con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\"); con.setRequestProperty(\"Content-length\", String.valueOf(data.length())); PrintStream out = new PrintStream(con.getOutputStream(), true); out.print(data); out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); while (in.readLine() != null) { } in.close(); }. \n Code2: public static void copyFile(String fromPath, String toPath) { try { File inputFile = new File(fromPath); String dirImg = (new File(toPath)).getParent(); File tmp = new File(dirImg); if (!tmp.exists()) { tmp.mkdir(); } File outputFile = new File(toPath); if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) { FileInputStream in = new FileInputStream(inputFile); FileOutputStream out = new FileOutputStream(outputFile); int c; while ((c = in.read()) != -1) out.",
        "ground_truth": "NO",
        "predict": "write(c); in.close(); out.close(); } } catch (IOException e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void postData(String protocol, String host, String form, String data) throws Exception { if ((protocol == null) || (protocol.equals(\"\"))) { protocol = DEFAULT_PROTOCOL; } if ((host == null) || (host.equals(\"\"))) { host = DEFAULT_HOST; } if (form == null) { form = DEFAULT_FORM; } if (data == null) { throw new IllegalArgumentException(\"Invalid data\"); } URL url = new URL(protocol, host, form); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setDoInput(true); con.setUseCaches"
    },
    {
        "ID": 26,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void parseXMLFile() { String u = WeatherApplication.SERVER + location + \".xml\"; InputStream in = null; String str = null; try { URL url = new URL(u); HttpURLConnection con = (HttpURLConnection) url.openConnection(); in = url.openStream(); ParserToolXML prt = new ParserToolXML(in); if (prt.doc == null) { System.err.println(FILE_NOT_FOUND_MSG + u); return; } NodeList ndl = prt.doc.getElementsByTagName(\"weather\"); for (int i = 0; i < ndl.getLength(); i++) { Forecast f = new Forecast(); str = prt.searchElementValue(ndl.item(i), \"date\"); f.setDate(str); str = prt.searchElementValue(ndl.item(i), \"daycode\"); f.setDaycode(Integer.parseInt(str.trim())); str = prt.searchElementValue(ndl.item(i), \"nightcode\"); f.setNightcode(Integer.parseInt(str.trim())); str = prt.searchElementValue(ndl.item(i), \"maxtemp\"); f.setDaytemp(Integer.parseInt(str.trim())); str = prt.searchElementValue(ndl.item(i), \"mintemp\"); f.setNighttemp(Integer.parseInt(str.trim())); str = prt.searchElementValue(ndl.item(i), \"winddirectionday\"); f.setDaywinddir(str); str = prt.searchElementValue(ndl.item(i), \"windspeedday\"); f.setDaywindspeed(Integer.parseInt(str.trim())); str = prt.searchElementValue(ndl.item(i), \"winddirectionnight\"); f.setNightwinddir(str); str = prt.searchElementValue(ndl.item(i), \"windspeednight\"); f.setNightwindspeed(Integer.parseInt(str.trim())); forecastlist.addElement(f); } } catch (MalformedURLException e) { System.err.println(MALFORMED_URL_MSG + u); System.err.println(e.getMessage()); e.printStackTrace(); } catch (IOException e) { } catch (NumberFormatException e) { System.err.println(FILE_CORRUPT_MSG + u); System.err.println(\"-\" + str + \"-\"); System.err.println(e.getMessage()); e.printStackTrace(); } finally { if (in != null) { try { in.close(); } catch (IOException e) { System.err.println(COULD_NOT_CLOSE_FILE_MSG + u); e.printStackTrace(); } } } }. \n Code2: public void copyFile(File source, File destination) { try { FileInputStream sourceStream = new FileInputStream(source); try { FileOutputStream destinationStream = new FileOutputStream(destination); try { FileChannel sourceChannel = sourceStream.getChannel(); sourceChannel.transferTo(0, sourceChannel.size(), destinationStream.getChannel()); } finally { try { destinationStream.close(); } catch (Exception e) { throw new RuntimeIoException(e, IoMode.CLOSE); } } } finally { try { sourceStream.close(); } catch (Exception e) { throw new RuntimeIoException(e, IoMode.CLOSE); } } } catch (IOException e) { throw new RuntimeIoException(e, IoMode.COPY); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) { log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); outageUpdater.setString(4, ipAddr); outageUpdater.setLong(5, serviceID); outageUpdater.executeUpdate(); outageUpdater.close(); try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } else { log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\"); } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \n Code2: private static byte[] baseHash(String name, String password) { try { MessageDigest digest = MessageDigest.getInstance(\"MD5\"); digest.reset(); digest.update(name.toLowerCase().getBytes()); digest.update(password.getBytes()); return digest.digest(); }",
        "ground_truth": "NO",
        "predict": " catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } }. \n Code2: private static String convertEventTimeIntoTimestamp(String eventTime) { try { return new Timestamp(Long.parseLong(eventTime)).toString(); } catch (NumberFormatException e) { throw new RuntimeException(e); } }. \n Code2: private static boolean openOutageExists(Connection dbConn, long nodeId, String ipAddr, long serviceId) throws SQLException { PreparedStatement stmt = dbConn.prepareStatement(OutageConstants.SQL_SELECT_OUTAGE_FOR_NODE_IP_SERVICE); stmt.setLong(1, nodeId); stmt.setString(2, ipAddr); stmt.setLong(3, serviceId); try { return stmt.executeQuery().next(); } finally { stmt.close(); } }. \n Code2: private static void closeStatement"
    },
    {
        "ID": 44,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletConfig config = getServletConfig(); ServletContext context = config.getServletContext(); try { String driver = context.getInitParameter(\"driver\"); Class.forName(driver); String dbURL = context.getInitParameter(\"db\"); String username = context.getInitParameter(\"username\"); String password = \"\"; connection = DriverManager.getConnection(dbURL, username, password); } catch (ClassNotFoundException e) { System.out.println(\"Database driver not found.\"); } catch (SQLException e) { System.out.println(\"Error opening the db connection: \" + e.getMessage()); } String action = \"\"; HttpSession session = request.getSession(); session.setMaxInactiveInterval(300); if (request.getParameter(\"action\") != null) { action = request.getParameter(\"action\"); } else { RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/login.jsp\"); dispatcher.forward(request, response); return; } if (action.equals(\"login\")) { String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); MessageDigest md = null; try { md = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { error = \"There was an error encrypting password.\"; session.setAttribute(\"error\", error); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/error.jsp\"); dispatcher.forward(request, response); return; } try { md.update(password.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { error = \"There was an error encrypting password.\"; session.setAttribute(\"error\", error); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/error.jsp\"); dispatcher.forward(request, response); return; } String encrypted_password = (new BASE64Encoder()).encode(md.digest()); try { String sql = \"SELECT * FROM person WHERE email LIKE '\" + username + \"' AND password='\" + encrypted_password + \"'\"; dbStatement = connection.createStatement(); dbResultSet = dbStatement.executeQuery(sql); if (dbResultSet.next()) { Person person = new Person(dbResultSet.getString(\"fname\"), dbResultSet.getString(\"lname\"), dbResultSet.getString(\"address1\"), dbResultSet.getString(\"address2\"), dbResultSet.getString(\"city\"), dbResultSet.getString(\"state\"), dbResultSet.getString(\"zip\"), dbResultSet.getString(\"email\"), dbResultSet.getString(\"password\"), dbResultSet.getInt(\"is_admin\")); String member_type = dbResultSet.getString(\"member_type\"); String person_id = Integer.toString(dbResultSet.getInt(\"id\")); session.setAttribute(\"person\", person); session.setAttribute(\"member_type\", member_type); session.setAttribute(\"person_id\", person_id); } else { notice = \"Your username and/or password is incorrect.\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/index.jsp\"); dispatcher.forward(request, response); return; } } catch (SQLException e) { error = \"There was an error trying to login. (SQL Statement)\"; session.setAttribute(\"error\", error); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/error.jsp\"); dispatcher.forward(request, response); return; } RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/index.jsp\"); dispatcher.forward(request, response); return; } else { notice = \"Unable to log you in. Please try again.\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/login.jsp\"); dispatcher.forward(request, response); return; } }. \n Code2: public Constructor run() throws Exception { String path = \"META-INF/services/\" + BeanletApplicationContext.class.getName(); ClassLoader loader = Thread.currentThread().getContextClassLoader(); final Enumeration<URL> urls; if (loader == null) { urls = BeanletApplicationContext.class.getClassLoader().getResources(path); } else { urls = loader.getResources(path); } while (urls.hasMoreElements()) { URL url = urls.nextElement(); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); try { String className = null; while ((className = reader.readLine()) != null) { final String name = className.trim(); if (!name.startsWith(\"#\") && !name.startsWith(\";\") && !name.startsWith(\"//\")) { final Class<?> cls; if (loader == null) { cls = Class.forName(name); } else { cls = Class.forName(name, true, loader); } int m = cls.getModifiers(); if (BeanletApplicationContext.class.isAssignableFrom(cls) && !Modifier.isAbstract(m) && !Modifier.isInterface(m)) { Constructor constructor = cls.getDeclaredConstructor(); if (!Modifier.isPublic(constructor.getModifiers())) { constructor.setAccessible(true); } return constructor; } else { throw new ClassCastException(cls.getName()); } } } } finally { reader.close(); } } throw new BeanletApplicationException(\"No \" + \"BeanletApplicationContext implementation \" + \"found.\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: String getLocation(Class clazz) { try { java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation(); String location = url.toString(); if (location.startsWith(\"jar\")) { url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL(); location = url.toString(); } if (location.startsWith(\"file\")) { java.io.File file = new java.io.File(url.getFile()); return file.getAbsolutePath(); } else { return url.toString(); } } catch (Throwable t) { } return Messages.getMessage(\"happyClientUnknownLocation\"); }. \n Code2: public static String eventHash(String eventstr) { try { if (md == null) { md = MessageDigest.getInstance(\"MD5\"); } md.update(eventstr.getBytes(\"utf-8\")); byte[] the",
        "ground_truth": "NO",
        "predict": "digest = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < thedigest.length; i++) { sb.append(Integer.toHexString((thedigest[i] & 0xFF) | 0x100).substring(1, 3)); } return sb.toString(); } catch (UnsupportedEncodingException e) { } catch (NoSuchAlgorithmException e) { } return \"\"; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: String getLocation(Class clazz) { try { java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation(); String location = url.toString(); if (location.startsWith(\"jar\")) { url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL(); location"
    },
    {
        "ID": 66,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String postFileRequest(String fileName, String internalFileName) throws Exception { status = STATUS_INIT; String responseString = null; String requestStringPostFix = new String(\"\"); if (isThreadStopped) { return \"\"; } status = STATUS_UPLOADING; if (isThreadStopped) { return \"\"; } String requestString = new String(\"\"); int contentLength = 0, c = 0, counter = 0; try { for (java.util.Iterator i = parameters.entrySet().iterator(); i.hasNext(); ) { java.util.Map.Entry e = (java.util.Map.Entry) i.next(); requestString = requestString + \"-----------------------------7d338a374003ea\\n\" + \"Content-Disposition: form-data; name=\\\"\" + (String) e.getKey() + \"\\\"\\n\\n\" + (String) e.getValue() + \"\\n\\n\"; } URL url = new URL(urlString); URLConnection connection = url.openConnection(); HttpURLConnection httpConn = (HttpURLConnection) connection; requestString = requestString + \"-----------------------------7d338a374003ea\\n\" + \"Content-Disposition: form-data; name=\\\"\" + internalFileName + \"\\\"; filename=\\\"\" + fileName + \"\\\"\\n\" + \"Content-Type: text/plain\\n\\n\"; requestStringPostFix = requestStringPostFix + \"\\n\\n\" + \"-----------------------------7d338a374003ea\\n\" + \"\\n\"; FileInputStream fis = null; String str = null; try { fis = new FileInputStream(fileName); int fileSize = fis.available(); contentLength = requestString.length() + requestStringPostFix.length() + fileSize; httpConn.setRequestProperty(\"Content-Length\", String.valueOf(contentLength)); httpConn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=---------------------------7d338a374003ea\"); httpConn.setRequestMethod(\"POST\"); httpConn.setDoOutput(true); httpConn.setDoInput(true); try { connection.connect(); } catch (ConnectException ec2) { error = true; finished = true; errorStr = \"Cannot connect to: \" + urlString; System.out.println(\"Cannot connect to:\" + urlString); } catch (java.io.InterruptedIOException e) { error = true; finished = true; errorStr = \"Connection to Portal lost: communication is timeouted.\"; parentWorkflow.getMenuButtonEventHandler().stopAutomaticRefresh(); } catch (IllegalStateException ei) { error = true; finished = true; errorStr = \"IllegalStateException: \" + ei.getMessage(); } OutputStream out = httpConn.getOutputStream(); byte[] toTransfer = requestString.getBytes(\"UTF-8\"); for (int i = 0; i < toTransfer.length; i++) { out.write(toTransfer[i]); } int count; int zBUFFER = 8 * 1024; setUploadProgress(fileSize, counter); byte data[] = new byte[zBUFFER]; GZIPOutputStream zos = new GZIPOutputStream(out); while ((count = fis.read(data, 0, zBUFFER)) != -1) { if (isThreadStopped) { return \"\"; } zos.write(data, 0, count); setUploadProgress(fileSize, counter); counter += count; } zos.flush(); zos.finish(); setUploadProgress(fileSize, counter); toTransfer = requestStringPostFix.getBytes(\"UTF-8\"); for (int i = 0; i < toTransfer.length; i++) { out.write(toTransfer[i]); } out.close(); } catch (IOException e) { finished = true; error = true; errorStr = \"Error in Uploading file: \" + fileName; } finally { try { fis.close(); } catch (IOException e2) { } } InputStreamReader isr = new InputStreamReader(httpConn.getInputStream()); BufferedReader br = new BufferedReader(isr); String temp; String tempResponse = \"\"; while ((temp = br.readLine()) != null) { if (isThreadStopped) { return \"\"; } tempResponse = tempResponse + temp + \"\\n\"; setDecompressStatusAtUpload(temp); } responseString = tempResponse; isr.close(); } catch (ConnectException ec) { error = true; finished = true; errorStr = \"Cannot connect to: \" + urlString + \"\\nServer is not responding.\"; } catch (java.io.InterruptedIOException e) { error = true; finished = true; errorStr = \"Connection to Portal lost: communication is timeouted.\"; parentWorkflow.getMenuButtonEventHandler().stopAutomaticRefresh(); } catch (IOException e2) { finished = true; error = true; errorStr = \"IOError in postFileRequest: \" + e2.getMessage(); } catch (Exception e4) { finished = true; error = true; errorStr = \"Error while trying to communicate the server: \" + e4.getMessage(); } return responseString; }. \n Code2: protected boolean check(String username, String password, String realm, String nonce, String nc, String cnonce, String qop, String uri, String response, HttpServletRequest request) { try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(username.getBytes()); md.update((byte) ':'); md.update(realm.getBytes()); md.update((byte) ':'); md.update(password.getBytes()); byte[] ha1 = md.digest(); md.reset(); md.update(request.getMethod().getBytes()); md.update((byte) ':'); md.update(uri.getBytes()); byte[] ha2 = md.digest(); md.update(TypeUtil.toString(ha1, 16).getBytes()); md.update((byte) ':'); md.update(nonce.getBytes()); md.update((byte) ':'); md.update(nc.getBytes()); md.update((byte) ':'); md.update(cnonce.getBytes()); md.update((byte) ':'); md.update(qop.getBytes()); md.update((byte) ':'); md.update(TypeUtil.toString(ha2, 16).getBytes()); byte[] digest = md.digest(); return response.equals(encode(digest)); } catch (Exception e) { e.printStackTrace(); return false; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected Reader openConnection(URL url) throws IOException { try { if (limit != null) { limit.",
        "ground_truth": "NO",
        "predict": "set(url); } } catch (Exception e) { } return new InputStreamReader(url.openStream()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String postFileRequest(String fileName, String internalFileName) throws Exception { status = STATUS_INIT; String responseString = null; String requestStringPostFix = new String(\"\"); if (isThreadStopped) { return \"\"; } status = STATUS_UPLOADING; if (isThreadStopped) { return \"\"; } String requestString = new String(\"\"); int contentLength = 0, c = 0, counter = 0; try { for (java.util.Iterator i = parameters.entrySet().iterator(); i.hasNext(); ) { java.util.Map.Entry e = (java.util.Map.Entry) i.next(); requestString = requestString + \"-----------------------------7d"
    },
    {
        "ID": 68,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void copiarMidias(final File vidDir, final File imgDir) { for (int i = 0; i < getMidias().size(); i++) { try { FileChannel src = new FileInputStream(getMidias().get(i).getUrl().trim()).getChannel(); FileChannel dest; if (getMidias().get(i).getTipo().equals(\"video\")) { FileChannel vidDest = new FileOutputStream(vidDir + \"/\" + processaString(getMidias().get(i).getTitulo()) + \".\" + retornaExtensaoMidia(getMidias().get(i))).getChannel(); dest = vidDest; } else { FileChannel midDest = new FileOutputStream(imgDir + \"/\" + processaString(getMidias().get(i).getTitulo()) + \".\" + retornaExtensaoMidia(getMidias().get(i))).getChannel(); dest = midDest; } dest.transferFrom(src, 0, src.size()); src.close(); dest.close(); } catch (Exception e) { System.err.print(e.getMessage()); e.printStackTrace(); } } }. \n Code2: private static void cut() { File inputFile = new File(inputFileName); BufferedReader in = null; try { in = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), inputCharSet)); } catch (FileNotFoundException e) { System.err.print(\"Invalid File Name!\"); System.err.flush(); System.exit(1); } catch (UnsupportedEncodingException e) { System.err.print(\"Invalid Char Set Name!\"); System.err.flush(); System.exit(1); } switch(cutMode) { case charMode: { int outputFileIndex = 1; char[] readBuf = new char[charPerFile]; while (true) { int readCount = 0; try { readCount = in.read(readBuf); } catch (IOException e) { System.err.println(\"Read IO Error!\"); System.err.flush(); System.exit(1); } if (-1 == readCount) break; else { try { int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = \"html\"; DecimalFormat outputFileIndexFormat = new DecimalFormat(\"0000\"); File outputFile = new File(prefixInputFileName + \"-\" + outputFileIndexFormat.format(outputFileIndex) + \".\" + postfixInputFileName); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile), outputCharSet)); out.write(readBuf, 0, readCount); out.flush(); out.close(); outputFileIndex++; } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } } } break; } case lineMode: { boolean isFileEnd = false; int outputFileIndex = 1; while (!isFileEnd) { try { int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = inputFileName.substring(ppos + 1); DecimalFormat outputFileIndexFormat = new DecimalFormat(\"0000\"); File outputFile = new File(prefixInputFileName + outputFileIndexFormat.format(outputFileIndex) + \".\" + postfixInputFileName); PrintStream out = new PrintStream(new FileOutputStream(outputFile), false, outputCharSet); int p = 0; while (p < linePerFile) { String line = in.readLine(); if (null == line) { isFileEnd = true; break; } out.println(line); ++p; } out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } ++outputFileIndex; } break; } case htmlMode: { boolean isFileEnd = false; int outputFileIndex = 1; int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = \"html\"; DecimalFormat df = new DecimalFormat(\"0000\"); while (!isFileEnd) { try { File outputFile = new File(prefixInputFileName + \"-\" + df.format(outputFileIndex) + \".\" + postfixInputFileName); PrintStream out = new PrintStream(new FileOutputStream(outputFile), false, outputCharSet); out.println(\"<html><head><title>\" + prefixInputFileName + \"-\" + df.format(outputFileIndex) + \"</title>\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; \" + \"charset=\" + outputCharSet + \"\\\" />\" + \"<link rel =\\\"stylesheet\\\" \" + \"type=\\\"text/css\\\" \" + \"href=\\\"stylesheet.css\\\" />\" + \"</head><body><div id=\\\"content\\\">\"); int p = 0; while (p < pPerFile) { String line = in.readLine(); if (null == line) { isFileEnd = true; break; } if (line.length() > 0) out.println(\"<p>\" + line + \"</p>\"); ++p; } out.println(\"</div><a href=\\\"\" + prefixInputFileName + \"-\" + df.format(outputFileIndex + 1) + \".\" + postfixInputFileName + \"\\\">NEXT</a></body></html>\"); out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } ++outputFileIndex; } try { File indexFile = new File(\"index.html\"); PrintStream out = new PrintStream(new FileOutputStream(indexFile), false, outputCharSet); out.println(\"<html><head><title>\" + \"Index\" + \"</title>\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; \" + \"charset=\" + outputCharSet + \"\\\" />\" + \"<link rel =\\\"stylesheet\\\" \" + \"type=\\\"text/css\\\" \" + \"href=\\\"stylesheet.css\\\" />\" + \"</head><body><h2>\" + htmlTitle + \"</h2><div id=\\\"content\\\"><ul>\"); for (int i = 1; i < outputFileIndex; i++) { out.println(\"<li><a href=\\\"\" + prefixInputFileName + \"-\" + df.format(i) + \".\" + postfixInputFileName + \"\\\">\" + df.format(i) + \"</a></li>\"); }",
        "ground_truth": "YES",
        "predict": " out.println(\"</ul></div><a href=\\\"\" + prefixInputFileName + \"-\" + df.format(outputFileIndex) + \".\" + postfixInputFileName + \"\\\">NEXT</a></body></html>\"); out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } } } }\n"
    },
    {
        "ID": 77,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean joinFiles(File dest, Collection<File> sources) { FileInputStream fis = null; FileOutputStream fos = null; boolean rv = false; byte[] buf = new byte[1000000]; int bytesRead = 0; if (!dest.getParentFile().exists()) dest.getParentFile().mkdirs(); try { fos = new FileOutputStream(dest); for (File source : sources) { fis = new FileInputStream(source); while ((bytesRead = fis.read(buf)) > 0) fos.write(buf, 0, bytesRead); fis.close(); fis = null; } fos.close(); fos = null; rv = true; } catch (Throwable t) { throw new ApplicationException(\"error joining files to \" + dest.getAbsolutePath(), t); } finally { if (fis != null) { try { fis.close(); } catch (Exception e) { } fis = null; } if (fos != null) { try { fos.close(); } catch (Exception e) { } fos = null; } } return rv; }. \n Code2: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void forBundle(BundleManipulator manip) { ByteArrayOutputStream bout = null; try { bout = new ByteArrayOutputStream(); ZipOutputStream zout = new ZipOutputStream(bout); Bundle bundle = getBundle(); Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false); if (files != null) { while (files.hasMoreElements()) { URL url = files.nextElement(); String name = url.getFile(); if (name.startsWith(\"/\")) { name = name.substring(1); } if (manip.includeEntry(name)) { zout.putNextEntry(new ZipEntry(name)); IOUtils.copy(url.openStream(), zout); } } } manip.finish(bundle, zout); Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream()); zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\")); mf.write(zout); zout.close(); File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\"); FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray()); if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) { pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME)); } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) { pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY)); } pluginController.installPlugin(new JarPluginArtifact(tmpFile)); ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName()); ((PackageAdmin) bundleContext.",
        "ground_truth": "YES",
        "predict": "getService(ref)).refreshPackages(null); } catch (IOException x) { x.printStackTrace(); } finally { if (bout != null) { try { bout.close(); } catch (IOException e) { } } } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void forBundle(BundleManipulator manip) { ByteArrayOutputStream bout = null; try { bout = new ByteArrayOutputStream(); ZipOutputStream zout = new ZipOutputStream(bout); Bundle bundle = getBundle(); Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false); if (files != null) { while (files.hasMoreElements()) { URL url = files.nextElement(); String name = url.getFile(); if (name.startsWith(\"/\")) { name = name.substring"
    },
    {
        "ID": 101,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void writeToFile(Body b, File mime4jFile) throws FileNotFoundException, IOException { if (b instanceof TextBody) { String charset = CharsetUtil.toJavaCharset(b.getParent().getCharset()); if (charset == null) { charset = \"ISO8859-1\"; } OutputStream out = new FileOutputStream(mime4jFile); IOUtils.copy(((TextBody) b).getReader(), out, charset); } else { OutputStream out = new FileOutputStream(mime4jFile); IOUtils.copy(((BinaryBody) b).getInputStream(), out); } }. \n Code2: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void unzipModel(String filename, String tempdir) throws EDITSException { try { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(filename); int BUFFER = 2048; ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { int count; byte data[] = new byte[BUFFER]; FileOutputStream fos = new FileOutputStream(tempdir + entry.getName()); dest = new BufferedOutputStream(fos, BUFFER); while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count); dest.flush(); dest.close(); } zis.close(); } catch (Exception e) { throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage()); } }. \n Code2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer(); for (int j = 0; j < array.length; ++j) { int b = array[j] & 0xFF; if (b < 0x10) sb.append('0'); sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { System.out",
        "ground_truth": "NO",
        "predict": ".println(\"Error: \" + e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void unzipModel(String filename, String tempdir) throws EDITSException { try { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(filename); int BUFFER = 2048; ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { int count; byte data[] = new byte[BUFFER]; FileOutputStream fos = new FileOutputStream(tempdir + entry.getName()); dest = new BufferedOutputStream(fos, BUFFER); while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count); dest.flush(); dest.close"
    },
    {
        "ID": 102,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Code2: private void installBinaryFile(File source, File destination) { byte[] buffer = new byte[8192]; FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(source); fos = new FileOutputStream(destination); int read; while ((read = fis.read(buffer)) != -1) { fos.write(buffer, 0, read); } } catch (FileNotFoundException e) { } catch (IOException e) { new ProjectCreateException(e, \"Failed to read binary file: %1$s\", source.getAbsolutePath()); } finally { if (fis != null) { try { fis.close(); } catch (IOException e) { } } if (fos != null) { try { fos.close(); } catch (IOException e) { } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\"; URL url = new URL(st); InputStream fis = null; if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream(); ZipInputStream zis = new ZipInputStream(fis); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { System.out.println(\"Extracting: \" + entry); int count; byte data[] = new byte[BUFFER]; FileOutputStream fos = new FileOutputStream(entry.getName()); BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER); while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count); dest.flush(); dest.close(); } zis.close(); }. \n Code2: public static void main(String[] args) { try { boolean readExp = Utils.getFlag('l', args); final boolean writeExp = Utils.getFlag('s', args); final String expFile = Utils.getOption('f', args); if ((readExp || writeExp) && (expFile.length() == 0)) { throw new Exception(\"A filename must be given with the -f option\"); } Experiment exp = null; if (readExp) { FileInputStream fi = new FileInputStream(expFile); ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi)); exp = (Experiment) oi.readObject(); oi.close(); } else { exp = new Experiment(); } System.err.println(\"Initial Experiment:\\n\" + exp.toString()); final JFrame jf = new JFrame(\"Weka Experiment Setup\"); jf.getContentPane().setLayout(new BorderLayout()); final SetupPanel sp = new SetupPanel(); jf.getContentPane().add(sp, BorderLayout.CENTER); jf.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString()); if (writeExp) { try { FileOutputStream fo = new FileOutputStream(expFile); ObjectOutputStream oo = new ObjectOutput",
        "ground_truth": "YES",
        "predict": "Stream(new BufferedOutputStream(fo)); oo.writeObject(sp.m_Exp); oo.close(); } catch (Exception ex) { ex.printStackTrace(); } } } }); jf.pack(); jf.setVisible(true); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\"; URL url = new URL(st); InputStream fis = null; if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream(); ZipInputStream zis = new ZipInputStream"
    },
    {
        "ID": 104,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void initializeTree() { InputStreamReader reader = null; BufferedReader buffReader = null; try { for (int i = 0; i < ORDER.length; i++) { int index = ORDER[i]; String indexName = index < 10 ? \"0\" + index : (index > 20 ? \"big\" : \"\" + index); URL url = EmptyClass.class.getResource(\"engchar\" + indexName + \".dic\"); logger.info(\"... Loading: \" + \"engchar\" + indexName + \".dic = {\" + url + \"}\"); reader = new InputStreamReader(url.openStream()); buffReader = new BufferedReader(reader); String line = null; String word = null; do { line = buffReader.readLine(); if (line != null) { boolean plural = line.endsWith(\"/S\"); boolean forbidden = line.endsWith(\"/X\"); if (plural) { int stringIndex = line.indexOf(\"/S\"); word = new String(line.substring(0, stringIndex)); } else if (forbidden) { int stringIndex = line.indexOf(\"/X\"); word = new String(line.substring(0, stringIndex)); } else { word = line.toString(); } if (tree == null) { tree = new BKTree(); } tree.insertDictionaryWord(word, plural, forbidden); } } while (line != null); } logger.debug(\"Loading supplemental dictionary...\"); List<String> listOfWords = KSupplementalDictionaryUtil.getWords(); for (String word : listOfWords) { tree.insertDictionaryWord(word, false, false); } initialized = true; } catch (Exception exception) { logger.error(\"Error\", exception); } finally { if (reader != null) { try { reader.close(); } catch (Exception ex) { } } if (buffReader != null) { try { buffReader.close(); } catch (Exception ex) { } } } }. \n Code2: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void updateFile(File file) throws FileNotFoundException, IOException { File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\")); FileChannel in = null; FileChannel out = null; try { if (!destFile.exists()) { destFile.getParentFile().mkdirs(); destFile.createNewFile(); } in = new FileInputStream(file).getChannel(); out = new FileOutputStream(destFile).getChannel(); in.transferTo(0, in.size(), out); } finally { if (out != null) out.close(); if (in != null) in.close(); } }. \n Code2: public static JSONObject getJSONData(String url) throws JSONException { JSONObject jObject = null; InputStream data = null; DefaultHttpClient httpClient = new DefaultHttpClient(); URI uri; try { uri = new URI(url); HttpGet httpGet = new HttpGet(uri); HttpResponse response = httpClient.execute(httpGet); data = response.getEntity().getContent(); String line; StringBuilder builder",
        "ground_truth": "NO",
        "predict": " = new StringBuilder();\n while ((line = readLine(data)) != null) { builder.append(line); } jObject = new JSONObject(builder.toString()); } catch (Exception e) { e.printStackTrace(); } finally { if (data != null) data.close(); } return jObject; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void updateFile(File file) throws FileNotFoundException, IOException { File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\")); FileChannel in = null; FileChannel out = null; try { if (!destFile.exists()) { destFile.getParentFile().mkdirs(); destFile.createNewFile(); } in = new FileInputStream(file).getChannel(); out = new FileOutputStream(dest"
    },
    {
        "ID": 111,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean copyDataToNewTable(EboContext p_eboctx, String srcTableName, String destTableName, String where, boolean log, int mode) throws boRuntimeException { srcTableName = srcTableName.toUpperCase(); destTableName = destTableName.toUpperCase(); Connection cn = null; Connection cndef = null; boolean ret = false; try { boolean srcexists = false; boolean destexists = false; final InitialContext ic = new InitialContext(); cn = p_eboctx.getConnectionData(); cndef = p_eboctx.getConnectionDef(); PreparedStatement pstm = cn.prepareStatement(\"SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?\"); pstm.setString(1, srcTableName); ResultSet rslt = pstm.executeQuery(); if (rslt.next()) { srcexists = true; } rslt.close(); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { destexists = true; } if (!destexists) { rslt.close(); pstm.close(); pstm = cn.prepareStatement(\"SELECT VIEW_NAME FROM USER_VIEWS WHERE VIEW_NAME=?\"); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { CallableStatement cstm = cn.prepareCall(\"DROP VIEW \" + destTableName); cstm.execute(); cstm.close(); } } rslt.close(); pstm.close(); if (srcexists && !destexists) { if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"CREATING_AND_COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage(\"TO\") + \" [\" + destTableName + \"]\"); } CallableStatement cstm = cn.prepareCall(\"CREATE TABLE \" + destTableName + \" AS SELECT * FROM \" + srcTableName + \" \" + (((where != null) && (where.length() > 0)) ? (\" WHERE \" + where) : \"\")); cstm.execute(); cstm.close(); if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"UPDATING_NGTDIC\")); } cn.commit(); ret = true; } else if (srcexists && destexists) { if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage(\"TO\") + \" [\" + destTableName + \"]\"); } PreparedStatement pstm2 = cn.prepareStatement(\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? \"); pstm2.setString(1, destTableName); ResultSet rslt2 = pstm2.executeQuery(); StringBuffer fields = new StringBuffer(); PreparedStatement pstm3 = cn.prepareStatement(\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? and COLUMN_NAME=?\"); while (rslt2.next()) { pstm3.setString(1, srcTableName); pstm3.setString(2, rslt2.getString(1)); ResultSet rslt3 = pstm3.executeQuery(); if (rslt3.next()) { if (fields.length() > 0) { fields.append(','); } fields.append('\"').append(rslt2.getString(1)).append('\"'); } rslt3.close(); } pstm3.close(); rslt2.close(); pstm2.close(); CallableStatement cstm; int recs = 0; if ((mode == 0) || (mode == 1)) { cstm = cn.prepareCall(\"INSERT INTO \" + destTableName + \"( \" + fields.toString() + \" ) ( SELECT \" + fields.toString() + \" FROM \" + srcTableName + \" \" + (((where != null) && (where.length() > 0)) ? (\" WHERE \" + where) : \"\") + \")\"); recs = cstm.executeUpdate(); cstm.close(); if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"DONE\") + \" [\" + recs + \"] \" + LoggerMessageLocalizer.getMessage(\"RECORDS_COPIED\")); } } cn.commit(); ret = true; } } catch (Exception e) { try { cn.rollback(); } catch (Exception z) { throw new boRuntimeException(\"boBuildDB.moveTable\", \"BO-1304\", z); } throw new boRuntimeException(\"boBuildDB.moveTable\", \"BO-1304\", e); } finally { try { cn.close(); } catch (Exception e) { } try { cndef.close(); } catch (Exception e) { } } return ret; }. \n Code2: public void testRevcounter() throws ServiceException, IOException { JCRNodeSource emptySource = loadTestSource(); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } String testSourceUri = BASE_URL + \"users/lars.trieloff?revision=1.1\"; JCRNodeSource secondSource = (JCRNodeSource) resolveSource(testSourceUri); System.out.println(\"Created at: \" + secondSource.getSourceRevision()); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } System.out.println(\"Read again at:\" + secondSource.getSourceRevision()); assertNotNull(emptySource.getSourceRevision()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void polishOff(IProgressMonitor monitor, String from,",
        "ground_truth": "NO",
        "predict": " String to) throws boException { Connection cn = null; Connection cndef = null; try { final InitialContext ic = new InitialContext(); cn = (Connection) ic.lookup(\"java:comp/env/jdbc/test\"); cndef = (Connection) ic.lookup(\"java:comp/env/jdbc/test\"); } catch (Exception e) { throw new boException(\"boBuildDB.polishOff\", \"BO-1304\", e); } try { PreparedStatement pstm = cn.prepareStatement(\"UPDATE USER_TABLES SET VIEW_NAME=? WHERE TABLE_NAME=?\"); pstm.setString(1, to); pstm.setString(2, from); pstm.execute(); pstm.close(); } catch (Exception e) { throw new boException(\"boBuildDB.polishOff\", \"BO-1304\", e); } }. \n Response: NO. \n"
    },
    {
        "ID": 112,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { PatternLayout pl = new PatternLayout(\"%d{ISO8601} %-5p %c: %m\\n\"); ConsoleAppender ca = new ConsoleAppender(pl); Logger.getRoot().addAppender(ca); Logger.getRoot().setLevel(Level.INFO); Options options = new Options(); options.addOption(\"p\", \"put\", false, \"put a file in the DHT overlay\"); options.addOption(\"g\", \"get\", false, \"get a file from the DHT\"); options.addOption(\"r\", \"remove\", false, \"remove a file from the DHT\"); options.addOption(\"u\", \"update\", false, \"updates the lease\"); options.addOption(\"j\", \"join\", false, \"join the DHT overlay\"); options.addOption(\"c\", \"config\", true, \"the configuration file\"); options.addOption(\"k\", \"key\", true, \"the key to read a file from\"); options.addOption(\"f\", \"file\", true, \"the file to read or write\"); options.addOption(\"a\", \"app\", true, \"the application ID\"); options.addOption(\"s\", \"secret\", true, \"the secret used to hide data\"); options.addOption(\"t\", \"ttl\", true, \"how long in seconds data should persist\"); CommandLineParser parser = new PosixParser(); CommandLine cmd = parser.parse(options, args); String configFile = null; String mode = null; String secretStr = null; int ttl = 9999; String keyStr = null; String file = null; int appId = 0; if (cmd.hasOption(\"j\")) { mode = \"join\"; } if (cmd.hasOption(\"p\")) { mode = \"put\"; } if (cmd.hasOption(\"g\")) { mode = \"get\"; } if (cmd.hasOption(\"r\")) { mode = \"remove\"; } if (cmd.hasOption(\"u\")) { mode = \"update\"; } if (cmd.hasOption(\"c\")) { configFile = cmd.getOptionValue(\"c\"); } if (cmd.hasOption(\"k\")) { keyStr = cmd.getOptionValue(\"k\"); } if (cmd.hasOption(\"f\")) { file = cmd.getOptionValue(\"f\"); } if (cmd.hasOption(\"s\")) { secretStr = cmd.getOptionValue(\"s\"); } if (cmd.hasOption(\"t\")) { ttl = Integer.parseInt(cmd.getOptionValue(\"t\")); } if (cmd.hasOption(\"a\")) { appId = Integer.parseInt(cmd.getOptionValue(\"a\")); } if (mode == null) { System.err.println(\"ERROR: --put or --get or --remove or --join or --update is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (configFile == null) { System.err.println(\"ERROR: --config is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } Properties conf = new Properties(); conf.load(new FileInputStream(configFile)); DHT dht = new DHT(conf); if (mode.equals(\"join\")) { dht.join(); } else if (mode.equals(\"put\")) { if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"putting file \" + file); FileInputStream in = new FileInputStream(file); byte[] tmp = new byte[1000000]; int num = in.read(tmp); byte[] value = new byte[num]; System.arraycopy(tmp, 0, value, 0, num); in.close(); if (dht.put((short) appId, keyStr.getBytes(), value, ttl, secretStr.getBytes()) < 0) { logger.info(\"There was an error while putting a key-value.\"); System.exit(0); } System.out.println(\"Ok!\"); } else if (mode.equals(\"get\")) { if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"getting file \" + file); ArrayList<byte[]> values = new ArrayList<byte[]>(); if (dht.get((short) appId, keyStr.getBytes(), Integer.MAX_VALUE, values) < 0) { logger.info(\"There was an error while getting a value.\"); System.exit(0); } if (values.size() == 0 || values == null) { System.out.println(\"No values returned.\"); System.exit(0); } FileOutputStream out = new FileOutputStream(file); System.out.println(\"Found \" + values.size() + \" values -- saving the first one only.\"); out.write(values.get(0)); out.close(); System.out.println(\"Ok!\"); } else if (mode.equals(\"remove\")) { if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"removing <key,value> for key=\" + keyStr); if (dht.remove((short) appId, keyStr.getBytes(), secretStr.getBytes()) < 0) { logger.info(\"There was an error while removing a key.\"); System.exit(0); } System.out.println(\"Ok!\"); } else if (mode.equals(\"update\")) { if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options);",
        "ground_truth": "NO",
        "predict": " System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"updating <key,value> for key=\" + keyStr); FileInputStream in = new FileInputStream(file); byte[] tmp = new byte[1000000]; int num = in.read(tmp); byte[] value = new byte[num]; System.arraycopy(tmp, 0, value, 0, num); in.close(); if (dht.update((short) appId, keyStr.getBytes(), value, secretStr.getBytes()) < 0) { logger.info"
    },
    {
        "ID": 114,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void removeOrphansElements() throws DatabaseException { this.getIdChache().clear(); final Connection connection = this.getConnection(); try { connection.setAutoCommit(false); PreparedStatement preparedStatement; preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getCallElementsSchemaAndTableName() + \" FROM \" + this.getCallElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getCallInvocationsSchemaAndTableName() + \" ON \" + this.getCallElementsSchemaAndTableName() + \".element_id = \" + this.getCallInvocationsSchemaAndTableName() + \".element_id WHERE \" + this.getCallInvocationsSchemaAndTableName() + \".element_id IS NULL\"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getCallExceptionsSchemaAndTableName() + \" FROM \" + this.getCallExceptionsSchemaAndTableName() + \" LEFT JOIN \" + this.getCallInvocationsSchemaAndTableName() + \" ON \" + this.getCallExceptionsSchemaAndTableName() + \".exception_id = \" + this.getCallInvocationsSchemaAndTableName() + \".exception_id WHERE \" + this.getCallInvocationsSchemaAndTableName() + \".exception_id IS NULL\"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getCallPrincipalsSchemaAndTableName() + \" FROM \" + this.getCallPrincipalsSchemaAndTableName() + \" LEFT JOIN \" + this.getCallInvocationsSchemaAndTableName() + \" ON \" + this.getCallPrincipalsSchemaAndTableName() + \".principal_id = \" + this.getCallInvocationsSchemaAndTableName() + \".principal_id WHERE \" + this.getCallInvocationsSchemaAndTableName() + \".principal_id IS NULL\"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getHttpSessionElementsSchemaAndTableName() + \" FROM \" + this.getHttpSessionElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getHttpSessionInvocationsSchemaAndTableName() + \" ON \" + this.getHttpSessionElementsSchemaAndTableName() + \".element_id = \" + this.getHttpSessionInvocationsSchemaAndTableName() + \".element_id WHERE \" + this.getHttpSessionInvocationsSchemaAndTableName() + \".element_id IS NULL\"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getJvmElementsSchemaAndTableName() + \" FROM \" + this.getJvmElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getJvmInvocationsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id = \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id IS NULL\"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getPersistenceEntityElementsSchemaAndTableName() + \" FROM \" + this.getPersistenceEntityElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getPersistenceEntityStatisticsSchemaAndTableName() + \" ON \" + this.getPersistenceEntityElementsSchemaAndTableName() + \".element_id = \" + this.getPersistenceEntityStatisticsSchemaAndTableName() + \".element_id WHERE \" + this.getPersistenceEntityStatisticsSchemaAndTableName() + \".element_id IS NULL \"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getPersistenceQueryElementsSchemaAndTableName() + \" FROM \" + this.getPersistenceQueryElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getPersistenceQueryStatisticsSchemaAndTableName() + \" ON \" + this.getPersistenceQueryElementsSchemaAndTableName() + \".element_id = \" + this.getPersistenceQueryStatisticsSchemaAndTableName() + \".element_id WHERE \" + this.getPersistenceQueryStatisticsSchemaAndTableName() + \".element_id IS NULL \"); preparedStatement.executeUpdate(); preparedStatement.close(); preparedStatement = DebugPreparedStatement.prepareStatement(connection, \"DELETE \" + this.getHardDiskElementsSchemaAndTableName() + \" FROM \" + this.getHardDiskElementsSchemaAndTableName() + \" LEFT JOIN \" + this.getHardDiskInvocationsSchemaAndTableName() + \" ON \" + this.getHardDiskElementsSchemaAndTableName() + \".element_id = \" + this.getHardDiskInvocationsSchemaAndTableName() + \".element_id WHERE \" + this.getHardDiskInvocationsSchemaAndTableName() + \".element_id IS NULL \"); preparedStatement.executeUpdate(); preparedStatement.close(); connection.commit(); } catch (final SQLException e) { try { connection.rollback(); } catch (final SQLException ex) { JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex); } JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage()); throw new DatabaseException(\"Error cleaning database.\", e); } finally { this.releaseConnection(connection); } return; }. \n Code2: private static void executeSQLScript() { File f = new File(System.getProperty(\"user.dir\") + \"/resources/umc.sql\"); if (f.exists()) { Connection con = null; PreparedStatement pre_stmt = null; try { Class.forName(\"org.sqlite.JDBC\"); con = DriverManager.getConnection(\"jdbc:sqlite:database/umc.db\", \"\", \"\"); BufferedReader br = new BufferedReader(new FileReader(f)); String line = \"\"; con.setAutoCommit(false); while ((line = br.readLine()) != null) { if (!line.equals(\"\") && !line.startsWith(\"--\") && !line.contains(\"--\")) {",
        "ground_truth": "NO",
        "predict": " if (line.contains(\"INSERT INTO\")) { pre_stmt = con.prepareStatement(line); pre_stmt.executeUpdate(); } else if (line.contains(\"UPDATE\")) { pre_stmt = con.prepareStatement(line); pre_stmt.executeUpdate(); } else if (line.contains(\"DELETE\")) { pre_stmt = con.prepareStatement(line); pre_stmt.executeUpdate(); } } } } catch (final Exception e) { JeeObserverServerContext.logger.log(Level.SEVERE, \"Error executing SQL script.\", e); } finally { try { if (pre_stmt != null) { pre_stmt.close(); } } catch (final SQLException e) { JeeObserverServerContext.logger.log(Level.SEVERE, \"Error closing SQL statement.\", e); } try { if (con != null) { con.close(); } } catch ("
    },
    {
        "ID": 116,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String hash(String message) { MessageDigest md = null; try { md = MessageDigest.getInstance(\"SHA1\"); } catch (NoSuchAlgorithmException e) { throw new AssertionError(\"Can't find the SHA1 algorithm in the java.security package\"); } String saltString = String.valueOf(12345); md.update(saltString.getBytes()); md.update(message.getBytes()); byte[] digestBytes = md.digest(); StringBuffer digestSB = new StringBuffer(); for (int i = 0; i < digestBytes.length; i++) { int lowNibble = digestBytes[i] & 0x0f; int highNibble = (digestBytes[i] >> 4) & 0x0f; digestSB.append(Integer.toHexString(highNibble)); digestSB.append(Integer.toHexString(lowNibble)); } String digestStr = digestSB.toString().trim(); return digestStr; }. \n Code2: public static String[] putFECSplitFile(String uri, File file, int htl, boolean mode) { FcpFECUtils fecutils = null; Vector segmentHeaders = null; Vector segmentFileMaps = new Vector(); Vector checkFileMaps = new Vector(); Vector segmentKeyMaps = new Vector(); Vector checkKeyMaps = new Vector(); int fileLength = (int) file.length(); String output = new String(); int maxThreads = frame1.frostSettings.getIntValue(\"splitfileUploadThreads\"); Thread[] chunkThreads = null; String[][] chunkResults = null; Thread[] checkThreads = null; String[][] checkResults = null; int threadCount = 0; String board = getBoard(file); { fecutils = new FcpFECUtils(frame1.frostSettings.getValue(\"nodeAddress\"), frame1.frostSettings.getIntValue(\"nodePort\")); synchronized (fecutils.getClass()) { try { segmentHeaders = fecutils.FECSegmentFile(\"OnionFEC_a_1_2\", fileLength); } catch (Exception e) { } } int chunkCnt = 0; int checkCnt = 0; synchronized (fecutils.getClass()) { try { Socket fcpSock; BufferedInputStream fcpIn; PrintStream fcpOut; for (int i = 0; i < segmentHeaders.size(); i++) { int blockCount = (int) ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).BlockCount; int blockNo = 0; fcpSock = new Socket(InetAddress.getByName(frame1.frostSettings.getValue(\"nodeAddress\")), frame1.frostSettings.getIntValue(\"nodePort\")); fcpSock.setSoTimeout(1800000); fcpOut = new PrintStream(fcpSock.getOutputStream()); fcpIn = new BufferedInputStream(fcpSock.getInputStream()); FileInputStream fileIn = new FileInputStream(file); File[] chunkFiles = new File[blockCount]; { System.out.println(\"Processing segment \" + i); fileIn.skip(((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).Offset); long segLength = ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).BlockCount * ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).BlockSize; System.out.println(\"segLength = \" + Long.toHexString(segLength)); String headerString = \"SegmentHeader\\n\" + ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).reconstruct() + \"EndMessage\\n\"; String dataHeaderString = \"\\0\\0\\0\\2FECEncodeSegment\\nMetadataLength=\" + Long.toHexString(headerString.length()) + \"\\nDataLength=\" + Long.toHexString(headerString.length() + segLength) + \"\\nData\\n\" + headerString; System.out.print(dataHeaderString); fcpOut.print(dataHeaderString); long count = 0; while (count < segLength) { byte[] buffer = new byte[(int) ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).BlockSize]; System.out.println(Long.toHexString(((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).Offset + count)); int inbytes = fileIn.read(buffer); if (inbytes < 0) { System.out.println(\"End of input file - no data\"); for (int j = 0; j < buffer.length; j++) buffer[j] = 0; inbytes = buffer.length; } if (inbytes < buffer.length) { System.out.println(\"End of input file - not enough data\"); for (int j = inbytes; j < buffer.length; j++) buffer[j] = 0; inbytes = buffer.length; } if (inbytes > segLength - count) inbytes = (int) (segLength - count); fcpOut.write(buffer); File uploadMe = new File(frame1.keypool + String.valueOf(System.currentTimeMillis()) + \"-\" + chunkCnt + \".tmp\"); chunkFiles[blockNo] = uploadMe; uploadMe.deleteOnExit(); FileOutputStream fileOut = new FileOutputStream(uploadMe); fileOut.write(buffer, 0, (int) inbytes); fileOut.close(); count += inbytes; chunkCnt++; ; blockNo++; if (blockNo >= blockCount) break; } segmentFileMaps.add(chunkFiles); fcpOut.flush(); fileIn.close(); } int checkNo = 0; int checkBlockCount = (int) ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).CheckBlockCount; File[] checkFiles = new File[checkBlockCount]; File uploadMe = null; FileOutputStream outFile = null; { String currentLine; long checkBlockSize = ((FcpFECUtilsSegmentHeader) segmentHeaders.get(i)).CheckBlockSize; int checkPtr = 0; int length = 0; do { boolean started = false; currentLine = fecutils.getLine(fcpIn).trim(); if (currentLine.equals(\"DataChunk\")) { started = true; } if (currentLine.startsWith(\"Length=\")) { length = Integer.parseInt((currentLine.split(\"=\"))[1], 16); } if (currentLine.equals(\"Data\")) { int currentRead; byte[] buffer = new byte[(int) length]; if (uploadMe == null) { uploadMe = new File(frame1.keypool + String.valueOf(System.currentTimeMillis()) + \"-chk-\" + checkCnt + \".tmp\"); uploadMe.delete",
        "ground_truth": "NO",
        "predict": "OnExit(); outFile = new FileOutputStream(uploadMe); } while (length > 0) { currentRead = fcpIn.read(buffer); if (currentRead < 0) break; length -= currentRead; outFile.write(buffer, 0, currentRead); } } if (currentLine.equals(\"EndMessage\")) { if (uploadMe == null) { uploadMe = new File(frame1.keypool + String.valueOf(System.currentTimeMillis()) + \"-chk-\" + checkCnt + \".tmp\"); uploadMe.deleteOnExit(); outFile = new FileOutputStream(uploadMe); } } if (started) { if (length > 0) { if (uploadMe == null) { uploadMe = new File(frame1.keypool + String.valueOf(System.currentTimeMillis()) + \"-chk-\" + checkCnt + \".tmp\"); uploadMe.deleteOnExit(); outFile = new FileOutputStream(uploadMe); } } if"
    },
    {
        "ID": 128,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean copyFile(final File src, final File dest, long extent, final boolean overwrite) throws FileNotFoundException, IOException { boolean result = false; if (LOGGER.isLoggable(Level.FINE)) { LOGGER.fine(\"Copying file \" + src + \" to \" + dest + \" extent \" + extent + \" exists \" + dest.exists()); } if (dest.exists()) { if (overwrite) { dest.delete(); LOGGER.finer(dest.getAbsolutePath() + \" removed before copy.\"); } else { return result; } } FileInputStream fis = null; FileOutputStream fos = null; FileChannel fcin = null; FileChannel fcout = null; try { fis = new FileInputStream(src); fos = new FileOutputStream(dest); fcin = fis.getChannel(); fcout = fos.getChannel(); if (extent < 0) { extent = fcin.size(); } long trans = fcin.transferTo(0, extent, fcout); if (trans < extent) { result = false; } result = true; } catch (IOException e) { String message = \"Copying \" + src.getAbsolutePath() + \" to \" + dest.getAbsolutePath() + \" with extent \" + extent + \" got IOE: \" + e.getMessage(); if (e.getMessage().equals(\"Invalid argument\")) { LOGGER.severe(\"Failed copy, trying workaround: \" + message); workaroundCopyFile(src, dest); } else { IOException newE = new IOException(message); newE.setStackTrace(e.getStackTrace()); throw newE; } } finally { if (fcin != null) { fcin.close(); } if (fcout != null) { fcout.close(); } if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } return result; }. \n Code2: public static final boolean checkForUpdate(final String currentVersion, final String updateURL, boolean noLock) throws Exception { try { final String parentFDTConfDirName = System.getProperty(\"user.home\") + File.separator + \".fdt\"; final String fdtUpdateConfFileName = \"update.properties\"; final File confFile = createOrGetRWFile(parentFDTConfDirName, fdtUpdateConfFileName); if (confFile != null) { long lastCheck = 0; Properties updateProperties = new Properties(); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(confFile); updateProperties.load(fis); final String lastCheckProp = (String) updateProperties.get(\"LastCheck\"); lastCheck = 0; if (lastCheckProp != null) { try { lastCheck = Long.parseLong(lastCheckProp); } catch (Throwable t) { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"Got exception parsing LastCheck param\", t); } lastCheck = 0; } } } catch (Throwable t) { logger.log(Level.WARNING, \"Cannot load update properties file: \" + confFile, t); } finally { closeIgnoringExceptions(fos); closeIgnoringExceptions(fis); } final long now = System.currentTimeMillis(); boolean bHaveUpdates = false; checkAndSetInstanceID(updateProperties); if (lastCheck + FDT.UPDATE_PERIOD < now) { lastCheck = now; try { logger.log(\"\\n\\nChecking for remote updates ... This may be disabled using -noupdates flag.\"); bHaveUpdates = updateFDT(currentVersion, updateURL, false, noLock); if (bHaveUpdates) { logger.log(\"FDT may be updated using: java -jar fdt.jar -update\"); } else { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"No updates available\"); } } } catch (Throwable t) { if (logger.isLoggable(Level.FINE)) { logger.log(Level.WARNING, \"Got exception\", t); } } updateProperties.put(\"LastCheck\", \"\" + now); try { fos = new FileOutputStream(confFile); updateProperties.store(fos, null); } catch (Throwable t1) { logger.log(Level.WARNING, \"Cannot store update properties file\", t1); } finally { closeIgnoringExceptions(fos); } return bHaveUpdates; } } else { if (logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \" [ checkForUpdate ] Cannot read or write the update conf file: \" + parentFDTConfDirName + File.separator + fdtUpdateConfFileName); } return false; } } catch (Throwable t) { logger.log(Level.WARNING, \"Got exception checking for updates\", t); } return false; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException { ProgramProfilingMessageSymbol profilingMessageSymbol = null; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\"; connection = DriverManager.getConnection(CONN_STR); statement = connection.createStatement(); statement.executeUpdate(query); query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID = \" + programMessageSymbolID; resultSet = statement.executeQuery(query); if (!resultSet.next()) { connection.rollback(); String msg = \"Attempt to create program profiling message \" + \"symbol failed.\"; log.error(msg); throw new AdaptationException(msg); } profilingMessageSymbol = getProfilingMessageSymbol(resultSet); connection.commit(); } catch (SQLException ex) { try { connection.rollback(); } catch (Exception e) { } String msg = \"SQLException in createNewProfilingMessageSymbol\"; log.error(msg, ex); throw new AdaptationException(msg, ex); } finally { try { resultSet.close(); } catch (Exception ex) { } try { statement.close(); } catch (Exception ex) { } try { connection.close(); } catch (Exception ex) { } } return profilingMessageSymbol; }. \n Code2: public void Load(String fname",
        "ground_truth": "NO",
        "predict": ") throws Exception { try { final String parentFDTConfDirName = System.getProperty(\"user.home\") + File.separator + \".fdt\"; final String fdtUpdateConfFileName = \"update.properties\"; final File confFile = createOrGetRWFile(parentFDTConfDirName, fdtUpdateConfFileName); if (confFile != null) { Properties updateProperties = new Properties(); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(confFile); updateProperties.load(fis); } catch (Throwable t) { logger.log(Level.WARNING, \"Cannot load update properties file: \" + confFile, t); } finally { closeIgnoringExceptions(fis); closeIgnoringExceptions(fos); } } } catch (Throwable t) { logger.log(Level.WARNING, \"Got exception loading fdt update properties file\", t); } }. \n Code3"
    },
    {
        "ID": 144,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer(); for (int j = 0; j < array.length; ++j) { int b = array[j] & 0xFF; if (b < 0x10) sb.append('0'); sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { System.out.println(\"Error:\" + e); } }. \n Code2: private void copyTemplates(ProjectPath pPath) { String sourceAntPath = pPath.sourceAntPath(); final String moduleName = projectOperations.getFocusedTopLevelPackage().toString(); logger.info(\"Module Name: \" + moduleName); String targetDirectory = pPath.canonicalFileSystemPath(projectOperations); logger.info(\"Moving into target Directory: \" + targetDirectory); if (!targetDirectory.endsWith(\"/\")) { targetDirectory += \"/\"; } if (!fileManager.exists(targetDirectory)) { fileManager.createDirectory(targetDirectory); } System.out.println(\"Target Directory: \" + pPath.sourceAntPath()); String path = TemplateUtils.getTemplatePath(getClass(), sourceAntPath); Set<URL> urls = UrlFindingUtils.findMatchingClasspathResources(context.getBundleContext(), path); Assert.notNull(urls, \"Could not search bundles for resources for Ant Path '\" + path + \"'\"); if (urls.isEmpty()) { logger.info(\"URLS are empty stopping...\"); } for (URL url : urls) { logger.info(\"Stepping into \" + url.toExternalForm()); String fileName = url.getPath().substring(url.getPath().lastIndexOf(\"/\") + 1); fileName = fileName.replace(\"-template\", \"\"); String targetFilename = targetDirectory + fileName; logger.info(\"Handling \" + targetFilename); if (!fileManager.exists(targetFilename)) { try { logger.info(\"Copied file\"); String input = FileCopyUtils.copyToString(new InputStreamReader(url.openStream())); logger.info(\"TopLevelPackage: \" + projectOperations.getFocusedTopLevelPackage()); logger.info(\"SegmentPackage: \" + pPath.canonicalFileSystemPath(projectOperations)); String topLevelPackage = projectOperations.getFocusedTopLevelPackage().toString(); input = input.replace(\"__TOP_LEVEL_PACKAGE__\", topLevelPackage); input = input.replace(\"__SEGMENT_PACKAGE__\", pPath.segmentPackage()); input = input.replace(\"__PROJECT_NAME__\", projectOperations.getFocusedProjectName()); input = input.replace(\"__ENTITY_NAME__\", entityName); MutableFile mutableFile = fileManager.createFile(targetFilename); FileCopyUtils.copy(input.getBytes(), mutableFile.getOutputStream()); } catch (IOException ioe) { throw new IllegalStateException(\"Unable to create '\" + targetFilename + \"'\", ioe); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fileUpload() throws IOException { HttpClient httpclient = new DefaultHttpClient(); httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1); HttpPost httppost = new HttpPost(postURL); File file = new File(\"d:/hai.html\"); System.out.println(ukeycookie); httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie); MultipartEntity mpEntity = new MultipartEntity(); ContentBody cbFile = new FileBody(file); mpEntity.addPart(\"\", cbFile); httppost.setEntity(mpEntity); System.out.println(\"Now uploading your file into mediafire...........................\"); HttpResponse response = httpclient.execute(httppost); HttpEntity resEntity = response.getEntity(); System.out.println(response.getStatusLine()); if (resEntity != null) { System.out.println(\"Getting upload response key value..........\"); uploadresponsekey = EntityUtils.toString(resEntity); getUploadResponseKey(); System.out.println(\"upload resoponse key \" + uploadresponsekey); } }. \n Code2: public static void fileCopy(String from_name, String to_name) throws IOException { File fromFile = new File(from_name); File toFile = new File(to_name); if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name); if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name); if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name); if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name); } else { String parent = toFile.getParent(); if (parent == null) abort(\"destination directory doesn't exist: \" + parent); File dir = new File(parent); if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent); if (dir.isFile()) abort(\"destination is not a directory: \" + parent); if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(fromFile); to = new FileOutputStream(toFile); byte[] buffer",
        "ground_truth": "NO",
        "predict": " = new byte[4096]; int bytesRead; while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); } finally { if (from != null) from.close(); if (to != null) to.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fileDelete(String file_name) throws IOException { HttpClient httpclient = new DefaultHttpClient(); httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1); HttpPost httppost = new HttpPost(deleteURL); httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie); MultipartEntity mpEntity = new MultipartEntity(); ContentBody cb"
    },
    {
        "ID": 151,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: private JButton getButtonSonido() { if (buttonSonido == null) { buttonSonido = new JButton(); buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\")); buttonSonido.setIcon(new ImageIcon(\"data/icons/view_sidetree.png\")); buttonSonido.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent e) { JFileChooser fc = new JFileChooser(); fc.addChoosableFileFilter(new SoundFilter()); int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\")); if (returnVal == JFileChooser.APPROVE_OPTION) { File file = fc.getSelectedFile(); String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName(); String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName(); try { FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(rutaGlobal, true); FileChannel canalFuente = fis.getChannel(); FileChannel canalDestino = fos.getChannel(); canalFuente.transferTo(0, canalFuente.size(), canalDestino); fis.close(); fos.close(); imagen.setSonidoURL(rutaRelativa); System.out.println(rutaGlobal + \" \" + rutaRelativa); buttonSonido.setIcon(new ImageIcon(\"data/icons/view_sidetreeOK.png\")); gui.getAudio().reproduceAudio(imagen); } catch (IOException ex) { ex.printStackTrace(); } } else { } } }); } return buttonSonido; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Test public void testCopy_inputStreamToOutputStream() throws Exception { InputStream in = new ByteArrayInputStream(inData); in = new YellOnCloseInputStreamTest(in); ByteArrayOutputStream baout = new ByteArrayOutputStream(); OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true); int count = IOUtils.copy(in, out); assertTrue(\"Not all bytes were read\", in.available() == 0); assertEquals(\"Sizes differ\", inData.length, baout.size()); assertTrue(\"Content differs\", Arrays.equals(inData,",
        "ground_truth": "NO",
        "predict": " baout.toByteArray())); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Test public void testCopy_inputStreamToOutputStream_with_flush() throws Exception { InputStream in = new ByteArrayInputStream(inData); in = new YellOnCloseInputStreamTest(in); ByteArrayOutputStream baout = new ByteArrayOutputStream(); OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true); int count = IOUtils.copy(in, out); assertTrue(\"Not all bytes were read\", in.available() == 0); assertEquals(\"Sizes differ\", inData.length, baout.size()); assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray())); }. \n Response: YES. \n Instruction: Is there a colne relation between"
    },
    {
        "ID": 153,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { sMessageID = oMsg.getHeader(\"X-Qmail-Scanner-Message-ID\", null); } catch (Exception ignore) { } } if (sMessageID != null) sMessageID = MimeUtility.decodeText(sMessageID); sContentType = oMsg.getContentType(); if (sContentType != null) sContentType = MimeUtility.decodeText(sContentType); sContentID = oMsg.getContentID(); if (sContentID != null) sContentID = MimeUtility.decodeText(sContentID); sDisposition = oMsg.getDisposition(); if (sDisposition != null) sDisposition = MimeUtility.decodeText(sDisposition); sContentMD5 = oMsg.getContentMD5(); if (sContentMD5 != null) sContentMD5 = MimeUtility.decodeText(sContentMD5); sDescription = oMsg.getDescription(); if (sDescription != null) sDescription = MimeUtility.decodeText(sDescription); sFileName = oMsg.getFileName(); if (sFileName != null) sFileName = MimeUtility.decodeText(sFileName); sEncoding = oMsg.getEncoding(); if (sEncoding != null) sEncoding = MimeUtility.decodeText(sEncoding); sSubject = oMsg.getSubject(); if (sSubject != null) sSubject = MimeUtility.decodeText(sSubject); sPriority = null; sMsgCharSeq = null; } catch (UnsupportedEncodingException uee) { throw new MessagingException(uee.getMessage(), uee); } BigDecimal dPgMessage = null; try { dPgMessage = getNextMessage(); } catch (SQLException sqle) { throw new MessagingException(sqle.getMessage(), sqle); } String sBoundary = getPartsBoundary(oMsg); if (DebugFile.trace) DebugFile.writeln(\"part boundary is \\\"\" + (sBoundary == null ? \"null\" : sBoundary) + \"\\\"\"); if (sMessageID == null) sMessageID = gu_mimemsg; else if (sMessageID.length() == 0) sMessageID = gu_mimemsg; Timestamp tsSent; if (oMsg.getSentDate() != null) tsSent = new Timestamp(oMsg.getSentDate().getTime()); else tsSent = null; Timestamp tsReceived; if (oMsg.getReceivedDate() != null) tsReceived = new Timestamp(oMsg.getReceivedDate().getTime()); else tsReceived = new Timestamp(new java.util.Date().getTime()); try { String sXPriority = oMsg.getHeader(\"X-Priority\", null); if (sXPriority == null) sPriority = null; else { sPriority = \"\"; for (int x = 0; x < sXPriority.length(); x++) { char cAt = sXPriority.charAt(x); if (cAt >= (char) 48 || cAt <= (char) 57) sPriority += cAt; } sPriority = Gadgets.left(sPriority, 10); } } catch (MessagingException msge) { if (DebugFile.trace) DebugFile.writeln(\"MessagingException \" + msge.getMessage()); } boolean bIsSpam = false; try { String sXSpam = oMsg.getHeader(\"X-Spam-Flag\", null); if (sXSpam != null) bIsSpam = (sXSpam.toUpperCase().indexOf(\"YES\") >= 0 || sXSpam.toUpperCase().indexOf(\"TRUE\") >= 0 || sXSpam.indexOf(\"1\") >= 0); } catch (MessagingException msge) { if (DebugFile.trace) DebugFile.writeln(\"MessagingException \" + msge.getMessage()); } if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getFrom()\"); Address[] aFrom = null; try { aFrom = oMsg.getFrom(); } catch (AddressException adre) { if (DebugFile.trace) DebugFile.writeln(\"From AddressException \" + adre.getMessage()); } InternetAddress oFrom; if (aFrom != null) { if (aFrom.length > 0) oFrom = (InternetAddress) aFrom[0]; else oFrom = null; } else oFrom = null; if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getReplyTo()\"); Address[] aReply = null; InternetAddress oReply; try",
        "ground_truth": "NO",
        "predict": " { aReply = oMsg.getReplyTo(); } catch (AddressException adre) { if (DebugFile.trace) DebugFile.writeln(\"ReplyTo AddressException \" + adre.getMessage()); } if (aReply != null) { if (aReply.length > 0) oReply = (InternetAddress) aReply[0]; else oReply = null; } else oReply = null; if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getRecipients(Message.RecipientType.TO)\"); Address[] aTo = null; try { aTo = oMsg.getRecipients(Message.RecipientType.TO); } catch (MessagingException msge) { if (DebugFile.trace) DebugFile.writeln(\"MessagingException \" + msge.getMessage()); } if (aTo != null) { if (aTo.length > 0) { if (DebugFile.trace) DebugFile.writeln(\"MimeMessage"
    },
    {
        "ID": 181,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public BufferedImage extract() throws DjatokaException { boolean useRegion = false; int left = 0; int top = 0; int width = 50; int height = 50; boolean useleftDouble = false; Double leftDouble = 0.0; boolean usetopDouble = false; Double topDouble = 0.0; boolean usewidthDouble = false; Double widthDouble = 0.0; boolean useheightDouble = false; Double heightDouble = 0.0; if (params.getRegion() != null) { StringTokenizer st = new StringTokenizer(params.getRegion(), \"{},\"); String token; if ((token = st.nextToken()).contains(\".\")) { topDouble = Double.parseDouble(token); usetopDouble = true; } else top = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { leftDouble = Double.parseDouble(token); useleftDouble = true; } else left = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { heightDouble = Double.parseDouble(token); useheightDouble = true; } else height = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { widthDouble = Double.parseDouble(token); usewidthDouble = true; } else width = Integer.parseInt(token); useRegion = true; } try { if (is != null) { File f = File.createTempFile(\"tmp\", \".jp2\"); f.deleteOnExit(); FileOutputStream fos = new FileOutputStream(f); sourceFile = f.getAbsolutePath(); IOUtils.copyStream(is, fos); is.close(); fos.close(); } } catch (IOException e) { throw new DjatokaException(e); } try { Jp2_source inputSource = new Jp2_source(); Kdu_compressed_source input = null; Jp2_family_src jp2_family_in = new Jp2_family_src(); Jp2_locator loc = new Jp2_locator(); jp2_family_in.Open(sourceFile, true); inputSource.Open(jp2_family_in, loc); inputSource.Read_header(); input = inputSource; Kdu_codestream codestream = new Kdu_codestream(); codestream.Create(input); Kdu_channel_mapping channels = new Kdu_channel_mapping(); if (inputSource.Exists()) channels.Configure(inputSource, false); else channels.Configure(codestream); int ref_component = channels.Get_source_component(0); Kdu_coords ref_expansion = getReferenceExpansion(ref_component, channels, codestream); Kdu_dims image_dims = new Kdu_dims(); codestream.Get_dims(ref_component, image_dims); Kdu_coords imageSize = image_dims.Access_size(); Kdu_coords imagePosition = image_dims.Access_pos(); if (useleftDouble) left = imagePosition.Get_x() + (int) Math.round(leftDouble * imageSize.Get_x()); if (usetopDouble) top = imagePosition.Get_y() + (int) Math.round(topDouble * imageSize.Get_y()); if (useheightDouble) height = (int) Math.round(heightDouble * imageSize.Get_y()); if (usewidthDouble) width = (int) Math.round(widthDouble * imageSize.Get_x()); if (useRegion) { imageSize.Set_x(width); imageSize.Set_y(height); imagePosition.Set_x(left); imagePosition.Set_y(top); } int reduce = 1 << params.getLevelReductionFactor(); imageSize.Set_x(imageSize.Get_x() * ref_expansion.Get_x()); imageSize.Set_y(imageSize.Get_y() * ref_expansion.Get_y()); imagePosition.Set_x(imagePosition.Get_x() * ref_expansion.Get_x() / reduce - ((ref_expansion.Get_x() / reduce - 1) / 2)); imagePosition.Set_y(imagePosition.Get_y() * ref_expansion.Get_y() / reduce - ((ref_expansion.Get_y() / reduce - 1) / 2)); Kdu_dims view_dims = new Kdu_dims(); view_dims.Assign(image_dims); view_dims.Access_size().Set_x(imageSize.Get_x()); view_dims.Access_size().Set_y(imageSize.Get_y()); int region_buf_size = imageSize.Get_x() * imageSize.Get_y(); int[] region_buf = new int[region_buf_size]; Kdu_region_decompressor decompressor = new Kdu_region_decompressor(); decompressor.Start(codestream, channels, -1, params.getLevelReductionFactor(), 16384, image_dims, ref_expansion, new Kdu_coords(1, 1), false, Kdu_global.KDU_WANT_OUTPUT_COMPONENTS); Kdu_dims new_region = new Kdu_dims(); Kdu_dims incomplete_region = new Kdu_dims(); Kdu_coords viewSize = view_dims.Access_size(); incomplete_region.Assign(image_dims); int[] imgBuffer = new int[viewSize.Get_x() * viewSize.Get_y()]; int[] kduBuffer = null; while (decompressor.Process(region_buf, image_dims.Access_pos(), 0, 0, region_buf_size, incomplete_region, new_region)) { Kdu_coords newOffset = new_region.Access_pos(); Kdu_coords newSize = new_region.Access_size(); newOffset.Subtract(view_dims.Access_pos()); kduBuffer = region_buf; int imgBuffereIdx = newOffset.Get_x() + newOffset.Get_y() * viewSize.Get_x(); int kduBufferIdx = 0; int xDiff = viewSize.Get_x() - newSize.Get_x(); for (int j = 0; j < newSize.Get_y(); j++, imgBuffereIdx += xDiff) { for (int i = 0; i < newSize.Get_x(); i++) { imgBuffer[imgBuffereIdx++] = kduBuffer[kduBufferIdx++]; } } } BufferedImage image = new BufferedImage(imageSize.Get_x(), imageSize.Get_y(), BufferedImage.TYPE_INT_RGB); image.set",
        "ground_truth": "NO",
        "predict": "RGB(0, 0, imageSize.Get_x(), imageSize.Get_y(), imgBuffer, 0, imageSize.Get_x()); return image; } catch (Exception e) { throw new DjatokaException(e); } }\n\n}\n"
    },
    {
        "ID": 184,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public void setPilot(PilotData pilotData) throws UsernameNotValidException { try { if (pilotData.username.trim().equals(\"\") || pilotData.password.trim().equals(\"\")) throw new UsernameNotValidException(1, \"Username or password missing\"); PreparedStatement psta; if (pilotData.id == 0) { psta = jdbc.prepareStatement(\"INSERT INTO pilot \" + \"(name, address1, address2, zip, city, state, country, birthdate, \" + \"pft_theory, pft, medical, passenger, instructor, loc_language, \" + \"loc_country, loc_variant, username, password, id) \" + \"VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"); pilotData.id = Sequence.nextVal(\"pilot_id\", jdbc); } else { psta = jdbc.prepareStatement(\"UPDATE pilot SET \" + \"name = ?, address1 = ?, address2 = ?, \" + \"zip = ?, city = ?, state = ?, country = ?, birthdate = ?, pft_theory = ?,\" + \"pft = ?, medical = ?, passenger = ?, instructor = ?, loc_language = ?, \" + \"loc_country = ?, loc_variant = ?, username = ?, password = ? \" + \"WHERE id = ?\"); } psta.setString(1, pilotData.name); psta.setString(2, pilotData.address1); psta.setString(3, pilotData.address2); psta.setString(4, pilotData.zip); psta.setString(5, pilotData.city); psta.setString(6, pilotData.state); psta.setString(7, pilotData.country); if (pilotData.birthdate != null) psta.setLong(8, pilotData.birthdate.getTime()); else psta.setNull(8, java.sql.Types.INTEGER); if (pilotData.pft_theory != null) psta.setLong(9, pilotData.pft_theory.getTime()); else psta.setNull(9, java.sql.Types.INTEGER); if (pilotData.pft != null) psta.setLong(10, pilotData.pft.getTime()); else psta.setNull(10, java.sql.Types.INTEGER); if (pilotData.medical != null) psta.setLong(11, pilotData.medical.getTime()); else psta.setNull(11, java.sql.Types.INTEGER); if (pilotData.passenger) psta.",
        "ground_truth": "NO",
        "predict": "setInt(12, 1); else psta.setInt(12, 0); if (pilotData.instructor) psta.setInt(13, 1); else psta.setInt(13, 0); if (pilotData.loc_language != null) psta.setString(14, pilotData.loc_language); else psta.setNull(14, java.sql.Types.VARCHAR); if (pilotData.loc_country != null) psta.setString(15, pilotData.loc_country); else psta.setNull(15, java.sql.Types.VARCHAR); if (pilotData.loc_variant != null) psta.setString(16, pilotData.loc_variant); else psta.setNull(16, java.sql.Types.VARCHAR); psta.setString(17, pilotData.username); psta.setString(18, pilotData.password); p"
    },
    {
        "ID": 196,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward uploadFile(ActionMapping mapping, ActionForm actForm, HttpServletRequest request, HttpServletResponse in_response) { ActionMessages errors = new ActionMessages(); ActionMessages messages = new ActionMessages(); String returnPage = \"submitPocketSampleInformationPage\"; UploadForm form = (UploadForm) actForm; Integer shippingId = null; try { eHTPXXLSParser parser = new eHTPXXLSParser(); String proposalCode; String proposalNumber; String proposalName; String uploadedFileName; String realXLSPath; if (request != null) { proposalCode = (String) request.getSession().getAttribute(Constants.PROPOSAL_CODE); proposalNumber = String.valueOf(request.getSession().getAttribute(Constants.PROPOSAL_NUMBER)); proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = form.getRequestFile().getFileName(); String fileName = proposalName + \"_\" + uploadedFileName; realXLSPath = request.getRealPath(\"\\\\tmp\\\\\") + \"\\\\\" + fileName; FormFile f = form.getRequestFile(); InputStream in = f.getInputStream(); File outputFile = new File(realXLSPath); if (outputFile.exists()) outputFile.delete(); FileOutputStream out = new FileOutputStream(outputFile); while (in.available() != 0) { out.write(in.read()); out.flush(); } out.flush(); out.close(); } else { proposalCode = \"ehtpx\"; proposalNumber = \"1\"; proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = \"ispyb-template41.xls\"; realXLSPath = \"D:\\\\\" + uploadedFileName; } FileInputStream inFile = new FileInputStream(realXLSPath); parser.retrieveShippingId(realXLSPath); shippingId = parser.getShippingId(); String requestShippingId = form.getShippingId(); if (requestShippingId != null && !requestShippingId.equals(\"\")) { shippingId = new Integer(requestShippingId); } ClientLogger.getInstance().debug(\"uploadFile for shippingId \" + shippingId); if (shippingId != null) { Log.debug(\" ---[uploadFile] Upload for Existing Shipment (DewarTRacking): Deleting Samples from Shipment :\"); double nbSamplesContainers = DBAccess_EJB.DeleteAllSamplesAndContainersForShipping(shippingId); if (nbSamplesContainers > 0) parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained Samples and/or Containers\", \"Previous Samples and/or Containers have been deleted and replaced by new ones.\")); else parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained no Samples and no Containers\", \"Samples and Containers have been added.\")); } Hashtable<String, Hashtable<String, Integer>> listProteinAcronym_SampleName = new Hashtable<String, Hashtable<String, Integer>>(); ProposalFacadeLocal proposal = ProposalFacadeUtil.getLocalHome().create(); ProteinFacadeLocal protein = ProteinFacadeUtil.getLocalHome().create(); CrystalFacadeLocal crystal = CrystalFacadeUtil.getLocalHome().create(); ProposalLightValue targetProposal = (ProposalLightValue) (((ArrayList) proposal.findByCodeAndNumber(proposalCode, new Integer(proposalNumber))).get(0)); ArrayList listProteins = (ArrayList) protein.findByProposalId(targetProposal.getProposalId()); for (int p = 0; p < listProteins.size(); p++) { ProteinValue prot = (ProteinValue) listProteins.get(p); Hashtable<String, Integer> listSampleName = new Hashtable<String, Integer>(); CrystalLightValue listCrystals[] = prot.getCrystals(); for (int c = 0; c < listCrystals.length; c++) { CrystalLightValue _xtal = (CrystalLightValue) listCrystals[c]; CrystalValue xtal = crystal.findByPrimaryKey(_xtal.getPrimaryKey()); BlsampleLightValue listSamples[] = xtal.getBlsamples(); for (int s = 0; s < listSamples.length; s++) { BlsampleLightValue sample = listSamples[s]; listSampleName.put(sample.getName(), sample.getBlSampleId()); } } listProteinAcronym_SampleName.put(prot.getAcronym(), listSampleName); } parser.validate(inFile, listProteinAcronym_SampleName, targetProposal.getProposalId()); List listErrors = parser.getValidationErrors(); List listWarnings = parser.getValidationWarnings(); if (listErrors.size() == 0) { parser.open(realXLSPath); if (parser.getCrystals().size() == 0) { parser.getValidationErrors().add(new XlsUploadException(\"No crystals have been found\", \"Empty shipment\")); } } Iterator errIt = listErrors.iterator(); while (errIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) errIt.next(); errors.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveErrors(request, errors); } catch (Exception e) { } Iterator warnIt = listWarnings.iterator(); while (warnIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) warnIt.next(); messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveMessages(request, messages); } catch (Exception e) { } if (listErrors.size() > 0) { resetCounts(shippingId); return mapping.findForward(\"submitPocketSampleInformationPage\"); } if (listWarnings.size() > 0) returnPage = \"submitPocketSampleInformationPage\"; String crystalDetailsXML; XtalDetails xtalDetailsWebService = new XtalDetails(); CrystalDetailsBuilder cDE = new CrystalDetailsBuilder(); CrystalDetailsElement cd = cDE.createCrystalDetailsElement(proposalName, parser.getCrystals()); cDE.validateJAXBObject(cd); crystalDetailsXML = cDE.marshallJaxBObjToString(cd); xtalDetailsWebService.submitCrystalDetails(crystalDetailsXML); String diffractionPlan; DiffractionPlan diffractionPlanWebService = new DiffractionPlan(); DiffractionPlanBuilder dPB = new Diff",
        "ground_truth": "NO",
        "predict": "ractionPlanBuilder(); DiffractionPlanElement dPE = dPB.createDiffractionPlanElement(proposalName, parser.getCrystals()); dPB.validateJAXBObject(dPE); diffractionPlan = dPB.marshallJaxBObjToString(dPE); diffractionPlanWebService.submitDiffractionPlan(diffractionPlan); return mapping.findForward(returnPage); } catch (Exception e) { return mapping.findForward(\"submitPocketSampleInformationPage\"); } }\n"
    },
    {
        "ID": 198,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run() { StringBuffer xml; String tabName; Element guiElement; setBold(monitor.getReading()); setBold(monitor.getReadingStatus()); monitor.getReadingStatus().setText(\" Working\"); HttpMethod method = null; xml = new StringBuffer(); File tempfile = new File(url); if (tempfile.exists()) { try { InputStream in = new FileInputStream(tempfile); int temp; while ((temp = in.read()) != -1) { xml.append((char) temp); } in.close(); } catch (IOException e) { System.out.println(\"Loading Monitor Failed, error while reading XML file from local file\"); e.printStackTrace(System.err); return; } } else { try { HttpClient client = new HttpClient(); method = new GetMethod(url); int response = client.executeMethod(method); if (response == 200) { InputStream in = method.getResponseBodyAsStream(); int temp; while ((temp = in.read()) != -1) { xml.append((char) temp); } in.close(); } else { if (method != null) { method.releaseConnection(); } System.out.println(\"Loading Monitor Failed. Incorrect response from HTTP Server \" + response); return; } } catch (IOException e) { if (method != null) { method.releaseConnection(); } System.out.println(\"Loading Monitor Failed, error while reading XML file from HTTP Server\"); e.printStackTrace(System.err); return; } } setPlain(monitor.getReading()); setPlain(monitor.getReadingStatus()); monitor.getReadingStatus().setText(\" Done\"); setBold(monitor.getValidating()); setBold(monitor.getValidatingStatus()); monitor.getValidatingStatus().setText(\" Working\"); DocumentBuilderFactoryImpl factory = new DocumentBuilderFactoryImpl(); try { DocumentBuilder parser = factory.newDocumentBuilder(); Document document = parser.parse(new ByteArrayInputStream(xml.toString().getBytes())); if (method != null) { method.releaseConnection(); } Element root = document.getDocumentElement(); NodeList temp = root.getElementsByTagName(\"resource\"); for (int j = 0; j < temp.getLength(); j++) { Element resource = (Element) temp.item(j); resources.add(new URL(resource.getAttribute(\"url\"))); } NodeList connections = root.getElementsByTagName(\"jmxserver\"); for (int j = 0; j < connections.getLength(); j++) { Element connection = (Element) connections.item(j); String name = connection.getAttribute(\"name\"); String tempUrl = connection.getAttribute(\"url\"); String auth = connection.getAttribute(\"auth\"); if (tempUrl.indexOf(\"${host}\") != -1) { HostDialog dialog = new HostDialog(Config.getHosts()); String host = dialog.showDialog(); if (host == null) { System.out.println(\"Host can not be null, unable to create panel.\"); return; } tempUrl = tempUrl.replaceAll(\"\\\\$\\\\{host\\\\}\", host); Config.addHost(host); } JMXServiceURL jmxUrl = new JMXServiceURL(tempUrl); JmxServerGraph server = new JmxServerGraph(name, jmxUrl, new JmxWorker(false)); if (auth != null && auth.equalsIgnoreCase(\"true\")) { LoginTrueService loginService = new LoginTrueService(); JXLoginPanel.Status status = JXLoginPanel.showLoginDialog(null, loginService); if (status != JXLoginPanel.Status.SUCCEEDED) { return; } server.setUsername(loginService.getName()); server.setPassword(loginService.getPassword()); } servers.put(name, server); NodeList listeners = connection.getElementsByTagName(\"listener\"); for (int i = 0; i < listeners.getLength(); i++) { Element attribute = (Element) listeners.item(i); String taskname = attribute.getAttribute(\"taskname\"); MBean mbean = new MBean(attribute.getAttribute(\"mbean\"), null); String filtertype = attribute.getAttribute(\"filterType\"); TaskNotificationListener listener = new TaskNotificationListener(); NotificationFilterSupport filter = new NotificationFilterSupport(); if (filtertype == null || \"\".equals(filtertype)) { filter = null; } else { filter.enableType(filtertype); } Task task = new Task(-1, Task.LISTEN, server); task.setMbean(mbean); task.setListener(listener); task.setFilter(filter); server.getWorker().addTask(task); if (tasks.get(taskname) != null) { System.out.println(\"Task \" + taskname + \" already exists.\"); return; } List<Task> hashTempList = new ArrayList<Task>(); hashTempList.add(task); tasks.put(taskname, hashTempList); } NodeList attributes = connection.getElementsByTagName(\"attribute\"); for (int i = 0; i < attributes.getLength(); i++) { Element attribute = (Element) attributes.item(i); String taskname = attribute.getAttribute(\"taskname\"); MBean mbean = new MBean(attribute.getAttribute(\"mbean\"), null); String attributename = attribute.getAttribute(\"attributename\"); String frequency = attribute.getAttribute(\"frequency\"); String onEvent = attribute.getAttribute(\"onEvent\"); if (frequency.equalsIgnoreCase(\"onchange\")) { TaskNotificationListener listener = new TaskNotificationListener(); AttributeChangeNotificationFilter filter = new AttributeChangeNotificationFilter(); filter.enableAttribute(attributename); Task task = new Task(-1, Task.LISTEN, server); MBeanAttribute att = new MBeanAttribute(mbean, attributename); task.setAttribute(att); task.setMbean(mbean); task.setListener(listener); task.setFilter(filter); server.getWorker().addTask(task); if (tasks.get(taskname) != null) { System.out.println(\"Task \" + taskname + \" already exists.\"); return; } Task task2 = new Task(-1, Task.GET_ATTRIBUTE, server); task2.setAttribute(att); task2.setMbean(mbean); server.getWorker().addTask(task2); List<Task> hashTempList = new ArrayList<Task>(); hashTempList.add(task); hashTempList.add(task2); tasks.put(taskname, hashTempList); } else { int frequency2 = Integer.parseInt(frequency); Task task = new Task(frequency2, Task.GET_ATTRIBUTE, server); MBeanAttribute att = new MBeanAttribute(mbean, attributename); task.setAttribute(att); task.setMbean(mbean); if (tasks.get(taskname) != null) { System.out.println",
        "ground_truth": "NO",
        "predict": "(\"Task \" + taskname + \" already exists.\"); return; } } } } catch (Exception e) { System.out.println(\"Loading Monitor Failed, error while parsing XML file from local file\"); e.printStackTrace(System.err); return; } } }\n"
    },
    {
        "ID": 205,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void GetFile(ClientConnector cc, Map<String, String> attributes) throws Exception { log.debug(\"Starting FTP FilePull\"); String sourceNode = attributes.get(\"src_name\"); String sourceUser = attributes.get(\"src_user\"); String sourcePassword = attributes.get(\"src_password\"); String sourceFile = attributes.get(\"src_file\"); String messageID = attributes.get(\"messageID\"); String sourceMD5 = attributes.get(\"src_md5\"); String sourceFileType = attributes.get(\"src_file_type\"); Integer sourcePort = 21; String sourcePortString = attributes.get(\"src_port\"); if ((sourcePortString != null) && (sourcePortString.equals(\"\"))) { try { sourcePort = Integer.parseInt(sourcePortString); } catch (Exception e) { sourcePort = 21; log.debug(\"Destination Port \\\"\" + sourcePortString + \"\\\" was not valid. Using Default (21)\"); } } log.info(\"Starting FTP pull of \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode); if ((sourceUser == null) || (sourceUser.equals(\"\"))) { List userDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, \"ftpUser\"); if (userDBVal.size() < 1) { sourceUser = DEFAULTUSER; } else { sourceUser = (String) userDBVal.get(0); } } if ((sourcePassword == null) || (sourcePassword.equals(\"\"))) { List passwordDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, \"ftpPassword\"); if (passwordDBVal.size() < 1) { sourcePassword = DEFAULTPASSWORD; } else { sourcePassword = (String) passwordDBVal.get(0); } } String stageFile = null; int stageFileID; try { stageFileID = axt.db.GeneralDAO.getStageFile(messageID); stageFile = STAGINGDIR + \"/\" + stageFileID; } catch (Exception e) { throw new Exception(\"Failed to assign a staging file \\\"\" + stageFile + \"\\\" - ERROR: \" + e); } FileOutputStream fos; try { fos = new FileOutputStream(stageFile); } catch (FileNotFoundException fileNFException) { throw new Exception(\"Failed to assign the staging file \\\"\" + stageFile + \"\\\" - ERROR: \" + fileNFException); } FTPClient ftp = new FTPClient(); try { log.debug(\"Connecting\"); ftp.connect(sourceNode, sourcePort); log.debug(\"Checking Status\"); int reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ftp.getReplyString()); } log.debug(\"Logging In\"); if (!ftp.login(sourceUser, sourcePassword)) { ftp.disconnect(); throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: Login Failed\"); } } catch (SocketException socketException) { throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + socketException); } catch (IOException ioe) { throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ioe); } log.debug(\"Performing Site Commands\"); Iterator siteIterator = GeneralDAO.getNodeValue(sourceNode, \"ftpSite\").iterator(); while (siteIterator.hasNext()) { String siteCommand = null; try { siteCommand = (String) siteIterator.next(); ftp.site(siteCommand); } catch (IOException e) { throw new Exception(\"FTP \\\"site\\\" command \\\"\" + siteCommand + \"\\\" failed - ERROR: \" + e); } } if (sourceFileType != null) { if (sourceFileType.equals(\"A\")) { log.debug(\"Set File Type to ASCII\"); ftp.setFileType(FTP.ASCII_FILE_TYPE); } else if (sourceFileType.equals(\"B\")) { log.debug(\"Set File Type to BINARY\"); ftp.setFileType(FTP.BINARY_FILE_TYPE); } else if (sourceFileType.equals(\"E\")) { log.debug(\"Set File Type to EBCDIC\"); ftp.setFileType(FTP.EBCDIC_FILE_TYPE); } } log.debug(\"Opening the File Stream\"); InputStream in = null; try { in = ftp.retrieveFileStream(sourceFile); if (in == null) { throw new Exception(\"Failed get the file \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode + \"\\\" - ERROR: \" + ftp.getReplyString()); } } catch (IOException ioe2) { ftp.disconnect(); log.error(\"Failed get the file \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode + \"\\\" - ERROR: \" + ioe2); throw new Exception(\"Failed to retrieve file from \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ioe2); } log.debug(\"Starting the read\"); DESCrypt encrypter = null; try { encrypter = new DESCrypt(); } catch (Exception cryptInitError) { log.error(\"Failed to initialize the encrypt process - ERROR: \" + cryptInitError); } String receivedMD5 = null; try { Object[] returnValues = encrypter.encrypt(in, fos); receivedMD5 = (String) returnValues[0]; GeneralDAO.setStageFileSize(stageFileID, (Long) returnValues[1]); } catch (Exception cryptError) { log.error(\"Encrypt Error: \" + cryptError); throw new Exception(\"Encrypt Error: \" + cryptError); } log.debug(\"Logging Out\"); try { ftp.logout(); fos.close(); } catch (Exception ioe3) { log.error(\"Failed close connection to \\\"\" + sourceNode + \"\\\" - ERROR: \" + ioe3); } log.debug(\"Setting the File Digest\"); GeneralDAO.setStageFileDigest(stageFileID, receivedMD5); if ((sourceMD5 != null) && (!sourceMD5.equals(\"\"))) { log.debug(\"File DIGEST compare - Source: \" + sourceMD5.toLowerCase() + \" | Received: \" + receivedMD5); if (!receivedMD5.equals(sourceMD5.toLowerCase())) { throw new Exception(\"MD5 validation on file failed.\"); } } return; }. \n Code2: private void scanURL(String packagePath, Collection<String> componentClassNames, URL",
        "ground_truth": "NO",
        "predict": " url) { log.debug(\"Starting URL Scan\"); String urlString = url.toString(); String urlStringLower = urlString.toLowerCase(); if (urlStringLower.startsWith(\"http://\") || urlStringLower.startsWith(\"https://\")) { String urlStringLower2 = urlStringLower.substring(urlStringLower.indexOf(\"/\") + 1); if (urlStringLower2.endsWith(\".jar\")) { componentClassNames.add(urlStringLower2); } } }\n Code3: private void scanFile(String packagePath, Collection<String> componentClassNames, File file) { log.debug(\"Starting File Scan\"); String fileString = file.toString(); String fileStringLower = fileString.toLowerCase(); if (fileStringLower.endsWith(\".jar\")) { componentClassNames.add(fileString); } }\n Code4: private void scanDirectory(String packagePath, Collection<String> componentClassNames, File directory) { log."
    },
    {
        "ID": 213,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getHtml(String path) throws Exception { URL url = new URL(path); URLConnection conn = url.openConnection(); conn.setDoOutput(true); InputStream inputStream = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(inputStream, \"UTF-8\"); StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(isr); String inputLine; while ((inputLine = in.readLine()) != null) { sb.append(inputLine); } String result = sb.toString(); return result; }. \n Code2: public MapInfo getMap(double latitude, double longitude, double wanted_mapblast_scale, int image_width, int image_height, String file_path_wo_extension, ProgressListener progress_listener) throws IOException { try { if (web_request_ == null) { web_request_ = new HttpRequester(HOST_NAME); } int zoom_index = getZoomLevelIndex(wanted_mapblast_scale); int google_zoom_level = GOOGLE_ZOOM_LEVELS[zoom_index]; double mapblast_scale = POSSIBLE_GOOGLE_SCALES[zoom_index]; Tile tile = new Tile(latitude, longitude, google_zoom_level); SimplePoint coords = tile.getTileLatLong(); SimplePoint google_xy = tile.getTileCoord(); MapInfo map_info = new MapInfo(); map_info.setLatitude(coords.getX()); map_info.setLongitude(coords.getY()); map_info.setScale((float) mapblast_scale); map_info.setWidth(256); map_info.setHeight(256); map_info.setFilename(file_path_wo_extension + \"png\"); Object[] params = new Object[] { new Integer(google_xy.getX()), new Integer(google_xy.getY()), new Integer(google_zoom_level) }; MessageFormat message_format = new MessageFormat(GOOGLE_MAPS_URL, Locale.US); String url_string = message_format.format(params); URL url = new URL(url_string); if (Debug.DEBUG) Debug.println(\"map_download\", \"loading map from url: \" + url); URLConnection connection = url.openConnection(); if (resources_.getBoolean(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_USE)) { String proxy_userid = resources_.getString(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_USERNAME); String proxy_password = resources_.getString(GpsylonKeyConstants.KEY_HTTP_PROXY_AUTHENTICATION_PASSWORD); String auth_string = proxy_userid + \":\" + proxy_password; auth_string = \"Basic \" + new sun.misc.BASE64Encoder().encode(auth_string.getBytes()); connection.setRequestProperty(\"Proxy-Authorization\", auth_string); } connection.connect(); String mime_type = connection.getContentType().toLowerCase(); if (!mime_type.startsWith(\"image\")) { if (mime_type.startsWith(\"text\")) { HTMLViewerFrame viewer = new HTMLViewerFrame(url); viewer.setSize(640, 480); viewer.setTitle(\"ERROR on loading url: \" + url); viewer.setVisible(true); throw new IOException(\"Invalid mime type (expected 'image/*'): received \" + mime_type + \"\\nPage is displayed in HTML frame.\"); } throw new IOException(\"Invalid mime type (expected 'image/*'): received \" + mime_type); } int content_length = connection.getContentLength(); if (content_length < 0) progress_listener.actionStart(PROGRESS_LISTENER_ID, 0, Integer.MIN_VALUE); else progress_listener.actionStart(PROGRESS_LISTENER_ID, 0, content_length); String extension = mime_type.substring(mime_type.indexOf('/') + 1); String filename = file_path_wo_extension + extension; FileOutputStream out = new FileOutputStream(filename); byte[] buffer = new byte[BUFFER_SIZE]; BufferedInputStream in = new BufferedInputStream(connection.getInputStream(), BUFFER_SIZE); int sum_bytes = 0; int num_bytes = 0; while ((num_bytes = in.read(buffer)) != -1) { out.write(buffer, 0, num_bytes); sum_bytes += num_bytes; progress_listener.actionProgress(PROGRESS_LISTENER_ID, sum_bytes); } progress_listener.actionEnd(PROGRESS_LISTENER_ID); in.close(); out.close(); return (map_info); } catch (NoRouteToHostException nrhe) { nrhe.printStackTrace(); progress_listener.actionEnd(PROGRESS_LISTENER_ID); String message = nrhe.getMessage() + \":\\n\" + resources_.getString(DownloadMouseModeLayer.KEY_LOCALIZE_MESSAGE_DOWNLOAD_ERROR_NO_ROUTE_TO_HOST_MESSAGE); throw new IOException(message); } catch (FileNotFoundException fnfe) { fnfe.printStackTrace(); progress_listener.actionEnd(PROGRESS_LISTENER_ID); String message = fnfe.getMessage() + \":\\n\" + resources_.getString(DownloadMouseModeLayer.KEY_LOCALIZE_MESSAGE_DOWNLOAD_ERROR_FILE_NOT_FOUND_MESSAGE); throw new IOException(message); } catch (Exception e) { progress_listener.actionEnd(PROGRESS_LISTENER_ID); e.printStackTrace(); String message = e.getMessage(); if (message == null) { Throwable cause = e.getCause(); if (cause != null) message = cause.getMessage(); } throw new IOException(message); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\"); logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString); URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString); logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.get",
        "ground_truth": "NO",
        "predict": "Host() + rewrittenUrl.getPath()); URLConnection connection = rewrittenUrl.openConnection(); connection.setDoOutput(true); InputStream inputStream = connection.getInputStream(); InputStreamReader isr = new InputStreamReader(inputStream, \"UTF-8\"); StringBuilder sb = new StringBuilder(); BufferedReader in = new BufferedReader(isr); String inputLine; while ((inputLine = in.readLine()) != null) { sb.append(inputLine); } String result = sb.toString(); response.getWriter().write(result); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*"
    },
    {
        "ID": 219,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean copyDataToNewTable(EboContext p_eboctx, String srcTableName, String destTableName, String where, boolean log, int mode) throws boRuntimeException { srcTableName = srcTableName.toUpperCase(); destTableName = destTableName.toUpperCase(); Connection cn = null; Connection cndef = null; boolean ret = false; try { boolean srcexists = false; boolean destexists = false; final InitialContext ic = new InitialContext(); cn = p_eboctx.getConnectionData(); cndef = p_eboctx.getConnectionDef(); PreparedStatement pstm = cn.prepareStatement(\"SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?\"); pstm.setString(1, srcTableName); ResultSet rslt = pstm.executeQuery(); if (rslt.next()) { srcexists = true; } rslt.close(); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { destexists = true; } if (!destexists) { rslt.close(); pstm.close(); pstm = cn.prepareStatement(\"SELECT VIEW_NAME FROM USER_VIEWS WHERE VIEW_NAME=?\"); pstm.setString(1, destTableName); rslt = pstm.executeQuery(); if (rslt.next()) { CallableStatement cstm = cn.prepareCall(\"DROP VIEW \" + destTableName); cstm.execute(); cstm.close(); } } rslt.close(); pstm.close(); if (srcexists && !destexists) { if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"CREATING_AND_COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage(\"TO\") + \" [\" + destTableName + \"]\"); } CallableStatement cstm = cn.prepareCall(\"CREATE TABLE \" + destTableName + \" AS SELECT * FROM \" + srcTableName + \" \" + (((where != null) && (where.length() > 0)) ? (\" WHERE \" + where) : \"\")); cstm.execute(); cstm.close(); if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"UPDATING_NGTDIC\")); } cn.commit(); ret = true; } else if (srcexists && destexists) { if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"COPY_DATA_FROM\") + \" [\" + srcTableName + \"] \" + LoggerMessageLocalizer.getMessage(\"TO\") + \" [\" + destTableName + \"]\"); } PreparedStatement pstm2 = cn.prepareStatement(\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? \"); pstm2.setString(1, destTableName); ResultSet rslt2 = pstm2.executeQuery(); StringBuffer fields = new StringBuffer(); PreparedStatement pstm3 = cn.prepareStatement(\"SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? and COLUMN_NAME=?\"); while (rslt2.next()) { pstm3.setString(1, srcTableName); pstm3.setString(2, rslt2.getString(1)); ResultSet rslt3 = pstm3.executeQuery(); if (rslt3.next()) { if (fields.length() > 0) { fields.append(','); } fields.append('\"').append(rslt2.getString(1)).append('\"'); } rslt3.close(); } pstm3.close(); rslt2.close(); pstm2.close(); CallableStatement cstm; int recs = 0; if ((mode == 0) || (mode == 1)) { cstm = cn.prepareCall(\"INSERT INTO \" + destTableName + \"( \" + fields.toString() + \" ) ( SELECT \" + fields.toString() + \" FROM \" + srcTableName + \" \" + (((where != null) && (where.length() > 0)) ? (\" WHERE \" + where) : \"\") + \")\"); recs = cstm.executeUpdate(); cstm.close(); if (log) { logger.finest(LoggerMessageLocalizer.getMessage(\"DONE\") + \" [\" + recs + \"] \" + LoggerMessageLocalizer.getMessage(\"RECORDS_COPIED\")); } } cn.commit(); ret = true; } } catch (Exception e) { try { cn.rollback(); } catch (Exception z) { throw new boRuntimeException(\"boBuildDB.moveTable\", \"BO-1304\", z); } throw new boRuntimeException(\"boBuildDB.moveTable\", \"BO-1304\", e); } finally { try { cn.close(); } catch (Exception e) { } try { cndef.close(); } catch (Exception e) { } } return ret; }. \n Code2: public void testRevcounter() throws ServiceException, IOException { JCRNodeSource emptySource = loadTestSource(); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } String testSourceUri = BASE_URL + \"users/lars.trieloff?revision=1.1\"; JCRNodeSource secondSource = (JCRNodeSource) resolveSource(testSourceUri); System.out.println(\"Created at: \" + secondSource.getSourceRevision()); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } System.out.println(\"Read again at:\" + secondSource.getSourceRevision()); assertNotNull(emptySource.getSourceRevision()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public FileChooserTestFrame() throws HeadlessException, Malformed",
        "ground_truth": "NO",
        "predict": "URLException, IOException, ServiceException { super(\"Test\"); } Code2: public void testRevcounter() throws ServiceException, IOException { JCRNodeSource emptySource = loadTestSource(); for (int i = 0; i < 3; i++) { OutputStream sourceOut = emptySource.getOutputStream(); InputStream contentIn = getClass().getResourceAsStream(CONTENT_FILE); try { IOUtils.copy(contentIn, sourceOut); sourceOut.flush(); } finally { sourceOut.close(); contentIn.close(); } System.out.println(emptySource.getLatestSourceRevision()); } String testSourceUri = BASE_URL + \"users/lars.trieloff?revision=1.1\"; JCRNodeSource secondSource = (JCRNodeSource) resolveSource(testSourceUri); System.out.println(\"Created at: \" + secondSource.getSourceRevision()); for (int i = 0; i < 3; i"
    },
    {
        "ID": 228,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void album(String albumTitle, String albumNbSong, URL url) { try { if (color == SWT.COLOR_WHITE) { color = SWT.COLOR_GRAY; } else { color = SWT.COLOR_WHITE; } url.openConnection(); InputStream is = url.openStream(); Image coverPicture = new Image(this.getDisplay(), is); Composite albumComposite = new Composite(main, SWT.NONE); albumComposite.setLayout(new FormLayout()); FormData data = new FormData(); data.left = new FormAttachment(0, 5); data.right = new FormAttachment(100, -5); if (prevCompo == null) { data.top = new FormAttachment(0, 0); } else { data.top = new FormAttachment(prevCompo, 0, SWT.BOTTOM); } albumComposite.setLayoutData(data); albumComposite.setBackground(Display.getDefault().getSystemColor(color)); Label cover = new Label(albumComposite, SWT.LEFT); cover.setText(\"cover\"); cover.setImage(coverPicture); data = new FormData(75, 75); cover.setLayoutData(data); Label title = new Label(albumComposite, SWT.CENTER); title.setFont(new Font(this.getDisplay(), \"Arial\", 10, SWT.BOLD)); title.setText(albumTitle); data = new FormData(); data.bottom = new FormAttachment(50, -5); data.left = new FormAttachment(cover, 5); title.setBackground(Display.getDefault().getSystemColor(color)); title.setLayoutData(data); Label nbSong = new Label(albumComposite, SWT.LEFT | SWT.BOLD); nbSong.setFont(new Font(this.getDisplay(), \"Arial\", 8, SWT.ITALIC)); nbSong.setText(\"Release date : \" + albumNbSong); data = new FormData(); data.top = new FormAttachment(50, 5); data.left = new FormAttachment(cover, 5); nbSong.setBackground(Display.getDefault().getSystemColor(color)); nbSong.setLayoutData(data); prevCompo = albumComposite; } catch (Exception e) { e.printStackTrace(); } }. \n Code2: private ArrayList execAtParentServer(ArrayList paramList) throws Exception { ArrayList outputList = null; String message = \"\"; try { HashMap serverUrlMap = InitXml.getInstance().getServerMap(); Iterator it = serverUrlMap.keySet().iterator(); while (it.hasNext()) { String server = (String) it.next(); String serverUrl = (String) serverUrlMap.get(server); serverUrl = serverUrl + Primer3Manager.servletName; URL url = new URL(serverUrl); URLConnection uc = url.openConnection(); uc.setDoOutput(true); OutputStream os = uc.getOutputStream(); StringBuffer buf = new StringBuffer(); buf.append(\"actionType=designparent\"); for (int i = 0; i < paramList.size(); i++) { Primer3Param param = (Primer3Param) paramList.get(i); if (i == 0) { buf.append(\"&sequence=\" + param.getSequence()); buf.append(\"&upstream_size\" + upstreamSize); buf.append(\"&downstreamSize\" + downstreamSize); buf.append(\"&MARGIN_LENGTH=\" + marginLength); buf.append(\"&OVERLAP_LENGTH=\" + overlapLength); buf.append(\"&MUST_XLATE_PRODUCT_MIN_SIZE=\" + param.getPrimerProductMinSize()); buf.append(\"&MUST_XLATE_PRODUCT_MAX_SIZE=\" + param.getPrimerProductMaxSize()); buf.append(\"&PRIMER_PRODUCT_OPT_SIZE=\" + param.getPrimerProductOptSize()); buf.append(\"&PRIMER_MAX_END_STABILITY=\" + param.getPrimerMaxEndStability()); buf.append(\"&PRIMER_MAX_MISPRIMING=\" + param.getPrimerMaxMispriming()); buf.append(\"&PRIMER_PAIR_MAX_MISPRIMING=\" + param.getPrimerPairMaxMispriming()); buf.append(\"&PRIMER_MIN_SIZE=\" + param.getPrimerMinSize()); buf.append(\"&PRIMER_OPT_SIZE=\" + param.getPrimerOptSize()); buf.append(\"&PRIMER_MAX_SIZE=\" + param.getPrimerMaxSize()); buf.append(\"&PRIMER_MIN_TM=\" + param.getPrimerMinTm()); buf.append(\"&PRIMER_OPT_TM=\" + param.getPrimerOptTm()); buf.append(\"&PRIMER_MAX_TM=\" + param.getPrimerMaxTm()); buf.append(\"&PRIMER_MAX_DIFF_TM=\" + param.getPrimerMaxDiffTm()); buf.append(\"&PRIMER_MIN_GC=\" + param.getPrimerMinGc()); buf.append(\"&PRIMER_OPT_GC_PERCENT=\" + param.getPrimerOptGcPercent()); buf.append(\"&PRIMER_MAX_GC=\" + param.getPrimerMaxGc()); buf.append(\"&PRIMER_SELF_ANY=\" + param.getPrimerSelfAny()); buf.append(\"&PRIMER_SELF_END=\" + param.getPrimerSelfEnd()); buf.append(\"&PRIMER_NUM_NS_ACCEPTED=\" + param.getPrimerNumNsAccepted()); buf.append(\"&PRIMER_MAX_POLY_X=\" + param.getPrimerMaxPolyX()); buf.append(\"&PRIMER_GC_CLAMP=\" + param.getPrimerGcClamp()); } buf.append(\"&target=\" + param.getPrimerSequenceId() + \",\" + (param.getTarget())[0] + \",\" + (param.getTarget())[1]); } PrintStream ps = new PrintStream(os); ps.print(buf.toString()); ps.close(); ObjectInputStream ois = new ObjectInputStream(uc.getInputStream()); outputList = (ArrayList) ois.readObject(); ois.close(); } } catch (IOException e1) { e1.printStackTrace(); } if ((outputList == null || outputList.size() == 0) && message != null && message.length() > 0) { throw new Exception(message); } return outputList; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static",
        "ground_truth": "NO",
        "predict": " void main(String[] args) { try { new Primer3Manager(); } catch (Exception e) { e.printStackTrace(); } }. \n Code1: public static void main(String[] args) { try { new Primer3Manager(); } catch (Exception e) { e.printStackTrace(); } }. \n Code2: public static void main(String[] args) { try { new Primer3Manager(); } catch (Exception e) { e.printStackTrace(); } }. \n */"
    },
    {
        "ID": 229,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void insertStringInFile(String file, String textToInsert, long fromByte, long toByte) throws Exception { String tmpFile = file + \".tmp\"; BufferedInputStream in = null; BufferedOutputStream out = null; long byteCount = 0; try { in = new BufferedInputStream(new FileInputStream(new File(file))); out = new BufferedOutputStream(new FileOutputStream(tmpFile)); long size = fromByte; byte[] buf = null; if (size == 0) { } else { buf = new byte[(int) size]; int length = -1; if ((length = in.read(buf)) != -1) { out.write(buf, 0, length); byteCount = byteCount + length; } else { String msg = \"Failed to read the first '\" + size + \"' bytes of file '\" + file + \"'. This might be a programming error.\"; logger.warning(msg); throw new Exception(msg); } } buf = textToInsert.getBytes(); int length = buf.length; out.write(buf, 0, length); byteCount = byteCount + length; long skipLength = toByte - fromByte; long skippedBytes = in.skip(skipLength); if (skippedBytes == -1) { } else { buf = new byte[4096]; length = -1; while ((length = in.read(buf)) != -1) { out.write(buf, 0, length); byteCount = byteCount + length; } } in.close(); in = null; out.close(); out = null; File fileToDelete = new File(file); boolean wasDeleted = fileToDelete.delete(); if (!wasDeleted) { String msg = \"Failed to delete the original file '\" + file + \"' to replace it with the modified file after text insertion.\"; logger.warning(msg); throw new Exception(msg); } File fileToRename = new File(tmpFile); boolean wasRenamed = fileToRename.renameTo(fileToDelete); if (!wasRenamed) { String msg = \"Failed to rename tmp file '\" + tmpFile + \"' to the name of the original file '\" + file + \"'\"; logger.warning(msg); throw new Exception(msg); } } catch (Exception e) { logger.log(Level.WARNING, \"Failed to read/write file '\" + file + \"'.\", e); throw e; } finally { if (in != null) { try { in.close(); } catch (IOException e) { logger.log(Level.FINEST, \"Ignoring error closing input file '\" + file + \"'.\", e); } } if (out != null) { try { out.close(); } catch (IOException e) { logger.log(Level.FINEST, \"Ignoring error closing output file '\" + tmpFile + \"'.\", e); } } } }. \n Code2: public static void copyFile(File source, File destination, long copyLength) throws IOException { if (!source.exists()) { String message = \"File \" + source + \" does not exist\"; throw new FileNotFoundException(message); } if (destination.getParentFile() != null && !destination.getParentFile().exists()) { forceMkdir(destination.getParentFile()); } if (destination.exists() && !destination.canWrite()) { String message = \"Unable to open file \" + destination + \" for writing.\"; throw new IOException(message); } if (source.getCanonicalPath().equals(destination.getCanonicalPath())) { String message = \"Unable to write file \" + source + \" on itself.\"; throw new IOException(message); } if (copyLength == 0) { truncateFile(destination, 0); } FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(source); output = new FileOutputStream(destination); long lengthLeft = copyLength; byte[] buffer = new byte[(int) Math.min(BUFFER_LENGTH, lengthLeft + 1)]; int read; while (lengthLeft > 0) { read = input.read(buffer); if (read == -1) { break; } lengthLeft -= read; output.write(buffer, 0, read); } output.flush(); output.getFD().sync(); } finally { IOUtil.closeQuietly(input); IOUtil.closeQuietly(output); } destination.setLastModified(source.lastModified()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException { if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName()); byte[] buffer = new byte[bufSize]; int read = 0; InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); while (true) { read = in.read(buffer); if (read == -1) break; out.write(buffer, 0, read); } } finally { if (in != null) try { in.close(); } finally { if (out != null) out.close(); } } }. \n Code2: public DataRecord addRecord(InputStream input) throws DataStoreException { File temporary = null; try { temporary = newTemporaryFile(); DataIdentifier tempId = new DataIdentifier(temporary.getName()); usesIdentifier(tempId); long length = 0; MessageDigest digest = MessageDigest.getInstance(DIGEST); OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest); try { length = IOUtils.copyLarge(input, output); } finally { output.close(); } DataIdentifier identifier = new DataIdentifier(digest.digest()); File file; synchronized (this) { usesIdentifier(identifier); file = getFile(identifier); if (!file.exists()) { File parent = file.getParentFile(); parent.mkdirs(); if (temporary.renameTo(file)) { temporary = null; } else { throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\"); } } else { long now = System.currentTimeMillis(); if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) { setLastModified(file, now + ACCESS_TIME_RESOLUTION); } } if (file.length() != length) { if (!file.isFile()) { throw new IOException(\"Not a file: \" + file); } throw new IOException(DIGEST + \" collision: \" + file); } } inUse.remove",
        "ground_truth": "YES",
        "predict": "(identifier); return new DataRecord(identifier, file); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void addRecord(File file, InputStream input) throws DataStoreException { usesIdentifier(file.getName()); usesIdentifier(new DataIdentifier(file.getName())); usesIdentifier(new DataIdentifier(file.getName() + \".md5\")); usesIdentifier(new DataIdentifier(file.getName() + \".sha1\")); usesIdentifier(new DataIdentifier(file.getName() + \".sha256\")); usesIdentifier(new DataIdentifier(file.getName() + \".sha512\")); usesIdentifier(new DataIdentifier(file.getName() + \".sha384\")); usesIdentifier(new DataIdentifier(file.getName() + \".sha384\")); usesIdentifier("
    },
    {
        "ID": 235,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private final void saveCopy(String source, String destination) { BufferedInputStream from = null; BufferedOutputStream to = null; try { from = new BufferedInputStream(new FileInputStream(source)); to = new BufferedOutputStream(new FileOutputStream(destination)); byte[] buffer = new byte[65535]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read); } catch (Exception e) { LogWriter.writeLog(\"Exception \" + e + \" copying file\"); } try { to.close(); from.close(); } catch (Exception e) { LogWriter.writeLog(\"Exception \" + e + \" closing files\"); } to = null; from = null; }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String installOvalDefinitions(final String xml_location) { InputStream in_stream = null; try { URL url = _toURL(xml_location); if (url == null) { in_stream = new FileInputStream(xml_location); } else { in_stream = url.openStream(); } } catch (IOException ex) { throw new OvalException(ex); } Class<OvalDefinitions> type = OvalDefinitions.class; OvalDefinitions object = _unmarshalObject(type, in_stream); String pid = _getDatastore().save(type, object); return pid; }. \n Code2: public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception { PreparedStatement pst1 = null; PreparedStatement pst2 = null; ResultSet rs = null; int retVal = -1; try { pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\"); pst1.setString(1, name); pst1.setString(2, instructions); pst1.setInt(3, categoryId); if (pst1.executeUpdate() > 0) { pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\"); pst2.setString(1, name); pst2.setString(2, instructions); pst2.setInt(3, categoryId); rs = pst2.executeQuery(); if (rs.next()) { int id = rs.getInt(1); System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\"); String[] aines; for (int i = 0; i < ainekset.length; ++i) { aines",
        "ground_truth": "NO",
        "predict": " = ainekset[i]; for (int j = 0; j < aines.length; ++j) { System.out.println(\"Ainesosat: \" + aines[j]); } } } } } catch (Exception ex) { throw new Exception(\"Kirjautuminen ep\u00e4onnistui\"); } finally { try { if (rs != null) rs.close(); } catch (Exception ex) { } try { if (pst1 != null) pst1.close(); } catch (Exception ex) { } try { if (pst2 != null) pst2.close(); } catch (Exception ex) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void addRecipe(String name, String instructions, int categoryId) throws Exception { addRecipe(name, instructions, categoryId, new String[0][0]);"
    },
    {
        "ID": 239,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void backup(File source) throws BackupException { try { int index = source.getAbsolutePath().lastIndexOf(\".\"); if (index == -1) return; File dest = new File(source.getAbsolutePath().substring(0, index) + \".bak\"); FileChannel srcChannel = new FileInputStream(source).getChannel(); FileChannel dstChannel = new FileOutputStream(dest).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (Exception ex) { throw new BackupException(ex.getMessage(), ex, source); } }. \n Code2: @SuppressWarnings(\"finally\") private void decompress(final File src) throws IOException { final String srcPath = src.getPath(); checkSourceFile(src); final boolean test = this.switches.contains(Switch.test); final File dst; if (test) dst = File.createTempFile(\"jaxlib-bzip\", null); else { if (srcPath.endsWith(\".bz2\")) dst = new File(srcPath.substring(0, srcPath.length() - 4)); else { this.log.println(\"WARNING: Can't guess original name, using extension \\\".out\\\":\").println(srcPath); dst = new File(srcPath + \".out\"); } } if (!checkDestFile(dst)) return; final boolean showProgress = this.switches.contains(Switch.showProgress); BZip2InputStream in = null; FileOutputStream out = null; FileChannel outChannel = null; FileLock inLock = null; FileLock outLock = null; try { final FileInputStream in0 = new FileInputStream(src); final FileChannel inChannel = in0.getChannel(); final long inSize = inChannel.size(); inLock = inChannel.tryLock(0, inSize, true); if (inLock == null) throw error(\"source file locked by another process: \" + src); in = new BZip2InputStream(new BufferedXInputStream(in0, 8192)); out = new FileOutputStream(dst); outChannel = out.getChannel(); outLock = outChannel.tryLock(); if (outLock == null) throw error(\"destination file locked by another process: \" + dst); if (showProgress || this.verbose) { this.log.print(\"source: \" + src).print(\": size=\").println(inSize); this.log.println(\"target: \" + dst); } long pos = 0; int progress = 0; final long maxStep = showProgress ? Math.max(8192, inSize / MAX_PROGRESS) : Integer.MAX_VALUE; while (true) { final long step = outChannel.transferFrom(in, pos, maxStep); if (step <= 0) { final long a = inChannel.size(); if (a != inSize) throw error(\"file \" + src + \" has been modified concurrently by another process\"); if (inChannel.position() >= inSize) { if (showProgress) { for (int i = progress; i < MAX_PROGRESS; i++) this.log.print('#'); this.log.println(\" done\"); } break; } } else { pos += step; if (showProgress) { final double p = (double) inChannel.position() / (double) inSize; final int newProgress = (int) (MAX_PROGRESS * p); for (int i = progress; i < newProgress; i++) this.log.print('#'); progress = newProgress; } } } final long outSize = outChannel.size(); in.close(); out.close(); if (this.verbose) { final double ratio = (outSize == 0) ? (inSize * 100) : ((double) inSize / (double) outSize); this.log.print(\"compressed size: \").print(inSize) .print(\"; decompressed size: \").print(outSize) .print(\"; compression ratio: \").print(ratio).println('%'); } if (!test && !this.switches.contains(Switch.keep)) { if (!src.delete()) throw error(\"unable to delete sourcefile: \" + src); } if (test && !dst.delete()) throw error(\"unable to delete testfile: \" + dst); } catch (final IOException ex) { IO.tryClose(in); IO.tryClose(out); IO.tryRelease(inLock); IO.tryRelease(outLock); try { this.log.println(); } finally { throw ex; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ArrayList<String> showTopLetters() { int[] tempArray = new int[engCountLetters.length]; char[] tempArrayLetters = new char[abcEng.length]; ArrayList<String> resultTopFiveLetters = new ArrayList<String>(); tempArray = engCountLetters.clone(); tempArrayLetters = abcEng.clone(); int tempCount; char tempLetters; for (int j = 0; j < (abcEng.length * abcEng.length); j++) { for (int i = 0; i < abcEng.length - 1; i++) { if (tempArray[i] > tempArray[i + 1]) { tempCount = tempArray[i]; tempLetters = tempArrayLetters[i]; tempArray[i] = tempArray[i + 1]; tempArrayLetters[i] = tempArrayLetters[i + 1]; tempArray[i + 1] = tempCount; tempArrayLetters[i + 1] = tempLetters; } } } for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) { resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]); } return resultTopFiveLetters; }. \n Code2: public void create() { Connection conn = OrmHandler.getInstance().getSession().getConnection(this); Statement stat = null; StringBuilder sql = new StringBuilder(256); try { getRenderer().printCreateDatabase(this, sql); conn = createConnection(); stat = conn.createStatement(); stat.executeUpdate(sql.toString()); conn.commit(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info(sql.toString()); } } catch (Throwable e) { if (conn != null) { try { conn.rollback(); } catch (SQLException ex) { LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex); } } throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e); } finally { try { close(conn, stat, null, true); } catch (IllegalStateException ex",
        "ground_truth": "NO",
        "predict": ") { } } }. \n Code3: public void drop() { Connection conn = OrmHandler.getInstance().getSession().getConnection(this); Statement stat = null; StringBuilder sql = new StringBuilder(256); try { getRenderer().printDropDatabase(this, sql); conn = createConnection(); stat = conn.createStatement(); stat.executeUpdate(sql.toString()); conn.commit(); if (LOGGER.isLoggable(Level.INFO)) { LOGGER.info(sql.toString()); } } catch (Throwable e) { if (conn != null) { try { conn.rollback(); } catch (SQLException ex) { LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex); } } throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e); } finally { try { close(conn, stat, null, true); } catch (IllegalStateException ex) { }"
    },
    {
        "ID": 241,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ForkJavaProject(String projectName, Class<?> activatorClass) { this.activatorClass = activatorClass; try { IWorkspaceRoot rootWorkspace = ResourcesPlugin.getWorkspace().getRoot(); this.prj = rootWorkspace.getProject(projectName); if (this.prj.exists()) { this.prj.delete(true, true, new NullProgressMonitor()); } this.prj.create(new NullProgressMonitor()); this.prj.open(new NullProgressMonitor()); IProjectDescription description = this.prj.getDescription(); description.setNatureIds(new String[] { \"org.eclipse.jdt.core.javanature\" }); this.prj.setDescription(description, new NullProgressMonitor()); createProjectDir(Constants.Dirs.DIR_MAIN_JAVA); createProjectDir(Constants.Dirs.DIR_CONFIG); createProjectDir(Constants.Dirs.DIR_MAIN_RESOURCES); createProjectDir(Constants.Dirs.DIR_MODELS); createProjectDir(Constants.Dirs.DIR_TESTS_JAVA); createProjectDir(Constants.Dirs.DIR_TESTS_RESOURCES); createProjectDir(Constants.Dirs.DIR_CLASSES); createProjectDir(Constants.Dirs.DIR_LIB); this.prj.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor()); this.javaProject = JavaCore.create(this.prj); if (this.javaProject.exists() && !this.javaProject.isOpen()) { this.javaProject.open(new NullProgressMonitor()); } File javaHome = new File(System.getProperty(\"java.home\")); IPath jreLibPath = new Path(javaHome.getPath()).append(\"lib\").append(\"rt.jar\"); this.javaProject.setOutputLocation(prj.getFolder(Constants.Dirs.DIR_CLASSES).getFullPath(), new NullProgressMonitor()); JavaCore.setClasspathVariable(\"JRE_LIB\", jreLibPath, new NullProgressMonitor()); this.javaProject.setRawClasspath(getProjectClassPath(), new NullProgressMonitor()); } catch (CoreException e) { Activator.getDefault().getLog().log(new Status(Status.ERROR, Activator.PLUGIN_ID, \"An exception has been thrown while creating Project\", e)); } }. \n Code2: private RemoteObject createRemoteObject(final VideoEntry videoEntry, final RemoteContainer container) throws RemoteException { MessageDigest instance; try { instance = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { throw new RemoteException(StatusCreator.newStatus(\"Error creating MD5\", e)); } StringWriter sw = new StringWriter(); YouTubeMediaGroup mediaGroup = videoEntry.getMediaGroup(); if (mediaGroup != null) { if (mediaGroup.getDescription() != null) { sw.append(mediaGroup.getDescription().getPlainTextContent()); } List<MediaCategory> keywordsGroup = mediaGroup.getCategories(); StringBuilder sb = new StringBuilder(); if (keywordsGroup != null) { for (MediaCategory mediaCategory : keywordsGroup) { sb.append(mediaCategory.getContent()); } } } instance.update(sw.toString().getBytes()); RemoteObject remoteVideo = InfomngmntFactory.eINSTANCE.createRemoteObject(); remoteVideo.setHash(asHex(instance.digest())); remoteVideo.setId(SiteInspector.getId(videoEntry.getHtmlLink().getHref())); remoteVideo.setName(videoEntry.getTitle().getPlainText()); remoteVideo.setRepositoryTypeObjectId(KEY_VIDEO); remoteVideo.setWrappedObject(videoEntry); setInternalUrl(remoteVideo, container); return remoteVideo; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException { String fullname = System.mapLibraryName(name); String path = \"native/\" + sysName + \"/\" + fullname; URL url = Thread.currentThread().getContextClassLoader().getResource(path); if (url == null) { if (!warning) { logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname }); } return; } URLConnection conn = url.openConnection(); InputStream in = conn.getInputStream(); File targetFile = new File(getExtractionDir(), fullname); OutputStream out = null; try { if (targetFile.exists()) { long targetLastModified = targetFile.lastModified(); long sourceLastModified = conn.getLastModified(); if (targetLastModified + 1000 > sourceLastModified) { logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname); return; } } out = new FileOutputStream(targetFile); int len; while ((len = in.read(buf)) > 0) { out.write(buf, 0, len); } in.close(); in = null; out.close(); out = null; targetFile.setLastModified(conn.getLastModified()); } catch (FileNotFoundException ex) { if (ex.getMessage().contains(\"used by another process\")) { return; } throw ex; } finally { if (load) { System.load(targetFile.getAbsolutePath()); } if (in != null) { in.close(); } if (out != null) { out.close(); } } logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile }); }. \n Code2: public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException { final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder(); final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath); final Multimap<String, String> proteins = HashMultimap.create(); for (final String query : queries) { HttpURLConnection connection = null; try { final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\"); final URL url = new URL(String.format(__urlTempl2, encoded, taxon)); connection = (HttpURLConnection) url.openConnection(); connection.setConnectTimeout(__connTimeout); connection.setReadTimeout(__readTimeout); connection.setRequestProperty(\"Connection\", \"close\"); connection.connect(); final InputStream stream = connection.getInputStream(); final Document doc = parser.",
        "ground_truth": "NO",
        "predict": "parse(stream); final XPath xpath = XPathFactory.newInstance().newXPath(); final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET); for (int i = 0; i < nodes.getLength(); i++) { final Node node = nodes.item(i); final String name = node.getTextContent(); if (name != null && !name.isEmpty()) { proteins.put(name, query); } } } catch (final IOException ex) { logger.log(Level.WARNING, \"Error while querying NCBI\", ex); } finally { if (connection != null) { connection.disconnect(); } } } return proteins; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { try { final String[] queries = { \"Bacteria\", \"Vir"
    },
    {
        "ID": 246,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { ejb.bprocess.OAIPMH.AutoHarvesterSession ahSession = home.create(); java.util.Vector vector = new java.util.Vector(1, 1); Integer libraryId = new Integer(1); String xmlstr = \"\"; String str = \"\"; String arr[] = new String[2]; String[] subarr = new String[4]; String mdPrefix = \"\", mdPrefixValue = \"\"; String from = \"\", fromValue = \"\"; String until = \"\", untilValue = \"\"; String set = \"\", setValue = \"\"; String oai_pmhRequest = request.getParameter(\"verb\"); String oai_pmhQuery = request.getQueryString(); String urlStr = \"\"; urlStr = \"http://\" + request.getServerName() + \":\" + request.getServerPort() + \"/newgenlibctxt/HarvestServlet\"; String attribute = oai_pmhQuery; String arguments = attribute.substring(attribute.indexOf(\"?\") + 1); StringTokenizer st = new StringTokenizer(arguments, \"&\"); int i = 0; int j = 0; int z = 0; int count = 0; String type = \"\"; while (st.hasMoreTokens()) { arr[i] = st.nextToken(); StringTokenizer subst = new StringTokenizer(arr[i], \"=\"); while (subst.hasMoreTokens()) { subarr[j] = subst.nextToken(); j++; } i++; count++; } int mdfCount = 0, fromCount = 0, untilCount = 0, setCount = 0; ListRecords lr = new ListRecords(); for (int k = 0; k < j; k += 2) { if (subarr[k].equals(\"from\")) { from = \"from\"; fromCount++; fromValue = subarr[k + 1]; fromValue = lr.validateDate(fromValue); } else if (subarr[k].equals(\"until\")) { until = \"until\"; untilCount++; untilValue = subarr[k + 1]; untilValue = lr.validateDate(untilValue); } } if (fromValue.equals(\"\") && untilCount == 1) { fromValue = lr.validateDate(\"0001-01-01\"); } else if (untilValue.equals(\"\") && fromCount == 1) { String a = (new Resdate()).getDate(); untilValue = a.substring(0, a.indexOf(\"T\")); } System.out.println(\"This is fromValue:\" + fromValue); System.out.println(\"This is untilValue:\" + untilValue); vector = ahSession.getHarvestLibrary(null, libraryId); String harlibraryId = \"\"; if (vector.size() > 0) { for (int k = 0; k < vector.size(); k = k + 3) { harlibraryId = vector.elementAt(k).toString(); String harvesturl = vector.elementAt(k + 1).toString(); String status = vector.elementAt(k + 2).toString(); if (status.equals(\"A\")) { String oai_pmhRequest1 = request.getParameter(\"verb\"); String oai_pmhQuery1 = request.getQueryString(); urlStr = \"http://\" + harvesturl + \":8080/newgenlibctxt/oai2.0?verb=ListRecords&metadataPrefix=marc21&from=\" + fromValue + \"&until=\" + untilValue + \"\"; boolean resExists = true; for (int n = 0; resExists == true; n++) { java.net.URL url = new java.net.URL(urlStr); java.net.URLConnection urlCon = url.openConnection(); urlCon.setDoInput(true); urlCon.connect(); InputStream is = urlCon.getInputStream(); System.out.println(\"input\" + is.available()); org.jdom.input.SAXBuilder sb = new org.jdom.input.SAXBuilder(); org.jdom.Document doc = sb.build(is); xmlstr = (new org.jdom.output.XMLOutputter()).outputString(doc); System.out.println(\"xmlStr:\" + xmlstr); doc = null; sb = null; java.util.Vector vec = new java.util.Vector(); vec = ahSession.autoInitialHarvest(null, xmlstr, harlibraryId); String resT = doc.getRootElement().getChildText(\"resumptionToken\", doc.getRootElement().getNamespace()); if (!(resT == null)) { urlStr = \"http://\" + harvesturl + \":8080/newgenlibctxt/oai2.0?verb=ListRecords&resumptionToken=\" + resT; } else { resExists = false; } } } else if (status.equals(\"B\")) { java.io.File file = new java.io.File(harvesturl); java.io.File[] file1 = file.listFiles(); for (int b = 0; b < file1.length; b++) { File file2 = (File) file1[b]; System.out.println(\"File2:\" + file2); long lastmodifed = file2.lastModified(); StringTokenizer st1 = new StringTokenizer(fromValue, \"-\"); String dar[] = new String[3]; java.util.Calendar c1 = java.util.Calendar.getInstance(); int g = 0; while (st1.hasMoreElements()) { dar[g] = st1.nextToken(); g++; } c1.set(Integer.parseInt(dar[0]), Integer.parseInt(dar[1]), Integer.parseInt(dar[2])); StringTokenizer st2 = new StringTokenizer(untilValue, \"-\"); String dar1[] = new String[3]; java.util.Calendar c2 = java.util.Calendar.getInstance(); int d = 0; while (st2.hasMoreElements()) { dar1[d] = st2.nextToken(); d++; } c2.set(Integer.parseInt(dar1[0]), Integer.parseInt(dar1[1]), Integer.parseInt(dar1[2])); java.util.Calendar c3 = java.util.Calendar.getInstance(); c3.setTimeInMillis(lastmodifed); c3.set(java.util.Calendar.HOUR, 0); c3.set(java.util.Calendar.AM_PM, java.util.Calendar.AM); c3.set(java.util.Calendar.MINUTE, 0); c3.set(java.util.Calendar.SECOND, 0); c3.set(java.util.Calendar.MILLISECOND, 0); java.",
        "ground_truth": "NO",
        "predict": "util.Date d1 = c3.getTime(); if (c1.after(c2) && c1.before(d1)) { String xmlstr1 = \"\"; xmlstr1 = ahSession.autoHarvest(null, file2.getAbsolutePath(), harlibraryId); if (xmlstr1 != null) { System.out.println(\"xmlStr1:\" + xmlstr1); } } } } } catch (Exception e) { e.printStackTrace(); } }\n\n}\n"
    },
    {
        "ID": 250,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void resize(File originalFile, File resizedFile, int width, String format) throws IOException { if (format != null && \"gif\".equals(format.toLowerCase())) { resize(originalFile, resizedFile, width, 1); return; } FileInputStream fis = new FileInputStream(originalFile); ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); int readLength = -1; int bufferSize = 1024; byte bytes[] = new byte[bufferSize]; while ((readLength = fis.read(bytes, 0, bufferSize)) != -1) { byteStream.write(bytes, 0, readLength); } byte[] in = byteStream.toByteArray(); fis.close(); byteStream.close(); Image inputImage = Toolkit.getDefaultToolkit().createImage(in); waitForImage(inputImage); int imageWidth = inputImage.getWidth(null); if (imageWidth < 1) throw new IllegalArgumentException(\"image width \" + imageWidth + \" is out of range\"); int imageHeight = inputImage.getHeight(null); if (imageHeight < 1) throw new IllegalArgumentException(\"image height \" + imageHeight + \" is out of range\"); int height = -1; double scaleW = (double) imageWidth / (double) width; double scaleY = (double) imageHeight / (double) height; if (scaleW >= 0 && scaleY >= 0) { if (scaleW > scaleY) { height = -1; } else { width = -1; } } Image outputImage = inputImage.getScaledInstance(width, height, java.awt.Image.SCALE_DEFAULT); checkImage(outputImage); encode(new FileOutputStream(resizedFile), outputImage, format); }. \n Code2: protected Object openDialogBox(Control cellEditorWindow) { FileDialog dialog = new FileDialog(parent.getShell(), SWT.OPEN); dialog.setFilterExtensions(new String[] { \"*.jpg;*.JPG;*.JPEG;*.gif;*.GIF;*.png;*.PNG\", \"*.jpg;*.JPG;*.JPEG\", \"*.gif;*.GIF\", \"*.png;*.PNG\" }); dialog.setFilterNames(new String[] { \"All\", \"Joint Photographic Experts Group (JPEG)\", \"Graphics Interchange Format (GIF)\", \"Portable Network Graphics (PNG)\" }); String imagePath = dialog.open(); if (imagePath == null) return null; IProject project = ProjectManager.getInstance().getCurrentProject(); String projectFolderPath = project.getLocation().toOSString(); File imageFile = new File(imagePath); String fileName = imageFile.getName(); ImageData imageData = null; try { imageData = new ImageData(imagePath); } catch (SWTException e) { UserErrorException error = new UserErrorException(PropertyHandler.getInstance().getProperty(\"_invalid_image_title\"), PropertyHandler.getInstance().getProperty(\"_invalid_image_text\")); UserErrorService.INSTANCE.showError(error); return null; } if (imageData == null) { UserErrorException error = new UserErrorException(PropertyHandler.getInstance().getProperty(\"_invalid_image_title\"), PropertyHandler.getInstance().getProperty(\"_invalid_image_text\")); UserErrorService.INSTANCE.showError(error); return null; } File copiedImageFile = new File(projectFolderPath + File.separator + imageFolderPath + File.separator + fileName); if (copiedImageFile.exists()) { Path path = new Path(copiedImageFile.getPath()); copiedImageFile = new File(projectFolderPath + File.separator + imageFolderPath + File.separator + UUID.randomUUID().toString() + \".\" + path.getFileExtension()); } try { copiedImageFile.createNewFile(); } catch (IOException e1) { ExceptionHandlingService.INSTANCE.handleException(e1); copiedImageFile = null; } if (copiedImageFile == null) { copiedImageFile = new File(projectFolderPath + File.separator + imageFolderPath + File.separator + UUID.randomUUID().toString()); try { copiedImageFile.createNewFile(); } catch (IOException e) { ExceptionHandlingService.INSTANCE.handleException(e); return \"\"; } } FileReader in = null; FileWriter out = null; try { in = new FileReader(imageFile); out = new FileWriter(copiedImageFile); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } catch (FileNotFoundException e) { ExceptionHandlingService.INSTANCE.handleException(e); return \"\"; } catch (IOException e) { ExceptionHandlingService.INSTANCE.handleException(e); return \"\"; } return imageFolderPath + File.separator + copiedImageFile.getName(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException { InputStream inStream = null; OutputStream outStream = null; try { inStream = MatsimResource.getAsInputStream(resourceFilename); outStream = new FileOutputStream(destinationFilename); IOUtils.copyStream(inStream, outStream); } finally { if (inStream != null) { try { inStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (outStream != null) { try { outStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }. \n Code2: public byte[] getResponse() { final ByteArrayInputStream bais = new ByteArrayInputStream(request); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); List<String> lines = Collections.emptyList(); try { @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais); lines = dl; } catch (IOException ioex) { throw new AssertionError(ioex); } String resource = null; for (String line : lines) { if (line.startsWith(\"GET \")) { int endIndex = line.lastIndexOf(' '); resource = line.substring(4, endIndex); } } final PrintStream printStream = new PrintStream(baos); if (resource == null) { printStream.println(\"HTTP/1.1 400 Bad Request\"); } else { final InputStream inputStream = getClass().getResourceAsStream(resource); if (inputStream == null) { printStream.println(\"HTTP/1.1 404 Not Found\"); printStream.println(); } else { printStream.println(\"HTTP/1.1 200 OK\"); printStream.",
        "ground_truth": "YES",
        "predict": "println(); } IOUtils.copyStream(inputStream, printStream); } return baos.toByteArray(); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void resize(File originalFile, File resizedFile, int width, String format) throws IOException { if (format != null && \"gif\".equals(format.toLowerCase())) { resize(originalFile, resizedFile, width, 1); return; } FileInputStream fis = new FileInputStream(originalFile); ByteArrayOutputStream byteStream = new ByteArrayOutputStream(); int readLength = -1; int bufferSize = 1024; byte bytes[] = new byte[bufferSize]; while ((readLength = fis.read(bytes, 0, bufferSize)) != -1) { byteStream.write(bytes, 0, readLength); } byte[] in = byteStream.toByte"
    },
    {
        "ID": 255,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActualTask(TEditor editor, TIGDataBase dataBase, String directoryPath) { File myDirectory = new File(directoryPath); String[] list = myDirectory.list(); int i; for (i = 0; ((i < list.length) && !stop); i++) { current = i; if ((list[i].compareTo(\"Images\") != 0) && ((list[i].substring(list[i].lastIndexOf('.'), list[i].length()).toLowerCase().compareTo(\".jpg\") == 0) || (list[i].substring(list[i].lastIndexOf('.'), list[i].length()).toLowerCase().compareTo(\".bmp\") == 0) || (list[i].substring(list[i].lastIndexOf('.'), list[i].length()).toLowerCase().compareTo(\".png\") == 0))) { String name = list[i]; String pathSrc = directoryPath.concat(list[i]); name = name.replace(' ', '_').replace(',', '-').replace('\u00e1', 'a').replace('\u00e9', 'e').replace('\u00ed', 'i').replace('\u00f3', 'o').replace('\u00fa', 'u').replace('\u00c1', 'A').replace('\u00c9', 'E').replace('\u00cd', 'I').replace('\u00d3', 'O').replace('\u00da', 'U'); String pathDst = directoryPath.concat(name); Vector aux = new Vector(); aux = dataBase.imageSearch(name.substring(0, name.lastIndexOf('.'))); if (aux.size() != 0) pathDst = pathDst.substring(0, pathDst.lastIndexOf('.')) + '_' + aux.size() + \".png\"; File src = new File(pathSrc); File absPath = new File(\"\"); String nameSrc = '.' + src.separator + \"Images\" + src.separator + name.substring(0, 1).toUpperCase() + src.separator + pathDst.substring(pathDst.lastIndexOf(src.separator) + 1, pathDst.length()); String newDirectory = '.' + src.separator + \"Images\" + src.separator + name.substring(0, 1).toUpperCase(); String imagePathThumb = (nameSrc.substring(0, nameSrc.lastIndexOf(\".\"))).concat(\"_th.jpg\"); ImageIcon image = null; if (src != null) { if (TFileUtils.isJAIRequired(src)) { RenderedOp src_aux = JAI.create(\"fileload\", src.getAbsolutePath()); BufferedImage bufferedImage = src_aux.getAsBufferedImage(); image = new ImageIcon(bufferedImage); } else { image = new ImageIcon(src.getAbsolutePath()); } if (image.getImageLoadStatus() == MediaTracker.ERRORED) { System.out.print(\"Error al insertar imagen: \"); System.out.println(pathDst); } else { int option = 0; imageFile = new File(directoryPath + \"Images\"); if (!imageFile.exists()) { TIGNewImageDataDialog dialog = new TIGNewImageDataDialog(editor, dataBase, image, nameSrc.substring(nameSrc.lastIndexOf(File.separator) + 1, nameSrc.length()), list[i].substring(0, list[i].lastIndexOf('.')), myTask); option = dialog.getOption(); if (option != 0) { File newDirectoryFolder = new File(newDirectory); newDirectoryFolder.mkdirs(); try { FileChannel srcChannel = new FileInputStream(pathSrc).getChannel(); FileChannel dstChannel = new FileOutputStream(nameSrc).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException exc) { System.out.println(exc.getMessage()); System.out.println(exc.toString()); } } } if (imageFile.exists()) { dataBase.insertImageDB(list[i].substring(0, list[i].lastIndexOf('.')), nameSrc.substring(nameSrc.lastIndexOf(File.separator) + 1, nameSrc.length())); File newDirectoryFolder = new File(newDirectory); newDirectoryFolder.mkdirs(); try { FileChannel srcChannel = new FileInputStream(pathSrc).getChannel(); FileChannel dstChannel = new FileOutputStream(nameSrc).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException exc) { System.out.println(exc.getMessage()); System.out.println(exc.toString()); } } try { int thumbWidth = PREVIEW_WIDTH; int thumbHeight = PREVIEW_HEIGHT; double thumbRatio = (double) thumbWidth / (double) thumbHeight; int imageWidth = image.getIconWidth(); int imageHeight = image.getIconHeight(); double imageRatio = (double) imageWidth / (double) imageHeight; if (thumbRatio < imageRatio) { thumbHeight = (int) (thumbWidth / imageRatio); } else { thumbWidth = (int) (thumbHeight * imageRatio); } BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB); Graphics2D graphics2D = thumbImage.createGraphics(); graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR); graphics2D.drawImage(image.getImage(), 0, 0, thumbWidth, thumbHeight, null); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(imagePathThumb)); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out); JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage); int quality = 100; quality = Math.max(0, Math.min(quality, 100)); param.setQuality((float) quality / 100.0f, false); encoder.setJPEGEncodeParam(param); encoder.encode(thumbImage); out.close(); } catch (Exception ex) { System.out.println(ex.getMessage()); System.out.println(ex.toString()); } } } } } if (imageFile.exists() && !stop) { try { DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder(); Document doc = docBuilder.parse(imageFile); Element dataBaseElement = doc.getDocumentElement(); if (",
        "ground_truth": "NO",
        "predict": "dataBaseElement.getNodeName().equals(\"dataBase\")) { if (dataBaseElement.getAttribute(\"name\").equals(name)) { if (dataBaseElement.getAttribute(\"path\").equals(pathDst)) { if (dataBaseElement.getAttribute(\"type\").equals(\"image\")) { if (dataBaseElement.getAttribute(\"code1\").equals(code1)) { if (dataBaseElement.getAttribute(\"code2\").equals(code2)) { if (dataBaseElement.getAttribute(\"code3\").equals(code3)) { if (dataBaseElement.getAttribute(\"code4\").equals(code4)) { if (dataBaseElement.getAttribute(\"code5\").equals(code5)) { if (dataBaseElement.getAttribute(\"code6\").equals(code6)) { if (dataBaseElement.getAttribute(\"code7\").equals(code7)) { if (dataBaseElement.getAttribute(\"code8\").equals("
    },
    {
        "ID": 256,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void doConvert(HttpServletResponse response, ConversionRequestResolver rr, EGE ege, ConversionsPath cpath) throws FileUploadException, IOException, RequestResolvingException, EGEException, FileNotFoundException, ConverterException, ZipException { InputStream is = null; OutputStream os = null; if (ServletFileUpload.isMultipartContent(rr.getRequest())) { ServletFileUpload upload = new ServletFileUpload(); FileItemIterator iter = upload.getItemIterator(rr.getRequest()); while (iter.hasNext()) { FileItemStream item = iter.next(); if (!item.isFormField()) { is = item.openStream(); applyConversionsProperties(rr.getConversionProperties(), cpath); DataBuffer buffer = new DataBuffer(0, EGEConstants.BUFFER_TEMP_PATH); String alloc = buffer.allocate(is); InputStream ins = buffer.getDataAsStream(alloc); is.close(); try { ValidationResult vRes = ege.performValidation(ins, cpath.getInputDataType()); if (vRes.getStatus().equals(ValidationResult.Status.FATAL)) { ValidationServlet valServ = new ValidationServlet(); valServ.printValidationResult(response, vRes); try { ins.close(); } finally { buffer.removeData(alloc, true); } return; } } catch (ValidatorException vex) { LOGGER.warn(vex.getMessage()); } finally { try { ins.close(); } catch (Exception ex) { } } File zipFile = null; FileOutputStream fos = null; String newTemp = UUID.randomUUID().toString(); IOResolver ior = EGEConfigurationManager.getInstance().getStandardIOResolver(); File buffDir = new File(buffer.getDataDir(alloc)); zipFile = new File(EGEConstants.BUFFER_TEMP_PATH + File.separator + newTemp + EZP_EXT); fos = new FileOutputStream(zipFile); ior.compressData(buffDir, fos); ins = new FileInputStream(zipFile); File szipFile = new File(EGEConstants.BUFFER_TEMP_PATH + File.separator + newTemp + ZIP_EXT); fos = new FileOutputStream(szipFile); try { try { ege.performConversion(ins, fos, cpath); } finally { fos.close(); } boolean isComplex = EGEIOUtils.isComplexZip(szipFile); response.setContentType(APPLICATION_OCTET_STREAM); String fN = item.getName().substring(0, item.getName().lastIndexOf(\".\")); if (isComplex) { String fileExt; if (cpath.getOutputDataType().getMimeType().equals(APPLICATION_MSWORD)) { fileExt = DOCX_EXT; } else { fileExt = ZIP_EXT; } response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fN + fileExt + \"\\\"\"); FileInputStream fis = new FileInputStream(szipFile); os = response.getOutputStream(); try { EGEIOUtils.copyStream(fis, os); } finally { fis.close(); } } else { String fileExt = getMimeExtensionProvider().getFileExtension(cpath.getOutputDataType().getMimeType()); response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fN + fileExt + \"\\\"\"); os = response.getOutputStream(); EGEIOUtils.unzipSingleFile(new ZipFile(szipFile), os); } } finally { ins.close(); if (os != null) { os.flush(); os.close(); } buffer.clear(true); szipFile.delete(); if (zipFile != null) { zipFile.delete(); } } } } } else { response.sendError(HttpServletResponse.SC_BAD_REQUEST); return; } }. \n Code2: private static void copy(String fromFileName, String toFileName) throws IOException { File fromFile = new File(fromFileName); File toFile = new File(toFileName); if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName); if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName); if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) throw new IOException(\"FileCopy: destination file is unwriteable: \" + toFileName); System.out.flush(); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String response = in.readLine(); if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new IOException(\"FileCopy: existing file was not overwritten.\"); } else { String parent = toFile.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent); if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent); if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(fromFile); to = new FileOutputStream(toFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); } finally { if (from != null) try { from.close(); } catch (IOException e) { ; } if (to != null) try { to.close(); } catch (IOException e) { ; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getSHA256Checksum(String source) { String checksum = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"SHA-256\"); md.update(source.getBytes()); byte[] byteData = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++)",
        "ground_truth": "NO",
        "predict": " { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) { sb.append('0'); } sb.append(hex); } checksum = sb.toString(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return checksum; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getMD5Checksum(String source) { String checksum = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(source.getBytes()); byte[] byteData = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex."
    },
    {
        "ID": 269,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private File downloadPDB(String pdbId) { File tempFile = new File(path + \"/\" + pdbId + \".pdb.gz\"); File pdbHome = new File(path); if (!pdbHome.canWrite()) { System.err.println(\"can not write to \" + pdbHome); return null; } String ftp = String.format(\"ftp://ftp.ebi.ac.uk/pub/databases/msd/pdb_uncompressed/pdb%s.ent\", pdbId.toLowerCase()); System.out.println(\"Fetching \" + ftp); try { URL url = new URL(ftp); InputStream conn = url.openStream(); System.out.println(\"writing to \" + tempFile); FileOutputStream outPut = new FileOutputStream(tempFile); GZIPOutputStream gzOutPut = new GZIPOutputStream(outPut); PrintWriter pw = new PrintWriter(gzOutPut); BufferedReader fileBuffer = new BufferedReader(new InputStreamReader(conn)); String line; while ((line = fileBuffer.readLine()) != null) { pw.println(line); } pw.flush(); pw.close(); outPut.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); return null; } return tempFile; }. \n Code2: private static List lookupForImplementations(final Class clazz, final ClassLoader loader, final String[] defaultImplementations, final boolean onlyFirst, final boolean returnInstances) throws ClassNotFoundException { if (clazz == null) { throw new IllegalArgumentException(\"Argument 'clazz' cannot be null!\"); } ClassLoader classLoader = loader; if (classLoader == null) { classLoader = clazz.getClassLoader(); } String interfaceName = clazz.getName(); ArrayList tmp = new ArrayList(); ArrayList toRemove = new ArrayList(); String className = System.getProperty(interfaceName); if (className != null && className.trim().length() > 0) { tmp.add(className.trim()); } Enumeration en = null; try { en = classLoader.getResources(\"META-INF/services/\" + clazz.getName()); } catch (IOException e) { e.printStackTrace(); } while (en != null && en.hasMoreElements()) { URL url = (URL) en.nextElement(); InputStream is = null; try { is = url.openStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); String line; do { line = reader.readLine(); boolean remove = false; if (line != null) { if (line.startsWith(\"#-\")) { remove = true; line = line.substring(2); } int pos = line.indexOf('#'); if (pos >= 0) { line = line.substring(0, pos); } line = line.trim(); if (line.length() > 0) { if (remove) { toRemove.add(line); } else { tmp.add(line); } } } } while (line != null); } catch (IOException e) { e.printStackTrace(); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } if (defaultImplementations != null) { for (int i = 0; i < defaultImplementations.length; i++) { tmp.add(defaultImplementations[i].trim()); } } if (!clazz.isInterface()) { int m = clazz.getModifiers(); if (!Modifier.isAbstract(m) && Modifier.isPublic(m) && !Modifier.isStatic(m)) { tmp.add(interfaceName); } } tmp.removeAll(toRemove); ArrayList res = new ArrayList(); for (Iterator it = tmp.iterator(); it.hasNext(); ) { className = (String) it.next(); try { Class c = Class.forName(className, false, classLoader); if (c != null) { if (clazz.isAssignableFrom(c)) { if (returnInstances) { Object o = null; try { o = c.newInstance(); } catch (Throwable e) { e.printStackTrace(); } if (o != null) { res.add(o); if (onlyFirst) { return res; } } } else { res.add(c); if (onlyFirst) { return res; } } } else { logger.warning(\"MetaInfLookup: Class '\" + className + \"' is not a subclass of class : \" + interfaceName); } } } catch (ClassNotFoundException e) { logger.log(Level.WARNING, \"Cannot create implementation of interface: \" + interfaceName, e); } } if (res.size() == 0) { throw new ClassNotFoundException(\"Cannot find any implemnetation of class \" + interfaceName); } return res; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void unzipModel(String filename, String tempdir) throws EDITSException { try { BufferedOutputStream dest = null; FileInputStream fis = new FileInputStream(filename); int BUFFER = 2048; ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis)); ZipEntry entry; while ((entry = zis.getNextEntry()) != null) { int count; byte data[] = new byte[BUFFER]; FileOutputStream fos = new FileOutputStream(tempdir + entry.getName()); dest = new BufferedOutputStream(fos, BUFFER); while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count); dest.flush(); dest.close(); } zis.close(); } catch (Exception e) { throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage()); } }. \n Code2: private synchronized void loadDDL() throws IOException { try { conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close(); } catch (SQLException e) { Statement stmt = null; if (!e.getMessage().matches(ERR_MISSING_TABLE)) { e.printStackTrace(System.out); throw new IOException(\"Error on initial data store read\"); } String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val",
        "ground_truth": "NO",
        "predict": " LONG VARCHAR)\", \"CREATE TABLE settings_backup (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old_old (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old_old_old (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old_old_old_old (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old_old_old_old_old (var VARCHAR(32) NOT NULL, val LONG VARCHAR)\", \"CREATE TABLE settings_backup_old_old_old_old_old_old (var VARCHAR(32) NOT NULL,"
    },
    {
        "ID": 271,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ProgramMessageSymbol addProgramMessageSymbol(int programID, String name, byte[] bytecode) throws AdaptationException { ProgramMessageSymbol programMessageSymbol = null; Connection connection = null; PreparedStatement preparedStatement = null; Statement statement = null; ResultSet resultSet = null; InputStream stream = new ByteArrayInputStream(bytecode); try { String query = \"INSERT INTO ProgramMessageSymbols(programID, name, \" + \"bytecode) VALUES ( ?, ?, ? )\"; connection = DriverManager.getConnection(CONN_STR); preparedStatement = connection.prepareStatement(query); preparedStatement.setInt(1, programID); preparedStatement.setString(2, name); preparedStatement.setBinaryStream(3, stream, bytecode.length); log.info(\"INSERT INTO ProgramMessageSymbols(programID, name, \" + \"bytecode) VALUES (\" + programID + \", '\" + name + \"', \" + \"<bytecode>)\"); preparedStatement.executeUpdate(); statement = connection.createStatement(); query = \"SELECT * FROM ProgramMessageSymbols WHERE \" + \"programID = \" + programID + \" AND \" + \"name = '\" + name + \"'\"; resultSet = statement.executeQuery(query); if (!resultSet.next()) { connection.rollback(); String msg = \"Attempt to add program message symbol failed.\"; log.error(msg); ; throw new AdaptationException(msg); } programMessageSymbol = getProgramMessageSymbol(resultSet); connection.commit(); } catch (SQLException ex) { try { connection.rollback(); } catch (Exception e) { } String msg = \"SQLException in addProgramMessageSymbol\"; log.error(msg, ex); throw new AdaptationException(msg, ex); } finally { try { resultSet.close(); } catch (Exception ex) { } try { preparedStatement.close(); } catch (Exception ex) { } try { statement.close(); } catch (Exception ex) { } try { connection.close(); } catch (Exception ex) { } } return programMessageSymbol; }. \n Code2: public static void unzip(final File file, final ZipFile zipFile, final File targetDirectory) throws PtException { LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory \" + \"'\" + targetDirectory.getAbsolutePath() + \"'.\"); assert (file.exists() && file.isFile()); if (targetDirectory.exists() == false) { LOG.debug(\"Creating target directory.\"); if (targetDirectory.mkdirs() == false) { throw new PtException(\"Could not create target directory at \" + \"'\" + targetDirectory.getAbsolutePath() + \"'!\"); } } ZipInputStream zipin = null; try { zipin = new ZipInputStream(new FileInputStream(file)); ZipEntry nextZipEntry = zipin.getNextEntry(); while (nextZipEntry != null) { LOG.debug(\"Unzipping entry '\" + nextZipEntry.getName() + \"'.\"); if (nextZipEntry.isDirectory()) { LOG.debug(\"Skipping directory.\"); continue; } final File targetFile = new File(targetDirectory, nextZipEntry.getName()); final File parentTargetFile = targetFile.getParentFile(); if (parentTargetFile.exists() == false) { LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\"); if (parentTargetFile.mkdirs() == false) { throw new PtException(\"Could not create target directory at \" + \"'\" + parentTargetFile.getAbsolutePath() + \"'!\"); } } InputStream input = null; FileOutputStream output = null; try { input = zipFile.getInputStream(nextZipEntry); if (targetFile.createNewFile() == false) { throw new PtException(\"Could not create target file \" + \"'\" + targetFile.getAbsolutePath() + \"'!\"); } output = new FileOutputStream(targetFile); byte[] buffer = new byte[BUFFER_SIZE]; int readBytes = input.read(buffer, 0, buffer.length); while (readBytes > 0) { output.write(buffer, 0, readBytes); readBytes = input.read(buffer, 0, buffer.length); } } finally { PtCloseUtil.close(input, output); } nextZipEntry = zipin.getNextEntry(); } } catch (IOException e) { throw new PtException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e); } finally { PtCloseUtil.close(zipin); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException { String fullname = System.mapLibraryName(name); String path = \"native/\" + sysName + \"/\" + fullname; URL url = Thread.currentThread().getContextClassLoader().getResource(path); if (url == null) { if (!warning) { logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname }); } return; } URLConnection conn = url.openConnection(); InputStream in = conn.getInputStream(); File targetFile = new File(getExtractionDir(), fullname); OutputStream out = null; try { if (targetFile.exists()) { long targetLastModified = targetFile.lastModified(); long sourceLastModified = conn.getLastModified(); if (targetLastModified + 1000 > sourceLastModified) { logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname); return; } } out = new FileOutputStream(targetFile); int len; while ((len = in.read(buf)) > 0) { out.write(buf, 0, len); } in.close(); in = null; out.close(); out = null; targetFile.setLastModified(conn.getLastModified()); } catch (FileNotFoundException ex) { if (ex.getMessage().contains(\"used by another process\")) { return; } throw ex; } finally { if (load) { System.load(targetFile.getAbsolutePath()); } if (in != null) { in.close(); } if (out != null) { out.close(); } } logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile }); }. \n Code2: public static String md5(String str) { if (logger.isDebugEnabled()) { logger.debug(\"md5(String) - start\"); } try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(str.getBytes()); byte[] b = md.dig",
        "ground_truth": "NO",
        "predict": "est(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < b.length; i++) { sb.append(Integer.toHexString((b[i] & 0xFF) | 0x100).substring(1, 3)); } return sb.toString(); } catch (NoSuchAlgorithmException e) { if (logger.isDebugEnabled()) { logger.debug(\"md5(String) - end\"); } return null; } }. \n Code3: public static String getExtractionDir() { if (logger.isDebugEnabled()) { logger.debug(\"getExtractionDir() - start\"); } String dir = System.getProperty(\"user.dir\"); if (logger.isDebugEnabled()) { logger.debug(\"getExtractionDir() - end\"); } return dir; }. \n Code4: public static void main(String[] args) { LOG.info(\"Starting...\"); }. \n Code5: public static"
    },
    {
        "ID": 280,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void replaceEntityMappings(File signserverearpath, File entityMappingXML) throws ZipException, IOException { ZipInputStream earFile = new ZipInputStream(new FileInputStream(signserverearpath)); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ZipOutputStream tempZip = new ZipOutputStream(baos); ZipEntry next = earFile.getNextEntry(); while (next != null) { ByteArrayOutputStream content = new ByteArrayOutputStream(); byte[] data = new byte[30000]; int numberread; while ((numberread = earFile.read(data)) != -1) { content.write(data, 0, numberread); } if (next.getName().equals(\"signserver-ejb.jar\")) { content = replaceEntityMappings(content, entityMappingXML); next = new ZipEntry(\"signserver-ejb.jar\"); } tempZip.putNextEntry(next); tempZip.write(content.toByteArray()); next = earFile.getNextEntry(); } earFile.close(); tempZip.close(); FileOutputStream fos = new FileOutputStream(signserverearpath); fos.write(baos.toByteArray()); fos.close(); }. \n Code2: public DataSet guessAtUnknowns(String filename) { TasselFileType guess = TasselFileType.Sequence; DataSet tds = null; try { BufferedReader br = null; if (filename.startsWith(\"http\")) { URL url = new URL(filename); br = new BufferedReader(new InputStreamReader(url.openStream())); } else { br = new BufferedReader(new FileReader(filename)); } String line1 = br.readLine().trim(); String[] sval1 = line1.split(\"\\\\s\"); String line2 = br.readLine().trim(); String[] sval2 = line2.split(\"\\\\s\"); boolean lociMatchNumber = false; if (!sval1[0].startsWith(\"<\") && (sval1.length == 2) && (line1.indexOf(':') < 0)) { int countLoci = Integer.parseInt(sval1[1]); if (countLoci == sval2.length) { lociMatchNumber = true; } } if (sval1[0].equalsIgnoreCase(\"<Annotated>\")) { guess = TasselFileType.Annotated; } else if (line1.startsWith(\"<\") || line1.startsWith(\"#\")) { boolean isTrait = false; boolean isMarker = false; boolean isNumeric = false; boolean isMap = false; Pattern tagPattern = Pattern.compile(\"[<>\\\\s]+\"); String[] info1 = tagPattern.split(line1); String[] info2 = tagPattern.split(line2); if (info1.length > 1) { if (info1[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info1[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info1[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info1[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } if (info2.length > 1) { if (info2[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info2[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info2[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info2[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } else { guess = null; String inline = br.readLine(); while (guess == null && inline != null && (inline.startsWith(\"#\") || inline.startsWith(\"<\"))) { if (inline.startsWith(\"<\")) { String[] info = tagPattern.split(inline); if (info[1].toUpperCase().startsWith(\"MARKER\")) { isMarker = true; } else if (info[1].toUpperCase().startsWith(\"TRAIT\")) { isTrait = true; } else if (info[1].toUpperCase().startsWith(\"NUMER\")) { isNumeric = true; } else if (info[1].toUpperCase().startsWith(\"MAP\")) { isMap = true; } } } } if (isTrait || (isMarker && isNumeric)) { guess = TasselFileType.Phenotype; } else if (isMarker) { guess = TasselFileType.Polymorphism; } else if (isMap) { guess = TasselFileType.GeneticMap; } else { throw new IOException(\"Improperly formatted header. Data will not be imported.\"); } } else if ((line1.startsWith(\">\")) || (line1.startsWith(\";\"))) { guess = TasselFileType.Fasta; } else if (sval1.length == 1) { guess = TasselFileType.SqrMatrix; } else if (line1.indexOf(':') > 0) { guess = TasselFileType.Polymorphism; } else if ((sval1.length == 2) && (lociMatchNumber)) { guess = TasselFileType.Polymorphism; } else if ((line1.startsWith(\"#Nexus\")) || (line1.startsWith(\"#NEXUS\")) || (line1.startsWith(\"CLUSTAL\")) || ((sval1.length == 2) && (sval2.length == 2))) { guess = TasselFileType.Sequence; } else if (sval1.length == 3) { guess = TasselFileType.Numerical; } myLogger.info(\"guessAtUnknowns: type: \" + guess); tds = processDatum(filename, guess); br.close(); } catch (Exception e) { } return tds; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String md5(String text) { String encrypted = \"\"; try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(text.getBytes()); encrypted = hex(md.digest()); } catch (NoSuchAlgorithmException nsaEx) { } return encrypted; }. \n Code2: private void unzip(File filename) throws ZipException, IOException { ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename))",
        "ground_truth": "NO",
        "predict": "); ZipEntry entry = in.getNextEntry(); while (entry != null) { if (!entry.isDirectory()) { byte[] buffer = new byte[4096]; int count; while ((count = in.read(buffer)) != -1) { System.out.write(buffer, 0, count); } } entry = in.getNextEntry(); } in.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String hex(byte[] array) { StringBuffer sb = new StringBuffer(); for (int i = 0; i < array.length; ++i) { sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1, 3)); } return sb.toString(); }. \n Code2: public static void main(String[] args) { String filename = \"\";"
    },
    {
        "ID": 286,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void gravaOp(Vector<?> op) { PreparedStatement ps = null; String sql = null; ResultSet rs = null; int seqop = 0; Date dtFabrOP = null; try { sql = \"SELECT MAX(SEQOP) FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { seqop = rs.getInt(1) + 1; } rs.close(); ps.close(); con.commit(); sql = \"SELECT DTFABROP FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, txtSeqOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { dtFabrOP = rs.getDate(1); } rs.close(); ps.close(); con.commit(); sql = \"INSERT INTO PPOP (CODEMP,CODFILIAL,CODOP,SEQOP,CODEMPPD,CODFILIALPD,CODPROD,SEQEST,DTFABROP,\" + \"QTDPREVPRODOP,QTDFINALPRODOP,DTVALIDPDOP,CODEMPLE,CODFILIALLE,CODLOTE,CODEMPTM,CODFILIALTM,CODTIPOMOV,\" + \"CODEMPAX,CODFILIALAX,CODALMOX,CODEMPOPM,CODFILIALOPM,CODOPM,SEQOPM,QTDDISTIOP,QTDSUGPRODOP)\" + \" VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, seqop); ps.setInt(5, Aplicativo.iCodEmp); ps.setInt(6, ListaCampos.getMasterFilial(\"PPESTRUTURA\")); ps.setInt(7, ((Integer) op.elementAt(4)).intValue()); ps.setInt(8, ((Integer) op.elementAt(6)).intValue()); ps.setDate(9, dtFabrOP); ps.setFloat(10, ((BigDecimal) op.elementAt(7)).floatValue()); ps.setFloat(11, 0); ps.setDate(12, (Funcoes.strDateToSqlDate((String) op.elementAt(11)))); ps.setInt(13, Aplicativo.iCodEmp); ps.setInt(14, ListaCampos.getMasterFilial(\"EQLOTE\")); ps.setString(15, ((String) op.elementAt(10))); ps.setInt(16, Aplicativo.iCodEmp); ps.setInt(17, ListaCampos.getMasterFilial(\"EQTIPOMOV\")); ps.setInt(18, buscaTipoMov()); ps.setInt(19, ((Integer) op.elementAt(13)).intValue()); ps.setInt(20, ((Integer) op.elementAt(14)).intValue()); ps.setInt(21, ((Integer) op.elementAt(12)).intValue()); ps.setInt(22, Aplicativo.iCodEmp); ps.setInt(23, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(24, txtCodOP.getVlrInteger().intValue()); ps.setInt(25, txtSeqOP.getVlrInteger().intValue()); ps.setFloat(26, ((BigDecimal) op.elementAt(9)).floatValue()); ps.setFloat(27, ((BigDecimal) op.elementAt(7)).floatValue()); ps.executeUpdate(); ps.close(); con.commit(); geraRMA(seqop); } catch (SQLException e) { Funcoes.mensagemErro(null, \"Erro ao gerar OP's de distribui\ufffd\ufffdo!\\n\" + e.getMessage()); try { con.rollback(); } catch (SQLException eb) { } } }. \n Code2: public void delete(String user) throws FidoDatabaseException { try { Connection conn = null; Statement stmt = null; try { conn = fido.util.FidoDataSource.getConnection(); conn.setAutoCommit(false); stmt = conn.createStatement(); stmt.executeUpdate(\"delete from Principals where PrincipalId = '\" + user + \"'\"); stmt.executeUpdate(\"delete from Roles where PrincipalId = '\" + user + \"'\"); conn.commit(); } catch (SQLException e) { if (conn != null) conn.rollback(); throw e; } finally { if (stmt != null) stmt.close(); if (conn != null) conn.close(); } } catch (SQLException e) { throw new FidoDatabaseException(e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { String code = \"\"; UserFunction function = null; ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\"); try { URL url = new URL(codeBase, directoryAndFile); InputStream in = url.openStream(); BufferedReader inReader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = inReader.readLine()) != null) { code += line + \"\\n\"; } inReader.close(); } catch (Exception e) { Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");",
        "ground_truth": "NO",
        "predict": " } return function; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { try { URL url = new URL(codeBase, directoryAndFile); InputStream in = url.openStream(); BufferedReader inReader = new BufferedReader(new InputStreamReader(in)); String line; while ((line = inReader.readLine()) != null) { } inReader.close(); } catch (Exception e) { Errors.throwMathLibException(\"MFileLoader: m-file exception via web\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { try { URL"
    },
    {
        "ID": 289,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void moveMessage(DBMimeMessage oSrcMsg) throws MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.moveMessage()\"); DebugFile.incIdent(); } JDCConnection oConn = null; PreparedStatement oStmt = null; ResultSet oRSet = null; BigDecimal oPg = null; BigDecimal oPos = null; int iLen = 0; try { oConn = ((DBStore) getStore()).getConnection(); oStmt = oConn.prepareStatement(\"SELECT \" + DB.pg_message + \",\" + DB.nu_position + \",\" + DB.len_mimemsg + \" FROM \" + DB.k_mime_msgs + \" WHERE \" + DB.gu_mimemsg + \"=?\"); oStmt.setString(1, oSrcMsg.getMessageGuid()); oRSet = oStmt.executeQuery(); if (oRSet.next()) { oPg = oRSet.getBigDecimal(1); oPos = oRSet.getBigDecimal(2); iLen = oRSet.getInt(3); } oRSet.close(); oRSet = null; oStmt.close(); oStmt = null; oConn.setAutoCommit(false); oStmt = oConn.prepareStatement(\"UPDATE \" + DB.k_categories + \" SET \" + DB.len_size + \"=\" + DB.len_size + \"-\" + String.valueOf(iLen) + \" WHERE \" + DB.gu_category + \"=?\"); oStmt.setString(1, ((DBFolder) (oSrcMsg.getFolder())).getCategory().getString(DB.gu_category)); oStmt.executeUpdate(); oStmt.close(); oStmt = null; oStmt = oConn.prepareStatement(\"UPDATE \" + DB.k_categories + \" SET \" + DB.len_size + \"=\" + DB.len_size + \"+\" + String.valueOf(iLen) + \" WHERE \" + DB.gu_category + \"=?\"); oStmt.setString(1, getCategory().getString(DB.gu_category)); oStmt.executeUpdate(); oStmt.close(); oStmt = null; oConn.commit(); } catch (SQLException sqle) { if (null != oRSet) { try { oRSet.close(); } catch (Exception ignore) { } } if (null != oStmt) { try { oStmt.close(); } catch (Exception ignore) { } } if (null != oConn) { try { oConn.rollback(); } catch (Exception ignore) { } } throw new MessagingException(sqle.getMessage(), sqle); } if (null == oPg) throw new MessagingException(\"Source message not found\"); if (null == oPos) throw new MessagingException(\"Source message position is not valid\"); DBFolder oSrcFldr = (DBFolder) oSrcMsg.getFolder(); MboxFile oMboxSrc = null, oMboxThis = null; try { oMboxSrc = new MboxFile(oSrcFldr.getFile(), MboxFile.READ_WRITE); oMboxThis = new MboxFile(oSrcFldr.getFile(), MboxFile.READ_WRITE); oMboxThis.appendMessage(oMboxSrc, oPos.longValue(), iLen); oMboxThis.close(); oMboxThis = null; oMboxSrc.purge(new int[] { oPg.intValue() }); oMboxSrc.close(); oMboxSrc = null; } catch (Exception e) { if (oMboxThis != null) { try { oMboxThis.close(); } catch (Exception ignore) { } } if (oMboxSrc != null) { try { oMboxSrc.close(); } catch (Exception ignore) { } } throw new MessagingException(e.getMessage(), e); } try { oConn = ((DBStore) getStore()).getConnection(); BigDecimal dNext = getNextMessage(); String sCatGuid = getCategory().getString(DB.gu_category); oStmt = oConn.prepareStatement(\"UPDATE \" + DB.k_mime_msgs + \" SET \" + DB.gu_category + \"=?,\" + DB.pg_message + \"=? WHERE \" + DB.gu_mimemsg + \"=?\"); oStmt.setString(1, sCatGuid); oStmt.setBigDecimal(2, dNext); oStmt.setString(3, oSrcMsg.getMessageGuid()); oStmt.executeUpdate(); oStmt.close(); oStmt = null; oConn.commit(); } catch (SQLException sqle) { if (null != oStmt) { try { oStmt.close(); } catch (Exception ignore) { } } if (null != oConn) { try { oConn.rollback(); } catch (Exception ignore) { } } throw new MessagingException(sqle.getMessage(), sqle); } if (DebugFile.trace) { DebugFile.decIdent(); DebugFile.writeln(\"End DBFolder.moveMessage()\"); } }. \n Code2: private static boolean insereTutorial(final Connection con, final Tutorial tut, final Autor aut, final Descricao desc) { try { con.setAutoCommit(false); Statement smt = con.createStatement(); if (aut.getCodAutor() == 0) { GeraID.gerarCodAutor(con, aut); smt.executeUpdate(\"INSERT INTO autor VALUES(\" + aut.getCodAutor() + \",'\" + aut.getNome() + \"','\" + aut.getEmail() + \"')\"); } GeraID.gerarCodDescricao(con, desc); GeraID.gerarCodTutorial(con, tut); String titulo = tut.getTitulo().replaceAll(\"['\\\"]\", \"\"); String coment = tut.getComentario().replaceAll(\"[']\", \"\\\"\"); String texto = desc.getTexto().replaceAll(\"[']\", \"\\\"\"); smt.executeUpdate(\"INSERT INTO descricao VALUES(\" + desc.getCodDesc() + \",'\" + texto + \"')\"); smt.executeUpdate(\"INSERT INTO tutorial VALUES(\" + tut.getCodigo() + \",'\" + titulo + \"','\" + coment + \"',\" + desc.getCodDesc() + \")\"); smt.executeUpdate(\"INSERT INTO tut_aut VALUES(\" + tut.getCodigo() + \",\" + aut.getCodAutor() + \")\"); con.commit(); return (true); } catch (SQLException e)",
        "ground_truth": "NO",
        "predict": " { if (con != null) { try { con.rollback(); } catch (Exception ignore) { } } throw new RuntimeException(e); } }. \n Code3: private static boolean insereTutorial(final Connection con, final Tutorial tut, final Autor aut, final Descricao desc) { try { con.setAutoCommit(false); Statement smt = con.createStatement(); if (aut.getCodAutor() == 0) { GeraID.gerarCodAutor(con, aut); smt.executeUpdate(\"INSERT INTO autor VALUES(\" + aut.getCodAutor() + \",'\" + aut.getNome() + \"','\" + aut.getEmail() + \"')\"); } GeraID.gerarCodDescricao(con, desc); GeraID.gerarCodTutorial(con, tut); String titulo = tut.getTitulo().replaceAll(\"['\\\"]\", \"\"); String coment = tut"
    },
    {
        "ID": 290,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static File copyJarToPool(File file) { File outFile = new File(RizzToolConstants.TOOL_POOL_FOLDER.getAbsolutePath() + File.separator + file.getName()); if (file != null && file.exists() && file.canRead()) { try { FileChannel inChan = new FileInputStream(file).getChannel(); FileChannel outChan = new FileOutputStream(outFile).getChannel(); inChan.transferTo(0, inChan.size(), outChan); return outFile; } catch (Exception ex) { RizzToolConstants.DEFAULT_LOGGER.error(\"Exception while copying jar file to tool pool [inFile=\" + file.getAbsolutePath() + \"] [outFile=\" + outFile.getAbsolutePath() + \": \" + ex); } } else { RizzToolConstants.DEFAULT_LOGGER.error(\"Could not copy jar file. File does not exist or can't read file. [inFile=\" + file.getAbsolutePath() + \"]\"); } return null; }. \n Code2: public String doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { if (logger.isDebugEnabled()) { logger.debug(\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - start\"); } t_information_EditMap editMap = new t_information_EditMap(); try { t_information_Form vo = null; vo = (t_information_Form) form; vo.setCompany(vo.getCounty()); if (\"\ufffd\ufffd\ufffd\ufffd\".equals(vo.getInfo_type())) { vo.setInfo_level(null); vo.setAlert_level(null); } String str_postFIX = \"\"; int i_p = 0; editMap.add(vo); try { logger.info(\"\ufffd\ufffd\ufffd\u0379\ufffd\u02fe\ufffd\u9c68\ufffd\ufffd\"); String[] mobiles = request.getParameterValues(\"mobiles\"); vo.setMobiles(mobiles); SMSService.inforAlert(vo); } catch (Exception e) { logger.error(\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\", e); } String filename = vo.getFile().getFileName(); if (null != filename && !\"\".equals(filename)) { FormFile file = vo.getFile(); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = vo.getId(); String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); String strAppend = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); if (file.getFileSize() != 0) { file.getInputStream(); String name = file.getFileName(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); String fullPath = realpath + \"attach/\" + strAppend + str_postFIX; t_attach attach = new t_attach(); attach.setAttach_fullname(fullPath); attach.setAttach_name(name); attach.setInfor_id(Integer.parseInt(inforId)); attach.setInsert_day(new Date()); attach.setUpdate_day(new Date()); t_attach_EditMap attachEdit = new t_attach_EditMap(); attachEdit.add(attach); File sysfile = new File(fullPath); if (!sysfile.exists()) { sysfile.createNewFile(); } java.io.OutputStream out = new FileOutputStream(sysfile); org.apache.commons.io.IOUtils.copy(file.getInputStream(), out); out.close(); } } } catch (HibernateException e) { logger.error(\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\", e); ActionErrors errors = new ActionErrors(); errors.add(\"org.apache.struts.action.GLOBAL_ERROR\", new ActionError(\"error.database.save\", e.toString())); saveErrors(request, errors); e.printStackTrace(); request.setAttribute(\"t_information_Form\", form); if (logger.isDebugEnabled()) { logger.debug(\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - end\"); } return \"addpage\"; } if (logger.isDebugEnabled()) { logger.debug(\"doAdd(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse) - end\"); } return \"aftersave\"; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String senha = \"\"; String email = request.getParameter(\"EmailLogin\"); try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length()); senha = new BigInteger(1, messageDigest.digest()).toString(16); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha); String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\"; if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) { redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\"; } if (usuario.getNome() != null) { HttpSession session = request.getSession(); session.setAttribute(\"usuario\", usuario); redirect = \"index.jsp\"; } response.sendRedirect(redirect); }. \n Code2: public List<String> extractUrlList(String url) throws IOException, XPathExpressionException { LinkedList<String> list = new LinkedList<String>(); HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection(); Tidy tidy",
        "ground_truth": "NO",
        "predict": " = new Tidy(); String html = tidy.parseDOM(new ByteArrayInputStream(conn.getInputStream().toByteArray()), null); XPath xpath = XPathFactory.newInstance().newXPath(); NodeList nodes = (NodeList) xpath.compile(\"//a[@href]\").evaluate(html, XPathConstants.NODESET); for (int i = 0; i < nodes.getLength(); i++) { Element element = (Element) nodes.item(i); String href = element.getAttribute(\"href\"); if (href.indexOf(\"http\") != -1) { list.add(href); } } return list; }. \n */"
    },
    {
        "ID": 291,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setInput(String input, Component caller, FFMpegProgressReceiver recv) throws IOException { inputMedium = null; if (input.contains(\"youtube\")) { URL url = new URL(input); InputStreamReader read = new InputStreamReader(url.openStream()); BufferedReader in = new BufferedReader(read); String inputLine; String line = null; String vid = input.substring(input.indexOf(\"?v=\") + 3); if (vid.indexOf(\"&\") != -1) vid = vid.substring(0, vid.indexOf(\"&\")); while ((inputLine = in.readLine()) != null) { if (inputLine.contains(\"\\\"t\\\": \\\"\")) { line = inputLine.substring(inputLine.indexOf(\"\\\"t\\\": \\\"\") + 6); line = line.substring(0, line.indexOf(\"\\\"\")); break; } } in.close(); if (line == null) throw new IOException(\"Could not find flv-Video\"); Downloader dl = new Downloader(\"http://www.youtube.com/get_video?video_id=\" + vid + \"&t=\" + line, recv, lang); dl.start(); return; } Runtime rt = Runtime.getRuntime(); Process p = rt.exec(new String[] { path, \"-i\", input }); BufferedReader br = new BufferedReader(new InputStreamReader(p.getErrorStream())); String line; Codec videoCodec = null; Codec audioCodec = null; double duration = -1; String aspectRatio = null; String scala = null; String colorSpace = null; String rate = null; String mrate = null; String aRate = null; String aFreq = null; String aChannel = null; try { while ((line = br.readLine()) != null) { if (Constants.debug) System.out.println(line); if (line.contains(\"Duration:\")) { int hours = Integer.parseInt(line.substring(12, 14)); int mins = Integer.parseInt(line.substring(15, 17)); double secs = Double.parseDouble(line.substring(18, line.indexOf(','))); duration = secs + 60 * mins + hours * 60 * 60; Pattern pat = Pattern.compile(\"[0-9]+ kb/s\"); Matcher m = pat.matcher(line); if (m.find()) mrate = line.substring(m.start(), m.end()); } if (line.contains(\"Video:\")) { String info = line.substring(24); String parts[] = info.split(\", \"); Pattern pat = Pattern.compile(\"Video: [a-zA-Z0-9]+,\"); Matcher m = pat.matcher(line); String codec = \"\"; if (m.find()) codec = line.substring(m.start(), m.end()); videoCodec = supportedCodecs.getCodecByName(codec.replace(\"Video: \", \"\").replace(\",\", \"\")); colorSpace = parts[1]; pat = Pattern.compile(\"[0-9]+x[0-9]+\"); m = pat.matcher(info); if (m.find()) scala = info.substring(m.start(), m.end()); pat = Pattern.compile(\"DAR [0-9]+:[0-9]+\"); m = pat.matcher(info); if (m.find()) aspectRatio = info.substring(m.start(), m.end()).replace(\"DAR \", \"\"); else if (scala != null) aspectRatio = String.valueOf((double) (Math.round(((double) ConvertUtils.getWidthFromScala(scala) / (double) ConvertUtils.getHeightFromScala(scala)) * 100)) / 100); pat = Pattern.compile(\"[0-9]+ kb/s\"); m = pat.matcher(info); if (m.find()) rate = info.substring(m.start(), m.end()); } else if (line.contains(\"Audio:\")) { String info = line.substring(24); Pattern pat = Pattern.compile(\"Audio: [a-zA-Z0-9]+,\"); Matcher m = pat.matcher(line); String codec = \"\"; if (m.find()) codec = line.substring(m.start(), m.end()).replace(\"Audio: \", \"\").replace(\",\", \"\"); if (codec.equals(\"mp3\")) codec = \"libmp3lame\"; audioCodec = supportedCodecs.getCodecByName(codec); pat = Pattern.compile(\"[0-9]+ kb/s\"); m = pat.matcher(info); if (m.find()) aRate = info.substring(m.start(), m.end()); pat = Pattern.compile(\"[0-9]+ Hz\"); m = pat.matcher(info); if (m.find()) aFreq = info.substring(m.start(), m.end()); if (line.contains(\"5.1\")) aChannel = \"5.1\"; else if (line.contains(\"2.1\")) aChannel = \"2.1\"; else if (line.contains(\"stereo\")) aChannel = \"Stereo\"; else if (line.contains(\"mono\")) aChannel = \"Mono\"; } if (videoCodec != null && audioCodec != null && duration != -1) { if (rate == null && mrate != null && aRate != null) rate = String.valueOf(ConvertUtils.getRateFromRateString(mrate) - ConvertUtils.getRateFromRateString(aRate)) + \" kb/s\"; inputMedium = new InputMedium(audioCodec, videoCodec, input, duration, colorSpace, aspectRatio, scala, rate, mrate, aRate, aFreq, aChannel); break; } } if ((videoCodec != null || audioCodec != null) && duration != -1) inputMedium = new InputMedium(audioCodec, videoCodec, input, duration, colorSpace, aspectRatio, scala, rate, mrate, aRate, aFreq, aChannel); } catch (Exception exc) { if (caller != null) JOptionPane.showMessageDialog(caller, lang.inputerror + \" Audiocodec? \" + (audioCodec != null) + \" Videocodec? \" + (videoCodec != null), lang.error, JOptionPane.ERROR_MESSAGE); if (Constants.debug) System.out.println(\"Audiocodec: \" + audioCodec + \"\\nVideocodec: \" + videoCodec); if (Constants.debug) exc.printStackTrace(); throw new IOException(\"Input file error\"); } if (inputMedium == null",
        "ground_truth": "NO",
        "predict": ") throw new IOException(\"Input file error\"); }\n\n}\n"
    },
    {
        "ID": 298,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void setupService(MessageContext msgContext) throws Exception { String realpath = msgContext.getStrProp(Constants.MC_REALPATH); String extension = (String) getOption(OPTION_JWS_FILE_EXTENSION); if (extension == null) extension = DEFAULT_JWS_FILE_EXTENSION; if ((realpath != null) && (realpath.endsWith(extension))) { String jwsFile = realpath; String rel = msgContext.getStrProp(Constants.MC_RELATIVE_PATH); File f2 = new File(jwsFile); if (!f2.exists()) { throw new FileNotFoundException(rel); } if (rel.charAt(0) == '/') { rel = rel.substring(1); } int lastSlash = rel.lastIndexOf('/'); String dir = null; if (lastSlash > 0) { dir = rel.substring(0, lastSlash); } String file = rel.substring(lastSlash + 1); String outdir = msgContext.getStrProp(Constants.MC_JWS_CLASSDIR); if (outdir == null) outdir = \".\"; if (dir != null) { outdir = outdir + File.separator + dir; } File outDirectory = new File(outdir); if (!outDirectory.exists()) { outDirectory.mkdirs(); } if (log.isDebugEnabled()) log.debug(\"jwsFile: \" + jwsFile); String jFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"java\"; String cFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"class\"; if (log.isDebugEnabled()) { log.debug(\"jFile: \" + jFile); log.debug(\"cFile: \" + cFile); log.debug(\"outdir: \" + outdir); } File f1 = new File(cFile); String clsName = null; if (clsName == null) clsName = f2.getName(); if (clsName != null && clsName.charAt(0) == '/') clsName = clsName.substring(1); clsName = clsName.substring(0, clsName.length() - extension.length()); clsName = clsName.replace('/', '.'); if (log.isDebugEnabled()) log.debug(\"ClsName: \" + clsName); if (!f1.exists() || f2.lastModified() > f1.lastModified()) { log.debug(Messages.getMessage(\"compiling00\", jwsFile)); log.debug(Messages.getMessage(\"copy00\", jwsFile, jFile)); FileReader fr = new FileReader(jwsFile); FileWriter fw = new FileWriter(jFile); char[] buf = new char[4096]; int rc; while ((rc = fr.read(buf, 0, 4095)) >= 0) fw.write(buf, 0, rc); fw.close(); fr.close(); log.debug(\"javac \" + jFile); Compiler compiler = CompilerFactory.getCompiler(); compiler.setClasspath(ClasspathUtils.getDefaultClasspath(msgContext)); compiler.setDestination(outdir); compiler.addFile(jFile); boolean result = compiler.compile(); (new File(jFile)).delete(); if (!result) { (new File(cFile)).delete(); Document doc = XMLUtils.newDocument(); Element root = doc.createElementNS(\"\", \"Errors\"); StringBuffer message = new StringBuffer(\"Error compiling \"); message.append(jFile); message.append(\":\\n\"); List errors = compiler.getErrors(); int count = errors.size(); for (int i = 0; i < count; i++) { CompilerError error = (CompilerError) errors.get(i); if (i > 0) message.append(\"\\n\"); message.append(\"Line \"); message.append(error.getStartLine()); message.append(\", column \"); message.append(error.getStartColumn()); message.append(\": \"); message.append(error.getMessage()); } root.appendChild(doc.createTextNode(message.toString())); throw new AxisFault(\"Server.compileError\", Messages.getMessage(\"badCompile00\", jFile), null, new Element[] { root }); } ClassUtils.removeClassLoader(clsName); soapServices.remove(clsName); } ClassLoader cl = ClassUtils.getClassLoader(clsName); if (cl == null) { cl = new JWSClassLoader(clsName, msgContext.getClassLoader(), cFile); } msgContext.setClassLoader(cl); SOAPService rpc = (SOAPService) soapServices.get(clsName); if (rpc == null) { rpc = new SOAPService(new RPCProvider()); rpc.setName(clsName); rpc.setOption(RPCProvider.OPTION_CLASSNAME, clsName); rpc.setEngine(msgContext.getAxisEngine()); String allowed = (String) getOption(RPCProvider.OPTION_ALLOWEDMETHODS); if (allowed == null) allowed = \"*\"; rpc.setOption(RPCProvider.OPTION_ALLOWEDMETHODS, allowed); String scope = (String) getOption(RPCProvider.OPTION_SCOPE); if (scope == null) scope = Scope.DEFAULT.getName(); rpc.setOption(RPCProvider.OPTION_SCOPE, scope); rpc.getInitializedServiceDesc(msgContext); soapServices.put(clsName, rpc); } rpc.setEngine(msgContext.getAxisEngine()); rpc.init(); msgContext.setService(rpc); } if (log.isDebugEnabled()) { log.debug(\"Exit: JWSHandler::invoke\"); } }. \n Code2: public static String SHA1(String text) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); md.update(text.getBytes()); byte byteData[] = md.digest(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } StringBuilder hexString = new StringBuilder(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) hexString.append('0'); hexString.append(hex); } return hexString.toString",
        "ground_truth": "NO",
        "predict": "(); }\n}\n"
    },
    {
        "ID": 299,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String generateHash(String message) throws NoSuchAlgorithmException, UnsupportedEncodingException, DigestException { MessageDigest digest; digest = MessageDigest.getInstance(\"SHA-1\"); digest.reset(); digest.update(message.getBytes(\"iso-8859-1\"), 0, message.length()); byte[] output = new byte[20]; digest.digest(output, 0, output.length); return convertToHex(output); }. \n Code2: public MsgRecvInfo[] recvMsg(MsgRecvReq msgRecvReq) throws SQLException { String updateSQL = \" update dyhikemomessages set receive_id = ?, receive_Time = ? where mo_to =? and receive_id =0 limit 20\"; String selectSQL = \" select MOMSG_ID,mo_from,mo_to,create_time,mo_content from dyhikemomessages where receive_id =? \"; String insertSQL = \" insert into t_receive_history select * from dyhikemomessages where receive_id =? \"; String deleteSQL = \" delete from dyhikemomessages where receive_id =? \"; Logger logger = Logger.getLogger(this.getClass()); ArrayList msgInfoList = new ArrayList(); String mo_to = msgRecvReq.getAuthInfo().getUserName(); MsgRecvInfo[] msgInfoArray = new ototype.MsgRecvInfo[0]; String receiveTime = Const.DF.format(new Date()); logger.debug(\"recvMsgNew1\"); Connection conn = null; try { int receiveID = this.getSegquence(\"receiveID\"); conn = this.getJdbcTemplate().getDataSource().getConnection(); conn.setAutoCommit(false); PreparedStatement pstmt = conn.prepareStatement(updateSQL); pstmt.setInt(1, receiveID); pstmt.setString(2, receiveTime); pstmt.setString(3, mo_to); int recordCount = pstmt.executeUpdate(); logger.info(recordCount + \" record(s) got\"); if (recordCount > 0) { pstmt = conn.prepareStatement(selectSQL); pstmt.setInt(1, receiveID); ResultSet rs = pstmt.executeQuery(); while (rs.next()) { MsgRecvInfo msg = new MsgRecvInfo(); msg.setDestMobile(rs.getString(\"mo_to\")); msg.setRecvAddi(rs.getString(\"mo_to\")); msg.setSendAddi(rs.getString(\"MO_FROM\")); msg.setContent(rs.getString(\"mo_content\")); msg.setRecvDate(rs.getString(\"create_time\")); msgInfoList.add(msg); } msgInfoArray = (MsgRecvInfo[]) msgInfoList.toArray(new MsgRecvInfo[msgInfoList.size()]); pstmt = conn.prepareStatement(insertSQL); pstmt.setInt(1, receiveID); pstmt.execute(); pstmt = conn.prepareStatement(deleteSQL); pstmt.setInt(1, receiveID); pstmt.execute(); conn.commit(); } logger.debug(\"recvMsgNew2\"); return msgInfoArray; } catch (SQLException e) { conn.rollback(); throw e; } finally { if (conn != null) { conn.setAutoCommit(true); conn.close(); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static PersistencyParameters parse(String unitName) { URL[] persistenceUnits; try { persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\"); } catch (IOException e) { throw new Error(e); } Set classes = new HashSet(); for (int i = 0; i < persistenceUnits.length; i++) { URL url = persistenceUnits[i]; try { nu.xom.Builder b = new nu.xom.Builder(false); Document d = b.build(url.openStream()); Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\")); for (int j = 0; j < unitNodes.size(); j++) { Node unitNode = unitNodes.get(j); Element unitElt = ((Element) unitNode); String uName = unitElt.getAttributeValue(\"name\"); if (!uName.equals(unitName)) continue; { PersistencyParameters parameters = new PersistencyParameters(); Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\")); for (int k = 0; k < classNodes.size(); k++) { Node classNode = classNodes.get(k); if (!(classNode instanceof Element)) continue; Element classElt = (Element) classNode; String elementName = classElt.getAttribute(\"name\").getValue(); if (elementName.equals(\"eclipselink.jdbc.url\")) { String elementValue = classElt.getAttribute(\"value\").getValue(); parameters.setJdbcUrl(elementValue); } else if (elementName.equals(\"eclipselink.jdbc.user\")) { String elementValue = classElt.getAttribute(\"value\").getValue(); parameters.setDBUserName(elementValue); } else if (elementName.equals(\"eclipselink.jdbc.password\")) { String elementValue = classElt.getAttribute(\"value\").getValue(); parameters.setDBPassword(elementValue); } else if (elementName.equals(\"eclipselink.jdbc.driver\")) { String elementValue = classElt.getAttribute(\"value\").getValue(); parameters.setDBDriverClassName(elementValue); } } return parameters; } } } catch (Exception x) { x.printStackTrace(); throw new Error(x); } } return null; }. \n Code2: public void createVendorSignature() { byte b; try { _vendorMessageDigest = MessageDigest.getInstance(\"MD5\"); _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\"); _vendorSig.initSign((PrivateKey) _vendorPrivateKey); _vendorMessageDigest.update(getBankString().getBytes()); _vendorMessageDigestBytes = _vendorMessageDigest.digest(); _vendorSig.update(_vendorMessageDigestBytes); _vendorSignatureBytes = _vendorSig.sign(); }",
        "ground_truth": "NO",
        "predict": " catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (SignatureException e) { e.printStackTrace(); } }. \n Code2: public void createBankSignature() { byte b; try { _bankMessageDigest = MessageDigest.getInstance(\"MD5\"); _bankSig = Signature.getInstance(\"MD5/RSA/PKCS#1\"); _bankSig.initSign((PrivateKey) _bankPrivateKey); _bankMessageDigest.update(getBankString().getBytes()); _bankMessageDigestBytes = _bankMessageDigest.digest(); _bankSig.update(_bankMessageDigestBytes); _bankSignatureBytes = _bankSig.sign(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch"
    },
    {
        "ID": 313,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { String layerName = args[0]; String layerDescription = args[1]; String units = args[2]; String rawDataDirPath = args[3]; String processDirPath = args[4]; String divaDirPath = args[5]; String legendDirPath = args[6]; String geotiffDirPath = args[7]; String dbJdbcUrl = args[8]; String dbUsername = args[9]; String dbPassword = args[10]; String geoserverUsername = args[11]; String geoserverPassword = args[12]; File rawDataDir = new File(rawDataDirPath); if (!rawDataDir.exists() || !rawDataDir.isDirectory()) { throw new RuntimeException(\"Supplied raw data directory \" + rawDataDirPath + \" does not exist or is not a directory\"); } File processDir = new File(processDirPath); if (!processDir.exists() || !processDir.isDirectory()) { throw new RuntimeException(\"Supplied process directory \" + processDirPath + \" does not exist or is not a directory\"); } File divaDir = new File(divaDirPath); if (!divaDir.exists() || !divaDir.isDirectory()) { throw new RuntimeException(\"Supplied diva directory \" + divaDirPath + \" does not exist or is not a directory\"); } File legendDir = new File(legendDirPath); if (!legendDir.exists() || !legendDir.isDirectory()) { throw new RuntimeException(\"Supplied legend directory \" + legendDirPath + \" does not exist or is not a directory\"); } File geotiffDir = new File(geotiffDirPath); if (!geotiffDir.exists() || !geotiffDir.isDirectory()) { throw new RuntimeException(\"Supplied geotiff directory \" + geotiffDirPath + \" does not exist or is not a directory\"); } System.out.println(\"Beginning environmetal load\"); System.out.println(\"Connecting to database\"); Class.forName(\"org.postgresql.Driver\"); Properties props = new Properties(); props.setProperty(\"user\", dbUsername); props.setProperty(\"password\", dbPassword); Connection conn = DriverManager.getConnection(dbJdbcUrl, props); conn.setAutoCommit(false); try { File layerProcessDir = new File(processDir, layerName); layerProcessDir.mkdir(); System.out.println(\"Running gdalwarp\"); File hdrFile = new File(rawDataDir, \"hdr.adf\"); if (!hdrFile.exists()) { throw new RuntimeException(\"Could not find hdr.adf in \" + rawDataDirPath); } File bilFile = new File(layerProcessDir, layerName + \".bil\"); Process procGdalWarp = Runtime.getRuntime().exec(new String[] { \"gdalwarp\", \"-of\", \"EHdr\", \"-ot\", \"Float32\", hdrFile.getAbsolutePath(), bilFile.getAbsolutePath() }); int gdalWarpReturnVal = procGdalWarp.waitFor(); if (gdalWarpReturnVal != 0) { String gdalWarpErrorOutput = IOUtils.toString(procGdalWarp.getErrorStream()); throw new RuntimeException(\"gdalwarp failed: \" + gdalWarpErrorOutput); } System.out.println(\"Running Bil2diva\"); boolean bil2DivaSuccess = Bil2diva.bil2diva(layerProcessDir.getAbsolutePath() + File.separator + layerName, divaDir.getAbsolutePath() + File.separator + layerName, units); if (!bil2DivaSuccess) { throw new RuntimeException(\"Bil2diva Failed\"); } System.out.println(\"Running GridLegend\"); boolean gridLegendSuccess = GridLegend.generateGridLegend(divaDir.getAbsolutePath() + File.separator + layerName, legendDir.getAbsolutePath() + File.separator + layerName, 1, false); if (!gridLegendSuccess) { throw new RuntimeException(\"GridLegend Failed\"); } System.out.println(\"Running gdal_translate\"); File geotiffFile = new File(geotiffDir, layerName + \".tif\"); Process procGdalTranslate = Runtime.getRuntime().exec(new String[] { \"gdal_translate\", \"-of\", \"GTiff\", bilFile.getAbsolutePath(), geotiffFile.getAbsolutePath() }); int gdalTranslateReturnVal = procGdalTranslate.waitFor(); if (gdalTranslateReturnVal != 0) { String gdalTranslateErrorOutput = IOUtils.toString(procGdalTranslate.getErrorStream()); throw new RuntimeException(\"gdal_translate failed: \" + gdalTranslateErrorOutput); } System.out.println(\"Extracting extents and min/max environmental value from diva .grd file\"); File divaGrd = new File(divaDir, layerName + \".grd\"); if (!divaGrd.exists()) { throw new RuntimeException(\"Could not locate diva .grd file: \" + divaGrd.toString()); } String strDivaGrd = FileUtils.readFileToString(divaGrd); float minValue = Float.parseFloat(matchPattern(strDivaGrd, \"^MinValue=(.+)$\")); float maxValue = Float.parseFloat(matchPattern(strDivaGrd, \"^MaxValue=(.+)$\")); float minLatitude = Float.parseFloat(matchPattern(strDivaGrd, \"^MinY=(.+)$\")); float maxLatitude = Float.parseFloat(matchPattern(strDivaGrd, \"^MaxY=(.+)$\")); float minLongitude = Float.parseFloat(matchPattern(strDivaGrd, \"^MinX=(.+)$\")); float maxLongitude = Float.parseFloat(matchPattern(strDivaGrd, \"^MaxX=(.+)$\")); System.out.println(\"Generating ID for new layer...\"); Statement st = conn.createStatement(); ResultSet rs = st.executeQuery(\"SELECT MAX(id) from layers\"); rs.next(); int id = 1; String idAsString = rs.getString(1); if (idAsString != null) { id = Integer.parseInt(idAsString); id++; } String displayPath = MessageFormat.format(GEOSERVER_QUERY_TEMPLATE, layerName); System.out.println(\"Creating layers table entry...\"); PreparedStatement createLayersStatement = createLayersInsert(conn, id, layerDescription, divaDir.getAbsolutePath(), layerName, displayPath, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue, maxValue, units); createLayersStatement.execute(); System.out.println(\"Creating fields table entry...\"); PreparedStatement",
        "ground_truth": "NO",
        "predict": " createFieldsStatement = createFieldsInsert(conn, id, layerName, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue, maxValue, units); createFieldsStatement.execute(); System.out.println(\"Creating features table entry...\"); PreparedStatement createFeaturesStatement = createFeaturesInsert(conn, id, layerName, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue, maxValue, units); createFeaturesStatement.execute(); System.out.println(\"Creating style table entry...\"); PreparedStatement createStyleStatement = createStyleInsert(conn, id, layerName, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue, maxValue, units); createStyleStatement.execute(); System.out.println(\"Creating style table entry...\"); PreparedStatement createLegendStatement = createLegendInsert(conn, id, layerName, minLatitude, minLongitude, maxLatitude, maxLongitude, minValue"
    },
    {
        "ID": 316,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String getResponseText(String url) throws MalformedURLException, IOException { URL m_url = new URL(url); URLConnection urlCconn = m_url.openConnection(); urlCconn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.16) Gecko/20080702 Firefox/2.0.0.16\"); urlCconn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); urlCconn.setRequestProperty(\"Accept-Language\", \"en-us,en;q=0.5\"); urlCconn.setRequestProperty(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"); urlCconn.setRequestProperty(\"Keep-Alive\", \"300\"); urlCconn.setRequestProperty(\"Connection\", \"keep-alive\"); return IOUtil.toString(urlCconn.getInputStream()); }. \n Code2: public static void main(String[] args) { LogFrame.getInstance(); for (int i = 0; i < args.length; i++) { String arg = args[i]; if (arg.trim().startsWith(DEBUG_PARAMETER_NAME + \"=\")) { properties.put(DEBUG_PARAMETER_NAME, arg.trim().substring(DEBUG_PARAMETER_NAME.length() + 1).trim()); if (properties.getProperty(DEBUG_PARAMETER_NAME).toLowerCase().equals(DEBUG_TRUE)) { DEBUG = true; } } else if (arg.trim().startsWith(AUTOCONNECT_PARAMETER_NAME + \"=\")) { properties.put(AUTOCONNECT_PARAMETER_NAME, arg.trim().substring(AUTOCONNECT_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(SITE_CONFIG_URL_PARAMETER_NAME + \"=\")) { properties.put(SITE_CONFIG_URL_PARAMETER_NAME, arg.trim().substring(SITE_CONFIG_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOCSERVICE_URL_PARAMETER_NAME + \"=\")) { properties.put(DOCSERVICE_URL_PARAMETER_NAME, arg.trim().substring(DOCSERVICE_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOC_ID_PARAMETER_NAME + \"=\")) { properties.put(DOC_ID_PARAMETER_NAME, arg.trim().substring(DOC_ID_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME + \"=\")) { properties.put(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME, arg.trim().substring(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME.length() + 1).trim()); RichUIUtils.setDocServiceProxyFactoryClassname(properties.getProperty(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME)); } else { System.out.println(\"WARNING! Unknown or undefined parameter: '\" + arg.trim() + \"'\"); } } System.out.println(\"Annotation Diff GUI startup parameters:\"); System.out.println(\"------------------------------\"); for (Object propName : properties.keySet()) { System.out.println(propName.toString() + \"=\" + properties.getProperty((String) propName)); } System.out.println(\"------------------------------\"); if (properties.getProperty(SITE_CONFIG_URL_PARAMETER_NAME) == null || properties.getProperty(SITE_CONFIG_URL_PARAMETER_NAME).length() == 0) { String err = \"Mandatory parameter '\" + SITE_CONFIG_URL_PARAMETER_NAME + \"' is missing.\\n\\nApplication will exit.\"; System.out.println(err); JOptionPane.showMessageDialog(new JFrame(), err, \"Error!\", JOptionPane.ERROR_MESSAGE); System.exit(-1); } try { String context = System.getProperty(CONTEXT); if (context == null || \"\".equals(context)) { context = DEFAULT_CONTEXT; } String s = System.getProperty(GateConstants.GATE_HOME_PROPERTY_NAME); if (s == null || s.length() == 0) { File f = File.createTempFile(\"foo\", \"\"); String gateHome = f.getParent().toString() + context; f.delete(); System.setProperty(GateConstants.GATE_HOME_PROPERTY_NAME, gateHome); f = new File(System.getProperty(GateConstants.GATE_HOME_PROPERTY_NAME)); if (!f.exists()) { f.mkdirs(); } } s = System.getProperty(GateConstants.PLUGINS_HOME_PROPERTY_NAME); if (s == null || s.length() == 0) { System.setProperty(GateConstants.PLUGINS_HOME_PROPERTY_NAME, System.getProperty(GateConstants.GATE_HOME_PROPERTY_NAME) + \"/plugins\"); File f = new File(System.getProperty(GateConstants.PLUGINS_HOME_PROPERTY_NAME)); if (!f.exists()) { f.mkdirs(); } } s = System.getProperty(GateConstants.GATE_SITE_CONFIG_PROPERTY_NAME); if (s == null || s.length() == 0) { System.setProperty(GateConstants.GATE_SITE_CONFIG_PROPERTY_NAME, System.getProperty(GateConstants.GATE_HOME_PROPERTY_NAME) + \"/gate.xml\"); } if (properties.getProperty(SITE_CONFIG_URL_PARAMETER_NAME) != null && properties.getProperty(SITE_CONFIG_URL_PARAMETER_NAME).length() > 0) { File f = new File(System.getProperty(GateConstants.GATE_SITE_CONFIG_PROPERTY_NAME)); if (f.exists()) { f.delete",
        "ground_truth": "NO",
        "predict": "(); } } } catch (Exception e) { e.printStackTrace(); } }\n"
    },
    {
        "ID": 319,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void addEMInformation() { try { long emDate = System.currentTimeMillis(); if (_local == true) { File emFile = new File(\"emprotz.dat\"); if (!emFile.exists()) { return; } emDate = emFile.lastModified(); } if (emDate > this._emFileDate) { this._emFileDate = emDate; this._emDate = emDate; for (int ii = 0; ii < this._projectInfo.size(); ii++) { Information info = getInfo(ii); if (info != null) { info._emDeadline = null; info._emFrames = null; info._emValue = null; } } Reader reader = null; if (_local == true) { reader = new FileReader(\"emprotz.dat\"); } else { StringBuffer urlName = new StringBuffer(); urlName.append(\"http://home.comcast.net/\"); urlName.append(\"~wxdude1/emsite/download/\"); urlName.append(\"emprotz.zip\"); try { URL url = new URL(urlName.toString()); InputStream stream = url.openStream(); ZipInputStream zip = new ZipInputStream(stream); zip.getNextEntry(); reader = new InputStreamReader(zip); } catch (MalformedURLException mue) { mue.printStackTrace(); } } BufferedReader file = new BufferedReader(reader); try { String line1 = null; int count = 0; while ((line1 = file.readLine()) != null) { String line2 = (line1 != null) ? file.readLine() : null; String line3 = (line2 != null) ? file.readLine() : null; String line4 = (line3 != null) ? file.readLine() : null; count++; if ((count > 1) && (line1 != null) && (line2 != null) && (line3 != null) && (line4 != null)) { if (line1.length() > 2) { int posBegin = line1.indexOf(\"\\\"\", 0); int posEnd = line1.indexOf(\"\\\"\", posBegin + 1); if ((posBegin >= 0) && (posEnd >= 0)) { String project = line1.substring(posBegin + 1, posEnd - posBegin); int projectNum = Integer.parseInt(project); Integer deadline = Integer.valueOf(line2.trim()); Double value = Double.valueOf(line3.trim()); Integer frames = Integer.valueOf(line4.trim()); Information info = getInfo(projectNum); if (info == null) { info = createInfo(projectNum); } if (info._emValue == null) { info._emDeadline = deadline; info._emFrames = frames; info._emValue = value; } } } } } } catch (Exception e) { e.printStackTrace(); } finally { file.close(); } } } catch (FileNotFoundException e) { } catch (IOException e) { } }. \n Code2: public static synchronized void repartition(File[] sourceFiles, File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception { if (!targetDirectory.exists()) { if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create directory \" + targetDirectory.getAbsolutePath()); } File tmpFile = new File(targetDirectory, \"tmp.fasta\"); FileOutputStream fos = new FileOutputStream(tmpFile); FileChannel fco = fos.getChannel(); for (File file : sourceFiles) { FileInputStream fis = new FileInputStream(file); FileChannel fci = fis.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(64000); while (fci.read(buffer) > 0) { buffer.flip(); fco.write(buffer); buffer.clear(); } fci.close(); } fco.close(); FastaFile fastaFile = new FastaFile(tmpFile); fastaFile.split(targetDirectory, prefix, maxUnitBases, maxUnitEntries); tmpFile.delete(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception { URL url = null; HttpURLConnection conn = null; InputStream istream = null; try { url = new URL(urlLocation); conn = (HttpURLConnection) url.openConnection(); } catch (Exception e) { throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage()); } loadCookies(urlLocation, conn, c); if (headers != null) { for (int i = 0; i < headers.size(); i++) { String header = (String) headers.get(i); String key = header.substring(0, header.indexOf(\":\")); String value = header.substring(header.indexOf(\":\") + 2); Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\"); conn.setRequestProperty(key, value); } } Debug.debug(\"Set to use GET, URL=\" + urlLocation); try { istream = conn.getInputStream(); } catch (Exception e) { Debug.debug(\"Unable to capture input stream: \" + e.getMessage()); throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage()); } Debug.debug(\"'GET' - Got input stream.\"); if (conn.getContentLength() == -1) { Debug.debug(\"Content length = unknown\"); } else { Debug.debug(\"Content length = \" + conn.getContentLength()); } byte data[] = null; int curPos = 0, contentLength = conn.getContentLength(); if (conn.getContentLength() == -1) { String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\"); if (byteSize == null) { contentLength = 4096; } else { contentLength = Integer.parseInt(byteSize); } Debug.debug(\"Content length unknown. Allowing fuzz of \" + contentLength + \" bytes.\"); } data = new byte[contentLength]; try { int dataRead = 0; while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) { if (dataRead == 0) { break; } curPos += dataRead; } } catch (Exception e) { throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage()); } try { istream.close(); conn.disconnect(); } catch (MalformedURLException e) { throw new Exception(\"Soap request to site '\"",
        "ground_truth": "NO",
        "predict": " + urlLocation + \"' failed: \" + e.getMessage()); } catch (IOException e) { throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed: \" + e.getMessage()); } }. \n Code3: public static synchronized void loadCookies(String urlLocation, HttpURLConnection conn, RenderEngine c) throws Exception { if (conn.getURL().getProtocol().equals(\"https\")) { String cookie = c.getCookie(urlLocation); if (cookie != null) { conn.setRequestProperty(\"Cookie\", cookie); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setCookie(String cookie) { this._cookie = cookie; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1"
    },
    {
        "ID": 329,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void runTask(HashMap pjobParms) throws Exception { FTPClient lftpClient = null; FileOutputStream lfosTargetFile = null; JBJFPluginDefinition lpluginCipher = null; IJBJFPluginCipher theCipher = null; try { JBJFFTPDefinition lxmlFTP = null; if (getFTPDefinition() != null) { lxmlFTP = getFTPDefinition(); this.mstrSourceDirectory = lxmlFTP.getSourceDirectory(); this.mstrTargetDirectory = lxmlFTP.getTargetDirectory(); this.mstrFilename = lxmlFTP.getFilename(); this.mstrRemoteServer = lxmlFTP.getServer(); if (getResources().containsKey(\"plugin-cipher\")) { lpluginCipher = (JBJFPluginDefinition) getResources().get(\"plugin-cipher\"); } if (lpluginCipher != null) { theCipher = getTaskPlugins().getCipherPlugin(lpluginCipher.getPluginId()); } if (theCipher != null) { this.mstrServerUsr = theCipher.decryptString(lxmlFTP.getUser()); this.mstrServerPwd = theCipher.decryptString(lxmlFTP.getPass()); } else { this.mstrServerUsr = lxmlFTP.getUser(); this.mstrServerPwd = lxmlFTP.getPass(); } } else { throw new Exception(\"Work unit [ \" + SHORT_NAME + \" ] is missing an FTP Definition. Please check\" + \" your JBJF Batch Definition file an make sure\" + \" this work unit has a <resource> element added\" + \" within the <task> element.\"); } lfosTargetFile = new FileOutputStream(mstrTargetDirectory + File.separator + mstrFilename); lftpClient = new FTPClient(); lftpClient.connect(mstrRemoteServer); lftpClient.setFileType(lxmlFTP.getFileTransferType()); if (!FTPReply.isPositiveCompletion(lftpClient.getReplyCode())) { throw new Exception(\"FTP server [ \" + mstrRemoteServer + \" ] refused connection.\"); } if (!lftpClient.login(mstrServerUsr, mstrServerPwd)) { throw new Exception(\"Unable to login to server [ \" + mstrTargetDirectory + \" ].\"); } if (!lftpClient.changeWorkingDirectory(mstrSourceDirectory)) { throw new Exception(\"Unable to change to remote directory [ \" + mstrSourceDirectory + \"]\"); } lftpClient.enterLocalPassiveMode(); if (!lftpClient.retrieveFile(mstrFilename, lfosTargetFile)) { throw new Exception(\"Unable to download [ \" + mstrSourceDirectory + \"/\" + mstrFilename + \" to \" + mstrTargetDirectory + File.separator + mstrFilename + \" ] from server [ \" + mstrRemoteServer + \" ]\"); } lfosTargetFile.close(); lftpClient.logout(); } catch (Exception e) { throw e; } finally { if (lftpClient != null && lftpClient.isConnected()) { try { lftpClient.disconnect(); } catch (IOException ioe) { } } if (lfosTargetFile != null) { try { lfosTargetFile.close(); } catch (Exception e) { } } } }. \n Code2: public static String MD5(String str) { try { MessageDigest md5 = MessageDigest.getInstance(\"md5\"); md5.update(str.getBytes(), 0, str.length()); String sig = new BigInteger(1, md5.digest()).toString(); return sig; } catch (NoSuchAlgorithmException e) { System.err.println(\"Can not use md5 algorithm\"); } return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void populateResources() throws BasicException { try { List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage()); if (templates.size() == 0) { templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\"); } for (URL url : templates) { String fileName = url.getFile(); fileName = fileName.substring(fileName.lastIndexOf('/') + 1); if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) { Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4)); InputStream is = url.openStream(); StringBuffer strBuff = new StringBuffer(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String str; while ((str = br.readLine()) != null) { strBuff.append(str + \"\\n\"); } templateResource.setText(strBuff.toString()); templateResource.save(); } } } catch (MalformedURLException e1) { logger.error(\"Unable to load templates\", e1); } catch (IOException e1) { logger.error(\"Unable to load templates\", e1); } String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } }; for (int i = 0; i < images.length; i++) { Image img = new Image(); img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1]))); img.save(); Property imgProperty = new Property(images[i][0]); imgProperty.setValue(\"\" + img.getId()); imgProperty.save(); } }. \n Code2: public HttpResponseExchange execute() throws Exception { HttpResponseExchange forwardResponse = null; int fetchSizeLimit = Config.getInstance().getFetchLimitSize(); while (null != lastContentRange) { forwardRequest.setBody(new byte[0]); ContentRangeHeaderValue old = lastContentRange; long sendSize = fetchSizeLimit; if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) { sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1); } if (sendSize <= 0) { break; } lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength()); forwardRequest.",
        "ground_truth": "NO",
        "predict": "setHeader(\"Content-Range\", lastContentRange.toString()); forwardRequest.setHeader(\"Content-Length\", \"\" + sendSize); forwardRequest.setHeader(\"Content-Type\", \"application/octet-stream\"); forwardRequest.setHeader(\"Connection\", \"close\"); forwardRequest.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + mstrFilename + \"\\\"\"); forwardRequest.setHeader(\"Content-Transfer-Encoding\", \"binary\"); forwardRequest.setHeader(\"Expires\", \"0\"); forwardRequest.setHeader(\"Pragma\", \"no-cache\"); forwardRequest.setHeader(\"Cache-Control\", \"no-cache\"); forwardRequest.setHeader(\"Cache-Control\", \"no-store\"); forwardRequest.setHeader(\"Cache-Control\", \"must-revalidate\"); forwardRequest.setHeader(\"Cache-Control\", \"post-check=0\"); forwardRequest.setHeader(\"Cache-Control\", \"pre-check=0\"); forwardRequest.setHeader(\"Cache-"
    },
    {
        "ID": 330,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public void verRecordatorio() { try { cantidadArchivos = obtenerCantidad() + 1; boolean existe = false; String filenametxt = \"\"; String filenamezip = \"\"; String hora = \"\"; String lugar = \"\"; String actividad = \"\"; String linea = \"\"; int dia = 0; int mes = 0; int ano = 0; for (int i = 1; i < cantidadArchivos; i++) { filenamezip = \"recordatorio\" + i + \".zip\"; filenametxt = \"recordatorio\" + i + \".txt\"; BufferedOutputStream dest = null; BufferedInputStream is = null; ZipEntry entry; ZipFile zipfile = new ZipFile(filenamezip); Enumeration e = zipfile.entries(); while (e.hasMoreElements()) { entry = (ZipEntry) e.nextElement(); is = new BufferedInputStream(zipfile.getInputStream(entry)); int count; byte data[] = new byte[buffer]; FileOutputStream fos = new FileOutputStream(entry.getName()); dest = new BufferedOutputStream(fos, buffer); while ((count = is.read(data, 0, buffer)) != -1) dest.write(data, 0, count); dest.flush(); dest.close(); is.close(); } DataInputStream input = new DataInputStream(new FileInputStream(filenametxt)); dia = Integer.parseInt(input.readLine()); mes = Integer.parseInt(input.readLine()); ano = Integer.parseInt(input.readLine()); if (dia == Integer.parseInt(identificarDato(datoSeleccionado))) { existe = true; hora = input.readLine(); lugar = input.readLine(); while ((linea = input.readLine()) != null) actividad += linea + \"\\n\"; verRecordatorioInterfaz(hora, lugar, actividad); hora = \"\"; lugar = \"\"; actividad = \"\"; } input.close(); } if (!existe) JOptionPane.showMessageDialog(null, \"No existe un recordatorio guardado\\n\" + \"para el \" + identificarDato(datoSeleccionado) + \" de \" + meses[mesTemporal].toLowerCase() + \" del a\ufffdo \" + anoTemporal, \"No existe\", JOptionPane.INFORMATION_MESSAGE); table.clearSelection(); } catch (Exception e) { JOptionPane.showMessageDialog(null, \"Error en: \" + e.toString(), \"Error\", JOptionPane.ERROR_MESSAGE); } }. \n Response:",
        "ground_truth": "NO",
        "predict": " public void verRecordatorioInterfaz(String hora, String lugar, String actividad) { JOptionPane.showMessageDialog(null, \"Recordatorio guardado en:\\n\" + hora + \"\\n\" + lugar + \"\\n\" + actividad, \"Recordatorio\", JOptionPane.INFORMATION_MESSAGE); }. \n Code3: public void verRecordatorioInterfaz(String hora, String lugar, String actividad) { try { String filename = \"recordatorio\" + cantidadArchivos + \".zip\"; BufferedOutputStream dest = null; BufferedInputStream is = null; ZipEntry entry; ZipFile zipfile = new ZipFile(filename); Enumeration e = zipfile.entries(); while (e.hasMoreElements()) { entry = (ZipEntry) e.nextElement(); is = new BufferedInputStream(zipfile.getInputStream(entry)); int count;"
    },
    {
        "ID": 333,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void generateSchema() { ConsoleOutputWindow console = DefaultXPontusWindowImpl.getInstance().getConsole(); MessagesWindowDockable mconsole = (MessagesWindowDockable) console.getDockableById(MessagesWindowDockable.DOCKABLE_ID); ByteArrayOutputStream bao = new ByteArrayOutputStream(); IDocumentContainer container = (IDocumentContainer) DefaultXPontusWindowImpl.getInstance().getDocumentTabContainer().getCurrentDockable(); try { SchemaGenerationModel model = view.getModel(); boolean isValid = transformationIsValid(model); if (!isValid) { return; } DefaultXPontusWindowImpl.getInstance().getStatusBar().setMessage(\"Generating schema...\"); view.setVisible(false); InputFormat inFormat = null; OutputFormat of = null; if (model.getInputType().equalsIgnoreCase(\"RELAX NG Grammar\")) { inFormat = new SAXParseInputFormat(); } else if (model.getInputType().equalsIgnoreCase(\"RELAX NG Compact Grammar\")) { inFormat = new CompactParseInputFormat(); } else if (model.getInputType().equalsIgnoreCase(\"DTD\")) { inFormat = new DtdInputFormat(); } else if (model.getInputType().equalsIgnoreCase(\"XML\")) { inFormat = new XmlInputFormat(); } if (model.getOutputType().equalsIgnoreCase(\"DTD\")) { of = new DtdOutputFormat(); } else if (model.getOutputType().equalsIgnoreCase(\"Relax NG Grammar\")) { of = new RngOutputFormat(); } else if (model.getOutputType().equalsIgnoreCase(\"XML Schema\")) { of = new XsdOutputFormat(); } else if (model.getOutputType().equalsIgnoreCase(\"Relax NG Compact Grammar\")) { of = new RncOutputFormat(); } ErrorHandlerImpl eh = new ErrorHandlerImpl(bao); SchemaCollection sc = null; if (!view.getModel().isUseExternalDocument()) { JTextComponent jtc = DefaultXPontusWindowImpl.getInstance().getDocumentTabContainer().getCurrentEditor(); if (jtc == null) { XPontusComponentsUtils.showErrorMessage(\"No document opened!!!\"); DefaultXPontusWindowImpl.getInstance().getStatusBar().setMessage(\"Error generating schema, Please see the messages window!\"); return; } String suffixe = model.getOutputType().toLowerCase(); File tmp = File.createTempFile(\"schemageneratorhandler\", +System.currentTimeMillis() + \".\" + suffixe); OutputStream m_outputStream = new FileOutputStream(tmp); CharsetDetector detector = new CharsetDetector(); detector.setText(jtc.getText().getBytes()); Writer m_writer = new OutputStreamWriter(m_outputStream, \"UTF-8\"); IOUtils.copy(detector.detect().getReader(), m_writer); IOUtils.closeQuietly(m_writer); try { sc = inFormat.load(UriOrFile.toUri(tmp.getAbsolutePath()), new String[0], model.getOutputType().toLowerCase(), eh); } catch (Exception ife) { ife.printStackTrace(); StrBuilder stb = new StrBuilder(); stb.append(\"\\nError loading input document!\\n\"); stb.append(\"Maybe the input type is invalid?\\n\"); stb.append(\"Please check again the input type list or trying validating your document\\n\"); throw new Exception(stb.toString()); } tmp.deleteOnExit(); } else { try { sc = inFormat.load(UriOrFile.toUri(view.getModel().getInputURI()), new String[0], model.getOutputType().toLowerCase(), eh); } catch (Exception ife) { StrBuilder stb = new StrBuilder(); stb.append(\"\\nError loading input document!\\n\"); stb.append(\"Maybe the input type is invalid?\\n\"); stb.append(\"Please check again the input type list or trying validating your document\\n\"); throw new Exception(stb.toString()); } } OutputDirectory od = new LocalOutputDirectory(sc.getMainUri(), new File(view.getModel().getOutputURI()), model.getOutputType().toLowerCase(), DEFAULT_OUTPUT_ENCODING, DEFAULT_LINE_LENGTH, DEFAULT_INDENT); of.output(sc, od, new String[0], model.getInputType().toLowerCase(), eh); mconsole.println(\"Schema generated sucessfully!\"); DefaultXPontusWindowImpl.getInstance().getStatusBar().setMessage(\"Schema generated sucessfully!\"); if (model.isOpenInEditor()) { XPontusComponentsUtils.showWarningMessage(\"The document will NOT be opened in the editor sorry for that!\\n You need to open it yourself.\"); } } catch (Exception ex) { DefaultXPontusWindowImpl.getInstance().getStatusBar().setMessage(\"Error generating schema, Please see the messages window!\"); StringWriter sw = new StringWriter(); PrintWriter ps = new PrintWriter(sw); ex.printStackTrace(ps); StrBuilder sb = new StrBuilder(); sb.append(\"Error generating schema\"); sb.appendNewLine(); sb.append(new String(bao.toByteArray())); sb.appendNewLine(); if (ex instanceof SAXParseException) { SAXParseException spe = (SAXParseException) ex; sb.append(\"Error around line \" + spe.getLineNumber()); sb.append(\", column \" + spe.getColumnNumber()); sb.appendNewLine(); } sb.append(sw.toString()); mconsole.println(sb.toString(), OutputDockable.RED_STYLE); logger.error(sb.toString()); try { ps.flush(); ps.close(); sw.flush(); sw.close(); } catch (IOException ioe) { logger.error(ioe.getMessage()); } } finally { console.setFocus(MessagesWindowDockable.DOCKABLE_ID); Toolkit.getDefaultToolkit().beep(); } }. \n Code2: private void downloadPage(final URL url, final File file) { try { long size = 0; final byte[] buffer = new byte[BotUtil.BUFFER_SIZE]; final File tempFile = new File(file.getParentFile(), \"temp.tmp\"); int length; int lastUpdate = 0; FileOutputStream fos = new FileOutputStream(tempFile); final InputStream is = url.openStream(); do { length = is.read(buffer); if (length >= 0) { fos.write(buffer, 0, length); size += length; } if (lastUpdate > UPDATE_TIME) { report(0, (int) (size",
        "ground_truth": "YES",
        "predict": " / 1024), (int) (size % 1024), (int) (size / 1024), (int) (size % 1024), (int) (size / 1024), (int) (size % 1024)); } lastUpdate = System.currentTimeMillis(); } while (length >= 0); fos.close(); is.close(); } catch (IOException e) { } }\n Code3: private void report(final int total, final int done, final int totalDone, final int totalDoneDone, final int totalDoneDoneDone, final int totalDoneDoneDoneDone, final int totalDoneDoneDoneDone) { try { final StringBuilder sb = new StringBuilder(); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); sb.append(\"\\n\"); s"
    },
    {
        "ID": 340,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void process(String dir) { String[] list = new File(dir).list(); if (list == null) return; int n = list.length; long[] bubblesort = new long[list.length + 1]; if (!statustext) { IJ.log(\"Current Directory is: \" + dir); IJ.log(\" \"); IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick); IJ.log(\" \"); } for (int i = 0; i < n; i++) { IJ.showStatus(i + \"/\" + n); File f = new File(dir + list[i]); if (!f.isDirectory()) { ImagePlus img = new Opener().openImage(dir, list[i]); if (img != null && img.getStackSize() == 1) { if (!scoutengine(img)) return; if (!statustext) { IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase); } int lastDigit = whichcase.length() - 1; while (lastDigit > 0) { if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break; } if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1); bubblesort[i] = Long.parseLong(whichcase); } } } if (statussorta || statussortd || statustext) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (statussorta) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } else { if (bubblesort[i] < bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } } IJ.log(\" \"); for (int i = 0; i < n; i++) { if (!statustext) { IJ.log(list[i] + \" / \" + bubblesort[i]); } else { IJ.log(dir + list[i]); } } } if (open_as_stack || only_images) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } if (only_images) { Opener o = new Opener(); int counter = 0; IJ.log(\" \"); for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; else { ImagePlus imp = o.openImage(path); counter++; if (imp != null) { IJ.log(counter + \" + \" + path); imp.show(); } else IJ.log(counter + \" - \" + path); } } return; } int width = 0, height = 0, type = 0; ImageStack stack = null; double min = Double.MAX_VALUE; double max = -Double.MAX_VALUE; int k = 0; try { for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; if (list[i].endsWith(\".txt\")) continue; ImagePlus imp = new Opener().openImage(path); if (imp != null && stack == null) { width = imp.getWidth(); height = imp.getHeight(); type = imp.getType(); ColorModel cm = imp.getProcessor().getColorModel(); if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm); } if (stack != null) k = stack.getSize() + 1; IJ.showStatus(k + \"/\" + n); IJ.showProgress((double) k / n); if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else { ImageProcessor ip = imp.getProcessor(); if (grayscale) ip = ip.convertToByte(true); if (halfSize) ip = ip.resize(width / 2, height / 2); if (ip.getMin() < min) min = ip.getMin(); if (ip.getMax() > max) max = ip.getMax(); String label = imp.getTitle(); String info = (String) imp.getProperty(\"Info\"); if (info != null) label += \"\\n\" + info; stack.addSlice(label, ip); } System.gc(); } } catch (OutOfMemoryError e) { IJ.outOfMemory(\"FolderOpener\"); stack.trim(); } if (stack != null && stack.getSize() > 0) { ImagePlus imp2 = new ImagePlus(\"Stack\", stack); if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max); imp2.show(); } IJ.showProgress(1.0); } }. \n Code2: public static String SHA1(String text) { try { MessageDigest md; md = MessageDigest.getInstance(\"SHA-1\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (UnsupportedEnc",
        "ground_truth": "NO",
        "predict": "odingException e) { throw new RuntimeException(e); } }\n Code3: public static String convertToHex(byte[] data) { StringBuffer buf = new StringBuffer(); for (int i = 0; i < data.length; i++) { int halfbyte = (data[i] >>> 4) & 0x0F; int two_halfs = 0; int upper = 0; int lower = 0; if (halfbyte == 0) { upper = data[i]; } else { two_halfs = 1; upper &= (data[i] >>> 4); lower = data[i] & 0x0F; } char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; char[] hex = new char[2]; hex[0] = hexChars[halfbyte];"
    },
    {
        "ID": 341,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward uploadFile(ActionMapping mapping, ActionForm actForm, HttpServletRequest request, HttpServletResponse in_response) { ActionMessages errors = new ActionMessages(); ActionMessages messages = new ActionMessages(); String returnPage = \"submitPocketSampleInformationPage\"; UploadForm form = (UploadForm) actForm; Integer shippingId = null; try { eHTPXXLSParser parser = new eHTPXXLSParser(); String proposalCode; String proposalNumber; String proposalName; String uploadedFileName; String realXLSPath; if (request != null) { proposalCode = (String) request.getSession().getAttribute(Constants.PROPOSAL_CODE); proposalNumber = String.valueOf(request.getSession().getAttribute(Constants.PROPOSAL_NUMBER)); proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = form.getRequestFile().getFileName(); String fileName = proposalName + \"_\" + uploadedFileName; realXLSPath = request.getRealPath(\"\\\\tmp\\\\\") + \"\\\\\" + fileName; FormFile f = form.getRequestFile(); InputStream in = f.getInputStream(); File outputFile = new File(realXLSPath); if (outputFile.exists()) outputFile.delete(); FileOutputStream out = new FileOutputStream(outputFile); while (in.available() != 0) { out.write(in.read()); out.flush(); } out.flush(); out.close(); } else { proposalCode = \"ehtpx\"; proposalNumber = \"1\"; proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = \"ispyb-template41.xls\"; realXLSPath = \"D:\\\\\" + uploadedFileName; } FileInputStream inFile = new FileInputStream(realXLSPath); parser.retrieveShippingId(realXLSPath); shippingId = parser.getShippingId(); String requestShippingId = form.getShippingId(); if (requestShippingId != null && !requestShippingId.equals(\"\")) { shippingId = new Integer(requestShippingId); } ClientLogger.getInstance().debug(\"uploadFile for shippingId \" + shippingId); if (shippingId != null) { Log.debug(\" ---[uploadFile] Upload for Existing Shipment (DewarTRacking): Deleting Samples from Shipment :\"); double nbSamplesContainers = DBAccess_EJB.DeleteAllSamplesAndContainersForShipping(shippingId); if (nbSamplesContainers > 0) parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained Samples and/or Containers\", \"Previous Samples and/or Containers have been deleted and replaced by new ones.\")); else parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained no Samples and no Containers\", \"Samples and Containers have been added.\")); } Hashtable<String, Hashtable<String, Integer>> listProteinAcronym_SampleName = new Hashtable<String, Hashtable<String, Integer>>(); ProposalFacadeLocal proposal = ProposalFacadeUtil.getLocalHome().create(); ProteinFacadeLocal protein = ProteinFacadeUtil.getLocalHome().create(); CrystalFacadeLocal crystal = CrystalFacadeUtil.getLocalHome().create(); ProposalLightValue targetProposal = (ProposalLightValue) (((ArrayList) proposal.findByCodeAndNumber(proposalCode, new Integer(proposalNumber))).get(0)); ArrayList listProteins = (ArrayList) protein.findByProposalId(targetProposal.getProposalId()); for (int p = 0; p < listProteins.size(); p++) { ProteinValue prot = (ProteinValue) listProteins.get(p); Hashtable<String, Integer> listSampleName = new Hashtable<String, Integer>(); CrystalLightValue listCrystals[] = prot.getCrystals(); for (int c = 0; c < listCrystals.length; c++) { CrystalLightValue _xtal = (CrystalLightValue) listCrystals[c]; CrystalValue xtal = crystal.findByPrimaryKey(_xtal.getPrimaryKey()); BlsampleLightValue listSamples[] = xtal.getBlsamples(); for (int s = 0; s < listSamples.length; s++) { BlsampleLightValue sample = listSamples[s]; listSampleName.put(sample.getName(), sample.getBlSampleId()); } } listProteinAcronym_SampleName.put(prot.getAcronym(), listSampleName); } parser.validate(inFile, listProteinAcronym_SampleName, targetProposal.getProposalId()); List listErrors = parser.getValidationErrors(); List listWarnings = parser.getValidationWarnings(); if (listErrors.size() == 0) { parser.open(realXLSPath); if (parser.getCrystals().size() == 0) { parser.getValidationErrors().add(new XlsUploadException(\"No crystals have been found\", \"Empty shipment\")); } } Iterator errIt = listErrors.iterator(); while (errIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) errIt.next(); errors.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveErrors(request, errors); } catch (Exception e) { } Iterator warnIt = listWarnings.iterator(); while (warnIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) warnIt.next(); messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveMessages(request, messages); } catch (Exception e) { } if (listErrors.size() > 0) { resetCounts(shippingId); return mapping.findForward(\"submitPocketSampleInformationPage\"); } if (listWarnings.size() > 0) returnPage = \"submitPocketSampleInformationPage\"; String crystalDetailsXML; XtalDetails xtalDetailsWebService = new XtalDetails(); CrystalDetailsBuilder cDE = new CrystalDetailsBuilder(); CrystalDetailsElement cd = cDE.createCrystalDetailsElement(proposalName, parser.getCrystals()); cDE.validateJAXBObject(cd); crystalDetailsXML = cDE.marshallJaxBObjToString(cd); xtalDetailsWebService.submitCrystalDetails(crystalDetailsXML); String diffractionPlan; DiffractionPlan diffractionPlanWebService = new DiffractionPlan(); DiffractionPlanBuilder dPB = new Diff",
        "ground_truth": "NO",
        "predict": "ractionPlanBuilder(); DiffractionPlanElement dPE = dPB.createDiffractionPlanElement(proposalName, parser.getCrystals()); dPB.validateJAXBObject(dPE); diffractionPlan = dPB.marshallJaxBObjToString(dPE); diffractionPlanWebService.submitDiffractionPlan(diffractionPlan); return mapping.findForward(returnPage); } catch (Exception e) { return mapping.findForward(\"submitPocketSampleInformationPage\"); } }\n"
    },
    {
        "ID": 345,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Boolean decompress(File source, File destination) { FileOutputStream outputStream; ZipInputStream inputStream; try { outputStream = null; inputStream = new ZipInputStream(new FileInputStream(source)); int read; byte buffer[] = new byte[BUFFER_SIZE]; ZipEntry zipEntry; while ((zipEntry = inputStream.getNextEntry()) != null) { if (zipEntry.isDirectory()) new File(destination, zipEntry.getName()).mkdirs(); else { File fileEntry = new File(destination, zipEntry.getName()); fileEntry.getParentFile().mkdirs(); outputStream = new FileOutputStream(fileEntry); while ((read = inputStream.read(buffer, 0, BUFFER_SIZE)) != -1) { outputStream.write(buffer, 0, read); } outputStream.flush(); outputStream.close(); } } inputStream.close(); } catch (Exception oException) { return false; } return true; }. \n Code2: public GeocodeResponse getGKCoordinateFromAddress(SearchAddressRequest searchAddressRequest) { GeocodeResponse result = null; String adress = null; if (searchAddressRequest.getAdressTextField() != null) adress = searchAddressRequest.getAdressTextField().getText(); if (adress == null || adress.length() == 0) adress = \" \"; String postRequest = \"\"; postRequest = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> \\n\" + \"<xls:XLS xmlns:xls=\\\"http://www.opengis.net/xls\\\" xmlns:sch=\\\"http://www.ascc.net/xml/schematron\\\" xmlns:gml=\\\"http://www.opengis.net/gml\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.opengis.net/xls \\n\" + \"http://gdi3d.giub.uni-bonn.de:8080/openls-lus/schemas/LocationUtilityService.xsd\\\" version=\\\"1.1\\\"> \\n\" + \" <xls:RequestHeader srsName=\\\"EPSG:\" + Navigator.getEpsg_code() + \"\\\"/> \\n\" + \" <xls:Request methodName=\\\"GeocodeRequest\\\" requestID=\\\"123456789\\\" version=\\\"1.1\\\"> \\n\" + \" <xls:GeocodeRequest> \\n\" + \" <xls:Address countryCode=\\\"DE\\\"> \\n\" + \" <xls:freeFormAddress>\" + adress + \"</xls:freeFormAddress> \\n\" + \" </xls:Address> \\n\" + \" </xls:GeocodeRequest> \\n\" + \" </xls:Request> \\n\" + \"</xls:XLS> \\n\"; if (Navigator.isVerbose()) { System.out.println(\"OpenLSGeocoder postRequest \" + postRequest); } String errorMessage = \"\"; try { System.out.println(\"contacting \" + serviceEndPoint); URL u = new URL(serviceEndPoint); HttpURLConnection urlc = (HttpURLConnection) u.openConnection(); urlc.setReadTimeout(Navigator.TIME_OUT); urlc.setAllowUserInteraction(false); urlc.setRequestMethod(\"POST\"); urlc.setRequestProperty(\"Content-Type\", \"application/xml\"); urlc.setDoOutput(true); urlc.setDoInput(true); urlc.setUseCaches(false); PrintWriter xmlOut = null; xmlOut = new java.io.PrintWriter(urlc.getOutputStream()); xmlOut.write(postRequest); xmlOut.flush(); xmlOut.close(); InputStream is = urlc.getInputStream(); result = new GeocodeResponse(); XLSDocument xlsResponse = XLSDocument.Factory.parse(is); XLSType xlsTypeResponse = xlsResponse.getXLS(); Node node0 = xlsTypeResponse.getDomNode(); NodeList nodes1 = node0.getChildNodes(); for (int i = 0; i < nodes1.getLength(); i++) { Node node1 = nodes1.item(i); NodeList nodes2 = node1.getChildNodes(); for (int j = 0; j < nodes2.getLength(); j++) { Node node2 = nodes2.item(j); NodeList nodes3 = node2.getChildNodes(); for (int k = 0; k < nodes3.getLength(); k++) { Node node3 = nodes3.item(k); String nodeName = node3.getNodeName(); if (nodeName.equalsIgnoreCase(\"xls:GeocodeResponseList\")) { net.opengis.xls.GeocodeResponseListDocument gcrld = net.opengis.xls.GeocodeResponseListDocument.Factory.parse(node3); net.opengis.xls.GeocodeResponseListType geocodeResponseList = gcrld.getGeocodeResponseList(); result.setGeocodeResponseList(geocodeResponseList); } } } } is.close(); } catch (java.net.ConnectException ce) { JOptionPane.showMessageDialog(null, \"no connection to geocoder\", \"Connection Error\", JOptionPane.ERROR_MESSAGE); } catch (SocketTimeoutException ste) { ste.printStackTrace(); errorMessage += \"<p>Time Out Exception, Server is not responding</p>\"; } catch (IOException ioe) { ioe.printStackTrace(); errorMessage += \"<p>IO Exception</p>\"; } catch (XmlException xmle) { xmle.printStackTrace(); errorMessage += \"<p>Error occured during parsing the XML response</p>\"; } if (!errorMessage.equals(\"\")) { System.out.println(\"\\nerrorMessage: \" + errorMessage + \"\\n\\n\"); JLabel label1 = new JLabel(\"<html><head><style type=\\\"text/css\\\"><!--.Stil2 {font-size: 10px;font-weight: bold;}--></style></head><body><span class=\\\"Stil2\\\">Geocoder Error</span></body></html>\"); JLabel label2 = new JLabel(\"<html><head><style type=\\\"text/css\\\"><!--.Stil2 {font-size: 10px;font-weight: normal;}--></style></head><body><span class=\\\"Stil2\\\">\" + \"<br>\" + errorMessage + \"<br>\" + \"<p>please check Java console. If problem persits, please report to system manager</p>\" + \"</span></body></html>\"); Object[] objects = {",
        "ground_truth": "NO",
        "predict": " label1, label2 }; JOptionPane.showOptionDialog(null, objects, \"Geocoder Error\", JOptionPane.DEFAULT_OPTION, JOptionPane.ERROR_MESSAGE, null, null, null); } return result; }\n"
    },
    {
        "ID": 353,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean actualizarIdPartida(int idJugadorDiv, int idRonda, int idPartida) { int intResult = 0; String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPartida = \" + idPartida + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda; try { connection = conexionBD.getConnection(); connection.setAutoCommit(false); ps = connection.prepareStatement(sql); intResult = ps.executeUpdate(); connection.commit(); } catch (SQLException ex) { ex.printStackTrace(); try { connection.rollback(); } catch (SQLException exe) { exe.printStackTrace(); } } finally { conexionBD.close(ps); conexionBD.close(connection); } return (intResult > 0); }. \n Code2: public boolean consolidateCrossrefGet(BiblioItem bib, ArrayList<BiblioItem> bib2) throws Exception { boolean result = false; String doi = bib.getDOI(); String aut = bib.getFirstAuthorSurname(); String title = bib.getTitle(); String firstPage = null; String pageRange = bib.getPageRange(); int beginPage = bib.getBeginPage(); if (beginPage != -1) { firstPage = \"\" + beginPage; } else if (pageRange != null) { StringTokenizer st = new StringTokenizer(pageRange, \"--\"); if (st.countTokens() == 2) { firstPage = st.nextToken(); } else if (st.countTokens() == 1) firstPage = pageRange; } if (aut != null) { aut = TextUtilities.removeAccents(aut); } if (title != null) { title = TextUtilities.removeAccents(title); } if (doi != null) { if (doi.startsWith(\"doi:\") | doi.startsWith(\"DOI:\")) { doi.substring(4, doi.length()); doi = doi.trim(); } doi = doi.replace(\" \", \"\"); String xml = null; if (cCon != null) { PreparedStatement pstmt = null; try { pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL3); pstmt.setString(1, doi); ResultSet res = pstmt.executeQuery(); if (res.next()) { xml = res.getString(1); } res.close(); pstmt.close(); } catch (SQLException se) { System.err.println(\"EXCEPTION HANDLING CROSSREF CACHE\"); throw new GROBIDServiceException(\"EXCEPTION HANDLING CROSSREF CACHE.\", se); } finally { try { if (pstmt != null) pstmt.close(); } catch (SQLException se) { } } if (xml != null) { InputSource is = new InputSource(); is.setCharacterStream(new StringReader(xml)); DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(is, crossref); if (bib2.size() > 0) { if (!bib2.get(0).getError()) result = true; } } } if (xml == null) { String subpath = String.format(DOI_BASE_QUERY, crossref_id, crossref_pw, doi); URL url = new URL(\"http://\" + crossref_host + \"/\" + subpath); System.out.println(\"Sending: \" + url.toString()); HttpURLConnection urlConn = null; try { urlConn = (HttpURLConnection) url.openConnection(); } catch (Exception e) { this.setProxy(); try { urlConn = (HttpURLConnection) url.openConnection(); } catch (Exception e2) { urlConn = null; throw new GROBIDServiceException(\"An exception occured while running Grobid.\", e2); } } if (urlConn != null) { try { urlConn.setDoOutput(true); urlConn.setDoInput(true); urlConn.setRequestMethod(\"GET\"); urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); InputStream in = urlConn.getInputStream(); xml = TextUtilities.convertStreamToString(in); InputSource is = new InputSource(); is.setCharacterStream(new StringReader(xml)); DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(is, crossref); if (bib2.size() > 0) { if (!bib2.get(0).getError()) result = true; } urlConn.disconnect(); } catch (Exception e) { System.err.println(\"Warning: Consolidation set true, \" + \"but the online connection to Crossref fails.\"); } if (cCon != null) { PreparedStatement pstmt2 = null; try { pstmt2 = cCon.prepareStatement(INSERT_CROSSREF_SQL3); pstmt2.setString(1, doi); pstmt2.setString(2, xml); pstmt2.executeUpdate(); pstmt2.close(); } catch (SQLException se) { System.err.println(\"EXCEPTION HANDLING CROSSREF UPDATE\"); } finally { try { if (pstmt2 != null) pstmt2.close(); } catch (SQLException se) { } } } } } } else if ((title != null) & (aut != null)) { String xml = null; if (cCon != null) { PreparedStatement pstmt = null; try { pstmt = cCon.prepareStatement(QUERY_CROSSREF_SQL); pstmt.setString(1, aut); pstmt.setString(2, title); ResultSet res = pstmt.executeQuery(); if (res.next()) { xml = res.getString(1); } res.close(); pstmt.close(); } catch (SQLException se) { throw new GROBIDServiceException(\"EXCEPTION HANDLING CROSSREF CACHE\", se); } finally { try { if (pstmt != null) pstmt.close(); } catch (SQLException se) { } } if (xml != null) { InputSource is = new InputSource(); is.setCharacterStream(new StringReader(xml)); DefaultHandler crossref = new crossrefUnixrefSaxParser(bib2); SAXP",
        "ground_truth": "NO",
        "predict": "arserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(is, crossref); if (bib2.size() > 0) { if (!bib2.get(0).getError()) result = true; } } } } return result; }\n"
    },
    {
        "ID": 363,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void upgradeSchema() throws IOException { Statement stmt = null; try { int i = getSchema(); if (i < SCHEMA_VERSION) { conn.setAutoCommit(false); stmt = conn.createStatement(); while (i < SCHEMA_VERSION) { String qry; switch(i) { case 1: qry = \"CREATE TABLE log (id INTEGER PRIMARY KEY, context VARCHAR(16) NOT NULL, level VARCHAR(16) NOT NULL, time LONG INT NOT NULL, msg LONG VARCHAR NOT NULL, parent INT)\"; stmt.executeUpdate(qry); qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; case 2: qry = \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status INTEGER NOT NULL)\"; stmt.executeUpdate(qry); qry = \"UPDATE settings SET val = '3' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; case 3: qry = \"CREATE TABLE favs (id INTEGER PRIMARY KEY NOT NULL)\"; stmt.executeUpdate(qry); qry = \"UPDATE settings SET val = '4' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; case 4: qry = \"DROP TABLE log\"; stmt.executeUpdate(qry); qry = \"UPDATE settings SET val = '5' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; case 5: qry = \"UPDATE settings SET val = '120000' WHERE var = 'SleepTime'\"; stmt.executeUpdate(qry); qry = \"UPDATE settings set val = '6' WHERE var = 'schema'\"; stmt.executeUpdate(qry); break; } i++; } conn.commit(); } } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e2) { LOG.trace(SQL_ERROR, e2); LOG.error(e2); } LOG.trace(SQL_ERROR, e); LOG.fatal(e); throw new IOException(\"Error upgrading data store\", e); } finally { try { if (stmt != null) { stmt.close(); } conn.setAutoCommit(true); } catch (SQLException e) { LOG.trace(SQL_ERROR, e); throw new IOException(\"Unable to cleanup SQL resources\", e); } } }. \n Code2: private static String scramble(String text) { try { MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); md.update(text.getBytes(\"UTF-8\")); StringBuffer sb = new StringBuffer(); for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16)); return sb.toString(); } catch (UnsupportedEncodingException e) { return null; } catch (NoSuchAlgorithmException e) { return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) { Connection conexion = null; PreparedStatement select = null; PreparedStatement update = null; ResultSet rs = null; boolean exito = false; try { conexion = pool.getConnection(); conexion.setAutoCommit(false); select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\"); update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\"); String codigoProd; int filasAfectadas = 0; Iterator<String> iterador = carro.keySet().iterator(); while (iterador.hasNext()) { codigoProd = iterador.next(); select.setString(1, codigoProd); rs = select.executeQuery(); if (rs.next() == false) { Tools.anadirMensaje(request, \"No existe el producto con codigo: \" + codigoProd + \"(producto eliminado de la cesta)\"); iterador.remove(); conexion.rollback(); } else { Producto prod = new Producto(rs.getString(\"Codigo\"), rs.getString(\"Nombre\"), rs.getDouble(\"Precio\"), rs.getInt(\"Stock\"), rs.getString(\"Descripcion\"), rs.getString(\"Detalles\")); select.clearParameters(); if (carro.get(codigoProd) > prod.getStock()) { Tools.anadirMensaje(request, \"No hay unidades suficientes de: \" + prod.getNombre() + \"(producto eliminado de la cesta)\"); iterador.remove(); conexion.rollback(); } else { update.setInt(1, prod.getStock() - carro.get(codigoProd)); update.setString(2, codigoProd); filasAfectadas = update.executeUpdate(); if (filasAfectadas != 1) { Tools.anadirMensaje(request, \"Ocurrio un error en el catalogo\"); conexion.rollback(); } update.clearParameters(); listado.put(prod, carro.get(codigoProd)); } } } conexion.commit(); exito = true; } catch (SQLException ex) { logger.log(Level.SEVERE, \"Error actualizando unidades de productos en compra\", ex); try { conexion.rollback(); } catch (SQLException ex1) { logger.log(Level.SEVERE, \"Error haciendo rolback de la transacci\u00f3n que ha dado error en la actualizaci\u00f3n de unidades por compra\", ex1); } } finally { cerrarConexionYStatement(conexion, select, update); cerrarResultSet(rs); } return exito; }. \n Code2: public static void main(String[] args) throws Exception { if (args.length != 2) { System.out.println(\"Usage: URLDumper <URL> <file>\"); System.exit(1); } String location = args[0]; String file = args[1]; URL url = new URL(location); FileOutputStream fos = new FileOutputStream(file); byte[] bytes = new byte[4096]; InputStream is = url.openStream(); int read; while ((read = is.read(bytes)) != -1) { fos.write(bytes, 0, read",
        "ground_truth": "NO",
        "predict": "); } fos.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public boolean updateProductIfAvailable(Map<String, Integer> carro, HttpServletRequest request, Map<Producto, Integer> listado) { Connection conexion = null; PreparedStatement select = null; PreparedStatement update = null; ResultSet rs = null; boolean exito = false; try { conexion = pool.getConnection(); conexion.setAutoCommit(false); select = conexion.prepareStatement(\"SELECT* FROM \" + nameBD + \".Productos WHERE Codigo=?\"); update = conexion.prepareStatement(\"UPDATE \" + nameBD + \".Productos SET Stock=? WHERE Codigo=?\"); String codigoProd; int filasAfectadas = 0; Iterator<String> iterador = carro."
    },
    {
        "ID": 376,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void refreshMods(String modsUrl) { while (true) { JMenuItem mi = mnMods.getItem(mnMods.getItemCount() - 1); if (mi == null) break; mnMods.remove(mnMods.getItemCount() - 1); } try { log.info(\"Loading mods from \" + modsUrl); URL url = new URL(modsUrl); URLConnection conn = url.openConnection(); conn.setUseCaches(false); SAXReader reader = new SAXReader(); Document document = reader.read(conn.getInputStream()); Element root = document.getRootElement(); for (Iterator i = root.elementIterator(\"mod\"); i.hasNext(); ) { final Element mod = (Element) i.next(); JMenuItem mi = new JMenuItem(mod.element(\"name\").getTextTrim()); mi.setIcon(Application.icon(\"applications-other\")); mi.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { Application.getInstance().openUrl(mod.element(\"siteUrl\").getTextTrim()); } }); mnMods.add(mi); } } catch (Throwable t) { t.printStackTrace(); log.warn(\"Failed to dynamically add mod links\"); } }. \n Code2: public void process(String dir) { String[] list = new File(dir).list(); if (list == null) return; int n = list.length; long[] bubblesort = new long[list.length + 1]; if (!statustext) { IJ.log(\"Current Directory is: \" + dir); IJ.log(\" \"); IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick); IJ.log(\" \"); } for (int i = 0; i < n; i++) { IJ.showStatus(i + \"/\" + n); File f = new File(dir + list[i]); if (!f.isDirectory()) { ImagePlus img = new Opener().openImage(dir, list[i]); if (img != null && img.getStackSize() == 1) { if (!scoutengine(img)) return; if (!statustext) { IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase); } int lastDigit = whichcase.length() - 1; while (lastDigit > 0) { if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break; } if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1); bubblesort[i] = Long.parseLong(whichcase); } } } if (statussorta || statussortd || statustext) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (statussorta) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } else { if (bubblesort[i] < bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } } IJ.log(\" \"); for (int i = 0; i < n; i++) { if (!statustext) { IJ.log(list[i] + \" / \" + bubblesort[i]); } else { IJ.log(dir + list[i]); } } } if (open_as_stack || only_images) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } if (only_images) { Opener o = new Opener(); int counter = 0; IJ.log(\" \"); for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; else { ImagePlus imp = o.openImage(path); counter++; if (imp != null) { IJ.log(counter + \" + \" + path); imp.show(); } else IJ.log(counter + \" - \" + path); } } return; } int width = 0, height = 0, type = 0; ImageStack stack = null; double min = Double.MAX_VALUE; double max = -Double.MAX_VALUE; int k = 0; try { for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; if (list[i].endsWith(\".txt\")) continue; ImagePlus imp = new Opener().openImage(path); if (imp != null && stack == null) { width = imp.getWidth(); height = imp.getHeight(); type = imp.getType(); ColorModel cm = imp.getProcessor().getColorModel(); if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm); } if (stack != null) k = stack.getSize() + 1; IJ.showStatus(k + \"/\" + n); IJ.showProgress((double) k / n); if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else { ImageProcessor ip = imp.getProcessor(); if (grayscale) ip = ip.convertToByte(true); if (halfSize) ip = ip.resize(width / 2, height / 2); if (ip.getMin() < min) min = ip.getMin(); if (ip.getMax()",
        "ground_truth": "NO",
        "predict": " > max) max = ip.getMax(); if (stack != null) stack.addSlice(list[i], ip); } } } catch (Throwable t) { t.printStackTrace(); } if (stack != null) { if (stack.getSize() > 1) stack.setColorModel(new ColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), new int[] { 8 }, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE)); else stack.setColorModel(new ColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), new int[] { 8 }, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE)); } if (statustext) { IJ.log(\" \"); IJ.log(\"DICOM File Name / \" + prefix1 + \"/\" + prefix2 + \"/\" + prefix3 + \"/\" + pick); IJ.log(\" \"); I"
    },
    {
        "ID": 387,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.B64InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: static synchronized Person lookup(PhoneNumber number, String siteName) { Vector<Person> foundPersons = new Vector<Person>(5); if (number.isFreeCall()) { Person p = new Person(\"\", \"FreeCall\"); p.addNumber(number); foundPersons.add(p); } else if (number.isSIPNumber() || number.isQuickDial()) { Person p = new Person(); p.addNumber(number); foundPersons.add(p); } else if (ReverseLookup.rlsMap.containsKey(number.getCountryCode())) { nummer = number.getAreaNumber(); rls_list = ReverseLookup.rlsMap.get(number.getCountryCode()); Debug.info(\"Begin reverselookup for: \" + nummer); if (nummer.startsWith(number.getCountryCode())) nummer = nummer.substring(number.getCountryCode().length()); city = \"\"; for (int i = 0; i < rls_list.size(); i++) { yield(); rls = rls_list.get(i); if (!siteName.equals(\"\") && !siteName.equals(rls.getName())) { Debug.warning(\"This lookup should be done using a specific site, skipping\"); continue; } prefix = rls.getPrefix(); ac_length = rls.getAreaCodeLength(); if (!nummer.startsWith(prefix)) nummer = prefix + nummer; urlstr = rls.getURL(); if (urlstr.contains(\"$AREACODE\")) { urlstr = urlstr.replaceAll(\"\\\\$AREACODE\", nummer.substring(prefix.length(), ac_length + prefix.length())); urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer.substring(prefix.length() + ac_length)); } else if (urlstr.contains(\"$PFXAREACODE\")) { urlstr = urlstr.replaceAll(\"\\\\$PFXAREACODE\", nummer.substring(0, prefix.length() + ac_length)); urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer.substring(prefix.length() + ac_length)); } else urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer); Debug.info(\"Reverse lookup using: \" + urlstr); url = null; data = new String[dataLength]; try { url = new URL(urlstr); if (url != null) { try { con = url.openConnection(); con.setConnectTimeout(5000); con.setReadTimeout(15000); con.addRequestProperty(\"User-Agent\", userAgent); con.connect(); header = \"\"; charSet = \"\"; for (int j = 0; ; j++) { String headerName = con.getHeaderFieldKey(j); String headerValue = con.getHeaderField(j); if (headerName == null && headerValue == null) { break; } if (\"content-type\".equalsIgnoreCase(headerName)) { String[] split = headerValue.split(\";\", 2); for (int k = 0; k < split.length; k++) { if (split[k].trim().toLowerCase().startsWith(\"charset=\")) { String[] charsetSplit = split[k].split(\"=\"); charSet = charsetSplit[1].trim(); } } } header += headerName + \": \" + headerValue + \" | \"; } Debug.debug(\"Header of \" + rls.getName() + \":\" + header); Debug.debug(\"CHARSET : \" + charSet); BufferedReader d; if (charSet.equals(\"\")) { d = new BufferedReader(new InputStreamReader(con.getInputStream(), \"ISO-8859-1\")); } else { d = new BufferedReader(new InputStreamReader(con.getInputStream(), charSet)); } int lines = 0; while (null != ((str = d.readLine()))) { data[lines] = str; yield(); if (lines >= dataLength) { System.err.println(\"Result > \" + dataLength + \" Lines\"); break; } lines++; } d.close(); Debug.info(\"Begin processing response from \" + rls.getName()); for (int j = 0; j < rls.size(); j++) { yield(); firstname = \"\"; lastname = \"\"; company = \"\"; street = \"\"; zipcode = \"\"; city = \"\"; Person p = null; patterns = rls.getEntry(j); Pattern namePattern = null; Pattern streetPattern = null; Pattern cityPattern = null; Pattern zipcodePattern = null; Pattern firstnamePattern = null; Pattern lastnamePattern = null; Matcher nameMatcher = null; Matcher streetMatcher = null; Matcher cityMatcher = null; Matcher zipcodeMatcher = null; Matcher firstnameMatcher = null; Matcher lastnameMatcher = null; if (!patterns[ReverseLookupSite.NAME].equals(\"\") && (patterns[ReverseLookupSite.FIRSTNAME].equals(\"\") && patterns[ReverseLookupSite.LASTNAME].equals(\"\"))) { namePattern = Pattern.compile(patterns[ReverseLookupSite.NAME]); } if (!patterns[ReverseLookupSite.STREET].equals(\"\")) { streetPattern = Pattern.compile(patterns[ReverseLookupSite.STREET]); } if (!patterns[ReverseLookupSite.CITY].equals(\"\")) { cityPattern = Pattern.compile(patterns[ReverseLookupSite.CITY]); } if (!patterns[ReverseLookupSite.ZIPCODE].equals(\"\")) { zipcodePattern = Pattern.compile(patterns[ReverseLookupSite.ZIPCODE]); } if (!patterns[ReverseLookupSite.FIRSTNAME].equals(\"\")) { firstnamePattern = Pattern.",
        "ground_truth": "NO",
        "predict": "compile(patterns[ReverseLookupSite.FIRSTNAME]); } if (!patterns[ReverseLookupSite.LASTNAME].equals(\"\")) { lastnamePattern = Pattern.compile(patterns[ReverseLookupSite.LASTNAME]); } if (namePattern != null) { nameMatcher = namePattern.matcher(str); } if (streetPattern != null) { streetMatcher = streetPattern.matcher(str); } if (cityPattern != null) { cityMatcher = cityPattern.matcher(str); } if (zipcodePattern != null) { zipcodeMatcher = zipcodePattern.matcher(str); } if (firstnamePattern != null) { firstnameMatcher = firstnamePattern.matcher(str); } if (lastnamePattern != null) { lastnameMatcher = lastnamePattern.matcher(str); } if (nameMatcher != null && nameMatcher.find()) { firstname ="
    },
    {
        "ID": 389,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ProgramSymbol createNewProgramSymbol(int programID, String module, String symbol, int address, int size) throws AdaptationException { ProgramSymbol programSymbol = null; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { String query = \"INSERT INTO ProgramSymbols \" + \"(programID, module, symbol, address, size)\" + \" VALUES (\" + programID + \", '\" + module + \"', '\" + symbol + \"', \" + address + \", \" + size + \")\"; connection = DriverManager.getConnection(CONN_STR); statement = connection.createStatement(); statement.executeUpdate(query); query = \"SELECT * FROM ProgramSymbols WHERE \" + \"programID = \" + programID + \" AND \" + \"module = '\" + module + \"' AND \" + \"symbol = '\" + symbol + \"'\"; resultSet = statement.executeQuery(query); if (!resultSet.next()) { connection.rollback(); String msg = \"Attempt to create program symbol failed.\"; log.error(msg); throw new AdaptationException(msg); } programSymbol = getProgramSymbol(resultSet); connection.commit(); } catch (SQLException ex) { try { connection.rollback(); } catch (Exception e) { } String msg = \"SQLException in createNewProgramSymbol\"; log.error(msg, ex); throw new AdaptationException(msg, ex); } finally { try { resultSet.close(); } catch (Exception ex) { } try { statement.close(); } catch (Exception ex) { } try { connection.close(); } catch (Exception ex) { } } return programSymbol; }. \n Code2: public static boolean copyFileCover(String srcFileName, String descFileName, boolean coverlay) { File srcFile = new File(srcFileName); if (!srcFile.exists()) { System.out.println(\"\u590d\u5236\u6587\u4ef6\u5931\u8d25\uff0c\u6e90\u6587\u4ef6\" + srcFileName + \"\u4e0d\u5b58\u5728!\"); return false; } else if (!srcFile.isFile()) { System.out.println(\"\u590d\u5236\u6587\u4ef6\u5931\u8d25\uff0c\" + srcFileName + \"\u4e0d\u662f\u4e00\u4e2a\u6587\u4ef6!\"); return false; } File descFile = new File(descFileName); if (descFile.exists()) { if (coverlay) { System.out.println(\"\u76ee\u6807\u6587\u4ef6\u5df2\u5b58\u5728\uff0c\u51c6\u5907\u5220\u9664!\"); if (!FileOperateUtils.delFile(descFileName)) { System.out.println(\"\u5220\u9664\u76ee\u6807\u6587\u4ef6\" + descFileName + \"\u5931\u8d25!\"); return false; } } else { System.out.println(\"\u590d\u5236\u6587\u4ef6\u5931\u8d25\uff0c\u76ee\u6807\u6587\u4ef6\" + descFileName + \"\u5df2\u5b58\u5728!\"); return false; } } else { if (!descFile.getParentFile().exists()) { System.out.println(\"\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u76ee\u5f55\u4e0d\u5b58\u5728\uff0c\u521b\u5efa\u76ee\u5f55!\"); if (!descFile.getParentFile().mkdirs()) { System.out.println(\"\u521b\u5efa\u76ee\u6807\u6587\u4ef6\u6240\u5728\u7684\u76ee\u5f55\u5931\u8d25!\"); return false; } } } int readByte = 0; InputStream ins = null; OutputStream outs = null; try { ins = new FileInputStream(srcFile); outs = new FileOutputStream(descFile); byte[] buf = new byte[1024]; while ((readByte = ins.read(buf)) != -1) { outs.write(buf, 0, readByte); } System.out.println(\"\u590d\u5236\u5355\u4e2a\u6587\u4ef6\" + srcFileName + \"\u5230\" + descFileName + \"\u6210\u529f!\"); return true; } catch (Exception e) { System.out.println(\"\u590d\u5236\u6587\u4ef6\u5931\u8d25\uff1a\" + e.getMessage()); return false; } finally { if (outs != null) { try { outs.close(); } catch (IOException oute) { oute.printStackTrace(); } } if (ins != null) { try { ins.close(); } catch (IOException ine) { ine.printStackTrace(); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void handleHandshake(Packet2Handshake par1Packet2Handshake) { boolean flag = true; String s = par1Packet2Handshake.username; if (s == null || s.trim().length() == 0) { flag = false; } else if (!s.equals(\"-\")) { try { Long.parseLong(s, 16); } catch (NumberFormatException numberformatexception) { flag = false; } } if (!flag) { netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" }); } else if (par1Packet2Handshake.username.equals(\"-\")) { addToSendQueue(new Packet1Login(mc.session.username, 29)); } else { try { URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString()); BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(url.openStream())); String s1 = bufferedreader.readLine(); bufferedreader.close(); if (s1.equalsIgnoreCase(\"ok\")) { addToSendQueue(new Packet1Login(mc.session.username, 29)); } else { netManager.networkShutdown(\"disconnect.loginFailedInfo\", new Object[] { s1 }); } } catch (Exception exception) { exception.printStackTrace(); netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { (new StringBuilder()).append(\"Internal client error: \").append(exception.toString()).toString() }); } } }. \n Code2: private void downloadFile(File target, String s3key) throws IOException, S3ServiceException { InputStream in = downloadData(s3key); if (in == null) { throw new IOException(\"No data found\"); } in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEnc",
        "ground_truth": "NO",
        "predict": "ryptor(s3key))); FileOutputStream out = new FileOutputStream(target); byte[] buffer = new byte[1024]; int len; while ((len = in.read(buffer)) > 0) { out.write(buffer, 0, len); } out.close(); in.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void handlePacket250Packet(Packet250CustomPayload packet) { if (packet.channel.equals(\"REGISTER\")) { String s = packet.data; if (s.equals(\"-\")) { addToSendQueue(new Packet1Login(mc.session.username, 29)); } else { try { URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append"
    },
    {
        "ID": 390,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setDefaultMailBox(final int domainId, final int userId) { final EmailAddress defaultMailbox = cmDB.getDefaultMailbox(domainId); try { connection.setAutoCommit(false); new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) { @Override public void executeProcessReturnNull() throws SQLException { psImpl = connImpl.prepareStatement(sqlCommands.getProperty(defaultMailbox == null ? \"domain.setDefaultMailbox\" : \"domain.updateDefaultMailbox\")); if (defaultMailbox == null) { psImpl.setInt(1, domainId); psImpl.setInt(2, userId); } else { psImpl.setInt(1, userId); psImpl.setInt(2, domainId); } psImpl.executeUpdate(); } }); connection.commit(); cmDB.updateDomains(null, null); } catch (SQLException sqle) { log.error(sqle); if (connection != null) { try { connection.rollback(); } catch (SQLException ex) { } } } finally { if (connection != null) { try { connection.setAutoCommit(true); } catch (SQLException ex) { } } } }. \n Code2: public int executeUpdateJT(String sql, Object[][] paramsList) { Connection connection = null; connection = this.getConnection(); try { connection.setAutoCommit(false); } catch (SQLException e1) { e1.printStackTrace(); } PreparedStatement preparedStatement = null; try { preparedStatement = connection.prepareStatement(sql); for (int i = 0; i < paramsList.length; i++) { if (connection != null && !connection.isClosed()) { InputStream is = null; if (paramsList[i].length > 0) { for (int j = 0; j < paramsList[i].length; j++) { Object obj = paramsList[i][j]; if (obj.getClass().equals(Class.forName(\"java.io.File\"))) { File file = (File) obj; is = new FileInputStream(file); preparedStatement.setBinaryStream(j + 1, is, (int) file.length()); } else if (obj.getClass().equals(Class.forName(\"java.util.Date\"))) { java.text.SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); preparedStatement.setString(j + 1, sdf.format((Date) obj)); } else { preparedStatement.setObject(j + 1, obj); } } } preparedStatement.executeUpdate(); if (is != null) { is.close(); } ; } } } catch (Exception e) { System.out.println(\"\u53d1\u751f\u9519\u8bef\uff0c\u6570\u636e\u56de\u6eda\uff01\"); e.printStackTrace(); try { connection.rollback(); return 0; } catch (SQLException e1) { e1.printStackTrace(); } } try { connection.commit(); return 1; } catch (SQLException e) { e.printStackTrace(); } finally { try { preparedStatement.close(); connection.close(); } catch (SQLException e) { e.printStackTrace(); } try { connection.close(); } catch (SQLException e) { log.error(\"\u672a\u80fd\u6b63\u786e\u5173\u95ed\u6570\u636e\u5e93\u8fde\u63a5\uff01\", e); System.out.println(\"\u672a\u80fd\u6b63\u786e\u5173\u95ed\u6570\u636e\u5e93\u8fde\u63a5\uff01\"); e.printStackTrace(); } } return -1; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static Properties loadPropertiesFromClasspath(String path) { Enumeration<URL> locations; Properties props = new Properties(); try { locations = Thread.currentThread().getContextClassLoader().getResources(path); while (locations.hasMoreElements()) { URL url = locations.nextElement(); InputStream in = url.openStream(); props.load(in); in.close(); logger.config(\"Load properties from \" + url); } } catch (IOException e) { logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e); } return props; }. \n Code2: public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception { URL url = null; HttpURLConnection conn = null; InputStream istream = null; try { url = new URL(urlLocation); conn = (HttpURLConnection) url.openConnection(); } catch (Exception e) { throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage()); } loadCookies(urlLocation, conn, c); if (headers != null) { for (int i = 0; i < headers.size(); i++) { String header = (String) headers.get(i); String key = header.substring(0, header.indexOf(\":\")); String value = header.substring(header.indexOf(\":\") + 2); Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\"); conn.setRequestProperty(key, value); } } Debug.debug(\"Set to use GET, URL=\" + urlLocation); try { istream = conn.getInputStream(); } catch (Exception e) { Debug.debug(\"Unable to capture input stream: \" + e.getMessage()); throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage()); } Debug.debug(\"'GET' - Got input stream.\"); if (conn.getContentLength() == -1) { Debug.debug(\"Content length = unknown\"); } else { Debug.debug(\"Content length = \" + conn.getContentLength()); } byte data[] = null; int curPos = 0, contentLength = conn.getContentLength(); if (conn.getContentLength() == -1) { String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\"); if (byteSize == null) { contentLength = 4096; } else { contentLength = Integer.parseInt(byteSize); } Debug.debug(\"Content length unknown. Allowing fuzz of \" + contentLength + \" bytes.\"); } data = new byte[contentLength]; try { int dataRead = 0; while ((dataRead = istream.read(data, curPos, contentLength",
        "ground_truth": "NO",
        "predict": " - curPos)) != -1) { curPos += dataRead; } } catch (Exception e) { throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage()); } Debug.debug(\"'GET' - Got \" + curPos + \" bytes.\"); Debug.debug(\"'GET' - Got \" + contentLength + \" bytes.\"); Debug.debug(\"'GET' - Got \" + new String(data) + \".\"); } catch (Exception e) { throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage()); } finally { if (istream != null) { istream.close(); } if (conn != null) { conn.disconnect(); } } return new String(data); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public"
    },
    {
        "ID": 391,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void prepareOutput(HttpServletRequest req) { EaasyStreet.logTrace(METHOD_IN + className + OUTPUT_METHOD); super.prepareOutput(req); String content = Constants.EMPTY_STRING; String rawContent = null; List parts = null; try { URL url = new URL(sourceUrl); BufferedReader input = new BufferedReader(new InputStreamReader(url.openStream())); String line = \"\"; StringBuffer buffer = new StringBuffer(); while ((line = input.readLine()) != null) { buffer.append(line); buffer.append(Constants.LF); } rawContent = buffer.toString(); } catch (FileNotFoundException nf) { req.setAttribute(Constants.RAK_SYSTEM_ACTION, Constants.SYSTEM_ACTION_BACK); EaasyStreet.handleSafeEvent(req, new Event(Constants.EAA0012I, new String[] { \"URL\", nf.getMessage(), nf.toString() })); } catch (Exception e) { req.setAttribute(Constants.RAK_SYSTEM_ACTION, Constants.SYSTEM_ACTION_BACK); EaasyStreet.handleSafeEvent(req, new Event(Constants.EAA0012I, new String[] { \"URL\", e.getMessage(), e.toString() })); } if (rawContent != null) { if (startDelimiter != null) { parts = StringUtils.split(rawContent, startDelimiter); if (parts != null && parts.size() > 1) { rawContent = (String) parts.get(1); if (parts.size() > 2) { for (int x = 2; x < parts.size(); x++) { rawContent += startDelimiter; rawContent += parts.get(x); } } } else { rawContent = null; } } } if (rawContent != null) { if (endDelimiter != null) { parts = StringUtils.split(rawContent, endDelimiter); if (parts != null && parts.size() > 0) { rawContent = (String) parts.get(0); } else { rawContent = null; } } } if (rawContent != null) { if (replacementValues != null && !replacementValues.isEmpty()) { for (int x = 0; x < replacementValues.size(); x++) { LabelValueBean bean = (LabelValueBean) replacementValues.get(x); rawContent = StringUtils.replace(rawContent, bean.getLabel(), bean.getValue()); } } } if (rawContent != null) { content = rawContent; } req.setAttribute(getFormName(), content); EaasyStreet.logTrace(METHOD_OUT + className + OUTPUT_METHOD); }. \n Code2: public void elimina(Pedido pe) throws errorSQL, errorConexionBD { System.out.println(\"GestorPedido.elimina()\"); int id = pe.getId(); String sql; Statement stmt = null; try { gd.begin(); sql = \"DELETE FROM pedido WHERE id=\" + id; System.out.println(\"Ejecutando: \" + sql); stmt = gd.getConexion().createStatement(); stmt.executeUpdate(sql); System.out.println(\"executeUpdate\"); gd.commit(); System.out.println(\"commit\"); stmt.close(); } catch (SQLException e) { gd.rollback(); throw new errorSQL(e.toString()); } catch (errorConexionBD e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } catch (errorSQL e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void actionPerformed(ActionEvent e) { if (\"register\".equals(e.getActionCommand())) { buttonClicked = \"register\"; try { String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\"); URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\"); URLConnection conn = url.openConnection(); conn.setDoInput(true); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = rd.readLine()) != null) { } rd.close(); wr.close(); } catch (Exception ex) { } setVisible(false); } else if (\"cancel\".equals(e.getActionCommand())) { buttonClicked = \"cancel\"; setVisible(false); } else if (\"never\".equals(e.getActionCommand())) { buttonClicked = \"never\"; setVisible(false); } }. \n Code2: public boolean update(String dbName, Query[] queries) throws ServiceException { Connection con = null; PreparedStatement pstmt = null; int rows = 0; try { con = getDbConnection().getConnection(dbName); con.setAutoCommit(false); for (int i = 0; i < queries.length; i++) { Query query = queries[i]; System.out.println(query.getSql()); pstmt = con.prepareStatement(query.getSql());",
        "ground_truth": "NO",
        "predict": " for (int j = 0; j < query.getParameters().length; j++) { pstmt.setObject(j + 1, query.getParameters()[j]); } pstmt.executeUpdate(); } con.commit(); rows = queries.length; } catch (SQLException e) { try { if (con != null) con.rollback(); } catch (SQLException e1) { } throw new ServiceException(e.getMessage()); } catch (ServiceException e) { try { if (con != null) con.rollback(); } catch (SQLException e1) { } throw e; } finally { try { if (pstmt != null) pstmt.close(); } catch (SQLException e) { } try { if (con != null) con.close(); } catch (SQLException e) { } } return rows > 0; }. \n Response: YES. \n Instruction: Is there"
    },
    {
        "ID": 395,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null && stableBuild != null) { doVersionCheck(view, stableBuild, develBuild); } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \n Code2: public void loadScripts() { org.apache.batik.script.Window window = null; NodeList scripts = document.getElementsByTagNameNS(SVGConstants.SVG_NAMESPACE_URI, SVGConstants.SVG_SCRIPT_TAG); int len = scripts.getLength(); if (len == 0) { return; } for (int i = 0; i < len; i++) { Element script = (Element) scripts.item(i); String type = script.getAttributeNS(null, SVGConstants.SVG_TYPE_ATTRIBUTE); if (type.length() == 0) { type = SVGConstants.SVG_SCRIPT_TYPE_DEFAULT_VALUE; } if (type.equals(SVGConstants.SVG_SCRIPT_TYPE_JAVA)) { try { String href = XLinkSupport.getXLinkHref(script); ParsedURL purl = new ParsedURL(XMLBaseSupport.getCascadedXMLBase(script), href); checkCompatibleScriptURL(type, purl); DocumentJarClassLoader cll; URL docURL = null; try { docURL = new URL(docPURL.toString()); } catch (MalformedURLException mue) { } cll = new DocumentJarClassLoader(new URL(purl.toString()), docURL); URL url = cll.findResource(\"META-INF/MANIFEST.MF\"); if (url == null) { continue; } Manifest man = new Manifest(url.openStream()); String sh; sh = man.getMainAttributes().getValue(\"Script-Handler\"); if (sh != null) { ScriptHandler h; h = (ScriptHandler) cll.loadClass(sh).newInstance(); if (window == null) { window = createWindow(); } h.run(document, window); } sh = man.getMainAttributes().getValue(\"SVG-Handler-Class\"); if (sh != null) { EventListenerInitializer initializer; initializer = (EventListenerInitializer) cll.loadClass(sh).newInstance(); if (window == null) { window = createWindow(); } initializer.initializeEventListeners((SVGDocument) document); } } catch (Exception e) { if (userAgent != null) { userAgent.displayError(e); } } continue; } Interpreter interpreter = getInterpreter(type); if (interpreter == null) continue; try { String href = XLinkSupport.getXLinkHref(script); String desc = null; Reader reader; if (href.length() > 0) { desc = href; ParsedURL purl = new ParsedURL(XMLBaseSupport.getCascadedXMLBase(script), href); checkCompatibleScriptURL(type, purl); reader = new InputStreamReader(purl.openStream()); } else { checkCompatibleScriptURL(type, docPURL); DocumentLoader dl = bridgeContext.getDocumentLoader(); Element e = script; SVGDocument d = (SVGDocument) e.getOwnerDocument(); int line = dl.getLineNumber(script); desc = Messages.formatMessage(INLINE_SCRIPT_DESCRIPTION, new Object[] { d.getURL(), \"<\" + script.getNodeName() + \">\", new Integer(line) }); Node n = script.getFirstChild(); if (n != null) { StringBuffer sb = new StringBuffer(); while (n != null) { if (n.getNodeType() == Node.CDATA_SECTION_NODE || n.getNodeType() == Node.TEXT_NODE) sb.append(n.getNodeValue()); n = n.getNextSibling(); } reader = new StringReader(sb.toString()); } else { continue; } } interpreter.evaluate(reader, desc); } catch (IOException e) { if (userAgent != null) { userAgent.displayError(e); } return; } catch (InterpreterException e) { System.err.println(\"InterpExcept: \" + e); handleInterpreterException(e); return; } catch (SecurityException e) { if (userAgent != null) { userAgent.displayError(e); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException { URL url = new URL(app.getUrl() + request.getRequestURI()); s_log.debug(\"Redirecting to \" + url); URLConnection urlConnection = url.openConnection(); Map<String, List<String>> fields = urlConnection.getHeaderFields(); for (String key : fields.keySet()) { StringBuffer values = new StringBuffer(); boolean comma = false; for (String value : fields.get(key)) { if (comma) { values.append(\", \"); } values.append(value); comma = true; } if (key != null) { response.setHeader(key, values.toString()); } else { response.setStatus(Integer.parseInt(values.toString().split(\" \")[1])); } } InputStream in = urlConnection.getInputStream(); try { ServletOutputStream out = response.getOutputStream(); byte[] buff = new byte[1024]; int len; while ((len = in.read(buff)) != -1) { out.write(buff, 0, len); } } finally { in.close(); } }. \n Code2: public boolean update(String dbName, Query[] queries) throws ServiceException { Connection con = null; PreparedStatement pstmt = null; int rows = 0; try { con = getDbConnection().getConnection(dbName); con.setAutoCommit(false); for (int i = 0; i < queries.length;",
        "ground_truth": "NO",
        "predict": " i++) { if (queries[i].getQuery() == null) { continue; } if (queries[i].getQuery().length() == 0) { continue; } if (queries[i].getQuery().indexOf(\"?\") == -1) { pstmt = con.prepareStatement(queries[i].getQuery()); } else { pstmt = con.prepareStatement(queries[i].getQuery(), Statement.RETURN_GENERATED_KEYS); } pstmt.setObject(1, queries[i].getParameters()); pstmt.executeUpdate(); rows += pstmt.getUpdateCount(); } } catch (SQLException e) { throw new ServiceException(e.getMessage()); } finally { try { if (pstmt != null) pstmt.close(); } catch (SQLException e) { } try { if (con != null) con.close(); } catch (SQLEx"
    },
    {
        "ID": 399,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setUp() { try { String excelFile = \"result\" + java.io.File.separator + \"input\" + java.io.File.separator + \"conextech.xls\"; java.io.File f1 = new java.io.File(excelFile); URL url = new URL(\"file:test/result/input/checksun.xls\"); InputStream is = url.openStream(); workbook = Workbook.getWorkbook(is); } catch (MalformedURLException urlEx) { urlEx.printStackTrace(); fail(); } catch (IOException ioEx) { ioEx.printStackTrace(); fail(); } catch (BiffException biffEx) { biffEx.printStackTrace(); fail(); } }. \n Code2: public ObservationResult[] call(String url, String servicename, String srsname, String version, String offering, String observed_property, String responseFormat) { System.out.println(\"GetObservationBasic.call url \" + url); URL service = null; URLConnection connection = null; ArrayList<ObservationResult> obsList = new ArrayList<ObservationResult>(); boolean isDataArrayRead = false; try { service = new URL(url); connection = service.openConnection(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } connection.setDoOutput(true); connection.setDoInput(true); connection.setUseCaches(false); connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); try { DataOutputStream out = new DataOutputStream(connection.getOutputStream()); GetObservationDocument getobDoc = GetObservationDocument.Factory.newInstance(); GetObservation getob = getobDoc.addNewGetObservation(); getob.setService(servicename); getob.setVersion(version); getob.setSrsName(srsname); getob.setOffering(offering); getob.setObservedPropertyArray(new String[] { observed_property }); getob.setResponseFormat(responseFormat); String request = URLEncoder.encode(getobDoc.xmlText(), \"UTF-8\"); out.writeBytes(request); out.flush(); out.close(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL observation_url = new URL(\"file:///E:/Temp/Observation.xml\"); URLConnection urlc = observation_url.openConnection(); urlc.connect(); InputStream observation_url_is = urlc.getInputStream(); ObservationCollectionDocument obsCollDoc = ObservationCollectionDocument.Factory.parse(observation_url_is); ObservationCollectionType obsColl = obsCollDoc.getObservationCollection(); ObservationPropertyType[] aObsPropType = obsColl.getMemberArray(); for (ObservationPropertyType observationPropertyType : aObsPropType) { ObservationType observation = observationPropertyType.getObservation(); if (observation != null) { System.out.println(\"observation \" + observation.getClass().getName()); ObservationResult obsResult = new ObservationResult(); if (observation instanceof GeometryObservationTypeImpl) { GeometryObservationTypeImpl geometryObservation = (GeometryObservationTypeImpl) observation; TimeObjectPropertyType samplingTime = geometryObservation.getSamplingTime(); TimeInstantTypeImpl timeInstant = (TimeInstantTypeImpl) samplingTime.getTimeObject(); TimePositionType timePosition = timeInstant.getTimePosition(); String time = (String) timePosition.getObjectValue(); StringTokenizer date_st; String day = new StringTokenizer(time, \"T\").nextToken(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date d = sdf.parse(day); String timetemp = null; date_st = new StringTokenizer(time, \"T\"); while (date_st.hasMoreElements()) timetemp = date_st.nextToken(); sdf = new SimpleDateFormat(\"HH:mm:ss\"); Date ti = sdf.parse(timetemp.substring(0, timetemp.lastIndexOf(':') + 2)); d.setHours(ti.getHours()); d.setMinutes(ti.getMinutes()); d.setSeconds(ti.getSeconds()); obsResult.setDatetime(d); String textValue = \"null\"; FeaturePropertyType featureOfInterest = (FeaturePropertyType) geometryObservation.getFeatureOfInterest(); Node fnode = featureOfInterest.getDomNode(); NodeList childNodes = fnode.getChildNodes(); for (int j = 0; j < childNodes.getLength(); j++) { Node cnode = childNodes.item(j); if (cnode.getNodeName().equals(\"n52:movingObject\")) { NamedNodeMap att = cnode.getAttributes(); Node id = att.getNamedItem(\"gml:id\"); textValue = id.getNodeValue(); obsResult.setTextValue(textValue); obsResult.setIsTextValue(true); } } XmlObject result = geometryObservation.getResult(); if (result instanceof GeometryPropertyTypeImpl) { GeometryPropertyTypeImpl geometryPropertyType = (GeometryPropertyTypeImpl) result; AbstractGeometryType geometry = geometryPropertyType.getGeometry(); String srsName = geometry.getSrsName(); StringTokenizer st = new StringTokenizer(srsName, \":\"); String epsg = null; while (st.hasMoreElements()) epsg = st.nextToken(); int sri = Integer.parseInt(epsg); if (geometry instanceof PointTypeImpl) { PointTypeImpl point = (PointTypeImpl) geometry; Node node = point.getDomNode(); PointDocument pointDocument = PointDocument.Factory.parse(node); PointType point2 = pointDocument.getPoint(); XmlCursor cursor = point.newCursor(); cursor.toFirstChild(); CoordinatesDocument coordinatesDocument = CoordinatesDocument.Factory.parse(cursor.xmlText()); CoordinatesType coords = coordinatesDocument.getCoordinates(); StringTokenizer tok = new StringTokenizer(coords.getStringValue(), \" ,;\", false); double x = Double.parseDouble(tok.nextToken()); double y = Double.parseDouble(tok.nextToken()); double z = 0; if (tok.hasMoreTokens()) { z = Double.parseDouble(tok.nextToken()); } x += 207561; y += 3318814; z += 20; Point3d center = new Point3d(x, y, z); obsResult.setCenter(center); GeometryFactory fact = new GeometryFactory(); Coordinate coordinate = new Coordinate(x, y, z); Geometry g1 = fact.createPoint",
        "ground_truth": "NO",
        "predict": "(coordinate); obsResult.setGeometry(g1); } } } catch (Exception e) { e.printStackTrace(); } return obsList.toArray(new ObservationResult[obsList.size()]); }\n}\n"
    },
    {
        "ID": 405,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static int copy(File src, int amount, File dst) { final int BUFFER_SIZE = 1024; int amountToRead = amount; InputStream in = null; OutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(src)); out = new BufferedOutputStream(new FileOutputStream(dst)); byte[] buf = new byte[BUFFER_SIZE]; while (amountToRead > 0) { int read = in.read(buf, 0, Math.min(BUFFER_SIZE, amountToRead)); if (read == -1) break; amountToRead -= read; out.write(buf, 0, read); } } catch (IOException e) { } finally { if (in != null) try { in.close(); } catch (IOException e) { } if (out != null) { try { out.flush(); } catch (IOException e) { } try { out.close(); } catch (IOException e) { } } } return amount - amountToRead; }. \n Code2: public static void save(String from, String recipient, InputStream in, MimeMessage message) throws IOException, MessagingException, DocumentVideException { ConversationManager conversationManager = FGDSpringUtils.getConversationManager(); conversationManager.beginConversation(); FGDDelegate delegate = new FGDDelegate(); UtilisateurIFGD utilisateur = delegate.getUtilisateurParCourriel(from); if (utilisateur == null) { String responseEmailSubject = \"Votre adresse ne correspond pas \u00e0 celle d'un utilisateur d'IntelliGID\"; String responseEmailMessage = \"<h3>Pour sauvegarder un courriel, vous devez \u00eatre un utilisateur d'IntelliGID et l'adresse de courrier \u00e9lectronique utilis\u00e9e doit \u00eatre celle apparaissant dans votre profil.</h3>\"; String sender = recipient.endsWith(\"localhost\") ? FGDSpringUtils.getExpediteurSupport() : recipient; Map<String, String> recipients = new HashMap<String, String>(); recipients.put(from, null); MailUtils.sendSimpleHTMLMessage(recipients, responseEmailSubject, responseEmailMessage, sender); return; } File tempFile = File.createTempFile(\"email\", \".eml\"); tempFile.deleteOnExit(); BufferedInputStream bis = new BufferedInputStream(in); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tempFile)); IOUtils.copy(bis, bos); IOUtils.closeQuietly(bis); IOUtils.closeQuietly(bos); if (message == null) { GestionnaireProprietesMimeMessageParser gestionnaire = new GestionnaireProprietesMimeMessageParser(); message = gestionnaire.asMimeMessage(new BufferedInputStream(new FileInputStream(tempFile))); } String subject; try { subject = message.getSubject().replace(\"Fwd:\", \"\").trim(); } catch (MessagingException e) { subject = \"Message sans sujet\"; } File tempDir = new File(System.getProperty(\"java.io.tmpdir\")); if (!tempDir.exists()) { tempDir.mkdirs(); } File emailFile = new File(tempDir, FilenameUtils.normalize(subject) + \".eml\"); FileUtils.copyFile(tempFile, emailFile); FicheDocument ficheDocument = new FicheDocument(); ficheDocument.setFicheCompletee(false); ficheDocument.setDateCreationHorodatee(new Date()); ficheDocument.setUtilisateurSoumetteur(utilisateur); ficheDocument.getLangues().addAll(getLanguesDefaut()); ficheDocument.setCourriel(true); FileIOContenuFichierElectronique contenuFichier = new FileIOContenuFichierElectronique(emailFile, \"multipart/alternative\"); SupportDocument support = new SupportDocument(); support.setFicheDocument(ficheDocument); FichierElectroniqueUtils.setContenu(ficheDocument, support, contenuFichier, utilisateur); ficheDocument.setTitre(subject); delegate.sauvegarder(ficheDocument, utilisateur); String modifyEmail = \"http://\" + FGDSpringUtils.getServerHost() + \":\" + FGDSpringUtils.getServerPort() + \"/\" + FGDSpringUtils.getApplicationName() + \"/app/modifierDocument/id/\" + ficheDocument.getId(); System.out.println(modifyEmail); String responseEmailSubject = \"Veuillez compl\u00e9ter la fiche du courriel \u00ab\" + subject + \"\u00bb\"; String responseEmailMessage = \"<h3>Le courrier \u00e9lectronique a \u00e9t\u00e9 sauvegard\u00e9, mais il est n\u00e9cessaire de <a href=\\\"\" + modifyEmail + \"\\\">compl\u00e9ter sa fiche</a>.</h3>\"; String sender = recipient.endsWith(\"localhost\") ? FGDSpringUtils.getExpediteurSupport() : recipient; try { MailUtils.sendSimpleHTMLMessage(utilisateur, responseEmailSubject, responseEmailMessage, sender); } catch (Throwable e) { e.printStackTrace(); } conversationManager.commitTransaction(); tempFile.delete(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static byte[] loadURLToBuffer(URL url) throws IOException { byte[] buf = new byte[4096]; byte[] data = null; byte[] temp = null; int iCount = 0; int iTotal = 0; BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480); while ((iCount = in.read(buf, 0, buf.length)) != -1) { if (iTotal == 0) { data = new byte[iCount]; System.arraycopy(buf, 0, data, 0, iCount); iTotal = iCount; } else { temp = new byte[iCount + iTotal]; System.arraycopy(data, 0, temp, 0, iTotal); System.arraycopy(buf, 0, temp, iTotal, iCount); data = temp; iTotal = iTotal + iCount; } } in.close(); return data; }. \n Code2: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.",
        "ground_truth": "NO",
        "predict": "setRequestMethod(\"GET\"); conn.setRequestProperty(\"Authorization\", \"Basic \" + new String(Base64.encodeBase64(userPassword.getBytes()))); conn.connect(); InputStream is = conn.getInputStream(); filePath = FileUtils.getTempDirectory() + \"/\" + FilenameUtils.getBaseName(wsdlURL) + \".wsdl\"; FileUtils.copyInputStreamToFile(is, new File(filePath)); } catch (IOException e) { throw new WiseConnectionException(e); } return filePath; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { URL url = new URL(\"http://localhost:8080/app/modifierDocument/id/1\"); byte[] data = loadURLToBuffer(url); String filePath = null; try { FileUt"
    },
    {
        "ID": 407,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public int extract() throws Exception { int count = 0; if (VERBOSE) System.out.println(\"IAAE:Extractr.extract: getting ready to extract \" + getArtDir().toString()); ITCFileFilter iff = new ITCFileFilter(); RecursiveFileIterator rfi = new RecursiveFileIterator(getArtDir(), iff); FileTypeDeterminer ftd = new FileTypeDeterminer(); File artFile = null; File targetFile = null; broadcastStart(); while (rfi.hasMoreElements()) { artFile = (File) rfi.nextElement(); targetFile = getTargetFile(artFile); if (VERBOSE) System.out.println(\"IAAE:Extractr.extract: working ont \" + artFile.toString()); BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream((new FileInputStream(artFile))); out = new BufferedOutputStream((new FileOutputStream(targetFile))); byte[] buffer = new byte[10240]; int read = 0; int total = 0; read = in.read(buffer); while (read != -1) { if ((total <= 491) && (read > 491)) { out.write(buffer, 492, (read - 492)); } else if ((total <= 491) && (read <= 491)) { } else { out.write(buffer, 0, read); } total = total + read; read = in.read(buffer); } } catch (Exception e) { e.printStackTrace(); broadcastFail(); } finally { in.close(); out.close(); } broadcastSuccess(); count++; } broadcastDone(); return count; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void createSettingsIfNecessary() throws IOException { OutputStream out = null; try { final File fSettings = SettingsUtils.getSettingsFile(); if (!fSettings.exists()) { fSettings.createNewFile(); final Path src = new Path(\"mvn/settings.xml\"); final InputStream in = FileLocator.openStream(getBundle(), src, false); out = new FileOutputStream(SettingsUtils.getSettings(), true); IOUtils.copy(in, out); } else { Logger.getLog().info(\"File settings.xml already exists at \" + fSettings); } } finally { if (out != null) { out.flush(); out.close(); } } }. \n Code2: public void run() { URL url; try { url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\"); BufferedReader in = new BufferedReader",
        "ground_truth": "NO",
        "predict": "(new InputStreamReader(url.openStream())); String line; while ((line = in.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p."
    },
    {
        "ID": 413,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run() { XmlFilesFilter filter = new XmlFilesFilter(); String pathTemp = Settings.get(\"vo_store.databaseMetaCollection\"); String sectionName = pathTemp.substring(1, pathTemp.indexOf(\"/\", 2)); String templateName = VOAccess.getElementByName(settingsDB, \"TEMPLATE\", sectionName); String schemaName = VOAccess.getElementByName(settingsDB, \"SCHEMA\", sectionName); byte[] buf = new byte[1024]; Hashtable templateElements = null; try { URL xmlTemplateUrl = new URL(httpURI + settingsDB + \"/\" + templateName); URL getDocPathsAndValuesXslUrl = new URL(httpURI + settingsDB + \"/\" + \"getDocPathsValuesAndDisplays.xsl\"); org.w3c.dom.Document curTemplateXml = VOAccess.readDocument(xmlTemplateUrl); DOMResult templateResult = new DOMResult(); InputStream tempInput = getDocPathsAndValuesXslUrl.openStream(); javax.xml.transform.sax.SAXSource tempXslSource = new javax.xml.transform.sax.SAXSource(new org.xml.sax.InputSource(tempInput)); Transformer trans = TransformerFactory.newInstance().newTransformer(tempXslSource); trans.setParameter(\"schemaUrl\", httpURI + settingsDB + \"/\" + schemaName); trans.transform(new javax.xml.transform.dom.DOMSource(curTemplateXml), templateResult); tempInput.close(); templateElements = VOAccess.displaysToHashtable(templateResult); ((CollectionManagementService) CollectionsManager.getService(xmldbURI + rootDB, false, \"CollectionManager\")).createCollection(rootDB + pathTemp); } catch (Exception ex) { logger.error(\"Error parsing input document\", ex); ex.printStackTrace(); } while (true) { File[] fileList = sourceMetaFilesDir.listFiles(filter); for (int i = 0; i < Math.min(fileList.length, 500); i++) { File newFile = fileList[i]; try { Document metaDoc = build.build(newFile); Element metaElm = metaDoc.getRootElement(); String dataFileName = metaElm.getChildText(\"Content\"), previewFileName = metaElm.getChildText(\"Preview\"); String objId = VOAccess.getUniqueId(); metaElm.getChild(\"Content\").setText(\"videostore?type=doc&objId=\" + objId); metaElm.getChild(\"Preview\").setText(\"videostore?type=preview&objId=\" + objId); boolean found = false; for (Iterator it = sourceDataFilesDirs.iterator(); it.hasNext() && !found; ) { String sourceDataFilesDir = (String) it.next(); File dataInput = new File(sourceDataFilesDir + \"/\" + dataFileName); if (dataInput.exists()) { found = true; BufferedInputStream inp = new BufferedInputStream(new FileInputStream(dataInput)); FileOutputStream outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".dat\")); int read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); dataInput = new File(sourceDataFilesDir + \"/\" + previewFileName); inp = new BufferedInputStream(new FileInputStream(dataInput)); outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".jpg\")); read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); curDirWriteTo++; if (curDirWriteTo >= targetDataFilesDirs.size()) { curDirWriteTo = 0; } } } if (!found) { newFile.renameTo(new File(newFile.getAbsolutePath() + \".not_found\")); } else { String title = getValueByPath((String) templateElements.get(\"title\"), metaDoc.getRootElement()); String description = getValueByPath((String) templateElements.get(\"description\"), metaDoc.getRootElement()); String onlink = \"\"; if (null != templateElements.get(\"onlink\")) { onlink = getValueByPath((String) templateElements.get(\"onlink\"), metaDoc.getRootElement()); } String ncover = \"\"; if (null != templateElements.get(\"ncover\")) { ncover = getValueByPath((String) templateElements.get(\"ncover\"), metaDoc.getRootElement()); } String wcover = \"\"; if (null != templateElements.get(\"wcover\")) { wcover = getValueByPath((String) templateElements.get(\"wcover\"), metaDoc.getRootElement()); } String ecover = \"\"; if (null != templateElements.get(\"ecover\")) { ecover = getValueByPath((String) templateElements.get(\"ecover\"), metaDoc.getRootElement()); } String scover = \"\"; if (null != templateElements.get(\"scover\")) { scover = getValueByPath((String) templateElements.get(\"scover\"), metaDoc.getRootElement()); } String datefrom = \"\"; if (null != templateElements.get(\"datefrom\")) { datefrom = getValueByPath((String) templateElements.get(\"datefrom\"), metaDoc.getRootElement()); } String dateto = \"\"; if (null != templateElements.get(\"dateto\")) { dateto = getValueByPath((String) templateElements.get(\"dateto\"), metaDoc.getRootElement()); } String previewimg = \"\"; if (null != templateElements.get(\"previewimg\")) { previewimg = getValueByPath((String) templateElements.get(\"previewimg\"), metaDoc.getRootElement()); } String discRestr = \"false\"; String votingRestr = \"false\"; datefrom = VOAccess.parseDate(datefrom, \"yyyy-MM-dd'T'HH:mm:ss\", VO.defaultTimeFormat.toPattern()); dateto = VOAccess.parseDate(datefrom, \"yyyy-MM-dd'T'HH:mm:ss\", VO.defaultTimeFormat.toPattern()); Hashtable discussionFields = new Hashtable(); discussionFields.put(\"OBJECT_ID\", objId); discussionFields.put(\"AUTHOR_ID\", \"auto\"); discussionFields.put(\"AUTHOR_NAME\", \"",
        "ground_truth": "NO",
        "predict": "auto\"); discussionFields.put(\"AUTHOR_EMAIL\", \"auto\"); discussionFields.put(\"AUTHOR_PHONE\", \"auto\"); discussionFields.put(\"AUTHOR_ADDRESS\", \"auto\"); discussionFields.put(\"AUTHOR_CITY\", \"auto\"); discussionFields.put(\"AUTHOR_COUNTRY\", \"auto\"); discussionFields.put(\"AUTHOR_POSTAL_CODE\", \"auto\"); discussionFields.put(\"AUTHOR_STREET\", \"auto\"); discussionFields.put(\"AUTHOR_CITY\", \"auto\"); discussionFields.put(\"AUTHOR_COUNTRY\", \"auto\"); discussionFields.put(\"AUTHOR_POSTAL_CODE\", \"auto\"); discussionFields.put(\"AUTHOR_STREET\", \"auto\"); discussionFields.put(\"AUTHOR_CITY\", \"auto\"); discussionFields.put(\"AUTHOR_C"
    },
    {
        "ID": 418,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Logging() throws Exception { File home = new File(System.getProperty(\"user.home\"), \".jorgan\"); if (!home.exists()) { home.mkdirs(); } File logging = new File(home, \"logging.properties\"); if (!logging.exists()) { InputStream input = getClass().getResourceAsStream(\"logging.properties\"); OutputStream output = null; try { output = new FileOutputStream(logging); IOUtils.copy(input, output); } finally { IOUtils.closeQuietly(input); IOUtils.closeQuietly(output); } } FileInputStream input = null; try { input = new FileInputStream(logging); LogManager.getLogManager().readConfiguration(input); } finally { IOUtils.closeQuietly(input); } }. \n Code2: public boolean verifySignature() { try { byte[] data = readFile(name + \".tmp1.bin\"); if (data == null) return false; if (data[data.length - 0x104] != 'N' || data[data.length - 0x103] != 'G' || data[data.length - 0x102] != 'I' || data[data.length - 0x101] != 'S') return false; byte[] signature = new byte[0x100]; byte[] module = new byte[data.length - 0x104]; System.arraycopy(data, data.length - 0x100, signature, 0, 0x100); System.arraycopy(data, 0, module, 0, data.length - 0x104); BigIntegerEx power = new BigIntegerEx(BigIntegerEx.LITTLE_ENDIAN, new byte[] { 0x01, 0x00, 0x01, 0x00 }); BigIntegerEx mod = new BigIntegerEx(BigIntegerEx.LITTLE_ENDIAN, new byte[] { (byte) 0x6B, (byte) 0xCE, (byte) 0xF5, (byte) 0x2D, (byte) 0x2A, (byte) 0x7D, (byte) 0x7A, (byte) 0x67, (byte) 0x21, (byte) 0x21, (byte) 0x84, (byte) 0xC9, (byte) 0xBC, (byte) 0x25, (byte) 0xC7, (byte) 0xBC, (byte) 0xDF, (byte) 0x3D, (byte) 0x8F, (byte) 0xD9, (byte) 0x47, (byte) 0xBC, (byte) 0x45, (byte) 0x48, (byte) 0x8B, (byte) 0x22, (byte) 0x85, (byte) 0x3B, (byte) 0xC5, (byte) 0xC1, (byte) 0xF4, (byte) 0xF5, (byte) 0x3C, (byte) 0x0C, (byte) 0x49, (byte) 0xBB, (byte) 0x56, (byte) 0xE0, (byte) 0x3D, (byte) 0xBC, (byte) 0xA2, (byte) 0xD2, (byte) 0x35, (byte) 0xC1, (byte) 0xF0, (byte) 0x74, (byte) 0x2E, (byte) 0x15, (byte) 0x5A, (byte) 0x06, (byte) 0x8A, (byte) 0x68, (byte) 0x01, (byte) 0x9E, (byte) 0x60, (byte) 0x17, (byte) 0x70, (byte) 0x8B, (byte) 0xBD, (byte) 0xF8, (byte) 0xD5, (byte) 0xF9, (byte) 0x3A, (byte) 0xD3, (byte) 0x25, (byte) 0xB2, (byte) 0x66, (byte) 0x92, (byte) 0xBA, (byte) 0x43, (byte) 0x8A, (byte) 0x81, (byte) 0x52, (byte) 0x0F, (byte) 0x64, (byte) 0x98, (byte) 0xFF, (byte) 0x60, (byte) 0x37, (byte) 0xAF, (byte) 0xB4, (byte) 0x11, (byte) 0x8C, (byte) 0xF9, (byte) 0x2E, (byte) 0xC5, (byte) 0xEE, (byte) 0xCA, (byte) 0xB4, (byte) 0x41, (byte) 0x60, (byte) 0x3C, (byte) 0x7D, (byte) 0x02, (byte) 0xAF, (byte) 0xA1, (byte) 0x2B, (byte) 0x9B, (byte) 0x22, (byte) 0x4B, (byte) 0x3B, (byte) 0xFC, (byte) 0xD2, (byte) 0x5D, (byte) 0x73, (byte) 0xE9, (byte) 0x29, (byte) 0x34, (byte) 0x91, (byte) 0x85, (byte) 0x93, (byte) 0x4C, (byte) 0xBE, (byte) 0xBE, (byte) 0x73, (byte) 0xA9, (byte) 0xD2, (byte) 0x3B, (byte) 0x27, (byte) 0x7A, (byte) 0x47, (byte) 0x76, (byte) 0xEC, (byte) 0xB0, (byte) 0x28, (byte) 0xC9, (byte) 0xC1, (byte) 0xDA, (byte) 0xEE, (byte) 0xAA, (byte) 0xB3, (byte) 0x96, (byte) 0x9C, (byte) 0x1E, (byte) 0xF5, (byte) 0x6B, (byte) 0xF6, (byte) 0x64, (byte) 0xD8, (byte) 0x94, (byte) 0x2E, (byte) 0xF1, (byte) 0xF7, (byte) 0x14, (byte) 0x5F, (byte) 0xA0, (byte) 0xF1, (byte) 0xA3, (byte) 0xB9, (byte) 0xB1, (byte) 0x",
        "ground_truth": "NO",
        "predict": "A9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0x"
    },
    {
        "ID": 428,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private int mergeFiles(Merge merge) throws MojoExecutionException { String encoding = DEFAULT_ENCODING; if (merge.getEncoding() != null && merge.getEncoding().length() > 0) { encoding = merge.getEncoding(); } int numMergedFiles = 0; Writer ostream = null; FileOutputStream fos = null; try { fos = new FileOutputStream(merge.getTargetFile(), true); ostream = new OutputStreamWriter(fos, encoding); BufferedWriter output = new BufferedWriter(ostream); for (String orderingName : this.orderingNames) { List<File> files = this.orderedFiles.get(orderingName); if (files != null) { getLog().info(\"Appending: \" + files.size() + \" files that matched the name: \" + orderingName + \" to the target file: \" + merge.getTargetFile().getAbsolutePath() + \"...\"); for (File file : files) { String fileName = file.getName(); getLog().info(\"Appending file: \" + fileName + \" to the target file: \" + merge.getTargetFile().getAbsolutePath() + \"...\"); InputStream input = null; try { input = new FileInputStream(file); if (merge.getSeparator() != null && merge.getSeparator().trim().length() > 0) { String replaced = merge.getSeparator().trim(); replaced = replaced.replace(\"\\n\", \"\"); replaced = replaced.replace(\"\\t\", \"\"); replaced = replaced.replace(\"#{file.name}\", fileName); replaced = replaced.replace(\"#{parent.name}\", file.getParentFile() != null ? file.getParentFile().getName() : \"\"); replaced = replaced.replace(\"\\\\n\", \"\\n\"); replaced = replaced.replace(\"\\\\t\", \"\\t\"); getLog().debug(\"Appending separator: \" + replaced); IOUtils.copy(new StringReader(replaced), output); } IOUtils.copy(input, output, encoding); } catch (IOException ioe) { throw new MojoExecutionException(\"Failed to append file: \" + fileName + \" to output file\", ioe); } finally { IOUtils.closeQuietly(input); } numMergedFiles++; } } } output.flush(); } catch (IOException ioe) { throw new MojoExecutionException(\"Failed to open stream file to output file: \" + merge.getTargetFile().getAbsolutePath(), ioe); } finally { if (fos != null) { IOUtils.closeQuietly(fos); } if (ostream != null) { IOUtils.closeQuietly(ostream); } } return numMergedFiles; }. \n Code2: public ValidationReport validate(OriginalDeployUnitDescription unit) throws UnitValidationException { ValidationReport vr = new DefaultValidationReport(); errorHandler = new SimpleErrorHandler(vr); vr.setFileUri(unit.getAbsolutePath()); SAXParser parser; SAXReader reader = null; try { parser = factory.newSAXParser(); reader = new SAXReader(parser.getXMLReader()); reader.setValidation(false); reader.setErrorHandler(this.errorHandler); } catch (ParserConfigurationException e) { throw new UnitValidationException(\"The configuration of parser is illegal.\", e); } catch (SAXException e) { String m = \"Something is wrong when register schema\"; logger.error(m, e); throw new UnitValidationException(m, e); } ZipInputStream zipInputStream; InputStream tempInput = null; try { tempInput = new FileInputStream(unit.getAbsolutePath()); } catch (FileNotFoundException e1) { String m = String.format(\"The file [%s] don't exist.\", unit.getAbsolutePath()); logger.error(m, e1); throw new UnitValidationException(m, e1); } zipInputStream = new ZipInputStream(tempInput); ZipEntry zipEntry = null; try { zipEntry = zipInputStream.getNextEntry(); if (zipEntry == null) { String m = String.format(\"Error when get zipEntry. Maybe the [%s] is not zip file!\", unit.getAbsolutePath()); logger.error(m); throw new UnitValidationException(m); } while (zipEntry != null) { if (configFiles.contains(zipEntry.getName())) { byte[] extra = new byte[(int) zipEntry.getSize()]; zipInputStream.read(extra); File file = File.createTempFile(\"temp\", \"extra\"); file.deleteOnExit(); logger.info(\"[TempFile:]\" + file.getAbsoluteFile()); ByteArrayInputStream byteInputStream = new ByteArrayInputStream(extra); FileOutputStream tempFileOutputStream = new FileOutputStream(file); IOUtils.copy(byteInputStream, tempFileOutputStream); tempFileOutputStream.flush(); IOUtils.closeQuietly(tempFileOutputStream); InputStream inputStream = new FileInputStream(file); reader.read(inputStream, unit.getAbsolutePath() + \":\" + zipEntry.getName()); IOUtils.closeQuietly(inputStream); } zipEntry = zipInputStream.getNextEntry(); } } catch (IOException e) { ValidationMessage vm = new XMLValidationMessage(\"IOError\", 0, 0, unit.getUrl() + \":\" + zipEntry.getName(), e); vr.addValidationMessage(vm); } catch (DocumentException e) { ValidationMessage vm = new XMLValidationMessage(\"Document Error.\", 0, 0, unit.getUrl() + \":\" + zipEntry.getName(), e); vr.addValidationMessage(vm); } finally { IOUtils.closeQuietly(tempInput); IOUtils.closeQuietly(zipInputStream); } return vr; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void loadDDL() throws IOException { try { conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close(); } catch (SQLException e) { Statement stmt = null; if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) { LOG.fatal(SQL_ERROR, e); throw new IOException(\"Error on initial data store read\", e); } String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(",
        "ground_truth": "NO",
        "predict": "id))\" }; for (String q : qry) { try { stmt = conn.createStatement(); stmt.executeUpdate(q); } catch (SQLException e1) { LOG.fatal(SQL_ERROR, e1); throw new IOException(\"Error on initial data store read\", e1); } } } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void loadDDL() throws IOException { try { conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close(); } catch (SQLException e) { Statement stmt = null; if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) { LOG.fatal(SQL_ERROR, e); throw new IOException(\"Error on initial data store read\", e); } String[] qry = { \"CREATE TABLE monitor (id INTEG"
    },
    {
        "ID": 430,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static boolean copyFile(File src, File dest) { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(src); fos = new FileOutputStream(dest); for (int c = fis.read(); c != -1; c = fis.read()) fos.write(c); return true; } catch (FileNotFoundException e) { e.printStackTrace(); return false; } catch (IOException e) { e.printStackTrace(); return false; } finally { if (fis != null) try { fis.close(); } catch (IOException e) { e.printStackTrace(); } if (fos != null) try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } }. \n Code2: private static void cut() { File inputFile = new File(inputFileName); BufferedReader in = null; try { in = new BufferedReader(new InputStreamReader(new FileInputStream(inputFile), inputCharSet)); } catch (FileNotFoundException e) { System.err.print(\"Invalid File Name!\"); System.err.flush(); System.exit(1); } catch (UnsupportedEncodingException e) { System.err.print(\"Invalid Char Set Name!\"); System.err.flush(); System.exit(1); } switch(cutMode) { case charMode: { int outputFileIndex = 1; char[] readBuf = new char[charPerFile]; while (true) { int readCount = 0; try { readCount = in.read(readBuf); } catch (IOException e) { System.err.println(\"Read IO Error!\"); System.err.flush(); System.exit(1); } if (-1 == readCount) break; else { try { int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = \"html\"; DecimalFormat outputFileIndexFormat = new DecimalFormat(\"0000\"); File outputFile = new File(prefixInputFileName + \"-\" + outputFileIndexFormat.format(outputFileIndex) + \".\" + postfixInputFileName); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile), outputCharSet)); out.write(readBuf, 0, readCount); out.flush(); out.close(); outputFileIndex++; } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } } } break; } case lineMode: { boolean isFileEnd = false; int outputFileIndex = 1; while (!isFileEnd) { try { int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = inputFileName.substring(ppos + 1); DecimalFormat outputFileIndexFormat = new DecimalFormat(\"0000\"); File outputFile = new File(prefixInputFileName + outputFileIndexFormat.format(outputFileIndex) + \".\" + postfixInputFileName); PrintStream out = new PrintStream(new FileOutputStream(outputFile), false, outputCharSet); int p = 0; while (p < linePerFile) { String line = in.readLine(); if (null == line) { isFileEnd = true; break; } out.println(line); ++p; } out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } ++outputFileIndex; } break; } case htmlMode: { boolean isFileEnd = false; int outputFileIndex = 1; int ppos = inputFileName.lastIndexOf(\".\"); String prefixInputFileName = inputFileName.substring(0, ppos); String postfixInputFileName = \"html\"; DecimalFormat df = new DecimalFormat(\"0000\"); while (!isFileEnd) { try { File outputFile = new File(prefixInputFileName + \"-\" + df.format(outputFileIndex) + \".\" + postfixInputFileName); PrintStream out = new PrintStream(new FileOutputStream(outputFile), false, outputCharSet); out.println(\"<html><head><title>\" + prefixInputFileName + \"-\" + df.format(outputFileIndex) + \"</title>\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; \" + \"charset=\" + outputCharSet + \"\\\" />\" + \"<link rel =\\\"stylesheet\\\" \" + \"type=\\\"text/css\\\" \" + \"href=\\\"stylesheet.css\\\" />\" + \"</head><body><div id=\\\"content\\\">\"); int p = 0; while (p < pPerFile) { String line = in.readLine(); if (null == line) { isFileEnd = true; break; } if (line.length() > 0) out.println(\"<p>\" + line + \"</p>\"); ++p; } out.println(\"</div><a href=\\\"\" + prefixInputFileName + \"-\" + df.format(outputFileIndex + 1) + \".\" + postfixInputFileName + \"\\\">NEXT</a></body></html>\"); out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } ++outputFileIndex; } try { File indexFile = new File(\"index.html\"); PrintStream out = new PrintStream(new FileOutputStream(indexFile), false, outputCharSet); out.println(\"<html><head><title>\" + \"Index\" + \"</title>\" + \"<meta http-equiv=\\\"Content-Type\\\"\" + \" content=\\\"text/html; \" + \"charset=\" + outputCharSet + \"\\\" />\" + \"<link rel =\\\"stylesheet\\\" \" + \"type=\\\"text/css\\\" \" + \"href=\\\"stylesheet.css\\\" />\" + \"</head><body><h2>\" + htmlTitle + \"</h2><div id=\\\"content\\\"><ul>\"); for (int i = 1; i < outputFileIndex; i++) { out.println(\"<li><a href=\\\"\" + prefixInputFileName + \"-\" + df.format(i) + \".\" + postfixInputFileName + \"\\\">\" + df.format(i) + \"</a></li>\"); } out.println(\"</ul></body></html>\"); out.flush(); out.close(); } catch (IOException e) { System.err.println(\"Write IO Error!\"); System.err.flush(); System.exit(1); } break; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to",
        "ground_truth": "NO",
        "predict": " YES or NO. Code1: private static boolean copyFile(File src, File dest) { FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(src); fos = new FileOutputStream(dest); for (int c = fis.read(); c != -1; c = fis.read()) fos.write(c); return true; } catch (FileNotFoundException e) { e.printStackTrace(); return false; } catch (IOException e) { e.printStackTrace(); return false; } finally { if (fis != null) try { fis.close(); } catch (IOException e) { e.printStackTrace(); } if (fos != null) try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } }. \n Code2: private static void cut() { File inputFile = new File(inputFileName);"
    },
    {
        "ID": 435,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected String doInBackground(Location... params) { if (params == null || params.length == 0 || params[0] == null) { return null; } Location location = params[0]; String address = \"\"; String cachedAddress = DataService.GetInstance(mContext).getAddressFormLocationCache(location.getLatitude(), location.getLongitude()); if (!TextUtils.isEmpty(cachedAddress)) { address = cachedAddress; } else { StringBuilder jsonText = new StringBuilder(); HttpClient client = new DefaultHttpClient(); String url = String.format(GoogleMapAPITemplate, location.getLatitude(), location.getLongitude()); HttpGet httpGet = new HttpGet(url); try { HttpResponse response = client.execute(httpGet); StatusLine statusLine = response.getStatusLine(); int statusCode = statusLine.getStatusCode(); if (statusCode == 200) { HttpEntity entity = response.getEntity(); InputStream content = entity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(content)); String line; while ((line = reader.readLine()) != null) { jsonText.append(line); } JSONObject result = new JSONObject(jsonText.toString()); String status = result.getString(GoogleMapStatusSchema.status); if (GoogleMapStatusCodes.OK.equals(status)) { JSONArray addresses = result.getJSONArray(GoogleMapStatusSchema.results); if (addresses.length() > 0) { address = addresses.getJSONObject(0).getString(GoogleMapStatusSchema.formatted_address); if (!TextUtils.isEmpty(currentBestLocationAddress)) { DataService.GetInstance(mContext).updateAddressToLocationCache(location.getLatitude(), location.getLongitude(), currentBestLocationAddress); } } } } else { Log.e(\"Error\", \"Failed to get address via google map API.\"); } } catch (ClientProtocolException e) { e.printStackTrace(); Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } catch (IOException e) { Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } catch (JSONException e) { Toast.makeText(mContext, \"Failed to get location.\", Toast.LENGTH_SHORT).show(); } } return address; }. \n Code2: private void handleNodeUp(long eventID, long nodeID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1) { log.warn(EventConstants.NODE_UP_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid: \" + eventID + \"/\" + nodeID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); int count = 0; if (openOutageExists(dbConn, nodeID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGES_FOR_NODE); outageUpdater.setLong(1, eventID); outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime)); outageUpdater.setLong(3, nodeID); count = outageUpdater.executeUpdate(); outageUpdater.close(); } else { log.warn(\"\\'\" + EventConstants.NODE_UP_EVENT_UEI + \"\\' for \" + nodeID + \" no open record.\"); } try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"nodeUp closed \" + count + \" outages for nodeid \" + nodeID + \" in DB\"); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeUp could not be recorded for nodeId: \" + nodeID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } } catch (SQLException se) { log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public FileChooserTestFrame() throws HeadlessException, MalformedURLException { super(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent aEvent) { System.exit(0); } }); Dimension dim = getToolkit().getScreenSize(); Rectangle abounds = getBounds(); setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2); setVisible(true); URL url = new URL(\"ftp://cendantstp/\"); char[] password = \"spnr\".toCharArray(); PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password); FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication); JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setMultiSelectionEnabled(true); File[] selectedFiles = null; if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) { selectedFiles = fileChooser.getSelectedFiles(); for (int i = 0; i < selectedFiles.length; i++) { if (selectedFiles[i] instanceof FTPFileFile) { FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i]; logger.fine(ftpFile.getName()); logger.fine(ftpFile.getPath()); } else { logger.fine(selectedFiles[i].toString()); logger.fine(selectedFiles[i].getAbsolutePath()); } } } remoteFileSystemView.disconnect(); try { if (null != selectedFiles) { FTPClient ftpClient = new FTPClient(); InetAddress inetAddress = InetAddress.getByName(url.getHost()); ftpClient.connect(inetAddress); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) { throw new FTPBrowseException(ftpClient",
        "ground_truth": "NO",
        "predict": ".getReplyString()); } } } catch (IOException e) { throw new FTPBrowseException(e.getMessage()); } }. \n Code3: public void handleNodeDown(long eventID, long nodeID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1) { log.warn(EventConstants.NODE_DOWN_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid: \" + eventID + \"/\" + nodeID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); int count = 0; if (openOutageExists(dbConn, nodeID)) { try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } Prep"
    },
    {
        "ID": 440,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private final long test(final boolean applyFilter, final int executionCount) throws NoSuchAlgorithmException, NoSuchPaddingException, FileNotFoundException, IOException, RuleLoadingException { final boolean stripHtmlEnabled = true; final boolean injectSecretTokensEnabled = true; final boolean encryptQueryStringsEnabled = true; final boolean protectParamsAndFormsEnabled = true; final boolean applyExtraProtectionForDisabledFormFields = true; final boolean applyExtraProtectionForReadonlyFormFields = false; final boolean applyExtraProtectionForRequestParamValueCount = false; final ContentInjectionHelper helper = new ContentInjectionHelper(); final RuleFileLoader ruleFileLoaderModificationExcludes = new ClasspathZipRuleFileLoader(); ruleFileLoaderModificationExcludes.setPath(WebCastellumFilter.MODIFICATION_EXCLUDES_DEFAULT); final ContentModificationExcludeDefinitionContainer containerModExcludes = new ContentModificationExcludeDefinitionContainer(ruleFileLoaderModificationExcludes); containerModExcludes.parseDefinitions(); helper.setContentModificationExcludeDefinitions(containerModExcludes); final AttackHandler attackHandler = new AttackHandler(null, 123, 600000, 100000, 300000, 300000, null, \"MOCK\", false, false, 0, false, false, Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), true); final SessionCreationTracker sessionCreationTracker = new SessionCreationTracker(attackHandler, 0, 600000, 300000, 0, \"\", \"\", \"\", \"\"); final RequestWrapper request = new RequestWrapper(new RequestMock(), helper, sessionCreationTracker, \"123.456.789.000\", false, true, true); final RuleFileLoader ruleFileLoaderResponseModifications = new ClasspathZipRuleFileLoader(); ruleFileLoaderResponseModifications.setPath(WebCastellumFilter.RESPONSE_MODIFICATIONS_DEFAULT); final ResponseModificationDefinitionContainer container = new ResponseModificationDefinitionContainer(ruleFileLoaderResponseModifications); container.parseDefinitions(); final ResponseModificationDefinition[] responseModificationDefinitions = downCast(container.getAllEnabledRequestDefinitions()); final List tmpPatternsToExcludeCompleteTag = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeCompleteScript = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeCompleteTag = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeCompleteScript = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpGroupNumbersToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpGroupNumbersToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); for (int i = 0; i < responseModificationDefinitions.length; i++) { final ResponseModificationDefinition responseModificationDefinition = responseModificationDefinitions[i]; if (responseModificationDefinition.isMatchesScripts()) { tmpPatternsToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPattern()); tmpPrefiltersToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPrefilter()); tmpPatternsToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinScripts.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } if (responseModificationDefinition.isMatchesTags()) { tmpPatternsToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPattern()); tmpPrefiltersToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPrefilter()); tmpPatternsToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinTags.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } } final Matcher[] matchersToExcludeCompleteTag = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteTag); final Matcher[] matchersToExcludeCompleteScript = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteScript); final Matcher[] matchersToExcludeLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinScripts); final Matcher[] matchersToExcludeLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinTags); final Matcher[] matchersToCaptureLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinScripts); final Matcher[] matchersToCaptureLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinTags); final WordDictionary[] prefiltersToExcludeCompleteTag = (WordDictionary[]) tmpPrefiltersToExcludeCompleteTag.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeCompleteScript = (WordDictionary[]) tmpPrefiltersToExclude",
        "ground_truth": "NO",
        "predict": "CompleteScript.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeLinksWithinScripts = (WordDictionary[]) tmpPrefiltersToExcludeLinksWithinScripts.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeLinksWithinTags = (WordDictionary[]) tmpPrefiltersToExcludeLinksWithinTags.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToCaptureLinksWithinScripts = (WordDictionary[]) tmpPrefiltersToCaptureLinksWithinScripts.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToCaptureLinksWithinTags = (WordDictionary[]) tmpPrefiltersToCaptureLinksWithinTags.toArray(new WordDictionary[0]); final int[] groupNumbersToCaptureLinksWithinScripts = (int[]) tmpGroupNumbersToCaptureLinksWithinScripts.toArray(new int[0]); final"
    },
    {
        "ID": 456,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { try { { byte[] bytes1 = { (byte) 2, (byte) 2, (byte) 3, (byte) 0, (byte) 9 }; byte[] bytes2 = { (byte) 99, (byte) 2, (byte) 2, (byte) 3, (byte) 0, (byte) 9 }; System.out.println(\"Bytes 2,2,3,0,9 as Base64: \" + encodeBytes(bytes1)); System.out.println(\"Bytes 2,2,3,0,9 w/ offset: \" + encodeBytes(bytes2, 1, bytes2.length - 1)); byte[] dbytes = decode(encodeBytes(bytes1)); System.out.print(encodeBytes(bytes1) + \" decoded: \"); for (int i = 0; i < dbytes.length; i++) System.out.print(dbytes[i] + (i < dbytes.length - 1 ? \",\" : \"\\n\")); } { java.io.FileInputStream fis = new java.io.FileInputStream(\"test.gif.b64\"); Base64.InputStream b64is = new Base64.InputStream(fis, DECODE); byte[] bytes = new byte[0]; int b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[bytes.length + 1]; System.arraycopy(bytes, 0, temp, 0, bytes.length); temp[bytes.length] = (byte) b; bytes = temp; } b64is.close(); javax.swing.ImageIcon iicon = new javax.swing.ImageIcon(bytes); javax.swing.JLabel jlabel = new javax.swing.JLabel(\"Read from test.gif.b64\", iicon, 0); javax.swing.JFrame jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif_out\"); fos.write(bytes); fos.close(); fis = new java.io.FileInputStream(\"test.gif_out\"); b64is = new Base64.InputStream(fis, ENCODE); byte[] ebytes = new byte[0]; b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[ebytes.length + 1]; System.arraycopy(ebytes, 0, temp, 0, ebytes.length); temp[ebytes.length] = (byte) b; ebytes = temp; } b64is.close(); String s = new String(ebytes); javax.swing.JTextArea jta = new javax.swing.JTextArea(s); javax.swing.JScrollPane jsp = new javax.swing.JScrollPane(jta); jframe = new javax.swing.JFrame(); jframe.setTitle(\"Read from test.gif_out\"); jframe.getContentPane().add(jsp); jframe.pack(); jframe.setVisible(true); fos = new java.io.FileOutputStream(\"test.gif.b64_out\"); fos.write(ebytes); fis = new java.io.FileInputStream(\"test.gif.b64_out\"); b64is = new Base64.InputStream(fis, DECODE); byte[] edbytes = new byte[0]; b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[edbytes.length + 1]; System.arraycopy(edbytes, 0, temp, 0, edbytes.length); temp[edbytes.length] = (byte) b; edbytes = temp; } b64is.close(); iicon = new javax.swing.ImageIcon(edbytes); jlabel = new javax.swing.JLabel(\"Read from test.gif.b64_out\", iicon, 0); jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); } { java.io.FileInputStream fis = new java.io.FileInputStream(\"test.gif_out\"); byte[] rbytes = new byte[0]; int b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rbytes.length + 1]; System.arraycopy(rbytes, 0, temp, 0, rbytes.length); temp[rbytes.length] = (byte) b; rbytes = temp; } fis.close(); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif.b64_out2\"); Base64.OutputStream b64os = new Base64.OutputStream(fos, ENCODE); b64os.write(rbytes); b64os.close(); fis = new java.io.FileInputStream(\"test.gif.b64_out2\"); byte[] rebytes = new byte[0]; b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rebytes.length + 1]; System.arraycopy(rebytes, 0, temp, 0, rebytes.length); temp[rebytes.length] = (byte) b; rebytes = temp; } fis.close(); String s = new String(rebytes); javax.swing.JTextArea jta = new javax.swing.JTextArea(s); javax.swing.JScrollPane jsp = new javax.swing.JScrollPane(jta); javax.swing.JFrame jframe = new javax.swing.JFrame(); jframe.setTitle(\"Read from test.gif.b64_out2\"); jframe.getContentPane().add(jsp); jframe.pack(); jframe.setVisible(true); fos = new java.io.FileOutputStream(\"test.gif_out2\"); b64os = new Base64.OutputStream(fos, DECODE); b64os.write(rebytes); b64os.close(); javax.swing.ImageIcon iicon = new javax.swing.ImageIcon(\"test.gif_out2\"); javax.swing.JLabel jlabel = new javax.swing.JLabel(\"Read from test.gif_out2\", iicon, 0); jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); } { java.io.FileInputStream fis = new",
        "ground_truth": "NO",
        "predict": " java.io.FileInputStream(\"test.gif_out2\"); byte[] rbytes = new byte[0]; int b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rbytes.length + 1]; System.arraycopy(rbytes, 0, temp, 0, rbytes.length); temp[rbytes.length] = (byte) b; rbytes = temp; } fis.close(); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif.b64_out3\"); Base64.OutputStream b64os = new Base64.OutputStream(fos, ENCODE); b64os.write(rbytes); b64os.close(); fis = new java.io.FileInputStream(\"test.gif.b64_out3\"); byte[] rebytes = new byte[0]; b = -1; while ((b = fis.read()) >= 0"
    },
    {
        "ID": 457,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { boolean rotateLeft = false; boolean rotateRight = false; boolean exclude = false; boolean reset = false; float quality = 0f; int thumbArea = 12000; for (int i = 0; i < args.length; i++) { if (args[i].equals(\"-rotl\")) rotateLeft = true; else if (args[i].equals(\"-rotr\")) rotateRight = true; else if (args[i].equals(\"-exclude\")) exclude = true; else if (args[i].equals(\"-reset\")) reset = true; else if (args[i].equals(\"-quality\")) quality = Float.parseFloat(args[++i]); else if (args[i].equals(\"-area\")) thumbArea = Integer.parseInt(args[++i]); else { File f = new File(args[i]); try { Tools t = new Tools(f); if (exclude) { URL url = t.getClass().getResource(\"exclude.jpg\"); InputStream is = url.openStream(); File dest = t.getExcludeFile(); OutputStream os = new FileOutputStream(dest); byte[] buf = new byte[1024]; int len; while ((len = is.read(buf)) > 0) os.write(buf, 0, len); os.close(); is.close(); t.getOutFile().delete(); t.getThumbFile().delete(); System.exit(0); } if (reset) { t.getOutFile().delete(); t.getThumbFile().delete(); t.getExcludeFile().delete(); System.exit(0); } if (quality > 0) t.setQuality(quality); if (t.getType() == Tools.THUMB || t.getType() == Tools.EXCLUDE) t.load(t.getBaseFile()); else t.load(t.getSourceFile()); File out = t.getOutFile(); if (rotateLeft) t.rotateLeft(); else if (rotateRight) t.rotateRight(); t.save(out); t.getExcludeFile().delete(); t.getThumbFile().delete(); System.exit(0); } catch (Throwable e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, \"The operation could not be performed\", \"JPhotoAlbum\", JOptionPane.ERROR_MESSAGE); System.exit(1); } } } }. \n Code2: public static final String crypt(final String password, String salt, final String magic) { if (password == null) throw new IllegalArgumentException(\"Null password!\"); if (salt == null) throw new IllegalArgumentException(\"Null salt!\"); if (magic == null) throw new IllegalArgumentException(\"Null salt!\"); byte finalState[]; long l; MessageDigest ctx, ctx1; try { ctx = MessageDigest.getInstance(\"md5\"); ctx1 = MessageDigest.getInstance(\"md5\"); } catch (final NoSuchAlgorithmException ex) { System.err.println(ex); return null; } if (salt.startsWith(magic)) { salt = salt.substring(magic.length()); } if (salt.indexOf('$') != -1) { salt = salt.substring(0, salt.indexOf('$')); } if (salt.length() > 8) { salt = salt.substring(0, 8); } ctx.update(password.getBytes()); ctx.update(magic.getBytes()); ctx.update(salt.getBytes()); ctx1.update(password.getBytes()); ctx1.update(salt.getBytes()); ctx1.update(password.getBytes()); finalState = ctx1.digest(); for (int pl = password.length(); pl > 0; pl -= 16) { ctx.update(finalState, 0, pl > 16 ? 16 : pl); } clearbits(finalState); for (int i = password.length(); i != 0; i >>>= 1) { if ((i & 1) != 0) { ctx.update(finalState, 0, 1); } else { ctx.update(password.getBytes(), 0, 1); } } finalState = ctx.digest(); for (int i = 0; i < 1000; i++) { try { ctx1 = MessageDigest.getInstance(\"md5\"); } catch (final NoSuchAlgorithmException e0) { return null; } if ((i & 1) != 0) { ctx1.update(password.getBytes()); } else { ctx1.update(finalState, 0, 16); } if ((i % 3) != 0) { ctx1.update(salt.getBytes()); } if ((i % 7) != 0) { ctx1.update(password.getBytes()); } if ((i & 1) != 0) { ctx1.update(finalState, 0, 16); } else { ctx1.update(password.getBytes()); } finalState = ctx1.digest(); } final StringBuffer result = new StringBuffer(); result.append(magic); result.append(salt); result.append(\"$\"); l = (bytes2u(finalState[0]) << 16) | (bytes2u(finalState[6]) << 8) | bytes2u(finalState[12]); result.append(to64(l, 4)); l = (bytes2u(finalState[1]) << 16) | (bytes2u(finalState[7]) << 8) | bytes2u(finalState[13]); result.append(to64(l, 4)); l = (bytes2u(finalState[2]) << 16) | (bytes2u(finalState[8]) << 8) | bytes2u(finalState[14]); result.append(to64(l, 4)); l = (bytes2u(finalState[3]) << 16) | (bytes2u(finalState[9]) << 8) | bytes2u(finalState[15]); result.append(to64(l, 4)); l = (bytes2u(finalState[4]) << 16) | (bytes2u(finalState[10]) << 8) | bytes2u(finalState[5]); result.append(to64(l, 4)); l = bytes2u(finalState[11]); result.append(to64(l, 2)); clearbits(finalState); return result.toString(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String generateStackHashKey() { Exception e = null; try { throw new Exception(); } catch (Exception ex) { e = ex; } MessageDigest digest; try { digest = java.security.MessageDigest.getInstance(\"MD5\"); digest.update(getStackTrace(e).getBytes());",
        "ground_truth": "NO",
        "predict": " } catch (java.security.NoSuchAlgorithmException ex) { return null; } return toHex(digest.digest()); }. \n Code1: public static final String toHex(final byte[] data) { if (data == null) throw new IllegalArgumentException(\"Null data!\"); StringBuffer result = new StringBuffer(); for (int i = 0; i < data.length; i++) { result.append(Integer.toHexString(data[i] & 0xFF)); } return result.toString(); }. \n Code2: public static final String to64(final long l, final int pad) { String result = Long.toString(l, 36); if (pad > 0) { while (result.length() < pad) { result = \"0\" + result; } } return result; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO"
    },
    {
        "ID": 458,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \n Code2: private void trySend(Primitive p) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); try { mSerializer.serialize(p, out); } catch (SerializerException e) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.SERIALIZER_ERROR, \"Internal serializer error, primitive: \" + p.getType()); out.close(); return; } HttpPost req = new HttpPost(mPostUri); req.addHeader(mContentTypeHeader); if (mMsisdnHeader != null) { req.addHeader(mMsisdnHeader); } ByteArrayEntity entity = new ByteArrayEntity(out.toByteArray()); req.setEntity(entity); mLastActive = SystemClock.elapsedRealtime(); if (Log.isLoggable(ImpsLog.TAG, Log.DEBUG)) { long sendBytes = entity.getContentLength() + 176; ImpsLog.log(mConnection.getLoginUserName() + \" >> \" + p.getType() + \" HTTP payload approx. \" + sendBytes + \" bytes\"); } if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { ImpsLog.dumpRawPacket(out.toByteArray()); ImpsLog.dumpPrimitive(p); } HttpResponse res = mHttpClient.execute(req); StatusLine statusLine = res.getStatusLine(); HttpEntity resEntity = res.getEntity(); InputStream in = resEntity.getContent(); if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { Log.d(ImpsLog.PACKET_TAG, statusLine.toString()); Header[] headers = res.getAllHeaders(); for (Header h : headers) { Log.d(ImpsLog.PACKET_TAG, h.toString()); } int len = (int) resEntity.getContentLength(); if (len > 0) { byte[] content = new byte[len]; int offset = 0; int bytesRead = 0; do { bytesRead = in.read(content, offset, len); offset += bytesRead; len -= bytesRead; } while (bytesRead > 0); in.close(); ImpsLog.dumpRawPacket(content); in = new ByteArrayInputStream(content); } } try { if (statusLine.getStatusCode() != HttpURLConnection.HTTP_OK) { mTxManager.notifyErrorResponse(p.getTransactionID(), statusLine.getStatusCode(), statusLine.getReasonPhrase()); return; } if (resEntity.getContentLength() == 0) { if ((p.getTransactionMode() != TransactionMode.Response) && !p.getType().equals(ImpsTags.Polling_Request)) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.ILLEGAL_SERVER_RESPONSE, \"bad response from server\"); } return; } Primitive response = mParser.parse(in); if (Log.isLoggable(ImpsLog.PACKET_TAG, Log.DEBUG)) { ImpsLog.dumpPrimitive(response); } if (Log.isLoggable(ImpsLog.TAG, Log.DEBUG)) { long len = 2 + resEntity.getContentLength() + statusLine.toString().length() + 2; Header[] headers = res.getAllHeaders(); for (Header header : headers) { len += header.getName().length() + header.getValue().length() + 4; } ImpsLog.log(mConnection.getLoginUserName() + \" << \" + response.getType() + \" HTTP payload approx. \" + len + \"bytes\"); } if (!mReceiveQueue.offer(response)) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.UNKNOWN_ERROR, \"receiving queue full\"); } } catch (ParserException e) { ImpsLog.logError(e); mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.PARSER_ERROR, \"Parser error, received a bad response from server\"); } finally { resEntity.consumeContent(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static byte[] getJarEntry(String jarName, String entry, int port) { byte[] b = null; try { String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName()); String protocol = \"http://\"; int x = codebase.indexOf(protocol) + protocol.length(); String s2 = codebase.substring(x); int x2 = s2.indexOf('/'); String downloadHost = s2.substring(0, x2); if (downloadHost.indexOf(':') == -1) { downloadHost += \":\" + port; } URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry); JarURLConnection jurl = (JarURLConnection) url.openConnection(); JarEntry je = jurl.getJarEntry(); InputStream is = jurl.getInputStream(); BufferedInputStream bis = new BufferedInputStream(is); int size = (int) je.getSize(); b = new byte[size]; int rb = 0; int chunk = 0; while ((size - rb) > 0) { chunk = bis.read(b, rb, size - rb); if (chunk == -1) { break; } rb += chunk; } bis.close(); is.close(); bis = null; is = null; url = null; jurl = null; } catch (UnknownHostException e) { e.printStackTrace(); return null; } catch (IOException e) { e.printStackTrace(); return null; } return b; }. \n Code2: public static void main(String[] args) throws Exception { FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes())); fc.close(); fc = new FileInputStream(\"data2.txt\").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); System.out.println(buff.asCharBuffer()); buff.rew",
        "ground_truth": "NO",
        "predict": "ind(); System.out.println(buff.asCharBuffer()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \n Code2: private void trySend(Primitive p) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); try { mSerializer.serialize(p, out); } catch (SerializerException e) { mTxManager.notifyErrorResponse(p.getTransactionID(), ImErrorInfo.SERIAL"
    },
    {
        "ID": 460,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public synchronized AbstractBaseObject update(AbstractBaseObject obj) throws ApplicationException { PreparedStatement preStat = null; StringBuffer sqlStat = new StringBuffer(); MailSetting tmpMailSetting = (MailSetting) ((MailSetting) obj).clone(); synchronized (dbConn) { try { int updateCnt = 0; Timestamp currTime = Utility.getCurrentTimestamp(); sqlStat.append(\"UPDATE MAIL_SETTING \"); sqlStat.append(\"SET USER_RECORD_ID=?, PROFILE_NAME=?, MAIL_SERVER_TYPE=?, DISPLAY_NAME=?, EMAIL_ADDRESS=?, REMEMBER_PWD_FLAG=?, SPA_LOGIN_FLAG=?, INCOMING_SERVER_HOST=?, INCOMING_SERVER_PORT=?, INCOMING_SERVER_LOGIN_NAME=?, INCOMING_SERVER_LOGIN_PWD=?, OUTGOING_SERVER_HOST=?, OUTGOING_SERVER_PORT=?, OUTGOING_SERVER_LOGIN_NAME=?, OUTGOING_SERVER_LOGIN_PWD=?, PARAMETER_1=?, PARAMETER_2=?, PARAMETER_3=?, PARAMETER_4=?, PARAMETER_5=?, UPDATE_COUNT=?, UPDATER_ID=?, UPDATE_DATE=? \"); sqlStat.append(\"WHERE ID=? AND UPDATE_COUNT=? \"); preStat = dbConn.prepareStatement(sqlStat.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); setPrepareStatement(preStat, 1, tmpMailSetting.getUserRecordID()); setPrepareStatement(preStat, 2, tmpMailSetting.getProfileName()); setPrepareStatement(preStat, 3, tmpMailSetting.getMailServerType()); setPrepareStatement(preStat, 4, tmpMailSetting.getDisplayName()); setPrepareStatement(preStat, 5, tmpMailSetting.getEmailAddress()); setPrepareStatement(preStat, 6, tmpMailSetting.getRememberPwdFlag()); setPrepareStatement(preStat, 7, tmpMailSetting.getSpaLoginFlag()); setPrepareStatement(preStat, 8, tmpMailSetting.getIncomingServerHost()); setPrepareStatement(preStat, 9, tmpMailSetting.getIncomingServerPort()); setPrepareStatement(preStat, 10, tmpMailSetting.getIncomingServerLoginName()); setPrepareStatement(preStat, 11, tmpMailSetting.getIncomingServerLoginPwd()); setPrepareStatement(preStat, 12, tmpMailSetting.getOutgoingServerHost()); setPrepareStatement(preStat, 13, tmpMailSetting.getOutgoingServerPort()); setPrepareStatement(preStat, 14, tmpMailSetting.getOutgoingServerLoginName()); setPrepareStatement(preStat, 15, tmpMailSetting.getOutgoingServerLoginPwd()); setPrepareStatement(preStat, 16, tmpMailSetting.getParameter1()); setPrepareStatement(preStat, 17, tmpMailSetting.getParameter2()); setPrepareStatement(preStat, 18, tmpMailSetting.getParameter3()); setPrepareStatement(preStat, 19, tmpMailSetting.getParameter4()); setPrepareStatement(preStat, 20, tmpMailSetting.getParameter5()); setPrepareStatement(preStat, 21, new Integer(tmpMailSetting.getUpdateCount().intValue() + 1)); setPrepareStatement(preStat, 22, sessionContainer.getUserRecordID()); setPrepareStatement(preStat, 23, currTime); setPrepareStatement(preStat, 24, tmpMailSetting.getID()); setPrepareStatement(preStat, 25, tmpMailSetting.getUpdateCount()); updateCnt = preStat.executeUpdate(); dbConn.commit(); if (updateCnt == 0) { throw new ApplicationException(ErrorConstant.DB_CONCURRENT_ERROR); } else { tmpMailSetting.setUpdaterID(sessionContainer.getUserRecordID()); tmpMailSetting.setUpdateDate(currTime); tmpMailSetting.setUpdateCount(new Integer(tmpMailSetting.getUpdateCount().intValue() + 1)); tmpMailSetting.setCreatorName(UserInfoFactory.getUserFullName(tmpMailSetting.getCreatorID())); tmpMailSetting.setUpdaterName(UserInfoFactory.getUserFullName(tmpMailSetting.getUpdaterID())); return (tmpMailSetting); } } catch (Exception e) { try { dbConn.rollback(); } catch (Exception ex) { } log.error(e, e); throw new ApplicationException(ErrorConstant.DB_UPDATE_ERROR, e); } finally { try { preStat.close(); } catch (Exception ignore) { } finally { preStat = null; } } } }. \n Code2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; final StringBuilder sbValueBeforeMD5 = new StringBuilder(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { logger.fatal(\"\", e); return; } try { final long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(sId); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); final byte[] array = md5.digest(); final StringBuilder sb = new StringBuilder(); for (int j = 0; j < array.length; ++j) { final int b = array[j] & 0xFF; if (b < 0x10) { sb.append('0'); } sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { logger.fatal(\"\", e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String encryptPassword(String password) throws NoSuchAlgorithmException { StringBuffer encryptedPassword = new StringBuffer(); MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.reset(); md5.update(password.getBytes()); byte digest[] = md5.digest(); for (int i = 0; i < digest.length; i++) { String hex = Integer.toHexString(0xFF & digest[i]); if (hex.",
        "ground_truth": "YES",
        "predict": "length() == 1) { encryptedPassword.append('0'); } encryptedPassword.append(hex); } return encryptedPassword.toString(); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String decryptPassword(String encryptedPassword) throws NoSuchAlgorithmException { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.reset(); md5.update(encryptedPassword.getBytes()); byte digest[] = md5.digest(); for (int i = 0; i < digest.length; i++) { String hex = Integer.toHexString(0xFF & digest[i]); if (hex.length() == 1) { encryptedPassword = '0' + encryptedPassword; } } return encryptedPassword; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO."
    },
    {
        "ID": 462,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public DialogSongList(JFrame frame) { super(frame, \"Menu_SongList\", \"songList\"); setMinimumSize(new Dimension(400, 200)); JPanel panel, spanel; Container contentPane; (contentPane = getContentPane()).add(songSelector = new SongSelector(configKey, null, true)); songSelector.setSelectionAction(new Runnable() { public void run() { final Item<URL, MidiFileInfo> item = songSelector.getSelectedInfo(); if (item != null) { try { selection = new File(item.getKey().toURI()); author.setEnabled(true); title.setEnabled(true); difficulty.setEnabled(true); save.setEnabled(true); final MidiFileInfo info = item.getValue(); author.setText(info.getAuthor()); title.setText(info.getTitle()); Util.selectKey(difficulty, info.getDifficulty()); return; } catch (Exception e) { } } selection = null; author.setEnabled(false); title.setEnabled(false); difficulty.setEnabled(false); save.setEnabled(false); } }); contentPane.add(panel = new JPanel(), BorderLayout.SOUTH); panel.setLayout(new BorderLayout()); JScrollPane scrollPane; panel.add(scrollPane = new JScrollPane(spanel = new JPanel()), BorderLayout.NORTH); scrollPane.setPreferredSize(new Dimension(0, 60)); Util.addLabeledComponent(spanel, \"Lbl_Author\", author = new JTextField(10)); Util.addLabeledComponent(spanel, \"Lbl_Title\", title = new JTextField(14)); Util.addLabeledComponent(spanel, \"Lbl_Difficulty\", difficulty = new JComboBox()); difficulty.addItem(new Item<Byte, String>((byte) -1, \"\")); for (Map.Entry<Byte, String> entry : SongSelector.DIFFICULTIES.entrySet()) { final String value = entry.getValue(); difficulty.addItem(new Item<Byte, String>(entry.getKey(), Util.getMsg(value, value), value)); } spanel.add(save = new JButton()); Util.updateButtonText(save, \"Save\"); save.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { final File selected = MidiSong.setMidiFileInfo(selection, author.getText(), title.getText(), getAsByte(difficulty)); SongSelector.refresh(); try { songSelector.setSelected(selected == null ? null : selected.toURI().toURL()); } catch (MalformedURLException ex) { } } }); author.setEnabled(false); title.setEnabled(false); difficulty.setEnabled(false); save.setEnabled(false); JButton button; panel.add(spanel = new JPanel(), BorderLayout.WEST); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Import\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { final File inputFile = KeyboardHero.midiFile(); try { if (inputFile == null) return; final File dir = (new File(Util.DATA_FOLDER + MidiSong.MIDI_FILES_DIR)); if (dir.exists()) { if (!dir.isDirectory()) { Util.error(Util.getMsg(\"Err_MidiFilesDirNotDirectory\"), dir.getParent()); return; } } else if (!dir.mkdirs()) { Util.error(Util.getMsg(\"Err_CouldntMkDir\"), dir.getParent()); return; } File outputFile = new File(dir.getPath() + File.separator + inputFile.getName()); if (!outputFile.exists() || KeyboardHero.confirm(\"Que_FileExistsOverwrite\")) { final FileChannel inChannel = new FileInputStream(inputFile).getChannel(); inChannel.transferTo(0, inChannel.size(), new FileOutputStream(outputFile).getChannel()); } } catch (Exception ex) { Util.getMsg(Util.getMsg(\"Err_CouldntImportSong\"), ex.toString()); } SongSelector.refresh(); } }); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Delete\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if (KeyboardHero.confirm(Util.getMsg(\"Que_SureToDelete\"))) { try { new File(songSelector.getSelectedFile().toURI()).delete(); } catch (Exception ex) { Util.error(Util.getMsg(\"Err_CouldntDeleteFile\"), ex.toString()); } SongSelector.refresh(); } } }); panel.add(spanel = new JPanel(), BorderLayout.CENTER); spanel.setLayout(new FlowLayout()); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Close\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { close(); } }); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Play\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Game.newGame(songSelector.getSelectedFile()); close(); } }); panel.add(spanel = new JPanel(), BorderLayout.EAST); spanel.add(button = new JButton()); Util.updateButtonText(button, \"Refresh\"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SongSelector.refresh(); } }); getRootPane().setDefaultButton(button); instance = this; }. \n Code2: public static Element retrieveFromCache(String cacheName, Object key) { URL url = null; HttpURLConnection connection = null; InputStream is = null; OutputStream os = null; int result = 0; StringBuilder sb = null; Element cacheElement = null; try { url = new URL(EHCACHE_SERVER_BASE + \"/\" + cacheName + \"/\" + key); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.connect(); is = connection.getInputStream(); byte[] response = new byte[4096]; result = is.read(response); while (result != -1) { sb.append(response); result = is.read(response); } if (is != null) { try { is.close(); } catch (Exception ignore) { } } if (connection != null) { connection.disconnect(); } cacheElement = new Element(key, s",
        "ground_truth": "NO",
        "predict": "b.toString()); } catch (Exception ex) { } finally { try { if (is != null) is.close(); } catch (Exception ignore) { } try { if (os != null) os.close(); } catch (Exception ignore) { } try { if (connection != null) connection.disconnect(); } catch (Exception ignore) { } } return cacheElement; }\n Code3: public static void saveToCache(String cacheName, Object key, Element cacheElement) { URL url = null; HttpURLConnection connection = null; OutputStream os = null; try { url = new URL(EHCACHE_SERVER_BASE + \"/\" + cacheName + \"/\" + key); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"PUT\"); connection.setDoOutput(true); connection.setRequestProperty(\"Content-Type\", \"text/xml\"); connection.setRequestProperty(\"Content-Length\", \"\" + cacheElement.getSize()); connection."
    },
    {
        "ID": 482,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void request() { try { URL url = new URL(\"http://www.nseindia.com/marketinfo/companyinfo/companysearch.jsp?cons=ghcl&section=7\"); URLConnection conn = url.openConnection(); conn.setDoOutput(true); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = rd.readLine()) != null) { System.out.println(line); } rd.close(); } catch (Exception e) { e.printStackTrace(); } }. \n Code2: public void process(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException { String UrlStr = req.getRequestURL().toString(); URL domainurl = new URL(UrlStr); domain = domainurl.getHost(); pathinfo = req.getPathInfo(); String user_agent = req.getHeader(\"user-agent\"); UserAgent userAgent = UserAgent.parseUserAgentString(user_agent); String browser = userAgent.getBrowser().getName(); String[] shot_domain_array = domain.split(\"\\\\.\"); shot_domain = shot_domain_array[1] + \".\" + shot_domain_array[2]; if (browser.equalsIgnoreCase(\"Robot/Spider\") || browser.equalsIgnoreCase(\"Lynx\") || browser.equalsIgnoreCase(\"Downloading Tool\")) { JSONObject domainJsonObject = CsvReader.CsvReader(\"domainparUpdated.csv\", shot_domain); log.info(domainJsonObject.toString()); } else { String title; String locale; String facebookid; String color; String headImage; String google_ad_client; String google_ad_slot1; String google_ad_width1; String google_ad_height1; String google_ad_slot2; String google_ad_width2; String google_ad_height2; String google_ad_slot3; String google_ad_width3; String google_ad_height3; String countrycode = null; String city = null; String gmclickval = null; String videos = null; int intcount = 0; String strcount = \"0\"; boolean countExist = false; Cookie[] cookies = req.getCookies(); if (cookies != null) { for (int i = 0; i < cookies.length; i++) { if (cookies[i].getName().equals(\"count\")) { strcount = cookies[i].getValue(); if (strcount != null && strcount.length() > 0) { log.info(\"Check count \" + strcount + \" path \" + cookies[i].getPath()); intcount = Integer.parseInt(strcount); intcount++; } else { intcount = 1; } log.info(\"New count \" + intcount); LongLivedCookie count = new LongLivedCookie(\"count\", Integer.toString(intcount)); resp.addCookie(count); countExist = true; } if (cookies[i].getName().equals(\"countrycode\")) { countrycode = cookies[i].getValue(); } if (cookies[i].getName().equals(\"city\")) { city = cookies[i].getValue(); } if (cookies[i].getName().equals(\"videos\")) { videos = cookies[i].getValue(); log.info(\"Welcome videos \" + videos); } if (cookies[i].getName().equals(\"gmclick\")) { log.info(\"gmclick exist!!\"); gmclickval = cookies[i].getValue(); if (intcount % 20 == 0 && intcount > 0) { log.info(\"Cancell gmclick -> \" + gmclickval + \" intcount \" + intcount + \" path \" + cookies[i].getPath()); Cookie gmclick = new Cookie(\"gmclick\", \"0\"); gmclick.setPath(\"/\"); gmclick.setMaxAge(0); resp.addCookie(gmclick); } } } if (!countExist) { LongLivedCookie count = new LongLivedCookie(\"count\", \"0\"); resp.addCookie(count); log.info(\" Not First visit count Don't Exist!!\"); } if (videos == null) { LongLivedCookie videoscookies = new LongLivedCookie(\"videos\", \"0\"); resp.addCookie(videoscookies); log.info(\"Not First visit VIDEOS Don't Exist!!\"); } } else { LongLivedCookie count = new LongLivedCookie(\"count\", strcount); resp.addCookie(count); LongLivedCookie videosfirstcookies = new LongLivedCookie(\"videos\", \"0\"); resp.addCookie(videosfirstcookies); log.info(\"First visit count = \" + intcount + \" videos 0\"); } String[] dompar = CommUtils.CsvParsing(domain, \"domainpar.csv\"); title = dompar[0]; locale = dompar[1]; facebookid = dompar[2]; color = dompar[3]; headImage = dompar[4]; google_ad_client = dompar[5]; google_ad_slot1 = dompar[6]; google_ad_width1 = dompar[7]; google_ad_height1 = dompar[8]; google_ad_slot2 = dompar[9]; google_ad_width2 = dompar[10]; google_ad_height2 = dompar[11]; google_ad_slot3 = dompar[12]; google_ad_width3 = dompar[13]; google_ad_height3 = dompar[14]; String ip = req.getRemoteHost(); if ((countrycode == null) || (city == null)) { String ipServiceCall = \"http://api.ipinfodb.com/v2/ip_query.php?key=abbb04fd823793c5343a046e5d56225af37861b9020e9bc86313eb20486b6133&ip=\" + ip + \"&output=json\"; String strCallResult = \"\"; URL url = new URL(ipServiceCall); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF8\")); StringBuffer response = new StringBuffer(); String line; while ((line = reader.readLine()) != null) { response.append(line); } reader.close(); strCallResult = response.toString(); try { JSONObject jso = new JSONObject(strCallResult); log.info(\"Status -> \" + jso.get(\"Status\").toString()); log.info(\"City -> \" + jso.get(\"City\").toString()); city = jso.get(\"City\").toString(); countrycode = jso.get(\"CountryCode\").toString(); log.info(\"countrycode -> \" + countrycode); if ((city.length() == 0) || (city == null)) { LongLivedC",
        "ground_truth": "NO",
        "predict": "ookie citycookie = new LongLivedCookie(\"city\", \"0\"); resp.addCookie(citycookie); city = \"0\"; } } catch (JSONException e) { e.printStackTrace(); } } }\n"
    },
    {
        "ID": 483,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void copyFileToFileWithPaths(String sourcePath, String destinPath) throws Exception { BufferedInputStream in = null; BufferedOutputStream out = null; byte dataBuff[] = new byte[bufferSize]; File file1 = new File(sourcePath); if (file1.exists() && (file1.isFile())) { File file2 = new File(destinPath); if (file2.exists()) { file2.delete(); } FileUtils.getInstance().createDirectory(file2.getParent()); in = new BufferedInputStream(new FileInputStream(sourcePath), bufferSize); out = new BufferedOutputStream(new FileOutputStream(destinPath), bufferSize); int readLen; while ((readLen = in.read(dataBuff)) > 0) { out.write(dataBuff, 0, readLen); } out.flush(); in.close(); out.close(); } else { throw new Exception(\"Source file not exist ! sourcePath = (\" + sourcePath + \")\"); } }. \n Code2: public void run() { XmlFilesFilter filter = new XmlFilesFilter(); String pathTemp = Settings.get(\"vo_store.databaseMetaCollection\"); String sectionName = pathTemp.substring(1, pathTemp.indexOf(\"/\", 2)); String templateName = VOAccess.getElementByName(settingsDB, \"TEMPLATE\", sectionName); String schemaName = VOAccess.getElementByName(settingsDB, \"SCHEMA\", sectionName); byte[] buf = new byte[1024]; Hashtable templateElements = null; try { URL xmlTemplateUrl = new URL(httpURI + settingsDB + \"/\" + templateName); URL getDocPathsAndValuesXslUrl = new URL(httpURI + settingsDB + \"/\" + \"getDocPathsValuesAndDisplays.xsl\"); org.w3c.dom.Document curTemplateXml = VOAccess.readDocument(xmlTemplateUrl); DOMResult templateResult = new DOMResult(); InputStream tempInput = getDocPathsAndValuesXslUrl.openStream(); javax.xml.transform.sax.SAXSource tempXslSource = new javax.xml.transform.sax.SAXSource(new org.xml.sax.InputSource(tempInput)); Transformer trans = TransformerFactory.newInstance().newTransformer(tempXslSource); trans.setParameter(\"schemaUrl\", httpURI + settingsDB + \"/\" + schemaName); trans.transform(new javax.xml.transform.dom.DOMSource(curTemplateXml), templateResult); tempInput.close(); templateElements = VOAccess.displaysToHashtable(templateResult); ((CollectionManagementService) CollectionsManager.getService(xmldbURI + rootDB, false, \"CollectionManager\")).createCollection(rootDB + pathTemp); } catch (Exception ex) { logger.error(\"Error parsing input document\", ex); ex.printStackTrace(); } while (true) { File[] fileList = sourceMetaFilesDir.listFiles(filter); for (int i = 0; i < Math.min(fileList.length, 500); i++) { File newFile = fileList[i]; try { Document metaDoc = build.build(newFile); Element metaElm = metaDoc.getRootElement(); String dataFileName = metaElm.getChildText(\"Content\"), previewFileName = metaElm.getChildText(\"Preview\"); String objId = VOAccess.getUniqueId(); metaElm.getChild(\"Content\").setText(\"videostore?type=doc&objId=\" + objId); metaElm.getChild(\"Preview\").setText(\"videostore?type=preview&objId=\" + objId); boolean found = false; for (Iterator it = sourceDataFilesDirs.iterator(); it.hasNext() && !found; ) { String sourceDataFilesDir = (String) it.next(); File dataInput = new File(sourceDataFilesDir + \"/\" + dataFileName); if (dataInput.exists()) { found = true; BufferedInputStream inp = new BufferedInputStream(new FileInputStream(dataInput)); FileOutputStream outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".dat\")); int read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); dataInput = new File(sourceDataFilesDir + \"/\" + previewFileName); inp = new BufferedInputStream(new FileInputStream(dataInput)); outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".jpg\")); read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); curDirWriteTo++; if (curDirWriteTo >= targetDataFilesDirs.size()) { curDirWriteTo = 0; } } } if (!found) { newFile.renameTo(new File(newFile.getAbsolutePath() + \".not_found\")); } else { String title = getValueByPath((String) templateElements.get(\"title\"), metaDoc.getRootElement()); String description = getValueByPath((String) templateElements.get(\"description\"), metaDoc.getRootElement()); String onlink = \"\"; if (null != templateElements.get(\"onlink\")) { onlink = getValueByPath((String) templateElements.get(\"onlink\"), metaDoc.getRootElement()); } String ncover = \"\"; if (null != templateElements.get(\"ncover\")) { ncover = getValueByPath((String) templateElements.get(\"ncover\"), metaDoc.getRootElement()); } String wcover = \"\"; if (null != templateElements.get(\"wcover\")) { wcover = getValueByPath((String) templateElements.get(\"wcover\"), metaDoc.getRootElement()); } String ecover = \"\"; if (null != templateElements.get(\"ecover\")) { ecover = getValueByPath((String) templateElements.get(\"ecover\"), metaDoc.getRootElement()); } String scover = \"\"; if (null != templateElements.get(\"scover\")) { scover = getValueByPath((String) templateElements.get(\"scover\"), metaDoc.getRootElement()); } String datefrom = \"\"; if (null != templateElements.get(\"datefrom\")) { datefrom = getValueByPath((String) templateElements.get(\"datefrom\"), metaDoc.getRootElement()); } String dateto =",
        "ground_truth": "NO",
        "predict": " \"\"; if (null != templateElements.get(\"dateto\")) { dateto = getValueByPath((String) templateElements.get(\"dateto\"), metaDoc.getRootElement()); } String datefrom2 = \"\"; if (null != templateElements.get(\"datefrom2\")) { datefrom2 = getValueByPath((String) templateElements.get(\"datefrom2\"), metaDoc.getRootElement()); } String dateto2 = \"\"; if (null != templateElements.get(\"dateto2\")) { dateto2 = getValueByPath((String) templateElements.get(\"dateto2\"), metaDoc.getRootElement()); } String datefrom3 = \"\"; if (null != templateElements.get(\"datefrom3\")) { datefrom3 = getValueByPath((String) templateElements.get(\"datefrom3\"), metaDoc.getRootElement()); } String dateto3 = \"\"; if (null != templateElements.get(\"dateto3"
    },
    {
        "ID": 486,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void download(URL url, File destination, long beginRange, long endRange, long totalFileSize, boolean appendToFile) throws DownloadException { System.out.println(\" DOWNLOAD REQUEST RECEIVED \" + url.toString() + \" \\n\\tbeginRange : \" + beginRange + \" - EndRange \" + endRange + \" \\n\\t to -> \" + destination.getAbsolutePath()); try { if (destination.exists() && !appendToFile) { destination.delete(); } if (!destination.exists()) destination.createNewFile(); GetMethod get = new GetMethod(url.toString()); HttpClient httpClient = new HttpClient(); Header rangeHeader = new Header(); rangeHeader.setName(\"Range\"); rangeHeader.setValue(\"bytes=\" + beginRange + \"-\" + endRange); get.setRequestHeader(rangeHeader); httpClient.executeMethod(get); int statusCode = get.getStatusCode(); if (statusCode >= 400 && statusCode < 500) throw new DownloadException(\"The file does not exist in this location : message from server -> \" + statusCode + \" \" + get.getStatusText()); InputStream input = get.getResponseBodyAsStream(); OutputStream output = new FileOutputStream(destination, appendToFile); try { int length = IOUtils.copy(input, output); System.out.println(\" Length : \" + length); } finally { input.close(); output.flush(); output.close(); } } catch (Exception e) { e.printStackTrace(); logger.error(\"Unable to figure out the length of the file from the URL : \" + e.getMessage()); throw new DownloadException(\"Unable to figure out the length of the file from the URL : \" + e.getMessage()); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String postRequest(String urlString, HashMap data) { String returnData = \"\"; try { URL url = new URL(urlString); URLConnection connection = url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); PrintWriter out = new PrintWriter(connection.getOutputStream()); Object[] keySet = data.keySet().toArray(); Object[] values = data.values().toArray(); for (int count = 0; count < keySet.length; count++) { out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count])); if ((count + 1) < keySet.length) out.print(\"&\"); } out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream",
        "ground_truth": "NO",
        "predict": "())); String line; while ((line = in.readLine()) != null) { returnData += line; } in.close(); } catch (Exception e) { e.printStackTrace(); } return returnData; }. \n Code2: public static String uid(String uid) { return uid.replaceAll(\"[^0-9a-zA-Z]\", \"\"); }. \n */"
    },
    {
        "ID": 487,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: final void saveProject(Project project, final File file) { if (projectsList.contains(project)) { if (project.isDirty() || !file.getParentFile().equals(workspaceDirectory)) { try { if (!file.exists()) { if (!file.createNewFile()) throw new IOException(\"cannot create file \" + file.getAbsolutePath()); } File tmpFile = File.createTempFile(\"JFPSM\", \".tmp\"); ZipOutputStream zoStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file))); zoStream.setMethod(ZipOutputStream.DEFLATED); ZipEntry projectXMLEntry = new ZipEntry(\"project.xml\"); projectXMLEntry.setMethod(ZipEntry.DEFLATED); zoStream.putNextEntry(projectXMLEntry); CustomXMLEncoder encoder = new CustomXMLEncoder(new BufferedOutputStream(new FileOutputStream(tmpFile))); encoder.writeObject(project); encoder.close(); int bytesIn; byte[] readBuffer = new byte[1024]; FileInputStream fis = new FileInputStream(tmpFile); while ((bytesIn = fis.read(readBuffer)) != -1) zoStream.write(readBuffer, 0, bytesIn); fis.close(); ZipEntry entry; String floorDirectory; for (FloorSet floorSet : project.getLevelSet().getFloorSetsList()) for (Floor floor : floorSet.getFloorsList()) { floorDirectory = \"levelset/\" + floorSet.getName() + \"/\" + floor.getName() + \"/\"; for (MapType type : MapType.values()) { entry = new ZipEntry(floorDirectory + type.getFilename()); entry.setMethod(ZipEntry.DEFLATED); zoStream.putNextEntry(entry); ImageIO.write(floor.getMap(type).getImage(), \"png\", zoStream); } } final String tileDirectory = \"tileset/\"; for (Tile tile : project.getTileSet().getTilesList()) for (int textureIndex = 0; textureIndex < tile.getMaxTextureCount(); textureIndex++) if (tile.getTexture(textureIndex) != null) { entry = new ZipEntry(tileDirectory + tile.getName() + textureIndex + \".png\"); entry.setMethod(ZipEntry.DEFLATED); zoStream.putNextEntry(entry); ImageIO.write(tile.getTexture(textureIndex), \"png\", zoStream); } zoStream.close(); tmpFile.delete(); } catch (IOException ioe) { throw new RuntimeException(\"The project \" + project.getName() + \" cannot be saved!\", ioe); } } } else throw new IllegalArgumentException(\"The project \" + project.getName() + \" is not handled by this project set!\"); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); }",
        "ground_truth": "NO",
        "predict": " catch (Exception e) { System.out.println(\"\\n\" + src + \": conversion failed!\"); } }. \n Code3: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds."
    },
    {
        "ID": 493,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void listgroups() throws Exception { String lapage = new String(\"\"); Pattern pat; Matcher mat; int data; URL myurl = new URL(\"http://groups.yahoo.com/mygroups\"); URLConnection conn; URI myuri = new URI(\"http://groups.yahoo.com/mygroups\"); YahooInfo yi; clearAll(); System.out.print(\"http://groups.yahoo.com/mygroups : \"); do { myurl = new URL(myurl.toString()); conn = myurl.openConnection(); conn.connect(); if (!Pattern.matches(\"HTTP/... 2.. .*\", conn.getHeaderField(0).toString())) { System.out.println(conn.getHeaderField(0).toString()); return; } System.out.print(\".\"); InputStream in = conn.getInputStream(); lapage = \"\"; for (data = in.read(); data != -1; data = in.read()) lapage += (char) data; pat = Pattern.compile(\"<td class=\\\"grpname selected\\\"><a href=\\\"(.+?)\\\".*?><em>(.+?)</em></a>\"); mat = pat.matcher(lapage); while (mat.find()) { yi = new YahooInfo(mat.group(2), \"\", \"\", myuri.resolve(HTMLDecoder.decode(mat.group(1))).toURL().toString()); UrlList.add(yi); } pat = Pattern.compile(\"<a href=\\\"(.+?)\\\">Next &gt;</a>\"); mat = pat.matcher(lapage); myurl = null; if (mat.find()) { myurl = myuri.resolve(HTMLDecoder.decode(mat.group(1))).toURL(); } } while (myurl != null); System.out.println(\"\"); }. \n Code2: public static File insertFileInto(File zipFile, File toInsert, String targetPath) { Zip64File zip64File = null; try { boolean compress = false; zip64File = new Zip64File(zipFile); FileEntry testEntry = getFileEntry(zip64File, targetPath); if (testEntry != null && testEntry.getMethod() == FileEntry.iMETHOD_DEFLATED) { compress = true; } processAndCreateFolderEntries(zip64File, parseTargetPath(targetPath, toInsert), compress); if (testEntry != null) { log.info(\"[insertFileInto] Entry exists: \" + testEntry.getName()); log.info(\"[insertFileInto] Will delete this entry before inserting: \" + toInsert.getName()); if (!testEntry.isDirectory()) { zip64File.delete(testEntry.getName()); } else { log.info(\"[insertFileInto] Entry is a directory. \" + \"Will delete all files contained in this entry and insert \" + toInsert.getName() + \"and all nested files.\"); if (!targetPath.contains(\"/\")) { targetPath = targetPath + \"/\"; } deleteFileEntry(zip64File, testEntry); log.info(\"[insertFileInto] Entry successfully deleted.\"); } log.info(\"[insertFileInto] Writing new Entry: \" + targetPath); EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile); IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } else { EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile);",
        "ground_truth": "NO",
        "predict": " IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } catch (Exception e) { e.printStackTrace(); } } private static FileEntry getFileEntry(Zip64File zip64File, String path) { FileEntry testEntry = null; try { testEntry = zip64File.getFileEntry(path); } catch (Exception e) { } return testEntry; } private static void processAndCreateFolderEntries(Zip64File zip64File, String targetPath, boolean compress) throws IOException { EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(target"
    },
    {
        "ID": 502,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { ejb.bprocess.OAIPMH.AutoHarvesterSession ahSession = home.create(); java.util.Vector vector = new java.util.Vector(1, 1); Integer libraryId = new Integer(1); String xmlstr = \"\"; String str = \"\"; String arr[] = new String[2]; String[] subarr = new String[4]; String mdPrefix = \"\", mdPrefixValue = \"\"; String from = \"\", fromValue = \"\"; String until = \"\", untilValue = \"\"; String set = \"\", setValue = \"\"; String oai_pmhRequest = request.getParameter(\"verb\"); String oai_pmhQuery = request.getQueryString(); String urlStr = \"\"; urlStr = \"http://\" + request.getServerName() + \":\" + request.getServerPort() + \"/newgenlibctxt/HarvestServlet\"; String attribute = oai_pmhQuery; String arguments = attribute.substring(attribute.indexOf(\"?\") + 1); StringTokenizer st = new StringTokenizer(arguments, \"&\"); int i = 0; int j = 0; int z = 0; int count = 0; String type = \"\"; while (st.hasMoreTokens()) { arr[i] = st.nextToken(); StringTokenizer subst = new StringTokenizer(arr[i], \"=\"); while (subst.hasMoreTokens()) { subarr[j] = subst.nextToken(); j++; } i++; count++; } int mdfCount = 0, fromCount = 0, untilCount = 0, setCount = 0; ListRecords lr = new ListRecords(); for (int k = 0; k < j; k += 2) { if (subarr[k].equals(\"from\")) { from = \"from\"; fromCount++; fromValue = subarr[k + 1]; fromValue = lr.validateDate(fromValue); } else if (subarr[k].equals(\"until\")) { until = \"until\"; untilCount++; untilValue = subarr[k + 1]; untilValue = lr.validateDate(untilValue); } } if (fromValue.equals(\"\") && untilCount == 1) { fromValue = lr.validateDate(\"0001-01-01\"); } else if (untilValue.equals(\"\") && fromCount == 1) { String a = (new Resdate()).getDate(); untilValue = a.substring(0, a.indexOf(\"T\")); } System.out.println(\"This is fromValue:\" + fromValue); System.out.println(\"This is untilValue:\" + untilValue); vector = ahSession.getHarvestLibrary(null, libraryId); String harlibraryId = \"\"; if (vector.size() > 0) { for (int k = 0; k < vector.size(); k = k + 3) { harlibraryId = vector.elementAt(k).toString(); String harvesturl = vector.elementAt(k + 1).toString(); String status = vector.elementAt(k + 2).toString(); if (status.equals(\"A\")) { String oai_pmhRequest1 = request.getParameter(\"verb\"); String oai_pmhQuery1 = request.getQueryString(); urlStr = \"http://\" + harvesturl + \":8080/newgenlibctxt/oai2.0?verb=ListRecords&metadataPrefix=marc21&from=\" + fromValue + \"&until=\" + untilValue + \"\"; boolean resExists = true; for (int n = 0; resExists == true; n++) { java.net.URL url = new java.net.URL(urlStr); java.net.URLConnection urlCon = url.openConnection(); urlCon.setDoInput(true); urlCon.connect(); InputStream is = urlCon.getInputStream(); System.out.println(\"input\" + is.available()); org.jdom.input.SAXBuilder sb = new org.jdom.input.SAXBuilder(); org.jdom.Document doc = sb.build(is); xmlstr = (new org.jdom.output.XMLOutputter()).outputString(doc); System.out.println(\"xmlStr:\" + xmlstr); doc = null; sb = null; java.util.Vector vec = new java.util.Vector(); vec = ahSession.autoInitialHarvest(null, xmlstr, harlibraryId); String resT = doc.getRootElement().getChildText(\"resumptionToken\", doc.getRootElement().getNamespace()); if (!(resT == null)) { urlStr = \"http://\" + harvesturl + \":8080/newgenlibctxt/oai2.0?verb=ListRecords&resumptionToken=\" + resT; } else { resExists = false; } } } else if (status.equals(\"B\")) { java.io.File file = new java.io.File(harvesturl); java.io.File[] file1 = file.listFiles(); for (int b = 0; b < file1.length; b++) { File file2 = (File) file1[b]; System.out.println(\"File2:\" + file2); long lastmodifed = file2.lastModified(); StringTokenizer st1 = new StringTokenizer(fromValue, \"-\"); String dar[] = new String[3]; java.util.Calendar c1 = java.util.Calendar.getInstance(); int g = 0; while (st1.hasMoreElements()) { dar[g] = st1.nextToken(); g++; } c1.set(Integer.parseInt(dar[0]), Integer.parseInt(dar[1]), Integer.parseInt(dar[2])); StringTokenizer st2 = new StringTokenizer(untilValue, \"-\"); String dar1[] = new String[3]; java.util.Calendar c2 = java.util.Calendar.getInstance(); int d = 0; while (st2.hasMoreElements()) { dar1[d] = st2.nextToken(); d++; } c2.set(Integer.parseInt(dar1[0]), Integer.parseInt(dar1[1]), Integer.parseInt(dar1[2])); java.util.Calendar c3 = java.util.Calendar.getInstance(); c3.setTimeInMillis(lastmodifed); c3.set(java.util.Calendar.HOUR, 0); c3.set(java.util.Calendar.AM_PM, java.util.Calendar.AM); c3.set(java.util.Calendar.MINUTE, 0); c3.set(java.util.Calendar.SECOND, 0); c3.set(java.util.Calendar.MILLISECOND, 0); java.",
        "ground_truth": "NO",
        "predict": "util.Date d1 = c3.getTime(); if (c1.after(c2) && c1.before(d1)) { String xmlstr1 = \"\"; xmlstr1 = ahSession.autoHarvest(null, file2.getAbsolutePath(), harlibraryId); if (xmlstr1 != null) { System.out.println(\"xmlStr1:\" + xmlstr1); } } } } } catch (Exception e) { e.printStackTrace(); } }\n\n}\n"
    },
    {
        "ID": 506,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public TDSScene loadScene(URL url) throws IOException, IncorrectFormatException, ParsingErrorException { boolean baseURLWasNull = setBaseURLFromModelURL(url); TDSScene scene = loadScene(url.openStream()); if (baseURLWasNull) { popBaseURL(); } return (scene); }. \n Code2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\"export_page\"); query = query.replace(\"[RANDOM_INT]\", \"\" + random.nextInt()); int statusCode = -1; GetMethod get = new GetMethod(query); if (log.isInfoEnabled()) log.info(\"getting all contacts ...\"); try { statusCode = client.executeMethod(get); if (statusCode != 200) throw new GmailException(\"In contacts export page: Status code expected: 200 -> Status code returned: \" + statusCode); } catch (HttpException e) { throw new GmailException(\"HttpException in contacts export page:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in contacts export page:\" + e.getMessage()); } finally { get.releaseConnection(); } if (log.isTraceEnabled()) log.trace(\"accessing contacts export page successful...\"); String query_post = properties.getString(\"outlook_export_page\"); PostMethod post = new PostMethod(query_post); post.addRequestHeader(\"Accept-Encoding\", \"gzip,deflate\"); post.addRequestHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.8\"); NameValuePair[] data = { new NameValuePair(\"at\", getCookie(\"GMAIL_AT\")), new NameValuePair(\"ecf\", \"o\"), new NameValuePair(\"ac\", \"Export Contacts\") }; post.setRequestBody(data); if (log.isTraceEnabled()) log.trace(\"getting contacts csv file...\"); try { statusCode = client.executeMethod(post); if (statusCode != 200) throw new GmailException(\"In csv file post: Status code expected: 200 -> Status code returned: \" + statusCode); if (log.isTraceEnabled()) log.trace(\"Gmail: csv charset: \" + post.getResponseCharSet()); GMAIL_OUTPUT_CHARSET = post.getResponseCharSet(); InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet()); CSVReader reader = new CSVReader(isr); List csvEntries = reader.readAll(); reader.close(); ArrayList<GmailContact> contacts = new ArrayList<GmailContact>(); MessageDigest m = MessageDigest.getInstance(\"MD5\"); if (log.isTraceEnabled()) log.trace(\"creating Gmail contacts...\"); for (int i = 1; i < csvEntries.size(); i++) { GmailContact contact = new GmailContact(); String[] value = (String[]) csvEntries.get(i); for (int j = 0; j < value.length; j++) { switch(j) { case 0: contact.setName(value[j]); break; case 1: contact.setEmail(value[j]); if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]); break; case 2: contact.setNotes(value[j]); break; case 3: contact.setEmail2(value[j]); break; case 4: contact.setEmail3(value[j]); break; case 5: contact.setMobilePhone(value[j]); break; case 6: contact.setPager(value[j]); break; case 7: contact.setCompany(value[j]); break; case 8: contact.setJobTitle(value[j]); break; case 9: contact.setHomePhone(value[j]); break; case 10: contact.setHomePhone2(value[j]); break; case 11: contact.setHomeFax(value[j]); break; case 12: contact.setHomeAddress(value[j]); break; case 13: contact.setBusinessPhone(value[j]); break; case 14: contact.setBusinessPhone2(value[j]); break; case 15: contact.setBusinessFax(value[j]); break; case 16: contact.setBusinessAddress(value[j]); break; case 17: contact.setOtherPhone(value[j]); break; case 18: contact.setOtherFax(value[j]); break; case 19: contact.setOtherAddress(value[j]); break; } } m.update(contact.toString().getBytes()); if (log.isTraceEnabled()) log.trace(\"setting Md5 Hash...\"); contact.setMd5Hash(new BigInteger(m.digest()).toString()); contacts.add(contact); } if (log.isTraceEnabled()) log.trace(\"Mapping contacts uid...\"); Collections.sort(contacts); ArrayList<GmailContact> idList = getAllContactsID(); for (int i = 0; i < idList.size(); i++) { contacts.get(i).setId(idList.get(i).getId()); } if (log.isInfoEnabled()) log.info(\"getting all contacts info successful...\"); return contacts; } catch (HttpException e) { throw new GmailException(\"HttpException in csv file post:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in csv file post:\" + e.getMessage()); } catch (NoSuchAlgorithmException e) { throw new GmailException(\"No such md5 algorithm \" + e.getMessage()); } finally { post.releaseConnection(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getData(DefaultHttpClient httpclient) { try { HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\"); get.setHeader(\"Content-Type\", \"application/json\"); get.setHeader(\"Accept\", \"*/*\"); HttpResponse response = httpclient.execute(get); HttpEntity entity = response.getEntity(); InputStream instream = entity.getContent(); responseMessage = read(instream); if (instream != null) instream.close(); } catch (ClientProtocolException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return responseMessage; }. \n Code2: public static String fetchUrl(String urlString) { try { URL url = new URL(urlString); BufferedReader reader = new BufferedReader(new InputStream",
        "ground_truth": "NO",
        "predict": "Reader(url.openStream())); StringBuffer buffer = new StringBuffer(); String line; while ((line = reader.readLine()) != null) { buffer.append(line); } return buffer.toString(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getData(DefaultHttpClient httpclient) { try { HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\"); get.setHeader(\"Content-Type\", \"application/json\"); get.setHeader(\"Accept\", \"*/*\"); HttpResponse response = httpclient.execute(get); HttpEntity entity = response.getEntity(); InputStream instream = entity."
    },
    {
        "ID": 507,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run() { FTPClient ftp = null; try { StarkHhDownloaderEtcProperties etcProperties = new StarkHhDownloaderEtcProperties(getUri()); StarkHhDownloaderVarProperties varProperties = new StarkHhDownloaderVarProperties(getUri()); ftp = new FTPClient(); int reply; ftp.connect(etcProperties.getHostname()); log(\"Connecting to ftp server at \" + etcProperties.getHostname() + \".\"); log(\"Server replied with '\" + ftp.getReplyString() + \"'.\"); reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { throw UserException.newOk(\"FTP server refused connection.\"); } log(\"Connected to server, now logging in.\"); ftp.login(etcProperties.getUsername(), etcProperties.getPassword()); log(\"Server replied with '\" + ftp.getReplyString() + \"'.\"); List<String> directories = etcProperties.getDirectories(); for (int i = 0; i < directories.size(); i++) { log(\"Checking the directory '\" + directories.get(i) + \"'.\"); boolean found = false; FTPFile[] filesArray = ftp.listFiles(directories.get(i)); List<FTPFile> files = Arrays.asList(filesArray); Collections.sort(files, new Comparator<FTPFile>() { public int compare(FTPFile file1, FTPFile file2) { if (file2.getTimestamp().getTime().equals(file1.getTimestamp().getTime())) { return file2.getName().compareTo(file1.getName()); } else { return file1.getTimestamp().getTime().compareTo(file2.getTimestamp().getTime()); } } }); for (FTPFile file : files) { if (file.getType() == FTPFile.FILE_TYPE && (varProperties.getLastImportDate(i) == null ? true : (file.getTimestamp().getTime().equals(varProperties.getLastImportDate(i).getDate()) ? file.getName().compareTo(varProperties.getLastImportName(i)) < 0 : file.getTimestamp().getTime().after(varProperties.getLastImportDate(i).getDate())))) { String fileName = directories.get(i) + \"\\\\\" + file.getName(); if (file.getSize() == 0) { log(\"Ignoring '\" + fileName + \"'because it has zero length\"); } else { log(\"Attempting to download '\" + fileName + \"'.\"); InputStream is = ftp.retrieveFileStream(fileName); if (is == null) { reply = ftp.getReplyCode(); throw UserException.newOk(\"Can't download the file '\" + file.getName() + \"', server says: \" + reply + \".\"); } log(\"File stream obtained successfully.\"); hhImporter = new HhDataImportProcess(getContract().getId(), new Long(0), is, fileName + \".df2\", file.getSize()); hhImporter.run(); List<VFMessage> messages = hhImporter.getMessages(); hhImporter = null; if (messages.size() > 0) { for (VFMessage message : messages) { log(message.getDescription()); } throw UserException.newInvalidParameter(\"Problem loading file.\"); } } if (!ftp.completePendingCommand()) { throw UserException.newOk(\"Couldn't complete ftp transaction: \" + ftp.getReplyString()); } varProperties.setLastImportDate(i, new MonadDate(file.getTimestamp().getTime())); varProperties.setLastImportName(i, file.getName()); found = true; } } if (!found) { log(\"No new files found.\"); } } } catch (UserException e) { try { log(e.getVFMessage().getDescription()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } } catch (IOException e) { try { log(e.getMessage()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } } catch (Throwable e) { try { log(\"Exception: \" + e.getClass().getName() + \" Message: \" + e.getMessage()); } catch (ProgrammerException e1) { throw new RuntimeException(e1); } catch (UserException e1) { throw new RuntimeException(e1); } ChellowLogger.getLogger().logp(Level.SEVERE, \"ContextListener\", \"contextInitialized\", \"Can't initialize context.\", e); } finally { if (ftp != null && ftp.isConnected()) { try { ftp.logout(); ftp.disconnect(); log(\"Logged out.\"); } catch (IOException ioe) { } catch (ProgrammerException e) { } catch (UserException e) { } } } }. \n Code2: private static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException { if (url == null) { throw new IllegalArgumentException(\"Keystore url may not be null\"); } LOG.debug(\"Initializing key store\"); KeyStore keystore = KeyStore.getInstance(\"jks\"); InputStream is = null; try { is = url.openStream(); keystore.load(is, password != null ? password.toCharArray() : null); } finally { if (is != null) is.close(); } return keystore; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String connRemote(JSONObject jsonObject, String OPCode) { String retSrc = \"\"; try { HttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(AZConstants.validateURL); HttpParams httpParams = new BasicHttpParams(); List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>(); nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode)); nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString())); httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair)); httpPost.setParams(httpParams); HttpResponse response = httpClient.execute(httpPost); retSrc = EntityUtils.toString(response.getEntity()); } catch (",
        "ground_truth": "NO",
        "predict": "Exception e) { LOG.error(\"Error in connection to remote server: \" + e.getMessage()); } return retSrc; }. \n Code2: public static String connRemote(JSONObject jsonObject, String OPCode) { return connRemote(jsonObject, OPCode); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String connRemote(JSONObject jsonObject, String OPCode) { return connRemote(jsonObject, OPCode); }. \n Code2: public static String connRemote(JSONObject jsonObject, String OPCode) { return connRemote(jsonObject, OPCode); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String connRemote(JSONObject jsonObject, String OPCode) { return"
    },
    {
        "ID": 508,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void updateTableData(Connection dest, TableMetaData tableMetaData, Row r) throws Exception { PreparedStatement ps = null; try { dest.setAutoCommit(false); String sql = \"UPDATE \" + tableMetaData.getSchema() + \".\" + tableMetaData.getTableName() + \" SET \"; for (String columnName : tableMetaData.getColumnsNames()) { sql += columnName + \" = ? ,\"; } sql = sql.substring(0, sql.length() - 1); sql += \" WHERE \"; for (String pkColumnName : tableMetaData.getPkColumns()) { sql += pkColumnName + \" = ? AND \"; } sql = sql.substring(0, sql.length() - 4); System.out.println(\"UPDATE: \" + sql); ps = dest.prepareStatement(sql); int param = 1; for (String columnName : tableMetaData.getColumnsNames()) { if (dest instanceof OracleConnection) { if (tableMetaData.getColumnsTypes().get(columnName).equalsIgnoreCase(\"BLOB\")) { BLOB blob = new BLOB((OracleConnection) dest, (byte[]) r.getRowData().get(columnName)); ((OraclePreparedStatement) ps).setBLOB(param, blob); } else if (tableMetaData.getColumnsTypes().get(columnName).equalsIgnoreCase(\"CLOB\")) { ((OraclePreparedStatement) ps).setStringForClob(param, (String) r.getRowData().get(columnName)); } else if (tableMetaData.getColumnsTypes().get(columnName).equalsIgnoreCase(\"LONG\")) { ps.setBytes(param, (byte[]) r.getRowData().get(columnName)); } } else { ps.setObject(param, r.getRowData().get(columnName)); } param++; } for (String pkColumnName : tableMetaData.getPkColumns()) { ps.setObject(param, r.getRowData().get(pkColumnName)); param++; } if (ps.executeUpdate() != 1) { dest.rollback(); throw new Exception(\"Erro no update\"); } ps.clearParameters(); dest.commit(); dest.setAutoCommit(true); } finally { if (ps != null) ps.close(); } }. \n Code2: public long copyFileWithPaths(String userBaseDir, String sourcePath, String destinPath) throws Exception { if (userBaseDir.endsWith(sep)) { userBaseDir = userBaseDir.substring(0, userBaseDir.length() - sep.length()); } String file1FullPath = new String(); if (sourcePath.startsWith(sep)) { file1FullPath = new String(userBaseDir + sourcePath); } else { file1FullPath = new String(userBaseDir + sep + sourcePath); } String file2FullPath = new String(); if (destinPath.startsWith(sep)) { file2FullPath = new String(userBaseDir + destinPath); } else { file2FullPath = new String(userBaseDir + sep + destinPath); } long plussQuotaSize = 0; BufferedInputStream in = null; BufferedOutputStream out = null; byte dataBuff[] = new byte[bufferSize]; File fileordir = new File(file1FullPath); if (fileordir.exists()) { if (fileordir.isFile()) { File file2 = new File(file2FullPath); if (file2.exists()) { plussQuotaSize -= file2.length(); file2.delete(); } FileUtils.getInstance().createDirectory(file2.getParent()); in = new BufferedInputStream(new FileInputStream(file1FullPath), bufferSize); out = new BufferedOutputStream(new FileOutputStream(file2FullPath), bufferSize); int readLen; while ((readLen = in.read(dataBuff)) > 0) { out.write(dataBuff, 0, readLen); plussQuotaSize += readLen; } out.flush(); in.close(); out.close(); } if (fileordir.isDirectory()) { String[] entryList = fileordir.list(); if (entryList.length > 0) { for (int pos = 0; pos < entryList.length; pos++) { String entryName = entryList[pos]; String file1FullPathEntry = new String(file1FullPath.concat(entryList[pos])); String file2FullPathEntry = new String(file2FullPath.concat(entryList[pos])); File file2 = new File(file2FullPathEntry); if (file2.exists()) { plussQuotaSize -= file2.length(); file2.delete(); } FileUtils.getInstance().createDirectory(file2.getParent()); in = new BufferedInputStream(new FileInputStream(file1FullPathEntry), bufferSize); out = new BufferedOutputStream(new FileOutputStream(file2FullPathEntry), bufferSize); int readLen; while ((readLen = in.read(dataBuff)) > 0) { out.write(dataBuff, 0, readLen); plussQuotaSize += readLen; } out.flush(); in.close(); out.close(); } } } } else { throw new Exception(\"Source file or dir not exist ! file1FullPath = (\" + file1FullPath + \")\"); } return plussQuotaSize; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void extractFile(String input, String output) throws ZipException, IOException { FileReader reader = new FileReader(input); InputStream in = reader.getInputStream(); OutputStream out = new FileOutputStream(new File(output)); byte[] buf = new byte[512]; int len; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); reader.close(); out.close(); }. \n Code2: public Set<String> getAvailableRoles() { if (availableRoles == null) { availableRoles = new HashSet<String>(); try { Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION); while (resources.hasMoreElements()) { URL url = resources.nextElement(); InputStream is = null; try { URLConnection con = url.openConnection(); con.setUseCaches(false); is = con.getInputStream(); List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\"); if (lines != null) { for (String line : lines) { availableRoles.add(line.trim()); } } } finally { if (is != null) { is.close",
        "ground_truth": "NO",
        "predict": "(); } } } } catch (IOException e) { e.printStackTrace(); } } } return availableRoles; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void updateTableData(Connection dest, TableMetaData tableMetaData, Row r) throws Exception { PreparedStatement ps = null; try { dest.setAutoCommit(false); String sql = \"UPDATE \" + tableMetaData.getSchema() + \".\" + tableMetaData.getTableName() + \" SET \"; for (String columnName : tableMetaData.getColumnsNames()) { sql += columnName + \" = ? ,\"; } sql = sql.substring(0, sql.length() - 1); sql += \" WHERE \"; for (String pkColumnName : tableMetaData.getPkColumns()) { sql += pkColumnName + \" = ? AND \""
    },
    {
        "ID": 509,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean moveFileSafely(final File in, final File out) throws IOException { FileInputStream fis = null; FileOutputStream fos = null; FileChannel inChannel = null; FileChannel outChannel = null; final File tempOut = File.createTempFile(\"move\", \".tmp\"); try { fis = new FileInputStream(in); fos = new FileOutputStream(tempOut); inChannel = fis.getChannel(); outChannel = fos.getChannel(); inChannel.transferTo(0, inChannel.size(), outChannel); } finally { try { if (inChannel != null) inChannel.close(); } catch (IOException e) { LogUtils.debugf(JRobinConverter.class, \"failed to close channel %s\", inChannel); } try { if (outChannel != null) outChannel.close(); } catch (IOException e) { LogUtils.debugf(JRobinConverter.class, \"failed to close channel %s\", outChannel); } try { if (fis != null) fis.close(); } catch (IOException e) { LogUtils.debugf(JRobinConverter.class, \"failed to close stream %s\", fis); } try { if (fos != null) fos.close(); } catch (IOException e) { LogUtils.debugf(JRobinConverter.class, \"failed to close stream %s\", fos); } } out.delete(); if (!out.exists()) { tempOut.renameTo(out); return in.delete(); } return false; }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) { HttpURLConnection urlConn = null; try { String params = generatorParamString(parameters); URL url = new URL(reqUrl); urlConn = (HttpURLConnection) url.openConnection(); urlConn.setRequestMethod(\"POST\"); urlConn.setConnectTimeout(5000); urlConn.setReadTimeout(5000); urlConn.setDoOutput(true); byte[] b = params.getBytes(); urlConn.getOutputStream().write(b, 0, b.length); urlConn.getOutputStream().flush(); urlConn.getOutputStream().close(); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } return urlConn; }. \n Code2: public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException { URLConnection conn = url.openConnection(); String contentType = conn.getContentType(); String encoding = conn.getContentEncoding(); if (encoding == null) { int i = contentType.indexOf(\"charset\"); if (i >= 0) { String s = contentType.substring(i); i = s.indexOf('='); if (i >= 0) { s = contentType.substring(i + 1).trim(); encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim(); if (encoding.equals(\"\")) { encoding = defaultEncoding; } } } else { encoding = defaultEncoding; } } String expected = \"text/html\"; if (contentType == null) { DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\"); contentType = expected; } int index = contentType",
        "ground_truth": "NO",
        "predict": ".indexOf(\"charset=\"); if (index < 0) { index = contentType.indexOf(\"charset\"); } if (index >= 0) { String s = contentType.substring(index + 8); index = s.indexOf('='); if (index >= 0) { s = s.substring(index + 1).trim(); encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim(); if (encoding.equals(\"\")) { encoding = defaultEncoding; } } } else { encoding = defaultEncoding; } if (encoding.equals(\"\")) { encoding = defaultEncoding; } if (overrideEncoding) { encoding = \"UTF-8\"; } if (!expected.equals(contentType)) { throw new BadDocumentException(\"Expected content type '\" + expected + \"' but got '\" + contentType + \"'\"); } return new String(IOUtils.toByteArray(conn.getInputStream()"
    },
    {
        "ID": 512,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void launch(String xmlControl, String xmlDoc, long docId) { AgentLauncher l; Environment env; Properties prop; Resource res; String token; String deflt; String answ; String key; String entry; ShipService service; de.fhg.igd.util.URL url; java.net.URL wsurl; NodeList flow; InputSource xmlcontrolstream; TreeMap results; synchronized (lock_) { if (xmlControl == null || xmlControl.length() == 0 || xmlDoc == null || xmlDoc.length() == 0) { System.out.println(\"---- Need control AND XML document! ----\"); return; } Vector v_delegations_host = new Vector(); Vector v_delegations_url = new Vector(); Vector v_delegations_method = new Vector(); xmlcontrolstream = new InputSource(new StringReader(xmlControl)); NodeList destinations = SimpleXMLParser.parseDocument(xmlcontrolstream, AgentBehaviour.XML_DELEGATE); for (int i = 0; i < destinations.getLength(); i++) { if (destinations.item(i).getTextContent() != null && destinations.item(i).getTextContent().length() > 0) { System.out.println(destinations.item(i).getTextContent()); entry = SimpleXMLParser.findChildEntry(destinations.item(i), AgentBehaviour.XML_HOST); v_delegations_host.add(entry); entry = SimpleXMLParser.findChildEntry(destinations.item(i), AgentBehaviour.XML_URL); v_delegations_url.add(entry); entry = SimpleXMLParser.findChildEntry(destinations.item(i), AgentBehaviour.XML_METHOD); v_delegations_method.add(entry); } } token = \"\"; results = new TreeMap(); for (int i = 0; i < TOKEN_LENGTH; i++) { token = token + (char) (Math.random() * 26 + 65); } results.put(token, null); prop = AgentStructure.defaults(); prop.setProperty(AgentStructure.PROP_AGENT_CLASS, AGENT_); prop.setProperty(AgentBehaviour.CTX_DOCID, String.valueOf(docId)); prop.setProperty(AgentBehaviour.CTX_XML, xmlDoc); prop.setProperty(\"token\", token); deflt = prop.getProperty(AgentStructure.PROP_AGENT_EXCLUDE); prop.setProperty(AgentStructure.PROP_AGENT_EXCLUDE, deflt + \":\" + ADDITIONAL_EXCLUDES); service = (ShipService) getEnvironment().lookup(WhatIs.stringValue(ShipService.WHATIS)); for (int i = 0; i < v_delegations_host.size(); i++) { System.out.println(\"\\n-----SCANNING DELEGATES-----\"); System.out.println(\"\\n-----DELEGATE \" + i + \"-----\"); System.out.println(\"-----HOST: \" + i + \": \" + (String) v_delegations_host.elementAt(i)); System.out.println(\"-----URL: \" + i + \": \" + (String) v_delegations_url.elementAt(i)); System.out.println(\"-----METHOD: \" + i + \": \" + (String) v_delegations_method.elementAt(i)); try { url = new de.fhg.igd.util.URL((String) v_delegations_host.elementAt(i)); boolean alive = service.isAlive(url); System.out.println(\"-----ALIVE: \" + alive); if (alive) { wsurl = new java.net.URL((String) v_delegations_url.elementAt(i)); try { wsurl.openStream(); System.out.println(\"-----WEBSERVICE: ON\"); if (!prop.containsKey(0 + \".\" + AgentBehaviour.XML_URL)) { System.out.println(\"-----MIGRATION: First online host found. I will migrate here:)!\"); prop.setProperty(0 + \".\" + AgentBehaviour.XML_HOST, (String) v_delegations_host.elementAt(i)); prop.setProperty(0 + \".\" + AgentBehaviour.XML_URL, (String) v_delegations_url.elementAt(i)); prop.setProperty(0 + \".\" + AgentBehaviour.XML_METHOD, (String) v_delegations_method.elementAt(i)); } else { System.out.println(\"-----MIGRATION: I will not migrate here:(!\"); } } catch (IOException ex) { System.out.println(\"-----WEBSERVICE: Could not connect to the webservice!\"); System.out.println(\"-----MIGRATION: WEBSERVICE NOT FOUND! I will not migrate here:(!\"); } } } catch (ShipException she) { System.out.println(\"-----ALIVE: false\"); System.out.println(\"-----MIGRATION: HOST NOT FOUND! I will not migrate here:(!\"); } catch (SecurityException see) { System.out.println(\"-----EXCEPTION: Access connection to remote SHIP service fails! \" + \"No proper ShipPermission permission to invoke lookups! \" + \"Ignoring this host....\"); } catch (MalformedURLException murle) { System.out.println(\"-----EXCEPTION: The host URL is not valid! Ignoring this host....\"); } } res = new MemoryResource(); env = Environment.getEnvironment(); key = WhatIs.stringValue(AgentLauncher.WHATIS); l = (AgentLauncher) env.lookup(key); if (l == null) { System.out.println(\"Can't find the agent launcher\"); return; } try { l.launchAgent(res, prop); } catch (IllegalAgentException ex) { System.out.println(ex); } catch (GeneralSecurityException ex) { System.out.println(ex); } catch (IOException ex) { System.out.println(ex); } syncmap_.put(token, results); System.out.println(\"----- TOKEN = \" + token + \"------\"); } try { synchronized (token) { token.wait(TIMEOUT); Map m_results = (Map) syncmap_.get(token); Collection c_results = m_results.values(); String[] sa_results = (String[]) c_results.toArray(new String[0]); answ = \"\"; for (int j = 0; j < sa_results.length; j++) { answ = answ + sa_results[j]; } syncmap_.remove(token); System.out.println(\"----- \" + answ + \" -----\"); callbackWS(xmlControl, answ, docId); } } catch (InterruptedException ex)",
        "ground_truth": "YES",
        "predict": " { } }\n"
    },
    {
        "ID": 516,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public SWORDEntry ingestDepost(final DepositCollection pDeposit, final ServiceDocument pServiceDocument) throws SWORDException { try { ZipFileAccess tZipFile = new ZipFileAccess(super.getTempDir()); LOG.debug(\"copying file\"); String tZipTempFileName = super.getTempDir() + \"uploaded-file.tmp\"; IOUtils.copy(pDeposit.getFile(), new FileOutputStream(tZipTempFileName)); Datastream tDatastream = new LocalDatastream(super.getGenericFileName(pDeposit), this.getContentType(), tZipTempFileName); _datastreamList.add(tDatastream); _datastreamList.addAll(tZipFile.getFiles(tZipTempFileName)); int i = 0; boolean found = false; for (i = 0; i < _datastreamList.size(); i++) { if (_datastreamList.get(i).getId().equalsIgnoreCase(\"mets\")) { found = true; break; } } if (found) { SAXBuilder tBuilder = new SAXBuilder(); _mets = new METSObject(tBuilder.build(((LocalDatastream) _datastreamList.get(i)).getPath())); LocalDatastream tLocalMETSDS = (LocalDatastream) _datastreamList.remove(i); new File(tLocalMETSDS.getPath()).delete(); _datastreamList.add(_mets.getMETSDs()); _datastreamList.addAll(_mets.getMetadataDatastreams()); } else { throw new SWORDException(\"Couldn't find a METS document in the zip file, ensure it is named mets.xml or METS.xml\"); } SWORDEntry tEntry = super.ingestDepost(pDeposit, pServiceDocument); tZipFile.removeLocalFiles(); return tEntry; } catch (IOException tIOExcpt) { String tMessage = \"Couldn't retrieve METS from deposit: \" + tIOExcpt.toString(); LOG.error(tMessage); tIOExcpt.printStackTrace(); throw new SWORDException(tMessage, tIOExcpt); } catch (JDOMException tJDOMExcpt) { String tMessage = \"Couldn't build METS from deposit: \" + tJDOMExcpt.toString(); LOG.error(tMessage); tJDOMExcpt.printStackTrace(); throw new SWORDException(tMessage, tJDOMExcpt); } }. \n Code2: public void run() { XmlFilesFilter filter = new XmlFilesFilter(); String pathTemp = Settings.get(\"vo_store.databaseMetaCollection\"); String sectionName = pathTemp.substring(1, pathTemp.indexOf(\"/\", 2)); String templateName = VOAccess.getElementByName(settingsDB, \"TEMPLATE\", sectionName); String schemaName = VOAccess.getElementByName(settingsDB, \"SCHEMA\", sectionName); byte[] buf = new byte[1024]; Hashtable templateElements = null; try { URL xmlTemplateUrl = new URL(httpURI + settingsDB + \"/\" + templateName); URL getDocPathsAndValuesXslUrl = new URL(httpURI + settingsDB + \"/\" + \"getDocPathsValuesAndDisplays.xsl\"); org.w3c.dom.Document curTemplateXml = VOAccess.readDocument(xmlTemplateUrl); DOMResult templateResult = new DOMResult(); InputStream tempInput = getDocPathsAndValuesXslUrl.openStream(); javax.xml.transform.sax.SAXSource tempXslSource = new javax.xml.transform.sax.SAXSource(new org.xml.sax.InputSource(tempInput)); Transformer trans = TransformerFactory.newInstance().newTransformer(tempXslSource); trans.setParameter(\"schemaUrl\", httpURI + settingsDB + \"/\" + schemaName); trans.transform(new javax.xml.transform.dom.DOMSource(curTemplateXml), templateResult); tempInput.close(); templateElements = VOAccess.displaysToHashtable(templateResult); ((CollectionManagementService) CollectionsManager.getService(xmldbURI + rootDB, false, \"CollectionManager\")).createCollection(rootDB + pathTemp); } catch (Exception ex) { logger.error(\"Error parsing input document\", ex); ex.printStackTrace(); } while (true) { File[] fileList = sourceMetaFilesDir.listFiles(filter); for (int i = 0; i < Math.min(fileList.length, 500); i++) { File newFile = fileList[i]; try { Document metaDoc = build.build(newFile); Element metaElm = metaDoc.getRootElement(); String dataFileName = metaElm.getChildText(\"Content\"), previewFileName = metaElm.getChildText(\"Preview\"); String objId = VOAccess.getUniqueId(); metaElm.getChild(\"Content\").setText(\"videostore?type=doc&objId=\" + objId); metaElm.getChild(\"Preview\").setText(\"videostore?type=preview&objId=\" + objId); boolean found = false; for (Iterator it = sourceDataFilesDirs.iterator(); it.hasNext() && !found; ) { String sourceDataFilesDir = (String) it.next(); File dataInput = new File(sourceDataFilesDir + \"/\" + dataFileName); if (dataInput.exists()) { found = true; BufferedInputStream inp = new BufferedInputStream(new FileInputStream(dataInput)); FileOutputStream outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".dat\")); int read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); dataInput = new File(sourceDataFilesDir + \"/\" + previewFileName); inp = new BufferedInputStream(new FileInputStream(dataInput)); outp = new FileOutputStream(new File(targetDataFilesDirs.get(curDirWriteTo) + \"/\" + objId + \".jpg\")); read = inp.read(buf, 0, buf.length); while (read > 0) { outp.write(buf, 0, read); read = inp.read(buf, 0, buf.length); } inp.close(); outp.flush(); outp.close(); curDirWriteTo++; if (curDirWriteTo >= targetDataFilesDirs.size()) { curDirWriteTo = 0; } } } if (!found) { newFile.renameTo(new File(newFile.getAbsolutePath",
        "ground_truth": "NO",
        "predict": "() + \".deleted\")); } } catch (Exception ex) { logger.error(\"Error parsing input document\", ex); ex.printStackTrace(); } } } }\n"
    },
    {
        "ID": 519,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { File file; try { file = new File(filePath); if (!file.canWrite()) { Thread.sleep(5000); if (!file.canWrite()) { logger.error(\"Filed to gain write access to file:\" + filePath); exitState = false; return; } } fis = new BufferedInputStream(new FileInputStream(filePath)); } catch (FileNotFoundException e) { logger.error(\"File not found:\" + filePath); exitState = false; return; } catch (java.lang.InterruptedException ie) { logger.error(\"Upload thread halted or interrupted on file:\" + filePath); exitState = false; return; } ftp = new FTPClient(); ftp.setDefaultTimeout(20 * 1000); boolean uploadSuccessful = false; try { ftp.enterLocalPassiveMode(); ftp.connect(ftpHostname); ftp.login(username, password); logger.trace(\"FTP Logged In and connected\"); if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) { exitState = false; return; } ftp.setFileType(FTPClient.BINARY_FILE_TYPE); logger.trace(\"FTP Timeout Set and File Type Set\"); ftp.changeWorkingDirectory(serverDirectory); ftp.storeUniqueFile(file.getName(), fis); logger.trace(\"File Uploaded\"); if (FTPReply.isPositiveIntermediate(ftp.getReplyCode())) { System.out.println(\"Completing pending command\"); ftp.completePendingCommand(); } uploadSuccessful = true; } catch (Exception e) { try { ftp.disconnect(); } catch (Exception de) { e.printStackTrace(); } logger.error(\"Error uploading file:\", e); } finally { try { fis.close(); logger.trace(\"File closed\"); ftp.logout(); logger.trace(\"FTP Logged Out\"); ftp.disconnect(); logger.trace(\"FTP Disconnected\"); if (uploadSuccessful) { logger.info(\"Deleting file:\" + new File(filePath).getName()); if (!(new File(filePath)).delete()) { logger.error(\"Can't delete file for some reason\"); } Thread.sleep(1000); exitState = true; return; } } catch (Exception e) { logger.error(\"Exception on file upload cleanup:\", e); exitState = false; return; } } exitState = false; return; }. \n Code2: public osid.shared.Id ingest(String fileName, String templateFileName, String fileType, File file, Properties properties) throws osid.dr.DigitalRepositoryException, java.net.SocketException, java.io.IOException, osid.shared.SharedException, javax.xml.rpc.ServiceException { long sTime = System.currentTimeMillis(); if (DEBUG) System.out.println(\"INGESTING FILE TO FEDORA:fileName =\" + fileName + \"fileType =\" + fileType + \"t = 0\"); String host = FedoraUtils.getFedoraProperty(this, \"admin.ftp.address\"); String url = FedoraUtils.getFedoraProperty(this, \"admin.ftp.url\"); int port = Integer.parseInt(FedoraUtils.getFedoraProperty(this, \"admin.ftp.port\")); String userName = FedoraUtils.getFedoraProperty(this, \"admin.ftp.username\"); String password = FedoraUtils.getFedoraProperty(this, \"admin.ftp.password\"); String directory = FedoraUtils.getFedoraProperty(this, \"admin.ftp.directory\"); FTPClient client = new FTPClient(); client.connect(host, port); client.login(userName, password); client.changeWorkingDirectory(directory); client.setFileType(FTP.BINARY_FILE_TYPE); client.storeFile(fileName, new FileInputStream(file.getAbsolutePath().replaceAll(\"%20\", \" \"))); client.logout(); client.disconnect(); if (DEBUG) System.out.println(\"INGESTING FILE TO FEDORA: Writting to FTP Server:\" + (System.currentTimeMillis() - sTime)); fileName = url + fileName; int BUFFER_SIZE = 10240; StringBuffer sb = new StringBuffer(); String s = new String(); BufferedInputStream fis = new BufferedInputStream(new FileInputStream(new File(getResource(templateFileName).getFile().replaceAll(\"%20\", \" \")))); byte[] buf = new byte[BUFFER_SIZE]; int ch; int len; while ((len = fis.read(buf)) > 0) { s = s + new String(buf); } fis.close(); if (DEBUG) System.out.println(\"INGESTING FILE TO FEDORA: Read Mets File:\" + (System.currentTimeMillis() - sTime)); String r = updateMetadata(s, fileName, file.getName(), fileType, properties); if (DEBUG) System.out.println(\"INGESTING FILE TO FEDORA: Resplaced Metadata:\" + (System.currentTimeMillis() - sTime)); File METSfile = File.createTempFile(\"vueMETSMap\", \".xml\"); FileOutputStream fos = new FileOutputStream(METSfile); fos.write(r.getBytes()); fos.close(); if (DEBUG) System.out.println(\"INGESTING FILE TO FEDORA: Ingest complete:\" + (System.currentTimeMillis() - sTime)); String pid = \"Method Not Supported any more\"; System.out.println(\" METSfile= \" + METSfile.getPath() + \" PID = \" + pid); return new PID(pid); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copyFile(File in, File out) throws IOException { FileChannel source = new FileInputStream(in).getChannel(); FileChannel destination = new FileOutputStream(out).getChannel(); source.transferTo(0, source.size(), destination); source.close(); destination.close(); }. \n Code2: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; }",
        "ground_truth": "YES",
        "predict": " catch (Exception e) { e.printStackTrace(); } finally { try { if (in != null) in.close(); } catch (Exception e) { } try { if (out != null) out.close(); } catch (Exception e) { } } return success; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copyFile(File in, File out) throws IOException { FileChannel source = new FileInputStream(in).getChannel(); FileChannel destination = new FileOutputStream(out).getChannel(); source.transferTo(0, source.size(), destination); source.close(); destination.close(); }. \n Code2: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64"
    },
    {
        "ID": 523,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public InputStream sendReceive(String trackerURL) throws TorrentException { try { URL url = new URL(trackerURL); URLConnection conn = url.openConnection(); conn.setDoOutput(true); in = conn.getInputStream(); } catch (MalformedURLException e) { throw new TorrentException(e); } catch (IOException e) { throw new TorrentException(e); } return in; }. \n Code2: private void run(String[] args) throws Throwable { ArgParser parser = new ArgParser(\"Run an experiment\"); parser.addOptions(this, true); args = parser.matchAllArgs(args, 0, ArgParserOption.EXIT_ON_ERROR, ArgParserOption.STOP_FIRST_UNMATCHED); if (log4jFile != null) { logger.info(\"Using another log4j configuration: %s\", log4jFile); PropertyConfigurator.configure(log4jFile.getAbsolutePath()); } final TreeMap<TaskName, Class<Task>> tasks = GenericHelper.newTreeMap(); final Enumeration<URL> e = About.class.getClassLoader().getResources(EXPERIMENT_PACKAGES); while (e.hasMoreElements()) { final URL url = e.nextElement(); logger.debug(\"Got URL %s\", url); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String line; while ((line = in.readLine()) != null) { String packageName = line; getTasks(url, tasks, packageName); } } getTasks(null, tasks, getClass().getPackage().getName()); if (tasks.isEmpty()) { logger.fatal(\"I did not find any valid experiment (service bpiwowar.experiments.ExperimentListProvider)\"); System.exit(1); } if (args.length == 0 || args[0].equals(\"list\")) { System.out.format(\"Available experiments:%n\"); TreeMapArray<PackageName, String> map = TreeMapArray.newInstance(); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { TaskName task = entry.getKey(); if (showClassNames) map.add(task.packageName, String.format(\"%s (%s)\", task.name, entry.getValue().toString())); else map.add(task.packageName, task.name); } Stack<PackageName> ancestors = new Stack<PackageName>(); for (Entry<PackageName, ArrayList<String>> entry : map.entrySet()) { final PackageName key = entry.getKey(); while (!ancestors.isEmpty() && key.commonPrefixLength(ancestors.peek()) != ancestors.peek().getLength()) ancestors.pop(); int nbAncestors = ancestors.size(); int c = nbAncestors > 0 ? ancestors.peek().getLength() : 0; StringBuilder s = new StringBuilder(); for (int i = 0; i < c; i++) s.append(\"|\"); for (int i = c; i < key.getLength(); i++) { s.append(\"|\"); ancestors.add(new PackageName(key, i + 1)); System.out.format(\"%s%n\", s); System.out.format(\"%s+ [%s]%n\", s, ancestors.peek()); nbAncestors++; } String prefix = s.toString(); for (String task : entry.getValue()) System.out.format(\"%s|- %s%n\", prefix, task); ancestors.add(key); } return; } else if (args[0].equals(SEARCH_COMMAND)) { final class Options { @OrderedArgument(required = true) String search; } Options options = new Options(); ArgParser ap = new ArgParser(SEARCH_COMMAND); ap.addOptions(options); ap.matchAllArgs(args, 1); logger.info(\"Searching for %s\", options.search); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { TaskName taskname = entry.getKey(); if (taskname.name.contains(options.search)) { System.err.format(\"[*] %s - %s%n %s%n\", taskname, entry.getValue(), entry.getValue().getAnnotation(TaskDescription.class).description()); } } return; } String taskName = args[0]; args = Arrays.copyOfRange(args, 1, args.length); ArrayList<Class<Task>> matching = GenericHelper.newArrayList(); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { if (entry.getKey().name.equals(taskName)) matching.add(entry.getValue()); } if (matching.isEmpty()) { System.err.println(\"No task match \" + taskName); System.exit(1); } if (matching.size() > 1) { System.err.println(\"Too many tasks match \" + taskName); System.exit(1); } Class<Task> taskClass = matching.get(0); logger.info(\"Running experiment \" + taskClass.getCanonicalName()); Task task = taskClass.newInstance(); int errorCode = 0; try { task.init(args); if (xstreamOutput != null) { OutputStream out; if (xstreamOutput.toString().equals(\"-\")) out = System.out; else out = new FileOutputStream(xstreamOutput); logger.info(\"Serializing the object into %s\", xstreamOutput); new XStream().toXML(task, out); out.close(); } else { errorCode = task.run(); } logger.info(\"Finished task\"); } catch (Throwable t) { if (t instanceof InvocationTargetException && t.getCause() != null) { t = t.getCause(); } logger.error(\"Exception thrown while executing the action:%n%s%n\", t); errorCode = 2; } System.exit(errorCode); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String hashPassword(String password) throws NoSuchAlgorithmException { String hash = null; MessageDigest md = MessageDigest.getInstance(\"SHA\"); log.debug(\"secure hash on password \" + password); md.update(password.getBytes()); hash = new String(Base64.encodeBase64(md.digest())); log.debug(\"returning hash \" + hash); return hash; }. \n Code2: @Override protected URLConnection openConnection(URL url, Proxy proxy) throws IOException { if ((url == null) || (proxy == null)) { throw new IllegalArgumentException(Messages.getString(\"luni.1B\")); } return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy); }. ",
        "ground_truth": "NO",
        "predict": "\n Code3: public void run(String[] args) throws Throwable { ArgParser parser = new ArgParser(\"Run an experiment\"); parser.addOptions(this, true); args = parser.matchAllArgs(args, 0, ArgParserOption.EXIT_ON_ERROR, ArgParserOption.STOP_FIRST_UNMATCHED); if (log4jFile != null) { logger.info(\"Using another log4j configuration: %s\", log4jFile); PropertyConfigurator.configure(log4jFile.getAbsolutePath()); } final TreeMap<TaskName, Class<Task>> tasks = GenericHelper.newTreeMap(); final Enumeration<URL> e = About.class.getClassLoader().getResources(EXPERIMENT_PACKAGES); while (e.hasMoreElements()) { final URL url = e.nextElement(); logger.debug(\"Got URL %s\", url); BufferedReader in = new BufferedReader(new InputStreamReader"
    },
    {
        "ID": 529,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static byte[] getPassword(final String name, final String password) { try { final MessageDigest messageDigest = MessageDigest.getInstance(\"SHA\"); messageDigest.update(name.getBytes()); messageDigest.update(password.getBytes()); return messageDigest.digest(); } catch (final NoSuchAlgorithmException e) { throw new JobException(e); } }. \n Code2: @SuppressWarnings(\"unchecked\") public static void createInstance(ExternProtoDeclare externProtoDeclare) { ExternProtoDeclareImport epdi = new ExternProtoDeclareImport(); HashMap<String, ProtoDeclareImport> protoMap = X3DImport.getTheImport().getCurrentParser().getProtoMap(); boolean loadedFromWeb = false; File f = null; URL url = null; List<String> urls = externProtoDeclare.getUrl(); String tmpUrls = urls.toString(); urls = Util.splitStringToListOfStrings(tmpUrls); String protoName = null; int urlCount = urls.size(); for (int urlIndex = 0; urlIndex < urlCount; urlIndex++) { try { String path = urls.get(urlIndex); if (path.startsWith(\"\\\"\") && path.endsWith(\"\\\"\")) path = path.substring(1, path.length() - 1); int hashMarkPos = path.indexOf(\"#\"); int urlLength = path.length(); if (hashMarkPos == -1) path = path.substring(0, urlLength); else { protoName = path.substring(hashMarkPos + 1, urlLength); path = path.substring(0, hashMarkPos); } if (path.toLowerCase().startsWith(\"http://\")) { String filename = path.substring(path.lastIndexOf(\"/\") + 1, path.lastIndexOf(\".\")); String fileext = path.substring(path.lastIndexOf(\".\"), path.length()); f = File.createTempFile(filename, fileext); url = new URL(path); InputStream is = url.openStream(); FileOutputStream os = new FileOutputStream(f); byte[] buffer = new byte[0xFFFF]; for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len); is.close(); os.close(); url = f.toURI().toURL(); loadedFromWeb = true; } else { if (path.startsWith(\"/\") || (path.charAt(1) == ':')) { } else { File x3dfile = X3DImport.getTheImport().getCurrentParser().getFile(); path = Util.getRealPath(x3dfile) + path; } f = new File(path); url = f.toURI().toURL(); Object testContent = url.getContent(); if (testContent == null) continue; loadedFromWeb = false; } X3DDocument x3dDocument = null; try { x3dDocument = X3DDocument.Factory.parse(f); } catch (XmlException e) { e.printStackTrace(); return; } catch (IOException e) { e.printStackTrace(); return; } Scene scene = x3dDocument.getX3D().getScene(); ProtoDeclare[] protos = scene.getProtoDeclareArray(); ProtoDeclare protoDeclare = null; if (protoName == null) { protoDeclare = protos[0]; } else { for (ProtoDeclare proto : protos) { if (proto.getName().equals(protoName)) { protoDeclare = proto; break; } } } if (protoDeclare == null) continue; ProtoBody protoBody = protoDeclare.getProtoBody(); epdi.protoBody = protoBody; protoMap.put(externProtoDeclare.getName(), epdi); break; } catch (MalformedURLException e) { } catch (IOException e) { } finally { if (loadedFromWeb && f != null) { f.delete(); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException { ConnectionProvider cp = null; Connection conn = null; ResultSet rs = null; PreparedStatement pstmt = null; PrivilegeFactory factory = PrivilegeFactory.getInstance(); Operation op = factory.createOperation(); try { cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE); conn = cp.getConnection(); try { pstmt = conn.prepareStatement(DEL_ROLE_PERM); pstmt.setString(1, roleid); pstmt.executeUpdate(); } catch (Exception e) { } if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) { return; } else { conn.setAutoCommit(false); pstmt = conn.prepareStatement(ADD_ROLE_PERM); Iterator role_perm_ir = role_perm_collect.iterator(); while (role_perm_ir.hasNext()) { RolePermission rolePerm = (RolePermission) role_perm_ir.next(); pstmt.setString(1, String.valueOf(rolePerm.getRoleid())); pstmt.setString(2, String.valueOf(rolePerm.getResourceid())); pstmt.setString(3, String.valueOf(rolePerm.getResopid())); pstmt.executeUpdate(); } conn.commit(); conn.setAutoCommit(true); } } catch (Exception e) { conn.rollback(); throw new DAOException(); } finally { try { if (conn != null) { conn.close(); } if",
        "ground_truth": "NO",
        "predict": " (pstmt != null) { pstmt.close(); } if (cp != null) { cp.close(); } } catch (Exception e) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read"
    },
    {
        "ID": 539,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: private static String fetchImageViaHttp(URL imgUrl) throws IOException { String sURL = imgUrl.toString(); String imgFile = imgUrl.getPath(); HttpURLConnection cnx = (HttpURLConnection) imgUrl.openConnection(); String uri = null; try { cnx.setAllowUserInteraction(false); cnx.setDoOutput(true); cnx.addRequestProperty(\"Cache-Control\", \"no-cache\"); RequestContext ctx = RequestContext.get(); if (ctx != null) cnx.addRequestProperty(\"User-Agent\", ctx.header(\"user-agent\")); else cnx.addRequestProperty(\"User-Agent\", user_agent); cnx.addRequestProperty(\"Referer\", sURL.substring(0, sURL.indexOf('/', sURL.indexOf('.')) + 1)); cnx.connect(); if (cnx.getResponseCode() != HttpURLConnection.HTTP_OK) return null; InputStream imgData = cnx.getInputStream(); String ext = FilenameUtils.getExtension(imgFile).toLowerCase(); if (!Multimedia.isImageFile(\"aa.\" + ext)) ext = \"jpg\"; uri = FMT_FN.format(new Date()) + RandomStringUtils.randomAlphanumeric(4) + '.' + ext; File fileDest = new File(img_path + uri); if (!fileDest.getParentFile().exists()) fileDest.getParentFile().mkdirs(); FileOutputStream fos = new FileOutputStream(fileDest); try { IOUtils.copy(imgData, fos); } finally { IOUtils.closeQuietly(imgData); IOUtils.closeQuietly(fos); } } finally { cnx.disconnect(); } return RequestContext.get().contextPath() + \"/uploads/img/\" + uri; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public EntrySet read(EntrySet set) throws ReadFailedException { if (!SourceCache.contains(url)) { SSL.certify(url); try { super.setParser(Parser.detectParser(url.openStream())); final PipedInputStream in = new PipedInputStream(); final PipedOutputStream forParser = new PipedOutputStream(in); new Thread(new Runnable() { public void run() { try { OutputStream out = SourceCache.startCaching(url); InputStream is = url.openStream(); byte[] buffer = new byte[100000]; while (true) { int amountRead = is.read(buffer); if (amountRead == -1) {",
        "ground_truth": "NO",
        "predict": " break; } out.write(buffer, 0, amountRead); } } catch (IOException e) { } } } }).start(); try { set.setParser(Parser.parse(in)); } catch (IOException e) { throw new ReadFailedException(e); } } return set; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public EntrySet read(EntrySet set) throws ReadFailedException { if (!SourceCache.contains(url)) { SSL.certify(url); try { super.setParser(Parser.detectParser(url.openStream())); final PipedInputStream in = new PipedInputStream(); final PipedOutputStream forParser = new PipedOutputStream(in); new Thread(new Runnable() { public void run() { try { OutputStream out = SourceCache.startCaching(url); InputStream is"
    },
    {
        "ID": 543,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static NotaFiscal insert(NotaFiscal objNF) { final Connection c = DBConnection.getConnection(); PreparedStatement pst = null; int result; if (c == null) { return null; } if (objNF == null) { return null; } try { c.setAutoCommit(false); String sql = \"\"; int idNotaFiscal; idNotaFiscal = NotaFiscalDAO.getLastCodigo(); if (idNotaFiscal < 1) { return null; } sql = \"INSERT INTO nota_fiscal \" + \"(id_nota_fiscal, id_fornecedor, total, data_emissao, data_cadastro, numero) \" + \"VALUES(?, ?, TRUNCATE(?,2), STR_TO_DATE(?,'%d/%m/%Y'), now(), ?) \"; pst = c.prepareStatement(sql); pst.setInt(1, idNotaFiscal); pst.setLong(2, objNF.getFornecedor().getCodigo()); pst.setString(3, new DecimalFormat(\"#0.00\").format(objNF.getValor())); pst.setString(4, objNF.getDataEmissaoFormatada()); pst.setString(5, objNF.getNumero()); result = pst.executeUpdate(); pst = null; if (result > 0) { Iterator<ItemNotaFiscal> itINF = (objNF.getItemNotaFiscal()).iterator(); while ((itINF != null) && (itINF.hasNext())) { ItemNotaFiscal objINF = (ItemNotaFiscal) itINF.next(); sql = \"\"; sql = \"INSERT INTO item_nota_fiscal \" + \"(id_nota_fiscal, id_produto, quantidade, subtotal) \" + \"VALUES(?, ?, ?, TRUNCATE(?,2))\"; pst = c.prepareStatement(sql); pst.setInt(1, idNotaFiscal); pst.setInt(2, objINF.getProduto().getCodigo()); pst.setInt(3, objINF.getQuantidade()); pst.setString(4, new DecimalFormat(\"#0.00\").format(objINF.getSubtotal())); result = pst.executeUpdate(); } } c.commit(); objNF.setCodigo(idNotaFiscal); } catch (final Exception e) { try { c.rollback(); } catch (final Exception e1) { System.out.println(\"[NotaFiscalDAO.insert.rollback] Erro ao inserir -> \" + e1.getMessage()); } System.out.println(\"[NotaFiscalDAO.insert] Erro ao inserir -> \" + e.getMessage()); objNF = null; } finally { DBConnection.closePreparedStatement(pst); DBConnection.closeConnection(c); } return objNF; }. \n Code2: protected boolean check(String username, String password, String realm, String nonce, String nc, String cnonce, String qop, String uri, String response, HttpServletRequest request) { try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(username.getBytes()); md.update((byte) ':'); md.update(realm.getBytes()); md.update((byte) ':'); md.update(password.getBytes()); byte[] ha1 = md.digest(); md.reset(); md.update(request.getMethod().getBytes()); md.update((byte) ':'); md.update(uri.getBytes()); byte[] ha2 = md.digest(); md.update(TypeUtil.toString(ha1, 16).getBytes()); md.update((byte) ':'); md.update(nonce.getBytes()); md.update((byte) ':'); md.update(nc.getBytes()); md.update((byte) ':'); md.update(cnonce.getBytes()); md.update((byte) ':'); md.update(qop.getBytes()); md.update((byte) ':'); md.update(TypeUtil.toString(ha2, 16).getBytes()); byte[] digest = md.digest(); return response.equals(encode(digest)); } catch (Exception e) { e.printStackTrace(); return false; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException { File file = new File(src); BufferedReader in; InputStream is = null; try { if (!file.exists() || !file.canRead()) { try { is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src); in = new BufferedReader(new InputStreamReader(is)); } catch (Exception ex1) { try { is = RuleReaderImpl.class.getResourceAsStream(src); in = new BufferedReader(new InputStreamReader(is)); } catch (Exception ex2) { try { URL url = new URL(src); in = new BufferedReader(new InputStreamReader(url.openStream())); } catch (Exception ex3) { throw new IOException(\"Cannot read from \" + src); } } } } else { FileReader fr = new FileReader(file); in = new BufferedReader(fr); } List<ProvaSolution[]> results = prova.consult(agent, in, key); return results; } finally { if (is != null) is.close(); } }. \n Code2: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else { GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]); } } }",
        "ground_truth": "NO",
        "predict": " catch (Exception e) { e.printStackTrace(); } finally { view.hideWaitCursor(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException { File file = new File(src); BufferedReader in; InputStream is = null; try { if (!file.exists() || !file.canRead()) { try { is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src); in = new BufferedReader(new InputStreamReader(is)); } catch (Exception ex1) { try { is = RuleReaderImpl.class.getResourceAsStream(src); in = new BufferedReader(new InputStreamReader(is)); } catch (Exception ex2) { try { is = new FileInput"
    },
    {
        "ID": 558,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean buildCFItem2ItemStats(String outFileName, String movieAvgFileName, String custAvgFileName) { try { File infile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + movieAvgFileName); FileChannel inC = new FileInputStream(infile).getChannel(); int size = (int) inC.size(); ByteBuffer map = inC.map(FileChannel.MapMode.READ_ONLY, 0, size); TShortFloatHashMap movieAverages = new TShortFloatHashMap(17770, 1); inC.close(); while (map.hasRemaining()) { movieAverages.put(map.getShort(), map.getFloat()); } map = null; infile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + custAvgFileName); inC = new FileInputStream(infile).getChannel(); size = (int) inC.size(); map = inC.map(FileChannel.MapMode.READ_ONLY, 0, size); TIntFloatHashMap custAverages = new TIntFloatHashMap(480189, 1); inC.close(); while (map.hasRemaining()) { custAverages.put(map.getInt(), map.getFloat()); } File outfile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + outFileName); FileChannel outC = new FileOutputStream(outfile, true).getChannel(); short[] movies = CustomersAndRatingsPerMovie.keys(); Arrays.sort(movies); int noMovies = movies.length; for (int i = 0; i < noMovies - 1; i++) { short movie1 = movies[i]; TIntByteHashMap testMovieCustAndRatingsMap = (TIntByteHashMap) CustomersAndRatingsPerMovie.get(movie1); int[] customers1 = testMovieCustAndRatingsMap.keys(); Arrays.sort(customers1); System.out.println(\"Processing movie: \" + movie1); for (int j = i + 1; j < noMovies; j++) { short movie2 = movies[j]; TIntByteHashMap otherMovieCustAndRatingsMap = (TIntByteHashMap) CustomersAndRatingsPerMovie.get(movie2); int[] customers2 = otherMovieCustAndRatingsMap.keys(); TIntArrayList intersectSet = CustOverLapForTwoMoviesCustom(customers1, customers2); int count = 0; float diffRating = 0; float pearsonCorr = 0; float cosineCorr = 0; float adjustedCosineCorr = 0; float sumX = 0; float sumY = 0; float sumXY = 0; float sumX2 = 0; float sumY2 = 0; float sumXYPearson = 0; float sumX2Pearson = 0; float sumY2Pearson = 0; float sumXYACos = 0; float sumX2ACos = 0; float sumY2ACos = 0; if ((intersectSet.size() == 0) || (intersectSet == null)) { count = 0; diffRating = 0; } else { count = intersectSet.size(); for (int l = 0; l < count; l++) { int commonCust = intersectSet.getQuick(l); byte ratingX = testMovieCustAndRatingsMap.get(commonCust); sumX += ratingX; byte ratingY = otherMovieCustAndRatingsMap.get(commonCust); sumY += ratingY; sumX2 += ratingX * ratingX; sumY2 += ratingY * ratingY; sumXY += ratingX * ratingY; diffRating += ratingX - ratingY; sumXYPearson += (ratingX - movieAverages.get(movie1)) * (ratingY - movieAverages.get(movie2)); sumX2Pearson += Math.pow((ratingX - movieAverages.get(movie1)), 2); sumY2Pearson += Math.pow((ratingY - movieAverages.get(movie2)), 2); float custAverage = custAverages.get(commonCust); sumXYACos += (ratingX - custAverage) * (ratingY - custAverage); sumX2ACos += Math.pow((ratingX - custAverage), 2); sumY2ACos += Math.pow((ratingY - custAverage), 2); } } double pearsonDenominator = Math.sqrt(sumX2Pearson) * Math.sqrt(sumY2Pearson); if (pearsonDenominator == 0.0) { pearsonCorr = 0; } else { pearsonCorr = new Double(sumXYPearson / pearsonDenominator).floatValue(); } double adjCosineDenominator = Math.sqrt(sumX2ACos) * Math.sqrt(sumY2ACos); if (adjCosineDenominator == 0.0) { adjustedCosineCorr = 0; } else { adjustedCosineCorr = new Double(sumXYACos / adjCosineDenominator).floatValue(); } double cosineDenominator = Math.sqrt(sumX2) * Math.sqrt(sumY2); if (cosineDenominator == 0.0) { cosineCorr = 0; } else { cosineCorr = new Double(sumXY / cosineDenominator).floatValue(); } ByteBuffer buf = ByteBuffer.allocate(44); buf.putShort(movie1); buf.putShort(movie2); buf.putInt(count); buf.putFloat(diffRating); buf.putFloat(sumXY); buf.putFloat(sumX); buf.putFloat(sumY); buf.putFloat(sumX2); buf.putFloat(sumY2); buf.putFloat(pearsonCorr); buf.putFloat(adjustedCosineCorr); buf.putFloat(cosineCorr); buf.flip(); outC.write(buf); buf.clear(); } } outC.close(); return true; } catch (Exception e) { e.printStackTrace(); return false; } }. \n Code2: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + in",
        "ground_truth": "NO",
        "predict": "File.getName()); while (pdReader.hasNext()) { pdReader.next().copyTo(outFile); } }\n"
    },
    {
        "ID": 563,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: public ArrayList parseFile(File newfile) throws IOException { String s; String firstName; String header; String name = null; Integer PVLoggerID = new Integer(0); String[] tokens; int nvalues = 0; double num1, num2, num3; double xoffset = 1.0; double xdelta = 1.0; double yoffset = 1.0; double ydelta = 1.0; double zoffset = 1.0; double zdelta = 1.0; boolean readfit = false; boolean readraw = false; boolean zerodata = false; boolean baddata = false; boolean harpdata = false; ArrayList fitparams = new ArrayList(); ArrayList xraw = new ArrayList(); ArrayList yraw = new ArrayList(); ArrayList zraw = new ArrayList(); ArrayList sraw = new ArrayList(); ArrayList sxraw = new ArrayList(); ArrayList syraw = new ArrayList(); ArrayList szraw = new ArrayList(); URL url = newfile.toURI().toURL(); InputStream is = url.openStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); while ((s = br.readLine()) != null) { tokens = s.split(\"\\\\s+\"); nvalues = tokens.length; firstName = (String) tokens[0]; if (((String) tokens[0]).length() == 0) { readraw = false; readfit = false; continue; } if ((nvalues == 4) && (!firstName.startsWith(\"---\"))) { if ((Double.parseDouble(tokens[1]) == 0.) && (Double.parseDouble(tokens[2]) == 0.) && (Double.parseDouble(tokens[3]) == 0.)) { zerodata = true; } else { zerodata = false; } if (tokens[1].equals(\"NaN\") || tokens[2].equals(\"NaN\") || tokens[3].equals(\"NaN\")) { baddata = true; } else { baddata = false; } } if (firstName.startsWith(\"start\")) { header = s; } if (firstName.indexOf(\"WS\") > 0) { if (name != null) { dumpData(name, fitparams, sraw, sxraw, syraw, szraw, yraw, zraw, xraw); } name = tokens[0]; readraw = false; readfit = false; zerodata = false; baddata = false; harpdata = false; fitparams.clear(); xraw.clear(); yraw.clear(); zraw.clear(); sraw.clear(); sxraw.clear(); syraw.clear(); szraw.clear(); } if (firstName.startsWith(\"Area\")) ; if (firstName.startsWith(\"Ampl\")) ; if (firstName.startsWith(\"Mean\")) ; if (firstName.startsWith(\"Sigma\")) { fitparams.add(new Double(Double.parseDouble(tokens[3]))); fitparams.add(new Double(Double.parseDouble(tokens[1]))); fitparams.add(new Double(Double.parseDouble(tokens[5]))); } if (firstName.startsWith(\"Offset\")) ; if (firstName.startsWith(\"Slope\")) ; if ((firstName.equals(\"Position\")) && (((String) tokens[2]).equals(\"Raw\"))) { readraw = true; continue; } if ((firstName.equals(\"Position\")) && (((String) tokens[2]).equals(\"Fit\"))) { readfit = true; continue; } if ((firstName.contains(\"Harp\"))) { xraw.clear(); yraw.clear(); zraw.clear(); sraw.clear(); sxraw.clear(); syraw.clear(); szraw.clear(); harpdata = true; readraw = true; name = tokens[0]; continue; } if (firstName.startsWith(\"---\")) continue; if (harpdata == true) { if (((String) tokens[0]).length() != 0) { if (firstName.startsWith(\"PVLogger\")) { try { PVLoggerID = new Integer(Integer.parseInt(tokens[2])); } catch (NumberFormatException e) { } } else { sxraw.add(new Double(Double.parseDouble(tokens[0]))); xraw.add(new Double(Double.parseDouble(tokens[1]))); syraw.add(new Double(Double.parseDouble(tokens[2]))); yraw.add(new Double(Double.parseDouble(tokens[3]))); szraw.add(new Double(Double.parseDouble(tokens[4]))); zraw.add(new Double(Double.parseDouble(tokens[5]))); } } continue; } if (readraw && (!zerodata) && (!baddata)) { sraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0))); sxraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0))); syraw.add(new Double(Double.parseDouble(tokens[0]) / Math.sqrt(2.0))); szraw.add(new Double(Double.parseDouble(tokens[0]))); yraw.add(new Double(Double.parseDouble(tokens[1]))); zraw.add(new Double(Double.parseDouble(tokens[2]))); xraw.add(new Double(Double.parseDouble(tokens[3]))); } if (firstName.startsWith(\"PVLogger\")) { try { PVLoggerID = new Integer(Integer.parseInt(tokens[2])",
        "ground_truth": "NO",
        "predict": "); } catch (NumberFormatException e) { } } } } } catch (IOException e) { e.printStackTrace(); } } }\n"
    },
    {
        "ID": 571,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean delwuliao(String pid) { boolean flag = false; Connection conn = null; PreparedStatement pm = null; try { conn = Pool.getConnection(); conn.setAutoCommit(false); pm = conn.prepareStatement(\"delete from addwuliao where pid=?\"); pm.setString(1, pid); int x = pm.executeUpdate(); if (x == 0) { flag = false; } else { flag = true; } conn.commit(); Pool.close(pm); Pool.close(conn); } catch (Exception e) { e.printStackTrace(); flag = false; try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } Pool.close(pm); Pool.close(conn); } finally { Pool.close(pm); Pool.close(conn); } return flag; }. \n Code2: @Override public void backup() { Connection connection = null; PreparedStatement prestm = null; try { if (logger.isInfoEnabled()) logger.info(\"backup table \" + getOrigin() + \" start...\"); Class.forName(driver); connection = DriverManager.getConnection(url, username, password); String tableExistsResult = \"\"; prestm = connection.prepareStatement(\"show tables from \" + schema + \" like '\" + getDestination() + \"';\"); ResultSet rs = prestm.executeQuery(); if (rs.next()) tableExistsResult = rs.getString(1); rs.close(); prestm.close(); if (StringUtils.isBlank(tableExistsResult)) { String createTableSql = \"\"; prestm = connection.prepareStatement(\"show create table \" + getOrigin() + \";\"); rs = prestm.executeQuery(); if (rs.next()) createTableSql = rs.getString(2); rs.close(); prestm.close(); createTableSql = createTableSql.replaceAll(\"`\" + getOrigin() + \"`\", \"`\" + getDestination() + \"`\"); createTableSql = createTableSql.replaceAll(\"auto_increment\", \"\"); createTableSql = createTableSql.replaceAll(\"AUTO_INCREMENT\", \"\"); Matcher matcher = stripRelationTablePattern.matcher(createTableSql); if (matcher.find()) createTableSql = matcher.replaceAll(\"\"); matcher = normalizePattern.matcher(createTableSql); if (matcher.find()) createTableSql = matcher.replaceAll(\"\\n )\"); Statement stm = connection.createStatement(); stm.execute(createTableSql); if (logger.isDebugEnabled()) logger.debug(\"table '\" + getDestination() + \"' created!\"); } else if (logger.isDebugEnabled()) logger.debug(\"table '\" + getDestination() + \"' already exists\"); Date date = new Date(); date.setTime(TimeUtil.addHours(date, -getHours()).getTimeInMillis()); date.setTime(TimeUtil.getTodayAtMidnight().getTimeInMillis()); if (logger.isInfoEnabled()) logger.info(\"backuping records before: \" + date); long currentRows = 0L; prestm = connection.prepareStatement(\"select count(*) from \" + getOrigin() + \" where \" + getCondition() + \"\"); java.sql.Date sqlDate = new java.sql.Date(date.getTime()); prestm.setDate(1, sqlDate); rs = prestm.executeQuery(); if (rs.next()) currentRows = rs.getLong(1); rs.close(); prestm.close(); if (currentRows > 0) { connection.setAutoCommit(false); prestm = connection.prepareStatement(\"INSERT INTO \" + getDestination() + \" SELECT * FROM \" + getOrigin() + \" WHERE \" + getCondition()); prestm.setDate(1, sqlDate); int rows = prestm.executeUpdate(); prestm.close(); if (logger.isInfoEnabled()) logger.info(rows + \" rows backupped\"); prestm = connection.prepareStatement(\"DELETE FROM \" + getOrigin() + \" WHERE \" + getCondition()); prestm.setDate(1, sqlDate); rows = prestm.executeUpdate(); prestm.close(); connection.commit(); if (logger.isInfoEnabled()) logger.info(rows + \" rows deleted\"); } else if (logger.isInfoEnabled()) logger.info(\"no backup need\"); if (logger.isInfoEnabled()) logger.info(\"backup table \" + getOrigin() + \" end\"); } catch (SQLException e) { logger.error(e, e); if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, \"dbcon\", \"Errore SQL durante il backup dei dati della tabella \" + getOrigin(), e)); try { connection.rollback(); } catch (SQLException e1) { } } catch (Throwable e) { logger.error(e, e); if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, \"generic\", \"Errore generico durante il backup dei dati della tabella \" + getOrigin(), e)); try { connection.rollback(); } catch (SQLException e1) { } } finally { try { if (prestm != null) prestm.close(); } catch (SQLException e) { } try { if (connection != null) connection.close(); } catch (SQLException e) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copy(String src, String dest) throws IOException { InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); byte[] buf = new byte[1024]; int n; while ((n = in.read(buf)) > 0) out.write(buf, 0, n); } finally { if (in != null) in.close(); if (out != null) out.close(); } }. \n Code2: public String kodetu(String testusoila) { MessageDigest md = null; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE); e.printStackTrace(); } try { md.update(testusoila.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { new MezuLeiho(\"Er",
        "ground_truth": "NO",
        "predict": "rore UTF-8\", \"Ados\", \"Errore UTF-8\", JOptionPane.ERROR_MESSAGE); e.printStackTrace(); } return new String(md.digest()); }. \n Code3: public String kodetu(String testusoila, String testusoilb) { MessageDigest md = null; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE); e.printStackTrace(); } try { md.update(testusoila.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { new MezuLeiho(\"Errore UTF-8\", \"Ados\", \"Errore UTF"
    },
    {
        "ID": 575,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getRec(String attribute, String url) { String arr[] = new String[3]; String[] subarr = new String[6]; String mdPrefix = \"\"; String mdPrefixValue = \"\"; String iden = \"\"; String idenValue = \"\"; String s = \"\"; String arguments = attribute.substring(attribute.indexOf(\"?\") + 1); System.out.println(\"attributes\" + arguments); java.util.StringTokenizer st = new java.util.StringTokenizer(arguments, \"&\"); int i = 0; int j = 0; int count = 0; int argCount = 0; java.util.Vector v1 = new java.util.Vector(1, 1); java.util.Vector v901 = new java.util.Vector(1, 1); java.util.Vector v902 = new java.util.Vector(1, 1); java.util.Vector v903 = new java.util.Vector(1, 1); java.util.Vector v904 = new java.util.Vector(1, 1); java.util.Vector v905 = new java.util.Vector(1, 1); java.util.Vector v906 = new java.util.Vector(1, 1); java.util.Vector v907 = new java.util.Vector(1, 1); java.util.Vector v908 = new java.util.Vector(1, 1); java.util.Vector v3 = new java.util.Vector(1, 1); java.util.Vector vData = new java.util.Vector(1, 1); java.util.Vector vSet = new java.util.Vector(1, 1); java.util.Vector v856 = new java.util.Vector(1, 1); Resdate dt = new Resdate(); try { while (st.hasMoreElements()) { arr[i] = st.nextElement().toString(); java.util.StringTokenizer subSt = new java.util.StringTokenizer(arr[i], \"=\"); while (subSt.hasMoreElements()) { subarr[j] = subSt.nextElement().toString(); System.out.println(\" arga are... \" + subarr[j]); j++; } i++; count++; } } catch (Exception e) { e.printStackTrace(); } Namespace oains = Namespace.getNamespace(\"http://www.openarchives.org/OAI/2.0/\"); Element root = new Element(\"OAI-PMH\", oains); Namespace xsi = Namespace.getNamespace(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"); Attribute schemaLocation = new Attribute(\"schemaLocation\", \"http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd\", xsi); root.setAttribute(schemaLocation); root.addNamespaceDeclaration(xsi); Document doc = new Document(root); Element responseDate = new Element(\"responseDate\", oains); root.addContent(responseDate); responseDate.setText(dt.getDate()); Element request = new Element(\"request\", oains); request.setAttribute(\"verb\", \"GetRecord\"); int idenCount = 0, mdfCount = 0; for (int k = 2; k < j; k += 2) { System.out.println(\" arg key \" + subarr[k]); if (subarr[k].equals(\"metadataPrefix\")) { mdPrefix = \"metadataPrefix\"; mdfCount++; mdPrefixValue = subarr[k + 1]; request.setAttribute(mdPrefix, mdPrefixValue); System.out.println(subarr[k] + \"=\"); System.out.println(mdPrefixValue); argCount++; } else if (subarr[k].equals(\"identifier\")) { iden = \"identifier\"; idenCount++; idenValue = subarr[k + 1]; request.setAttribute(iden, idenValue); System.out.println(subarr[k] + \"=\"); System.out.println(idenValue); argCount++; } } request.setText(url); root.addContent(request); System.out.println(\"count\" + argCount); if (mdfCount == 1 && idenCount == 1 && (mdPrefixValue.equals(\"marc21\") || mdPrefixValue.equals(\"oai_dc\") || mdPrefixValue.equals(\"mods\"))) { try { v1 = ((ejb.bprocess.OAIPMH.ListGetRecordsHome) ejb.bprocess.util.HomeFactory.getInstance().getRemoteHome(\"ListGetRecords\")).create().getRecord(idenValue, mdPrefixValue); } catch (Exception ex) { ex.printStackTrace(); } if (v1.size() == 0) { System.out.println(\"vector size is empty\"); Errors e1 = new Errors(); Element errorXML = e1.describeError(3, attribute, url, \"GetRecord\"); root.addContent(errorXML); } else { Element GetRecord = new Element(\"GetRecord\", oains); root.addContent(GetRecord); Element Record = new Element(\"record\", oains); Element metadata = new Element(\"metadata\", oains); Element head = new Element(\"header\", oains); System.out.println(\"size i s \" + v1.size()); for (int v = 0; v < v1.size(); v = v + 13) { vSet = (java.util.Vector) v1.elementAt(v + 1); Element ident = new Element(\"identifier\", oains); ident.setText(idenValue); head.addContent(ident); Element dates = new Element(\"datestamp\", oains); dates.setText(v1.elementAt(v).toString().substring(0, 10)); head.addContent(dates); for (int t = 0; t < vSet.size(); t++) { Element setSpec = new Element(\"setSpec\", oains); System.out.println(\"set elem\" + vSet.elementAt(t).toString()); setSpec.setText(vSet.elementAt(t).toString()); head.addContent(setSpec); } Element marcroot = new Element(\"record\", \"marc\", \"http://www.loc.gov/MARC21/slim\"); Namespace xsimarc = Namespace.getNamespace(\"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"); marcroot.addNamespaceDeclaration(xsimarc); Attribute schemaLocationmarc = new Attribute(\"schemaLocation\", \"http://www.loc.gov/MARC21/slim http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd\", xsimarc);",
        "ground_truth": "NO",
        "predict": " marcroot.setAttribute(schemaLocationmarc); marcroot.addContent(head); Element content = new Element(\"content\", oains); Element record = new Element(\"record\", oains); record.setText(v1.elementAt(v).toString()); content.addContent(record); GetRecord.addContent(content); } } catch (Exception e) { e.printStackTrace(); } }\n"
    },
    {
        "ID": 584,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void encryptChkFile(ProjectMember member, File chkFile) throws Exception { final java.io.FileReader reader = new java.io.FileReader(chkFile); final File encryptedChkFile = new File(member.createOutputFileName(outputPath, \"chk\")); FileOutputStream outfile = null; ObjectOutputStream outstream = null; Utilities.discardBooleanResult(encryptedChkFile.getParentFile().mkdirs()); outfile = new FileOutputStream(encryptedChkFile); outstream = new ObjectOutputStream(outfile); outstream.writeObject(new Format().parse(reader)); reader.close(); outfile.close(); outstream.close(); }. \n Code2: public static Cursor load(URL url, String descriptor) { if (url == null) { log.log(Level.WARNING, \"Trying to load a cursor with a null url.\"); return null; } String cursorFile = url.getFile(); BufferedReader reader = null; int lineNumber = 0; try { DirectoryTextureLoader loader; URL cursorUrl; if (cursorFile.endsWith(cursorDescriptorFile)) { cursorUrl = url; Cursor cached = cursorCache.get(url); if (cached != null) return cached; reader = new BufferedReader(new InputStreamReader(url.openStream())); loader = new DirectoryTextureLoader(url, false); } else if (cursorFile.endsWith(cursorArchiveFile)) { loader = new DirectoryTextureLoader(url, true); if (descriptor == null) descriptor = defaultDescriptorFile; cursorUrl = loader.makeUrl(descriptor); Cursor cached = cursorCache.get(url); if (cached != null) return cached; ZipInputStream zis = new ZipInputStream(url.openStream()); ZipEntry entry; boolean found = false; while ((entry = zis.getNextEntry()) != null) { if (descriptor.equals(entry.getName())) { found = true; break; } } if (!found) { throw new IOException(\"Descriptor file \\\"\" + descriptor + \"\\\" was not found.\"); } reader = new BufferedReader(new InputStreamReader(zis)); } else { log.log(Level.WARNING, \"Invalid cursor fileName \\\"{0}\\\".\", cursorFile); return null; } Cursor cursor = new Cursor(); cursor.url = cursorUrl; List<Integer> delays = new ArrayList<Integer>(); List<String> frameFileNames = new ArrayList<String>(); Map<String, Texture> textureCache = new HashMap<String, Texture>(); String line; while ((line = reader.readLine()) != null) { lineNumber++; int commentIndex = line.indexOf(commentString); if (commentIndex != -1) { line = line.substring(0, commentIndex); } StringTokenizer tokens = new StringTokenizer(line, delims); if (!tokens.hasMoreTokens()) continue; String prefix = tokens.nextToken(); if (prefix.equals(hotSpotXPrefix)) { cursor.hotSpotOffset.x = Integer.valueOf(tokens.nextToken()); } else if (prefix.equals(hotSpotYPrefix)) { cursor.hotSpotOffset.y = Integer.valueOf(tokens.nextToken()); } else if (prefix.equals(timePrefix)) { delays.add(Integer.valueOf(tokens.nextToken())); if (tokens.nextToken().equals(imagePrefix)) { String file = tokens.nextToken(\"\"); file = file.substring(file.indexOf('=') + 1); file.trim(); frameFileNames.add(file); if (textureCache.get(file) == null) { textureCache.put(file, loader.loadTexture(file)); } } else { throw new NoSuchElementException(); } } } cursor.frameFileNames = frameFileNames.toArray(new String[0]); cursor.textureCache = textureCache; cursor.delays = new int[delays.size()]; cursor.images = new Image[frameFileNames.size()]; cursor.textures = new Texture[frameFileNames.size()]; for (int i = 0; i < cursor.frameFileNames.length; i++) { cursor.textures[i] = textureCache.get(cursor.frameFileNames[i]); cursor.images[i] = cursor.textures[i].getImage(); cursor.delays[i] = delays.get(i); } if (delays.size() == 1) cursor.delays = null; if (cursor.images.length == 0) { log.log(Level.WARNING, \"The cursor has no animation frames.\"); return null; } cursor.width = cursor.images[0].getWidth(); cursor.height = cursor.images[0].getHeight(); cursorCache.put(cursor.url, cursor); return cursor; } catch (MalformedURLException mue) { log.log(Level.WARNING, \"Unable to load cursor.\", mue); } catch (IOException ioe) { log.log(Level.WARNING, \"Unable to load cursor.\", ioe); } catch (NumberFormatException nfe) { log.log(Level.WARNING, \"Numerical error while parsing the \" + \"file \\\"{0}\\\" at line {1}\", new Object[] { url, lineNumber }); } catch (IndexOutOfBoundsException ioobe) { log.log(Level.WARNING, \"Error, \\\"=\\\" expected in the file \\\"{0}\\\" at line {1}\", new Object[] { url, lineNumber }); } catch (NoSuchElementException nsee) { log.log(Level.WARNING, \"Error while parsing the file \\\"{0}\\\" at line {1}\", new Object[] { url, lineNumber }); } finally { if (reader != null) { try { reader.close(); } catch (IOException ioe) { log.log(Level.SEVERE, \"Unable to close the steam.\", ioe); } } } return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException { if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName()); byte[] buffer = new byte[bufSize]; int read = 0; InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); while (true) { read = in.read(buffer); if (read == -1) break; out.write(buffer, 0, read); } } finally { if (in != null) try { in.close(); } finally { if (out != null) out.close",
        "ground_truth": "NO",
        "predict": "(); } } }. \n Code2: public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException { if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName()); byte[] buffer = new byte[bufSize]; int read = 0; InputStream in = null; OutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); while (true) { read = in.read(buffer); if (read == -1) break; out.write(buffer, 0, read); } } finally { if (in != null) try { in.close(); } finally { if (out != null) out.close(); } } }. \n Code3: public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException { if (dest.exists()) if ("
    },
    {
        "ID": 604,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void generateArchetype(final IProject project, final IDataModel model, final IProgressMonitor monitor, final boolean offline) throws CoreException, InterruptedException, IOException { if (getArchetypeArtifactId(model) != null) { final Properties properties = new Properties(); properties.put(\"archetypeArtifactId\", getArchetypeArtifactId(model)); properties.put(\"archetypeGroupId\", getArchetypeGroupId(model)); properties.put(\"archetypeVersion\", getArchetypeVersion(model)); String artifact = (String) model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_ARTIFACT_ID); if (artifact == null || artifact.trim().length() == 0) { artifact = project.getName(); } properties.put(\"artifactId\", artifact); String group = (String) model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_GROUP_ID); if (group == null || group.trim().length() == 0) { group = project.getName(); } properties.put(\"groupId\", group); properties.put(\"version\", model.getProperty(IMavenFacetInstallDataModelProperties.PROJECT_VERSION)); final StringBuffer sb = new StringBuffer(System.getProperty(\"user.home\")).append(File.separator); sb.append(\".m2\").append(File.separator).append(\"repository\"); final String local = sb.toString(); Logger.getLog().debug(\"Local Maven2 repository :: \" + local); properties.put(\"localRepository\", local); if (!offline) { final String sbRepos = getRepositories(); properties.put(\"remoteRepositories\", sbRepos); } final ILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager(); final ILaunchConfigurationType launchConfigurationType = launchManager.getLaunchConfigurationType(LAUNCH_CONFIGURATION_TYPE_ID); final ILaunchConfigurationWorkingCopy workingCopy = launchConfigurationType.newInstance(null, \"Creating project using Apache Maven archetype\"); File archetypePomDirectory = getDefaultArchetypePomDirectory(); try { String dfPom = getPomFile(group, artifact); ByteArrayInputStream bais = new ByteArrayInputStream(dfPom.getBytes()); File f = new File(archetypePomDirectory, \"pom.xml\"); OutputStream fous = null; try { fous = new FileOutputStream(f); IOUtils.copy(bais, fous); } finally { try { if (fous != null) { fous.close(); } if (bais != null) { bais.close(); } } catch (IOException e) { } } if (SiteManager.isHttpProxyEnable()) { addProxySettings(properties); } workingCopy.setAttribute(ATTR_POM_DIR, archetypePomDirectory.getAbsolutePath()); workingCopy.setAttribute(ATTR_PROPERTIES, convertPropertiesToList(properties)); String goalName = \"archetype:create\"; if (offline) { goalName = new StringBuffer(goalName).append(\" -o\").toString(); } goalName = updateGoal(goalName); workingCopy.setAttribute(ATTR_GOALS, goalName); final long timeout = org.maven.ide.eclipse.ext.Maven2Plugin.getTimeout(); TimeoutLaunchConfiguration.launchWithTimeout(monitor, workingCopy, project, timeout); monitor.setTaskName(\"Moving to workspace\"); FileUtils.copyDirectoryStructure(new File(archetypePomDirectory, project.getName()), ArchetypePOMHelper.getProjectDirectory(project)); monitor.worked(1); performMavenInstall(monitor, project, offline); project.refreshLocal(2, monitor); } catch (final IOException ioe) { Logger.log(Logger.ERROR, \"I/O exception. One probably solution is absence \" + \"of mvn2 archetypes or not the correct version, \" + \"in your local repository. Please, check existence \" + \"of this archetype.\"); Logger.getLog().error(\"I/O Exception arised creating mvn2 archetype\", ioe); throw ioe; } finally { FileUtils.deleteDirectory(archetypePomDirectory); Logger.log(Logger.INFO, \"Invoked removing of archetype POM directory\"); } } monitor.worked(1); }. \n Code2: private void copyFile(File orig, File dest) { byte[] buffer = new byte[1024]; try { FileInputStream fis = new FileInputStream(orig); FileOutputStream fos = new FileOutputStream(dest, true); int readBytes = 0; do { readBytes = fis.read(buffer); if (readBytes > 0) fos.write(buffer, 0, readBytes); } while (readBytes > 0); fos.close(); fis.close(); } catch (Exception e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void moveFile(File orig, File target) throws IOException { byte buffer[] = new byte[1000]; int bread = 0; FileInputStream fis = new FileInputStream(orig); FileOutputStream fos = new FileOutputStream(target); while (bread != -1) { bread = fis.read(buffer); if (bread != -1) fos.write(buffer, 0, bread); } fis.close(); fos.close(); orig.delete(); }. \n Code2: public void doUpdateByLoginID() throws Exception { if (!isValidate()) { throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\"); } Connection con = null; PreparedStatement ps = null; String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE login_id= ?\"; DBOperation dbo = factory.createDBOperation(POOL_NAME); try { con = dbo.getConnection(); con.setAutoCommit(false); ps = con.prepareStatement(strQuery); ps.setString(1, this.sessionID); ps.setInt(2, this.user.getUserID()); ps.setTimestamp(3, this.beginDate); ps.setString(4, this.ipAddress); ps.setString(5, this.macNO); ps.setString(6, this.loginID); int resultCount = ps.executeUpdate(); if (resultCount != 1) { con.rollback(); throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_S",
        "ground_truth": "NO",
        "predict": "ESSION table\"); } } catch (SQLException e) { if (con != null) { try { con.rollback(); } catch (SQLException e1) { } } } finally { try { if (ps != null) { ps.close(); } } catch (SQLException e) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void doUpdateByLoginID(String loginID) throws Exception { if (!isValidate()) { throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\"); } Connection con = null; PreparedStatement ps = null; String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac"
    },
    {
        "ID": 606,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { Option optHelp = new Option(\"h\", \"help\", false, \"print this message\"); Option optCerts = new Option(\"c\", \"cert\", true, \"use external semicolon separated X.509 certificate files\"); optCerts.setArgName(\"certificates\"); Option optPasswd = new Option(\"p\", \"password\", true, \"set password for opening PDF\"); optPasswd.setArgName(\"password\"); Option optExtract = new Option(\"e\", \"extract\", true, \"extract signed PDF revisions to given folder\"); optExtract.setArgName(\"folder\"); Option optListKs = new Option(\"lk\", \"list-keystore-types\", false, \"list keystore types provided by java\"); Option optListCert = new Option(\"lc\", \"list-certificates\", false, \"list certificate aliases in a KeyStore\"); Option optKsType = new Option(\"kt\", \"keystore-type\", true, \"use keystore type with given name\"); optKsType.setArgName(\"keystore_type\"); Option optKsFile = new Option(\"kf\", \"keystore-file\", true, \"use given keystore file\"); optKsFile.setArgName(\"file\"); Option optKsPass = new Option(\"kp\", \"keystore-password\", true, \"password for keystore file (look on -kf option)\"); optKsPass.setArgName(\"password\"); Option optFailFast = new Option(\"ff\", \"fail-fast\", true, \"flag which sets the Verifier to exit with error code on the first validation failure\"); final Options options = new Options(); options.addOption(optHelp); options.addOption(optCerts); options.addOption(optPasswd); options.addOption(optExtract); options.addOption(optListKs); options.addOption(optListCert); options.addOption(optKsType); options.addOption(optKsFile); options.addOption(optKsPass); options.addOption(optFailFast); CommandLine line = null; try { CommandLineParser parser = new PosixParser(); line = parser.parse(options, args); } catch (ParseException exp) { System.err.println(\"Illegal command used: \" + exp.getMessage()); System.exit(-1); } final boolean failFast = line.hasOption(\"ff\"); final String[] tmpArgs = line.getArgs(); if (line.hasOption(\"h\") || args == null || args.length == 0) { HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(70, \"java -jar Verifier.jar [file1.pdf [file2.pdf ...]]\", \"JSignPdf Verifier is a command line tool for verifying signed PDF documents.\", options, null, true); } else if (line.hasOption(\"lk\")) { for (String tmpKsType : KeyStoreUtils.getKeyStores()) { System.out.println(tmpKsType); } } else if (line.hasOption(\"lc\")) { for (String tmpCert : KeyStoreUtils.getCertAliases(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\"))) { System.out.println(tmpCert); } } else { final VerifierLogic tmpLogic = new VerifierLogic(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\")); tmpLogic.setFailFast(failFast); if (line.hasOption(\"c\")) { String tmpCertFiles = line.getOptionValue(\"c\"); for (String tmpCFile : tmpCertFiles.split(\";\")) { tmpLogic.addX509CertFile(tmpCFile); } } byte[] tmpPasswd = null; if (line.hasOption(\"p\")) { tmpPasswd = line.getOptionValue(\"p\").getBytes(); } String tmpExtractDir = null; if (line.hasOption(\"e\")) { tmpExtractDir = new File(line.getOptionValue(\"e\")).getPath(); } for (String tmpFilePath : tmpArgs) { System.out.println(\"Verifying \" + tmpFilePath); final File tmpFile = new File(tmpFilePath); if (!tmpFile.canRead()) { System.err.println(\"Couln't read the file. Check the path and permissions.\"); if (failFast) { System.exit(-1); } continue; } final VerificationResult tmpResult = tmpLogic.verify(tmpFilePath, tmpPasswd); if (tmpResult.getException() != null) { tmpResult.getException().printStackTrace(); System.exit(-1); } else { System.out.println(\"Total revisions: \" + tmpResult.getTotalRevisions()); for (SignatureVerification tmpSigVer : tmpResult.getVerifications()) { System.out.println(tmpSigVer.toString()); if (tmpExtractDir != null) { try { File tmpExFile = new File(tmpExtractDir + \"/\" + tmpFile.getName() + \"_\" + tmpSigVer.getRevision() + \".pdf\"); System.out.println(\"Extracting to \" + tmpExFile.getCanonicalPath()); FileOutputStream tmpFOS = new FileOutputStream(tmpExFile.getCanonicalPath()); InputStream tmpIS = tmpLogic.extractRevision(tmpFilePath, tmpPasswd, tmpSigVer.getName()); IOUtils.copy(tmpIS, tmpFOS); tmpIS.close(); tmpFOS.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } if (failFast && SignatureVerification.isError(tmpResult.getVerificationResultCode())) { System.exit(tmpResult.getVerificationResultCode()); } } } } }. \n Code2: public static void copy(File source, File dest) throws IOException { FileChannel in = null, out = null; try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(dest).getChannel(); long size = in.size(); MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); out.write(buf); } finally { if (in != null) in.close(); if (out != null) out.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected ExternalDecoder(InputStream source, Process process) { super(source); this.process = process; this.processStdOut = process.getInputStream(); this.processStdIn = process.getOutputStream(); new Thread() { @Override public void run() { try { IOUtils.copy(getSource(), processStdIn); System.err.println(\"",
        "ground_truth": "NO",
        "predict": "Process stdout: \" + IOUtils.toString(processStdOut)); } catch (IOException ioe) { ioe.printStackTrace(); } } }.start(); }. \n Code2: public static void main(String[] args) { new VerifierLogic().run(args); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { Option optHelp = new Option(\"h\", \"help\", false, \"print this message\"); Option optCerts = new Option(\"c\", \"cert\", true, \"use external semicolon separated X.509 certificate files\"); optCerts.setArgName(\"certificates\"); Option optPasswd = new Option(\"p\", \"password\", true, \"set password for opening PDF\"); optPasswd.setArgName(\"password\"); Option optExtract = new Option(\"e\","
    },
    {
        "ID": 608,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static void main(String[] args) { String WTKdir = null; String sourceFile = null; String instrFile = null; String outFile = null; String jadFile = null; Manifest mnf; if (args.length == 0) { usage(); return; } int i = 0; while (i < args.length && args[i].startsWith(\"-\")) { if ((\"-WTK\".equals(args[i])) && (i < args.length - 1)) { i++; WTKdir = args[i]; } else if ((\"-source\".equals(args[i])) && (i < args.length - 1)) { i++; sourceFile = args[i]; } else if ((\"-instr\".equals(args[i])) && (i < args.length - 1)) { i++; instrFile = args[i]; } else if ((\"-o\".equals(args[i])) && (i < args.length - 1)) { i++; outFile = args[i]; } else if ((\"-jad\".equals(args[i])) && (i < args.length - 1)) { i++; jadFile = args[i]; } else { System.out.println(\"Error: Unrecognized option: \" + args[i]); System.exit(0); } i++; } if (WTKdir == null || sourceFile == null || instrFile == null) { System.out.println(\"Error: Missing parameter!!!\"); usage(); return; } if (outFile == null) outFile = sourceFile; FileInputStream fisJar; try { fisJar = new FileInputStream(sourceFile); } catch (FileNotFoundException e1) { System.out.println(\"Cannot find source jar file: \" + sourceFile); e1.printStackTrace(); return; } FileOutputStream fosJar; File aux = null; try { aux = File.createTempFile(\"predef\", \"aux\"); fosJar = new FileOutputStream(aux); } catch (IOException e1) { System.out.println(\"Cannot find temporary jar file: \" + aux); e1.printStackTrace(); return; } JarFile instrJar = null; Enumeration en = null; File tempDir = null; try { instrJar = new JarFile(instrFile); en = instrJar.entries(); tempDir = File.createTempFile(\"jbtp\", \"\"); tempDir.delete(); System.out.println(\"Create directory: \" + tempDir.mkdirs()); tempDir.deleteOnExit(); } catch (IOException e) { System.out.println(\"Cannot open instrumented file: \" + instrFile); e.printStackTrace(); return; } String[] wtklib = new java.io.File(WTK",
        "ground_truth": "NO",
        "predict": "dir).list(); if (wtklib == null) { System.out.println(\"Cannot find WTK directory: \" + WTKdir); return; } while (en.hasMoreElements()) { String name = en.nextElement().toString(); if (name.endsWith(\".jar\")) { try { fosJar.write(name.getBytes()); fosJar.write('\\n'); } catch (IOException e) { System.out.println(\"Cannot write to temporary jar file: \" + aux); e.printStackTrace(); return; } } } fisJar.close(); fosJar.close(); try { mnf = new Manifest(fisJar); } catch (IOException e) { System.out.println(\"Cannot read manifest from instrumented file: \" + instrFile); e.printStackTrace(); return; } fisJar.close(); try { fosJar = new FileOutputStream(outFile); } catch (FileNotFound"
    },
    {
        "ID": 633,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void copyFileFromLocalMachineToRemoteMachine(InputStream source, File destination) throws Exception { String fileName = destination.getPath(); File f = new File(getFtpServerHome(), \"\" + System.currentTimeMillis()); f.deleteOnExit(); org.apache.commons.io.IOUtils.copy(source, new FileOutputStream(f)); remoteHostClient.setAscii(isAscii()); remoteHostClient.setPromptOn(isPrompt()); remoteHostClient.copyFileFromLocalMachineToRemoteClient(f.getName(), fileName); }. \n Code2: void run(String[] args) { InputStream istream = System.in; System.out.println(\"TradeMaximizer \" + version); String filename = parseArgs(args, false); if (filename != null) { System.out.println(\"Input from: \" + filename); try { if (filename.startsWith(\"http:\") || filename.startsWith(\"ftp:\")) { URL url = new URL(filename); istream = url.openStream(); } else istream = new FileInputStream(filename); } catch (IOException ex) { fatalError(ex.toString()); } } List<String[]> wantLists = readWantLists(istream); if (wantLists == null) return; if (options.size() > 0) { System.out.print(\"Options:\"); for (String option : options) System.out.print(\" \" + option); System.out.println(); } System.out.println(); try { MessageDigest digest = MessageDigest.getInstance(\"MD5\"); for (String[] wset : wantLists) { for (String w : wset) { digest.update((byte) ' '); digest.update(w.getBytes()); } digest.update((byte) '\\n'); } System.out.println(\"Input Checksum: \" + toHexString(digest.digest())); } catch (NoSuchAlgorithmException ex) { } parseArgs(args, true); if (iterations > 1 && seed == -1) { seed = System.currentTimeMillis(); System.out.println(\"No explicit SEED, using \" + seed); } if (!(metric instanceof MetricSumSquares) && priorityScheme != NO_PRIORITIES) System.out.println(\"Warning: using priorities with the non-default metric is normally worthless\"); buildGraph(wantLists); if (showMissing && officialNames != null && officialNames.size() > 0) { for (String name : usedNames) officialNames.remove(name); List<String> missing = new ArrayList<String>(officialNames); Collections.sort(missing); for (String name : missing) { System.out.println(\"**** Missing want list for official name \" + name); } System.out.println(); } if (showErrors && errors.size() > 0) { Collections.sort(errors); System.out.println(\"ERRORS:\"); for (String error : errors) System.out.println(error); System.out.println(); } long startTime = System.currentTimeMillis(); graph.removeImpossibleEdges(); List<List<Graph.Vertex>> bestCycles = graph.findCycles(); int bestMetric = metric.calculate(bestCycles); if (iterations > 1) { System.out.println(metric); graph.saveMatches(); for (int i = 0; i < iterations - 1; i++) { graph.shuffle(); List<List<Graph.Vertex>> cycles = graph.findCycles(); int newMetric = metric.calculate(cycles); if (newMetric < bestMetric) { bestMetric = newMetric; bestCycles = cycles; graph.saveMatches(); System.out.println(metric); } else if (verbose) System.out.println(\"# \" + metric); } System.out.println(); graph.restoreMatches(); } long stopTime = System.currentTimeMillis(); displayMatches(bestCycles); if (showElapsedTime) System.out.println(\"Elapsed time = \" + (stopTime - startTime) + \"ms\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void update(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try { dbo = (ERDBOperation) createDBOperation(); String url = \"\"; boolean flag = true; StringTokenizer st = null; conn = dbo.getConnection(); conn.setAutoCommit(false); ps = conn.prepareStatement(sqlInitial); rs = ps.executeQuery(); if (rs.next()) url = rs.getString(1); if (!url.equals(\"\")) { st = new StringTokenizer(url, \",\"); String sortDocId = \"\"; while (st.hasMoreTokens()) { if (flag) { sortDocId = \"'\" + st.nextToken() + \"'\"; flag = false; } else { sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\"; } } String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField; ps = conn.prepareStatement(sqlsort); rs = ps.executeQuery(); String sortURL = \"\"; boolean sortflag = true; while (rs.next()) { if (sortflag) { sortURL = rs.getString(1); sortflag = false; } else { sortURL = sortURL + \",\" + rs.getString(1); } } ps = conn.prepareStatement(sqlsortURL); ps.setString(1, sortURL); ps.executeUpdate(); } conn.commit(); } catch (Exception e) { e.printStackTrace(); try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { close(rs, null, ps, conn, dbo); } }. \n Code2: @Digester(forField = \"password\") public static String encriptPassword(String passwd) { try { MessageDigest md = MessageDigest.getInstance(\"",
        "ground_truth": "NO",
        "predict": "MD5\"); md.update(passwd.getBytes()); return toHexString(md.digest()); } catch (NoSuchAlgorithmException e) { return null; } }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code2: public static void main(String[] args"
    },
    {
        "ID": 634,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void processData(InputStream raw) { String fileName = remoteName; if (localName != null) { fileName = localName; } try { FileOutputStream fos = new FileOutputStream(new File(fileName), true); IOUtils.copy(raw, fos); LOG.info(\"ok\"); } catch (IOException e) { LOG.error(\"error writing file\", e); } }. \n Code2: public String doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UploadFileForm vo = (UploadFileForm) form; String review = request.getParameter(\"review\"); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = request.getParameter(\"inforId\"); request.setAttribute(\"id\", inforId); String str_postFIX = \"\"; int i_p = 0; if (null == review) { FormFile file = vo.getFile(); if (file != null) { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); String strAppend = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); if (file.getFileSize() != 0) { file.getInputStream(); String name = file.getFileName(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); String fullPath = realpath + \"attach/\" + strAppend + str_postFIX; t_attach attach = new t_attach(); attach.setAttach_fullname(fullPath); attach.setAttach_name(name); attach.setInfor_id(Integer.parseInt(inforId)); attach.setInsert_day(new Date()); attach.setUpdate_day(new Date()); t_attach_EditMap attachEdit = new t_attach_EditMap(); attachEdit.add(attach); File sysfile = new File(fullPath); if (!sysfile.exists()) { sysfile.createNewFile(); } java.io.OutputStream out = new FileOutputStream(sysfile); org.apache.commons.io.IOUtils.copy(file.getInputStream(), out); out.close(); } } request.setAttribute(\"operating-status\", \"\ufffd\ufffd\ufffd\ufffd\ufffd\u0279\ufffd! \ufffd\ufffd\u04ed\ufffd\ufffd\ufffd\ufffd\u02b9\ufffd\u00e1\ufffd\"); return \"editsave\"; } else { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); FormFile file = vo.getFile(); FormFile file2 = vo.getFile2(); FormFile file3 = vo.getFile3(); t_infor_review newreview = new t_infor_review(); String content = request.getParameter(\"content\"); newreview.setContent(content); if (null != inforId) newreview.setInfor_id(Integer.parseInt(inforId)); newreview.setInsert_day(new Date()); UserDetails user = LoginUtils.getLoginUser(request); newreview.setCreate_name(user.getUsercode()); if (null != file.getFileName() && !\"\".equals(file.getFileName())) { newreview.setAttachname1(file.getFileName()); String strAppend1 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); newreview.setAttachfullname1(realpath + \"attach/\" + strAppend1 + str_postFIX); saveFile(file.getInputStream(), realpath + \"attach/\" + strAppend1 + str_postFIX); } if (null != file2.getFileName() && !\"\".equals(file2.getFileName())) { newreview.setAttachname2(file2.getFileName()); String strAppend2 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file2.getFileName().lastIndexOf(\".\"); str_postFIX = file2.getFileName().substring(i_p, file2.getFileName().length()); newreview.setAttachfullname2(realpath + \"attach/\" + strAppend2 + str_postFIX); saveFile(file2.getInputStream(), realpath + \"attach/\" + strAppend2 + str_postFIX); } if (null != file3.getFileName() && !\"\".equals(file3.getFileName())) { newreview.setAttachname3(file3.getFileName()); String strAppend3 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file3.getFileName().lastIndexOf(\".\"); str_postFIX = file3.getFileName().substring(i_p, file3.getFileName().length()); newreview.setAttachfullname3(realpath + \"attach/\" + strAppend3 + str_postFIX); saveFile(file3.getInputStream(), realpath + \"attach/\" + strAppend3 + str_postFIX); } t_infor_review_EditMap reviewEdit = new t_infor_review_EditMap(); reviewEdit.add(newreview); request.setAttribute(\"review\", \"1\"); return \"aftersave\"; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void generate(String urlString, String target) throws Exception { URL url = new URL(urlString); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream()); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target)); byte[] buf = new byte[10 * 1024]; int len; while ((len = inputStream.read(buf, 0, buf.length)) != -1) { output",
        "ground_truth": "NO",
        "predict": "Stream.write(buf, 0, len); } outputStream.flush(); outputStream.close(); inputStream.close(); }. \n Code2: public void doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UploadFileForm vo = (UploadFileForm) form; String review = request.getParameter(\"review\"); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = request.getParameter(\"inforId\"); request.setAttribute(\"id\", inforId); String str_postFIX = \"\"; int i_p = 0; if (null == review) { FormFile file = vo.getFile(); if (file != null) { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String."
    },
    {
        "ID": 637,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Test public void test() throws JDOMException, IOException { InputStream is = this.getClass().getResourceAsStream(\"putRegularVehicle.xml\"); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); IOUtils.copy(is, byteArrayOutputStream); TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray()); TrafficSimulationEngine se = new TrafficSimulationEngine(); se.init(def); int linkId = 2; int segmentId = 3; Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>(); Set<Integer> segments = new HashSet<Integer>(); segments.add(segmentId); linkSegments.put(linkId, segments); FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>()); se.setFrameProperties(frameProperties); for (float time = 0; time < 60; time += 0.1f) { se.step(0.1f); System.out.println(\"*** Time: \" + time); for (RoadObject roadObject : se.getDynamicObjects()) { Vehicle vehicle = (Vehicle) roadObject; System.out.println(vehicle.getVehicleId() + \":\\tX=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed()); } } }. \n Code2: public void run() { long starttime = (new Date()).getTime(); Matcher m = Pattern.compile(\"(\\\\S+);(\\\\d+)\").matcher(Destination); boolean completed = false; if (OutFile.length() > IncommingProcessor.MaxPayload) { logger.warn(\"Payload is too large!\"); close(); } else { if (m.find()) { Runnable cl = new Runnable() { public void run() { WaitToClose(); } }; Thread t = new Thread(cl); t.start(); S = null; try { String ip = m.group(1); int port = Integer.valueOf(m.group(2)); SerpentEngine eng = new SerpentEngine(); byte[] keybytes = new byte[eng.getBlockSize()]; byte[] ivbytes = new byte[eng.getBlockSize()]; Random.nextBytes(keybytes); Random.nextBytes(ivbytes); KeyParameter keyparm = new KeyParameter(keybytes); ParametersWithIV keyivparm = new ParametersWithIV(keyparm, ivbytes); byte[] parmbytes = BCUtils.writeParametersWithIV(keyivparm); OAEPEncoding enc = new OAEPEncoding(new ElGamalEngine(), new RIPEMD128Digest()); enc.init(true, PublicKey); byte[] encbytes = enc.encodeBlock(parmbytes, 0, parmbytes.length); PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new SerpentEngine())); cipher.init(true, keyivparm); byte[] inbuffer = new byte[128]; byte[] outbuffer = new byte[256]; int readlen = 0; int cryptlen = 0; FileInputStream fis = new FileInputStream(OutFile); FileOutputStream fos = new FileOutputStream(TmpFile); readlen = fis.read(inbuffer); while (readlen >= 0) { if (readlen > 0) { cryptlen = cipher.processBytes(inbuffer, 0, readlen, outbuffer, 0); fos.write(outbuffer, 0, cryptlen); } readlen = fis.read(inbuffer); } cryptlen = cipher.doFinal(outbuffer, 0); if (cryptlen > 0) { fos.write(outbuffer, 0, cryptlen); } fos.close(); fis.close(); S = new Socket(ip, port); DataOutputStream dos = new DataOutputStream(S.getOutputStream()); dos.writeInt(encbytes.length); dos.write(encbytes); dos.writeLong(TmpFile.length()); fis = new FileInputStream(TmpFile); readlen = fis.read(inbuffer); while (readlen >= 0) { dos.write(inbuffer, 0, readlen); readlen = fis.read(inbuffer); } DataInputStream dis = new DataInputStream(S.getInputStream()); byte[] encipbytes = StreamUtils.readBytes(dis); cipher.init(false, keyivparm); byte[] decipbytes = new byte[encipbytes.length]; int len = cipher.processBytes(encipbytes, 0, encipbytes.length, decipbytes, 0); len += cipher.doFinal(decipbytes, len); byte[] realbytes = new byte[len]; System.arraycopy(decipbytes, 0, realbytes, 0, len); String ipstr = new String(realbytes, \"ISO-8859-1\"); Callback.Success(ipstr); completed = true; dos.write(0); dos.flush(); close(); } catch (Exception e) { close(); if (!completed) { e.printStackTrace(); Callback.Fail(e.getMessage()); } } } else { close(); logger.warn(\"Improper destination string. \" + Destination); Callback.Fail(\"Improper destination string. \" + Destination); } } CloseWait(); long newtime = (new Date()).getTime(); long timediff = newtime - starttime; logger.debug(\"Outgoing processor took: \" + timediff); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void actualizar() throws SQLException, ClassNotFoundException, Exception { Connection conn = null; PreparedStatement ms = null; registroActualizado = false; try { conn = ToolsBD.getConn(); conn.setAutoCommit(false); Date fechaSystem = new Date(); DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\"); int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem)); DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\"); DateFormat sss = new SimpleDateFormat(\"S\"); String ss = sss.format(fechaSystem); if (ss.length() > 2) { ss = ss.substring(0, 2); } int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss); ms = conn.prepareStatement(SENTENCIA_UPDATE); ms.setString(1, descartadoEntrada); ms.setString(2, usuarioEntrada); ms.setString(3, motivosDescarteEntrada); ms.setInt(4, Integer.parseInt(anoOficio)); ms.setInt(5, Integer.parseInt(oficinaOficio)); ms.",
        "ground_truth": "NO",
        "predict": "setInt(6, fzafsis); ms.setInt(7, fzahsis); ms.setInt(8, Integer.parseInt(idOficina)); ms.setInt(9, Integer.parseInt(idUsuario)); ms.setInt(10, Integer.parseInt(idVehiculo)); ms.executeUpdate(); registroActualizado = true; } catch (Exception e) { logger.error(\"Error al actualizar el registro: \" + e.getMessage()); } finally { try { if (ms != null) { ms.close(); } } catch (Exception e) { } } }. \n */"
    },
    {
        "ID": 642,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void test_UseCache_HttpURLConnection_NoCached_GetOutputStream() throws Exception { ResponseCache.setDefault(new MockNonCachedResponseCache()); uc = (HttpURLConnection) url.openConnection(); uc.setChunkedStreamingMode(10); uc.setDoOutput(true); uc.getOutputStream(); assertTrue(isGetCalled); assertFalse(isPutCalled); assertFalse(isAbortCalled); uc.disconnect(); }. \n Code2: public static String crypt(String strPassword, String strSalt) { try { StringTokenizer st = new StringTokenizer(strSalt, \"$\"); st.nextToken(); byte[] abyPassword = strPassword.getBytes(); byte[] abySalt = st.nextToken().getBytes(); MessageDigest _md = MessageDigest.getInstance(\"MD5\"); _md.update(abyPassword); _md.update(MAGIC.getBytes()); _md.update(abySalt); MessageDigest md2 = MessageDigest.getInstance(\"MD5\"); md2.update(abyPassword); md2.update(abySalt); md2.update(abyPassword); byte[] abyFinal = md2.digest(); for (int n = abyPassword.length; n > 0; n -= 16) { _md.update(abyFinal, 0, n > 16 ? 16 : n); } abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; for (int j = 0, i = abyPassword.length; i != 0; i >>>= 1) { if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(abyPassword, j, 1); } StringBuffer sbPasswd = new StringBuffer(); sbPasswd.append(MAGIC); sbPasswd.append(new String(abySalt)); sbPasswd.append('$'); abyFinal = _md.digest(); for (int n = 0; n < 1000; n++) { MessageDigest md3 = MessageDigest.getInstance(\"MD5\"); if ((n & 1) != 0) md3.update(abyPassword); else md3.update(abyFinal); if ((n % 3) != 0) md3.update(abySalt); if ((n % 7) != 0) md3.update(abyPassword); if ((n & 1) != 0) md3.update(abyFinal); else md3.update(abyPassword); abyFinal = md3.digest(); } int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) }; to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4); to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4); to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4); to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4); to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4); to64(sbPasswd, anFinal[11], 2); return sbPasswd.toString(); } catch (NoSuchAlgorithmException e) { return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int scrapeForIsbns(URL url) { int matches = 0; Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\"); Matcher m; for (int i = 0; i < RETRIES; i++) { try { InputStream in = url.openStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String str; while ((str = br.readLine()) != null) { m = p.matcher(str); while (m.find()) { matches++; outputIsbns.put(m.group(1)); logger.debug(\"Got ISBN: \" + m.group(1)); } } break; } catch (ConnectException e) { logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES); try { Thread.sleep(5000); } catch (InterruptedException e1) { } } catch (IOException e) { logger.error(\"Error reading URL stream\", e); } catch (InterruptedException e) { logger.error(\"Interrupted while calling put(Object E)\", e); } } return matches; }. \n Code2: public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException { int last = destfile.lastIndexOf('/'); if (last < 0) { DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\"); throw new java.io.FileNotFoundException(destfile); } String parent =",
        "ground_truth": "NO",
        "predict": " destfile.substring(0, last); if (!new File(parent).exists()) { DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't exist\"); throw new java.io.FileNotFoundException(destfile); } if (!new File(sourcefile).exists()) { DrxWriteError(\"CopyFile\", \"Source filepath \" + sourcefile + \" doesn't exist\"); throw new java.io.FileNotFoundException(sourcefile); } if (!new File(sourcefile).isFile()) { DrxWriteError(\"CopyFile\", \"Source filepath \" + sourcefile + \" is not a file\"); throw new java.io.FileNotFoundException(sourcefile); } if (!new File(destfile).isFile()) { DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" is not a file\"); throw new java.io.FileNotFoundException(destfile); } if (!new File(destfile"
    },
    {
        "ID": 643,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void saveDraft(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException { try { if (charset == null) { charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName()); } if ((body == null) || body.trim().equals(\"\")) { body = \" \"; } Email email = null; if (isHtml) { email = new HtmlEmail(); } else { email = new MultiPartEmail(); } email.setCharset(charset); Users user = getUser(hsession, repositoryName); Identity identity = getIdentity(hsession, ideIdint, user); InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName()); InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName()); InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName()); InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null); InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null); InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null); if (_from != null) { email.setFrom(_from.getAddress(), _from.getPersonal()); } if (_returnPath != null) { email.addHeader(\"Return-Path\", _returnPath.getAddress()); email.addHeader(\"Errors-To\", _returnPath.getAddress()); email.addHeader(\"X-Errors-To\", _returnPath.getAddress()); } if (_replyTo != null) { email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal()); } if ((_to != null) && (_to.length > 0)) { HashSet aux = new HashSet(_to.length); Collections.addAll(aux, _to); email.setTo(aux); } if ((_cc != null) && (_cc.length > 0)) { HashSet aux = new HashSet(_cc.length); Collections.addAll(aux, _cc); email.setCc(aux); } if ((_bcc != null) && (_bcc.length > 0)) { HashSet aux = new HashSet(_bcc.length); Collections.addAll(aux, _bcc); email.setBcc(aux); } email.setSubject(subject); Date now = new Date(); email.setSentDate(now); File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\"); if (!dir.exists()) { dir.mkdir(); } if ((attachments != null) && (attachments.size() > 0)) { for (int i = 0; i < attachments.size(); i++) { ByteArrayInputStream bais = null; FileOutputStream fos = null; try { MailPartObj obj = (MailPartObj) attachments.get(i); File file = new File(dir, obj.getName()); bais = new ByteArrayInputStream(obj.getAttachent()); fos = new FileOutputStream(file); IOUtils.copy(bais, fos); EmailAttachment attachment = new EmailAttachment(); attachment.setPath(file.getPath()); attachment.setDisposition(EmailAttachment.ATTACHMENT); attachment.setDescription(\"File Attachment: \" + file.getName()); attachment.setName(file.getName()); if (email instanceof MultiPartEmail) { ((MultiPartEmail) email).attach(attachment); } } catch (Exception ex) { } finally { IOUtils.closeQuietly(bais); IOUtils.closeQuietly(fos); } } } if (headers != null) { Header xheader; Enumeration xe = headers.getAllHeaders(); for (; xe.hasMoreElements(); ) { xheader = (Header) xe.nextElement(); if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) { email.addHeader(xheader.getName(), xheader.getValue()); } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) { email.addHeader(xheader.getName(), xheader.getValue()); } } } if (priority != null) { if (priority.equals(\"high\")) { email.addHeader(\"Importance\", priority); email.addHeader(\"X-priority\", \"1\"); } else if (priority.equals(\"low\")) { email.addHeader(\"Importance\", priority); email.addHeader(\"X-priority\", \"5\"); } } if (email instanceof HtmlEmail) { ((HtmlEmail) email).setHtmlMsg(body); } else { email.setMsg(body); } email.setMailSession(session); email.buildMimeMessage(); MimeMessage mime = email.getMimeMessage(); int size = MessageUtilities.getMessageSize(mime); if (!controlQuota(hsession, user, size)) { throw new MailException(\"ErrorMessages.mail.quota.exceded\"); } messageable.storeDraftMessage(getId(), mime, user); } catch (MailException e) { throw e; } catch (Exception e) { throw new MailException(e); } catch (java.lang.OutOfMemoryError ex) { System.gc(); throw new MailException(ex); } catch (Throwable e) { throw new MailException(e); } finally { GeneralOperations.closeHibernateSession(hsession); } }. \n Code2: private void newGame() { List scenarios = getScenarioChoices(); ScenarioChoice scenarioChoice = (ScenarioChoice) JOptionPane.showInputDialog(this, \"Choose a Scenario\", \"Choose a Scenario\", JOptionPane.PLAIN_MESSAGE, null, scenarios.toArray(), scenarios.get(0)); if (scenarioChoice == null) { return; } Object obj; try { obj = scamsoft.util.Toolkit.loadClass(scenarioChoice.className, null); } catch (ClassNotFoundException e) { handleNetworkException(e); return; } catch (InstantiationException e) { handleNetworkException(e); return; } catch (InvocationTargetException e) { handleNetworkException(e); return; } catch (IllegalArgumentException e) { handleNetworkException(e); return; } catch (IllegalAccessException e) { handleNetworkException(e); return; } if (obj == null || !(obj instanceof Scenario)) { return; } Scenario scenario = (Scenario) obj; String[] variations = scenario.getVariations(); int chosenvariation =",
        "ground_truth": "NO",
        "predict": " 0; while (true) { try { obj = scenario.getVariation(chosenvariation); } catch (Exception e) { handleNetworkException(e); return; } if (obj == null || !(obj instanceof Variation)) { return; } Variation variation = (Variation) obj; String[] variations = variation.getVariations(); int chosenvariation = 0; while (true) { try { obj = variation.getVariation(chosenvariation); } catch (Exception e) { handleNetworkException(e); return; } if (obj == null || !(obj instanceof Variation)) { return; } variation = (Variation) obj; variations = variation.getVariations(); chosenvariation = 0; while (true) { try { obj = variation.getVariation(chosenvariation); } catch (Exception e) { handleNetworkException(e); return; } if (obj == null || !(obj instanceof Variation)) { return; } variation = ("
    },
    {
        "ID": 645,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String encrypt(String plaintext) throws NoSuchAlgorithmException { MessageDigest md; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { logger.error(\"unable to encrypt password\" + e.getMessage()); throw new NoSuchAlgorithmException(e.getMessage()); } try { md.update(plaintext.getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { logger.error(\"unable to encrypt password\" + e.getMessage()); throw new NoSuchAlgorithmException(e.getMessage()); } byte raw[] = md.digest(); return (new BASE64Encoder()).encode(raw); }. \n Code2: protected void assignListeners() { groupsList.addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent event) { refreshInfo(); } }); saveButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { JFileChooser fileDialog = new JFileChooser(\".\"); fileDialog.setFileFilter(ReaderData.mkExtensionFileFilter(\".grp\", \"Group Files\")); int outcome = fileDialog.showSaveDialog((Frame) null); if (outcome == JFileChooser.APPROVE_OPTION) { assert (fileDialog.getCurrentDirectory() != null); assert (fileDialog.getSelectedFile() != null); String fileName = fileDialog.getCurrentDirectory().toString() + File.separator + fileDialog.getSelectedFile().getName(); try { PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(fileName))); ReaderWriterGroup.write(out, writer); System.err.println(\"Wrote groups informations to output '\" + fileName + \"'.\"); out.close(); } catch (IOException e) { System.err.println(\"error while writing (GroupManager.saveClt):\"); e.printStackTrace(); } } else if (outcome == JFileChooser.CANCEL_OPTION) { } } }); loadButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent evt) { JFileChooser fileDialog = new JFileChooser(\".\"); fileDialog.setFileFilter(ReaderData.mkExtensionFileFilter(\".grp\", \"Group Files\")); int outcome = fileDialog.showOpenDialog((Frame) null); if (outcome == JFileChooser.APPROVE_OPTION) { assert (fileDialog.getCurrentDirectory() != null); assert (fileDialog.getSelectedFile() != null); String fileName = fileDialog.getCurrentDirectory().toString() + File.separator + fileDialog.getSelectedFile().getName(); BufferedReader fileReader = null; try { fileReader = new BufferedReader(new FileReader(fileName)); ReaderWriterGroup.read(fileReader, writer); fileReader.close(); } catch (Exception e) { System.err.println(\"Exception while reading from file '\" + fileName + \"'.\"); System.err.println(e); } } else if (outcome == JFileChooser.CANCEL_OPTION) { } } }); ItemListener propItemListener = new ItemListener() { @Override public void itemStateChanged(ItemEvent event) { int[] indices = groupsList.getSelectedIndices(); for (int index : indices) { Group group = getGroupFromListIndex(index); if (group != null) { if (event.getSource() instanceof JComboBox) { JComboBox eventSource = (JComboBox) event.getSource(); if (eventSource == colorComboBox) { Color color = colorComboBox.getSelectedColor(); assert (color != null); group.setColor(color); shapeComboBox.setColor(color); } else if (eventSource == shapeComboBox) { Shape shape = shapeComboBox.getSelectedShape(); assert (shape != null); group.setShape(shape); } } else if (event.getSource() instanceof JCheckBox) { JCheckBox eventSource = (JCheckBox) event.getSource(); if (eventSource == showGroupCheckBox) { group.visible = showGroupCheckBox.isSelected(); } else if (eventSource == showGraphicInfoCheckBox) { group.info = showGraphicInfoCheckBox.isSelected(); } } } } graph.notifyAboutGroupsChange(null); } }; colorComboBox.addItemListener(propItemListener); shapeComboBox.addItemListener(propItemListener); showGroupCheckBox.addItemListener(propItemListener); showGraphicInfoCheckBox.addItemListener(propItemListener); showGroupfreeNodesCheckBox.addItemListener(new ItemListener() { @Override public void itemStateChanged(ItemEvent event) { graph.getGroup(0).visible = showGroupfreeNodesCheckBox.isSelected(); graph.notifyAboutGroupsChange(null); } }); ActionListener propActionListener = new ActionListener() { @Override public void actionPerformed(ActionEvent event) { JButton botton = (JButton) event.getSource(); Group group = getGroupFromListIndex(groupsList.getSelectedIndex()); if (group != null) { for (GraphVertex graphVertex : group) { if (botton == showLabelsButton) { graphVertex.setShowName(NameVisibility.Priority.GROUPS, true); } else if (botton == hideLabelsButton) { graphVertex.setShowName(NameVisibility.Priority.GROUPS, false); } } graph.notifyAboutGroupsChange(null); } } }; showLabelsButton.addActionListener(propActionListener); hideLabelsButton.addActionListener(propActionListener); newButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { String newGroupName = JOptionPane.showInputDialog(null, \"Enter a name\", \"Name of the new group\", JOptionPane.QUESTION_MESSAGE); if (newGroupName != null) { if (graph.getGroup(newGroupName) == null) { graph.addGroup(new Group(newGroupName, graph)); } } } }); editButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { Group group = getGroupFromListIndex(groupsList.getSelectedIndex()); if (group != null) { DialogEditGroup dialog = new DialogEditGroup(graph, group); dialog.setModal(true); dialog.setVisible(true); } } }); deleteButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent event) { int index = groupsList.getSelectedIndex(); if (index > 0 && index < graph.getNumberOfGroups() -",
        "ground_truth": "NO",
        "predict": " 1) { graph.removeGroup(index); } } }); }\n\n}\n"
    },
    {
        "ID": 651,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws IOException { ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(4444); } catch (IOException e) { System.err.println(\"Could not listen on port: 4444.\"); System.exit(1); } Socket clientSocket = null; try { clientSocket = serverSocket.accept(); } catch (IOException e) { System.err.println(\"Accept failed.\"); System.exit(1); } DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream()); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); String inputLine, outputLine; inputLine = in.readLine(); String dist_metric = in.readLine(); File outFile = new File(\"data.txt\"); FileWriter outw = new FileWriter(outFile); outw.write(inputLine); outw.close(); File sample_coords = new File(\"sample_coords.txt\"); sample_coords.delete(); File sp_coords = new File(\"sp_coords.txt\"); sp_coords.delete(); try { System.out.println(\"Running python script...\"); System.out.println(\"Command: \" + \"python l19test.py \" + \"\\\"\" + dist_metric + \"\\\"\"); Process pr = Runtime.getRuntime().exec(\"python l19test.py \" + dist_metric); BufferedReader br = new BufferedReader(new InputStreamReader(pr.getErrorStream())); String line; while ((line = br.readLine()) != null) { System.out.println(line); } int exitVal = pr.waitFor(); System.out.println(\"Process Exit Value: \" + exitVal); System.out.println(\"done.\"); } catch (Exception e) { System.out.println(\"Unable to run python script for PCoA analysis\"); } File myFile = new File(\"sp_coords.txt\"); byte[] mybytearray = new byte[(new Long(myFile.length())).intValue()]; FileInputStream fis = new FileInputStream(myFile); System.out.println(\".\"); System.out.println(myFile.length()); out.writeInt((int) myFile.length()); for (int i = 0; i < myFile.length(); i++) { out.writeByte(fis.read()); } myFile = new File(\"sample_coords.txt\"); mybytearray = new byte[(int) myFile.length()]; fis = new FileInputStream(myFile); fis.read(mybytearray); System.out.println(\".\"); System.out.println(myFile.length()); out.writeInt((int) myFile.length()); out.write(mybytearray); myFile = new File(\"evals.txt\"); mybytearray = new byte[(new Long(myFile.length())).intValue()]; fis = new FileInputStream(myFile); fis.read(mybytearray); System.out.println(\".\"); System.out.println(myFile.length()); out.writeInt((int) myFile.length()); out.write(mybytearray); out.flush(); out.close(); in.close(); clientSocket.close(); serverSocket.close(); }. \n Code2: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(File sourceFile, File destinationFile) throws IOException { FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel(); FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel(); sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel); sourceFileChannel.close(); destinationFileChannel.close(); }. \n Code2: public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException { HttpURLConnection con = null; InputStream is = null; try { URL u = new URL(url); if (url.startsWith(\"file://\")) { is = new BufferedInputStream(u.openStream()); } else { Proxy proxy; if (proxyHost != null) { proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)); } else { proxy = Proxy.NO_PROXY; } con = (HttpURLConnection) u.openConnection(proxy); con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\"); con.addRequestProperty(\"Accept-Charset\", \"UTF-8\"); con.addRequestProperty(\"Accept-Language\", \"en-US,en\"); con.addRequestProperty(\"Accept\", \"text/html,image/*\"); con.setDoInput(true); con.setDoOutput(false); con.connect(); is = new BufferedInputStream(con.getInputStream()); } ByteArrayOutputStream baos = new ByteArrayOutputStream(); IOUtils.",
        "ground_truth": "YES",
        "predict": "copy(is, baos); return baos.toByteArray(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws IOException { File outFile = new File(\"data.txt\"); outFile.delete(); copy(new File(\"data.txt\"), outFile); }. \n Code2: public static void main(String[] args) throws IOException { File outFile = new File(\"data.txt\"); outFile.delete(); fetchURLData(\"http://www.google.com\", null, -1); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws IOException { File outFile = new File(\"data.txt\"); outFile.delete(); fetchURLData(\"http://"
    },
    {
        "ID": 655,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String generateSig(Map<String, String> params, String secret) { SortedSet<String> keys = new TreeSet<String>(params.keySet()); keys.remove(FacebookParam.SIGNATURE.toString()); String str = \"\"; for (String key : keys) { str += key + \"=\" + params.get(key); } str += secret; try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(str.getBytes(\"UTF-8\")); StringBuilder result = new StringBuilder(); for (byte b : md.digest()) { result.append(Integer.toHexString((b & 0xf0) >>> 4)); result.append(Integer.toHexString(b & 0x0f)); } return result.toString(); } catch (Exception e) { throw new RuntimeException(e); } }. \n Code2: private void readParameterTable() { if (this.parameters != null) return; parameters = new GribPDSParameter[NPARAMETERS]; int center; int subcenter; int number; try { BufferedReader br; if (filename != null && filename.length() > 0) { GribPDSParamTable tab = (GribPDSParamTable) fileTabMap.get(filename); if (tab != null) { this.parameters = tab.parameters; return; } } if (url != null) { InputStream is = url.openStream(); InputStreamReader isr = new InputStreamReader(is); br = new BufferedReader(isr); } else { br = new BufferedReader(new FileReader(\"tables\\\\\" + filename)); } String line = br.readLine(); String[] tableDefArr = SmartStringArray.split(\":\", line); center = Integer.parseInt(tableDefArr[1].trim()); subcenter = Integer.parseInt(tableDefArr[2].trim()); number = Integer.parseInt(tableDefArr[3].trim()); while ((line = br.readLine()) != null) { line = line.trim(); if (line.length() == 0 || line.startsWith(\"//\")) continue; GribPDSParameter parameter = new GribPDSParameter(); tableDefArr = SmartStringArray.split(\":\", line); parameter.number = Integer.parseInt(tableDefArr[0].trim()); parameter.name = tableDefArr[1].trim(); if (tableDefArr[2].indexOf('[') == -1) { parameter.description = parameter.unit = tableDefArr[2].trim(); } else { String[] arr2 = SmartStringArray.split(\"[\", tableDefArr[2]); parameter.description = arr2[0].trim(); parameter.unit = arr2[1].substring(0, arr2[1].lastIndexOf(']')).trim(); } if (!this.setParameter(parameter)) { System.err.println(\"Warning, bad parameter ignored (\" + filename + \"): \" + parameter.toString()); } } if (filename != null && filename.length() > 0) { GribPDSParamTable loadedTable = new GribPDSParamTable(filename, center, subcenter, number, this.parameters); fileTabMap.put(filename, loadedTable); } } catch (IOException ioError) { System.err.println(\"An error occurred in GribPDSParamTable while \" + \"trying to open the parameter table \" + filename + \" : \" + ioError); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL().toString()); } else if (item.getType() == Type.ANY_URI) { LOG.debug(\"Streaming xs:anyURI\"); String url = item.getStringValue(); if (url.startsWith(\"/\")) { url = \"xmldb:exist://\" + url; } InputStream is = new URL(url).openStream(); streamSource.setInputStream(is); streamSource.setSystemId(url); } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) { LOG.debug(\"Streaming element or document node\"); if (item instanceof NodeProxy) { NodeProxy np = (NodeProxy) item; String url = \"xmldb:exist://\" + np.getDocument().getBaseURI(); LOG.debug(\"Document detected, adding URL \" + url); streamSource.setSystemId(url); } Serializer serializer = context.getBroker().newSerializer(); NodeValue node = (NodeValue) item; InputStream is = new NodeInputStream(serializer, node); streamSource.setInputStream(is); } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) { LOG.debug(\"Streaming base64 binary\"); BinaryValue binary = (BinaryValue) item; byte[] data = (byte[]) binary.toJavaObject(byte[].class); InputStream is = new ByteArrayInputStream(data); streamSource.setInputStream(is); if (item instanceof Base64BinaryDocument) { Base64BinaryDocument b64doc = (Base64BinaryDocument) item; String url = \"xmldb:exist://\" + b64doc.getUrl(); LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url); streamSource.setSystemId(url); } } else { LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType())); throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType())); } return streamSource; }. \n Code2: public static Model downloadModel(String url) { Model model = ModelFactory.createDefaultModel(); try { URLConnection connection = new URL(url).openConnection(); if (connection instanceof HttpURLConnection) { HttpURLConnection httpConnection = (HttpURLConnection) connection; httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\"); httpConnection.setRequestProperty(\"Accept-Language\",",
        "ground_truth": "NO",
        "predict": " \"en-US,en;q=0.5\"); httpConnection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0\"); httpConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\"); httpConnection.setRequestProperty(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"); httpConnection.setRequestProperty(\"Keep-Alive\", \"300\"); httpConnection.setRequestProperty(\"Connection\", \"keep-alive\"); httpConnection.setRequestMethod(\"GET\"); httpConnection.connect(); } } catch (IOException ioError) { LOG.error(\"An error occurred while downloading the model \" + url + \" : \" + ioError); } return model; }. \n Response: YES. \n Instruction: Is there a col"
    },
    {
        "ID": 660,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static Map<String, File> loadServiceCache() { ArrayList<String> preferredOrder = new ArrayList<String>(); HashMap<String, File> serviceFileMapping = new HashMap<String, File>(); File file = new File(IsqlToolkit.getBaseDirectory(), CACHE_FILE); if (!file.exists()) { return serviceFileMapping; } if (file.canRead()) { FileReader fileReader = null; try { fileReader = new FileReader(file); BufferedReader lineReader = new BufferedReader(fileReader); while (lineReader.ready()) { String data = lineReader.readLine(); if (data.charAt(0) == '#') { continue; } int idx0 = 0; int idx1 = data.indexOf(SERVICE_FIELD_SEPERATOR); String name = StringUtilities.decodeASCII(data.substring(idx0, idx1)); String uri = StringUtilities.decodeASCII(data.substring(idx1 + 1)); if (name.equalsIgnoreCase(KEY_SERVICE_LIST)) { StringTokenizer st = new StringTokenizer(uri, SERVICE_SEPERATOR); while (st.hasMoreTokens()) { String serviceName = st.nextToken(); preferredOrder.add(serviceName.toLowerCase().trim()); } continue; } try { URL url = new URL(uri); File serviceFile = new File(url.getFile()); if (serviceFile.isDirectory()) { logger.warn(messages.format(\"compatability_kit.service_mapped_to_directory\", name, uri)); continue; } else if (!serviceFile.canRead()) { logger.warn(messages.format(\"compatability_kit.service_not_readable\", name, uri)); continue; } else if (!serviceFile.exists()) { logger.warn(messages.format(\"compatability_kit.service_does_not_exist\", name, uri)); continue; } String bindName = name.toLowerCase().trim(); InputStream inputStream = null; try { inputStream = url.openStream(); InputSource inputSource = new InputSource(inputStream); bindName = ServiceDigester.parseService(inputSource, IsqlToolkit.getSharedEntityResolver()).getName(); } catch (Exception error) { continue; } if (serviceFileMapping.put(bindName, serviceFile) != null) { logger.warn(messages.format(\"compatability_kit.service_duplicate_name_error\", name, uri)); } } catch (MalformedURLException e) { logger.error(messages.format(\"compatability_kit.service_uri_error\", name, uri), e); } } } catch (IOException ioe) { logger.error(\"compatability_kit.service_generic_error\", ioe); } finally { if (fileReader != null) { try { fileReader.close(); } catch (Throwable ignored) { } } } } return serviceFileMapping; }. \n Code2: protected PersistenceUnitInfo getPersistenceUnitInfo() { if (this.persistenceUnitInfo == null) { this.persistenceUnitInfo = new PersistenceUnitInfo() { private List<ClassTransformer> transformers; private List<String> managedClasses; private List<String> mappingFileNames; private ClassLoader classLoader; public String getPersistenceUnitName() { return \"jomc-standalone\"; } public String getPersistenceProviderClassName() { return getPersistenceProvider().getClass().getName(); } public PersistenceUnitTransactionType getTransactionType() { return PersistenceUnitTransactionType.JTA; } public DataSource getJtaDataSource() { try { return (DataSource) getContext().lookup(getEnvironment().getJtaDataSourceJndiName()); } catch (final NamingException e) { getLogger().fatal(e); throw new RuntimeException(e); } } public DataSource getNonJtaDataSource() { return null; } public List<String> getMappingFileNames() { try { if (this.mappingFileNames == null) { this.mappingFileNames = new LinkedList<String>(); final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); factory.setValidating(false); final DocumentBuilder documentBuilder = factory.newDocumentBuilder(); for (final Enumeration<URL> e = this.getNewTempClassLoader().getResources(\"META-INF/persistence.xml\"); e.hasMoreElements(); ) { final URL url = e.nextElement(); final InputStream in = url.openStream(); final Document doc = documentBuilder.parse(in); in.close(); final NodeList persistenceUnits = doc.getElementsByTagNameNS(PERSISTENCE_NS, \"persistence-unit\"); for (int i = persistenceUnits.getLength() - 1; i >= 0; i--) { final Element persistenceUnit = (Element) persistenceUnits.item(i); final NodeList mappingFiles = persistenceUnit.getElementsByTagNameNS(PERSISTENCE_NS, \"mapping-file\"); for (int j = mappingFiles.getLength() - 1; j >= 0; j--) { final Element mappingFile = (Element) mappingFiles.item(j); this.mappingFileNames.add(mappingFile.getFirstChild().getNodeValue()); } } } } return this.mappingFileNames; } catch (final SAXException e) { getLogger().fatal(e); throw new RuntimeException(e); } catch (final IOException e) { getLogger().fatal(e); throw new RuntimeException(e); } catch (final ParserConfigurationException e) { getLogger().fatal(e); throw new RuntimeException(e); } } public List<URL> getJarFileUrls() { try { final List<URL> jarFileUrls = new LinkedList<URL>(); for (final Enumeration<URL> unitUrls = this.getClassLoader().getResources(\"META-INF/persistence.xml\"); unitUrls.hasMoreElements(); ) { final URL unitUrl = unitUrls.nextElement(); final String externalForm = unitUrl.toExternalForm(); final String jarUrl = externalForm.substring(0, externalForm.indexOf(\"META-INF\")); jarFileUrls.add(new URL(jarUrl)); } return jarFileUrls; } catch (final IOException e) { getLogger().fatal(e); throw new RuntimeException(e.getMessage(), e); } } public URL getPersistenceUnitRootUrl() { return getEnvironment().getJpaRootUrl(); } public List<String> getManagedClassNames() { try { if (this.managedClasses == null) { this.managedClasses = new LinkedList<String>(); final DocumentBuilder",
        "ground_truth": "NO",
        "predict": "Factory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); factory.setValidating(false); final DocumentBuilder documentBuilder = factory.newDocumentBuilder(); for (final Enumeration<URL> e = this.getNewTempClassLoader().getResources(\"META-INF/persistence.xml\"); e.hasMoreElements(); ) { final URL url = e.nextElement(); final InputStream in = url.openStream(); final Document doc = documentBuilder.parse(in); in.close(); final NodeList persistenceUnits = doc.getElementsByTagNameNS(PERSISTENCE_NS, \"persistence-unit\"); for (int i = persistenceUnits.getLength() - 1; i >= 0; i--) { final Element persistenceUnit = (Element) persistenceUnits.item(i); final NodeList managedClasses = persistenceUnit.getElementsByTagNameNS(PERSISTENCE_NS, \"class\"); for (int"
    },
    {
        "ID": 664,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void Download(String uri) throws MalformedURLException { URL url = new URL(uri); try { bm = BitmapFactory.decodeStream(url.openConnection().getInputStream()); } catch (IOException ex) { bm = getError(); } }. \n Code2: public static void loadMemcachedConfigFromURL(URL url, XMLInputFactory factory, List<MemcachedClientConfig> memcachedClientconfigs, List<MemcachedClientSocketPoolConfig> memcachedClientSocketPoolConfigs, List<MemcachedClientClusterConfig> memcachedClientClusterConfig) { MemcachedClientConfig node = null; MemcachedClientSocketPoolConfig socketnode = null; MemcachedClientClusterConfig clusternode = null; InputStream in = null; XMLEventReader r = null; try { in = url.openStream(); r = factory.createXMLEventReader(in); String servers = null; String weights = null; while (r.hasNext()) { XMLEvent event = r.nextEvent(); if (event.isStartElement()) { StartElement start = event.asStartElement(); String tag = start.getName().getLocalPart(); if (tag.equalsIgnoreCase(\"client\")) { node = new MemcachedClientConfig(); if (start.getAttributeByName(new QName(\"\", \"name\")) != null) node.setName(start.getAttributeByName(new QName(\"\", \"name\")).getValue()); else throw new RuntimeException(\"memcached client name can't not be null!\"); if (start.getAttributeByName(new QName(\"\", \"socketpool\")) != null) node.setSocketPool(start.getAttributeByName(new QName(\"\", \"socketpool\")).getValue()); else throw new RuntimeException(\"memcached client socketpool can't not be null!\"); if (start.getAttributeByName(new QName(\"\", \"compressEnable\")) != null) node.setCompressEnable(Boolean.parseBoolean(start.getAttributeByName(new QName(\"\", \"compressEnable\")).getValue())); else node.setCompressEnable(true); if (start.getAttributeByName(new QName(\"\", \"defaultEncoding\")) != null) node.setDefaultEncoding(start.getAttributeByName(new QName(\"\", \"defaultEncoding\")).getValue()); else node.setDefaultEncoding(\"UTF-8\"); continue; } if (tag.equalsIgnoreCase(\"errorHandler\") && node != null) { event = r.peek(); if (event.isCharacters()) { node.setErrorHandler(event.asCharacters().getData()); r.nextEvent(); } continue; } if (tag.equalsIgnoreCase(\"socketpool\")) { socketnode = new MemcachedClientSocketPoolConfig(); servers = null; weights = null; if (start.getAttributeByName(new QName(\"\", \"name\")) != null) socketnode.setName(start.getAttributeByName(new QName(\"\", \"name\")).getValue()); else throw new RuntimeException(\"memcached client socketpool name can't not be null!\"); if (start.getAttributeByName(new QName(\"\", \"failover\")) != null) socketnode.setFailover(Boolean.parseBoolean(start.getAttributeByName(new QName(\"\", \"failover\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"initConn\")) != null) socketnode.setInitConn(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"initConn\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"minConn\")) != null) socketnode.setMinConn(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"minConn\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"maxConn\")) != null) socketnode.setMaxConn(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"maxConn\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"maintSleep\")) != null) socketnode.setMaintSleep(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"maintSleep\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"nagle\")) != null) socketnode.setNagle(Boolean.parseBoolean(start.getAttributeByName(new QName(\"\", \"nagle\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"socketTO\")) != null) socketnode.setSocketTo(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"socketTO\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"maxIdle\")) != null) socketnode.setMaxIdle(Integer.parseInt(start.getAttributeByName(new QName(\"\", \"maxIdle\")).getValue())); if (start.getAttributeByName(new QName(\"\", \"aliveCheck\")) != null) socketnode.setAliveCheck(Boolean.parseBoolean(start.getAttributeByName(new QName(\"\", \"aliveCheck\")).getValue())); continue; } if (tag.equalsIgnoreCase(\"servers\") && socketnode != null) { event = r.peek(); if (event.isCharacters()) { servers = event.asCharacters().getData(); socketnode.setServers(servers); r.nextEvent(); } continue; } if (tag.equalsIgnoreCase(\"weights\") && socketnode != null) { event = r.peek(); if (event.isCharacters()) { weights = event.asCharacters().getData(); socketnode.setWeights(weights); r.nextEvent(); } continue; } if (tag.equalsIgnoreCase(\"cluster\")) { clusternode = new MemcachedClientClusterConfig(); if (start.getAttributeByName(new QName(\"\", \"name\")) != null) clusternode.setName(start.getAttributeByName(new QName(\"\", \"name\")).getValue()); else throw new RuntimeException(\"memcached cluster name can't not be null!\"); if (start.getAttributeByName(new QName(\"\", \"mode\")) != null) clusternode.setMode(start.getAttributeByName(new QName(\"\", \"mode\")).getValue()); continue; } if (tag.equalsIgnoreCase(\"memCachedClients\") && clusternode != null) { event = r.peek(); if (event.isCharacters()) { String clients = event.asCharacters().getData(); if (clients != null && !clients.equals(\"\")) { clusternode.setMemCachedClients(clients.",
        "ground_truth": "NO",
        "predict": "split(\",\")); } r.nextEvent(); } continue; } } } catch (XMLStreamException ex) { ex.printStackTrace(); } catch (IOException ex) { ex.printStackTrace(); } } }\n"
    },
    {
        "ID": 677,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String act = request.getParameter(\"act\"); if (null == act) { } else if (\"down\".equalsIgnoreCase(act)) { String vest = request.getParameter(\"vest\"); String id = request.getParameter(\"id\"); if (null == vest) { t_attach_Form attach = null; t_attach_QueryMap query = new t_attach_QueryMap(); attach = query.getByID(id); if (null != attach) { String filename = attach.getAttach_name(); String fullname = attach.getAttach_fullname(); response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + filename + \"\"); File file = new File(fullname); if (file.exists()) { java.io.FileInputStream in = new FileInputStream(file); org.apache.commons.io.IOUtils.copy(in, response.getOutputStream()); } } } else if (\"review\".equalsIgnoreCase(vest)) { t_infor_review_QueryMap reviewQuery = new t_infor_review_QueryMap(); t_infor_review_Form review = reviewQuery.getByID(id); String seq = request.getParameter(\"seq\"); String name = null, fullname = null; if (\"1\".equals(seq)) { name = review.getAttachname1(); fullname = review.getAttachfullname1(); } else if (\"2\".equals(seq)) { name = review.getAttachname2(); fullname = review.getAttachfullname2(); } else if (\"3\".equals(seq)) { name = review.getAttachname3(); fullname = review.getAttachfullname3(); } String downTypeStr = DownType.getInst().getDownTypeByFileName(name); logger.debug(\"filename=\" + name + \" downtype=\" + downTypeStr); response.setContentType(downTypeStr); response.addHeader(\"Content-Disposition\", \"attachment;filename=\" + name + \"\"); File file = new File(fullname); if (file.exists()) { java.io.FileInputStream in = new FileInputStream(file); org.apache.commons.io.IOUtils.copy(in, response.getOutputStream()); in.close(); } } } else if (\"upload\".equalsIgnoreCase(act)) { String infoId = request.getParameter(\"inforId\"); logger.debug(\"infoId=\" + infoId); } } catch (Exception e) { } }. \n Code2: public void writeOutput(String directory) throws IOException { File f = new File(directory); int i = 0; if (f.isDirectory()) { for (AppInventorScreen screen : screens.values()) { File screenFile = new File(getScreenFilePath(f.getAbsolutePath(), screen)); screenFile.getParentFile().mkdirs(); screenFile.createNewFile(); FileWriter out = new FileWriter(screenFile); String initial = files.get(i).toString(); Map<String, String> types = screen.getTypes(); String[] lines = initial.split(\"\\n\"); for (String key : types.keySet()) { if (!key.trim().equals(screen.getName().trim())) { String value = types.get(key); boolean varFound = false; boolean importFound = false; for (String line : lines) { if (line.matches(\"^\\\\s*(public|private)\\\\s+\" + value + \"\\\\s+\" + key + \"\\\\s*=.*;$\")) varFound = true; if (line.matches(\"^\\\\s*(public|private)\\\\s+\" + value + \"\\\\s+\" + key + \"\\\\s*;$\")) varFound = true; if (line.matches(\"^\\\\s*import\\\\s+.*\" + value + \"\\\\s*;$\")) importFound = true; } if (!varFound) initial = initial.replaceFirst(\"(?s)(?<=\\\\{\\n)\", \"\\tprivate \" + value + \" \" + key + \";\\n\"); if (!importFound) initial = initial.replaceFirst(\"(?=import)\", \"import com.google.devtools.simple.runtime.components.android.\" + value + \";\\n\"); } } out.write(initial); out.close(); i++; } File manifestFile = new File(getManifestFilePath(f.getAbsolutePath(), manifest)); manifestFile.getParentFile().mkdirs(); manifestFile.createNewFile(); FileWriter out = new FileWriter(manifestFile); out.write(manifest.toString()); out.close(); File projectFile = new File(getProjectFilePath(f.getAbsolutePath(), project)); projectFile.getParentFile().mkdirs(); projectFile.createNewFile(); out = new FileWriter(projectFile); out.write(project.toString()); out.close(); String[] copyResourceFilenames = { \"proguard.cfg\", \"project.properties\", \"libSimpleAndroidRuntime.jar\", \"\\\\.classpath\", \"res/drawable/icon.png\", \"\\\\.settings/org.eclipse.jdt.core.prefs\" }; for (String copyResourceFilename : copyResourceFilenames) { InputStream is = getClass().getResourceAsStream(\"/resources/\" + copyResourceFilename.replace(\"\\\\.\", \"\")); File outputFile = new File(f.getAbsoluteFile() + File.separator + copyResourceFilename.replace(\"\\\\.\", \".\")); outputFile.getParentFile().mkdirs(); OutputStream os = new FileOutputStream(outputFile); byte[] buf = new byte[1024]; int readBytes; if (is == null) System.out.println(\"/resources/\" + copyResourceFilename.replace(\"\\\\.\", \"\")); if (os == null) System.out.println(f.getAbsolutePath() + File.separator + copyResourceFilename.replace(\"\\\\.\", \".\")); while ((readBytes = is.read(buf)) > 0) { os.write(buf, 0, readBytes); } } for (String assetName : assets) { InputStream is = new FileInputStream(new File(assetsDir.getAbsolutePath() + File.separator + assetName)); File outputFile = new File(f.getAbsoluteFile() + File.separator + assetName); outputFile.getParentFile().mkdirs(); OutputStream os = new FileOutputStream(outputFile); byte[] buf = new byte[1024]; int readBytes; while ((readBytes = is.read(buf)) > 0) { os.write(buf, 0, readBytes); } } File assetsOutput = new File(getAssetsFilePath(f.getAbsolutePath())); new File(assetsDir.getAbsoluteFile() + File.separator + \"assets\").rename",
        "ground_truth": "NO",
        "predict": "To(assetsOutput); assetsOutput.renameTo(new File(assetsDir.getAbsoluteFile() + File.separator + \"assets.old\")); assetsOutput.renameTo(new File(assetsDir.getAbsoluteFile() + File.separator + \"assets\")); } } }\n"
    },
    {
        "ID": 697,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (log.isTraceEnabled()) { log.trace(\"doGet(requestURI=\" + request.getRequestURI() + \")\"); } ServletConfig sc = getServletConfig(); String uriPrefix = request.getContextPath() + \"/\" + request.getServletPath(); String resUri = request.getRequestURI().substring(uriPrefix.length()); if (log.isTraceEnabled()) { log.trace(\"Request for resource '\" + resUri + \"'\"); } boolean allowAccess = true; String prefixesSpec = sc.getInitParameter(PARAM_ALLOWED_PREFIXES); if (null != prefixesSpec && prefixesSpec.length() > 0) { String[] prefixes = prefixesSpec.split(\";\"); allowAccess = false; if (log.isTraceEnabled()) { log.trace(\"allowedPrefixes specified; checking access\"); } for (String prefix : prefixes) { if (log.isTraceEnabled()) { log.trace(\"Checking resource URI '\" + resUri + \"' against allowed prefix '\" + prefix + \"'\"); } if (resUri.startsWith(prefix)) { if (log.isTraceEnabled()) { log.trace(\"Found matching prefix for resource URI '\" + resUri + \"': '\" + prefix + \"'\"); } allowAccess = true; break; } } } if (!allowAccess) { if (log.isWarnEnabled()) { log.warn(\"Requested for resource that does not match with\" + \" allowed prefixes: \" + resUri); } response.sendError(HttpServletResponse.SC_FORBIDDEN); return; } String resPrefix = sc.getInitParameter(PARAM_RESOURCE_PREFIX); if (null != resPrefix && resPrefix.length() > 0) { if (log.isTraceEnabled()) { log.trace(\"resourcePrefix specified: \" + resPrefix); } if (resPrefix.endsWith(\"/\")) { resUri = resPrefix + resUri; } else { resUri = resPrefix + \"/\" + resUri; } } resUri = resUri.replaceAll(\"\\\\/\\\\/+\", \"/\"); if (log.isTraceEnabled()) { log.trace(\"Qualified (prefixed) resource URI: \" + resUri); } String baseClassName = sc.getInitParameter(PARAM_BASE_CLASS); if (null == baseClassName || 0 == baseClassName.length()) { if (log.isTraceEnabled()) { log.trace(\"No baseClass initialization parameter specified; using default: \" + ResourceLoaderServlet.class.getName()); } baseClassName = ResourceLoaderServlet.class.getName(); } else { if (log.isTraceEnabled()) { log.trace(\"Using baseClass: \" + baseClassName); } } Class baseClass; try { baseClass = Class.forName(baseClassName); } catch (ClassNotFoundException ex) { throw new ServletException(\"Base class '\" + baseClassName + \"' not found\", ex); } URL resUrl = baseClass.getResource(resUri); if (null != resUrl) { if (log.isTraceEnabled()) { log.trace(\"Sending resource: \" + resUrl); } URLConnection urlc = resUrl.openConnection(); response.setContentType(urlc.getContentType()); response.setContentLength(urlc.getContentLength()); response.setStatus(HttpServletResponse.SC_OK); final byte[] buf = new byte[255]; int r = 0; InputStream in = new BufferedInputStream(urlc.getInputStream()); OutputStream out = new BufferedOutputStream(response.getOutputStream()); do { r = in.read(buf, 0, 255); if (r > 0) { out.write(buf, 0, r); } } while (r > 0); in.close(); out.flush(); out.close(); } else { response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Resource not found\"); } }. \n Code2: public InputStream sendCommandRaw(String command, boolean usePost) throws IOException { try { String fullCommand = prefix + command + fixSuffix(command, suffix); long curGap = System.currentTimeMillis() - lastCommandTime; long delayTime = minimumCommandPeriod - curGap; delay(delayTime); URI uri = new URI(fullCommand); URL url = uri.toURL(); if (trace || traceSends) { System.out.println(\"Sending--> \" + url); } if (logFile != null) { logFile.println(\"Sending--> \" + url); } InputStream is = null; for (int i = 0; i < tryCount; i++) { try { URLConnection urc = url.openConnection(); if (usePost) { if (urc instanceof HttpURLConnection) { ((HttpURLConnection) urc).setRequestMethod(\"POST\"); } } if (getTimeout() != -1) { urc.setReadTimeout(getTimeout()); urc.setConnectTimeout(getTimeout()); } is = new BufferedInputStream(urc.getInputStream()); break; } catch (FileNotFoundException e) { throw e; } catch (IOException e) { System.out.println(name + \" Error: \" + e + \" cmd: \" + command); } } lastCommandTime = System.currentTimeMillis(); if (is == null) { System.out.println(name + \" retry failure cmd: \" + url); throw new IOException(\"Can't send command\"); } return is; } catch (URISyntaxException ex) { throw new IOException(\"bad uri \" + ex); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void copyResource() throws Exception { URL url = getResource(source); InputStream input; if (url != null) { input = url.openStream(); } else if (new File(source).exists()) { input = new FileInputStream(source); } else { throw new Exception(\"Could not load resource: \" + source); } OutputStream output = new FileOutputStream(destinationFile()); int b; while ((b = input.read()) != -1) output.write(b); input.close(); output.close(); }. \n Code2: public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException { int k_blockSize = 1024; int byteCount; char[] buf = new char[k_blockSize]; File ofp = new File(outFile); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp)); zos.setMethod(ZipOutputStream",
        "ground_truth": "YES",
        "predict": ".DEFLATED); zos.setLevel(Deflater.BEST_SPEED); return new BufferedWriter(new OutputStreamWriter(zos, \"UTF-8\")); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { if (log.isTraceEnabled()) { log.trace(\"doPost(requestURI=\" + request.getRequestURI() + \")\"); } String uriPrefix = request.getContextPath() + \"/\" + request.getServletPath(); String resUri = request.getRequestURI().substring(uriPrefix.length()); if (log.isTraceEnabled()) { log.trace(\"Request for resource '\" + resUri + \"'\"); } boolean allowAccess = true; String prefixesSpec = getServ"
    },
    {
        "ID": 716,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public String entryToObject(TupleInput input) { boolean zipped = input.readBoolean(); if (!zipped) { return input.readString(); } int len = input.readInt(); try { byte array[] = new byte[len]; input.read(array); GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(array)); ByteArrayOutputStream out = new ByteArrayOutputStream(); IOUtils.copyTo(in, out); in.close(); out.close(); return new String(out.toByteArray()); } catch (IOException err) { throw new RuntimeException(err); } }. \n Code2: public void checkFilesAndCopyValid(String filename) { downloadResults(); loadResults(); File tmpFolderF = new File(tmpFolder); deleteFileFromTMPFolder(tmpFolderF); ZipReader zr = new ZipReader(); zr.UnzipFile(filename); try { LogManager.getInstance().log(\"Ov\ufffd\ufffduji odevzdan\ufffd soubory a kop\ufffdruji validovan\ufffd:\"); LogManager.getInstance().log(\"\"); JAXBElement<?> element = ElementJAXB.getJAXBElement(); Ppa1VysledkyCviceniType pvct = (Ppa1VysledkyCviceniType) element.getValue(); File zipFolder = new File(tmpFolder).listFiles()[0].listFiles()[0].listFiles()[0]; File[] zipFolderList = zipFolder.listFiles(); for (File studentDirectory : zipFolderList) { if (studentDirectory.isDirectory()) { String osobniCisloZeSlozky = studentDirectory.getName().split(\"-\")[0]; LogManager.getInstance().changeLog(\"Prov\ufffd\ufffdov\ufffdn\ufffd soubor\ufffd studenta s \ufffd\ufffdslem: \" + osobniCisloZeSlozky); List<StudentType> students = (List<StudentType>) pvct.getStudent(); for (StudentType student : students) { if (student.getOsobniCislo().equals(osobniCisloZeSlozky)) { int pzp = student.getDomaciUlohy().getPosledniZpracovanyPokus().getCislo().intValue(); DomaciUlohyType dut = student.getDomaciUlohy(); ChybneOdevzdaneType chot = dut.getChybneOdevzdane(); ObjectFactory of = new ObjectFactory(); File[] pokusyDirectories = studentDirectory.listFiles(); NodeList souboryNL = result.getElementsByTagName(\"soubor\"); int start = souboryNL.getLength() - 1; boolean samostatnaPrace = false; for (int i = (pokusyDirectories.length - 1); i >= 0; i--) { if ((pokusyDirectories[i].isDirectory()) && (pzp < Integer.parseInt(pokusyDirectories[i].getName().split(\"_\")[1].trim()))) { File testedFile = pokusyDirectories[i].listFiles()[0]; if ((testedFile.exists()) && (testedFile.isFile())) { String[] partsOfFilename = testedFile.getName().split(\"_\"); String osobniCisloZeSouboru = \"\", priponaSouboru = \"\"; String[] posledniCastSouboru = null; if (partsOfFilename.length == 4) { posledniCastSouboru = partsOfFilename[3].split(\"[.]\"); osobniCisloZeSouboru = posledniCastSouboru[0]; if (posledniCastSouboru.length <= 1) priponaSouboru = \"\"; else priponaSouboru = posledniCastSouboru[1]; } String samostatnaPraceNazev = Konfigurace.getInstance().getSamostatnaPraceNazev(); List<SouborType> lst = chot.getSoubor(); if (testedFile.getName().startsWith(samostatnaPraceNazev)) { samostatnaPrace = true; } else { samostatnaPrace = false; if (partsOfFilename.length != 4) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"\ufffdpatn\ufffd struktura jm\ufffdna souboru.\"); lst.add(st); continue; } else if (!testedFile.getName().startsWith(\"Ppa1_cv\")) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"\ufffdpatn\ufffd za\ufffd\ufffdtek jm\ufffdna souboru.\"); lst.add(st); continue; } else if (!priponaSouboru.equals(\"java\")) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"\ufffdpatn\ufffd p\ufffd\ufffdpona souboru.\"); lst.add(st); continue; } else if (!osobniCisloZeSouboru.equals(osobniCisloZeSlozky)) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"Nesouhlas\ufffd osobn\ufffd \ufffd\ufffdsla.\"); lst.add(st); continue; } else if (partsOfFilename[3].split(\"[.]\").length > 2) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"V\ufffdce p\ufffd\ufffdpon souboru.\"); lst.add(st); continue; } else { long cisloCviceni, cisloUlohy; try { if (partsOfFilename[1].length() == 4) { String cisloS = partsOfFilename[1].substring(2); long cisloL = Long.parseLong(cisloS); cisloCviceni = cisloL; } else { throw new NumberFormatException(); } } catch (NumberFormatException e) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"Chyb\ufffd (nebo je chybn\ufffd) \ufffd\ufffdslo cvi\ufffden\ufffd\"); lst.add(st); continue; } try { if (partsOfFilename[2].length() > 0) { String cisloS = partsOfFilename[2]; long cisloL = Long.parseLong(",
        "ground_truth": "NO",
        "predict": "cisloS); cisloUlohy = cisloL; } else { throw new NumberFormatException(); } } catch (NumberFormatException e) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"Chyb\ufffd (nebo je chybn\ufffd) \ufffd\ufffdulohy cvi\ufffden\ufffd\"); lst.add(st); continue; } if (cisloCviceni > cisloUlohy) { SouborType st = new SouborType(); st.setJmeno(testedFile.getName()); st.setDuvod(\"Nesouhlas\ufffd cvi\ufffden\ufffd \ufffd\ufffdslo cvi\ufffden\ufffd.\"); lst.add(st); continue; } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }"
    },
    {
        "ID": 724,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void readHTMLFromURL(URL url) throws IOException { InputStream in = url.openStream(); try { readHTMLFromStream(new InputStreamReader(in)); } finally { try { in.close(); } catch (IOException ex) { Logger.getLogger(HTMLTextAreaModel.class.getName()).log(Level.SEVERE, \"Exception while closing InputStream\", ex); } } }. \n Code2: public static void doGet(HttpServletRequest request, HttpServletResponse response, CollOPort colloport, PrintStream out) throws ServletException, IOException { response.addDateHeader(\"Expires\", System.currentTimeMillis() - 86400); String id = request.getParameter(\"id\"); String url_index = request.getParameter(\"url_index\"); int url_i; try { url_i = Integer.parseInt(url_index); } catch (NumberFormatException nfe) { url_i = 0; } Summary summary = colloport.getSummary(id); String filename = request.getPathInfo(); if (filename != null && filename.length() > 0) { filename = filename.substring(1); } String includeURLAll = summary.getIncludeURL(); String includeURLs[] = includeURLAll.split(\" \"); String includeURL = includeURLs[url_i]; if (includeURL != null && includeURL.length() > 0) { if (filename.indexOf(\":\") > 0) { includeURL = \"\"; } else if (filename.startsWith(\"/\")) { includeURL = includeURL.substring(0, includeURL.indexOf(\"/\")); } else if (!includeURL.endsWith(\"/\") && includeURL.indexOf(\".\") > 0) { includeURL = includeURL.substring(0, includeURL.lastIndexOf(\"/\") + 1); } URL url = null; try { url = new URL(includeURL + response.encodeURL(filename)); } catch (MalformedURLException mue) { System.out.println(mue); } URLConnection conn = null; if (url != null) { try { conn = url.openConnection(); } catch (IOException ioe) { System.out.println(ioe); } } if (conn != null) { String contentType = conn.getContentType(); String contentDisposition; if (contentType == null) { contentType = \"application/x-java-serialized-object\"; contentDisposition = \"attachment;filename=\\\"\" + filename + \"\\\"\"; } else { contentDisposition = \"inline;filename=\\\"\" + filename + \"\\\"\"; } response.setHeader(\"content-disposition\", contentDisposition); response.setContentType(contentType); try { InputStream inputStream = conn.getInputStream(); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = inputStream.read(buffer)) >= 0) { response.getOutputStream().write(buffer, 0, bytesRead); } inputStream.close(); } catch (IOException ioe) { response.setContentType(\"text/plain\"); ioe.printStackTrace(out); } if (conn instanceof HttpURLConnection) { ((HttpURLConnection) conn).disconnect(); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static byte[] encrypt(String x) throws Exception { java.security.MessageDigest d = null; d = java.security.MessageDigest.getInstance(\"SHA-1\"); d.reset(); d.update(x.getBytes()); return d.digest(); }. \n Code2: private void insertService(String table, int type) { Connection con = null; log.info(\"\"); log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\"); try { con = DODataSource.getDefaultCon(); con.setAutoCommit(false); Statement stmt = con.createStatement(); Statement stmt2 = con.createStatement(); String serviceUid = UUIDHex.getInstance().generate(); DOBO bo = DOBO.getDOBOByName(table); List props = new ArrayList(); StringBuffer mainSql = null; String name = \"\"; String l10n = \"\"; String prefix = table; String serviceType = \"null\"; Boolean isNew = null; switch(type) { case 1: name = prefix + \"_insert\"; l10n = name; props = bo.retrieveProperties(); mainSql = getInsertSql(props, table); serviceType = \"8\"; isNew = Boolean.TRUE; break; case 2: name = prefix + \"_update\"; l10n = name; props = bo.retrieveProperties(); mainSql = this.getModiSql(props, table); serviceType = \"7\"; isNew = Boolean.FALSE; break; case 3: DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol); if (property == null || property.getColName() == null) { return; } name = prefix + \"_delete\"; l10n = name; props.add(property); mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\"); serviceType = \"5\"; break; case 4: property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol); if (property == null || property.getColName() == null) { return; } name = prefix + \"_browse\"; l10n = name; props.add(property); mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\"); serviceType = \"10\"; break; case 5: serviceType = \"2\"; name = prefix + \"_list\"; l10n = name; mainSql = new StringBuffer(\"select * from \").append(table); } this.setParaLinkBatch(props, stmt2, serviceUid, isNew); StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\"); log.info(\"Servcice's Sql:\" + aSql.toString()); stmt.executeUpdate(aSql.toString()); stmt2.executeBatch(); con.commit(); } catch (SQLException ex) { try { con.",
        "ground_truth": "NO",
        "predict": "rollback(); } catch (SQLException ex1) { } } catch (Exception ex) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static byte[] encrypt(String x) throws Exception { java.security.MessageDigest d = null; d = java.security.MessageDigest.getInstance(\"SHA-1\"); d.reset(); d.update(x.getBytes()); return d.digest(); }. \n Code2: private void setParaLinkBatch(List props, Statement stmt, String serviceUid, Boolean isNew) throws Exception { if (props == null || props.size() == 0) { return; } if (isNew == null) { isNew = Boolean.FALSE; } StringBuffer aSql = new StringBuffer(\"insert into DO_ServicePara(serviceuid,objuid,is"
    },
    {
        "ID": 733,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void readBooklist(String filename) { Reader input = null; try { if (filename.startsWith(\"http:\")) { URL url = new URL(filename); URLConnection conn = url.openConnection(); input = new InputStreamReader(conn.getInputStream()); } else { String fileNameAll = filename; try { fileNameAll = new File(filename).getCanonicalPath(); } catch (IOException e) { fileNameAll = new File(filename).getAbsolutePath(); } input = new FileReader(new File(fileNameAll)); } BufferedReader reader = new BufferedReader(input); String line; Date today = new Date(); while ((line = reader.readLine()) != null) { if (shuttingDown) break; String fields[] = line.split(\"\\\\|\"); Map<String, String> valuesToAdd = new LinkedHashMap<String, String>(); valuesToAdd.put(\"fund_code_facet\", fields[11]); valuesToAdd.put(\"date_received_facet\", fields[0]); DateFormat format = new SimpleDateFormat(\"yyyyMMdd\"); Date dateReceived = format.parse(fields[0], new ParsePosition(0)); if (dateReceived.after(today)) continue; String docID = \"u\" + fields[9]; try { Map<String, Object> docMap = getDocumentMap(docID); if (docMap != null) { addNewDataToRecord(docMap, valuesToAdd); documentCache.put(docID, docMap); if (doUpdate && docMap != null && docMap.size() != 0) { update(docMap); } } } catch (SolrMarcIndexerException e) { if (e.getLevel() == SolrMarcIndexerException.IGNORE) { logger.error(\"Indexing routine says record \" + docID + \" should be ignored\"); } else if (e.getLevel() == SolrMarcIndexerException.DELETE) { logger.error(\"Indexing routine says record \" + docID + \" should be deleted\"); } if (e.getLevel() == SolrMarcIndexerException.EXIT) { logger.error(\"Indexing routine says processing should be terminated by record \" + docID); break; } } } } catch (FileNotFoundException e) { logger.info(e.getMessage()); logger.error(e.getCause()); } catch (IOException e) { logger.info(e.getMessage()); logger.error(e.getCause()); } }. \n Code2: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1 < 0) { continue; } String bundleSymbolicName = line.substring(0, pos1); String bundleName = line.substring(pos1",
        "ground_truth": "NO",
        "predict": " + 1); if (bundleSymbolicName.equals(\"org.apache.felix.bundlerepository\")) { for (BundleInfo bi : list) { if (bi.getSymbolicName().equals(bundleSymbolicName)) { bi.setName(bundleName); break; } } } } } catch (IOException e) { } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1"
    },
    {
        "ID": 758,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void process(String dir) { String[] list = new File(dir).list(); if (list == null) return; int n = list.length; long[] bubblesort = new long[list.length + 1]; if (!statustext) { IJ.log(\"Current Directory is: \" + dir); IJ.log(\" \"); IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick); IJ.log(\" \"); } for (int i = 0; i < n; i++) { IJ.showStatus(i + \"/\" + n); File f = new File(dir + list[i]); if (!f.isDirectory()) { ImagePlus img = new Opener().openImage(dir, list[i]); if (img != null && img.getStackSize() == 1) { if (!scoutengine(img)) return; if (!statustext) { IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase); } int lastDigit = whichcase.length() - 1; while (lastDigit > 0) { if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break; } if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1); bubblesort[i] = Long.parseLong(whichcase); } } } if (statussorta || statussortd || statustext) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (statussorta) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } else { if (bubblesort[i] < bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } } IJ.log(\" \"); for (int i = 0; i < n; i++) { if (!statustext) { IJ.log(list[i] + \" / \" + bubblesort[i]); } else { IJ.log(dir + list[i]); } } } if (open_as_stack || only_images) { boolean sorted = false; while (!sorted) { sorted = true; for (int i = 0; i < n - 1; i++) { if (bubblesort[i] > bubblesort[i + 1]) { long temp = bubblesort[i]; tempp = list[i]; bubblesort[i] = bubblesort[i + 1]; list[i] = list[i + 1]; bubblesort[i + 1] = temp; list[i + 1] = tempp; sorted = false; } } } if (only_images) { Opener o = new Opener(); int counter = 0; IJ.log(\" \"); for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; else { ImagePlus imp = o.openImage(path); counter++; if (imp != null) { IJ.log(counter + \" + \" + path); imp.show(); } else IJ.log(counter + \" - \" + path); } } return; } int width = 0, height = 0, type = 0; ImageStack stack = null; double min = Double.MAX_VALUE; double max = -Double.MAX_VALUE; int k = 0; try { for (int i = 0; i < n; i++) { String path = (dir + list[i]); if (path == null) break; if (list[i].endsWith(\".txt\")) continue; ImagePlus imp = new Opener().openImage(path); if (imp != null && stack == null) { width = imp.getWidth(); height = imp.getHeight(); type = imp.getType(); ColorModel cm = imp.getProcessor().getColorModel(); if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm); } if (stack != null) k = stack.getSize() + 1; IJ.showStatus(k + \"/\" + n); IJ.showProgress((double) k / n); if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else { ImageProcessor ip = imp.getProcessor(); if (grayscale) ip = ip.convertToByte(true); if (halfSize) ip = ip.resize(width / 2, height / 2); if (ip.getMin() < min) min = ip.getMin(); if (ip.getMax() > max) max = ip.getMax(); String label = imp.getTitle(); String info = (String) imp.getProperty(\"Info\"); if (info != null) label += \"\\n\" + info; stack.addSlice(label, ip); } System.gc(); } } catch (OutOfMemoryError e) { IJ.outOfMemory(\"FolderOpener\"); stack.trim(); } if (stack != null && stack.getSize() > 0) { ImagePlus imp2 = new ImagePlus(\"Stack\", stack); if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max); imp2.show(); } IJ.showProgress(1.0); } }. \n Code2: private String encryptPassword(String password) throws NoSuchAlgorithmException { MessageDigest encript = MessageDigest.getInstance(\"MD5\"); encript.update(password.getBytes()); byte[] b = encript.digest(); int size = b.length; StringBuffer h = new StringBuffer(size); for (int i = 0; i < size; i++) { h.append(b[i]); } return h.toString(); }. \n Response: YES. ",
        "ground_truth": "NO",
        "predict": "\n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. \n Response: NO. \n Response: YES. "
    },
    {
        "ID": 759,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static String filtraDoc(HttpServletRequest request, String resource, Repository rep, String template) throws IOException { StringBuilder sb = new StringBuilder(); BufferedReader br = null; int sec = 0; try { URL url = rep.getResource(request, resource); if (url == null) { return \"Documento \" + rep.dir + \"/\" + resource + \" no encontrado\"; } br = new BufferedReader(new InputStreamReader(url.openStream(), rep.encoding)); String line = br.readLine(); while (line != null) { int pos = line.indexOf(\"KAttach(\"); if (pos > -1) { sb.append(attach(request, ++sec, line, pos, template)); } else { line = line.replaceAll(\"%20\", \"-\"); sb.append(new String(line.getBytes(rep.encoding), Config.getMng().getEncoding())).append(\"\\n\"); } line = br.readLine(); } } finally { if (br != null) br.close(); } return sb.toString(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) { if (monitor != null && monitor.isCanceled()) { return; } try { ftpClient = new FTPClient(); ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST))); ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT)); ftpClient.connect(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD))); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (from != null) { FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false); synchedSet.add(ftpHolder); } JobHandler.aquireFTPLock(); for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) { if (monitor != null && monitor.isCanceled()) { JobHandler.releaseFTPLock(); ftpClient.quit(); return; } Thread.yield(); FTPHolder element = (FTPHolder) iter.next(); ft",
        "ground_truth": "NO",
        "predict": "pClient.rename(element.getFrom(), element.getTo()); } } finally { if (ftpClient != null) { ftpClient.disconnect(); } } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void polishOn(IProgressMonitor monitor, String from, String to, String renameTo) { if (monitor != null && monitor.isCanceled()) { return; } try { ftpClient = new FTPClient(); ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST))); ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT)); ftpClient.connect(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace"
    },
    {
        "ID": 763,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static MenuListener openRecentHandler() { MenuListener handler = new MenuListener() { public void menuSelected(final MenuEvent event) { final JMenu menu = (JMenu) event.getSource(); menu.removeAll(); String[] recentURLSpecs = Application.getApp().getRecentURLSpecs(); for (int index = 0; index < recentURLSpecs.length; index++) { String urlSpec = recentURLSpecs[index]; JMenuItem menuItem = new JMenuItem(urlSpec); menu.add(menuItem); menuItem.setAction(openURLAction(urlSpec)); menuItem.setText(urlSpec); try { new java.net.URL(urlSpec).openStream(); } catch (java.io.IOException exception) { menuItem.setEnabled(false); } } menu.addSeparator(); final JMenuItem clearItem = new JMenuItem(\"Clear\"); clearItem.setAction(new AbstractAction() { public void actionPerformed(final ActionEvent event) { Application.getApp().clearRecentItems(); } }); clearItem.setText(\"Clear\"); menu.add(clearItem); } public void menuCanceled(final MenuEvent event) { } public void menuDeselected(final MenuEvent event) { } }; return handler; }. \n Code2: public void add(AddInterceptorChain chain, Entry entry, LDAPConstraints constraints) throws LDAPException { Connection con = (Connection) chain.getRequest().get(JdbcInsert.MYVD_DB_CON + \"LDAPBaseServer\"); if (con == null) { throw new LDAPException(\"Operations Error\", LDAPException.OPERATIONS_ERROR, \"No Database Connection\"); } try { con.setAutoCommit(false); HashMap<String, String> db2ldap = (HashMap<String, String>) chain.getRequest().get(JdbcInsert.MYVD_DB_DB2LDAP + \"LDAPBaseServer\"); PreparedStatement ps = con.prepareStatement(\"INSERT INTO USERS (id,firstname,lastname,username) VALUES (?,?,?,?)\"); ps.setInt(1, 5); ps.setString(2, entry.getEntry().getAttribute(db2ldap.get(\"firstname\")).getStringValue()); ps.setString(3, entry.getEntry().getAttribute(db2ldap.get(\"lastname\")).getStringValue()); ps.setString(4, entry.getEntry().getAttribute(db2ldap.get(\"username\")).getStringValue()); ps.executeUpdate(); ps.close(); ps = con.prepareStatement(\"SELECT id FROM LOCATIONS WHERE name=?\"); PreparedStatement inst = con.prepareStatement(\"INSERT INTO LOCATIONMAP (person,location) VALUES (?,?)\"); LDAPAttribute l = entry.getEntry().getAttribute(db2ldap.get(\"name\")); if (l == null) { con.rollback(); throw new LDAPException(\"Location is required\", LDAPException.OBJECT_CLASS_VIOLATION, \"Location is required\"); } String[] vals = l.getStringValueArray(); for (int i = 0; i < vals.length; i++) { ps.setString(1, vals[i]); ResultSet rs = ps.executeQuery(); if (!rs.next()) { con.rollback(); throw new LDAPException(\"Location \" + vals[i] + \" does not exist\", LDAPException.OBJECT_CLASS_VIOLATION, \"Location \" + vals[i] + \" does not exist\"); } inst.setInt(1, 5); inst.setInt(2, rs.getInt(\"id\")); inst.executeUpdate(); } ps.close(); inst.close(); con.commit(); } catch (SQLException e) { try { con.rollback(); } catch (SQLException e1) { throw new LDAPException(\"Could not add entry or rollback transaction\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } throw new LDAPException(\"Could not add entry\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception { InputSource source = null; InputStream stream = null; if (resolver != null) { try { source = resolver.resolveEntity(null, systemId); } catch (Exception e) { LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\"); LogService.instance().log(LogService.ERROR, e); } } if (source != null) { try { stream = source.getByteStream(); } catch (Exception e) { LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\"); LogService.instance().log(LogService.ERROR, e); } } if (stream == null) { URL url = new URL(systemId); stream = url.openStream(); } return stream; }. \n Code2: @Override protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException { HttpURLConnection connection = null; try { switch(method) { case GET: connection = openConnection(url.concat(\"?\").concat(formEncode(parameters))); connection.setRequestMethod(\"GET\"); connection.connect(); break; case POST: connection = openConnection(url); connection.setRequestMethod(\"POST\"); connection.setDoOutput(true); connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); connection.connect(); final OutputStream out = connection.getOutputStream(); out.write(formEncode(parameters).getBytes()); out.flush(); out.close(); break; } final int statusCode = connection.getResponseCode(); if (statusCode / 100 != 2) { final Error error = parseBody(connection.getErrorStream(), new ErrorHandler()); if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage()); } return parseBody(connection.getInputStream(), handler); } catch (final IOException e) { throw new FoursquareException(e); } catch (final ParserConfigurationException e) { throw new",
        "ground_truth": "NO",
        "predict": " FoursquareException(e); } catch (final SAXException e) { throw new FoursquareException(e); } finally { if (connection != null) connection.disconnect(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception { InputSource source = null; InputStream stream = null; if (resolver != null) { try { source = resolver.resolveEntity(null, systemId); } catch (Exception e) { LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\"); LogService.instance().log(LogService.ERROR, e); } } if (source != null) { try { stream = source.getByteStream(); } catch (Exception e) { LogService."
    },
    {
        "ID": 766,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public synchronized void write() throws IOException { ZipOutputStream jar = new ZipOutputStream(new FileOutputStream(jarPath)); int index = className.lastIndexOf('.'); String packageName = className.substring(0, index); String clazz = className.substring(index + 1); String directory = packageName.replace('.', '/'); ZipEntry dummyClass = new ZipEntry(directory + \"/\" + clazz + \".class\"); jar.putNextEntry(dummyClass); ClassGen classgen = new ClassGen(getClassName(), \"java.lang.Object\", \"<generated>\", Constants.ACC_PUBLIC | Constants.ACC_SUPER, null); byte[] bytes = classgen.getJavaClass().getBytes(); jar.write(bytes); jar.closeEntry(); ZipEntry synthFile = new ZipEntry(directory + \"/synth.xml\"); jar.putNextEntry(synthFile); Comment comment = new Comment(\"Generated by SynthBuilder from L2FProd.com\"); Element root = new Element(\"synth\"); root.addAttribute(new Attribute(\"version\", \"1\")); root.appendChild(comment); Element defaultStyle = new Element(\"style\"); defaultStyle.addAttribute(new Attribute(\"id\", \"default\")); Element defaultFont = new Element(\"font\"); defaultFont.addAttribute(new Attribute(\"name\", \"SansSerif\")); defaultFont.addAttribute(new Attribute(\"size\", \"12\")); defaultStyle.appendChild(defaultFont); Element defaultState = new Element(\"state\"); defaultStyle.appendChild(defaultState); root.appendChild(defaultStyle); Element bind = new Element(\"bind\"); bind.addAttribute(new Attribute(\"style\", \"default\")); bind.addAttribute(new Attribute(\"type\", \"region\")); bind.addAttribute(new Attribute(\"key\", \".*\")); root.appendChild(bind); doc = new Document(root); imagesToCopy = new HashMap(); ComponentStyle[] styles = config.getStyles(); for (ComponentStyle element : styles) { write(element); } Serializer writer = new Serializer(jar); writer.setIndent(2); writer.write(doc); writer.flush(); jar.closeEntry(); for (Iterator iter = imagesToCopy.keySet().iterator(); iter.hasNext(); ) { String element = (String) iter.next(); File pathToImage = (File) imagesToCopy.get(element); ZipEntry image = new ZipEntry(directory + \"/\" + element); jar.putNextEntry(image); FileInputStream input = new FileInputStream(pathToImage); int read = -1; while ((read = input.read()) != -1) { jar.write(read); } input.close(); jar.flush(); jar.closeEntry(); } jar.flush(); jar.close(); }. \n Code2: public void testRegister() throws IOException { User newUser = new User(false, \"testregUser\", \"regUser\"); newUser.setEmail(\"eagle-r@gmx.de\"); newUser.setUniversity(\"uni\"); newUser.setFirstName(\"first\"); newUser.setLastName(\"last\"); User regUser = null; try { regUser = (User) getJdbcTemplate().queryForObject(\"select id, login, password, email, hash, REGISTRATION_DATE, university, FORUM_ID from USER where login = ?\", new Object[] { newUser.getUsername() }, new UserMapper()); } catch (EmptyResultDataAccessException e) { } assertNull(\"This test user already exists! Abort test\", regUser); userServiceRemote.registrate(newUser); setComplete(); endTransaction(); regUser = (User) getJdbcTemplate().queryForObject(\"select id, login, password, email, hash, REGISTRATION_DATE, university, FORUM_ID from USER where login = ?\", new Object[] { newUser.getUsername() }, new UserMapper()); assertNotNull(regUser); assertNotNull(regUser.getId()); assertNotNull(regUser.getHash()); assertFalse(regUser.getHash().isEmpty()); assertEquals(regUser.getLogin(), newUser.getLogin()); assertEquals(regUser.getPassword(), newUser.getPassword()); assertEquals(regUser.getUniversity(), newUser.getUniversity()); assertEquals(regUser.getEmail(), newUser.getEmail()); Integer id = newUser.getId(); getJdbcTemplate().execute(\"DELETE FROM USER_AUTHORITIES WHERE USER_ID =\" + id); getJdbcTemplate().execute(\"DELETE FROM USER WHERE ID = \" + id); StringBuilder urlString = new StringBuilder(userService.getForumUrl()); urlString.append(\"phpBB.php?action=remove\").append(\"&id=\").append(newUser.getForumID()).append(\"&mode=remove\"); logger.debug(\"Connecting to URL: \" + urlString.toString()); URL url = new URL(urlString.toString()); URLConnection con = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); String inputLine; while ((inputLine = in.readLine()) != null) logger.debug(\"Response: \" + inputLine); in.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { String key = getKey(); synchronized (this.lauchedHTTPRequests) { if (this.lauchedHTTPRequests.contains(key)) return; this.lauchedHTTPRequests.add(key); } String st = this.dataSource.getTileURL(this.x, this.y, this.z); URL url; try { url = new URL(st); } catch (MalformedURLException e1) { logger.warning(\"Error in URL: \" + st); return; } String geoJSON = \"\"; try { InputStream is; if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else { logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol()); return; } BufferedReader in = new BufferedReader(new InputStreamReader(is)); String line; while ((line = in.readLine()) != null) geoJSON += line; in.close(); } catch (FileNotFoundException e) { return; } catch (IOException e) { e.printStackTrace(); return; } VectorTile tile = new VectorTile(geoJSON, x, y, z); Geometry[] geoms = new Geometry[tile.getPieces().size()]; int i = 0; for (MfGe",
        "ground_truth": "NO",
        "predict": "ometry piece : tile.getPieces()) { geoms[i++] = piece.getGeometry(); } VectorTile.Tile tile2 = new VectorTile.Tile(geoms, tile.getBounds()); VectorTile.Tile tile3 = tile2.rotate(90); VectorTile.Tile tile4 = tile3.rotate(180); VectorTile.Tile tile5 = tile4.rotate(270); VectorTile.Tile tile6 = tile5.rotate(360); VectorTile.Tile tile7 = tile6.rotate(0); VectorTile.Tile tile8 = tile7.rotate(180); VectorTile.Tile tile9 = tile8.rotate(90); VectorTile.Tile tile10 = tile9.rotate(270); VectorTile.Tile tile11 = tile10.rotate(360); VectorTile.Tile tile12 = tile11.rotate(0); VectorTile.Tile tile13 = tile12.rotate(180); VectorTile.Tile tile"
    },
    {
        "ID": 769,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void initialize(IProgressMonitor monitor) throws JETException { IProgressMonitor progressMonitor = monitor; progressMonitor.beginTask(\"\", 10); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_GeneratingJETEmitterFor_message\", new Object[] { getTemplateURI() })); final IWorkspace workspace = ResourcesPlugin.getWorkspace(); IJavaModel javaModel = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()); try { final JETCompiler jetCompiler = getTemplateURIPath() == null ? new MyBaseJETCompiler(getTemplateURI(), getEncoding(), getClassLoader()) : new MyBaseJETCompiler(getTemplateURIPath(), getTemplateURI(), getEncoding(), getClassLoader()); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETParsing_message\", new Object[] { jetCompiler.getResolvedTemplateURI() })); jetCompiler.parse(); progressMonitor.worked(1); String packageName = jetCompiler.getSkeleton().getPackageName(); if (getTemplateURIPath() != null) { URI templateURI = URI.createURI(getTemplateURIPath()[0]); URLClassLoader theClassLoader = null; if (templateURI.isPlatformResource()) { IProject project = workspace.getRoot().getProject(templateURI.segment(1)); if (JETNature.getRuntime(project) != null) { List<URL> urls = new ArrayList<URL>(); IJavaProject javaProject = JavaCore.create(project); urls.add(new File(project.getLocation() + \"/\" + javaProject.getOutputLocation().removeFirstSegments(1) + \"/\").toURI().toURL()); for (IClasspathEntry classpathEntry : javaProject.getResolvedClasspath(true)) { if (classpathEntry.getEntryKind() == IClasspathEntry.CPE_PROJECT) { IPath projectPath = classpathEntry.getPath(); IProject otherProject = workspace.getRoot().getProject(projectPath.segment(0)); IJavaProject otherJavaProject = JavaCore.create(otherProject); urls.add(new File(otherProject.getLocation() + \"/\" + otherJavaProject.getOutputLocation().removeFirstSegments(1) + \"/\").toURI().toURL()); } } theClassLoader = new URLClassLoader(urls.toArray(new URL[0])) { @Override public Class<?> loadClass(String className) throws ClassNotFoundException { try { return super.loadClass(className); } catch (ClassNotFoundException classNotFoundException) { return getClassLoader().loadClass(className); } } }; } } else if (templateURI.isPlatformPlugin()) { final Bundle bundle = Platform.getBundle(templateURI.segment(1)); if (bundle != null) { theClassLoader = new URLClassLoader(new URL[0], getClassLoader()) { @Override public Class<?> loadClass(String className) throws ClassNotFoundException { try { return bundle.loadClass(className); } catch (ClassNotFoundException classNotFoundException) { return super.loadClass(className); } } }; } } if (theClassLoader != null) { String className = (packageName.length() == 0 ? \"\" : packageName + \".\") + jetCompiler.getSkeleton().getClassName(); if (className.endsWith(\"_\")) { className = className.substring(0, className.length() - 1); } try { Class<?> theClass = theClassLoader.loadClass(className); Class<?> theOtherClass = null; try { theOtherClass = getClassLoader().loadClass(className); } catch (ClassNotFoundException exception) { } if (theClass != theOtherClass) { String methodName = jetCompiler.getSkeleton().getMethodName(); Method[] methods = theClass.getDeclaredMethods(); for (int i = 0; i < methods.length; ++i) { if (methods[i].getName().equals(methodName)) { jetEmitter.setMethod(methods[i]); break; } } return; } } catch (ClassNotFoundException exception) { } } } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); jetCompiler.generate(outputStream); final InputStream contents = new ByteArrayInputStream(outputStream.toByteArray()); if (!javaModel.isOpen()) { javaModel.open(new SubProgressMonitor(progressMonitor, 1)); } else { progressMonitor.worked(1); } final IProject project = workspace.getRoot().getProject(jetEmitter.getProjectName()); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETPreparingProject_message\", new Object[] { project.getName() })); IJavaProject javaProject; if (!project.exists()) { progressMonitor.subTask(\"JET creating project \" + project.getName()); project.create(new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETCreatingProject_message\", new Object[] { project.getName() })); IProjectDescription description = workspace.newProjectDescription(project.getName()); description.setNatureIds(new String[] { JavaCore.NATURE_ID }); description.setLocation(null); project.open(new SubProgressMonitor(progressMonitor, 1)); project.setDescription(description, new SubProgressMonitor(progressMonitor, 1)); } else { project.open(new SubProgressMonitor(progressMonitor, 5)); IProjectDescription description = project.getDescription(); description.setNatureIds(new String[] { JavaCore.NATURE_ID }); project.setDescription(description, new SubProgressMonitor(progressMonitor, 1)); } javaProject = JavaCore.create(project); List<IClasspathEntry> classpath = new UniqueEList<IClasspathEntry>(Arrays.asList(javaProject.getRawClasspath())); for (int i = 0, len = classpath.size(); i < len; i++) { IClasspathEntry entry = classpath.get(i); if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE && (\"/\" + project.getName()).equals(entry.getPath().toString())) { classpath.remove(i); } } progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETInitializingProject_message\", new Object[] { project.getName() })); IClasspathEntry classpathEntry = JavaCore.newSourceEntry(new Path(\"/\" + project.getName() + \"/src\")); IClasspathEntry jreClasspathEntry = JavaCore.newContainerEntry(new Path(\"org.eclipse.jdt.launching.JRE_CONTAINER\")); classpath.add(classpathEntry); classpath.add",
        "ground_truth": "NO",
        "predict": "(jreClasspathEntry); javaProject.setRawClasspath(classpath.toArray(new IClasspathEntry[0]), new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETConfiguringProject_message\", new Object[] { project.getName() })); javaProject.setOutputLocation(new Path(\"/\" + project.getName() + \"/bin\"), new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETConfiguringProject_message\", new Object[] { project.getName() })); javaProject.setRawClasspath(new IClasspathEntry[] { classpathEntry }, new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETConfiguringProject_message\", new Object[] { project.getName() })); javaProject."
    },
    {
        "ID": 771,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void main(String[] args) { try { File f = new File(\"test.txt\"); if (f.exists()) { throw new IOException(f + \" already exists. I don't want to overwrite it.\"); } StraightStreamReader in; char[] cbuf = new char[0x1000]; int read; int totRead; FileOutputStream out = new FileOutputStream(f); for (int i = 0x00; i < 0x100; i++) { out.write(i); } out.close(); in = new StraightStreamReader(new FileInputStream(f)); for (int i = 0x00; i < 0x100; i++) { read = in.read(); if (read != i) { System.err.println(\"Error: \" + i + \" read as \" + read); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = in.read(cbuf); if (totRead != 0x100) { System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); in = new StraightStreamReader(new FileInputStream(f)); totRead = 0; while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) { totRead += read; } if (totRead != 0x100) { System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead)); } for (int i = 0x00; i < totRead; i++) { if (cbuf[i + 0x123] != i) { System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]); } } in.close(); f.delete(); } catch (IOException x) { System.err.println(x.getMessage()); } }. \n Code2: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); conn.setRequestProperty(\"Connection\", \"close\"); if (userPassword != null) { conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes())); } InputStream is = null; if (conn.getResponseCode() == 200) { is = conn.getInputStream(); } else { is = conn.getErrorStream(); InputStreamReader isr = new InputStreamReader(is); StringWriter sw = new StringWriter(); char[] buf = new char[200]; int read = 0; while (read != -1) { read = isr.read(buf); sw.write(buf); } throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString()); } File file = new File(tmpDeployDir, new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString()); OutputStream fos = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copyStream(fos, is); fos.close(); is.close(); filePath = file.getPath(); } catch (WiseConnectionException wce) { throw wce; } catch (Exception e) { throw new WiseConnectionException(\"Wsdl download failed!\", e); } return filePath; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: synchronized List<String> getDatasetsList(String surl) { if (datasetsList == null) { datasetsList = new HashMap<String, List<String>>(); } List<String> result = datasetsList.get(surl); if (result == null) { BufferedReader reader = null; try { URL url = new URL(surl + \"?server=list\"); reader = new BufferedReader(new InputStreamReader(url.openStream())); String s = reader.readLine(); ArrayList<String> list = new ArrayList<String>(); while (s != null) { list.add(s); s = reader.readLine(); } datasetsList.put(surl, list); } catch (IOException ex) { Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex); throw new RuntimeException(ex); } finally { try { reader.close(); } catch (IOException ex) { Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level",
        "ground_truth": "NO",
        "predict": ".SEVERE, null, ex); } } } return result; }. \n Code2: synchronized List<String> getDatasetsList(String surl) { return datasetsList.get(surl); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: synchronized List<String> getDatasetsList(String surl) { if (datasetsList == null) { datasetsList = new HashMap<String, List<String>>(); } List<String> result = datasetsList.get(surl); if (result == null) { BufferedReader reader = null; try { URL url = new URL(surl + \"?server=list\"); reader = new BufferedReader(new InputStreamReader(url.openStream())); String s = reader.readLine(); ArrayList<String> list = new ArrayList<String>(); while (s != null) {"
    },
    {
        "ID": 788,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public CasAssembly build() { try { prepareForBuild(); File casWorkingDirectory = casFile.getParentFile(); DefaultCasFileReadIndexToContigLookup read2contigMap = new DefaultCasFileReadIndexToContigLookup(); AbstractDefaultCasFileLookup readIdLookup = new DefaultReadCasFileLookup(casWorkingDirectory); CasParser.parseOnlyMetaData(casFile, MultipleWrapper.createMultipleWrapper(CasFileVisitor.class, read2contigMap, readIdLookup)); ReadWriteDirectoryFileServer consedOut = DirectoryFileServer.createReadWriteDirectoryFileServer(commandLine.getOptionValue(\"o\")); long startTime = DateTimeUtils.currentTimeMillis(); int numberOfCasContigs = read2contigMap.getNumberOfContigs(); for (long i = 0; i < numberOfCasContigs; i++) { File outputDir = consedOut.createNewDir(\"\" + i); Command aCommand = new Command(new File(\"fakeCommand\")); aCommand.setOption(\"-casId\", \"\" + i); aCommand.setOption(\"-cas\", commandLine.getOptionValue(\"cas\")); aCommand.setOption(\"-o\", outputDir.getAbsolutePath()); aCommand.setOption(\"-tempDir\", tempDir.getAbsolutePath()); aCommand.setOption(\"-prefix\", \"temp\"); if (commandLine.hasOption(\"useIllumina\")) { aCommand.addFlag(\"-useIllumina\"); } if (commandLine.hasOption(\"useClosureTrimming\")) { aCommand.addFlag(\"-useClosureTrimming\"); } if (commandLine.hasOption(\"trim\")) { aCommand.setOption(\"-trim\", commandLine.getOptionValue(\"trim\")); } if (commandLine.hasOption(\"trimMap\")) { aCommand.setOption(\"-trimMap\", commandLine.getOptionValue(\"trimMap\")); } if (commandLine.hasOption(\"chromat_dir\")) { aCommand.setOption(\"-chromat_dir\", commandLine.getOptionValue(\"chromat_dir\")); } submitSingleCasAssemblyConversion(aCommand); } waitForAllAssembliesToFinish(); int numContigs = 0; int numReads = 0; for (int i = 0; i < numberOfCasContigs; i++) { File countMap = consedOut.getFile(i + \"/temp.counts\"); Scanner scanner = new Scanner(countMap); if (!scanner.hasNextInt()) { throw new IllegalStateException(\"single assembly conversion # \" + i + \" did not complete\"); } numContigs += scanner.nextInt(); numReads += scanner.nextInt(); scanner.close(); } System.out.println(\"num contigs =\" + numContigs); System.out.println(\"num reads =\" + numReads); consedOut.createNewDir(\"edit_dir\"); consedOut.createNewDir(\"phd_dir\"); String prefix = commandLine.hasOption(\"prefix\") ? commandLine.getOptionValue(\"prefix\") : DEFAULT_PREFIX; OutputStream masterAceOut = new FileOutputStream(consedOut.createNewFile(\"edit_dir/\" + prefix + \".ace.1\")); OutputStream masterPhdOut = new FileOutputStream(consedOut.createNewFile(\"phd_dir/\" + prefix + \".phd.ball\")); OutputStream masterConsensusOut = new FileOutputStream(consedOut.createNewFile(prefix + \".consensus.fasta\")); OutputStream logOut = new FileOutputStream(consedOut.createNewFile(prefix + \".log\")); try { masterAceOut.write(String.format(\"AS %d %d%n\", numContigs, numReads).getBytes()); for (int i = 0; i < numberOfCasContigs; i++) { InputStream aceIn = consedOut.getFileAsStream(i + \"/temp.ace\"); IOUtils.copy(aceIn, masterAceOut); InputStream phdIn = consedOut.getFileAsStream(i + \"/temp.phd\"); IOUtils.copy(phdIn, masterPhdOut); InputStream consensusIn = consedOut.getFileAsStream(i + \"/temp.consensus.fasta\"); IOUtils.copy(consensusIn, masterConsensusOut); IOUtil.closeAndIgnoreErrors(aceIn, phdIn, consensusIn); File tempDir = consedOut.getFile(i + \"\"); IOUtil.recursiveDelete(tempDir); } consedOut.createNewSymLink(\"../phd_dir/\" + prefix + \".phd.ball\", \"edit_dir/phd.ball\"); if (commandLine.hasOption(\"chromat_dir\")) { consedOut.createNewDir(\"chromat_dir\"); File originalChromatDir = new File(commandLine.getOptionValue(\"chromat_dir\")); for (File chromat : originalChromatDir.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".scf\"); } })) { File newChromatFile = consedOut.createNewFile(\"chromat_dir/\" + FilenameUtils.getBaseName(chromat.getName())); FileOutputStream newChromat = new FileOutputStream(newChromatFile); InputStream in = new FileInputStream(chromat); IOUtils.copy(in, newChromat); IOUtil.closeAndIgnoreErrors(in, newChromat); } } System.out.println(\"finished making casAssemblies\"); for (File traceFile : readIdLookup.getFiles()) { final String name = traceFile.getName(); String extension = FilenameUtils.getExtension(name); if (name.contains(\"fastq\")) { if (!consedOut.contains(\"solexa_dir\")) { consedOut.createNewDir(\"solexa_dir\"); } if (consedOut.contains(\"solexa_dir/\" + name)) { IOUtil.delete(consedOut.getFile(\"solexa_dir/\" + name)); } consedOut.createNewSymLink(traceFile.getAbsolutePath(), \"solexa_dir/\" + name); } else if (\"sff\".equals(extension)) { if (!consedOut.contains(\"sff_dir\")) { consedOut.createNewDir(\"sff_dir\"); } if (consedOut.contains(\"sff_dir/\" + name)) { IOUtil.delete(consedOut.getFile(\"sff_dir/\" + name)); } consedOut.createNewSymLink(traceFile.getAbsolutePath(), \"sff_dir/\" + name); } } long endTime = DateTimeUtils.currentTimeMillis(); logOut.write(String.format(\"t",
        "ground_truth": "NO",
        "predict": "ook %d seconds to convert %d casAssemblies%n\", (endTime - startTime) / 1000, numberOfCasContigs).getBytes()); logOut.close(); } catch (IOException e) { throw new RuntimeException(e); } }\n"
    },
    {
        "ID": 789,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void gravaOp(Vector<?> op) { PreparedStatement ps = null; String sql = null; ResultSet rs = null; int seqop = 0; Date dtFabrOP = null; try { sql = \"SELECT MAX(SEQOP) FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { seqop = rs.getInt(1) + 1; } rs.close(); ps.close(); con.commit(); sql = \"SELECT DTFABROP FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, txtSeqOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { dtFabrOP = rs.getDate(1); } rs.close(); ps.close(); con.commit(); sql = \"INSERT INTO PPOP (CODEMP,CODFILIAL,CODOP,SEQOP,CODEMPPD,CODFILIALPD,CODPROD,SEQEST,DTFABROP,\" + \"QTDPREVPRODOP,QTDFINALPRODOP,DTVALIDPDOP,CODEMPLE,CODFILIALLE,CODLOTE,CODEMPTM,CODFILIALTM,CODTIPOMOV,\" + \"CODEMPAX,CODFILIALAX,CODALMOX,CODEMPOPM,CODFILIALOPM,CODOPM,SEQOPM,QTDDISTIOP,QTDSUGPRODOP)\" + \" VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, seqop); ps.setInt(5, Aplicativo.iCodEmp); ps.setInt(6, ListaCampos.getMasterFilial(\"PPESTRUTURA\")); ps.setInt(7, ((Integer) op.elementAt(4)).intValue()); ps.setInt(8, ((Integer) op.elementAt(6)).intValue()); ps.setDate(9, dtFabrOP); ps.setFloat(10, ((BigDecimal) op.elementAt(7)).floatValue()); ps.setFloat(11, 0); ps.setDate(12, (Funcoes.strDateToSqlDate((String) op.elementAt(11)))); ps.setInt(13, Aplicativo.iCodEmp); ps.setInt(14, ListaCampos.getMasterFilial(\"EQLOTE\")); ps.setString(15, ((String) op.elementAt(10))); ps.setInt(16, Aplicativo.iCodEmp); ps.setInt(17, ListaCampos.getMasterFilial(\"EQTIPOMOV\")); ps.setInt(18, buscaTipoMov()); ps.setInt(19, ((Integer) op.elementAt(13)).intValue()); ps.setInt(20, ((Integer) op.elementAt(14)).intValue()); ps.setInt(21, ((Integer) op.elementAt(12)).intValue()); ps.setInt(22, Aplicativo.iCodEmp); ps.setInt(23, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(24, txtCodOP.getVlrInteger().intValue()); ps.setInt(25, txtSeqOP.getVlrInteger().intValue()); ps.setFloat(26, ((BigDecimal) op.elementAt(9)).floatValue()); ps.setFloat(27, ((BigDecimal) op.elementAt(7)).floatValue()); ps.executeUpdate(); ps.close(); con.commit(); geraRMA(seqop); } catch (SQLException e) { Funcoes.mensagemErro(null, \"Erro ao gerar OP's de distribui\ufffd\ufffdo!\\n\" + e.getMessage()); try { con.rollback(); } catch (SQLException eb) { } } }. \n Code2: public void writeConfigurationFile() throws IOException, ComponentException { SystemConfig config = parent.getParentSystem().getConfiguration(); File original = config.getLocation(); File backup = new File(original.getParentFile(), original.getName() + \".\" + System.currentTimeMillis()); FileInputStream in = new FileInputStream(original); FileOutputStream out = new FileOutputStream(backup); byte[] buffer = new byte[2048]; try { int bytesread = 0; while ((bytesread = in.read(buffer)) > 0) { out.write(buffer, 0, bytesread); } } catch (IOException e) { logger.warn(\"Failed to copy backup of configuration file\"); throw e; } finally { in.close(); out.close(); } FileWriter replace = new FileWriter(original); replace.write(config.toFileFormat()); replace.close(); logger.info(\"Re-wrote configuration file \" + original.getPath()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static HttpResponse createUrlResponse(final URL url, final TcpConnection connection) throws IOException, NullPointerException { String fullPath = url.toString(); URLConnection conn = url.openConnection(); InputStream in = conn.getInputStream(); final long length = conn.getContentLength(); if (connection.isDebugEnabled()) connection.logDebug(\"Sending \" + fullPath + \" to \" + connection.getRemoteAddress() + \" (length: \" + length + \").\"); return createInputStreamResponse(in, conn.getContentType(), length, connection);",
        "ground_truth": "NO",
        "predict": " }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static HttpResponse createInputStreamResponse(final InputStream in, final String contentType, final long length, final TcpConnection connection) throws IOException, NullPointerException { final HttpResponse response = new HttpResponse(in, contentType, length); response.setHeader(\"Connection\", \"close\"); return response; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static HttpResponse createInputStreamResponse(final InputStream in, final String contentType, final long length, final TcpConnection connection) throws IOException, NullPointerException { final HttpResponse response = new HttpResponse(in, contentType, length); response.setHeader(\"Connection\", \"close\"); return response; }. \n"
    },
    {
        "ID": 825,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static final void cloneFile(File origin, File target) throws IOException { FileChannel srcChannel = null; FileChannel destChannel = null; try { srcChannel = new FileInputStream(origin).getChannel(); destChannel = new FileOutputStream(target).getChannel(); destChannel.transferFrom(srcChannel, 0, srcChannel.size()); } finally { if (srcChannel != null) srcChannel.close(); if (destChannel != null) destChannel.close(); } }. \n Code2: public Node external_open_url(Node startAt) throws Exception { if (inUse) { throw new InterpreterException(StdErrors.extend(StdErrors.Already_used, \"File already open\")); } inUse = true; startAt.isGoodArgsLength(false, 2); ExtURL url = new ExtURL(startAt.getSubNode(1, Node.TYPE_STRING).getString()); String protocol = url.getProtocol(); String mode = null; Node props = null; Node datas = null; byte[] buffer = null; String old_c = null; String old_r = null; int max_i = startAt.size() - 1; if (startAt.elementAt(max_i).getSymbolicValue_undestructive().isVList()) { props = startAt.getSubNode(max_i--, Node.TYPE_LIST); } int i_ = 2; if (i_ <= max_i) { mode = startAt.getSubNode(i_++, Node.TYPE_STRING).getString().toUpperCase().trim(); if (protocol.equalsIgnoreCase(\"http\") || protocol.equalsIgnoreCase(\"https\")) { if (!(mode.equals(\"GET\") || mode.equals(\"POST\") || mode.equals(\"PUT\"))) { throw new InterpreterException(128010, \"Unsupported request methode\"); } } else if (protocol.equalsIgnoreCase(\"ftp\") || protocol.equalsIgnoreCase(\"file\")) { if (!(mode.equalsIgnoreCase(\"r\") || mode.equalsIgnoreCase(\"w\"))) { throw new InterpreterException(128015, \"Unsupported access methode\"); } } else if (protocol.equalsIgnoreCase(\"jar\") || protocol.equalsIgnoreCase(\"stdin\")) { if (!(mode.equalsIgnoreCase(\"r\"))) { throw new InterpreterException(128015, \"Unsupported access methode\"); } } else if (protocol.equalsIgnoreCase(\"tcp\") || protocol.equalsIgnoreCase(\"ssl+tcp\")) { if (!(mode.equalsIgnoreCase(\"rw\"))) { throw new InterpreterException(128015, \"Unsupported access methode\"); } } else if (protocol.equalsIgnoreCase(\"stdout\") || protocol.equalsIgnoreCase(\"stderr\")) { if (!(mode.equalsIgnoreCase(\"w\"))) { throw new InterpreterException(128015, \"Unsupported access methode\"); } } else { throw new InterpreterException(128011, \"Unsupported protocol\"); } } if (i_ <= max_i) { if (!protocol.equalsIgnoreCase(\"http\") && !protocol.equalsIgnoreCase(\"https\")) { throw new InterpreterException(128016, \"Unsupported request datas\"); } datas = startAt.getSubNode(i_++, Node.TYPE_STRING | Node.TYPE_OBJECT); if (datas.isVObject()) { Object obj = datas.getVObjectExternalInstance(); if (External_Buffer.class.isInstance(obj)) { Buffer bbuffer = ((External_Buffer) obj).getBuffer(); buffer = bbuffer.read_bytes(); } else { throw new InterpreterException(StdErrors.extend(StdErrors.Invalid_parameter, \"Object (\" + obj.getClass().getName() + \") required \" + External_Buffer.class.getName())); } } else { buffer = datas.getString().getBytes(); } } if (datas != null && mode != null && mode.equals(\"GET\")) { throw new InterpreterException(128012, \"GET request with data body\"); } if (props != null && (!protocol.equalsIgnoreCase(\"http\") && !protocol.equalsIgnoreCase(\"https\"))) { throw new InterpreterException(128013, \"Cannot handle header properties in request\"); } try { if (protocol.equalsIgnoreCase(\"file\") && mode != null && mode.equalsIgnoreCase(\"w\")) { File f = new File(url.toURI()); outputStream = new FileOutputStream(f); outputBuffer = new BufferedOutputStream(outputStream); output = new DataOutputStream(outputBuffer); } else if (protocol.equalsIgnoreCase(\"tcp\")) { tcpHost = url.getHost(); tcpPort = url.getPort(); if (tcpPort < 0 || tcpPort > 65535) { throw new InterpreterException(StdErrors.extend(StdErrors.Out_of_range, \"\" + tcpPort)); } socket = new Socket(tcpHost, tcpPort); if (readTimeOut > 0) { socket.setSoTimeout(readTimeOut); } inputStream = socket.getInputStream(); inputBuffer = new BufferedInputStream(inputStream); input = new DataInputStream(inputBuffer); outputStream = socket.getOutputStream(); outputBuffer = new BufferedOutputStream(outputStream); output = new DataOutputStream(outputBuffer); } else if (protocol.equalsIgnoreCase(\"ssl+tcp\")) { tcpHost = url.getHost(); tcpPort = url.getPort(); if (tcpPort < 0 || tcpPort > 65535) { throw new InterpreterException(StdErrors.extend(StdErrors.Out_of_range, \"\" + tcpPort)); } SocketFactory socketFactory = SSLSocketFactory.getDefault(); socket = socketFactory.createSocket(tcpHost, tcpPort); if (readTimeOut > 0) { socket.setSoTimeout(readTimeOut); } inputStream = socket.getInputStream(); inputBuffer = new BufferedInputStream(inputStream); input = new DataInputStream(inputBuffer); outputStream = socket.getOutputStream(); outputBuffer = new BufferedOutputStream(outputStream); output = new DataOutputStream(outputBuffer); } else if (protocol.equalsIgnoreCase(\"stdout\")) { setBufOut(System.out); } else if (protocol.equalsIgnoreCase(\"stderr\")) { setBufOut(System.err); } else if (protocol.equalsIgnoreCase(\"stdin\")) { setBufIn(System.in); } else { urlConnection = url.openConnection(); if (connectTimeOut > 0) { urlConnection.setConnectTimeout(connect",
        "ground_truth": "NO",
        "predict": "TimeOut); } if (readTimeOut > 0) { urlConnection.setReadTimeout(readTimeOut); } } } catch (Exception e) { throw new InterpreterException(128017, \"Unable to open URL \" + url.toString() + \": \" + e.getMessage()); } }\n\n}\n"
    },
    {
        "ID": 826,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testPreparedStatement0009() throws Exception { Statement stmt = con.createStatement(); stmt.executeUpdate(\"create table #t0009 \" + \" (i integer not null, \" + \" s char(10) not null) \"); con.setAutoCommit(false); PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\"); int rowsToAdd = 8; final String theString = \"abcdefghijklmnopqrstuvwxyz\"; int count = 0; for (int i = 1; i <= rowsToAdd; i++) { pstmt.setInt(1, i); pstmt.setString(2, theString.substring(0, i)); count += pstmt.executeUpdate(); } pstmt.close(); assertEquals(count, rowsToAdd); con.rollback(); ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\"); assertNotNull(rs); count = 0; while (rs.next()) { count++; assertEquals(rs.getString(1).trim().length(), rs.getInt(2)); } assertEquals(count, 0); con.commit(); pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\"); rowsToAdd = 6; count = 0; for (int i = 1; i <= rowsToAdd; i++) { pstmt.setInt(1, i); pstmt.setString(2, theString.substring(0, i)); count += pstmt.executeUpdate(); } assertEquals(count, rowsToAdd); con.commit(); pstmt.close(); rs = stmt.executeQuery(\"select s, i from #t0009\"); count = 0; while (rs.next()) { count++; assertEquals(rs.getString(1).trim().length(), rs.getInt(2)); } assertEquals(count, rowsToAdd); con.commit(); stmt.close(); con.setAutoCommit(true); }. \n Code2: public static void retrieveAttachments(RemoteAttachment[] attachments, String id, String projectName, String key, SimpleDateFormat formatter, java.sql.Connection connect) { if (attachments.length != 0) { for (RemoteAttachment attachment : attachments) { attachmentAuthor = attachment.getAuthor(); if (attachment.getCreated() != null) { attachmentCreated = formatter.format(attachment.getCreated().getTime()); } attachmentFileName = attachment.getFilename(); attachmentFileSize = attachment.getFilesize(); attachmentId = attachment.getId(); attachmentMimeType = attachment.getMimetype(); if (attachmentMimeType.startsWith(\"text\")) { URL attachmentUrl; try { attachmentUrl = new URL(\"https://issues.apache.org/jira/secure/attachment/\" + attachmentId + \"/\" + attachmentFileName); urlConnection = (HttpURLConnection) attachmentUrl.openConnection(); urlConnection.connect(); serverCode = urlConnection.getResponseCode(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } if (serverCode == 200) { actual = new File(\"../attachments/\" + projectName + \"/\" + key); if (!actual.exists()) { actual.mkdirs(); } attachmentPath = \"../attachments/\" + projectName + \"/\" + key + \"/\" + attachmentFileName; BufferedInputStream bis; try { bis = new BufferedInputStream(urlConnection.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(attachmentPath)); byte[] b = new byte[1024]; int len = -1; while ((len = bis.read(b)) != -1) { if (len == 1024) { bos.write(b); } else { bos.write(b, 0, len); } } bos.close(); bis.close(); insertAttachment(connect, id); } catch (IOException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer(); for (int j = 0; j < array.length; ++j) { int b = array[j] & 0xFF; if (b < 0x10) sb.append('0'); sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { System.out.println(\"Error:\" + e); } }. \n Code2: private void Submit2URL(URL url) throws Exception { HttpURLConnection urlc = null; try { urlc = (HttpURLConnection) url.openConnection(); urlc.setRequestMethod(\"GET\"); urlc.setDoOutput(true); urlc.setDoInput(true); urlc.setUseCaches(false); urlc.setAllowUserInteraction(false); if (urlc.getResponseCode() != 200) { InputStream in = null; Reader reader = null; try { in = urlc.getInputStream(); reader = new InputStreamReader(in, \"UTF-8\"); int read = 0; char[] buf = new char[1024]; String error = null; while ((read = reader.read(buf)) >= 0) { if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read); } throw new NpsException(error, ErrorHelper.SYS_UNKOWN); } finally { if (reader != null) try { reader.close(); } catch (Exception e1) { } if (in != null) try { in.close(); } catch (Exception e1",
        "ground_truth": "NO",
        "predict": ") { } } } } catch (IOException e) { throw new NpsException(e.getMessage(), ErrorHelper.SYS_UNKOWN); } finally { if (urlc != null) try { urlc.disconnect(); } catch (Exception e) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void Submit2URL(URL url) throws Exception { HttpURLConnection urlc = null; try { urlc = (HttpURLConnection) url.openConnection(); urlc.setRequestMethod(\"GET\"); urlc.setDoOutput(true); urlc.setDoInput(true); urlc.setUseCaches(false); urlc.setAllowUserInteraction(false); if (urlc.getResponseCode() != 200) { InputStream in = null; Reader reader = null; try { in = urlc.getInputStream();"
    },
    {
        "ID": 836,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public final void run() { active = true; String s = findcachedir(); uid = getuid(s); try { File file = new File(s + \"main_file_cache.dat\"); if (file.exists() && file.length() > 0x3200000L) file.delete(); cache_dat = new RandomAccessFile(s + \"main_file_cache.dat\", \"rw\"); for (int j = 0; j < 5; j++) cache_idx[j] = new RandomAccessFile(s + \"main_file_cache.idx\" + j, \"rw\"); } catch (Exception exception) { exception.printStackTrace(); } for (int i = threadliveid; threadliveid == i; ) { if (socketreq != 0) { try { socket = new Socket(socketip, socketreq); } catch (Exception _ex) { socket = null; } socketreq = 0; } else if (threadreq != null) { Thread thread = new Thread(threadreq); thread.setDaemon(true); thread.start(); thread.setPriority(threadreqpri); threadreq = null; } else if (dnsreq != null) { try { dns = InetAddress.getByName(dnsreq).getHostName(); } catch (Exception _ex) { dns = \"unknown\"; } dnsreq = null; } else if (savereq != null) { if (savebuf != null) try { FileOutputStream fileoutputstream = new FileOutputStream(s + savereq); fileoutputstream.write(savebuf, 0, savelen); fileoutputstream.close(); } catch (Exception _ex) { } if (waveplay) { wave = s + savereq; waveplay = false; } if (midiplay) { midi = s + savereq; midiplay = false; } savereq = null; } else if (urlreq != null) { try { urlstream = new DataInputStream((new URL(mainapp.getCodeBase(), urlreq)).openStream()); } catch (Exception _ex) { urlstream = null; } urlreq = null; } try { Thread.sleep(50L); } catch (Exception _ex) { } } }. \n Code2: public static String harvestForUser(Node userNode, String alias, Boolean all) { FTPClient client = new FTPClient(); OutputStream outStream = null; Calendar filterCal = Calendar.getInstance(); filterCal.set(Calendar.DAY_OF_MONTH, filterCal.get(Calendar.DAY_OF_MONTH) - 1); Date aDayAgo = filterCal.getTime(); String outputRecord = \"\"; try { Session session = CustomSystemSession.create(r); client.connect(ftpHostname); client.login(ftpUsername, ftpPassword); FTPFile[] users = client.listFiles(); if (users != null) { for (FTPFile user : users) { String userName = user.getName(); if (alias.equals(userName)) { outputRecord += \"Found account \" + userName + \".\\n\"; client.changeWorkingDirectory(\"/\" + userName + \"/\"); FTPFile[] experiments = client.listFiles(); if (experiments != null && userNode != null) { for (FTPFile experiment : experiments) { String experimentName = experiment.getName(); outputRecord += \"Exploring \" + userName + \"/\" + experimentName + \".\\n\"; client.changeWorkingDirectory(\"/\" + userName + \"/\" + experimentName + \"/\"); FTPFile[] datasets = client.listFiles(); if (datasets != null) { for (FTPFile dataset : datasets) { String datasetName = dataset.getName(); outputRecord += \"Exploring \" + userName + \"/\" + experimentName + \"/\" + datasetName + \".\\n\"; client.changeWorkingDirectory(\"/\" + userName + \"/\" + experimentName + \"/\" + datasetName + \"/\"); Date collectionDate = dataset.getTimestamp().getTime(); if (collectionDate.after(aDayAgo) || all) { FTPFile[] images = client.listFiles(); if (images != null) { for (FTPFile image : images) { outputRecord += processImage(userName, experimentName, datasetName, collectionDate, image, client, userNode, session); } } } } } } } } } } client.logout(); } catch (IOException ioe) { log.info(\"Error communicating with FTP server.\"); log.error(\"Error communicating with FTP server.\", ioe); ioe.printStackTrace(); } catch (RepositoryException ioe) { log.info(\"Error communicating with repository.\"); log.error(\"Error communicating with repository.\", ioe); ioe.printStackTrace(); } finally { IOUtils.closeQuietly(outStream); try { client.disconnect(); } catch (IOException e) { log.error(\"Problem disconnecting from FTP server\", e); } } return outputRecord; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void load(URL url) throws IOException { ResourceLocator locator = null; try { locator = new RelativeResourceLocator(url); } catch (URISyntaxException use) { throw new IllegalArgumentException(\"Bad URL: \" + use); } ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator); InputStream stream = null; try { stream = url.openStream(); if (stream == null) { throw new IOException(\"Failed to load materials file '\" + url + \"'\"); } logger.fine(\"Loading materials from '\" + url + \"'...\"); load(stream); } finally { if (stream != null) stream.close(); ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator); locator = null; } }. \n Code2: public void googleImageSearch(String search, String start) { try { String u = \"http://images.google.com/images?q=\" + search + start; if (u.contains(\" \")) { u = u.replace(\" \", \"+\"); } URL url = new URL(u); HttpURLConnection httpcon = (HttpURLConnection) url.openConnection(); httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\"); BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream())); googleImages.clear(); String text = \"\"; String lin = \"\"; while ((lin = readIn.readLine()) != null) { text += lin; } readIn.close(); if (text.contains(\"\\n\")) { text = text.replace(\"\\n\", \"\"); } String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\"); for (String s : array) { if (s.startsWith(\"http://\") || s.st",
        "ground_truth": "NO",
        "predict": "artsWith(\"https://\")) { googleImages.add(s); } } } catch (IOException ioe) { log.info(\"Error communicating with Google Images.\"); log.error(\"Error communicating with Google Images.\", ioe); ioe.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void load(InputStream stream) throws IOException { logger.fine(\"Loading materials from '\" + stream + \"'...\"); load(stream); }. \n Code2: public void load(InputStream stream) throws IOException { ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, new ResourceLocator(stream)); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void load(File file) throws IOException"
    },
    {
        "ID": 840,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String rename_tag(String sessionid, String originalTag, String newTagName) { String jsonstring = \"\"; try { Log.d(\"current running function name:\", \"rename_tag\"); HttpClient httpclient = new DefaultHttpClient(); HttpPost httppost = new HttpPost(\"https://mt0-app.cloud.cm/rpc/json\"); List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2); nameValuePairs.add(new BasicNameValuePair(\"c\", \"Storage\")); nameValuePairs.add(new BasicNameValuePair(\"m\", \"rename_tag\")); nameValuePairs.add(new BasicNameValuePair(\"new_tag_name\", newTagName)); nameValuePairs.add(new BasicNameValuePair(\"absolute_tag\", originalTag)); httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs)); httppost.setHeader(\"Cookie\", \"PHPSESSID=\" + sessionid); HttpResponse response = httpclient.execute(httppost); jsonstring = EntityUtils.toString(response.getEntity()); Log.d(\"jsonStringReturned:\", jsonstring); return jsonstring; } catch (Exception e) { e.printStackTrace(); } return jsonstring; }. \n Code2: public static void main(String[] args) { if (args.length <= 0) { System.out.println(\" *** SQL script generator and executor ***\"); System.out.println(\" You must specify name of the file with SQL script data\"); System.out.println(\" Fisrt rows of this file must be:\"); System.out.println(\" 1) JDBC driver class for your DBMS\"); System.out.println(\" 2) URL for your database instance\"); System.out.println(\" 3) user in that database (with administrator priviliges)\"); System.out.println(\" 4) password of that user\"); System.out.println(\" Next rows can have: '@' before schema to create,\"); System.out.println(\" '#' before table to create, '&' before table to insert,\"); System.out.println(\" '$' before trigger (inverse 'FK on delete cascade') to create,\"); System.out.println(\" '>' before table to drop, '<' before schema to drop.\"); System.out.println(\" Other rows contain parameters of these actions:\"); System.out.println(\" for & action each parameter is a list of values,\"); System.out.println(\" for @ -//- is # acrion, for # -//- is column/constraint \"); System.out.println(\" definition or $ action. $ syntax to delete from table:\"); System.out.println(\" fullNameOfTable:itsColInWhereClause=matchingColOfThisTable\"); System.out.println(\" '!' before row means that it is a comment.\"); System.out.println(\" If some exception is occured, all script is rolled back.\"); System.out.println(\" If you specify 2nd command line argument - file name too -\"); System.out.println(\" connection will be established but all statements will\"); System.out.println(\" be saved in that output file and not transmitted to DB\"); System.out.println(\" If you specify 3nd command line argument - connect_string -\"); System.out.println(\" connect information will be added to output file\"); System.out.println(\" in the form 'connect user/password@connect_string'\"); System.exit(0); } try { String[] info = new String[4]; BufferedReader reader = new BufferedReader(new FileReader(new File(args[0]))); Writer writer = null; try { for (int i = 0; i < 4; i++) info[i] = reader.readLine(); try { Class.forName(info[0]); Connection connection = DriverManager.getConnection(info[1], info[2], info[3]); SQLScript script = new SQLScript(connection); if (args.length > 1) { writer = new FileWriter(args[1]); if (args.length > 2) writer.write(\"connect \" + info[2] + \"/\" + info[3] + \"@\" + args[2] + script.statementTerminator); } try { System.out.println(script.executeScript(reader, writer) + \" updates has been performed during script execution\"); } catch (SQLException e4) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Script execution error: \" + e4); } connection.close(); } catch (Exception e3) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Connection error: \" + e3); } } catch (IOException e2) { System.out.println(\"Error in file \" + args[0]); } } catch (FileNotFoundException e1) { System.out.println(\"File \" + args[0] + \" not found\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException { try { Connection conn = null; Statement stmt = null; try { conn = fido.util.FidoDataSource.getConnection(); conn.setAutoCommit(false); stmt = conn.createStatement(); if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name); AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable(); prepTable.deleteLinkType(stmt, name); ObjectLinkTable objectLinkTable = new ObjectLinkTable(); objectLinkTable.deleteLinkType(stmt, name); String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\"; stmt.executeUpdate(sql); conn.commit(); } catch (SQLException e) { if (conn != null) conn.rollback(); throw e; } finally { if (stmt != null) stmt.close(); if (conn != null) conn.close(); } } catch (SQLException e) { throw new FidoDatabaseException(e); } }. \n Code2: public InputStream retrieveStream(String url) { HttpGet getRequest = new HttpGet(url); try { HttpResponse getResponse = getClient().execute(getRequest); final int statusCode = getResponse.getStatusLine().getStatusCode(); if (statusCode != HttpStatus.SC_OK) { Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url); return null; } HttpEntity getResponseEntity = getResponse.getEntity(); return getResponseEntity.getContent(); } catch (Exception e) { getRequest.abort(); Log.w(get",
        "ground_truth": "NO",
        "predict": "Class().getSimpleName(), \"Error for URL \" + url, e); return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException { try { Connection conn = null; Statement stmt = null; try { conn = fido.util.FidoDataSource.getConnection(); conn.setAutoCommit(false); stmt = conn.createStatement(); if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name); AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable(); prepTable.deleteLinkType(stmt, name); ObjectLinkTable objectLinkTable = new ObjectLinkTable(); objectLinkTable.deleteLinkType(stmt, name); String sql = \"delete from ClassLinkTypes"
    },
    {
        "ID": 841,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String getURLContent(String urlStr) throws MalformedURLException, IOException { URL url = new URL(urlStr); log.info(\"url: \" + url); URLConnection conn = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream())); StringBuffer buf = new StringBuffer(); String inputLine; while ((inputLine = in.readLine()) != null) { buf.append(inputLine); } in.close(); return buf.toString(); }. \n Code2: public static Set<Municipality> getMunicipios(String pURL) { Set<Municipality> result = new HashSet<Municipality>(); String iniCuerr = \"<cuerr>\"; String finCuerr = \"</cuerr>\"; String iniDesErr = \"<des>\"; String finDesErr = \"</des>\"; String iniMun = \"<muni>\"; String finMun = \"</muni>\"; String iniNomMun = \"<nm>\"; String finNomMun = \"</nm>\"; String iniCarto = \"<carto>\"; String iniCodDelMEH = \"<cd>\"; String finCodDelMEH = \"</cd>\"; String iniCodMunMEH = \"<cmc>\"; String finCodMunMEH = \"</cmc>\"; String iniCodProvINE = \"<cp>\"; String finCodProvINE = \"</cp>\"; String iniCodMunINE = \"<cm>\"; String finCodMunINE = \"</cm>\"; boolean error = false; int ini, fin; try { URL url = new URL(pURL); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream())); String str; Municipality municipio; while ((str = br.readLine()) != null) { if (str.contains(iniCuerr)) { ini = str.indexOf(iniCuerr) + iniCuerr.length(); fin = str.indexOf(finCuerr); if (Integer.parseInt(str.substring(ini, fin)) > 0) error = true; } if (error) { if (str.contains(iniDesErr)) { ini = str.indexOf(iniDesErr) + iniDesErr.length(); fin = str.indexOf(finDesErr); throw (new Exception(str.substring(ini, fin))); } } else { if (str.contains(iniMun)) { municipio = new Municipality(); municipio.setCodemunicipalityine(0); municipio.setCodemunicipalitydgc(0); while ((str = br.readLine()) != null && !str.contains(finMun)) { if (str.contains(iniNomMun)) { ini = str.indexOf(iniNomMun) + iniNomMun.length(); fin = str.indexOf(finNomMun); municipio.setMuniName(str.substring(ini, fin).trim()); } if (str.contains(iniCarto)) { if (str.contains(\"URBANA\")) municipio.setIsurban(true); if (str.contains(\"RUSTICA\")) municipio.setIsrustic(true); } if (str.contains(iniCodDelMEH)) { ini = str.indexOf(iniCodDelMEH) + iniCodDelMEH.length(); fin = str.indexOf(finCodDelMEH); municipio.setCodemunicipalitydgc(municipio.getCodemunicipalitydgc() + Integer.parseInt(str.substring(ini, fin)) * 1000); } if (str.contains(iniCodMunMEH)) { ini = str.indexOf(iniCodMunMEH) + iniCodMunMEH.length(); fin = str.indexOf(finCodMunMEH); municipio.setCodemunicipalitydgc(municipio.getCodemunicipalitydgc() + Integer.parseInt(str.substring(ini, fin))); } if (str.contains(iniCodProvINE)) { ini = str.indexOf(iniCodProvINE) + iniCodProvINE.length(); fin = str.indexOf(finCodProvINE); municipio.setCodemunicipalityine(municipio.getCodemunicipalityine() + Integer.parseInt(str.substring(ini, fin)) * 1000); } if (str.contains(iniCodMunINE)) { ini = str.indexOf(iniCodMunINE) + iniCodMunINE.length(); fin = str.indexOf(finCodMunINE); municipio.setCodemunicipalityine(municipio.getCodemunicipalityine() + Integer.parseInt(str.substring(ini, fin))); } municipio.setDescription(); } result.add(municipio); } } } br.close(); } catch (Exception e) { System.err.println(e); } return result; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void loadDefaultSettings(final String configFileName) { InputStream in = null; OutputStream out = null; try { in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES); out = new FileOutputStream(configFileName); IOUtils.copy(in, out); } catch (final Exception e) { log.warn(\"Unable to pull out the default.\", e); throw new RuntimeException(e); } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } }. \n Code2: public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException { LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\"); assert (file.exists() && file.isFile()); if (targetDirectory.exists() == false) { LOG.debug(\"Creating target directory.\"); if (targetDirectory.mkdirs() == false) { throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\"); } } ZipInputStream zipin = null; try { zipin = new ZipInputStream(new FileInputStream(file)); ZipEntry entry = null; while ((entry = zipin.getNextEntry()) != null) { LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\"); if (entry.isDirectory()) { LOG.debug(\"Skipping directory.\"",
        "ground_truth": "YES",
        "predict": "); } else { File outFile = new File(targetDirectory, entry.getName()); outFile.getParentFile().mkdirs(); outFile.createNewFile(); FileOutputStream out = null; try { out = new FileOutputStream(outFile); IOUtils.copy(zipin, out); } finally { IOUtils.closeQuietly(out); } } } } catch (final Exception e) { throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'!\", e); } finally { IOUtils.closeQuietly(zipin); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { try { loadDefaultSettings(\"config.properties\"); } catch (Exception e) { log."
    },
    {
        "ID": 846,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private boolean parse(Type type, URL url, boolean checkDict) throws Exception { boolean ok = true; Exception ee = null; Element rootElement = null; try { InputStream in = url.openStream(); if (type.equals(Type.XOM)) { new Builder().build(in); } else if (type.equals(Type.CML)) { rootElement = new CMLBuilder().build(in).getRootElement(); } in.close(); } catch (Exception e) { ee = e; } if (ee != null) { logger.severe(\"failed to cmlParse: \" + url + \"\\n..... because: [\" + ee + \"] [\" + ee.getMessage() + \"] in [\" + url + \"]\"); ok = false; } if (ok && checkDict) { ok = checkDict(rootElement); } return ok; }. \n Code2: protected void updateJava2ScriptProject(String prjFolder, String binRelative) { try { File cpFile = new File(prjFolder, \".classpath\"); FileInputStream fis = new FileInputStream(cpFile); String classpath = J2SLaunchingUtil.readAFile(fis); if (classpath != null) { boolean needUpdate = false; if (classpath.indexOf(\"ECLIPSE_SWT\") == -1 && classpath.indexOf(\"SWT_LIBRARY\") == -1 && classpath.indexOf(\"eclipse.swt\") == -1) { int idx = classpath.lastIndexOf(\"<\"); classpath = classpath.substring(0, idx) + \"\\t<classpathentry kind=\\\"var\\\" path=\\\"ECLIPSE_SWT\\\"/>\\r\\n\" + classpath.substring(idx); needUpdate = true; } if (classpath.indexOf(\"AJAX_SWT\") == -1 && classpath.indexOf(\"ajaxswt.jar\") == -1) { int idx = classpath.lastIndexOf(\"<\"); classpath = classpath.substring(0, idx) + \"\\t<classpathentry sourcepath=\\\"AJAX_SWT_SRC\\\" kind=\\\"var\\\" path=\\\"AJAX_SWT\\\"/>\\r\\n\" + classpath.substring(idx); needUpdate = true; } if (classpath.indexOf(\"AJAX_RPC\") == -1 && classpath.indexOf(\"ajaxrpc.jar\") == -1) { int idx = classpath.lastIndexOf(\"<\"); classpath = classpath.substring(0, idx) + \"\\t<classpathentry sourcepath=\\\"AJAX_RPC_SRC\\\" kind=\\\"var\\\" path=\\\"AJAX_RPC\\\"/>\\r\\n\" + classpath.substring(idx); needUpdate = true; } if (classpath.indexOf(\"AJAX_PIPE\") == -1 && classpath.indexOf(\"ajaxpipe.jar\") == -1) { int idx = classpath.lastIndexOf(\"<\"); classpath = classpath.substring(0, idx) + \"\\t<classpathentry sourcepath=\\\"AJAX_PIPE_SRC\\\" kind=\\\"var\\\" path=\\\"AJAX_PIPE\\\"/>\\r\\n\" + classpath.substring(idx); needUpdate = true; } if (needUpdate) { try { FileOutputStream fos = new FileOutputStream(cpFile); fos.write(classpath.getBytes(\"utf-8\")); fos.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } File webinf = new File(prjFolder, \"WEB-INF\"); webinf.mkdir(); new File(webinf, \"classes\").mkdir(); File lib = new File(webinf, \"lib\"); lib.mkdir(); IPath newPath = null; URL starterURL = AjaxPlugin.getDefault().getBundle().getEntry(File.separator); String root = \".\"; try { root = Platform.asLocalURL(starterURL).getFile(); } catch (IOException e1) { e1.printStackTrace(); } newPath = Path.fromPortableString(root + \"/ajaxrpc.jar\"); File rpcFile = new File(newPath.toOSString()); try { FileInputStream is = new FileInputStream(rpcFile); FileOutputStream os = new FileOutputStream(new File(lib, \"ajaxrpc.jar\")); byte[] buf = new byte[1024]; int read = -1; while ((read = is.read(buf)) != -1) { os.write(buf, 0, read); } os.close(); is.close(); } catch (IOException e1) { e1.printStackTrace(); } newPath = Path.fromPortableString(root + \"/ajaxpipe.jar\"); File pipeFile = new File(newPath.toOSString()); try { FileInputStream is = new FileInputStream(pipeFile); FileOutputStream os = new FileOutputStream(new File(lib, \"ajaxpipe.jar\")); byte[] buf = new byte[1024]; int read = -1; while ((read = is.read(buf)) != -1) { os.write(buf, 0, read); } os.close(); is.close(); } catch (IOException e1) { e1.printStackTrace(); } StringBuffer buildxml = new StringBuffer(); buildxml.append(\"<?xml version=\\\"1.0\\\"?>\\r\\n\"); buildxml.append(\"<project name=\\\"java2script.servlet.pack\\\" default=\\\"pack.war\\\" basedir=\\\".\\\">\\r\\n\"); buildxml.append(\" <description>Pack Java2Script Servlet Application</description>\\r\\n\"); buildxml.append(\"\\r\\n\"); String name = new File(prjFolder).getName(); buildxml.append(\" <property name=\\\"java2script.app.name\\\" value=\\\"\" + name + \"\\\"/>\\r\\n\"); buildxml.append(\" <property name=\\\"bin.folder\\\" value=\\\"${basedir}/../\" + binRelative + \"\\\"/>\\r\\n\"); buildxml.append(\"\\r\\n\"); buildxml.append(\" <target name=\\\"pack.war\\\" depends=\\\"pack.jar\\\">\\r\\n\"); buildxml.append(\" <tstamp>\\r\\n\"); buildxml.append(\" <format property=\\\"now\\\" pattern=\\\"yyyy-MM-dd-HH-mm-ss\\\"/>\\r\\n\"); buildxml.append(\" </tstamp>\\r\\n\"); buildxml.append(\" <delete file=\\\"${basedir}/../${java2script.app.name}.war\\\" quiet=\\\"true\\\"/>\\",
        "ground_truth": "NO",
        "predict": "r\\n\"); buildxml.append(\" <jar destfile=\\\"${bin.folder}/${java2script.app.name}.war\\\" basedir=\\\"${basedir}/..\\\"/>\\r\\n\"); buildxml.append(\" </target>\\r\\n\"); buildxml.append(\"\\r\\n\"); buildxml.append(\" <target name=\\\"pack.jar\\\" depends=\\\"pack.war\\\">\\r\\n\"); buildxml.append(\" <tstamp>\\r\\n\"); buildxml.append(\" <format property=\\\"now\\\" pattern=\\\"yyyy-MM-dd-HH-mm-ss\\\"/>\\r\\n\"); buildxml.append(\" </tstamp>\\r\\n\"); buildxml.append(\" <delete file=\\\"${bin.folder}/${java2script.app.name}.jar\\\" quiet=\\\"true\\\"/>\\r\\n\"); buildxml.append(\" <jar destfile=\\\"${bin.folder}/${java2script.app.name"
    },
    {
        "ID": 859,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int delete(BusinessObject o) throws DAOException { int delete = 0; Account acc = (Account) o; try { PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"DELETE_ACCOUNT\")); pst.setInt(1, acc.getId()); delete = pst.executeUpdate(); if (delete <= 0) { connection.rollback(); throw new DAOException(\"Number of rows <= 0\"); } else if (delete > 1) { connection.rollback(); throw new DAOException(\"Number of rows > 1\"); } connection.commit(); } catch (SQLException e) { Log.write(e.getMessage()); throw new DAOException(\"A SQLException has occured\"); } catch (NullPointerException npe) { Log.write(npe.getMessage()); throw new DAOException(\"Connection null\"); } return delete; }. \n Code2: public static synchronized int registerVote(String IDVotazione, byte[] T1, byte[] sbT2, byte[] envelope, Config config) { if (IDVotazione == null) { LOGGER.error(\"registerVote::IDV null\"); return C_addVote_BOH; } if (T1 == null) { LOGGER.error(\"registerVote::T1 null\"); return C_addVote_BOH; } if (envelope == null) { LOGGER.error(\"registerVote::envelope null\"); return C_addVote_BOH; } LOGGER.info(\"registering vote started\"); Connection conn = null; PreparedStatement stmt = null; boolean autoCommitPresent = true; int ANSWER = C_addVote_BOH; try { ByteArrayInputStream tmpXMLStream = new ByteArrayInputStream(envelope); SAXReader tmpXMLReader = new SAXReader(); Document doc = tmpXMLReader.read(tmpXMLStream); if (LOGGER.isTraceEnabled()) LOGGER.trace(doc.asXML()); String sT1 = new String(Base64.encodeBase64(T1), \"utf-8\"); String ssbT2 = new String(Base64.encodeBase64(sbT2), \"utf-8\"); String sEnvelope = new String(Base64.encodeBase64(envelope), \"utf-8\"); LOGGER.trace(\"loading jdbc driver ...\"); Class.forName(\"com.mysql.jdbc.Driver\"); LOGGER.trace(\"... loaded\"); conn = DriverManager.getConnection(config.getSconn()); autoCommitPresent = conn.getAutoCommit(); conn.setAutoCommit(false); String query = \"\" + \" INSERT INTO votes(IDVotazione, T1, signByT2 , envelope) \" + \" VALUES (? , ? , ? , ? ) \"; stmt = conn.prepareStatement(query); stmt.setString(1, IDVotazione); stmt.setString(2, sT1); stmt.setString(3, ssbT2); stmt.setString(4, sEnvelope); stmt.executeUpdate(); stmt.close(); LOGGER.debug(\"vote saved for references, now start the parsing\"); query = \"\" + \" INSERT INTO risposte (IDVotazione, T1, IDquestion , myrisposta,freetext) \" + \" VALUES (? , ? , ? , ? ,?) \"; stmt = conn.prepareStatement(query); Element question, itemsElem, rispostaElem; List<Element> rispList; String id, rispostaText, risposta, freeText, questionType; Iterator<Element> questionIterator = doc.selectNodes(\"/poll/manifest/question\").iterator(); while (questionIterator.hasNext()) { question = (Element) questionIterator.next(); risposta = freeText = \"\"; id = question.attributeValue(\"id\"); itemsElem = question.element(\"items\"); questionType = itemsElem == null ? \"\" : itemsElem.attributeValue(\"type\"); rispostaElem = question.element(\"myrisposta\"); rispostaText = rispostaElem == null ? \"\" : rispostaElem.getText(); if (rispostaText.equals(Votazione.C_TAG_WHITE_XML)) { risposta = C_TAG_WHITE; } else if (rispostaText.equals(Votazione.C_TAG_NULL_XML)) { risposta = C_TAG_NULL; } else { if (!rispostaText.equals(\"\") && LOGGER.isDebugEnabled()) LOGGER.warn(\"Risposta text should be empty!: \" + rispostaText); risposta = C_TAG_BUG; if (questionType.equals(\"selection\")) { Element rispItem = rispostaElem.element(\"item\"); String tmpRisposta = rispItem.attributeValue(\"index\"); if (tmpRisposta != null) { risposta = tmpRisposta; if (risposta.equals(\"0\")) freeText = rispItem.getText(); } } else if (questionType.equals(\"borda\")) { rispList = rispostaElem.elements(\"item\"); if (rispList != null) { risposta = \"\"; String index, tokens; for (Element rispItem : rispList) { index = rispItem.attributeValue(\"index\"); tokens = rispItem.attributeValue(\"tokens\"); if (index.equals(\"0\")) freeText = rispItem.getText(); if (risposta.length() > 0) risposta += \",\"; risposta += index + \":\" + tokens; } } } else if (questionType.equals(\"ordering\")) { rispList = rispostaElem.elements(\"item\"); if (rispList != null) { risposta = \"\"; String index, order; for (Element rispItem : rispList) { index = rispItem.attributeValue(\"index\"); order = rispItem.attributeValue(\"order\"); if (index == null) { continue; } if (index.equals(\"0\")) freeText = rispItem.getText(); if (risposta.length() > 0) risposta += \",\"; risposta += index + \":\" + order; } } } else if (questionType.equals(\"multiple\")) { rispList = rispostaElem.elements(\"item\"); if (rispList != null) { risposta = \"\"; String index; for (Element rispItem : rispList) { index = rispItem.attributeValue(\"index\"); if (index.equals(\"0\")) freeText = rispItem.getText(); if (risposta.length() > 0) risposta += \",\"; risposta",
        "ground_truth": "NO",
        "predict": " += index; } } } else if (questionType.equals(\"text\")) { risposta = rispostaElem.getText(); } else { if (LOGGER.isDebugEnabled()) LOGGER.warn(\"Question type not recognized: \" + questionType); risposta = C_TAG_BUG; } } catch (Exception e) { LOGGER.error(\"registerVote::\" + e.getMessage()); ANSWER = C_addVote_BOH; } finally { if (stmt != null) { try { stmt.close(); } catch (Exception e) { } } if (conn != null) { try { conn.close(); } catch (Exception e) { } } } } return ANSWER; }\n"
    },
    {
        "ID": 861,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void constructDialogContent(Composite parent) { SashForm splitter = new SashForm(parent, SWT.HORIZONTAL); splitter.setLayoutData(new GridData(GridData.FILL_BOTH)); Group fragmentsGroup = new Group(splitter, SWT.NONE); fragmentsGroup.setLayout(new GridLayout(1, false)); fragmentsGroup.setText(\"Result Fragments\"); fragmentsTable = CheckboxTableViewer.newCheckList(fragmentsGroup, SWT.NONE); fragmentsTable.getTable().setLayoutData(new GridData(GridData.FILL_BOTH)); fragmentsTable.setContentProvider(new ArrayContentProvider()); fragmentsTable.setLabelProvider(new LabelProvider() { public Image getImage(Object element) { return JFaceResources.getImage(WsmoImageRegistry.INSTANCE_ICON); } public String getText(Object element) { if (element == null) { return \"\"; } if (element instanceof ProcessFragment) { ProcessFragment frag = (ProcessFragment) element; String label = (frag.getName() == null) ? \" <no-fragment-name>\" : frag.getName(); if (frag.getDescription() != null) { label += \" [\" + Utils.normalizeSpaces(frag.getDescription()) + ']'; } return label; } return element.toString(); } }); fragmentsTable.setInput(results.toArray()); final MenuManager menuMgr = new MenuManager(); menuMgr.setRemoveAllWhenShown(true); menuMgr.addMenuListener(new IMenuListener() { public void menuAboutToShow(IMenuManager mgr) { if (false == GUIHelper.containsCursor(fragmentsTable.getTable())) { return; } if (false == fragmentsTable.getSelection().isEmpty()) { menuMgr.add(new Action(\"Edit Name\") { public void run() { doEditName(); } }); menuMgr.add(new Action(\"Edit Description\") { public void run() { doEditDescription(); } }); menuMgr.add(new Separator()); } menuMgr.add(new Action(\"Select All\") { public void run() { fragmentsTable.setAllChecked(true); updateSelectionMonitor(); } }); menuMgr.add(new Separator()); menuMgr.add(new Action(\"Unselect All\") { public void run() { fragmentsTable.setAllChecked(false); updateSelectionMonitor(); } }); } }); fragmentsTable.getTable().setMenu(menuMgr.createContextMenu(fragmentsTable.getTable())); fragmentsTable.addSelectionChangedListener(new ISelectionChangedListener() { public void selectionChanged(SelectionChangedEvent event) { updatePreviewPanel((IStructuredSelection) event.getSelection()); } }); new FragmentsToolTipProvider(this.fragmentsTable.getTable()); Group previewGroup = new Group(splitter, SWT.NONE); previewGroup.setLayout(new GridLayout(1, false)); previewGroup.setText(\"Fragment Preview\"); createZoomToolbar(previewGroup); previewArea = new Composite(previewGroup, SWT.BORDER); previewArea.setLayoutData(new GridData(GridData.FILL_BOTH)); previewArea.setLayout(new GridLayout(1, false)); viewer = new ScrollingGraphicalViewer(); viewer.createControl(previewArea); ScalableFreeformRootEditPart rootEditPart = new ScalableFreeformRootEditPart(); viewer.setRootEditPart(rootEditPart); viewer.setEditPartFactory(new GraphicalPartFactory()); viewer.getControl().setBackground(ColorConstants.listBackground); viewer.getControl().setLayoutData(new GridData(GridData.FILL_BOTH)); ZoomManager zoomManager = rootEditPart.getZoomManager(); ArrayList<String> zoomContributions = new ArrayList<String>(); zoomContributions.add(ZoomManager.FIT_ALL); zoomContributions.add(ZoomManager.FIT_HEIGHT); zoomContributions.add(ZoomManager.FIT_WIDTH); zoomManager.setZoomLevelContributions(zoomContributions); zoomManager.setZoomLevels(new double[] { 0.25, 0.33, 0.5, 0.75, 1.0 }); zoomManager.setZoom(1.0); Composite businessGoalPanel = new Composite(previewGroup, SWT.NONE); businessGoalPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); businessGoalPanel.setLayout(new GridLayout(4, false)); Label lab = new Label(businessGoalPanel, SWT.NONE); lab.setText(\"Process goal:\"); bpgIRI = new Text(businessGoalPanel, SWT.BORDER | SWT.READ_ONLY); bpgIRI.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); selectBpgButton = new Button(businessGoalPanel, SWT.NONE); selectBpgButton.setText(\"Select\"); selectBpgButton.setEnabled(false); selectBpgButton.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent s) { doSelectProcessGoal(); } }); clearBpgButton = new Button(businessGoalPanel, SWT.NONE); clearBpgButton.setText(\"Clear\"); clearBpgButton.setEnabled(false); clearBpgButton.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent s) { IStructuredSelection sel = (IStructuredSelection) fragmentsTable.getSelection(); if (sel.isEmpty() || false == sel.getFirstElement() instanceof ProcessFragment) { return; } ((ProcessFragment) sel.getFirstElement()).setBusinessProcessGoal(null); updatePreviewPanel(sel); } }); splitter.setWeights(new int[] { 1, 2 }); }. \n Code2: public static void main(String[] args) throws Exception { FileChannel fc = new FileOutputStream(\"data.txt\").getChannel(); fc.write(ByteBuffer.wrap(\"some text \".getBytes())); fc.close(); fc = new RandomAccessFile(\"data.txt\", \"rw\").getChannel(); fc.position(fc.size()); fc.write(ByteBuffer.wrap(\"some more\".getBytes())); fc.close(); fc = new FileInputStream(\"data.txt\").getChannel(); ByteBuffer buff = ByteBuffer.allocate(BSIZE); fc.read(buff); buff.flip(); while (buff.hasRemaining()) { PrintUtil.prt((char) buff.get()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code",
        "ground_truth": "YES",
        "predict": "1: private void doSelectProcessGoal() { IStructuredSelection sel = (IStructuredSelection) fragmentsTable.getSelection(); if (sel.isEmpty() || false == sel.getFirstElement() instanceof ProcessFragment) { return; } ProcessFragment frag = (ProcessFragment) sel.getFirstElement(); if (frag.getBusinessProcessGoal() != null) { bpgIRI.setText(frag.getBusinessProcessGoal().getIRI()); } else { bpgIRI.setText(\"\"); } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void doEditName() { IStructuredSelection sel = (IStructuredSelection) fragmentsTable.getSelection(); if (sel.isEmpty() || false == sel.getFirstElement() instanceof ProcessFragment) { return; } Process"
    },
    {
        "ID": 868,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static void _save(PortletRequest req, PortletResponse res, PortletConfig config, ActionForm form) throws Exception { try { String filePath = getUserManagerConfigPath() + \"user_manager_config.properties\"; String tmpFilePath = UtilMethods.getTemporaryDirPath() + \"user_manager_config_properties.tmp\"; File from = new java.io.File(tmpFilePath); from.createNewFile(); File to = new java.io.File(filePath); to.createNewFile(); FileChannel srcChannel = new FileInputStream(from).getChannel(); FileChannel dstChannel = new FileOutputStream(to).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (NonWritableChannelException we) { } catch (IOException e) { Logger.error(UserManagerPropertiesFactory.class, \"Property File save Failed \" + e, e); } SessionMessages.add(req, \"message\", \"message.usermanager.display.save\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) { HttpURLConnection urlConn = null; try { String params = generatorParamString(parameters); URL url = new URL(reqUrl); urlConn = (HttpURLConnection) url.openConnection(); urlConn.setRequestMethod(\"POST\"); urlConn.setConnectTimeout(5000); urlConn.setReadTimeout(5000); urlConn.setDoOutput(true); byte[] b = params.getBytes(); urlConn.getOutputStream().write(b, 0, b.length); urlConn.getOutputStream().flush(); urlConn.getOutputStream().close(); } catch (Exception e) { throw new RuntimeException(e.getMessage(), e); } return urlConn; }. \n Code2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.",
        "ground_truth": "NO",
        "predict": "append(Long.toString(rand)); md5.update(sbValueBeforeMD5.toString().getBytes()); StringBuffer sbValueAfterMD5 = new StringBuffer(); sbValueAfterMD5.append(Long.toHexString(md5.digest(sbValueBeforeMD5.toString().getBytes()))); this.s_id = sbValueAfterMD5.toString(); } catch (Exception e) { System.out.println(\"Error: \" + e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String getRandomGUID() { return s_id; }. \n Code2: public static String getRandomGUID() { return s_id; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code"
    },
    {
        "ID": 871,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Test public void testLargePut() throws Throwable { int size = CommonParameters.BLOCK_SIZE; InputStream is = new FileInputStream(_fileName); RepositoryFileOutputStream ostream = new RepositoryFileOutputStream(_nodeName, _putHandle, CommonParameters.local); int readLen = 0; int writeLen = 0; byte[] buffer = new byte[CommonParameters.BLOCK_SIZE]; while ((readLen = is.read(buffer, 0, size)) != -1) { ostream.write(buffer, 0, readLen); writeLen += readLen; } ostream.close(); CCNStats stats = _putHandle.getNetworkManager().getStats(); Assert.assertEquals(0, stats.getCounter(\"DeliverInterestFailed\")); }. \n Code2: public byte process(ProcessorContext<PublishRequest> context) throws InterruptedException, ProcessorException { logger.info(\"MapTileChacheTask:process\"); PublishRequest req = context.getItem().getEntity(); if (StringUtils.isEmpty(req.getBackMap())) return TaskState.STATE_TILE_CACHED; final PublicMapPost post; final GenericDAO<PublicMapPost> postDao = DAOFactory.createDAO(PublicMapPost.class); try { ReadOnlyTransaction.beginTransaction(); } catch (DatabaseException e) { logger.error(\"error\", e); throw new ProcessorException(e); } int numCachedTiles = 0; try { List<MapTile> backTiles = new ArrayList<MapTile>(); post = postDao.findUniqueByCriteria(Expression.eq(\"guid\", req.getPostGuid())); final LatLngRectangle bounds = new LatLngRectangle(new LatLngPoint(post.getSWLat(), post.getSWLon()), new LatLngPoint(post.getNELat(), post.getNELon())); final String backMapGuid = \"gst\"; final XFile dstDir = new XFile(new XFile(Configuration.getInstance().getPublicMapStorage().toString()), backMapGuid); dstDir.mkdir(); for (int z = Math.min(Tile.getOptimalZoom(bounds, 768), 9); z <= 17; z++) { final Tile tileStart = new Tile(bounds.getSouthWest().getLat(), bounds.getSouthWest().getLng(), z); final Tile tileEnd = new Tile(bounds.getNorthEast().getLat(), bounds.getNorthEast().getLng(), z); for (double y = tileEnd.getTileCoord().getY(); y <= tileStart.getTileCoord().getY(); y++) for (double x = tileStart.getTileCoord().getX(); x <= tileEnd.getTileCoord().getX(); x++) { NASAMapTile tile = new NASAMapTile((int) x, (int) y, z); XFile file = new XFile(dstDir, tile.toKeyString()); if (file.exists() && file.isFile()) continue; backTiles.add(tile); } } try { for (MapTile tile : backTiles) { InputStream in = null; OutputStream out = null; final URL url = new URL(tile.getPath()); try { final XFile outFile = new XFile(dstDir, tile.toKeyString()); final URLConnection conn = url.openConnection(); if (conn == null || !conn.getContentType().startsWith(\"image\")) throw new IllegalAccessException(\"onearth.jpl.nasa.gov service returns non-image file, \" + \"content-type='\" + conn.getContentType() + \"'\"); in = conn.getInputStream(); if (in != null) { out = new XFileOutputStream(outFile); IOUtils.copy(in, out); } else throw new IllegalStateException(\"opened stream is null\"); } finally { if (out != null) { out.flush(); out.close(); } if (in != null) in.close(); } if (++numCachedTiles % 100 == 0) { logger.info(numCachedTiles + \" tiles cached\"); } } } catch (Throwable e) { logger.error(\"map tile caching has failed: \", e); throw new ProcessorException(e); } } catch (ProcessorException e) { logger.error(\"map tile caching has failed: \", e); throw e; } catch (Throwable e) { logger.error(\"map tile caching has failed: \", e); throw new ProcessorException(e); } finally { ReadOnlyTransaction.closeTransaction(); logger.info(numCachedTiles + \" tiles cached\"); } return TaskState.STATE_TILE_CACHED; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String hashStringMD5(String string) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(string.getBytes()); byte byteData[] = md.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } StringBuffer hexString = new StringBuffer(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) hexString.append('0'); hexString.append(hex); } return hexString.toString(); }. \n Code2: private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception { Properties list = new Properties(); list.load(new FileInputStream(fileWithListOfImages)); long current = 0; long startTime = System.currentTimeMillis(); System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir); System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\"); System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\"); for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\"); } for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); URL url = new URL(uriPrefix + urlString); File file = new File",
        "ground_truth": "NO",
        "predict": "(outputDir, urlString.substring(urlString.lastIndexOf('/') + 1)); if (file.exists()) continue; try { URLConnection conn = url.openConnection(); conn.setConnectTimeout(5000); conn.setReadTimeout(5000); conn.connect(); InputStream in = conn.getInputStream(); OutputStream out = new FileOutputStream(file); IOUtils.copy(in, out); out.flush(); out.close(); in.close(); } catch (Exception e) { System.out.println(\"File \" + file + \" not downloaded\"); } } System.out.println(\"Done, took \" + (System.currentTimeMillis() - startTime) + \" ms\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String hashStringMD5(String string) throws NoSuchAlgorithmException { MessageDigest md ="
    },
    {
        "ID": 878,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward uploadFile(ActionMapping mapping, ActionForm actForm, HttpServletRequest request, HttpServletResponse in_response) { ActionMessages errors = new ActionMessages(); ActionMessages messages = new ActionMessages(); String returnPage = \"submitPocketSampleInformationPage\"; UploadForm form = (UploadForm) actForm; Integer shippingId = null; try { eHTPXXLSParser parser = new eHTPXXLSParser(); String proposalCode; String proposalNumber; String proposalName; String uploadedFileName; String realXLSPath; if (request != null) { proposalCode = (String) request.getSession().getAttribute(Constants.PROPOSAL_CODE); proposalNumber = String.valueOf(request.getSession().getAttribute(Constants.PROPOSAL_NUMBER)); proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = form.getRequestFile().getFileName(); String fileName = proposalName + \"_\" + uploadedFileName; realXLSPath = request.getRealPath(\"\\\\tmp\\\\\") + \"\\\\\" + fileName; FormFile f = form.getRequestFile(); InputStream in = f.getInputStream(); File outputFile = new File(realXLSPath); if (outputFile.exists()) outputFile.delete(); FileOutputStream out = new FileOutputStream(outputFile); while (in.available() != 0) { out.write(in.read()); out.flush(); } out.flush(); out.close(); } else { proposalCode = \"ehtpx\"; proposalNumber = \"1\"; proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = \"ispyb-template41.xls\"; realXLSPath = \"D:\\\\\" + uploadedFileName; } FileInputStream inFile = new FileInputStream(realXLSPath); parser.retrieveShippingId(realXLSPath); shippingId = parser.getShippingId(); String requestShippingId = form.getShippingId(); if (requestShippingId != null && !requestShippingId.equals(\"\")) { shippingId = new Integer(requestShippingId); } ClientLogger.getInstance().debug(\"uploadFile for shippingId \" + shippingId); if (shippingId != null) { Log.debug(\" ---[uploadFile] Upload for Existing Shipment (DewarTRacking): Deleting Samples from Shipment :\"); double nbSamplesContainers = DBAccess_EJB.DeleteAllSamplesAndContainersForShipping(shippingId); if (nbSamplesContainers > 0) parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained Samples and/or Containers\", \"Previous Samples and/or Containers have been deleted and replaced by new ones.\")); else parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained no Samples and no Containers\", \"Samples and Containers have been added.\")); } Hashtable<String, Hashtable<String, Integer>> listProteinAcronym_SampleName = new Hashtable<String, Hashtable<String, Integer>>(); ProposalFacadeLocal proposal = ProposalFacadeUtil.getLocalHome().create(); ProteinFacadeLocal protein = ProteinFacadeUtil.getLocalHome().create(); CrystalFacadeLocal crystal = CrystalFacadeUtil.getLocalHome().create(); ProposalLightValue targetProposal = (ProposalLightValue) (((ArrayList) proposal.findByCodeAndNumber(proposalCode, new Integer(proposalNumber))).get(0)); ArrayList listProteins = (ArrayList) protein.findByProposalId(targetProposal.getProposalId()); for (int p = 0; p < listProteins.size(); p++) { ProteinValue prot = (ProteinValue) listProteins.get(p); Hashtable<String, Integer> listSampleName = new Hashtable<String, Integer>(); CrystalLightValue listCrystals[] = prot.getCrystals(); for (int c = 0; c < listCrystals.length; c++) { CrystalLightValue _xtal = (CrystalLightValue) listCrystals[c]; CrystalValue xtal = crystal.findByPrimaryKey(_xtal.getPrimaryKey()); BlsampleLightValue listSamples[] = xtal.getBlsamples(); for (int s = 0; s < listSamples.length; s++) { BlsampleLightValue sample = listSamples[s]; listSampleName.put(sample.getName(), sample.getBlSampleId()); } } listProteinAcronym_SampleName.put(prot.getAcronym(), listSampleName); } parser.validate(inFile, listProteinAcronym_SampleName, targetProposal.getProposalId()); List listErrors = parser.getValidationErrors(); List listWarnings = parser.getValidationWarnings(); if (listErrors.size() == 0) { parser.open(realXLSPath); if (parser.getCrystals().size() == 0) { parser.getValidationErrors().add(new XlsUploadException(\"No crystals have been found\", \"Empty shipment\")); } } Iterator errIt = listErrors.iterator(); while (errIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) errIt.next(); errors.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveErrors(request, errors); } catch (Exception e) { } Iterator warnIt = listWarnings.iterator(); while (warnIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) warnIt.next(); messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveMessages(request, messages); } catch (Exception e) { } if (listErrors.size() > 0) { resetCounts(shippingId); return mapping.findForward(\"submitPocketSampleInformationPage\"); } if (listWarnings.size() > 0) returnPage = \"submitPocketSampleInformationPage\"; String crystalDetailsXML; XtalDetails xtalDetailsWebService = new XtalDetails(); CrystalDetailsBuilder cDE = new CrystalDetailsBuilder(); CrystalDetailsElement cd = cDE.createCrystalDetailsElement(proposalName, parser.getCrystals()); cDE.validateJAXBObject(cd); crystalDetailsXML = cDE.marshallJaxBObjToString(cd); xtalDetailsWebService.submitCrystalDetails(crystalDetailsXML); String diffractionPlan; DiffractionPlan diffractionPlanWebService = new DiffractionPlan(); DiffractionPlanBuilder dPB = new Diff",
        "ground_truth": "YES",
        "predict": "ractionPlanBuilder(); DiffractionPlanElement dPE = dPB.createDiffractionPlanElement(proposalName, parser.getCrystals()); dPB.validateJAXBObject(dPE); diffractionPlan = dPB.marshallJaxBObjToString(dPE); diffractionPlanWebService.submitDiffractionPlan(diffractionPlan); return mapping.findForward(returnPage); } catch (Exception e) { return mapping.findForward(\"submitPocketSampleInformationPage\"); } }\n"
    },
    {
        "ID": 882,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private IMolecule readMolecule() throws Exception { String xpath = \"\"; if (index.equals(\"ichi\")) { xpath = URLEncoder.encode(\"//molecule[./identifier/basic='\" + query + \"']\", UTF8); } else if (index.equals(\"kegg\")) { xpath = URLEncoder.encode(\"//molecule[./@name='\" + query + \"' and ./@dictRef='KEGG']\", UTF8); } else if (index.equals(\"nist\")) { xpath = URLEncoder.encode(\"//molecule[../@id='\" + query + \"']\", UTF8); } else { logger.error(\"Did not recognize index type: \" + index); return null; } String colname = URLEncoder.encode(\"/\" + this.collection, UTF8); logger.info(\"Doing query: \" + xpath + \" in collection \" + colname); URL url = new URL(\"http://\" + server + \"/Bob/QueryXindice\"); logger.info(\"Connection to server: \" + url.toString()); URLConnection connection = url.openConnection(); connection.setDoOutput(true); PrintWriter out = new PrintWriter(connection.getOutputStream()); out.print(\"detailed=on\"); out.print(\"&\"); out.print(\"xmlOnly=on\"); out.print(\"&\"); out.print(\"colName=\" + colname); out.print(\"&\"); out.print(\"xpathString=\" + xpath); out.print(\"&\"); out.println(\"query=Query\"); out.close(); InputStream stream = connection.getInputStream(); BufferedReader in = new BufferedReader(new InputStreamReader(stream)); in.mark(1000000); in.readLine(); String comment = in.readLine(); logger.debug(\"The comment is: \" + comment); Pattern p = Pattern.compile(\"<!-- There are (\\\\d{1,6}) results! -->\"); Matcher match = p.matcher(comment); if (match.find()) { resultNum = match.group(1); } else { resultNum = \"0\"; } logger.debug(\"The number of result is \" + resultNum); in.reset(); CMLReader reader = new CMLReader(stream); ChemFile cf = (ChemFile) reader.read((ChemObject) new ChemFile()); logger.debug(\"#sequences: \" + cf.getChemSequenceCount()); IMolecule m = null; if (cf.getChemSequenceCount() > 0) { org.openscience.cdk.interfaces.IChemSequence chemSequence = cf.getChemSequence(0); logger.debug(\"#models in sequence: \" + chemSequence.getChemModelCount()); if (chemSequence.getChemModelCount() > 0) { org.openscience.cdk.interfaces.IChemModel chemModel = chemSequence.getChemModel(0); org.openscience.cdk.interfaces.IMoleculeSet setOfMolecules = chemModel.getMoleculeSet(); logger.debug(\"#mols in model: \" + setOfMolecules.getMoleculeCount()); if (setOfMolecules.getMoleculeCount() > 0) { m = setOfMolecules.getMolecule(0); } else { logger.warn(\"No molecules in the model\"); } } else { logger.warn(\"No models in the sequence\"); } } else { logger.warn(\"No sequences in the file\"); } in.close(); return m; }. \n Code2: @Transactional(readOnly = true, propagation = Propagation.SUPPORTS) public Image getGoogleMapImage(final BigDecimal latitude, final BigDecimal longitude, final Integer zoomLevel) { if (longitude == null) { throw new IllegalArgumentException(\"Longitude cannot be null.\"); } if (latitude == null) { throw new IllegalArgumentException(\"Latitude cannot be null.\"); } if (zoomLevel == null) { throw new IllegalArgumentException(\"ZoomLevel cannot be null.\"); } final URI url = GoogleMapsUtils.buildGoogleMapsStaticUrl(latitude, longitude, zoomLevel); BufferedImage img; try { URLConnection conn = url.toURL().openConnection(); img = ImageIO.read(conn.getInputStream()); } catch (UnknownHostException e) { LOGGER.error(\"Google static MAPS web service is not reachable (UnknownHostException).\", e); img = new BufferedImage(GoogleMapsUtils.defaultWidth, 100, BufferedImage.TYPE_INT_RGB); final Graphics2D graphics = img.createGraphics(); final Map<Object, Object> renderingHints = CollectionUtils.getHashMap(); renderingHints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON); graphics.addRenderingHints(renderingHints); graphics.setBackground(Color.WHITE); graphics.setColor(Color.GRAY); graphics.clearRect(0, 0, GoogleMapsUtils.defaultWidth, 100); graphics.drawString(\"Not Available\", 30, 30); } catch (IOException e) { throw new IllegalStateException(e); } return img; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copyFile(File in, File out) throws IOException { FileChannel source = new FileInputStream(in).getChannel(); FileChannel destination = new FileOutputStream(out).getChannel(); source.transferTo(0, source.size(), destination); source.close(); destination.close(); }. \n Code2: public List load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace(\"load \" + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = \"MbeansDescriptorsDynamicMBeanSource\"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString(); type = param; inputsource = url.openStream(); if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof File) { location = ((File) source).getAbsolutePath(); inputsource = new FileInputStream((File) source); type = param; if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof InputStream) { type = param; inputsource = source; } else if (source instanceof Class) { location = ((Class) source).getName(); type = param; inputsource = source; if (sourceType == null) { sourceType = \"MbeansDescriptorsIntrospectionSource",
        "ground_truth": "NO",
        "predict": "\"; } } else if (source instanceof String) { location = (String) source; type = param; inputsource = source; if (sourceType == null) { sourceType = \"MbeansDescriptorsIntrospectionSource\"; } } else { throw new IllegalArgumentException(\"Unsupported source type: \" + source.getClass().getName()); } if (sourceType == null) { sourceType = sourceTypeFromExt(location); } if (type == null) { type = \"MbeansDescriptorsIntrospectionSource\"; } if (log.isTraceEnabled()) { log.trace(\"load \" + sourceType + \" \" + location + \" \" + type + \" \" + inputsource); } return load(sourceType, inputsource, type); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copyFile(File in, File out) throws IOException {"
    },
    {
        "ID": 914,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean nioWriteFile(FileInputStream inputStream, FileOutputStream out) { if (inputStream == null && out == null) { return false; } try { FileChannel fci = inputStream.getChannel(); FileChannel fco = out.getChannel(); fco.transferFrom(fci, 0, fci.size()); return true; } catch (Exception e) { e.printStackTrace(); return false; } finally { FileUtil.safeClose(inputStream); FileUtil.safeClose(out); } }. \n Code2: public void readMESHDescriptorFileIntoFiles(String outfiledir) { String inputLine, ins; String filename = getMESHdescriptorfilename(); String uid = \"\"; String name = \"\"; String description = \"\"; String element_of = \"\"; Vector treenr = new Vector(); Vector related = new Vector(); Vector synonyms = new Vector(); Vector actions = new Vector(); Vector chemicals = new Vector(); Vector allCASchemicals = new Vector(); Set CAS = new TreeSet(); Map treenr2uid = new TreeMap(); Map uid2name = new TreeMap(); String cut1, cut2; try { BufferedReader in = new BufferedReader(new FileReader(filename)); String outfile = outfiledir + \"\\\\mesh\"; BufferedWriter out_concept = new BufferedWriter(new FileWriter(outfile + \"_concept.txt\")); BufferedWriter out_concept_name = new BufferedWriter(new FileWriter(outfile + \"_concept_name.txt\")); BufferedWriter out_relation = new BufferedWriter(new FileWriter(outfile + \"_relation.txt\")); BufferedWriter cas_mapping = new BufferedWriter(new FileWriter(outfile + \"to_cas_mapping.txt\")); BufferedWriter ec_mapping = new BufferedWriter(new FileWriter(outfile + \"to_ec_mapping.txt\")); Connection db = tools.openDB(\"kb\"); String query = \"SELECT hierarchy_complete,uid FROM mesh_tree, mesh_graph_uid_name WHERE term=name\"; ResultSet rs = tools.executeQuery(db, query); while (rs.next()) { String db_treenr = rs.getString(\"hierarchy_complete\"); String db_uid = rs.getString(\"uid\"); treenr2uid.put(db_treenr, db_uid); } db.close(); System.out.println(\"Reading in the DUIDs ...\"); BufferedReader in_for_mapping = new BufferedReader(new FileReader(filename)); inputLine = getNextLine(in_for_mapping); boolean leave = false; while ((in_for_mapping != null) && (inputLine != null)) { if (inputLine.startsWith(\"<DescriptorRecord DescriptorClass\")) { inputLine = getNextLine(in_for_mapping); cut1 = \"<DescriptorUI>\"; cut2 = \"</DescriptorUI>\"; String mesh_uid = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); if (mesh_uid.compareTo(\"D041441\") == 0) leave = true; inputLine = getNextLine(in_for_mapping); inputLine = getNextLine(in_for_mapping); cut1 = \"<String>\"; cut2 = \"</String>\"; String mesh_name = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); uid2name.put(mesh_uid, mesh_name); } inputLine = getNextLine(in_for_mapping); } in_for_mapping.close(); BufferedReader in_ec_numbers = new BufferedReader(new FileReader(\"e:\\\\projects\\\\ondex\\\\ec_concept_acc.txt\")); Set ec_numbers = new TreeSet(); String ec_line = in_ec_numbers.readLine(); while (in_ec_numbers.ready()) { StringTokenizer st = new StringTokenizer(ec_line); st.nextToken(); ec_numbers.add(st.nextToken()); ec_line = in_ec_numbers.readLine(); } in_ec_numbers.close(); tools.printDate(); inputLine = getNextLine(in); while (inputLine != null) { if (inputLine.startsWith(\"<DescriptorRecord DescriptorClass\")) { treenr.clear(); related.clear(); synonyms.clear(); actions.clear(); chemicals.clear(); boolean id_ready = false; boolean line_read = false; while ((inputLine != null) && (!inputLine.startsWith(\"</DescriptorRecord>\"))) { line_read = false; if ((inputLine.startsWith(\"<DescriptorUI>\")) && (!id_ready)) { cut1 = \"<DescriptorUI>\"; cut2 = \"</DescriptorUI>\"; uid = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); inputLine = getNextLine(in); inputLine = getNextLine(in); cut1 = \"<String>\"; cut2 = \"</String>\"; name = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); id_ready = true; } if (inputLine.compareTo(\"<SeeRelatedList>\") == 0) { while ((inputLine != null) && (inputLine.indexOf(\"</SeeRelatedList>\") == -1)) { if (inputLine.startsWith(\"<DescriptorUI>\")) { cut1 = \"<DescriptorUI>\"; cut2 = \"</DescriptorUI>\"; String id = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); related.add(id); } inputLine = getNextLine(in); line_read = true; } } if (inputLine.compareTo(\"<TreeNumberList>\") == 0) { while ((inputLine != null) && (inputLine.indexOf(\"</TreeNumberList>\") == -1)) { if (inputLine.startsWith(\"<TreeNumber>\")) { cut1 = \"<TreeNumber>\"; cut2 = \"</TreeNumber>\"; String id = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); treenr.add(id); } inputLine = getNextLine(in); line_read = true; } } if (inputLine.startsWith(\"<Concept PreferredConceptYN\")) { boolean prefConcept = false; if (inputLine.compareTo(\"<Concept PreferredConceptYN=\\\"Y\\\">\") == 0) prefConcept = true; while ((inputLine != null) && (inputLine.indexOf(\"</Concept>\") == -1)) { if (inputLine.startsWith(\"<CASN1Name>\") && prefConcept) { cut1 =",
        "ground_truth": "NO",
        "predict": " \"<CASN1Name>\"; cut2 = \"</CASN1Name>\"; String id = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); CAS.add(id); } if (inputLine.startsWith(\"<ECN1Name>\") && prefConcept) { cut1 = \"<ECN1Name>\"; cut2 = \"</ECN1Name>\"; String id = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); ec_numbers.add(id); } if (inputLine.startsWith(\"<SynonymList>\") && prefConcept) { cut1 = \"<SynonymList>\"; cut2 = \"</SynonymList>\"; String id = inputLine.substring(cut1.length(), inputLine.indexOf(cut2)); synonyms.add(id); } if (inputLine.startsWith(\"<ActionList>\") && prefConcept)"
    },
    {
        "ID": 921,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private <T> Collection<T> loadProviders(final Class<T> providerClass) throws ModelException { try { final String providerNamePrefix = providerClass.getName() + \".\"; final Map<String, T> providers = new TreeMap<String, T>(new Comparator<String>() { public int compare(final String key1, final String key2) { return key1.compareTo(key2); } }); final File platformProviders = new File(this.getPlatformProviderLocation()); if (platformProviders.exists()) { if (this.isLoggable(Level.FINEST)) { this.log(Level.FINEST, getMessage(\"processing\", platformProviders.getAbsolutePath()), null); } InputStream in = null; boolean suppressExceptionOnClose = true; final java.util.Properties p = new java.util.Properties(); try { in = new FileInputStream(platformProviders); p.load(in); suppressExceptionOnClose = false; } finally { try { if (in != null) { in.close(); } } catch (final IOException e) { if (suppressExceptionOnClose) { this.log(Level.SEVERE, getMessage(e), e); } else { throw e; } } } for (Map.Entry<Object, Object> e : p.entrySet()) { if (e.getKey().toString().startsWith(providerNamePrefix)) { final String configuration = e.getValue().toString(); if (this.isLoggable(Level.FINEST)) { this.log(Level.FINEST, getMessage(\"providerInfo\", platformProviders.getAbsolutePath(), providerClass.getName(), configuration), null); } providers.put(e.getKey().toString(), this.createProviderObject(providerClass, configuration, platformProviders.toURI().toURL())); } } } final Enumeration<URL> classpathProviders = this.findResources(this.getProviderLocation() + '/' + providerClass.getName()); int count = 0; final long t0 = System.currentTimeMillis(); while (classpathProviders.hasMoreElements()) { count++; final URL url = classpathProviders.nextElement(); if (this.isLoggable(Level.FINEST)) { this.log(Level.FINEST, getMessage(\"processing\", url.toExternalForm()), null); } BufferedReader reader = null; boolean suppressExceptionOnClose = true; try { reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); String line = null; while ((line = reader.readLine()) != null) { if (line.contains(\"#\")) { continue; } if (this.isLoggable(Level.FINEST)) { this.log(Level.FINEST, getMessage(\"providerInfo\", url.toExternalForm(), providerClass.getName(), line), null); } providers.put(providerNamePrefix + providers.size(), this.createProviderObject(providerClass, line, url)); } suppressExceptionOnClose = false; } finally { try { if (reader != null) { reader.close(); } } catch (final IOException e) { if (suppressExceptionOnClose) { this.log(Level.SEVERE, getMessage(e), e); } else { throw new ModelException(getMessage(e), e); } } } } if (this.isLoggable(Level.FINE)) { this.log(Level.FINE, getMessage(\"contextReport\", count, this.getProviderLocation() + '/' + providerClass.getName(), Long.valueOf(System.currentTimeMillis() - t0)), null); } return providers.values(); } catch (final IOException e) { throw new ModelException(getMessage(e), e); } }. \n Code2: protected InputSource getInputSource(URL url, AtomicReference<Date> checkModifiedDate) throws IOException { String proto = url.getProtocol().toLowerCase(Locale.ENGLISH); if (!(\"http\".equals(proto) || \"https\".equals(proto))) throw new IllegalArgumentException(\"OAI only allows HTTP(S) as network protocol!\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(timeout * 1000); conn.setReadTimeout(timeout * 1000); StringBuilder ua = new StringBuilder(\"Java/\").append(System.getProperty(\"java.version\")).append(\" (\").append(de.pangaea.metadataportal.Package.getProductName()).append('/').append(de.pangaea.metadataportal.Package.getVersion()).append(\"; OAI downloader)\"); conn.setRequestProperty(\"User-Agent\", ua.toString()); conn.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate, identity;q=0.3, *;q=0\"); conn.setRequestProperty(\"Accept-Charset\", \"utf-8, *;q=0.1\"); conn.setRequestProperty(\"Accept\", \"text/xml, application/xml, *;q=0.1\"); if (checkModifiedDate != null && checkModifiedDate.get() != null) conn.setIfModifiedSince(checkModifiedDate.get().getTime()); conn.setUseCaches(false); conn.setFollowRedirects(true); log.debug(\"Opening connection...\"); InputStream in = null; try { conn.connect(); in = conn.getInputStream(); } catch (IOException ioe) { int after, code; try { after = conn.getHeaderFieldInt(\"Retry-After\", -1); code = conn.getResponseCode(); } catch (IOException ioe2) { after = -1; code = -1; } if (code == HttpURLConnection.HTTP_UNAVAILABLE && after > 0) throw new RetryAfterIOException(after, ioe); throw ioe; } if (checkModifiedDate != null) { if (conn.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) { log.debug(\"File not modified since \" + checkModifiedDate.get()); if (in != null) in.close(); return null; } long d = conn.getLastModified(); checkModifiedDate.set((d == 0L) ? null : new Date(d)); } String encoding = conn.getContentEncoding(); if (encoding == null) encoding = \"identity\"; encoding = encoding.toLowerCase(Locale.ENGLISH); log.debug(\"HTTP server uses \" + encoding + \" content encoding.\"); if (\"gzip\".equals(encoding)) in = new GZIPInputStream(in); else if (\"deflate\".equals(encoding)) in = new InflaterInputStream(in); else if (!\"identity\".equals(encoding)) throw new IOException(\"Server uses an invalid content encoding:",
        "ground_truth": "NO",
        "predict": " \" + encoding); } return new InputSource(in); }\n}\n"
    },
    {
        "ID": 932,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void unpackBundle() throws IOException { File useJarPath = null; if (DownloadManager.isWindowsVista()) { useJarPath = lowJarPath; File jarDir = useJarPath.getParentFile(); if (jarDir != null) { jarDir.mkdirs(); } } else { useJarPath = jarPath; } DownloadManager.log(\"Unpacking \" + this + \" to \" + useJarPath); InputStream rawStream = new FileInputStream(localPath); JarInputStream in = new JarInputStream(rawStream) { public void close() throws IOException { } }; try { File jarTmp = null; JarEntry entry; while ((entry = in.getNextJarEntry()) != null) { String entryName = entry.getName(); if (entryName.equals(\"classes.pack\")) { File packTmp = new File(useJarPath + \".pack\"); packTmp.getParentFile().mkdirs(); DownloadManager.log(\"Writing temporary .pack file \" + packTmp); OutputStream tmpOut = new FileOutputStream(packTmp); try { DownloadManager.send(in, tmpOut); } finally { tmpOut.close(); } jarTmp = new File(useJarPath + \".tmp\"); DownloadManager.log(\"Writing temporary .jar file \" + jarTmp); unpack(packTmp, jarTmp); packTmp.delete(); } else if (!entryName.startsWith(\"META-INF\")) { File dest; if (DownloadManager.isWindowsVista()) { dest = new File(lowJavaPath, entryName.replace('/', File.separatorChar)); } else { dest = new File(DownloadManager.JAVA_HOME, entryName.replace('/', File.separatorChar)); } if (entryName.equals(BUNDLE_JAR_ENTRY_NAME)) dest = useJarPath; File destTmp = new File(dest + \".tmp\"); boolean exists = dest.exists(); if (!exists) { DownloadManager.log(dest + \".mkdirs()\"); dest.getParentFile().mkdirs(); } try { DownloadManager.log(\"Using temporary file \" + destTmp); FileOutputStream out = new FileOutputStream(destTmp); try { byte[] buffer = new byte[2048]; int c; while ((c = in.read(buffer)) > 0) out.write(buffer, 0, c); } finally { out.close(); } if (exists) dest.delete(); DownloadManager.log(\"Renaming from \" + destTmp + \" to \" + dest); if (!destTmp.renameTo(dest)) { throw new IOException(\"unable to rename \" + destTmp + \" to \" + dest); } } catch (IOException e) { if (!exists) throw e; } } } if (jarTmp != null) { if (useJarPath.exists()) jarTmp.delete(); else if (!jarTmp.renameTo(useJarPath)) { throw new IOException(\"unable to rename \" + jarTmp + \" to \" + useJarPath); } } if (DownloadManager.isWindowsVista()) { DownloadManager.log(\"Using broker to move \" + name); if (!DownloadManager.moveDirWithBroker(DownloadManager.getKernelJREDir() + name)) { throw new IOException(\"unable to create \" + name); } DownloadManager.log(\"Broker finished \" + name); } DownloadManager.log(\"Finished unpacking \" + this); } finally { rawStream.close(); } if (deleteOnInstall) { localPath.delete(); } }. \n Code2: public static void concatenateOutput(File[] inputFiles, File outputFile) { int numberOfInputFiles = inputFiles.length; byte lf = (byte) '\\n'; try { FileOutputStream fos = new FileOutputStream(outputFile); FileChannel outfc = fos.getChannel(); System.out.println(\"Processing \" + inputFiles[0].getPath()); FileInputStream fis = new FileInputStream(inputFiles[0]); FileChannel infc = fis.getChannel(); int bufferCapacity = 100000; ByteBuffer bb = ByteBuffer.allocate(bufferCapacity); bb.clear(); while (infc.read(bb) > 0) { bb.flip(); outfc.write(bb); bb.clear(); } infc.close(); for (int f = 1; f < numberOfInputFiles; f++) { System.out.println(\"Processing \" + inputFiles[f].getPath()); fis = new FileInputStream(inputFiles[f]); infc = fis.getChannel(); bb.clear(); int bytesread = infc.read(bb); bb.flip(); byte b = bb.get(); while (b != lf) { b = bb.get(); } outfc.write(bb); bb.clear(); while (infc.read(bb) > 0) { bb.flip(); outfc.write(bb); bb.clear(); } infc.close(); } outfc.close(); } catch (IOException e) { e.printStackTrace(); System.exit(-1); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void retrieveFile(URL url, RSLink link) { link.setStatus(RSLink.STATUS_DOWNLOADING); HttpURLConnection httpConn = null; DataOutputStream outs = null; BufferedInputStream bins = null; BufferedOutputStream bouts = null; try { String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\"); httpConn = (HttpURLConnection) url.openConnection(); httpConn.setRequestMethod(\"POST\"); httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length)); httpConn.setRequestProperty(\"Content-Language\", \"en-US\"); httpConn.setDoOutput(true); httpConn.setDoInput(true); outs = new DataOutputStream(httpConn.getOutputStream()); outs.writeBytes(postData); outs.flush(); Pattern mimePattern = Pattern.compile(\".+/html.+\"); Matcher matcher = mimePattern.matcher(httpConn.getContentType()); if (matcher.find()) { log(\"Can not download, maybe all RS slots are busy!\"); return; } link.setSize(httpConn.getContentLength()); bins = new BufferedInputStream(httpConn.getInputStream(), 4096); bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096); link.setStatus(RS",
        "ground_truth": "NO",
        "predict": "Link.STATUS_DOWNLOADING); while (bins.available() > 0) { int read = bins.read(link.getBuffer(), link.getBufferOffset(), link.getBufferLength()); if (read == -1) break; link.setBufferOffset(link.getBufferOffset() + read); link.setStatus(RSLink.STATUS_DOWNLOADING); } while (bouts.getCount() > 0) { int write = bouts.write(link.getBuffer(), link.getBufferOffset(), link.getBufferLength()); if (write == -1) break; link.setBufferOffset(link.getBufferOffset() + write); link.setStatus(RSLink.STATUS_DOWNLOADING); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (outs != null) outs.close(); if (bouts != null) bouts.close(); if (bins != null) bins.close(); } catch (IO"
    },
    {
        "ID": 939,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void processHelpFile() { InputStream in = null; if (line.hasOption(\"helpfile\")) { OutputStream out = null; try { String filename = line.getOptionValue(\"helpfile\"); in = new FileInputStream(filename); filename = filename.replace('\\\\', '/'); filename = filename.substring(filename.lastIndexOf('/') + 1); File outFile = new File(outputDir, filename); if (LOG.isInfoEnabled()) { LOG.info(\"Processing generated file \" + outFile.getAbsolutePath()); } out = new FileOutputStream(outFile); baseProperties.setProperty(\"helpfile\", filename); IOUtils.copy(in, out); } catch (FileNotFoundException e) { LOG.error(e.getMessage(), e); } catch (IOException e) { LOG.error(e.getMessage(), e); } finally { if (in != null) { try { in.close(); } catch (IOException e) { LOG.error(e.getMessage(), e); } } if (out != null) { try { out.close(); } catch (IOException e) { LOG.error(e.getMessage(), e); } } } return; } Properties props = new Properties(baseProperties); ClassLoader cl = this.getClass().getClassLoader(); Document doc = null; try { in = cl.getResourceAsStream(RESOURCE_PKG + \"/help-doc.xml\"); doc = XmlUtils.parse(in); } catch (XmlException e) { LOG.error(e.getMessage(), e); } finally { if (in != null) { try { in.close(); } catch (IOException e) { LOG.error(e.getMessage(), e); } } } transformResource(doc, \"help-doc.xsl\", props, \"help-doc.html\"); baseProperties.setProperty(\"helpfile\", \"help-doc.html\"); }. \n Code2: @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.addHeader(\"Cache-Control\", \"max-age=\" + Constants.HTTP_CACHE_SECONDS); String uuid = req.getRequestURI().substring(req.getRequestURI().indexOf(Constants.SERVLET_FULL_PREFIX) + Constants.SERVLET_FULL_PREFIX.length() + 1); boolean notScale = ClientUtils.toBoolean(req.getParameter(Constants.URL_PARAM_NOT_SCALE)); ServletOutputStream os = resp.getOutputStream(); if (uuid != null && !\"\".equals(uuid)) { try { String mimetype = fedoraAccess.getMimeTypeForStream(uuid, FedoraUtils.IMG_FULL_STREAM); if (mimetype == null) { mimetype = \"image/jpeg\"; } ImageMimeType loadFromMimeType = ImageMimeType.loadFromMimeType(mimetype); if (loadFromMimeType == ImageMimeType.JPEG || loadFromMimeType == ImageMimeType.PNG) { StringBuffer sb = new StringBuffer(); sb.append(config.getFedoraHost()).append(\"/objects/\").append(uuid).append(\"/datastreams/IMG_FULL/content\"); InputStream is = RESTHelper.get(sb.toString(), config.getFedoraLogin(), config.getFedoraPassword(), false); if (is == null) { return; } try { IOUtils.copyStreams(is, os); } catch (IOException e) { resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND); LOGGER.error(\"Unable to open full image.\", e); } finally { os.flush(); if (is != null) { try { is.close(); } catch (IOException e) { resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND); LOGGER.error(\"Unable to close stream.\", e); } finally { is = null; } } } } else { Image rawImg = KrameriusImageSupport.readImage(uuid, FedoraUtils.IMG_FULL_STREAM, this.fedoraAccess, 0, loadFromMimeType); BufferedImage scaled = null; if (!notScale) { scaled = KrameriusImageSupport.getSmallerImage(rawImg, 1250, 1000); } else { scaled = KrameriusImageSupport.getSmallerImage(rawImg, 2500, 2000); } KrameriusImageSupport.writeImageToStream(scaled, \"JPG\", os); resp.setContentType(ImageMimeType.JPEG.getValue()); resp.setStatus(HttpURLConnection.HTTP_OK); } } catch (IOException e) { resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND); LOGGER.error(\"Unable to open full image.\", e); } catch (XPathExpressionException e) { resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND); LOGGER.error(\"Unable to create XPath expression.\", e); } finally { os.flush(); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Vector[] getLinksFromURLFast(String p_url) throws Exception { timeCheck(\"getLinksFromURLFast \"); URL x_url = new URL(p_url); URLConnection x_conn = x_url.openConnection(); InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream()); BufferedReader x_reader = new BufferedReader(x_is_reader); String x_line = null; RE e = new RE(\"(.*/)\", RE.REG_ICASE); System.out.println(\"RE: \" + e.toString()); REMatch x_match = e.getMatch(p_url); String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1)); e = new RE(\"(http://.*?)/?\", RE.REG_ICASE); x_match = e.getMatch(p_url); String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1)); e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE); System.out.println(\"RE: \" + e.toString()); Vector x_links = new Vector(100); Vector x_texts = new Vector(100); StringBuffer x_buf = new StringBuffer(10000); REMatch[] x_matches = null; timeCheck(\"starting parsing \"); while ((x_line = x_reader",
        "ground_truth": "NO",
        "predict": ".readLine()) != null) { x_matches = e.getMatches(x_line); if (x_matches != null) { for (int i = 0; i < x_matches.length; i++) { x_buf.append(x_matches[i].toString()).append(\"\\n\"); } } } x_links.add(x_buf.toString()); x_buf = new StringBuffer(10000); timeCheck(\"parsing done \"); } return new Vector[] { x_links, x_texts }; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Vector[] getLinksFromURL(String p_url) throws Exception { timeCheck(\"getLinksFromURL \"); URL x_url = new URL(p_url); URLConnection x_conn = x_url.openConnection(); InputStreamReader x_"
    },
    {
        "ID": 947,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public List<String[]> getCSV(String name) { return new ResourceLoader<List<String[]>>(name) { @Override protected List<String[]> get(URL url) throws Exception { CSVReader reader = null; try { reader = new CSVReader(new InputStreamReader(url.openStream())); return reader.readAll(); } finally { IOUtils.closeQuietly(reader); } } }.get(); }. \n Code2: protected Boolean lancerincident(long idbloc, String Etatbloc, java.util.GregorianCalendar datebloc, long idServeur, String niveau, String message) { String codeerr; Boolean retour = false; Boolean SauvegardeEtatAutocommit; int etat; acgtools_core.AcgIO.SortieLog(new Date() + \" - Appel de la fonction Lancer incident\"); Statement statement = null; ResultSet resultat = null; String RequeteSQL = \"\"; acgtools_core.AcgIO.SortieLog(new Date() + \" - nouvel incident pour le bloc : \" + acgtools_core.AcgIO.RetourneDate(datebloc)); try { this.con = db.OpenConnection(); SauvegardeEtatAutocommit = this.con.getAutoCommit(); this.con.setAutoCommit(false); if (idbloc == 0) { idbloc = this.CreationBloc(idServeur); if (idbloc == 0) { retour = false; acgtools_core.AcgIO.SortieLog(new Date() + \" - Probl\u00e8me lors de la cr\u00e9ation du bloc\"); this.con.rollback(); this.con.close(); return false; } } acgtools_core.AcgIO.SortieLog(new Date() + \" - bloc : \" + idbloc); etat = this.ChargerEtatServeur(idbloc, datebloc); if (etat != 2) { statement = con.createStatement(); acgtools_core.AcgIO.SortieLog(new Date() + \" - Etat charg\u00e9\"); RequeteSQL = \"SELECT incref_err_numer FROM tbl_incident_ref \" + \"WHERE incref_cde_job ='\" + idbloc + \"' \" + \"AND incref_err_numer NOT IN \" + \"(SELECT incref_err_numer FROM tbl_incident_ref \" + \"WHERE incref_err_etat='c') \" + \"AND incref_err_numer NOT IN \" + \"(SELECT incenc_err_numer FROM tbl_incident_encours \" + \"WHERE incenc_err_etat='c') ;\"; acgtools_core.AcgIO.SortieLog(new Date() + \" - \" + RequeteSQL); resultat = statement.executeQuery(RequeteSQL); if (!resultat.next()) { resultat.close(); RequeteSQL = \"INSERT INTO tbl_incident_ref \" + \"(incref_cde_job,incref_err_date,incref_err_etat,incref_niv_crimd,incref_err_msg,incref_err_srvnm)\" + \"VALUES ('\" + idbloc + \"','\" + acgtools_core.AcgIO.RetourneDate(datebloc) + \"','\" + Etatbloc + \"','\" + niveau + \"','\" + message + \"','\" + idServeur + \"');\"; acgtools_core.AcgIO.SortieLog(new Date() + \" - \" + RequeteSQL); statement.executeUpdate(RequeteSQL); RequeteSQL = \"SELECT incref_err_numer FROM tbl_incident_ref \" + \"WHERE incref_cde_job = '\" + idbloc + \"' \" + \"AND incref_err_srvnm = '\" + idServeur + \"' \" + \"AND incref_err_date = '\" + acgtools_core.AcgIO.RetourneDate(datebloc) + \"';\"; acgtools_core.AcgIO.SortieLog(new Date() + \" - \" + RequeteSQL); resultat = statement.executeQuery(RequeteSQL); if (resultat.next()) { codeerr = resultat.getString(\"incref_err_numer\"); resultat.close(); RequeteSQL = \"INSERT INTO tbl_incident_encours\" + \"(incenc_err_numer, incenc_err_etat, incenc_esc_etap, \" + \"incenc_err_date, incenc_typ_user,incenc_cde_user,incenc_err_msg,incenc_niv_crimd) \" + \"VALUES ('\" + codeerr + \"','\" + Etatbloc + \"',0, \" + \"'\" + acgtools_core.AcgIO.RetourneDate(datebloc) + \"','n',0,'\" + message + \"','\" + niveau + \"');\"; acgtools_core.AcgIO.SortieLog(new Date() + \" - \" + RequeteSQL); statement.executeUpdate(RequeteSQL); acgtools_core.AcgIO.SortieLog(new Date() + \" - Incident ins\u00e9r\u00e9 dans la base de donn\u00e9es\"); acgtools_core.AcgIO.SortieLog(new Date() + \" - Traitement de l'envois des emails si n\u00e9cessaire\"); this.usermail(codeerr, etat, acgtools_core.AcgIO.RetourneDate(datebloc), message); acgtools_core.AcgIO.SortieLog(new Date() + \" - Cr\u00e9ation de l'historique\"); this.CreerHistorique(codeerr); acgtools_core.AcgIO.SortieLog(new Date() + \" - Cr\u00e9er maj\"); this.CreerMaj(true); retour = true; } else { acgtools_core.AcgIO.SortieLog(new Date() + \" - Probl\u00e8me d'insertion du nouvel incident dans la base\"); retour = false; } } else { codeerr = resultat.getString(\"incref_err_numer\"); acgtools_core.AcgIO.SortieLog(new Date() + \" - Num\u00e9ro de l'erreur trouv\u00e9. Num\u00e9ro =\" + codeerr); RequeteSQL = \"SELECT incenc_err_etat FROM tbl_incident_encours \" + \"WHERE incenc_err_numer='\" + codeerr + \"';\"; acgtools_core.AcgIO.SortieLog(new Date",
        "ground_truth": "NO",
        "predict": "() + \" - \" + RequeteSQL); resultat = statement.executeQuery(RequeteSQL); if (resultat.next()) { etat = resultat.getInt(\"incenc_err_etat\"); } else { etat = 0; } if (etat == 2) { acgtools_core.AcgIO.SortieLog(new Date() + \" - Traitement de l'envois des emails si n\u00e9cessaire\"); this.usermail(codeerr, etat, acgtools_core.AcgIO.RetourneDate(datebloc), message); acgtools_core.AcgIO.SortieLog(new Date() + \" - Cr\u00e9ation de l'historique\"); this.CreerHistorique(codeerr); acgtools_core.AcgIO.SortieLog(new Date() + \" - Cr\u00e9er maj\"); this.CreerMaj(true); retour = true; } else { acgt"
    },
    {
        "ID": 955,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void processAction(ActionMapping mapping, ActionForm form, PortletConfig config, ActionRequest req, ActionResponse res) throws Exception { boolean editor = false; req.setAttribute(ViewReportsAction.REPORT_EDITOR_OR_ADMIN, false); User user = _getUser(req); List<Role> roles = RoleFactory.getAllRolesForUser(user.getUserId()); for (Role role : roles) { if (role.getName().equals(\"Report Administrator\") || role.getName().equals(\"Report Editor\") || role.getName().equals(\"CMS Administrator\")) { req.setAttribute(ViewReportsAction.REPORT_EDITOR_OR_ADMIN, true); editor = true; break; } } requiresInput = false; badParameters = false; newReport = false; ActionRequestImpl reqImpl = (ActionRequestImpl) req; HttpServletRequest httpReq = reqImpl.getHttpServletRequest(); String cmd = req.getParameter(Constants.CMD); Logger.debug(this, \"Inside EditReportAction cmd=\" + cmd); ReportForm rfm = (ReportForm) form; ArrayList<String> ds = (DbConnectionFactory.getAllDataSources()); ArrayList<DataSource> dsResults = new ArrayList<DataSource>(); for (String dataSource : ds) { DataSource d = rfm.getNewDataSource(); if (dataSource.equals(com.dotmarketing.util.Constants.DATABASE_DEFAULT_DATASOURCE)) { d.setDsName(\"DotCMS Datasource\"); } else { d.setDsName(dataSource); } dsResults.add(d); } rfm.setDataSources(dsResults); httpReq.setAttribute(\"dataSources\", rfm.getDataSources()); Long reportId = UtilMethods.parseLong(req.getParameter(\"reportId\"), 0); String referrer = req.getParameter(\"referrer\"); if (reportId > 0) { report = ReportFactory.getReport(reportId); ArrayList<String> adminRoles = new ArrayList<String>(); adminRoles.add(com.dotmarketing.util.Constants.ROLE_REPORT_ADMINISTRATOR); if (user.getUserId().equals(report.getOwner())) { _checkWritePermissions(report, user, httpReq, adminRoles); } if (cmd == null || !cmd.equals(Constants.EDIT)) { rfm.setSelectedDataSource(report.getDs()); rfm.setReportName(report.getReportName()); rfm.setReportDescription(report.getReportDescription()); rfm.setReportId(report.getInode()); rfm.setWebFormReport(report.isWebFormReport()); httpReq.setAttribute(\"selectedDS\", report.getDs()); } } else { if (!editor) { throw new DotRuntimeException(\"user not allowed to create a new report\"); } report = new Report(); report.setOwner(_getUser(req).getUserId()); newReport = true; } req.setAttribute(WebKeys.PERMISSION_INODE_EDIT, report); if ((cmd != null) && cmd.equals(Constants.EDIT)) { if (Validator.validate(req, form, mapping)) { report.setReportName(rfm.getReportName()); report.setReportDescription(rfm.getReportDescription()); report.setWebFormReport(rfm.isWebFormReport()); if (rfm.isWebFormReport()) report.setDs(\"None\"); else report.setDs(rfm.getSelectedDataSource()); String jrxmlPath = \"\"; String jasperPath = \"\"; try { HibernateUtil.startTransaction(); ReportFactory.saveReport(report); _applyPermissions(req, report); if (!rfm.isWebFormReport()) { if (UtilMethods.isSet(Config.getStringProperty(\"ASSET_REAL_PATH\"))) { jrxmlPath = Config.getStringProperty(\"ASSET_REAL_PATH\") + File.separator + Config.getStringProperty(\"REPORT_PATH\") + File.separator + report.getInode() + \".jrxml\"; jasperPath = Config.getStringProperty(\"ASSET_REAL_PATH\") + File.separator + Config.getStringProperty(\"REPORT_PATH\") + File.separator + report.getInode() + \".jasper\"; } else { jrxmlPath = Config.CONTEXT.getRealPath(File.separator + Config.getStringProperty(\"REPORT_PATH\") + File.separator + report.getInode() + \".jrxml\"); jasperPath = Config.CONTEXT.getRealPath(File.separator + Config.getStringProperty(\"REPORT_PATH\") + File.separator + report.getInode() + \".jasper\"); } UploadPortletRequest upr = PortalUtil.getUploadPortletRequest(req); File importFile = upr.getFile(\"jrxmlFile\"); if (importFile.exists()) { byte[] currentData = new byte[0]; FileInputStream is = new FileInputStream(importFile); int size = is.available(); currentData = new byte[size]; is.read(currentData); File f = new File(jrxmlPath); FileChannel channelTo = new FileOutputStream(f).getChannel(); ByteBuffer currentDataBuffer = ByteBuffer.allocate(currentData.length); currentDataBuffer.put(currentData); currentDataBuffer.position(0); channelTo.write(currentDataBuffer); channelTo.force(false); channelTo.close(); try { JasperCompileManager.compileReportToFile(jrxmlPath, jasperPath); } catch (Exception e) { Logger.error(this, \"Unable to compile or save jrxml: \" + e.toString()); try { f = new File(jrxmlPath); f.delete(); } catch (Exception ex) { Logger.info(this, \"Unable to delete jrxml. This is usually a permissions problem.\"); } try { f = new File(jasperPath); f.delete(); } catch (Exception ex) { Logger.info(this, \"Unable to delete jasper. This is usually a permissions problem.\"); } HibernateUtil.rollbackTransaction(); SessionMessages.add(req, \"error\", UtilMethods.htmlLineBreak(e.getMessage())); setForward(req, \"portlet.ext.report.edit_report\"); return; } JasperReport jasperReport = (JasperReport) JRLoader.loadObject(jasperPath); ReportParameterFactory.deleteReportsParameters(report); _loadReportParameters(jasperReport.getParameters()); report.setRequiresInput(requiresInput); HibernateUtil.save(report); } else if (newReport) { HibernateUtil.rollbackTransaction();",
        "ground_truth": "NO",
        "predict": " SessionMessages.add(req, \"error\", \"message.report.new.required\"); setForward(req, \"portlet.ext.report.edit_report\"); return; } else { HibernateUtil.rollbackTransaction(); SessionMessages.add(req, \"error\", \"message.report.edit.required\"); setForward(req, \"portlet.ext.report.edit_report\"); return; } } catch (Exception e) { HibernateUtil.rollbackTransaction(); SessionMessages.add(req, \"error\", \"message.report.edit.required\"); setForward(req, \"portlet.ext.report.edit_report\"); return; } } }\n"
    },
    {
        "ID": 979,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void setupService(MessageContext msgContext) throws Exception { String realpath = msgContext.getStrProp(Constants.MC_REALPATH); String extension = (String) getOption(OPTION_JWS_FILE_EXTENSION); if (extension == null) extension = DEFAULT_JWS_FILE_EXTENSION; if ((realpath != null) && (realpath.endsWith(extension))) { String jwsFile = realpath; String rel = msgContext.getStrProp(Constants.MC_RELATIVE_PATH); File f2 = new File(jwsFile); if (!f2.exists()) { throw new FileNotFoundException(rel); } if (rel.charAt(0) == '/') { rel = rel.substring(1); } int lastSlash = rel.lastIndexOf('/'); String dir = null; if (lastSlash > 0) { dir = rel.substring(0, lastSlash); } String file = rel.substring(lastSlash + 1); String outdir = msgContext.getStrProp(Constants.MC_JWS_CLASSDIR); if (outdir == null) outdir = \".\"; if (dir != null) { outdir = outdir + File.separator + dir; } File outDirectory = new File(outdir); if (!outDirectory.exists()) { outDirectory.mkdirs(); } if (log.isDebugEnabled()) log.debug(\"jwsFile: \" + jwsFile); String jFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"java\"; String cFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"class\"; if (log.isDebugEnabled()) { log.debug(\"jFile: \" + jFile); log.debug(\"cFile: \" + cFile); log.debug(\"outdir: \" + outdir); } File f1 = new File(cFile); String clsName = null; if (clsName == null) clsName = f2.getName(); if (clsName != null && clsName.charAt(0) == '/') clsName = clsName.substring(1); clsName = clsName.substring(0, clsName.length() - extension.length()); clsName = clsName.replace('/', '.'); if (log.isDebugEnabled()) log.debug(\"ClsName: \" + clsName); if (!f1.exists() || f2.lastModified() > f1.lastModified()) { log.debug(Messages.getMessage(\"compiling00\", jwsFile)); log.debug(Messages.getMessage(\"copy00\", jwsFile, jFile)); FileReader fr = new FileReader(jwsFile); FileWriter fw = new FileWriter(jFile); char[] buf = new char[4096]; int rc; while ((rc = fr.read(buf, 0, 4095)) >= 0) fw.write(buf, 0, rc); fw.close(); fr.close(); log.debug(\"javac \" + jFile); Compiler compiler = CompilerFactory.getCompiler(); compiler.setClasspath(ClasspathUtils.getDefaultClasspath(msgContext)); compiler.setDestination(outdir); compiler.addFile(jFile); boolean result = compiler.compile(); (new File(jFile)).delete(); if (!result) { (new File(cFile)).delete(); Document doc = XMLUtils.newDocument(); Element root = doc.createElementNS(\"\", \"Errors\"); StringBuffer message = new StringBuffer(\"Error compiling \"); message.append(jFile); message.append(\":\\n\"); List errors = compiler.getErrors(); int count = errors.size(); for (int i = 0; i < count; i++) { CompilerError error = (CompilerError) errors.get(i); if (i > 0) message.append(\"\\n\"); message.append(\"Line \"); message.append(error.getStartLine()); message.append(\", column \"); message.append(error.getStartColumn()); message.append(\": \"); message.append(error.getMessage()); } root.appendChild(doc.createTextNode(message.toString())); throw new AxisFault(\"Server.compileError\", Messages.getMessage(\"badCompile00\", jFile), null, new Element[] { root }); } ClassUtils.removeClassLoader(clsName); soapServices.remove(clsName); } ClassLoader cl = ClassUtils.getClassLoader(clsName); if (cl == null) { cl = new JWSClassLoader(clsName, msgContext.getClassLoader(), cFile); } msgContext.setClassLoader(cl); SOAPService rpc = (SOAPService) soapServices.get(clsName); if (rpc == null) { rpc = new SOAPService(new RPCProvider()); rpc.setName(clsName); rpc.setOption(RPCProvider.OPTION_CLASSNAME, clsName); rpc.setEngine(msgContext.getAxisEngine()); String allowed = (String) getOption(RPCProvider.OPTION_ALLOWEDMETHODS); if (allowed == null) allowed = \"*\"; rpc.setOption(RPCProvider.OPTION_ALLOWEDMETHODS, allowed); String scope = (String) getOption(RPCProvider.OPTION_SCOPE); if (scope == null) scope = Scope.DEFAULT.getName(); rpc.setOption(RPCProvider.OPTION_SCOPE, scope); rpc.getInitializedServiceDesc(msgContext); soapServices.put(clsName, rpc); } rpc.setEngine(msgContext.getAxisEngine()); rpc.init(); msgContext.setService(rpc); } if (log.isDebugEnabled()) { log.debug(\"Exit: JWSHandler::invoke\"); } }. \n Code2: public static File copyFile(File from, File to) throws IOException { FileOutputStream fos = new FileOutputStream(to); FileInputStream fis = new FileInputStream(from); FileChannel foc = fos.getChannel(); FileChannel fic = fis.getChannel(); foc.transferFrom(fic, 0, fic.size()); foc.close(); fic.close(); return to; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Before public void init() throws IOException { file = new File(LOCATION); url = file.toURI().toURL(); stream = url.openStream(); byteArray = IOUtils.toByteArray(new FileInputStream(file)); content = File",
        "ground_truth": "NO",
        "predict": "Utils.readFileToString(file); }. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void setupService(MessageContext msgContext) throws Exception { String realpath = msgContext.getStrProp(Constants.MC_REALPATH); String extension = (String) getOption(OPTION_JWS_FILE_EXTENSION); if (extension == null) extension = DEFAULT_JWS_FILE_EXTENSION; if ((realpath != null) && (realpath.endsWith(extension))) { String jwsFile = realpath; String rel = msgContext.getStrProp(Constants.MC_RELATIVE_PATH); File f2 = new File(jwsFile); if (!f2.exists()) { throw new FileNotFoundException(rel); } if (rel.charAt(0) == '/') { rel = rel.substring(1); } int"
    },
    {
        "ID": 981,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String args[]) { try { URL url = new URL(\"http://dev.activeanalytics.ca/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=17&m=2&s=16&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=0&m=22&s=1&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3A%2F%2Flyricscatcher.sourceforge.net%2Fcomputeracces.html&action_name=&idsite=1&res=1440x900&h=0&m=28&s=36&fla=1&dir=1&qt=1&realp=0&pdf=1&wma=1&java=1&cookie=1&title=&urlref=\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \n Code2: public static void writeDataResourceText(GenericValue dataResource, String mimeTypeId, Locale locale, Map templateContext, CmsOFBizRemoteClient remoteClient, Writer out, boolean cache) throws IOException, GeneralException { Map context = (Map) templateContext.get(\"context\"); if (context == null) { context = FastMap.newInstance(); } String webSiteId = (String) templateContext.get(\"webSiteId\"); if (UtilValidate.isEmpty(webSiteId)) { if (context != null) webSiteId = (String) context.get(\"webSiteId\"); } String https = (String) templateContext.get(\"https\"); if (UtilValidate.isEmpty(https)) { if (context != null) https = (String) context.get(\"https\"); } Map fields = dataResource.getAllFields(); String dataResourceId = (String) fields.get(\"dataResourceId\"); String dataResourceTypeId = (String) fields.get(\"dataResourceTypeId\"); if (UtilValidate.isEmpty(dataResourceTypeId)) { dataResourceTypeId = \"SHORT_TEXT\"; } if (\"SHORT_TEXT\".equals(dataResourceTypeId) || \"LINK\".equals(dataResourceTypeId)) { String text = (String) fields.get(\"objectInfo\"); writeText(remoteClient, dataResource, text, templateContext, mimeTypeId, locale, out); } else if (\"ELECTRONIC_TEXT\".equals(dataResourceTypeId)) { GenericValue electronicText; if (cache) { electronicText = remoteClient.findByPrimaryKeyCache(\"ElectronicText\", UtilMisc.toMap(\"dataResourceId\", dataResourceId)); } else { electronicText = remoteClient.findByPrimaryKey(\"ElectronicText\", UtilMisc.toMap(\"dataResourceId\", dataResourceId)); } fields = electronicText.getAllFields(); String text = (String) fields.get(\"textData\"); writeText(remoteClient, dataResource, text, templateContext, mimeTypeId, locale, out); } else if (dataResourceTypeId.endsWith(\"_OBJECT\")) { String text = (String) fields.get(\"dataResourceId\"); writeText(remoteClient, dataResource, text, templateContext, mimeTypeId, locale, out); } else if (dataResourceTypeId.equals(\"URL_RESOURCE\")) { String text = null; URL url = new URL((String) fields.get(\"objectInfo\")); if (url.getHost() != null) { InputStream in = url.openStream(); int c; StringWriter sw = new StringWriter(); while ((c = in.read()) != -1) { sw.write(c); } sw.close(); text = sw.toString(); } else { String prefix = DataResourceWorker.buildRequestPrefix(remoteClient, locale, webSiteId, https); String sep = \"\"; if (url.toString().indexOf(\"/\") != 0 && prefix.lastIndexOf(\"/\") != (prefix.length() - 1)) { sep = \"/\"; } String fixedUrlStr = prefix + sep + url.toString(); URL fixedUrl = new URL(fixedUrlStr); text = (",
        "ground_truth": "NO",
        "predict": "String) fields.get(\"objectInfo\"); writeText(remoteClient, dataResource, text, templateContext, mimeTypeId, locale, out); } } }. \n Code3: public static void writeText(CmsOFBizRemoteClient remoteClient, GenericValue dataResource, String text, Map templateContext, String mimeTypeId, Locale locale, Writer out) throws IOException, GeneralException { if (UtilValidate.isEmpty(text)) { return; } if (text.indexOf(\"<\") != -1) { out.write(text); return; } if (text.indexOf(\"&\") != -1) { text = text.replaceAll(\"&\", \"&amp;\"); } if (text.indexOf(\"<\") != -1) { text = text.replaceAll(\"<\", \"&lt;\"); } if (text.indexOf(\">\") != -1) { text = text.replaceAll(\">\", \"&gt;\"); } if"
    },
    {
        "ID": 986,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { try { { byte[] bytes1 = { (byte) 2, (byte) 2, (byte) 3, (byte) 0, (byte) 9 }; byte[] bytes2 = { (byte) 99, (byte) 2, (byte) 2, (byte) 3, (byte) 0, (byte) 9 }; System.out.println(\"Bytes 2,2,3,0,9 as Base64: \" + encodeBytes(bytes1)); System.out.println(\"Bytes 2,2,3,0,9 w/ offset: \" + encodeBytes(bytes2, 1, bytes2.length - 1)); byte[] dbytes = decode(encodeBytes(bytes1)); System.out.print(encodeBytes(bytes1) + \" decoded: \"); for (int i = 0; i < dbytes.length; i++) System.out.print(dbytes[i] + (i < dbytes.length - 1 ? \",\" : \"\\n\")); } { java.io.FileInputStream fis = new java.io.FileInputStream(\"test.gif.b64\"); Base64.InputStream b64is = new Base64.InputStream(fis, DECODE); byte[] bytes = new byte[0]; int b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[bytes.length + 1]; System.arraycopy(bytes, 0, temp, 0, bytes.length); temp[bytes.length] = (byte) b; bytes = temp; } b64is.close(); javax.swing.ImageIcon iicon = new javax.swing.ImageIcon(bytes); javax.swing.JLabel jlabel = new javax.swing.JLabel(\"Read from test.gif.b64\", iicon, 0); javax.swing.JFrame jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif_out\"); fos.write(bytes); fos.close(); fis = new java.io.FileInputStream(\"test.gif_out\"); b64is = new Base64.InputStream(fis, ENCODE); byte[] ebytes = new byte[0]; b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[ebytes.length + 1]; System.arraycopy(ebytes, 0, temp, 0, ebytes.length); temp[ebytes.length] = (byte) b; ebytes = temp; } b64is.close(); String s = new String(ebytes); javax.swing.JTextArea jta = new javax.swing.JTextArea(s); javax.swing.JScrollPane jsp = new javax.swing.JScrollPane(jta); jframe = new javax.swing.JFrame(); jframe.setTitle(\"Read from test.gif_out\"); jframe.getContentPane().add(jsp); jframe.pack(); jframe.setVisible(true); fos = new java.io.FileOutputStream(\"test.gif.b64_out\"); fos.write(ebytes); fis = new java.io.FileInputStream(\"test.gif.b64_out\"); b64is = new Base64.InputStream(fis, DECODE); byte[] edbytes = new byte[0]; b = -1; while ((b = b64is.read()) >= 0) { byte[] temp = new byte[edbytes.length + 1]; System.arraycopy(edbytes, 0, temp, 0, edbytes.length); temp[edbytes.length] = (byte) b; edbytes = temp; } b64is.close(); iicon = new javax.swing.ImageIcon(edbytes); jlabel = new javax.swing.JLabel(\"Read from test.gif.b64_out\", iicon, 0); jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); } { java.io.FileInputStream fis = new java.io.FileInputStream(\"test.gif_out\"); byte[] rbytes = new byte[0]; int b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rbytes.length + 1]; System.arraycopy(rbytes, 0, temp, 0, rbytes.length); temp[rbytes.length] = (byte) b; rbytes = temp; } fis.close(); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif.b64_out2\"); Base64.OutputStream b64os = new Base64.OutputStream(fos, ENCODE); b64os.write(rbytes); b64os.close(); fis = new java.io.FileInputStream(\"test.gif.b64_out2\"); byte[] rebytes = new byte[0]; b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rebytes.length + 1]; System.arraycopy(rebytes, 0, temp, 0, rebytes.length); temp[rebytes.length] = (byte) b; rebytes = temp; } fis.close(); String s = new String(rebytes); javax.swing.JTextArea jta = new javax.swing.JTextArea(s); javax.swing.JScrollPane jsp = new javax.swing.JScrollPane(jta); javax.swing.JFrame jframe = new javax.swing.JFrame(); jframe.setTitle(\"Read from test.gif.b64_out2\"); jframe.getContentPane().add(jsp); jframe.pack(); jframe.setVisible(true); fos = new java.io.FileOutputStream(\"test.gif_out2\"); b64os = new Base64.OutputStream(fos, DECODE); b64os.write(rebytes); b64os.close(); javax.swing.ImageIcon iicon = new javax.swing.ImageIcon(\"test.gif_out2\"); javax.swing.JLabel jlabel = new javax.swing.JLabel(\"Read from test.gif_out2\", iicon, 0); jframe = new javax.swing.JFrame(); jframe.getContentPane().add(jlabel); jframe.pack(); jframe.setVisible(true); } { java.io.FileInputStream fis = new",
        "ground_truth": "NO",
        "predict": " java.io.FileInputStream(\"test.gif_out2\"); byte[] rbytes = new byte[0]; int b = -1; while ((b = fis.read()) >= 0) { byte[] temp = new byte[rbytes.length + 1]; System.arraycopy(rbytes, 0, temp, 0, rbytes.length); temp[rbytes.length] = (byte) b; rbytes = temp; } fis.close(); java.io.FileOutputStream fos = new java.io.FileOutputStream(\"test.gif.b64_out3\"); Base64.OutputStream b64os = new Base64.OutputStream(fos, ENCODE); b64os.write(rbytes); b64os.close(); fis = new java.io.FileInputStream(\"test.gif.b64_out3\"); byte[] rebytes = new byte[0]; b = -1; while ((b = fis.read()) >= 0"
    },
    {
        "ID": 989,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean isSameHttpContent(final String url, final File localFile, UsernamePasswordCredentials creds) throws IOException { if (localFile.isFile()) { long localContentLength = localFile.length(); long localLastModified = localFile.lastModified() / 1000; long contentLength = -1; long lastModified = -1; HttpClient httpclient = createHttpClient(creds); try { HttpHead httphead = new HttpHead(url); HttpResponse response = httpclient.execute(httphead); if (response != null) { StatusLine statusLine = response.getStatusLine(); int status = statusLine.getStatusCode() / 100; if (status == 2) { Header lastModifiedHeader = response.getFirstHeader(\"Last-Modified\"); Header contentLengthHeader = response.getFirstHeader(\"Content-Length\"); if (contentLengthHeader != null) { contentLength = Integer.parseInt(contentLengthHeader.getValue()); } if (lastModifiedHeader != null) { SimpleDateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\"); formatter.setDateFormatSymbols(new DateFormatSymbols(Locale.US)); try { lastModified = formatter.parse(lastModifiedHeader.getValue()).getTime() / 1000; } catch (ParseException e) { logger.error(e); } } } else { return true; } } } finally { httpclient.getConnectionManager().shutdown(); } if (logger.isDebugEnabled()) { logger.debug(\"local:\" + localContentLength + \" \" + localLastModified); logger.debug(\"remote:\" + contentLength + \" \" + lastModified); } if (contentLength != -1 && localContentLength != contentLength) return false; if (lastModified != -1 && lastModified != localLastModified) return false; if (contentLength == -1 && lastModified == -1) return false; return true; } return false; }. \n Code2: @Override public DataTable generateDataTable(Query query, HttpServletRequest request) throws DataSourceException { String url = request.getParameter(URL_PARAM_NAME); if (StringUtils.isEmpty(url)) { log.error(\"url parameter not provided.\"); throw new DataSourceException(ReasonType.INVALID_REQUEST, \"url parameter not provided\"); } Reader reader; try { reader = new BufferedReader(new InputStreamReader(new URL(url).openStream())); } catch (MalformedURLException e) { log.error(\"url is malformed: \" + url); throw new DataSourceException(ReasonType.INVALID_REQUEST, \"url is malformed: \" + url); } catch (IOException e) { log.error(\"Couldn't read from url: \" + url, e); throw new DataSourceException(ReasonType.INVALID_REQUEST, \"Couldn't read from url: \" + url); } DataTable dataTable = null; ULocale requestLocale = DataSourceHelper.getLocaleFromRequest(request); try { dataTable = CsvDataSourceHelper.read(reader, null, true, requestLocale); } catch (IOException e) { log.error(\"Couldn't read from url: \" + url, e); throw new DataSourceException(ReasonType.INVALID_REQUEST, \"Couldn't read from url: \" + url); } return dataTable; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException { _cman = mgr; _sock = sock; for (int i = 0; i < 256; i++) { String key = Integer.toHexString(i); if (key.length() < 2) key = \"0\" + key; availcmd.push(key); commands.put(key, null); } try { _sout = new PrintWriter(_sock.getOutputStream(), true); _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream())); String seed = \"\"; Random rand = new Random(); for (int i = 0; i < 16; i++) { String hex = Integer.toHexString(rand.nextInt(256)); if (hex.length() < 2) hex = \"0\" + hex; seed += hex.substring(hex.length() - 2); } String pass = _mpsw + seed + _spsw; MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.reset(); md5.update(pass.getBytes()); String hash = hash2hex(md5.digest()).toLowerCase(); String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed; sendLine(banner); String txt = readLine(5); if (txt == null) { throw new IOException(\"Slave did not send banner !!\"); } String sname = \"\"; String spass = \"\"; String sseed = \"\"; try { String[] items = txt.split(\" \"); sname = items[1].trim(); spass = items[2].trim(); sseed = items[3].trim(); } catch (Exception e) { AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock); } pass = _spsw + sseed + _mpsw; md5 = MessageDigest.getInstance(\"MD5\"); md5.reset(); md5.update(pass.getBytes()); hash = hash2hex(md5.digest()).toLowerCase(); if (!sname.equals(_name)) { AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock); } if (!spass.toLowerCase().equals(hash.toLowerCase())) { AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock); } _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1); start(); } catch (IOException e) { if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) { logger.info(\"Check slaves.xml on the master that you are allowed to connect.\"); } logger.info(\"IOException: \" + e.toString()); try { sock.close(); } catch (Exception e1) { } } catch (Exception e) { logger.warn(\"Exception: \" + e.toString()); try { sock.close(); } catch (Exception e2) { } } System.gc(); }. \n Code2: private static void copyFile(File source, File dest) throws IOException { FileChannel srcChannel = new FileInputStream(source).getChannel();",
        "ground_truth": "NO",
        "predict": " FileChannel destChannel = new FileOutputStream(dest).getChannel(); srcChannel.transferTo(0, source.length(), destChannel); srcChannel.close(); destChannel.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void start() throws RemoteException { if (_cman == null) { throw new RemoteException(\"ConnectionManager is null\"); } if (_sock == null) { throw new RemoteException(\"Socket is null\"); } }. \n Code2: public void run() { while (true) { try { String line = _sinp.readLine(); if (line == null) { break; } if (line.startsWith(\"INIT\")) { String[] items = line.split(\" \"); String sname = items[1].trim(); String spass = items[2].trim(); String sseed = items[3].trim(); pass"
    },
    {
        "ID": 990,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(",
        "ground_truth": "YES",
        "predict": "new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out"
    },
    {
        "ID": 991,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public FileReader(String filePath, Configuration aConfiguration) throws IOException { file = new File(URLDecoder.decode(filePath, \"UTF-8\")).getCanonicalFile(); readerConf = aConfiguration; if (file.isDirectory()) { File indexFile = new File(file, \"index.php\"); File indexFile_1 = new File(file, \"index.html\"); if (indexFile.exists() && !indexFile.isDirectory()) { file = indexFile; } else if (indexFile_1.exists() && !indexFile_1.isDirectory()) { file = indexFile_1; } else { if (!readerConf.getOption(\"showFolders\").equals(\"Yes\")) { makeErrorPage(503, \"Permision denied\"); } else { FileOutputStream out = new FileOutputStream(readerConf.getOption(\"wwwPath\") + \"/temp/temp.php\"); File[] files = file.listFiles(); makeHeader(200, -1, new Date(System.currentTimeMillis()).toString(), \"text/html\"); String title = \"Index of \" + file; out.write((\"<html><head><title>\" + title + \"</title></head><body><h3>Index of \" + file + \"</h3><p>\\n\").getBytes()); for (int i = 0; i < files.length; i++) { file = files[i]; String filename = file.getName(); String description = \"\"; if (file.isDirectory()) { description = \"&lt;DIR&gt;\"; } out.write((\"<a href=\\\"\" + file.getPath().substring(readerConf.getOption(\"wwwPath\").length()) + \"\\\">\" + filename + \"</a> \" + description + \"<br>\\n\").getBytes()); } out.write((\"</p><hr><p>yawwwserwer</p></body><html>\").getBytes()); file = new File(URLDecoder.decode(readerConf.getOption(\"wwwPath\") + \"/temp/temp.php\", \"UTF-8\")).getCanonicalFile(); } } } else if (!file.exists()) { makeErrorPage(404, \"File Not Found.\"); } else if (getExtension() == \".exe\" || getExtension().contains(\".py\")) { FileOutputStream out = new FileOutputStream(readerConf.getOption(\"wwwPath\") + \"/temp/temp.php\"); out.write((runCommand(filePath)).getBytes()); file = new File(URLDecoder.decode(readerConf.getOption(\"wwwPath\") + \"/temp/temp.php\", \"UTF-8\")).getCanonicalFile(); } else { System.out.println(getExtension()); makeHeader(200, file.length",
        "ground_truth": "NO",
        "predict": "(), new Date(System.currentTimeMillis()).toString(), \"text/html\"); } } }\n Code3: public void run() { try { if (readerConf.getOption(\"showFolders\").equals(\"Yes\")) { File[] files = file.listFiles(); for (int i = 0; i < files.length; i++) { file = files[i]; if (file.isDirectory()) { file = new File(file, \"index.php\"); } if (file.exists()) { new Thread(new Code1(file.getPath(), readerConf)).start(); } } } else { new Thread(new Code1(file.getPath(), readerConf)).start(); } } catch (Exception e) { } }\n}\n"
    },
    {
        "ID": 994,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static boolean writeProperties(Map<String, String> customProps, File destination) throws IOException { synchronized (PropertiesIO.class) { L.info(Msg.msg(\"PropertiesIO.writeProperties.start\")); File tempFile = null; BufferedInputStream existingCfgInStream = null; FileInputStream in = null; FileOutputStream out = null; PrintStream ps = null; FileChannel fromChannel = null, toChannel = null; String line = null; try { existingCfgInStream = new BufferedInputStream(destination.exists() ? new FileInputStream(destination) : defaultPropertiesStream()); tempFile = File.createTempFile(\"properties-\", \".tmp\", null); ps = new PrintStream(tempFile); while ((line = Utils.readLine(existingCfgInStream)) != null) { String lineReady2write = setupLine(line, customProps); ps.println(lineReady2write); } destination.getParentFile().mkdirs(); in = new FileInputStream(tempFile); out = new FileOutputStream(destination, false); fromChannel = in.getChannel(); toChannel = out.getChannel(); fromChannel.transferTo(0, fromChannel.size(), toChannel); L.info(Msg.msg(\"PropertiesIO.writeProperties.done\").replace(\"#file#\", destination.getAbsolutePath())); return true; } finally { if (existingCfgInStream != null) existingCfgInStream.close(); if (ps != null) ps.close(); if (fromChannel != null) fromChannel.close(); if (toChannel != null) toChannel.close(); if (out != null) out.close(); if (in != null) in.close(); if (tempFile != null && tempFile.exists()) tempFile.delete(); } } }. \n Code2: private LinkedList<Datum> processDatum(Datum dataset) { ArrayList<Object[]> markerTestResults = new ArrayList<Object[]>(); ArrayList<Object[]> alleleEstimateResults = new ArrayList<Object[]>(); boolean hasAlleleNames = false; String blank = new String(\"\"); MarkerPhenotypeAdapter theAdapter; if (dataset.getDataType().equals(MarkerPhenotype.class)) { theAdapter = new MarkerPhenotypeAdapter((MarkerPhenotype) dataset.getData()); } else theAdapter = new MarkerPhenotypeAdapter((Phenotype) dataset.getData()); int numberOfMarkers = theAdapter.getNumberOfMarkers(); if (numberOfMarkers == 0) { return calculateBLUEsFromPhenotypes(theAdapter, dataset.getName()); } int numberOfCovariates = theAdapter.getNumberOfCovariates(); int numberOfFactors = theAdapter.getNumberOfFactors(); int numberOfPhenotypes = theAdapter.getNumberOfPhenotypes(); int expectedIterations = numberOfPhenotypes * numberOfMarkers; int iterationsSofar = 0; int percentFinished = 0; File tempFile = null; File ftestFile = null; File blueFile = null; BufferedWriter ftestWriter = null; BufferedWriter BLUEWriter = null; String ftestHeader = \"Trait\\tMarker\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tmarker_F\\tmarker_p\\tperm_p\\tmarkerR2\\tmarkerDF\\tmarkerMS\\terrorDF\\terrorMS\\tmodelDF\\tmodelMS\"; String BLUEHeader = \"Trait\\tMarker\\tObs\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tAllele\\tEstimate\"; if (writeOutputToFile) { String outputbase = outputName; if (outputbase.endsWith(\".txt\")) { int index = outputbase.lastIndexOf(\".\"); outputbase = outputbase.substring(0, index); } String datasetNameNoSpace = dataset.getName().trim().replaceAll(\"\\\\ \", \"_\"); ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.txt\"); int count = 0; while (ftestFile.exists()) { count++; ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest\" + count + \".txt\"); } blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs.txt\"); count = 0; while (blueFile.exists()) { count++; blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs\" + count + \".txt\"); } tempFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.tmp\"); try { if (permute) { ftestWriter = new BufferedWriter(new FileWriter(tempFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } else { ftestWriter = new BufferedWriter(new FileWriter(ftestFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } if (reportBLUEs) { BLUEWriter = new BufferedWriter(new FileWriter(blueFile)); BLUEWriter.write(BLUEHeader); BLUEWriter.newLine(); } } catch (IOException e) { myLogger.error(\"Failed to open file for output\"); myLogger.error(e); return null; } } if (permute) { minP = new double[numberOfPhenotypes][numberOfPermutations]; for (int i = 0; i < numberOfPermutations; i++) { for (int j = 0; j < numberOfPhenotypes; j++) { minP[j][i] = 1; } } } for (int ph = 0; ph < numberOfPhenotypes; ph++) { double[] phenotypeData = theAdapter.getPhenotypeValues(ph); boolean[] missing = theAdapter.getMissingPhenotypes(ph); ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(theAdapter, ph, missing); ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(theAdapter, ph, missing); double[][] permutedData = null; if (permute) { permutedData = permuteData(phenotypeData, missing, factorList, covariateList, theAdapter); } for (int m = 0; m < numberOfMarkers; m++) { Object[] markerData = theAdapter.getMarkerValue(ph, m); boolean[] finalMissing = new boolean[missing.length]; System.arraycopy(missing, 0, finalMissing, 0, missing.length); MarkerPhenotypeAdapterUtils.updateMissing(finalMissing, theAdapter.getMissingMarkers(ph, m)); int[]",
        "ground_truth": "YES",
        "predict": " permutation = null; if (permute) { permutation = permute(phenotypeData, finalMissing, factorList, covariateList, theAdapter); } for (int p = 0; p < numberOfPermutations; p++) { if (permute) { markerTestResults.add(new Object[]{markerData[0], markerData[1], markerData[2], markerData[3], markerData[4], markerData[5], markerData[6], markerData[7], markerData[8], markerData[9], markerData[10], markerData[11], markerData[12], markerData[13], markerData[14], markerData[15], markerData[16], markerData[17], markerData[18], markerData[19], markerData[20], markerData[21], markerData[22], markerData[23], markerData[24], markerData[25], markerData[26], markerData[27], markerData[28], marker"
    },
    {
        "ID": 1001,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected Connection openRelativeFile(String file) throws IOException { if (cachedBits == null) { cachedBits = new ByteArray(url.openConnection().getInputStream()).getBytes(); } ZipInputStream zin = new ZipInputStream(new ByteArrayInputStream(cachedBits)); ZipEntry zentry; while (true) { zentry = zin.getNextEntry(); if (zentry == null) { throw new IOException(\"Couldn't find resource \" + file + \" in ZIP-file\"); } if (zentry.getName().equals(file)) { return new Connection(zin, zentry.getSize()); } } }. \n Code2: protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletConfig config = getServletConfig(); ServletContext context = config.getServletContext(); try { String driver = context.getInitParameter(\"driver\"); Class.forName(driver); String dbURL = context.getInitParameter(\"db\"); String username = context.getInitParameter(\"username\"); String password = \"\"; connection = DriverManager.getConnection(dbURL, username, password); } catch (ClassNotFoundException e) { System.out.println(\"Database driver not found.\"); } catch (SQLException e) { System.out.println(\"Error opening the db connection: \" + e.getMessage()); } String action = \"\"; String notice; String error = \"\"; HttpSession session = request.getSession(); session.setMaxInactiveInterval(300); if (request.getParameter(\"action\") != null) { action = request.getParameter(\"action\"); } else { notice = \"Unknown action!\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/index.jsp\"); dispatcher.forward(request, response); return; } if (action.equals(\"edit_events\")) { String sql; String month_name = \"\"; int month; int year; Event event; if (request.getParameter(\"month\") != null) { month = Integer.parseInt(request.getParameter(\"month\")); String temp = request.getParameter(\"year_num\"); year = Integer.parseInt(temp); int month_num = month - 1; event = new Event(year, month_num, 1); month_name = event.getMonthName(); year = event.getYearNumber(); if (month < 10) { sql = \"SELECT * FROM event WHERE date LIKE '\" + year + \"-0\" + month + \"-%'\"; } else { sql = \"SELECT * FROM event WHERE date LIKE '\" + year + \"-\" + month + \"-%'\"; } } else { event = new Event(); month_name = event.getMonthName(); month = event.getMonthNumber() + 1; year = event.getYearNumber(); sql = \"SELECT * FROM event WHERE date LIKE '\" + year + \"-%\" + month + \"-%'\"; } try { dbStatement = connection.createStatement(); dbResultSet = dbStatement.executeQuery(sql); request.setAttribute(\"resultset\", dbResultSet); request.setAttribute(\"year\", Integer.toString(year)); request.setAttribute(\"month\", Integer.toString(month)); request.setAttribute(\"month_name\", month_name); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/edit_events.jsp\"); dispatcher.forward(request, response); return; } catch (SQLException e) { notice = \"Error retrieving events from the database.\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/index.jsp\"); dispatcher.forward(request, response); return; } } else if (action.equals(\"edit_event\")) { int id = Integer.parseInt(request.getParameter(\"id\")); Event event = new Event(); event = event.getEvent(id); if (event != null) { request.setAttribute(\"event\", event); request.setAttribute(\"id\", Integer.toString(id)); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/add_event.jsp\"); dispatcher.forward(request, response); return; } else { notice = \"Error retrieving event from the database.\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/index.jsp\"); dispatcher.forward(request, response); return; } } else if (action.equals(\"save_event\")) { String title = request.getParameter(\"title\"); String description = request.getParameter(\"description\"); String month = request.getParameter(\"month\"); String day = request.getParameter(\"day\"); String year = request.getParameter(\"year\"); String start_time = \"\"; String end_time = \"\"; if (request.getParameter(\"all_day\") == null) { String start_hour = request.getParameter(\"start_hour\"); String start_minutes = request.getParameter(\"start_minutes\"); String start_ampm = request.getParameter(\"start_ampm\"); String end_hour = request.getParameter(\"end_hour\"); String end_minutes = request.getParameter(\"end_minutes\"); String end_ampm = request.getParameter(\"end_ampm\"); if (Integer.parseInt(start_hour) < 10) { start_hour = \"0\" + start_hour; } if (Integer.parseInt(end_hour) < 10) { end_hour = \"0\" + end_hour; } start_time = start_hour + \":\" + start_minutes + \" \" + start_ampm; end_time = end_hour + \":\" + end_minutes + \" \" + end_ampm; } Event event = null; if (!start_time.equals(\"\") && !end_time.equals(\"\")) { event = new Event(title, description, month, day, year, start_time, end_time); } else { event = new Event(title, description, month, day, year); } if (event.saveEvent()) { notice = \"Calendar event saved!\"; request.setAttribute(\"notice\", notice); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/index.jsp\"); dispatcher.forward(request, response); return; } else { notice = \"Error saving calendar event.\"; request.setAttribute(\"notice\", notice); request.setAttribute(\"event\", event); RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(\"/admin/add_event.jsp\"); dispatcher.forward(request, response); return; } } else if (action.equals(\"update_event\")) { String title = request.getParameter(\"title\"); String description = request.getParameter(\"description\"); String month = request.getParameter(\"month\"); String day = request.getParameter(\"day",
        "ground_truth": "YES",
        "predict": "\"); String year = request.getParameter(\"year\"); String start_time = \"\"; String end_time = \"\"; if (request.getParameter(\"all_day\") == null) { String start_hour = request.getParameter(\"start_hour\"); String start_minutes = request.getParameter(\"start_minutes\"); String start_ampm = request.getParameter(\"start_ampm\"); String end_hour = request.getParameter(\"end_hour\"); String end_minutes = request.getParameter(\"end_minutes\"); String end_ampm = request.getParameter(\"end_ampm\"); if (Integer.parseInt(start_hour) < 10) { start_hour = \"0\" + start_hour; } if (Integer.parseInt(end_hour) < 10) { end_hour = \"0\" + end_hour; } start_time = start_hour + \":\" + start_minutes + \" \" + start_ampm; end_time ="
    },
    {
        "ID": 1018,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: @Override public String fetchElectronicEdition(Publication pub) { final String url = baseURL + pub.getKey() + \".html\"; logger.info(\"fetching pub ee from local cache at: \" + url); HttpMethod method = null; String responseBody = \"\"; method = new GetMethod(url); method.setFollowRedirects(true); try { if (StringUtils.isNotBlank(method.getURI().getScheme())) { InputStream is = null; StringWriter writer = new StringWriter(); try { client.executeMethod(method); Header contentType = method.getResponseHeader(\"Content-Type\"); if (contentType != null && StringUtils.isNotBlank(contentType.getValue()) && contentType.getValue().indexOf(\"text/html\") >= 0) { is = method.getResponseBodyAsStream(); IOUtils.copy(is, writer); responseBody = writer.toString(); } else { logger.info(\"ignoring non-text/html response from page: \" + url + \" content-type:\" + contentType); } } catch (HttpException he) { logger.error(\"Http error connecting to '\" + url + \"'\"); logger.error(he.getMessage()); } catch (IOException ioe) { logger.error(\"Unable to connect to '\" + url + \"'\"); } finally { IOUtils.closeQuietly(is); IOUtils.closeQuietly(writer); } } } catch (URIException e) { logger.error(e); } finally { method.releaseConnection(); } return responseBody; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void callService() { try { URL url = new URL(baseUrl + servicePath + attributes); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; StringBuffer buf = new StringBuffer(); while ((inputLine = in.readLine()) != null) { buf.append(inputLine); } in.close(); answer = buf.toString(); } catch (MalformedURLException e) { answer = \"Malformed Url:\" + e.getMessage(); return; } catch (IOException e) { answer = \"I/O exception: \" + e.getMessage(); return; } }. \n Code2: public void createTempFile(String resourceName) throws IOException { InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName); if (input == null) { fail(\"Couldn't resolve resource '\" + resourceName + \"'!\"); } inputFile = File.createTempFile(\"Import\", \"test\"); inputFile.delete(); FileOutputStream output =",
        "ground_truth": "NO",
        "predict": " new FileOutputStream(inputFile); IOUtils.copy(input, output); input.close(); output.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void callService() { try { URL url = new URL(baseUrl + servicePath + attributes); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; StringBuffer buf = new StringBuffer(); while ((inputLine = in.readLine()) != null) { buf.append(inputLine); } in.close(); answer = buf.toString(); } catch (MalformedURLException e) { answer = \"Malformed Url:\" + e.getMessage(); return; } catch (IOException e) { answer = \"I/O exception: \" + e.getMessage(); return; } }. \n Code2: public void createTemp"
    },
    {
        "ID": 1024,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public FlashExObj get(String s, int page) { FlashExObj retVal = new FlashExObj(); s = s.replaceAll(\"[^a-z0-9_]\", \"\"); ArrayList list = new ArrayList(); retVal.list = list; try { String result = null; URL url = new URL(\"http://www.flashcardexchange.com/flashcards/list/\" + URLEncoder.encode(s, \"UTF-8\") + \"?page=\" + page); URLConnection connection = url.openConnection(); connection.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"); connection.setDoOutput(false); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); String inputLine; int state = 2; StringBuilder sb = new StringBuilder(); while ((inputLine = in.readLine()) != null) { if (state == 0) { int textPos = inputLine.indexOf(\"Number of Card\"); if (textPos >= 0) { state = 1; } } else if (state == 1) { int s1 = inputLine.indexOf(\">\"); int s2 = inputLine.indexOf(\"<\", 1); if (s1 >= 0 && s1 < s2) { String numOfCardStr = inputLine.substring(s1 + 1, s2); try { } catch (Exception e) { } state = 2; } } else if (state == 2) { int textPos = inputLine.indexOf(\"tbody class=\\\"shaded\\\"\"); if (textPos >= 0) { state = 3; } } else if (state == 3) { int textPos = inputLine.indexOf(\"tbody\"); if (textPos >= 0) { break; } sb.append(inputLine); sb.append(\" \"); } } in.close(); Pattern myPattern = Pattern.compile(\"<td>(.*?)</td>\"); Matcher myMatcher = myPattern.matcher(sb); String str; int counter = 0; String buff[] = new String[4]; while (myMatcher.find()) { int tt = counter % 4; buff[tt] = myMatcher.group(1); if (tt == 3) { String toAdd[] = new String[2]; toAdd[0] = buff[1]; toAdd[1] = buff[2]; list.add(toAdd); } counter++; } } catch (Exception e) { e.printStackTrace(); } return retVal; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public FTPFile[] connect() { if (ftpe == null) { ftpe = new FTPEvent(this); } if (ftp == null) { ftp = new FTPClient(); } else if (ftp.isConnected()) { path = \"\"; try { ftp.disconnect(); } catch (IOException e1) { log.error(\"could not disconnect -\" + e1.getMessage()); } } currentDir = new FTPFile[0]; log.debug(\"try to connect\"); try { int reply; ftp.connect(ftpsite); reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); log.error(\"FTP server refused connection.\"); } } catch (IOException e) { log.error(\"FTPConnection error: \" + e.getMessage()); if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException f) { } } } try { if (!ftp.login(user, password)) { log.error(\"could not login with: \" + user); ftp.logout(); } log.debug(\"Remote system is \" + ftp.getSystemName()); ftp.enterLocalPassiveMode(); currentDir = ftp.listFiles(); } catch (FTPConnectionClosedException e) { log.error(\"FTPConnectionClosedException: \" + e.getMessage()); } catch (IOException e) { log.error(\"IOException: \" + e.getMessage()); } ftpe.setType(FTPEvent.CONNECT); fireFTPEvent(ftpe); return currentDir; }. \n Code2: public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) { FileReader reader = null; Writer writer = null; try { reader = new FileReader(sourceFile); logger.info(\"Using source file: \" + trimPath(userDir, sourceFile)); if (!destinationFile.getParentFile().exists()) { createDirectory(destinationFile.getParentFile()); } writer = new FileWriter(destinationFile); logger.info(\"Destination file: \" + trimPath(userDir, destinationFile)); execute(reader, writer, conversionType, java2HtmlConfig); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (writer != null) { try { writer.close(); writer = null;",
        "ground_truth": "NO",
        "predict": " } catch (IOException e) { } } if (reader != null) { try { reader.close(); reader = null; } catch (IOException e) { } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) { FileReader reader = null; Writer writer = null; try { reader = new FileReader(sourceFile); logger.info(\"Using source file: \" + trimPath(userDir, sourceFile)); if (!destinationFile.getParentFile().exists()) { createDirectory(destinationFile.getParentFile()); } writer = new FileWriter(destinationFile); logger.info(\"Destination file: \" + trimPath(userDir, destinationFile)); execute(reader, writer, conversionType, java2HtmlConfig); } catch (FileNotFoundException"
    },
    {
        "ID": 1029,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void actionPerformed(ActionEvent e) { if (path.compareTo(\"\") != 0) { imageName = (path.substring(path.lastIndexOf(File.separator) + 1, path.length())); String name = imageName.substring(0, imageName.lastIndexOf('.')); String extension = imageName.substring(imageName.lastIndexOf('.') + 1, imageName.length()); File imageFile = new File(path); directoryPath = \"images\" + File.separator + imageName.substring(0, 1).toUpperCase(); File directory = new File(directoryPath); directory.mkdirs(); imagePath = \".\" + File.separator + \"images\" + File.separator + imageName.substring(0, 1).toUpperCase() + File.separator + imageName; File newFile = new File(imagePath); if (myImagesBehaviour.equals(TLanguage.getString(\"TIGManageGalleryDialog.REPLACE_IMAGE\"))) { Vector<Vector<String>> aux = TIGDataBase.imageSearchByName(name); if (aux.size() != 0) { int idImage = TIGDataBase.imageKeySearchName(name); TIGDataBase.deleteAsociatedOfImage(idImage); } } if (myImagesBehaviour.equals(TLanguage.getString(\"TIGManageGalleryDialog.ADD_IMAGE\"))) { int i = 1; while (newFile.exists()) { imagePath = \".\" + File.separator + \"images\" + File.separator + imageName.substring(0, 1).toUpperCase() + File.separator + imageName.substring(0, imageName.lastIndexOf('.')) + \"_\" + i + imageName.substring(imageName.lastIndexOf('.'), imageName.length()); name = name + \"_\" + i; newFile = new File(imagePath); i++; } } imagePathThumb = (imagePath.substring(0, imagePath.lastIndexOf(\".\"))).concat(\"_th.jpg\"); imageName = name + \".\" + extension; try { FileChannel srcChannel = new FileInputStream(path).getChannel(); FileChannel dstChannel = new FileOutputStream(imagePath).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException exc) { System.out.println(exc.getMessage()); System.out.println(exc.toString()); } TIGDataBase.insertDB(theConcepts, imageName, imageName.substring(0, imageName.lastIndexOf('.'))); image = null; if (imageFile != null) { if (TFileUtils.isJAIRequired(imageFile)) { RenderedOp src = JAI.create(\"fileload\", imageFile.getAbsolutePath()); BufferedImage bufferedImage = src.getAsBufferedImage(); image = new ImageIcon(bufferedImage); } else { image = new ImageIcon(imageFile.getAbsolutePath()); } if (image.getImageLoadStatus() == MediaTracker.ERRORED) { int choosenOption = JOptionPane.NO_OPTION; choosenOption = JOptionPane.showConfirmDialog(null, TLanguage.getString(\"TIGInsertImageAction.MESSAGE\"), TLanguage.getString(\"TIGInsertImageAction.NAME\"), JOptionPane.CLOSED_OPTION, JOptionPane.ERROR_MESSAGE); } else { createThumbnail(); } } } }. \n Code2: public void save(InputStream is) throws IOException { File dest = Config.getDataFile(getInternalDate(), getPhysMessageID()); OutputStream os = null; try { os = new FileOutputStream(dest); IOUtils.copyLarge(is, os); } finally { IOUtils.closeQuietly(os); IOUtils.closeQuietly(is); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception { if (normaliseWhitespace) { profileDiff = removeWhitespaces(profileDiff); } MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(profileDiff.getBytes()); return new BASE64Encoder().encode(md.digest()); }. \n Code2: public static void createTar(File directoryToPack, File targetTarFile) throws IOException { if (directoryToPack == null) { throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\"); } if (targetTarFile == null) { throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\"); } if (!directoryToPack.exists() || !directoryToPack.isDirectory()) { throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\"); } if (targetTarFile.exists()) { log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\"); } log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\"); byte buffer[] = new byte[BUFFER_SIZE]; FileOutputStream targetOutput = new FileOutputStream(targetTarFile); TarOutputStream targetOutputTar = new TarOutputStream(targetOutput); try { List<File> fileList = collectFiles(directoryToPack); for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) { File file = iter.next(); if (file == null || !file.exists() || file.isDirectory()) { log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\"); continue; } if (file.equals(targetTarFile)) { log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\"); continue; } log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\"); String filePathInTar = getFilePathInTar(file, directoryToPack); log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\"); TarEntry tarAdd = new TarEntry(file); tarAdd.setModTime(file.lastModified()); tarAdd.setName(filePathInTar); targetOutputTar.putNextEntry(tarAdd); if (file.isFile()) { FileInputStream in = new FileInputStream(file); try { while (true) { int nRead = in.read(buffer, 0, buffer.length); if (nRead <= 0) break; targetOutputTar.write(buffer, 0",
        "ground_truth": "NO",
        "predict": ", nRead); } } finally { IOUtils.closeQuietly(in); } } } } } finally { targetOutputTar.close(); targetOutput.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static String getFilePathInTar(File file, File directoryToPack) throws IOException { if (file == null) { throw new NullPointerException(\"The parameter 'file' must not be null\"); } if (directoryToPack == null) { throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\"); } if (!file.exists() || !file.isFile()) { throw new IllegalArgumentException(\"The file '\" + file + \"' does not exist or is not a file.\"); } if (file.equals(directoryToPack)) { throw new IllegalArgumentException(\"The file '\" + file +"
    },
    {
        "ID": 1038,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testReadNormal() throws Exception { archiveFileManager.executeWith(new TemporaryFileExecutor() { public void execute(File temporaryFile) throws Exception { ZipArchive archive = new ZipArchive(temporaryFile.getPath()); InputStream input = archive.getInputFrom(ARCHIVE_FILE_1); if (input != null) { ByteArrayOutputStream output = new ByteArrayOutputStream(); IOUtils.copyAndClose(input, output); assertEquals(ARCHIVE_FILE_1 + \" contents not correct\", ARCHIVE_FILE_1_CONTENT, output.toString()); } else { fail(\"cannot open \" + ARCHIVE_FILE_1); } } }); }. \n Code2: @Override public void handler(Map<String, Match> result, TargetPage target) { List<String> lines = new LinkedList<String>(); List<String> page = new LinkedList<String>(); try { URL url = new URL(target.getUrl()); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"utf-8\")); String line = null; while ((line = reader.readLine()) != null) { page.add(line); } reader.close(); } catch (MalformedURLException e) { } catch (IOException e) { } try { result.put(\"27 svk par fix\", MatchEventFactory.getFix27()); result.put(\"41 svk ita fix\", MatchEventFactory.getFix41()); result.put(\"01 rsa mex\", MatchEventFactory.get01()); result.put(\"02 uru fra\", MatchEventFactory.get02()); result.put(\"04 kor gre\", MatchEventFactory.get04()); result.put(\"03 arg ngr\", MatchEventFactory.get03()); result.put(\"05 eng usa\", MatchEventFactory.get05()); result.put(\"06 alg slo\", MatchEventFactory.get06()); result.put(\"08 scg gha\", MatchEventFactory.get08()); result.put(\"07 ger aus\", MatchEventFactory.get07()); result.put(\"09 end den\", MatchEventFactory.get09()); result.put(\"10 jpn cmr\", MatchEventFactory.get10()); result.put(\"11 ita par\", MatchEventFactory.get11()); result.put(\"12 nzl svk\", MatchEventFactory.get12()); result.put(\"13 civ por\", MatchEventFactory.get13()); result.put(\"14 bra prk\", MatchEventFactory.get14()); result.put(\"15 hon chi\", MatchEventFactory.get15()); result.put(\"16 esp sui\", MatchEventFactory.get16()); result.put(\"17 rsa uru\", MatchEventFactory.get17()); result.put(\"20 arg kor\", MatchEventFactory.get20()); result.put(\"19 gre ngr\", MatchEventFactory.get19()); result.put(\"18 fra mex\", MatchEventFactory.get18()); result.put(\"21 ger scg\", MatchEventFactory.get21()); result.put(\"22 slo usa\", MatchEventFactory.get22()); result.put(\"23 eng alg\", MatchEventFactory.get23()); result.put(\"25 end jpn\", MatchEventFactory.get25()); result.put(\"24 gha aus\", MatchEventFactory.get24()); result.put(\"26 cmr den\", MatchEventFactory.get26()); result.put(\"27 slo par\", MatchEventFactory.get27()); result.put(\"28 ita nzl\", MatchEventFactory.get28()); result.put(\"29 bra civ\", MatchEventFactory.get29()); result.put(\"30 por prk\", MatchEventFactory.get30()); result.put(\"31 chi sui\", MatchEventFactory.get31()); result.put(\"32 esp hon\", MatchEventFactory.get32()); result.put(\"34 fra rsa\", MatchEventFactory.get34()); result.put(\"33 mex uru\", MatchEventFactory.get33()); result.put(\"35 ngr kor\", MatchEventFactory.get35()); result.put(\"36 gre arg\", MatchEventFactory.get36()); result.put(\"38 usa alg\", MatchEventFactory.get38()); result.put(\"37 slo eng\", MatchEventFactory.get37()); result.put(\"39 gha ger\", MatchEventFactory.get39()); result.put(\"40 aus scg\", MatchEventFactory.get40()); result.put(\"42 par nzl\", MatchEventFactory.get42()); result.put(\"41 slo ita\", MatchEventFactory.get41()); result.put(\"44 cmr ned\", MatchEventFactory.get44()); result.put(\"43 den jpn\", MatchEventFactory.get43()); result.put(\"45 por bra\", MatchEventFactory.get45()); result.put(\"46 prk civ\", MatchEventFactory.get46()); result.put(\"47 chi esp\", MatchEventFactory.get47()); result.put(\"48 sui hon\", MatchEventFactory.get48()); result.put(\"49 uru kor\", MatchEventFactory.get49Team()); result.put(\"50 usa gha\", MatchEventFactory.get50Team()); result.put(\"51 ger eng\", MatchEventFactory.get51Team()); result.put(\"52 arg mex\", MatchEventFactory.get52Team()); result.put(\"53 ned svk\", MatchEventFactory.get53Team()); result.put(\"54 bra chi\", MatchEventFactory.get54Team()); result.put(\"55 par jpn\", MatchEventFactory.get55Team()); result.put(\"56 esp por\", MatchEventFactory.get56Team()); result.put(\"57 ned bra\", MatchEventFactory.get57Team()); result.put(\"58 uru gha\", MatchEventFactory.get58Team()); result.put(\"59 arg ger\", MatchEventFactory.get59Team()); result.put(\"49\", MatchEventFactory.get49()); result.put(\"50\", MatchEventFactory.get50()); result.put(\"51\", MatchEventFactory.get51()); result.put(\"52\", MatchEventFactory.get52()); result.put(\"53\", MatchEventFactory.get53()); result.put(\"54\", MatchEventFactory.get54()); this.stage2MatchHandler(\"318295\", \"55\", \"2010-06-29 22:30\", result); this.stage2MatchHandler(\"318296\", \"56\", \"2010-06-30 02:30\", result); this.stage2MatchHandler(\"318297\", \"57\", \"2010-07-02 22:00\", result); this.stage2MatchHandler(\"318298\", \"58\", \"2010-07-03 02:30\", result); this.stage2MatchHandler(\"318299\", \"59\", \"2010-07-03 22:00\", result); this.stage2MatchHandler(\"318300\", \"60\", \"2010-07-04 02:30\", result); this.stage2MatchHandler(\"318301\", \"61\", \"2010-07-07 02:30\", result); this.stage2MatchHandler(\"318302",
        "ground_truth": "NO",
        "predict": "\", \"62\", \"2010-07-07 22:00\", result); this.stage2MatchHandler(\"318303\", \"63\", \"2010-07-08 02:30\", result); this.stage2MatchHandler(\"318304\", \"64\", \"2010-07-09 02:30\", result); this.stage2MatchHandler(\"318305\", \"65\", \"2010-07-09 22:00\", result); this.stage2MatchHandler(\"318306\", \"66\", \"2010-07-10 02:30\", result); this.stage2MatchHandler(\"318307\", \"67\", \"2010-07-10 22:00\", result); this.stage2MatchHandler(\"318308\", \"68\", \"2010-07-11 02:30\", result); this.stage2MatchHandler(\"318309\", \"69\", \"2010-07-11 22:00\", result); this.stage2MatchHandler(\"318310\", \"70\", \"2010-07-12 02:30\", result"
    },
    {
        "ID": 1052,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void service(TranslationRequest request, TranslationResponse response) { try { Thread.sleep((long) Math.random() * 250); } catch (InterruptedException e1) { } hits.incrementAndGet(); String key = getKey(request); RequestResponse cachedResponse = cache.get(key); if (cachedResponse == null) { response.setEndState(new ResponseStateBean(ResponseCode.ERROR, \"response not found for \" + key)); return; } response.addHeaders(cachedResponse.getExpectedResponse().getHeaders()); response.setTranslationCount(cachedResponse.getExpectedResponse().getTranslationCount()); response.setFailCount(cachedResponse.getExpectedResponse().getFailCount()); if (cachedResponse.getExpectedResponse().getLastModified() != -1) { response.setLastModified(cachedResponse.getExpectedResponse().getLastModified()); } try { OutputStream output = response.getOutputStream(); InputStream input = cachedResponse.getExpectedResponse().getInputStream(); try { IOUtils.copy(input, output); } finally { IOUtils.closeQuietly(input); IOUtils.closeQuietly(output); } } catch (IOException e) { response.setEndState(new ResponseStateException(e)); return; } response.setEndState(cachedResponse.getExpectedResponse().getEndState()); }. \n Code2: protected long loadFromSource(long afterThisTime) { long startTime = System.currentTimeMillis(); QuoteDataSourceDescriptor quoteDataSourceDescriptor = (QuoteDataSourceDescriptor) dataSourceDescriptor; List<Quote> dataPool = dataPools.get(quoteDataSourceDescriptor.sourceSymbol); Calendar calendar = Calendar.getInstance(); calendar.clear(); SimpleDateFormat sdf = new SimpleDateFormat(quoteDataSourceDescriptor.dateFormat, Locale.US); Date fromDate = new Date(); Date toDate = new Date(); if (afterThisTime == FIRST_TIME_LOAD) { fromDate = quoteDataSourceDescriptor.fromDate; toDate = quoteDataSourceDescriptor.toDate; } else { calendar.setTimeInMillis(afterThisTime); fromDate = calendar.getTime(); } calendar.setTime(fromDate); int a = calendar.get(Calendar.MONTH); int b = calendar.get(Calendar.DAY_OF_MONTH); int c = calendar.get(Calendar.YEAR); calendar.setTime(toDate); int d = calendar.get(Calendar.MONTH); int e = calendar.get(Calendar.DAY_OF_MONTH); int f = calendar.get(Calendar.YEAR); BufferedReader dis; StringBuffer urlStr = new StringBuffer(); urlStr.append(\"http://table.finance.yahoo.com/table.csv\").append(\"?s=\"); urlStr.append(quoteDataSourceDescriptor.sourceSymbol); urlStr.append(\"&a=\" + a + \"&b=\" + b + \"&c=\" + c + \"&d=\" + d + \"&e=\" + e + \"&f=\" + f); urlStr.append(\"&g=d&ignore=.csv\"); try { URL url = new URL(urlStr.toString()); System.out.println(url); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setAllowUserInteraction(true); conn.setRequestMethod(\"GET\"); conn.setInstanceFollowRedirects(true); InputStreamReader isr = new InputStreamReader(conn.getInputStream()); dis = new BufferedReader(isr); String s = dis.readLine(); int iDateTime = 0; int iOpen = 1; int iHigh = 2; int iLow = 3; int iClose = 4; int iVolume = 5; int iAdjClose = 6; count = 0; calendar.clear(); while ((s = dis.readLine()) != null) { String[] items; items = s.split(\",\"); if (items.length < 6) { break; } Date date = null; try { date = sdf.parse(items[iDateTime].trim()); } catch (ParseException ex) { ex.printStackTrace(); continue; } calendar.clear(); calendar.setTime(date); long time = calendar.getTimeInMillis(); if (time <= afterThisTime) { continue; } Quote quote = new Quote(); quote.time = time; quote.open = Float.parseFloat(items[iOpen].trim()); quote.high = Float.parseFloat(items[iHigh].trim()); quote.low = Float.parseFloat(items[iLow].trim()); quote.close = Float.parseFloat(items[iClose].trim()); quote.volume = Float.parseFloat(items[iVolume].trim()) / 100f; quote.amount = -1; quote.close_adj = Float.parseFloat(items[iAdjClose].trim()); if (quote.high * quote.low * quote.close == 0) { quote = null; continue; } dataPool.add(quote); if (count == 0) { firstTime = time; } lastTime = time; setAscending((lastTime >= firstTime) ? true : false); count++; } } catch (Exception ex) { System.out.println(\"Error in Reading File: \" + ex.getMessage()); } long newestTime = (lastTime >= firstTime) ? lastTime : firstTime; return newestTime; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static File getZipAsFile(DigitalObject digOb) { String folderName = randomizeFileName(getFolderNameFromDigObject(digOb)); File tmpFolder = new File(utils_tmp, folderName); File zip = null; try { FileUtils.forceMkdir(tmpFolder); zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null)); FileOutputStream out = new FileOutputStream(zip); IOUtils.copyLarge(digOb.getContent().getInputStream(), out); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return zip; }. \n Code2: public static String generate(boolean secure, boolean sep) throws UnknownHostException { MessageDigest messagedigest; StringBuilder stringbuffer = new StringBuilder(); try { messagedigest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException nosuchalgorithmexception) { throw new RuntimeException(nosuchalgorithmexception); } StringBuffer stringbuffer2; InetAddress inetaddress = InetAddress.getLocalHost(); long l = System.currentTimeMillis(); long l1 =",
        "ground_truth": "NO",
        "predict": " l; long l2 = l; long l3 = l; long l4 = l; long l5 = l; long l6 = l; long l7 = l; long l8 = l; long l9 = l; long l10 = l; long l11 = l; long l12 = l; long l13 = l; long l14 = l; long l15 = l; long l16 = l; long l17 = l; long l18 = l; long l19 = l; long l20 = l; long l21 = l; long l22 = l; long l23 = l; long l24 = l; long l25 = l; long l26 = l; long l27 = l; long l28 = l; long l29 = l; long l30 = l; long l31 = l; long l32 = l; long l33 = l; long l34 = l; long l35 = l; long l36 = l; long l37 ="
    },
    {
        "ID": 1057,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static final long copyFile(final File srcFile, final File dstFile, final long cpySize) throws IOException { if ((null == srcFile) || (null == dstFile)) return (-1L); final File dstFolder = dstFile.getParentFile(); if ((!dstFolder.exists()) && (!dstFolder.mkdirs())) throw new IOException(\"Failed to created destination folder(s)\"); FileChannel srcChannel = null, dstChannel = null; try { srcChannel = new FileInputStream(srcFile).getChannel(); dstChannel = new FileOutputStream(dstFile).getChannel(); final long srcLen = srcFile.length(), copyLen = dstChannel.transferFrom(srcChannel, 0, (cpySize < 0L) ? srcLen : cpySize); if ((cpySize < 0L) && (copyLen != srcLen)) return (-2L); return copyLen; } finally { FileUtil.closeAll(srcChannel, dstChannel); } }. \n Code2: private void doTask() { try { log(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\"); log(\" =================================================\"); log(\" = Starting PSCafePOS =\"); log(\" =================================================\"); log(\" = An open source point of sale system =\"); log(\" = for educational organizations. =\"); log(\" =================================================\"); log(\" = General Information =\"); log(\" = http://pscafe.sourceforge.net =\"); log(\" = Free Product Support =\"); log(\" = http://www.sourceforge.net/projects/pscafe =\"); log(\" =================================================\"); log(\" = License Overview =\"); log(\" =================================================\"); log(\" = PSCafePOS is a POS System for Schools =\"); log(\" = Copyright (C) 2007 Charles Syperski =\"); log(\" = =\"); log(\" = This program is free software; you can =\"); log(\" = redistribute it and/or modify it under the =\"); log(\" = terms of the GNU General Public License as =\"); log(\" = published by the Free Software Foundation; =\"); log(\" = either version 2 of the License, or any later =\"); log(\" = version. =\"); log(\" = =\"); log(\" = This program is distributed in the hope that =\"); log(\" = it will be useful, but WITHOUT ANY WARRANTY; =\"); log(\" = without even the implied warranty of =\"); log(\" = MERCHANTABILITY or FITNESS FOR A PARTICULAR =\"); log(\" = PURPOSE. =\"); log(\" = =\"); log(\" = See the GNU General Public License for more =\"); log(\" = details. =\"); log(\" = =\"); log(\" = You should have received a copy of the GNU =\"); log(\" = General Public License along with this =\"); log(\" = program; if not, write to the =\"); log(\" = =\"); log(\" = Free Software Foundation, Inc. =\"); log(\" = 59 Temple Place, Suite 330 =\"); log(\" = Boston, MA 02111-1307 USA =\"); log(\" =================================================\"); log(\" = If you have any questions of comments please =\"); log(\" = let us know at http://pscafe.sourceforge.net =\"); log(\" =================================================\"); pause(); File settings; if (blAltSettings) { System.out.println(\"\\n + Alternative path specified at run time:\"); System.out.println(\" Path: \" + strAltPath); settings = new File(strAltPath); } else { settings = new File(\"etc\" + File.separatorChar + \"settings.dbp\"); } System.out.print(\"\\n + Checking for existance of settings...\"); boolean blGo = false; if (settings.exists() && settings.canRead()) { log(\"[OK]\"); blGo = true; if (forceConfig) { System.out.print(\"\\n + Running Config Wizard (at user request)...\"); Process pp = Runtime.getRuntime().exec(\"java -cp.PSSettingWizard etc\" + File.separatorChar + \"settings.dbp\"); InputStream stderr = pp.getErrorStream(); InputStream stdin = pp.getInputStream(); InputStreamReader isr = new InputStreamReader(stdin); BufferedReader br = new BufferedReader(isr); String ln = null; while ((ln = br.readLine()) != null) System.out.println(\" \" + ln); pp.waitFor(); } } else { log(\"[FAILED]\"); settings = new File(\"etc\" + File.separatorChar + \"settings.dbp.firstrun\"); System.out.print(\"\\n + Checking if this is the first run... \"); if (settings.exists() && settings.canRead()) { log(\"[FOUND]\"); File toFile = new File(\"etc\" + File.separatorChar + \"settings.dbp\"); FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(settings); to = new FileOutputStream(toFile); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } if (toFile.exists() && toFile.canRead()) { settings = null; settings = new File(\"etc\" + File.separatorChar + \"settings.dbp\"); } System.out.print(\"\\n + Running Settings Wizard... \"); try { Process p = Runtime.getRuntime().exec(\"java PSSettingWizard etc\" + File.separatorChar + \"settings.dbp\"); InputStream stderr = p.getErrorStream(); InputStream stdin = p.getInputStream(); InputStreamReader isr = new InputStreamReader(stdin); BufferedReader br = new BufferedReader(isr); String ln = null; while ((ln = br.readLine()) != null) System.out.println(\" \" + ln); p.waitFor(); log(\"[OK]\"); if (p.exitValue() == 0) blGo = true; } catch (InterruptedException i) { System.err.println(i.getMessage()); } } catch (Exception ex) { System.err.println(ex.getMessage()); } finally { if (from != null) try { from.close(); } catch (IOException e) { ; } if (to != null) try { to.close(); } catch (IOException e) { ; } } } else { settings = null; settings = new File(\"etc\" + File.separatorChar + \"settings.dbp\"); DBSettingsWriter writ = new DBSettingsWriter(); writ.writeFile(new DBSettings(), settings); blGo = true; } } if (blGo) { String cp = \".\"; try { File classpath = new File(\"lib\"); File[] subFiles = classpath.listFiles(); for (int i = 0; i < subFiles.length; i++) { if (subFiles[i].isFile()) { cp += File.pathSeparatorChar + \"lib\" + File.separatorChar",
        "ground_truth": "NO",
        "predict": " + subFiles[i].getName(); } } } catch (Exception e) { ; } System.out.print(\"\\n + Running PSCafePOS...\"); System.out.println(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n"
    },
    {
        "ID": 1062,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private boolean copy_to_file_io(File src, File dst) throws IOException { InputStream is = null; OutputStream os = null; try { is = new FileInputStream(src); is = new BufferedInputStream(is); os = new FileOutputStream(dst); os = new BufferedOutputStream(os); byte buffer[] = new byte[1024 * 64]; int read; while ((read = is.read(buffer)) > 0) { os.write(buffer, 0, read); } return true; } finally { try { if (is != null) is.close(); } catch (IOException e) { Debug.debug(e); } try { if (os != null) os.close(); } catch (IOException e) { Debug.debug(e); } } }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean import_hints(String filename) { int pieceId; int i, col, row; int rotation; int number; boolean byurl = true; e2piece temppiece; String lineread; StringTokenizer tok; BufferedReader entree; try { if (byurl == true) { URL url = new URL(baseURL, filename); InputStream in = url.openStream(); entree = new BufferedReader(new InputStreamReader(in)); } else { entree = new BufferedReader(new FileReader(filename)); } pieceId = 0; lineread = entree.readLine(); tok = new StringTokenizer(lineread, \" \"); number = Integer.parseInt(tok.nextToken()); for (i = 0; i < number; i++) { lineread = entree.readLine(); if (lineread == null) { break; } tok = new StringTokenizer(lineread, \" \"); pieceId = Integer.parseInt(tok.nextToken()); col = Integer.parseInt(tok.nextToken()) - 1; row = Integer.parseInt(tok.nextToken()) - 1; rotation = Integer.parseInt(tok.nextToken()); System.out.println(\"placing hint piece : \" + pieceId); place_piece_at(pieceId, col, row, 0); temppiece = board.get_piece_at(col, row); temppiece.reset_rotation(); temppiece.rotate(rotation); temppiece.set_as_hint(); } return true; } catch (IOException err) { return false; } }. \n Code2: public static void copy(File from, File to) { boolean result; if (from.isDirectory()) { File[] subFiles = from.listFiles(); for (int i = 0; i < subFiles.length; i++) { File newDir = new File(to, subFiles[i].getName()); result = false; if (subFiles[i].isDirectory()) { if (newDir.exists()) result = true; else result = newDir.mkdirs(); } else if (subFiles[i].isFile()) { try { result = newDir.createNewFile(); } catch (IOException e) { log.error(\"unable to create new file: \" + newDir, e); result = false; } } if (result) copy(subFiles[i], newDir); } } else if (from.isFile()) { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(from); out = new FileOutputStream(to);",
        "ground_truth": "NO",
        "predict": " byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead); } catch (IOException e) { log.error(\"unable to copy file: \" + from, e); } finally { try { if (in != null) in.close(); } catch (IOException e) { log.error(\"unable to close input stream: \" + from, e); } try { if (out != null) out.close(); } catch (IOException e) { log.error(\"unable to close output stream: \" + to, e); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean import_hints(String filename) { int pieceId; int i, col, row; int rotation; int number; boolean byurl = true; e"
    },
    {
        "ID": 1065,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public TVRageShowInfo(String xmlShowName, String xmlSearchBy) { String[] tmp, tmp2; String line = \"\"; this.usrShowName = xmlShowName; try { URL url = new URL(\"http://www.tvrage.com/quickinfo.php?show=\" + xmlShowName.replaceAll(\" \", \"%20\")); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while ((line = in.readLine()) != null) { tmp = line.split(\"@\"); if (tmp[0].equals(\"Show Name\")) showName = tmp[1]; if (tmp[0].equals(\"Show URL\")) showURL = tmp[1]; if (tmp[0].equals(\"Latest Episode\")) { StringTokenizer st = new StringTokenizer(tmp[1], \"^\"); for (int i = 0; st.hasMoreTokens(); i++) { if (i == 0) { tmp2 = st.nextToken().split(\"x\"); latestSeasonNum = tmp2[0]; latestEpisodeNum = tmp2[1]; if (latestSeasonNum.charAt(0) == '0') latestSeasonNum = latestSeasonNum.substring(1); } else if (i == 1) latestTitle = st.nextToken().replaceAll(\"&\", \"and\"); else latestAirDate = st.nextToken(); } } if (tmp[0].equals(\"Next Episode\")) { StringTokenizer st = new StringTokenizer(tmp[1], \"^\"); for (int i = 0; st.hasMoreTokens(); i++) { if (i == 0) { tmp2 = st.nextToken().split(\"x\"); nextSeasonNum = tmp2[0]; nextEpisodeNum = tmp2[1]; if (nextSeasonNum.charAt(0) == '0') nextSeasonNum = nextSeasonNum.substring(1); } else if (i == 1) nextTitle = st.nextToken().replaceAll(\"&\", \"and\"); else nextAirDate = st.nextToken(); } } if (tmp[0].equals(\"Status\")) status = tmp[1]; if (tmp[0].equals(\"Airtime\") && tmp.length > 1) { airTime = tmp[1]; } } if (airTime.length() > 10) { tmp = airTime.split(\"at\"); airTimeHour = tmp[1]; } in.close(); if (xmlSearchBy.equals(\"Showname SeriesNum\")) { url = new URL(showURL); in = new BufferedReader(new InputStreamReader(url.openStream())); while ((line = in.readLine()) != null) { if (line.indexOf(\"<b>Latest Episode: </b>\") > -1) { tmp = line.split(\"'>\"); if (tmp[5].indexOf(':') > -1) { tmp = tmp[5].split(\":\"); latestSeriesNum = tmp[0]; } } else if (line.indexOf(\"<b>Next Episode: </b>\") > -1) { tmp = line.split(\"'>\"); if (tmp[3].indexOf(':') > -1) { tmp = tmp[3].split(\":\"); nextSeriesNum = tmp[0]; } } } in.close(); } } catch (MalformedURLException e) { } catch (IOException e) { } }. \n Code2: private void enumeratePathArchive(final String archive) throws IOException { final boolean trace1 = m_trace1; final File fullArchive = new File(m_currentPathDir, archive); JarInputStream in = null; try { in = new JarInputStream(new BufferedInputStream(new FileInputStream(fullArchive), 32 * 1024)); final IPathHandler handler = m_handler; Manifest manifest = in.getManifest(); if (manifest == null) manifest = readManifestViaJarFile(fullArchive); handler.handleArchiveStart(m_currentPathDir, new File(archive), manifest); for (ZipEntry entry; (entry = in.getNextEntry()) != null; ) { if (trace1) m_log.trace1(\"enumeratePathArchive\", \"processing archive entry [\" + entry.getName() + \"] ...\"); handler.handleArchiveEntry(in, entry); in.closeEntry(); } if (m_processManifest) { if (manifest == null) manifest = in.getManifest(); if (manifest != null) { final Attributes attributes = manifest.getMainAttributes(); if (attributes != null) { final String jarClassPath = attributes.getValue(Attributes.Name.CLASS_PATH); if (jarClassPath != null) { final StringTokenizer tokenizer = new StringTokenizer(jarClassPath); for (int p = 1; tokenizer.hasMoreTokens(); ) { final String relPath = tokenizer.nextToken(); final File archiveParent = fullArchive.getParentFile(); final File path = archiveParent != null ? new File(archiveParent, relPath) : new File(relPath); final String fullPath = m_canonical ? Files.canonicalizePathname(path.getPath()) : path.getPath(); if (m_pathSet.add(fullPath)) { if (m_verbose) m_log.verbose(\" added manifest Class-Path entry [\" + path + \"]\"); m_path.add(m_pathIndex + (p++), path); } } } } } } } catch (FileNotFoundException fnfe) { if ($assert.ENABLED) throw fnfe; } finally { if (in != null) try { in.close(); } catch (Exception ignore) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fileDownload(String fAddress, String destinationDir) { int slashIndex = fAddress.lastIndexOf('/'); int periodIndex = fAddress.lastIndexOf('.'); String fileName = fAddress.substring(slashIndex + 1); URL url; try { url = new URL(fAddress); URLConnection uc = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream())); File file = new File(destinationDir + \"/download.pdf\"); FileOutputStream fos = new FileOutputStream(file); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos)); int inputLine; while ((inputLine = in.read()) != -1) out.write(inputLine); in.close(); } catch (Exception ex) { Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex); } }. \n Code2: public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException { AQUtility.debug(\"net\", urlPath); URL url = new URL(url",
        "ground_truth": "NO",
        "predict": "Path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setReadTimeout(5000); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:25.0) Gecko/20100101 Firefox/25.0\"); conn.setRequestProperty(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"); conn.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\"); conn.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\"); conn.setRequestProperty(\"DNT\", \"1\"); conn.setRequestProperty(\"Connection\", \"keep-alive\"); conn.setRequestProperty(\"Referer\", \"http://www.google.com/\"); conn"
    },
    {
        "ID": 1077,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void convertClasses(File source, File destination) throws PostProcessingException, CodeCheckException, IOException { Stack sourceStack = new Stack(); Stack destinationStack = new Stack(); sourceStack.push(source); destinationStack.push(destination); while (!sourceStack.isEmpty()) { source = (File) sourceStack.pop(); destination = (File) destinationStack.pop(); if (!destination.exists()) destination.mkdirs(); File[] files = source.listFiles(); for (int i = 0; i < files.length; i++) { File current = (File) files[i]; if (current.isDirectory()) { sourceStack.push(current); destinationStack.push(new File(destination, current.getName())); } else if (current.getName().endsWith(\".class\")) { ClassWriter writer = new ClassWriter(); InputStream is = new BufferedInputStream(new FileInputStream(current)); writer.readClass(is); is.close(); if ((getStatusFlags(writer.getClassName(writer.getCurrentClassIndex())) & PP_PROCESSED) != 0) { ClassWriter[] auxWriter = new ClassWriter[1]; transformClass(writer, auxWriter); File output = new File(destination, current.getName()); OutputStream os = new BufferedOutputStream(new FileOutputStream(output)); writer.writeClass(os); os.close(); if (auxWriter[0] != null) { String className = auxWriter[0].getClassName(auxWriter[0].getCurrentClassIndex()); className = className.substring(className.lastIndexOf('.') + 1, className.length()); output = new File(destination, className + \".class\"); os = new BufferedOutputStream(new FileOutputStream(output)); auxWriter[0].writeClass(os); os.close(); } } } } } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void writeConfiguration(Writer out) throws IOException { if (myResource == null) { out.append(\"# Unable to print configuration resource\\n\"); } else { URL url = myResource.getUrl(); InputStream in = url.openStream(); if (in != null) { try { IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(in); } } else { out.append(\"# Unable to print configuration resource\\n\"); } } }. \n Code2: protected void connect() throws SocketException, IOException, LoginFailException { logger.info(\"Connect to FTP Server \" + account.getServer()); client = new FTPClient(); client.connect(account.getServer()); if (client.login(account.get",
        "ground_truth": "NO",
        "predict": "User(), account.getPass())) { logger.info(\"Login successful\"); } else { logger.error(\"Login failed\"); throw new LoginFailException(); } }. \n Code3: public void disconnect() throws IOException { if (client != null) { client.disconnect(); } }. \n Code4: public void setFMI(boolean fmi) { this.fmi = fmi; }. \n Code5: public void setFMI(boolean fmi, String studyUID, String seriesUID, String instUID) { this.fmi = fmi; this.studyUID = studyUID; this.seriesUID = seriesUID; this.instUID = instUID; }. \n Code6: public void setFMI(boolean fmi, String studyUID, String seriesUID, String instUID, String code) { this.fmi = fmi; this.studyUID = studyUID; this.seriesUID = seriesUID; this.instUID = instUID"
    },
    {
        "ID": 1090,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void serializeWithClass(Class theClass, int count, String comment) { for (int c = 0; c < 10; c++) { if (c == 9) { beginAction(1, \"persistence write/read\", count, comment); } String tempFile = \".tmp.archive\"; SerializeClassInterface theInstance = null; try { theInstance = (SerializeClassInterface) theClass.newInstance(); } catch (Exception e) { e.printStackTrace(); } if (theInstance == null) { System.err.println(\"error: Couldn't initialize class to \" + \"be serialized!\"); return; } reset(); for (int i = 0; i < count; i++) { try { FileOutputStream fout = new FileOutputStream(tempFile); BufferedOutputStream bout = new BufferedOutputStream(fout); ObjectOutputStream oout = new ObjectOutputStream(bout); oout.writeObject(theInstance); oout.flush(); oout.close(); } catch (IOException ioe) { System.err.println(\"serializing: \" + tempFile + \":\" + ioe.toString()); } try { FileInputStream fin = new FileInputStream(tempFile); BufferedInputStream bin = new BufferedInputStream(fin); ObjectInputStream oin = new ObjectInputStream(bin); theInstance = (SerializeClassInterface) oin.readObject(); oin.close(); } catch (Exception e) { System.err.println(\"deserializing: \" + tempFile + \":\" + e.toString()); break; } proceed(); } reset(); if (c == 9) { endAction(); } } }. \n Code2: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { sMessageID = oMsg.getHeader(\"X-Qmail-Scanner-Message-ID\", null); } catch (Exception ignore) { } } if (sMessageID != null) sMessageID = MimeUtility.decodeText(sMessageID); sContentType = oMsg.getContentType(); if (sContentType != null) sContentType = MimeUtility.decodeText(sContentType); sContentID = oMsg.getContentID(); if (sContentID != null) sContentID = MimeUtility.decodeText(sContentID); sDisposition = oMsg.getDisposition(); if (sDisposition != null) sDisposition = MimeUtility.decodeText(sDisposition); sContentMD5 = oMsg.getContentMD5(); if (sContentMD5 != null) sContentMD5 = MimeUtility.decodeText(sContentMD5); sDescription = oMsg.getDescription(); if (sDescription != null) sDescription = MimeUtility.decodeText(sDescription); sFileName = oMsg.getFileName(); if (sFileName != null) sFileName = MimeUtility.decodeText(sFileName); sEncoding = oMsg.getEncoding(); if (sEncoding != null) sEncoding = MimeUtility.decodeText(sEncoding); sSubject = oMsg.getSubject(); if (sSubject != null) sSubject = MimeUtility.decodeText(sSubject); sPriority = null; sMsgCharSeq = null; } catch (UnsupportedEncodingException uee) { throw new MessagingException(uee.getMessage(), uee); } BigDecimal dPgMessage = null; try { dPgMessage = getNextMessage(); } catch (SQLException sqle) { throw new MessagingException(sqle.getMessage(), sqle); } String sBoundary = getPartsBoundary(oMsg); if (DebugFile.trace) DebugFile.writeln(\"part boundary is \\\"\" + (sBoundary == null ? \"null\" : sBoundary) + \"\\\"\"); if (sMessageID == null) sMessageID = gu_mimemsg; else if (sMessageID.length() == 0) sMessageID = gu_mimemsg; Timestamp tsSent; if (oMsg.getSentDate() != null) tsSent = new Timestamp(oMsg.getSentDate().getTime()); else tsSent = null; Timestamp tsReceived; if (oMsg.getReceivedDate() != null) tsReceived = new Timestamp(oMsg.getReceivedDate().getTime()); else tsReceived = new Timestamp(new java.util.Date().getTime()); try { String sXPriority = oMsg.getHeader(\"X-Priority\", null); if (sXPriority == null) sPriority = null; else { sPriority = \"\"; for (int x = 0; x < sXPriority.length(); x++) { char cAt = sX",
        "ground_truth": "NO",
        "predict": "Priority.charAt(x); if (cAt == ' ') continue; if (cAt == 'X') break; sPriority += cAt; } } } catch (Exception ignore) { } if (sPriority == null) sPriority = \"\"; if (sPriority.length() == 0) sPriority = \"0\"; if (sPriority.length() > 1) sPriority = \"1\"; if (sPriority.length() > 2) sPriority = \"2\"; if (sPriority.length() > 3) sPriority = \"3\"; if (sPriority.length() > 4) sPriority = \"4\"; if (sPriority.length() > 5) sPriority = \"5\"; if (sPriority.length() > 6) sPriority = \"6\"; if (sPriority.length() > 7) sPriority = \"7\"; if (sPriority.length() > 8) sPrior"
    },
    {
        "ID": 1091,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void modify(ModifyInterceptorChain chain, DistinguishedName dn, ArrayList<LDAPModification> mods, LDAPConstraints constraints) throws LDAPException { Connection con = (Connection) chain.getRequest().get(JdbcInsert.MYVD_DB_CON + \"LDAPBaseServer\"); if (con == null) { throw new LDAPException(\"Operations Error\", LDAPException.OPERATIONS_ERROR, \"No Database Connection\"); } try { con.setAutoCommit(false); HashMap<String, String> db2ldap = (HashMap<String, String>) chain.getRequest().get(JdbcInsert.MYVD_DB_DB2LDAP + \"LDAPBaseServer\"); Iterator<LDAPModification> it = mods.iterator(); String uid = ((RDN) dn.getDN().getRDNs().get(0)).getValue(); int id = this.getId(dn, con); while (it.hasNext()) { LDAPModification mod = it.next(); if (mod.getOp() == LDAPModification.REPLACE) { String attributeName = mod.getAttribute().getName(); if (attributeName.equals(db2ldap.get(\"first\")) || attributeName.equals(db2ldap.get(\"last\"))) { PreparedStatement ps = con.prepareStatement(\"UPDATE USERS SET \" + (attributeName.equals(db2ldap.get(\"first\")) ? \"first\" : \"last\") + \"=? WHERE username=?\"); ps.setString(1, mod.getAttribute().getStringValue()); ps.setString(2, uid); ps.executeUpdate(); ps.close(); } else if (attributeName.equals(db2ldap.get(\"username\"))) { throw new LDAPException(\"Can not modify the rdn\", LDAPException.NOT_ALLOWED_ON_RDN, \"Can not perform modify\"); } else if (attributeName.equals(db2ldap.get(\"name\"))) { PreparedStatement ps = con.prepareStatement(\"DELETE FROM locationmap WHERE person=?\"); ps.setInt(1, id); ps.executeUpdate(); ps.close(); ps = con.prepareStatement(\"INSERT INTO locationmap (person,location) VALUES (?,?)\"); PreparedStatement pssel = con.prepareStatement(\"SELECT id FROM LOCATIONS WHERE name=?\"); String[] vals = mod.getAttribute().getStringValueArray(); for (int i = 0; i < vals.length; i++) { pssel.setString(1, vals[i]); ResultSet rs = pssel.executeQuery(); if (!rs.next()) { con.rollback(); throw new LDAPException(\"Location \" + vals[i] + \" does not exist\", LDAPException.OBJECT_CLASS_VIOLATION, \"Location \" + vals[i] + \" does not exist\"); } int lid = rs.getInt(\"id\"); ps.setInt(1, id); ps.setInt(2, lid); ps.executeUpdate(); } ps.close(); pssel.close(); } } else if (mod.getOp() == LDAPModification.DELETE) { if (mod.getAttribute().getName().equals(db2ldap.get(\"name\"))) { String[] vals = mod.getAttribute().getStringValueArray(); if (vals.length == 0) { PreparedStatement ps = con.prepareStatement(\"DELETE FROM locationmap WHERE person=?\"); ps.setInt(1, id); ps.executeUpdate(); ps.close(); } else { PreparedStatement ps = con.prepareStatement(\"DELETE FROM locationmap WHERE person=? and location=?\"); PreparedStatement pssel = con.prepareStatement(\"SELECT id FROM LOCATIONS WHERE name=?\"); for (int i = 0; i < vals.length; i++) { pssel.setString(1, vals[i]); ResultSet rs = pssel.executeQuery(); if (!rs.next()) { con.rollback(); throw new LDAPException(\"Location \" + vals[i] + \" does not exist\", LDAPException.OBJECT_CLASS_VIOLATION, \"Location \" + vals[i] + \" does not exist\"); } int lid = rs.getInt(\"id\"); ps.setInt(1, id); ps.setInt(2, lid); ps.executeUpdate(); } ps.close(); pssel.close(); } } else { throw new LDAPException(\"Can not delete attribute \" + mod.getAttribute().getName(), LDAPException.INVALID_ATTRIBUTE_SYNTAX, \"\"); } } else if (mod.getOp() == LDAPModification.ADD) { if (mod.getAttribute().getName().equals(db2ldap.get(\"name\"))) { String[] vals = mod.getAttribute().getStringValueArray(); PreparedStatement ps = con.prepareStatement(\"INSERT INTO locationmap (person,location) VALUES (?,?)\"); PreparedStatement pssel = con.prepareStatement(\"SELECT id FROM LOCATIONS WHERE name=?\"); for (int i = 0; i < vals.length; i++) { pssel.setString(1, vals[i]); ResultSet rs = pssel.executeQuery(); if (!rs.next()) { con.rollback(); throw new LDAPException(\"Location \" + vals[i] + \" does not exist\", LDAPException.OBJECT_CLASS_VIOLATION, \"Location \" + vals[i] + \" does not exist\"); } int lid = rs.getInt(\"id\"); ps.setInt(1, id); ps.setInt(2, lid); ps.executeUpdate(); } ps.close(); pssel.close(); } else { throw new LDAPException(\"Can not delete attribute \" + mod.getAttribute().getName(), LDAPException.INVALID_ATTRIBUTE_SYNTAX, \"\"); } } } con.commit(); } catch (SQLException e) { try { con.rollback(); } catch (SQLException e1) { throw new LDAPException(\"Could not delete entry or rollback transaction\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } throw new LDAPException(\"Could not delete entry\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } }. \n Code2: public byte[] getBytesMethod(String url) { logger.info(\"Facebook: @executing facebookGetMethod():\" + url); byte[] responseBytes = null; try { HttpGet loginGet = new HttpGet(url); loginGet.addHeader(\"Accept-Encoding\", \"gzip\"); HttpResponse response = httpClient.execute(loginGet); HttpEntity entity = response.getEntity(); logger.trace(\"Facebook: getBytesMethod: \" + response.getStatusLine()); if (entity != null) { Input",
        "ground_truth": "YES",
        "predict": "Stream instream = entity.getContent(); if (instream != null) { responseBytes = IOUtils.toByteArray(instream); } } } catch (Exception e) { logger.error(\"Facebook: getBytesMethod: \" + e.toString()); } return responseBytes; }\n}\n"
    },
    {
        "ID": 1104,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String args[]) { try { URL url = new URL(\"http://dev.activeanalytics.ca/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=17&m=2&s=16&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3a%2f%2flyricscatcher.sourceforge.net%2fpiwik.php&action_name=&idsite=1&res=1440x900&h=0&m=22&s=1&fla=1&dir=1&qt=1&realp=1&pdf=1&wma=1&java=1&cookie=0&title=JAVAACCESS&urlref=http%3a%2f%2flyricscatcher.sourceforge.net%2fcomputeraccespage.html\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { URL url = new URL(\"http://apps.sourceforge.net/piwik/lyricscatcher/piwik.php?url=http%3A%2F%2Flyricscatcher.sourceforge.net%2Fcomputeracces.html&action_name=&idsite=1&res=1440x900&h=0&m=28&s=36&fla=1&dir=1&qt=1&realp=0&pdf=1&wma=1&java=1&cookie=1&title=&urlref=\"); InputStream ist = url.openStream(); InputStreamReader isr = new InputStreamReader(ist); BufferedReader in = new BufferedReader(isr); String line = \"\"; String inputline = \"\"; while ((inputline = in.readLine()) != null) { line += inputline + \"\\n\"; } System.out.println(\"finished: length=\" + line.length() + \"line=\" + line); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \n Code2: private static String fetchUrl(String url, boolean keepLineEnds) throws IOException, MalformedURLException { URLConnection destConnection = (new URL(url)).openConnection(); BufferedReader br; String inputLine; StringBuffer doc = new StringBuffer(); String contentEncoding; destConnection.setRequestProperty(\"Accept-Encoding\", \"gzip\"); if (proxyAuth != null) destConnection.setRequestProperty(\"Proxy-Authorization\", proxyAuth); destConnection.connect(); contentEncoding = destConnection.getContentEncoding(); if ((contentEncoding != null) && contentEncoding.equals(\"gzip\")) { br = new BufferedReader(new InputStreamReader(new GZIPInputStream(destConnection.getInputStream()))); } else { br = new BufferedReader(new InputStreamReader(destConnection.getInputStream())); } while ((inputLine = br.readLine()) != null) { if (keepLineEnds) doc.append(inputLine + \"\\n\"); else doc.append(inputLine); } br.close(); return doc.toString(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @TestProperties(name = \"Simple test for adding different image files to report as link\") public void testAddLinkToImage() throws Exception { InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\"); report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\"))); in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\"); IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\"))); report.addLink(\"Link to JPG\", \"splash.jpg\"); report.addLink(\"Link to PNG\", \"blue.png\"); report.addLink(\"Link to GIF\", \"classDir.gif\"); }. \n Code2: public void deleteAuthors() throws Exception { if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\"); String[] pids = proposalIds.split(\",\"); String[] uids = usrIds.split(\",\"); int pnum = pids.length; int unum = uids.length; if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\"); int i",
        "ground_truth": "NO",
        "predict": " = 0; while (i < pnum) { if (i >= unum) break; if (proposals.get(pids[i]).getAuthor() != null) { proposals.get(pids[i]).getAuthor().delete(); } i++; } }. \n Response: YES. \n Instruction: Delete the authors of the selected proposals. \n Code2: public void deleteAuthors() throws Exception { if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\"); String[] pids = proposalIds.split(\",\"); String[] uids = usrIds.split(\",\"); int pnum = pids.length; int unum = uids.length; if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\"); int i = 0; while (i < pnum) { if (i >= unum) break; if ("
    },
    {
        "ID": 1107,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward uploadFile(ActionMapping mapping, ActionForm actForm, HttpServletRequest request, HttpServletResponse in_response) { ActionMessages errors = new ActionMessages(); ActionMessages messages = new ActionMessages(); String returnPage = \"submitPocketSampleInformationPage\"; UploadForm form = (UploadForm) actForm; Integer shippingId = null; try { eHTPXXLSParser parser = new eHTPXXLSParser(); String proposalCode; String proposalNumber; String proposalName; String uploadedFileName; String realXLSPath; if (request != null) { proposalCode = (String) request.getSession().getAttribute(Constants.PROPOSAL_CODE); proposalNumber = String.valueOf(request.getSession().getAttribute(Constants.PROPOSAL_NUMBER)); proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = form.getRequestFile().getFileName(); String fileName = proposalName + \"_\" + uploadedFileName; realXLSPath = request.getRealPath(\"\\\\tmp\\\\\") + \"\\\\\" + fileName; FormFile f = form.getRequestFile(); InputStream in = f.getInputStream(); File outputFile = new File(realXLSPath); if (outputFile.exists()) outputFile.delete(); FileOutputStream out = new FileOutputStream(outputFile); while (in.available() != 0) { out.write(in.read()); out.flush(); } out.flush(); out.close(); } else { proposalCode = \"ehtpx\"; proposalNumber = \"1\"; proposalName = proposalCode + proposalNumber.toString(); uploadedFileName = \"ispyb-template41.xls\"; realXLSPath = \"D:\\\\\" + uploadedFileName; } FileInputStream inFile = new FileInputStream(realXLSPath); parser.retrieveShippingId(realXLSPath); shippingId = parser.getShippingId(); String requestShippingId = form.getShippingId(); if (requestShippingId != null && !requestShippingId.equals(\"\")) { shippingId = new Integer(requestShippingId); } ClientLogger.getInstance().debug(\"uploadFile for shippingId \" + shippingId); if (shippingId != null) { Log.debug(\" ---[uploadFile] Upload for Existing Shipment (DewarTRacking): Deleting Samples from Shipment :\"); double nbSamplesContainers = DBAccess_EJB.DeleteAllSamplesAndContainersForShipping(shippingId); if (nbSamplesContainers > 0) parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained Samples and/or Containers\", \"Previous Samples and/or Containers have been deleted and replaced by new ones.\")); else parser.getValidationWarnings().add(new XlsUploadException(\"Shipment contained no Samples and no Containers\", \"Samples and Containers have been added.\")); } Hashtable<String, Hashtable<String, Integer>> listProteinAcronym_SampleName = new Hashtable<String, Hashtable<String, Integer>>(); ProposalFacadeLocal proposal = ProposalFacadeUtil.getLocalHome().create(); ProteinFacadeLocal protein = ProteinFacadeUtil.getLocalHome().create(); CrystalFacadeLocal crystal = CrystalFacadeUtil.getLocalHome().create(); ProposalLightValue targetProposal = (ProposalLightValue) (((ArrayList) proposal.findByCodeAndNumber(proposalCode, new Integer(proposalNumber))).get(0)); ArrayList listProteins = (ArrayList) protein.findByProposalId(targetProposal.getProposalId()); for (int p = 0; p < listProteins.size(); p++) { ProteinValue prot = (ProteinValue) listProteins.get(p); Hashtable<String, Integer> listSampleName = new Hashtable<String, Integer>(); CrystalLightValue listCrystals[] = prot.getCrystals(); for (int c = 0; c < listCrystals.length; c++) { CrystalLightValue _xtal = (CrystalLightValue) listCrystals[c]; CrystalValue xtal = crystal.findByPrimaryKey(_xtal.getPrimaryKey()); BlsampleLightValue listSamples[] = xtal.getBlsamples(); for (int s = 0; s < listSamples.length; s++) { BlsampleLightValue sample = listSamples[s]; listSampleName.put(sample.getName(), sample.getBlSampleId()); } } listProteinAcronym_SampleName.put(prot.getAcronym(), listSampleName); } parser.validate(inFile, listProteinAcronym_SampleName, targetProposal.getProposalId()); List listErrors = parser.getValidationErrors(); List listWarnings = parser.getValidationWarnings(); if (listErrors.size() == 0) { parser.open(realXLSPath); if (parser.getCrystals().size() == 0) { parser.getValidationErrors().add(new XlsUploadException(\"No crystals have been found\", \"Empty shipment\")); } } Iterator errIt = listErrors.iterator(); while (errIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) errIt.next(); errors.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveErrors(request, errors); } catch (Exception e) { } Iterator warnIt = listWarnings.iterator(); while (warnIt.hasNext()) { XlsUploadException xlsEx = (XlsUploadException) warnIt.next(); messages.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"message.free\", xlsEx.getMessage() + \" ---> \" + xlsEx.getSuggestedFix())); } try { saveMessages(request, messages); } catch (Exception e) { } if (listErrors.size() > 0) { resetCounts(shippingId); return mapping.findForward(\"submitPocketSampleInformationPage\"); } if (listWarnings.size() > 0) returnPage = \"submitPocketSampleInformationPage\"; String crystalDetailsXML; XtalDetails xtalDetailsWebService = new XtalDetails(); CrystalDetailsBuilder cDE = new CrystalDetailsBuilder(); CrystalDetailsElement cd = cDE.createCrystalDetailsElement(proposalName, parser.getCrystals()); cDE.validateJAXBObject(cd); crystalDetailsXML = cDE.marshallJaxBObjToString(cd); xtalDetailsWebService.submitCrystalDetails(crystalDetailsXML); String diffractionPlan; DiffractionPlan diffractionPlanWebService = new DiffractionPlan(); DiffractionPlanBuilder dPB = new Diff",
        "ground_truth": "NO",
        "predict": "ractionPlanBuilder(); DiffractionPlanElement dPE = dPB.createDiffractionPlanElement(proposalName, parser.getCrystals()); dPB.validateJAXBObject(dPE); diffractionPlan = dPB.marshallJaxBObjToString(dPE); diffractionPlanWebService.submitDiffractionPlan(diffractionPlan); return mapping.findForward(returnPage); } catch (Exception e) { return mapping.findForward(\"submitPocketSampleInformationPage\"); } }\n"
    },
    {
        "ID": 1112,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: int openBinaryLut(FileInfo fi, boolean isURL, boolean raw) throws IOException { InputStream is; if (isURL) is = new URL(fi.url + fi.fileName).openStream(); else is = new FileInputStream(fi.directory + fi.fileName); DataInputStream f = new DataInputStream(is); int nColors = 256; if (!raw) { int id = f.readInt(); if (id != 1229147980) { f.close(); return 0; } int version = f.readShort(); nColors = f.readShort(); int start = f.readShort(); int end = f.readShort(); long fill1 = f.readLong(); long fill2 = f.readLong(); int filler = f.readInt(); } f.read(fi.reds, 0, nColors); f.read(fi.greens, 0, nColors); f.read(fi.blues, 0, nColors); if (nColors < 256) interpolate(fi.reds, fi.greens, fi.blues, nColors); f.close(); return 256; }. \n Code2: @Override protected URLConnection openConnection(URL url) throws IOException { try { final HttpServlet servlet; String path = url.getPath(); if (path.matches(\"reg:.+\")) { String registerName = path.replaceAll(\"reg:([^/]*)/.*\", \"$1\"); servlet = register.get(registerName); if (servlet == null) throw new RuntimeException(\"No servlet registered with name \" + registerName); } else { String servletClassName = path.replaceAll(\"([^/]*)/.*\", \"$1\"); servlet = (HttpServlet) Class.forName(servletClassName).newInstance(); } final MockHttpServletRequest req = new MockHttpServletRequest().setMethod(\"GET\"); final MockHttpServletResponse resp = new MockHttpServletResponse(); return new HttpURLConnection(url) { @Override public int getResponseCode() throws IOException { serviceIfNeeded(); return resp.status; } @Override public InputStream getInputStream() throws IOException { serviceIfNeeded(); if (resp.status == 500) throw new IOException(\"Server responded with error 500\"); byte[] array = resp.out.toByteArray(); return new ByteArrayInputStream(array); } @Override public InputStream getErrorStream() { try { serviceIfNeeded(); } catch (IOException e) { throw new RuntimeException(e); } if (resp.status != 500) return null; return new ByteArrayInputStream(resp.out.toByteArray()); } @Override public OutputStream getOutputStream() throws IOException { return req.tmp; } @Override public void addRequestProperty(String key, String value) { req.addHeader(key, value); } @Override public void connect() throws IOException { } @Override public boolean usingProxy() { return false; } @Override public void disconnect() { } private boolean called; private void serviceIfNeeded() throws IOException { try { if (!called) { called = true; req.setMethod(getRequestMethod()); servlet.service(req, resp); } } catch (ServletException e) { throw new RuntimeException(e); } } }; } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL().toString()); } else if (item.getType() == Type.ANY_URI) { LOG.debug(\"Streaming xs:anyURI\"); String url = item.getStringValue(); if (url.startsWith(\"/\")) { url = \"xmldb:exist://\" + url; } InputStream is = new URL(url).openStream(); streamSource.setInputStream(is); streamSource.setSystemId(url); } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) { LOG.debug(\"Streaming element or document node\"); if (item instanceof NodeProxy) { NodeProxy np = (NodeProxy) item; String url = \"xmldb:exist://\" + np.getDocument().getBaseURI(); LOG.debug(\"Document detected, adding URL \" + url); streamSource.setSystemId(url); } Serializer serializer = context.getBroker().newSerializer(); NodeValue node = (NodeValue) item; InputStream is = new NodeInputStream(serializer, node); streamSource.setInputStream(is); } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) { LOG.debug(\"Streaming base64 binary\"); BinaryValue binary = (BinaryValue) item; byte[] data = (byte[]) binary.toJavaObject(byte[].class); InputStream is = new ByteArrayInputStream(data); streamSource.setInputStream(is); if (item instanceof Base64BinaryDocument) { Base64BinaryDocument b64doc = (Base64BinaryDocument) item; String url = \"xmldb:exist://\" + b64doc.getUrl(); LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url); streamSource.setSystemId(url); } } else { LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType())); throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType())); } return streamSource; }. \n Code2: public static void copyFile(File in, File out) { try { FileChannel inChannel = null, outChannel = null; try { out.getParentFile().mkdirs(); inChannel = new FileInputStream(in).getChannel(); outChannel = new FileOutputStream(out).getChannel(); outChannel.transferFrom(inChannel, 0, inChannel.size()); } finally { if (inChannel != null) { inChannel.close(); } if",
        "ground_truth": "NO",
        "predict": " (outChannel != null) { outChannel.close(); } } } catch (IOException e) { throw new RuntimeException(e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL"
    },
    {
        "ID": 1123,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void updateCoordinates(Address address) { String mapURL = \"http://maps.google.com/maps/geo?output=csv\"; String mapKey = \"ABQIAAAAi__aT6y6l86JjbootR-p9xQd1nlEHNeAVGWQhS84yIVN5yGO2RQQPg9QLzy82PFlCzXtMNe6ofKjnA\"; String location = address.getStreet() + \" \" + address.getZip() + \" \" + address.getCity(); if (logger.isDebugEnabled()) { logger.debug(location); } double[] coordinates = { 0.0, 0.0 }; String content = \"\"; try { location = URLEncoder.encode(location, \"UTF-8\"); String request = mapURL + \"&q=\" + location + \"&key=\" + mapKey; URL url = new URL(request); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String line; while ((line = reader.readLine()) != null) { content += line; } reader.close(); } catch (Exception e) { if (logger.isDebugEnabled()) { logger.debug(\"Error from google: \" + e.getMessage()); } } if (logger.isDebugEnabled()) { logger.debug(content); } StringTokenizer tokenizer = new StringTokenizer(content, \",\"); int i = 0; while (tokenizer.hasMoreTokens()) { i++; String token = tokenizer.nextToken(); if (i == 3) { coordinates[0] = Double.parseDouble(token); } if (i == 4) { coordinates[1] = Double.parseDouble(token); } } if ((coordinates[0] != 0) || (coordinates[1] != 0)) { address.setLatitude(coordinates[0]); address.setLongitude(coordinates[1]); } else { if (logger.isDebugEnabled()) { logger.debug(\"Invalid coordinates for address \" + address.getId()); } } }. \n Code2: private void fileMaker() { try { long allData = 0; double a = 10; int range = 0; int blockLength = 0; File newFile = new File(mfr.getFilename() + \".part\"); if (newFile.exists()) { newFile.delete(); } ArrayList<DataRange> rangeList = null; byte[] data = null; newFile.createNewFile(); ByteBuffer buffer = ByteBuffer.allocate(mfr.getBlocksize()); FileChannel rChannel = new FileInputStream(inputFileName).getChannel(); FileChannel wChannel = new FileOutputStream(newFile, true).getChannel(); System.out.println(); System.out.print(\"File completion: \"); System.out.print(\"|----------|\"); openConnection(); http.getResponseHeader(); for (int i = 0; i < fileMap.length; i++) { fileOffset = fileMap[i]; if (fileOffset != -1) { rChannel.read(buffer, fileOffset); buffer.flip(); wChannel.write(buffer); buffer.clear(); } else { if (!rangeQueue) { rangeList = rangeLookUp(i); range = rangeList.size(); openConnection(); http.setRangesRequest(rangeList); http.sendRequest(); http.getResponseHeader(); data = http.getResponseBody(mfr.getBlocksize()); allData += http.getAllTransferedDataLength(); } if ((i * mfr.getBlocksize() + mfr.getBlocksize()) < mfr.getLength()) { blockLength = mfr.getBlocksize(); } else { blockLength = (int) ((int) (mfr.getBlocksize()) + (mfr.getLength() - (i * mfr.getBlocksize() + mfr.getBlocksize()))); } buffer.put(data, (range - rangeList.size()) * mfr.getBlocksize(), blockLength); buffer.flip(); wChannel.write(buffer); buffer.clear(); rangeList.remove(0); if (rangeList.isEmpty()) { rangeQueue = false; } } if ((((double) i / ((double) fileMap.length - 1)) * 100) >= a) { progressBar(((double) i / ((double) fileMap.length - 1)) * 100); a += 10; } } newFile.setLastModified(getMTime()); sha = new SHA1(newFile); if (sha.SHA1sum().equals(mfr.getSha1())) { System.out.println(\"\\nverifying download...checksum matches OK\"); System.out.println(\"used \" + (mfr.getLength() - (mfr.getBlocksize() * missing)) + \" \" + \"local, fetched \" + (mfr.getBlocksize() * missing)); new File(mfr.getFilename()).renameTo(new File(mfr.getFilename() + \".zs-old\")); newFile.renameTo(new File(mfr.getFilename())); allData += mfr.getLengthOfMetafile(); System.out.println(\"really downloaded \" + allData); double overhead = ((double) (allData - (mfr.getBlocksize() * missing)) / ((double) (mfr.getBlocksize() * missing))) * 100; System.out.println(\"overhead: \" + df.format(overhead) + \"%\"); } else { System.out.println(\"\\nverifying download...checksum don't match\"); System.out.println(\"Deleting temporary file\"); newFile.delete(); System.exit(1); } } catch (IOException ex) { System.out.println(\"Can't read or write, check your permissions.\"); System.exit(1); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void exportNotesToServer() { boolean uploaded = true; try { File f = new File(UserSettings.getInstance().getNotesFile()); FileInputStream fis = new FileInputStream(f); String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName(); setDefaultAuthenticator(); URL url = new URL(urlString); HttpURLConnection urlc = (HttpURLConnection) url.openConnection(); urlc.setDoOutput(true); urlc.setRequestMethod(\"PUT\"); OutputStream os = urlc.getOutputStream(); int nextByte = fis.read(); while (nextByte != -1) { os.write(nextByte); nextByte = fis.read(); } fis.close(); os.close(); if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP",
        "ground_truth": "NO",
        "predict": "_OK) { uploaded = false; } } catch (Exception e) { uploaded = false; } }. \n Code2: private void progressBar(double percent) { System.out.print(\"\\r\" + df.format(percent) + \"%\"); }. \n Code3: private void setDefaultAuthenticator() { Authenticator.setDefault(new Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(\"\", \"\".toCharArray()); } }); }. \n Code4: private void openConnection() { http = new HttpClient(); }. \n Code5: private void closeConnection() { http.getConnectionManager().shutdown(); }. \n Code6: private void setRangesRequest(ArrayList<DataRange> rangeList) { rangesRequest = rangeList; }. \n Code7: private void sendRequest() { http.sendRequest(); }. \n Code8: private void getResponseHeader() { http.getResponseHeader"
    },
    {
        "ID": 1129,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void listgroups() throws Exception { String lapage = new String(\"\"); Pattern pat; Matcher mat; int data; URL myurl = new URL(\"http://groups.yahoo.com/mygroups\"); URLConnection conn; URI myuri = new URI(\"http://groups.yahoo.com/mygroups\"); YahooInfo yi; clearAll(); System.out.print(\"http://groups.yahoo.com/mygroups : \"); do { myurl = new URL(myurl.toString()); conn = myurl.openConnection(); conn.connect(); if (!Pattern.matches(\"HTTP/... 2.. .*\", conn.getHeaderField(0).toString())) { System.out.println(conn.getHeaderField(0).toString()); return; } System.out.print(\".\"); InputStream in = conn.getInputStream(); lapage = \"\"; for (data = in.read(); data != -1; data = in.read()) lapage += (char) data; pat = Pattern.compile(\"<td class=\\\"grpname selected\\\"><a href=\\\"(.+?)\\\".*?><em>(.+?)</em></a>\"); mat = pat.matcher(lapage); while (mat.find()) { yi = new YahooInfo(mat.group(2), \"\", \"\", myuri.resolve(HTMLDecoder.decode(mat.group(1))).toURL().toString()); UrlList.add(yi); } pat = Pattern.compile(\"<a href=\\\"(.+?)\\\">Next &gt;</a>\"); mat = pat.matcher(lapage); myurl = null; if (mat.find()) { myurl = myuri.resolve(HTMLDecoder.decode(mat.group(1))).toURL(); } } while (myurl != null); System.out.println(\"\"); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String str2md5(String str) { try { MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE); alga.update(str.getBytes()); byte[] digesta = alga.digest(); return byte2hex(digesta); } catch (NoSuchAlgorithmException ex) { return str; } }. \n Code2: public static final String calculate(File f) { MessageDigest md; BufferedReader rd; StringBuffer buffer = new StringBuffer(\"\"); try { rd = new BufferedReader(new FileReader(f)); md = MessageDigest.getInstance(\"SHA\"); String line = \"\"; while ((line = rd.readLine()) != null) buffer.append(line); md.update",
        "ground_truth": "YES",
        "predict": "(buffer.toString().getBytes()); byte[] digest = md.digest(); return byte2hex(digest); } catch (NoSuchAlgorithmException ex) { return \"\"; } catch (FileNotFoundException ex) { return \"\"; } catch (IOException ex) { return \"\"; } }. \n Code3: public static final String byte2hex(byte[] b) { String h = \"\"; for (int i = 0; i < b.length; i++) h += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1); return h; }. \n */\n"
    },
    {
        "ID": 1130,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getContentsFromVariant(SelectedVariant selected) { if (selected == null) { return null; } ActivatedVariablePolicy policy = selected.getPolicy(); Variant variant = selected.getVariant(); if (variant == null) { return null; } Content content = variant.getContent(); if (content instanceof EmbeddedContent) { EmbeddedContent embedded = (EmbeddedContent) content; return embedded.getData(); } else { MarinerURL marinerURL = computeURL((Asset) selected.getOldObject()); URL url; try { url = context.getAbsoluteURL(marinerURL); } catch (MalformedURLException e) { logger.warn(\"asset-mariner-url-retrieval-error\", new Object[] { policy.getName(), ((marinerURL == null) ? \"\" : marinerURL.getExternalForm()) }, e); return null; } String text = null; try { if (logger.isDebugEnabled()) { logger.debug(\"Retrieving contents of URL \" + url); } URLConnection connection = url.openConnection(); int contentLength = connection.getContentLength(); if (contentLength > 0) { String charset = connection.getContentEncoding(); if (charset == null) { charset = \"UTF-8\"; } InputStreamReader is = new InputStreamReader(connection.getInputStream(), charset); BufferedReader br = new BufferedReader(is); char[] buf = new char[contentLength]; int length = br.read(buf, 0, buf.length); text = String.copyValueOf(buf, 0, length); } } catch (IOException e) { logger.warn(\"asset-url-retrieval-error\", new Object[] { policy.getName(), url }, e); } return text; } }. \n Code2: public static boolean saveMap(LWMap map, boolean saveAs, boolean export) { Log.info(\"saveMap: \" + map); GUI.activateWaitCursor(); if (map == null) return false; File file = map.getFile(); int response = -1; if (map.getSaveFileModelVersion() == 0) { final Object[] defaultOrderButtons = { VueResources.getString(\"saveaction.saveacopy\"), VueResources.getString(\"saveaction.save\") }; Object[] messageObject = { map.getLabel() }; response = VueUtil.option(VUE.getDialogParent(), VueResources.getFormatMessage(messageObject, \"dialog.saveaction.message\"), VueResources.getFormatMessage(messageObject, \"dialog.saveaction.title\"), JOptionPane.YES_NO_OPTION, JOptionPane.PLAIN_MESSAGE, defaultOrderButtons, VueResources.getString(\"saveaction.saveacopy\")); } if (response == 0) { saveAs = true; } if ((saveAs || file == null) && !export) { file = ActionUtil.selectFile(\"Save Map\", null); } else if (export) { file = ActionUtil.selectFile(\"Export Map\", \"export\"); } if (file == null) { try { return false; } finally { GUI.clearWaitCursor(); } } try { Log.info(\"saveMap: target[\" + file + \"]\"); final String name = file.getName().toLowerCase(); if (name.endsWith(\".rli.xml\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".xml\") || name.endsWith(\".vue\")) { ActionUtil.marshallMap(file, map); } else if (name.endsWith(\".jpeg\") || name.endsWith(\".jpg\")) ImageConversion.createActiveMapJpeg(file, VueResources.getDouble(\"imageExportFactor\")); else if (name.endsWith(\".png\")) ImageConversion.createActiveMapPng(file, VueResources.getDouble(\"imageExportFactor\")); else if (name.endsWith(\".svg\")) SVGConversion.createSVG(file); else if (name.endsWith(\".pdf\")) { PresentationNotes.createMapAsPDF(file); } else if (name.endsWith(\".zip\")) { Vector resourceVector = new Vector(); Iterator i = map.getAllDescendents(LWComponent.ChildKind.PROPER).iterator(); while (i.hasNext()) { LWComponent component = (LWComponent) i.next(); System.out.println(\"Component:\" + component + \" has resource:\" + component.hasResource()); if (component.hasResource() && (component.getResource() instanceof URLResource)) { URLResource resource = (URLResource) component.getResource(); try { if (resource.isLocalFile()) { String spec = resource.getSpec(); System.out.println(resource.getSpec()); Vector row = new Vector(); row.add(new Boolean(true)); row.add(resource); row.add(new Long(file.length())); row.add(\"Ready\"); resourceVector.add(row); } } catch (Exception ex) { System.out.println(\"Publisher.setLocalResourceVector: Resource \" + resource.getSpec() + ex); ex.printStackTrace(); } } } File savedCMap = PublishUtil.createZip(map, resourceVector); InputStream istream = new BufferedInputStream(new FileInputStream(savedCMap)); OutputStream ostream = new BufferedOutputStream(new FileOutputStream(file)); int fileLength = (int) savedCMap.length(); byte bytes[] = new byte[fileLength]; try { while (istream.read(bytes, 0, fileLength) != -1) ostream.write(bytes, 0, fileLength); } catch (Exception e) { e.printStackTrace(); } finally { istream.close(); ostream.close(); } } else if (name.endsWith(\".html\")) { HtmlOutputDialog hod = new HtmlOutputDialog(); hod.setVisible(true); if (hod.getReturnVal() > 0) new ImageMap().createImageMap(file, hod.getScale(), hod.getFormat()); } else if (name.endsWith(\".rdf\")) { edu.tufts.vue.rdf.RDFIndex index = new edu.tufts.vue.rdf.RDFIndex(); String selectionType = VueResources.getString(\"rdf.export.selection\"); if (selectionType.equals(\"ALL\")) { Iterator<LWMap> maps = VUE.getLeftTabbedPane().getAllMaps(); while (maps.hasNext()) { index.index(maps.next()); } } else if (selectionType.equals(\"ACTIVE\")) { index.index(VUE.getActiveMap()); } else { index.index(VUE.getActiveMap()); } FileWriter writer = new FileWriter(file); index.write(writer); writer.close(); }",
        "ground_truth": "NO",
        "predict": " else if (name.endsWith(\".rli\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.xml\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.zip\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.zip.xml\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.zip.zip\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.zip.zip.xml\")) { new IMSResourceList().convert(map, file); } else if (name.endsWith(\".rli.zip.zip.zip\")) { new IMSResourceList().convert(map, file); } else if ("
    },
    {
        "ID": 1137,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void loadDBpediaOntology() { try { URL url = new URL(\"http://downloads.dbpedia.org/3.6/dbpedia_3.6.owl.bz2\"); InputStream is = new BufferedInputStream(url.openStream()); CompressorInputStream in = new CompressorStreamFactory().createCompressorInputStream(\"bzip2\", is); dbPediaOntology = OWLManager.createOWLOntologyManager().loadOntologyFromOntologyDocument(in); reasoner = PelletReasonerFactory.getInstance().createNonBufferingReasoner(dbPediaOntology); reasoner.precomputeInferences(InferenceType.CLASS_HIERARCHY); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (CompressorException e) { e.printStackTrace(); } catch (OWLOntologyCreationException e) { e.printStackTrace(); } }. \n Code2: @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.listview); HttpGet request = new HttpGet(SERVICE_URI + \"/json/getroutes/1\"); request.setHeader(\"Accept\", \"application/json\"); request.setHeader(\"Content-type\", \"application/json\"); DefaultHttpClient httpClient = new DefaultHttpClient(); String theString = new String(\"\"); try { HttpResponse response = httpClient.execute(request); HttpEntity responseEntity = response.getEntity(); InputStream stream = responseEntity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); Vector<String> vectorOfStrings = new Vector<String>(); String tempString = new String(); String tempStringAgent = new String(); String tempStringClient = new String(); String tempStringRoute = new String(); String tempStringZone = new String(); StringBuilder builder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { builder.append(line); } stream.close(); theString = builder.toString(); JSONObject json = new JSONObject(theString); Log.i(\"_GetClient_\", \"<jsonobject> \\n \" + json.toString() + \" \\n </jsonobject>\"); this.dm = new DataManipulator(this); JSONArray nameArray = json.getJSONArray(\"GetRoutesByAgentResult\"); for (int i = 0; i < nameArray.length(); i++) { tempStringAgent = nameArray.getJSONObject(i).getString(\"Agent\"); tempStringClient = nameArray.getJSONObject(i).getString(\"Client\"); tempStringRoute = nameArray.getJSONObject(i).getString(\"Route\"); tempStringZone = nameArray.getJSONObject(i).getString(\"Zone\"); Log.i(\"_GetClient_\", \"<Agent\" + i + \">\" + tempStringAgent + \"</Agent\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Client\" + i + \">\" + tempStringClient + \"</Client\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Route\" + i + \">\" + tempStringRoute + \"</Route\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Zone\" + i + \">\" + tempStringZone + \"</Zone\" + i + \">\\n\"); this.dm.insertIntoClients(tempStringAgent, tempStringClient, tempStringRoute, tempStringZone); tempString = nameArray.getJSONObject(i).getString(\"Client\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Route\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Zone\"); vectorOfStrings.add(new String(tempString)); } int orderCount = vectorOfStrings.size(); String[] orderTimeStamps = new String[orderCount]; vectorOfStrings.copyInto(orderTimeStamps); setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, orderTimeStamps)); } catch (Exception e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1 < 0) { continue; } String bundleSymbolicName = line.substring(0, pos1); String bundleName = line.substring(pos1 + 1); for (BundleInfo info : list) { if (info.bundleSymbolicName.equals(bundleSymbolicName)) { info.bundleName = bundleName; break; } } } return true; } catch (IOException e) { e.printStackTrace(); } return false; }. \n Code2: public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception { pAndamento.delimitarIntervaloDeVariacao(0, 49); WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento); pAndamento.delimitarIntervaloDeVariacao(50, 100); if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) { String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\"; OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql); stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE); int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length; try { int quantidadeDeRegistrosImportados = 0; int numeroDoRegistro = 0; for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) { ++numeroDoRegistro; stmtDestino.clearParameters(); int ano = cotacaoPendenteDoDolar.getAno(), mes = c",
        "ground_truth": "NO",
        "predict": "otacaoPendenteDoDolar.getMes(), dia = cotacaoPendenteDoDolar.getDia(); stmtDestino.setDate(1, new java.sql.Date(ano - 1900, mes - 1, dia)); stmtDestino.setDouble(2, cotacaoPendenteDoDolar.getPreco()); stmtDestino.addBatch(); ++quantidadeDeRegistrosImportados; if (quantidadeDeRegistrosImportados % COMMANDOS_POR_LOTE == 0) { stmtDestino.executeBatch(); } } stmtDestino.executeBatch(); } catch (SQLException e) { e.printStackTrace(); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static WSValorSerieVO[] obter"
    },
    {
        "ID": 1163,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File in, File out) throws IOException { FileChannel inChannel = new FileInputStream(in).getChannel(); FileChannel outChannel = new FileOutputStream(out).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } catch (IOException e) { throw e; } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } }. \n Code2: public void testEmptyBlock_01() throws Exception { EXISchema corpus = EXISchemaFactoryTestUtil.getEXISchema(\"/compression/emptyBlock_01.xsd\", getClass(), m_compilerErrors); Assert.assertEquals(0, m_compilerErrors.getTotalCount()); GrammarCache grammarCache = new GrammarCache(corpus, GrammarOptions.STRICT_OPTIONS); Transmogrifier encoder = new Transmogrifier(); EXIDecoder decoder = new EXIDecoder(31); Scanner scanner; InputSource inputSource; encoder.setOutputOptions(HeaderOptionsOutputType.lessSchemaId); encoder.setAlignmentType(AlignmentType.compress); encoder.setBlockSize(1); encoder.setEXISchema(grammarCache); ByteArrayOutputStream baos = new ByteArrayOutputStream(); encoder.setOutputStream(baos); URL url = resolveSystemIdAsURL(\"/compression/emptyBlock_01.xml\"); inputSource = new InputSource(url.toString()); inputSource.setByteStream(url.openStream()); byte[] bts; int n_events; encoder.encode(inputSource); bts = baos.toByteArray(); decoder.setEXISchema(grammarCache); decoder.setInputStream(new ByteArrayInputStream(bts)); scanner = decoder.processHeader(); ArrayList<EXIEvent> exiEventList = new ArrayList<EXIEvent>(); EXIEvent exiEvent; n_events = 0; while ((exiEvent = scanner.nextEvent()) != null) { ++n_events; exiEventList.add(exiEvent); } Assert.assertEquals(11, n_events); Assert.assertEquals(1, ((ChannellingScanner) scanner).getBlockCount()); EventType eventType; EventTypeList eventTypeList; int pos = 0; exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SD, exiEvent.getEventVariety()); eventType = exiEvent.getEventType(); Assert.assertSame(exiEvent, eventType); Assert.assertEquals(0, eventType.getIndex()); eventTypeList = eventType.getEventTypeList(); Assert.assertNull(eventTypeList.getEE()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"root\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"parent\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"child\", exiEvent.getName()); Assert.assertEquals(\"\", eventType.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_CH, exiEvent.getEventVariety()); Assert.assertEquals(\"42\", exiEvent.getCharacters().makeString()); int tp = ((EventTypeSchema) exiEvent.getEventType()).getSchemaSubstance(); Assert.assertEquals(EXISchemaConst.UNSIGNED_BYTE_TYPE, corpus.getSerialOfType(tp)); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_SE, exiEvent.getEventVariety()); Assert.assertEquals(\"adjunct\", exiEvent.getName()); Assert.assertEquals(\"\", exiEvent.getURI()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_EE, exiEvent.getEventVariety()); exiEvent = exiEventList.get(pos++); Assert.assertEquals(EXIEvent.EVENT_ED, exiEvent.getEventVariety()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException { final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder(); final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath); final Multimap<String, String> proteins = HashMultimap.create(); for (final String query : queries) { HttpURLConnection connection = null; try { final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\"); final URL url = new URL(String.format(__urlTempl2, encoded, taxon)); connection = (HttpURLConnection) url.openConnection(); connection.setConnectTimeout(__connTimeout); connection.setReadTimeout(__readTimeout); connection.setRequestProperty(\"Connection\", \"close\"); connection.connect(); final InputStream stream = connection.getInputStream(); final Document doc = parser.parse(stream); final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET); if (nodes != null) { final int n = nodes.getLength(); for (int i =",
        "ground_truth": "NO",
        "predict": " 0; i < n; ++i) { final Node node = nodes.item(i); final String name = node.getNodeName(); final String value = node.getTextContent(); if (name.equals(\"protein\")) { final String[] parts = value.split(\"\\\\s+\"); final String accession = parts[0]; final String name = parts[1]; final String taxon = parts[2]; final String[] taxonParts = taxon.split(\"\\\\.\"); final int taxonId = Integer.parseInt(taxonParts[0]); final int taxonRank = Integer.parseInt(taxonParts[1]); final String taxonName = taxonParts[2]; final String[] taxonNameParts = taxonName.split(\"\\\\s+\"); final String commonName = taxonNameParts[0]; final String[] commonNameParts = commonName.split(\"\\\\s+\"); final String scientificName = commonNameParts[0]; final String[] scientificNameParts = scientificName"
    },
    {
        "ID": 1173,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: @Override public boolean checkConnection() { int status = 0; try { URL url = new URL(TupeloProxy.endpoint); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); status = conn.getResponseCode(); } catch (Exception e) { logger.severe(\"Connection test failed with code:\" + status); e.printStackTrace(); } if (status < 200 || status >= 400) return false; String url = this.url + \"?title=Special:UserLogin&action=submitlogin&type=login&returnto=Main_Page&wpDomain=\" + domain + \"&wpLoginattempt=Log%20in&wpName=\" + username + \"&wpPassword=\" + password; return true; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME); while (urls.hasMoreElements()) { URL url = urls.nextElement(); log.debug(\"Found: \" + url); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String className = null; while ((className = reader.readLine()) != null) { className = className.trim(); if (!\"\".equals(className) && !className.startsWith(\"#\")) { log.debug(\"Found class: \" + className); Class<?> clazz = classLoader.loadClass(className); addClass(clazz); } } } } catch (IOException e) { e.printStackTrace(); log.error(e); } catch (ClassNotFoundException e) { e.printStackTrace(); log.error(e); } }. \n Code2: @Override public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException { File dest = new File(this.realFile, name); if (allowedClient) { if (\".request\".equals(name) || \".tokens\".equals(name)) { FileOutputStream out = null; try { out = new FileOutputStream(dest); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(out); } if (\".request\".equals(name)) { File request = new File(realFile.getAbsolutePath() + \"/\" + name); RequestManager.manageRequest(request, null, true); return new",
        "ground_truth": "NO",
        "predict": " FileResource(request); } } } return new FileResource(dest); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME); while (urls.hasMoreElements()) { URL url = urls.nextElement(); log.debug(\"Found: \" + url); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String className = null; while ((className = reader.readLine()) != null) { className = className.trim(); if (!\"\".equals(class"
    },
    {
        "ID": 1183,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public TDSScene loadScene(URL url) throws IOException, IncorrectFormatException, ParsingErrorException { boolean baseURLWasNull = setBaseURLFromModelURL(url); TDSScene scene = loadScene(url.openStream()); if (baseURLWasNull) { popBaseURL(); } return (scene); }. \n Code2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\"export_page\"); query = query.replace(\"[RANDOM_INT]\", \"\" + random.nextInt()); int statusCode = -1; GetMethod get = new GetMethod(query); if (log.isInfoEnabled()) log.info(\"getting all contacts ...\"); try { statusCode = client.executeMethod(get); if (statusCode != 200) throw new GmailException(\"In contacts export page: Status code expected: 200 -> Status code returned: \" + statusCode); } catch (HttpException e) { throw new GmailException(\"HttpException in contacts export page:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in contacts export page:\" + e.getMessage()); } finally { get.releaseConnection(); } if (log.isTraceEnabled()) log.trace(\"accessing contacts export page successful...\"); String query_post = properties.getString(\"outlook_export_page\"); PostMethod post = new PostMethod(query_post); post.addRequestHeader(\"Accept-Encoding\", \"gzip,deflate\"); post.addRequestHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.8\"); NameValuePair[] data = { new NameValuePair(\"at\", getCookie(\"GMAIL_AT\")), new NameValuePair(\"ecf\", \"o\"), new NameValuePair(\"ac\", \"Export Contacts\") }; post.setRequestBody(data); if (log.isTraceEnabled()) log.trace(\"getting contacts csv file...\"); try { statusCode = client.executeMethod(post); if (statusCode != 200) throw new GmailException(\"In csv file post: Status code expected: 200 -> Status code returned: \" + statusCode); if (log.isTraceEnabled()) log.trace(\"Gmail: csv charset: \" + post.getResponseCharSet()); GMAIL_OUTPUT_CHARSET = post.getResponseCharSet(); InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet()); CSVReader reader = new CSVReader(isr); List csvEntries = reader.readAll(); reader.close(); ArrayList<GmailContact> contacts = new ArrayList<GmailContact>(); MessageDigest m = MessageDigest.getInstance(\"MD5\"); if (log.isTraceEnabled()) log.trace(\"creating Gmail contacts...\"); for (int i = 1; i < csvEntries.size(); i++) { GmailContact contact = new GmailContact(); String[] value = (String[]) csvEntries.get(i); for (int j = 0; j < value.length; j++) { switch(j) { case 0: contact.setName(value[j]); break; case 1: contact.setEmail(value[j]); if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]); break; case 2: contact.setNotes(value[j]); break; case 3: contact.setEmail2(value[j]); break; case 4: contact.setEmail3(value[j]); break; case 5: contact.setMobilePhone(value[j]); break; case 6: contact.setPager(value[j]); break; case 7: contact.setCompany(value[j]); break; case 8: contact.setJobTitle(value[j]); break; case 9: contact.setHomePhone(value[j]); break; case 10: contact.setHomePhone2(value[j]); break; case 11: contact.setHomeFax(value[j]); break; case 12: contact.setHomeAddress(value[j]); break; case 13: contact.setBusinessPhone(value[j]); break; case 14: contact.setBusinessPhone2(value[j]); break; case 15: contact.setBusinessFax(value[j]); break; case 16: contact.setBusinessAddress(value[j]); break; case 17: contact.setOtherPhone(value[j]); break; case 18: contact.setOtherFax(value[j]); break; case 19: contact.setOtherAddress(value[j]); break; } } m.update(contact.toString().getBytes()); if (log.isTraceEnabled()) log.trace(\"setting Md5 Hash...\"); contact.setMd5Hash(new BigInteger(m.digest()).toString()); contacts.add(contact); } if (log.isTraceEnabled()) log.trace(\"Mapping contacts uid...\"); Collections.sort(contacts); ArrayList<GmailContact> idList = getAllContactsID(); for (int i = 0; i < idList.size(); i++) { contacts.get(i).setId(idList.get(i).getId()); } if (log.isInfoEnabled()) log.info(\"getting all contacts info successful...\"); return contacts; } catch (HttpException e) { throw new GmailException(\"HttpException in csv file post:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in csv file post:\" + e.getMessage()); } catch (NoSuchAlgorithmException e) { throw new GmailException(\"No such md5 algorithm \" + e.getMessage()); } finally { post.releaseConnection(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Properties load(String propsName) { Properties props = new Properties(); URL url = ClassLoader.getSystemResource(propsName); try { props.load(url.openStream()); } catch (IOException e) { e.printStackTrace(); } return props; }. \n Code2: public static void main(String[] argv) { if (1 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).getChannel(); try { source.transferTo(0L, srclen, target",
        "ground_truth": "NO",
        "predict": "); } catch (IOException e) { e.printStackTrace(); } } } catch (IOException e) { e.printStackTrace(); } } } } } } }. \n */"
    },
    {
        "ID": 1191,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"deprecation\") public static final ReturnCode runCommand(IOBundle io, String[] args) { if ((args.length < 3) || (args.length > 4)) return ReturnCode.makeReturnCode(ReturnCode.RET_INVALID_NUM_ARGS, \"Invalid number of arguments: \" + args.length); if ((args.length == 3) && (!args[1].equals(\"show\"))) return ReturnCode.makeReturnCode(ReturnCode.RET_INVALID_NUM_ARGS, \"Invalid number of arguments: \" + args.length); if ((args.length == 4) && (!(args[2].equals(\"training\") || args[2].equals(\"log\") || args[2].equals(\"configuration\")))) return ReturnCode.makeReturnCode(ReturnCode.RET_BAD_REQUEST, \"Access denied to directory: \" + args[2]); if (args[1].equals(\"open\")) { final String fileName = args[2] + \"/\" + args[3]; final File file = new File(fileName); FileInputStream fis = null; BufferedInputStream bis = null; DataInputStream dis = null; try { fis = new FileInputStream(file); bis = new BufferedInputStream(fis); dis = new DataInputStream(bis); io.println(fileName); io.println(file.length() + \" bytes\"); while (dis.available() != 0) { io.println(dis.readLine()); } fis.close(); bis.close(); dis.close(); } catch (FileNotFoundException e) { e.printStackTrace(); return ReturnCode.makeReturnCode(ReturnCode.RET_NOT_FOUND, \"File \" + fileName + \" doesn't exist\"); } catch (IOException e) { e.printStackTrace(); return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"Error reading File \" + fileName); } } else if (args[1].equals(\"save\")) { final String fileName = args[2] + \"/\" + args[3]; String line; try { BufferedWriter out = new BufferedWriter(new FileWriter(fileName)); line = io.readLine(); int count = Integer.parseInt(line.trim()); while (count > 0) { out.write(io.read()); count = count - 1; } out.flush(); out.close(); } catch (IOException e) { e.printStackTrace(); return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"Error writing File \" + fileName); } } else if (args[1].equals(\"delete\")) { final String fileName = args[2] + \"/\" + args[3]; final File file = new File(fileName); if (!file.exists()) return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"No such file or directory: \" + fileName); if (!file.canWrite()) return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"File is write-protected: \" + fileName); if (file.isDirectory()) { String[] files = file.list(); if (files.length > 0) return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"Directory is not empty: \" + fileName); } if (!file.delete()) return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"Deletion failed: \" + fileName); } else if (args[1].equals(\"show\")) { File directory = new File(args[2]); String[] files; if ((!directory.isDirectory()) || (!directory.exists())) { return ReturnCode.makeReturnCode(ReturnCode.RET_IO_ERROR, \"No such directory: \" + directory); } int count = 0; files = directory.list(); io.println(\"Files in directory \\\"\" + directory + \"\\\":\"); for (int i = 0; i < files.length; i++) { directory = new File(files[i]); if (!directory.isDirectory()) { count++; io.println(\" \" + files[i]); } } io.println(\"Total \" + count + \" files\"); } else return ReturnCode.makeReturnCode(ReturnCode.RET_BAD_REQUEST, \"Unrecognized command\"); return ReturnCode.makeReturnCode(ReturnCode.RET_OK); }. \n Code2: public void doUpdateByIP() throws Exception { if (!isValidate()) { throw new CesSystemException(\"User_session.doUpdateByIP(): Illegal data values for update\"); } Connection con = null; PreparedStatement ps = null; String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \" mac_no = ?, login_id= ? \" + \"WHERE ip_address = ?\"; DBOperation dbo = factory.createDBOperation(POOL_NAME); try { con = dbo.getConnection(); con.setAutoCommit(false); ps = con.prepareStatement(strQuery); ps.setString(1, this.sessionID); ps.setInt(2, this.user.getUserID()); ps.setTimestamp(3, this.beginDate); ps.setString(4, this.macNO); ps.setString(5, this.loginID); ps.setString(6, this.ipAddress); int resultCount = ps.executeUpdate(); if (resultCount != 1) { con.rollback(); throw new CesSystemException(\"User_session.doUpdateByIP(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount); } con.commit(); } catch (SQLException se) { if (con != null) { con.rollback(); } throw new CesSystemException(\"User_session.doUpdateByIP(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se); } finally { con.setAutoCommit(true); closePreparedStatement(ps); closeConnection(dbo); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException { URLConnection conn = url.openConnection(); String contentType = conn.getContentType(); String encoding = conn.getContentEncoding(); if (encoding == null) { int i = contentType.indexOf(\"charset\"); if (i >= 0) { String s = contentType.substring(i); i = s.indexOf('='); if (i >= 0) { s = contentType.substring(i + 1",
        "ground_truth": "NO",
        "predict": "); try { encoding = s.substring(0, s.indexOf(';')); } catch (Exception e) { } } } } } if (encoding == null) { encoding = defaultEncoding; } if (encoding.equals(\"\")) { encoding = defaultEncoding; } if (encoding.equals(\"ISO-8859-1\")) { encoding = \"ISO-8859-1\"; } if (encoding.equals(\"UTF-8\")) { encoding = \"UTF-8\"; } if (encoding.equals(\"UTF-16\")) { encoding = \"UTF-16\"; } if (encoding.equals(\"UTF-16BE\")) { encoding = \"UTF-16BE\"; } if (encoding.equals(\"UTF-16LE\")) { encoding = \"UTF-16LE\"; } if (encoding.equals(\"UTF-32\")) { encoding = \"UTF-32\"; } if (encoding.equals(\"UTF-32BE\")) { encoding ="
    },
    {
        "ID": 1192,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String extractIconPath(String siteURL) throws IOException { siteURL = siteURL.trim(); if (!siteURL.startsWith(\"http://\")) { siteURL = \"http://\" + siteURL; } URL url = new URL(siteURL); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String iconURL = null; String iconPath = null; String inputLine; while ((inputLine = in.readLine()) != null) { if (inputLine.contains(\"type=\\\"image/x-icon\\\"\") || inputLine.toLowerCase().contains(\"rel=\\\"shortcut icon\\\"\")) { String tmp = new String(inputLine); String[] smallLines = inputLine.replace(\">\", \">\\n\").split(\"\\n\"); for (String smallLine : smallLines) { if (smallLine.contains(\"type=\\\"image/x-icon\\\"\") || smallLine.toLowerCase().contains(\"rel=\\\"shortcut icon\\\"\")) { tmp = smallLine; break; } } iconURL = tmp.replaceAll(\"^.*href=\\\"\", \"\"); iconURL = iconURL.replaceAll(\"\\\".*\", \"\"); tmp = null; String originalSiteURL = new String(siteURL); siteURL = getHome(siteURL); if (iconURL.charAt(0) == '/') { if (siteURL.charAt(siteURL.length() - 1) == '/') { iconURL = siteURL + iconURL.substring(1); } else { iconURL = siteURL + iconURL; } } else if (!iconURL.startsWith(\"http://\")) { if (siteURL.charAt(siteURL.length() - 1) == '/') { iconURL = siteURL + iconURL; } else { iconURL = siteURL + \"/\" + iconURL; } } siteURL = originalSiteURL; break; } if (inputLine.contains(\"</head>\".toLowerCase())) { break; } } in.close(); siteURL = getHome(siteURL); if (iconURL == null || \"\".equals(iconURL.trim())) { iconURL = \"favicon.ico\"; if (siteURL.charAt(siteURL.length() - 1) == '/') { iconURL = siteURL + iconURL; } else { iconURL = siteURL + \"/\" + iconURL; } } try { String iconFileName = siteURL; if (iconFileName.startsWith(\"http://\")) { iconFileName = iconFileName.substring(7); } iconFileName = iconFileName.replaceAll(\"\\\\W\", \" \").trim().replace(\" \", \"_\").concat(\".ico\"); iconPath = JReader.getConfig().getShortcutIconsDir() + File.separator + iconFileName; InputStream inIcon = new URL(iconURL).openStream(); OutputStream outIcon = new FileOutputStream(iconPath); byte[] buf = new byte[1024]; int len; while ((len = inIcon.read(buf)) > 0) { outIcon.write(buf, 0, len); } inIcon.close(); outIcon.close(); } catch (Exception e) { } return iconPath; }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out",
        "ground_truth": "NO",
        "predict": ".write((byte) ((b2 << 8) | b3)); } } } catch (Exception e) { } out.close(); in.close(); }. \n Code3: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.S"
    },
    {
        "ID": 1202,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void processOrder() { double neg = 0d; if (intMode == MODE_CHECKOUT) { if (round2Places(mBuf.getBufferTotal()) >= round2Places(order.getOrderTotal())) { double cash, credit, allowedCredit = 0d; allowedCredit = getStudentCredit(); if (settings.get(DBSettings.MAIN_ALLOWNEGBALANCES).compareTo(\"1\") == 0) { try { neg = Double.parseDouble(settings.get(DBSettings.MAIN_MAXNEGBALANCE)); } catch (NumberFormatException ex) { System.err.println(\"NumberFormatException::Potential problem with setting MAIN_MAXNEGBALANCE\"); System.err.println(\" * Note: If you enable negative balances, please don't leave this\"); System.err.println(\" blank. At least set it to 0. For right now we are setting \"); System.err.println(\" the max negative balance to $0.00\"); System.err.println(\"\"); System.err.println(\"Exception Message:\" + ex.getMessage()); } if (neg < 0) neg *= -1; allowedCredit += neg; } if (round2Places(mBuf.getCredit()) <= round2Places(allowedCredit)) { if (round2Places(mBuf.getCredit()) > round2Places(getStudentCredit()) && !student.isStudentSet()) { gui.setStatus(\"Can't allow negative balance on an anonymous student!\", true); } else { if (round2Places(mBuf.getCredit()) > round2Places(order.getOrderTotal())) { credit = round2Places(order.getOrderTotal()); } else { credit = round2Places(mBuf.getCredit()); } if ((mBuf.getCash() + credit) >= order.getOrderTotal()) { cash = round2Places(order.getOrderTotal() - credit); double change = round2Places(mBuf.getCash() - cash); if (round2Places(cash + credit) == round2Places(order.getOrderTotal())) { Connection conn = null; Statement stmt = null; ResultSet rs = null; try { conn = dbMan.getPOSConnection(); conn.setAutoCommit(false); stmt = conn.createStatement(); String host = getHostName(); String stuId = student.getStudentNumber(); String building = settings.get(DBSettings.MAIN_BUILDING); String cashier = dbMan.getPOSUser(); String strSql = \"insert into \" + strPOSPrefix + \"trans_master ( tm_studentid, tm_total, tm_cashtotal, tm_credittotal, tm_building, tm_register, tm_cashier, tm_datetime, tm_change ) values( '\" + stuId + \"', '\" + round2Places(order.getOrderTotal()) + \"', '\" + round2Places(cash) + \"', '\" + round2Places(credit) + \"', '\" + building + \"', '\" + host + \"', '\" + cashier + \"', NOW(), '\" + round2Places(change) + \"')\"; int intSqlReturnVal = -1; int masterID = -1; try { intSqlReturnVal = stmt.executeUpdate(strSql, Statement.RETURN_GENERATED_KEYS); ResultSet keys = stmt.getGeneratedKeys(); keys.next(); masterID = keys.getInt(1); keys.close(); stmt.close(); } catch (Exception exRetKeys) { System.err.println(exRetKeys.getMessage() + \" (but pscafepos is attempting a work around)\"); intSqlReturnVal = stmt.executeUpdate(strSql); masterID = dbMan.getLastInsertIDWorkAround(stmt, strPOSPrefix + \"trans_master_tm_id_seq\"); if (masterID == -1) System.err.println(\"It looks like the work around failed, please submit a bug report!\"); else System.err.println(\"work around was successful!\"); } if (intSqlReturnVal == 1) { if (masterID >= 0) { OrderItem[] itms = order.getOrderItems(); if (itms != null && itms.length > 0) { for (int i = 0; i < itms.length; i++) { if (itms[i] != null) { stmt = conn.createStatement(); int itemid = itms[i].getDBID(); double itemprice = round2Places(itms[i].getEffectivePrice()); int f, r, a; String strItemName, strItemBuilding, strItemCat; f = 0; r = 0; a = 0; if (itms[i].isSoldAsFree()) { f = 1; } if (itms[i].isSoldAsReduced()) { r = 1; } if (itms[i].isTypeA()) { a = 1; } strItemName = itms[i].getName(); strItemBuilding = (String) itms[i].getBuilding(); strItemCat = itms[i].getCategory(); if (stmt.executeUpdate(\"insert into \" + strPOSPrefix + \"trans_item ( ti_itemid, ti_tmid, ti_pricesold, ti_registerid, ti_cashier, ti_studentid, ti_isfree, ti_isreduced, ti_datetime, ti_istypea, ti_itemname, ti_itembuilding, ti_itemcat ) values('\" + itemid + \"', '\" + masterID + \"', '\" + round2Places(itemprice) + \"', '\" + host + \"', '\" + cashier + \"', '\" + stuId + \"', '\" + f + \"', '\" + r + \"', NOW(), '\" + a + \"', '\" + strItemName + \"', '\" + strItemBuilding + \"', '\" + strItemCat + \"')\") != 1) { gui.setCriticalMessage(\"Item insert failed\"); conn.rollback(); } stmt.close(); stmt = conn.createStatement(); String sqlInv = \"SELECT inv_id from \" + strPOSPrefix + \"inventory where inv_menuid = \" + itemid + \"\"; if (stmt.execute(sqlInv)) { ResultSet rsInv = stmt.getResultSet(); int delId = -1; if (rsInv.next()) { delId = rsInv.getInt(\"inv_id\"); } if (delId != -1) { stmt.executeUpdate(\"delete from \" + strPOSPrefix + \"inventory where inv_id = \" + delId); } stmt.close(); } } else { gui.setCriticalMessage(\"Null Item\"); conn.rollback(); } } boolean bl",
        "ground_truth": "NO",
        "predict": "nSuccessful = true; if (blnSuccessful) { if (order.getOrderItems() != null && order.getOrderItems().length > 0) { blnSuccessful = false; } } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccessful = false; } if (blnSuccessful) { blnSuccess"
    },
    {
        "ID": 1206,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String crypt(String password, String salt) { if (salt.startsWith(magic)) { salt = salt.substring(magic.length()); } int saltEnd = salt.indexOf('$'); if (saltEnd != -1) { salt = salt.substring(0, saltEnd); } if (salt.length() > 8) { salt = salt.substring(0, 8); } MessageDigest md5_1, md5_2; try { md5_1 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } md5_1.update(password.getBytes()); md5_1.update(magic.getBytes()); md5_1.update(salt.getBytes()); try { md5_2 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } md5_2.update(password.getBytes()); md5_2.update(salt.getBytes()); md5_2.update(password.getBytes()); byte[] md5_2_digest = md5_2.digest(); int md5Size = md5_2_digest.length; int pwLength = password.length(); for (int i = pwLength; i > 0; i -= md5Size) { md5_1.update(md5_2_digest, 0, i > md5Size ? md5Size : i); } md5_2.reset(); byte[] pwBytes = password.getBytes(); for (int i = pwLength; i > 0; i >>= 1) { if ((i & 1) == 1) { md5_1.update((byte) 0); } else { md5_1.update(pwBytes[0]); } } StringBuffer output = new StringBuffer(magic); output.append(salt); output.append(\"$\"); byte[] md5_1_digest = md5_1.digest(); byte[] saltBytes = salt.getBytes(); for (int i = 0; i < 1000; i++) { md5_2.reset(); if ((i & 1) == 1) { md5_2.update(pwBytes); } else { md5_2.update(md5_1_digest); } if (i % 3 != 0) { md5_2.update(saltBytes); } if (i % 7 != 0) { md5_2.update(pwBytes); } if ((i & 1) != 0) { md5_2.update(md5_1_digest); } else { md5_2.update(pwBytes); } md5_1_digest = md5_2.digest(); } int value; value = ((md5_1_digest[0] & 0xff) << 16) | ((md5_1_digest[6] & 0xff) << 8) | (md5_1_digest[12] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[1] & 0xff) << 16) | ((md5_1_digest[7] & 0xff) << 8) | (md5_1_digest[13] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[2] & 0xff) << 16) | ((md5_1_digest[8] & 0xff) << 8) | (md5_1_digest[14] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[3] & 0xff) << 16) | ((md5_1_digest[9] & 0xff) << 8) | (md5_1_digest[15] & 0xff); output.append(cryptTo64(value, 4)); value = ((md5_1_digest[4] & 0xff) << 16) | ((md5_1_digest[10] & 0xff) << 8) | (md5_1_digest[5] & 0xff); output.append(cryptTo64(value, 4)); value = md5_1_digest[11] & 0xff; output.append(cryptTo64(value, 2)); md5_1 = null; md5_2 = null; md5_1_digest = null; md5_2_digest = null; pwBytes = null; saltBytes = null; password = salt = null; return output.toString(); }. \n Code2: private void copyFile(String from, String to) throws Exception { URL monitorCallShellScriptUrl = Thread.currentThread().getContextClassLoader().getResource(from); File inScriptFile = null; try { inScriptFile = new File(monitorCallShellScriptUrl.toURI()); } catch (URISyntaxException e) { throw e; } File outScriptFile = new File(to); FileChannel inChannel = new FileInputStream(inScriptFile).getChannel(); FileChannel outChannel = new FileOutputStream(outScriptFile).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } catch (IOException e) { throw e; } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } try { LinuxCommandExecutor cmdExecutor = new LinuxCommandExecutor(); cmdExecutor.setWorkingDirectory(workingDirectory); cmdExecutor.runCommand(\"chmod 777 \" + to); } catch (Exception e) { throw e; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \n Code2: public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException { ConnectionProvider cp = null; Connection conn = null; ResultSet rs = null; PreparedStatement pstmt = null; PrivilegeFactory factory = PrivilegeFactory.getInstance(); Operation op = factory.createOperation(); try { cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE); conn = cp.getConnection(); try { pstmt = conn.prepareStatement(DEL_ROLE_PERM); pstmt.setString(",
        "ground_truth": "NO",
        "predict": "1, roleid); pstmt.executeUpdate(); } catch (SQLException e) { throw e; } } catch (Exception e) { throw e; } finally { if (rs != null) rs.close(); if (pstmt != null) pstmt.close(); if (conn != null) conn.close(); if (cp != null) cp.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException { MessageDigest md; md = MessageDigest.getInstance(\"MD5\"); byte[] md5hash = new byte[32]; md.update(text.getBytes(\"iso-8859-1\"), 0, text.length()); md5hash = md.digest(); return convertToHex(md5hash); }. \n"
    },
    {
        "ID": 1209,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward sendTrackback(ActionMapping mapping, ActionForm actionForm, HttpServletRequest request, HttpServletResponse response) throws RollerException { ActionForward forward = mapping.findForward(\"weblogEdit.page\"); ActionErrors errors = new ActionErrors(); WeblogEntryData entry = null; try { RollerRequest rreq = RollerRequest.getRollerRequest(request); if (rreq.isUserAuthorizedToEdit()) { WeblogEntryFormEx form = (WeblogEntryFormEx) actionForm; String entryid = form.getId(); if (entryid == null) { entryid = request.getParameter(RollerRequest.WEBLOGENTRYID_KEY); } RollerContext rctx = RollerContext.getRollerContext(request); WeblogManager wmgr = rreq.getRoller().getWeblogManager(); entry = wmgr.retrieveWeblogEntry(entryid); String title = entry.getTitle(); PageHelper pageHelper = PageHelper.createPageHelper(request, response); pageHelper.setSkipFlag(true); String excerpt = pageHelper.renderPlugins(entry); excerpt = StringUtils.left(Utilities.removeHTML(excerpt), 255); String url = rctx.createEntryPermalink(entry, request, true); String blog_name = entry.getWebsite().getName(); if (form.getTrackbackUrl() != null) { try { String data = URLEncoder.encode(\"title\", \"UTF-8\") + \"=\" + URLEncoder.encode(title, \"UTF-8\"); data += (\"&\" + URLEncoder.encode(\"excerpt\", \"UTF-8\") + \"=\" + URLEncoder.encode(excerpt, \"UTF-8\")); data += (\"&\" + URLEncoder.encode(\"url\", \"UTF-8\") + \"=\" + URLEncoder.encode(url, \"UTF-8\")); data += (\"&\" + URLEncoder.encode(\"blog_name\", \"UTF-8\") + \"=\" + URLEncoder.encode(blog_name, \"UTF-8\")); URL tburl = new URL(form.getTrackbackUrl()); URLConnection conn = tburl.openConnection(); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; StringBuffer resultBuff = new StringBuffer(); while ((line = rd.readLine()) != null) { resultBuff.append(Utilities.escapeHTML(line, true)); resultBuff.append(\"<br />\"); } ActionMessages resultMsg = new ActionMessages(); resultMsg.add(ActionMessages.GLOBAL_MESSAGE, new ActionMessage(\"weblogEdit.trackbackResults\", resultBuff)); saveMessages(request, resultMsg); wr.close(); rd.close(); } catch (IOException e) { errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.trackback\", e)); } } else { errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.noTrackbackUrlSpecified\")); } form.setTrackbackUrl(null); } else { forward = mapping.findForward(\"access-denied\"); } } catch (Exception e) { mLogger.error(e); String msg = e.getMessage(); if (msg == null) { msg = e.getClass().getName(); } errors.add(ActionErrors.GLOBAL_ERROR, new ActionError(\"error.general\", msg)); } if (!errors.isEmpty()) { saveErrors(request, errors); } request.setAttribute(\"model\", new WeblogEntryPageModel(request, response, mapping, (WeblogEntryFormEx) actionForm, WeblogEntryPageModel.EDIT_MODE)); return forward; }. \n Code2: public static String calculateHash(String data, String algorithm) { if (data == null) { return null; } algorithm = (algorithm == null ? INTERNAL : algorithm.toUpperCase()); if (algorithm.equals(PLAIN)) { return data; } if (algorithm.startsWith(\"{RSA}\")) { return encode(data, algorithm.substring(5), \"RSA\"); } try { MessageDigest md = MessageDigest.getInstance(algorithm); md.update(data.getBytes(\"UTF-8\")); return getHashString(md.digest()); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage()); return null; } catch (NoSuchAlgorithmException nsae) { logger.error(nsae.getMessage()); return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"unchecked\") public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException { StringBuilder json = new StringBuilder(); String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key; try { URL url = new URL(requestUrl.toString()); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; while ((inputLine = in.readLine()) != null) { json.append(inputLine); } in.close(); } catch (IOException e) { throw new GtugsException(e); } List<Event> events = new ArrayList<Event>(); JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString()); JSONArray results = (JSONArray) jsonObj.get(\"results\"); for (int i = 0; i < results.size(); i++) { JSONObject result = (JSONObject) results.get(i); Event e = new Event(); e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\"))); e.setCity((String) result.get(\"venue_city\")); e.setDescription((String) result.get(\"description\")); e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\"))); e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\"))); e.setName((String) result.get(\"name\")); Date myDate = null; String time = (String) result.get(\"time\"); try { myDate = meetupDateFormat.parse(time); e.setStartTime(timeDateFormat.format(myDate)); e.setEndTime(timeDateFormat.format(myDate)); e.setStartDate(myDate); e.setEndDate(myDate); String tz = tzDateFormat.format(myDate",
        "ground_truth": "NO",
        "predict": "); e.setTimeZone(tz); } catch (ParseException pe) { logger.error(pe.getMessage()); } } return events; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"unchecked\") public List<Event> lookupPastEvents(String groupIdentifier) throws GtugsException { StringBuilder json = new StringBuilder(); String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key; try { URL url = new URL(requestUrl.toString()); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String inputLine; while ((inputLine = in.readLine()) != null) { json.append(inputLine); } in.close(); } catch (IOException e) { throw new"
    },
    {
        "ID": 1216,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int procesar() { int mas = 0; String uriOntologia = \"\", source = \"\", uri = \"\"; String fichOrigenHTML = \"\", fichOrigenLN = \"\"; String ficheroOutOWL = \"\"; md5 firma = null; StringTokenV2 entra = null, entra2 = null, entra3 = null; FileInputStream lengNat = null; BufferedInputStream lengNat2 = null; DataInputStream entradaLenguajeNatural = null; FileWriter salOWL = null; BufferedWriter salOWL2 = null; PrintWriter salidaOWL = null; String sujeto = \"\", verbo = \"\", CD = \"\", CI = \"\", fraseOrigen = \"\"; StringTokenV2 token2; boolean bandera = false; OntClass c = null; OntClass cBak = null; String claseTrabajo = \"\"; String nombreClase = \"\", nombrePropiedad = \"\", variasPalabras = \"\"; int incre = 0, emergencia = 0; String lineaSalida = \"\"; String[] ontologia = new String[5]; ontologia[0] = \"http://www.criado.info/owl/vertebrados_es.owl#\"; ontologia[1] = \"http://www.w3.org/2001/sw/WebOnt/guide-src/wine#\"; ontologia[2] = \"http://www.co-ode.org/ontologies/pizza/2005/10/18/pizza.owl#\"; ontologia[3] = \"http://www.w3.org/2001/sw/WebOnt/guide-src/food#\"; ontologia[4] = \"http://www.daml.org/2001/01/gedcom/gedcom#\"; String[] ontologiaSource = new String[5]; ontologiaSource[0] = this.directorioMapeo + \"\\\\\" + \"mapeo_vertebrados_es.xml\"; ontologiaSource[1] = this.directorioMapeo + \"\\\\\" + \"mapeo_wine_es.xml\"; ontologiaSource[2] = this.directorioMapeo + \"\\\\\" + \"mapeo_pizza_es.xml\"; ontologiaSource[3] = this.directorioMapeo + \"\\\\\" + \"mapeo_food_es.xml\"; ontologiaSource[4] = this.directorioMapeo + \"\\\\\" + \"mapeo_parentesco_es.xml\"; mapeoIdiomas clasesOntologias; try { if ((entrada = entradaFichero.readLine()) != null) { if (entrada.trim().length() > 10) { entrada2 = new StringTokenV2(entrada.trim(), \"\\\"\"); if (entrada2.isIncluidaSubcadena(\"<fichero ontologia=\")) { ontologiaOrigen = entrada2.getToken(2); fichOrigenHTML = entrada2.getToken(4); fichOrigenLN = entrada2.getToken(6); if (ontologiaOrigen.equals(\"VERTEBRADOS\")) { source = ontologiaSource[0]; uriOntologia = ontologia[0]; } if (ontologiaOrigen.equals(\"WINE\")) { source = ontologiaSource[1]; uriOntologia = ontologia[1]; } if (ontologiaOrigen.equals(\"PIZZA\")) { source = ontologiaSource[2]; uriOntologia = ontologia[2]; } if (ontologiaOrigen.equals(\"FOOD\")) { source = ontologiaSource[3]; uriOntologia = ontologia[3]; } if (ontologiaOrigen.equals(\"PARENTESCOS\")) { source = ontologiaSource[4]; uriOntologia = ontologia[4]; } firma = new md5(uriOntologia, false); clasesOntologias = new mapeoIdiomas(source); uri = \"\"; ficheroOutOWL = \"\"; entra2 = new StringTokenV2(fichOrigenHTML, \"\\\\\"); int numToken = entra2.getNumeroTokenTotales(); entra = new StringTokenV2(fichOrigenHTML, \" \"); if (entra.isIncluidaSubcadena(directorioLocal)) { entra = new StringTokenV2(entra.getQuitar(directorioLocal) + \"\", \" \"); uri = entra.getCambiar(\"\\\\\", \"/\"); uri = entra.getQuitar(entra2.getToken(numToken)) + \"\"; entra3 = new StringTokenV2(entra2.getToken(numToken), \".\"); ficheroOutOWL = entra3.getToken(1) + \"_\" + firma.toString() + \".owl\"; uri = urlPatron + uri + ficheroOutOWL; } entra3 = new StringTokenV2(fichOrigenHTML, \".\"); ficheroOutOWL = entra3.getToken(1) + \"_\" + firma.toString() + \".owl\"; lineaSalida = \"<vistasemantica origen=\\\"\" + fichOrigenLN + \"\\\" destino=\\\"\" + uri + \"\\\" />\"; lengNat = new FileInputStream(fichOrigenLN); lengNat2 = new BufferedInputStream(lengNat); entradaLenguajeNatural = new DataInputStream(lengNat2); salOWL = new FileWriter(ficheroOutOWL); salOWL2 = new BufferedWriter(salOWL); salidaOWL = new PrintWriter(salOWL2); while ((entradaInstancias = entradaLenguajeNatural.readLine()) != null) { sujeto = \"\"; verbo = \"\"; CD = \"\"; CI = \"\"; fraseOrigen = \"\"; if (entradaInstancias.trim().length() > 10) { entrada2 = new StringTokenV2(entradaInstancias.trim(), \"\\\"\"); if (entrada2.isIncluidaSubcadena(\"<oracion sujeto=\")) { sujeto = entrada2.getToken(2).trim(); verbo = entrada2.getToken(4).trim(); CD = entrada2.getToken(6).trim(); CI = entrada2.getToken(8).trim(); fraseOrigen = entrada2.getToken(10).trim(); if (sujeto.length() > 0 & ver",
        "ground_truth": "NO",
        "predict": "bo.length() > 0 & CD.length() > 0 & CI.length() > 0 & fraseOrigen.length() > 0) { token2 = new StringTokenV2(sujeto, \" \"); token2 = new StringTokenV2(verbo, \" \"); token2 = new StringTokenV2(CD, \" \"); token2 = new StringTokenV2(CI, \" \"); token2 = new StringTokenV2(fraseOrigen, \" \"); token2 = new StringTokenV2(token2.getToken(0), \" \"); token2 = new StringTokenV2(token2.getToken(1), \" \"); token2 = new StringTokenV2(token2.getToken(2), \" \"); token2 = new StringTokenV2(token2.getToken(3), \" \"); token2 = new StringTokenV2(token2.getToken(4), \" \"); token2 = new StringTokenV2"
    },
    {
        "ID": 1222,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Pedido insert(Pedido objPedido) { final Connection c = DBConnection.getConnection(); PreparedStatement pst = null; int result; if (c == null) { return null; } try { c.setAutoCommit(false); String sql = \"\"; int idPedido; idPedido = PedidoDAO.getLastCodigo(); if (idPedido < 1) { return null; } sql = \"insert into pedido \" + \"(id_pedido, id_funcionario,data_pedido,valor) \" + \"values(?,?,now(),truncate(?,2))\"; pst = c.prepareStatement(sql); pst.setInt(1, idPedido); pst.setInt(2, objPedido.getFuncionario().getCodigo()); pst.setString(3, new DecimalFormat(\"#0.00\").format(objPedido.getValor())); result = pst.executeUpdate(); pst = null; if (result > 0) { Iterator<ItemPedido> itItemPedido = (objPedido.getItemPedido()).iterator(); while ((itItemPedido != null) && (itItemPedido.hasNext())) { ItemPedido objItemPedido = (ItemPedido) itItemPedido.next(); sql = \"\"; sql = \"insert into item_pedido \" + \"(id_pedido,id_produto,quantidade,subtotal) \" + \"values (?,?,?,truncate(?,2))\"; pst = c.prepareStatement(sql); pst.setInt(1, idPedido); pst.setInt(2, (objItemPedido.getProduto()).getCodigo()); pst.setInt(3, objItemPedido.getQuantidade()); pst.setString(4, new DecimalFormat(\"#0.00\").format(objItemPedido.getSubtotal())); result = pst.executeUpdate(); } } pst = null; sql = \"\"; sql = \"insert into pedido_situacao \" + \"(id_pedido,id_situacao, em, observacao, id_funcionario) \" + \"values (?,?,now(), ?, ?)\"; pst = c.prepareStatement(sql); pst.setInt(1, idPedido); pst.setInt(2, 1); pst.setString(3, \"Inclus\ufffdo de pedido\"); pst.setInt(4, objPedido.getFuncionario().getCodigo()); result = pst.executeUpdate(); pst = null; sql = \"\"; sql = \"insert into tramitacao \" + \"(data_tramitacao, id_pedido, id_dep_origem, id_dep_destino) \" + \"values (now(),?,?, ?)\"; pst = c.prepareStatement(sql); pst.setInt(1, idPedido); pst.setInt(2, 6); pst.setInt(3, 2); result = pst.executeUpdate(); c.commit(); objPedido.setCodigo(idPedido); } catch (final Exception e) { try { c.rollback(); } catch (final Exception e1) { System.out.println(\"[PedidoDAO.insert] Erro ao inserir -> \" + e1.getMessage()); } System.out.println(\"[PedidoDAO.insert] Erro ao inserir -> \" + e.getMessage()); } finally { DBConnection.closePreparedStatement(pst); DBConnection.closeConnection(c); } return objPedido; }. \n Code2: public APIResponse update(Item item) throws Exception { APIResponse response = new APIResponse(); connection = (HttpURLConnection) new URL(url + \"/api/item/update\").openConnection(); connection.setDoOutput(true); connection.setRequestMethod(\"PUT\"); connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\"); connection.setUseCaches(false); connection.setConnectTimeout(TIMEOUT); connection.connect(); marshaller.marshal(item, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\"))); connection.getOutputStream().flush(); connection.getOutputStream().close(); if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) { JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine())); response.setDone(true); response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration())))); connection.getInputStream().close(); } else { response.setDone(false); response.setMessage(\"Update Item Error Code: Http (\" + connection.getResponseCode() + \")\"); } connection.disconnect(); return response; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String connRemote(JSONObject jsonObject, String OPCode) { String retSrc = \"\"; try { HttpClient httpClient = new DefaultHttpClient(); HttpPost httpPost = new HttpPost(AZConstants.validateURL); HttpParams httpParams = new BasicHttpParams(); List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>(); nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode)); nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString())); httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair)); httpPost.setParams(httpParams); HttpResponse response = httpClient.execute(httpPost); retSrc = EntityUtils.toString(response.getEntity()); } catch (Exception e) { Log.e(TAG, e.toString()); } return retSrc; }. \n Code2: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read",
        "ground_truth": "NO",
        "predict": " = 0; while ((read = in.read(buffer)) != -1) { out.write(buffer, 0, read); } } catch (java.io.IOException e) { Log.e(TAG, e.toString()); } finally { try { if (in != null) in.close(); } catch (java.io.IOException e) { Log.e(TAG, e.toString()); } try { if (out != null) out.close(); } catch (java.io.IOException e) { Log.e(TAG, e.toString()); } } return success; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64"
    },
    {
        "ID": 1225,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File src, File dst) throws IOException { FileChannel inChannel = new FileInputStream(src).getChannel(); FileChannel outChannel = new FileOutputStream(dst).getChannel(); try { inChannel.transferTo(0, inChannel.size(), outChannel); } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } }. \n Code2: private static void reconfigureDebug() { useFile = false; logValue = 0; String methodString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.method']/@value\"); String levelString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.level']/@value\"); String quietString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.quiet']/@value\"); String fileString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.file']/@value\"); String filemodeString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.filemode']/@value\"); String calltraceString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.calltrace']/@value\"); String rotateTimeoutString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatetimeout']/@value\"); String rotateDestString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedest']/@value\"); String rotateCompressString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatecompress']/@value\"); String rotateDaysString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedays']/@value\"); String rotateArchiveString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatearchive']/@value\"); String rotateDeleteString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedelete']/@value\"); String dirName = \".\"; if (rotateTimeoutString != null) { rotateTimeout = Integer.parseInt(rotateTimeoutString); } if (rotateDestString != null) { rotateDest = rotateDestString; } if (rotateCompressString != null && rotateCompressString.equalsIgnoreCase(\"true\")) { rotateCompress = true; } if (rotateDaysString != null) { rotateDays = Integer.parseInt(rotateDaysString); } if (rotateArchiveString != null) { rotateArchive = rotateArchiveString; } if (rotateDeleteString != null && rotateDeleteString.equalsIgnoreCase(\"true\")) { rotateDelete = true; } if (fileString != null && fileString.indexOf(\"/\") != -1) { dirName = fileString.substring(0, fileString.lastIndexOf(\"/\")); (new File(dirName)).mkdirs(); } if (methodString != null) { logMethod = methodString; } else { logMethod = \"file\"; } if (levelString != null) { logValue = Integer.parseInt(levelString); } else { logValue = 0; } if (calltraceString != null && calltraceString.equalsIgnoreCase(\"true\")) { calltrace = true; } else { calltrace = false; } if (logMethod == null) { logMethod = \"file\"; } if (quietString != null) { if (quietString.equalsIgnoreCase(\"true\")) { beQuiet = true; } } if (logMethod != null) { if (logMethod.equalsIgnoreCase(\"file\")) { if (fileString != null) { logFile = fileString; } else { logFile = \"log.txt\"; } useFile = true; } } else { System.err.println(\"*** A debugging method (debug.method) is required in properties file!\"); System.err.println(\"*** Please refer to configuration documentation.\"); System.exit(-1); } timesRepeated = 0; lastMessage = null; if (useFile) { logfile = new File(logFile); try { if (filemodeString != null && filemodeString.equalsIgnoreCase(\"append\")) { ps = new PrintStream(new FileOutputStream(logfile, true)); } else { ps = new PrintStream(new FileOutputStream(logfile)); } isFile = true; Calendar calendar = new GregorianCalendar(); Date date = calendar.getTime(); DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); ps.println(); ps.println(\"--- Log file opened \" + format1.format(date) + \" ---\"); } catch (FileNotFoundException e) { System.out.println(\"Debug: Unable to instantiate debugger: \" + e.getMessage()); System.exit(-1); } catch (Exception e) { System.out.println(\"Debug: Unable to instantiate debugger - internal error: \" + e.getMessage()); System.exit(-1); } } if (!registeredSchedule) { registeredSchedule = true; if (Server.getScheduler() != null) { Server.getScheduler().register(\"Log File Rotator for '\" + logFile + \"'\", new SchedulerInterface() { public int getScheduleRate() { if (rotateTimeout != 0) { return rotateTimeout / 10; } return 0; } public void handle() { FileChannel srcChannel, destChannel; String destOutFile = logFile + \".\" + System.currentTimeMillis(); String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\"; if (rotateDest != null) { (new File(rotateDest)).mkdirs(); if (destOutFile.indexOf(\"/\") != -1) { destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);",
        "ground_truth": "NO",
        "predict": " } if (rotateCompress) { destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1); } } try { srcChannel = new FileInputStream(logFile).getChannel(); destChannel = new FileOutputStream(destOutFile).getChannel(); if (rotateCompress) { destChannel = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed)).getChannel(); } try { srcChannel.transferTo(0, srcChannel.size(), destChannel); } finally { if (srcChannel != null) srcChannel.close(); if (destChannel != null) destChannel.close(); } } catch (IOException e) { System.out.println(\"Debug: Unable to rotate log file: \" + e.getMessage()); } } }); } }\n"
    },
    {
        "ID": 1227,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: @Override public String toString() { if (byteArrayOutputStream == null) return \"<Unparsed binary data: Content-Type=\" + getHeader(\"Content-Type\") + \" >\"; String charsetName = getCharsetName(); if (charsetName == null) charsetName = \"ISO-8859-1\"; try { if (unzip) { GZIPInputStream gzipInputStream = new GZIPInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); ByteArrayOutputStream unzippedResult = new ByteArrayOutputStream(); IOUtils.copy(gzipInputStream, unzippedResult); return unzippedResult.toString(charsetName); } else { return byteArrayOutputStream.toString(charsetName); } } catch (UnsupportedEncodingException e) { throw new OutputException(e); } catch (IOException e) { throw new OutputException(e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public NodeId generateTopicId(String topicName) { MessageDigest md = null; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { System.err.println(\"No SHA support!\"); } if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName); md.update(topicName.getBytes()); byte[] digest = md.digest(); NodeId newId = new NodeId(digest); return newId; }. \n Code2: public static void copy(File from, File to) { boolean result; if (from.isDirectory()) { File[] subFiles = from.listFiles(); for (int i = 0; i < subFiles.length; i++) { File newDir = new File(to, subFiles[i].getName()); result = false; if (subFiles[i].isDirectory()) { if (newDir.exists()) result = true; else result = newDir.mkdirs(); } else if (subFiles[i].isFile()) { try { result = newDir.createNewFile(); } catch (IOException e) { log.error(\"unable to create new file: \" + newDir, e); result = false; } } if (result) copy(subFiles[i], newDir); } } else if (from.isFile()) { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(from); out = new FileOutputStream(to); int fileLength = (int) from.length(); char charBuff[] = new char[fileLength]; int len;",
        "ground_truth": "NO",
        "predict": " while ((len = in.read(charBuff)) > 0) out.write(charBuff, 0, len); } catch (IOException e) { log.error(\"unable to copy file: \" + from, e); } finally { try { in.close(); } catch (IOException e) { } try { out.close(); } catch (IOException e) { } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setReady(boolean ready) { m_ready = ready; }. \n Code2: public static void main(String[] args) { if (args.length < 2) { System.out.println(\"Usage: java -cp .:scribe.jar org.apache.nutch.scribe.Scribe <topic> <message>\"); System.exit(1); } Scribe scribe = new Scribe(); scribe.set"
    },
    {
        "ID": 1228,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public BufferedImage extract() throws DjatokaException { boolean useRegion = false; int left = 0; int top = 0; int width = 50; int height = 50; boolean useleftDouble = false; Double leftDouble = 0.0; boolean usetopDouble = false; Double topDouble = 0.0; boolean usewidthDouble = false; Double widthDouble = 0.0; boolean useheightDouble = false; Double heightDouble = 0.0; if (params.getRegion() != null) { StringTokenizer st = new StringTokenizer(params.getRegion(), \"{},\"); String token; if ((token = st.nextToken()).contains(\".\")) { topDouble = Double.parseDouble(token); usetopDouble = true; } else top = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { leftDouble = Double.parseDouble(token); useleftDouble = true; } else left = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { heightDouble = Double.parseDouble(token); useheightDouble = true; } else height = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { widthDouble = Double.parseDouble(token); usewidthDouble = true; } else width = Integer.parseInt(token); useRegion = true; } try { if (is != null) { File f = File.createTempFile(\"tmp\", \".jp2\"); f.deleteOnExit(); FileOutputStream fos = new FileOutputStream(f); sourceFile = f.getAbsolutePath(); IOUtils.copyStream(is, fos); is.close(); fos.close(); } } catch (IOException e) { throw new DjatokaException(e); } try { Jp2_source inputSource = new Jp2_source(); Kdu_compressed_source input = null; Jp2_family_src jp2_family_in = new Jp2_family_src(); Jp2_locator loc = new Jp2_locator(); jp2_family_in.Open(sourceFile, true); inputSource.Open(jp2_family_in, loc); inputSource.Read_header(); input = inputSource; Kdu_codestream codestream = new Kdu_codestream(); codestream.Create(input); Kdu_channel_mapping channels = new Kdu_channel_mapping(); if (inputSource.Exists()) channels.Configure(inputSource, false); else channels.Configure(codestream); int ref_component = channels.Get_source_component(0); Kdu_coords ref_expansion = getReferenceExpansion(ref_component, channels, codestream); Kdu_dims image_dims = new Kdu_dims(); codestream.Get_dims(ref_component, image_dims); Kdu_coords imageSize = image_dims.Access_size(); Kdu_coords imagePosition = image_dims.Access_pos(); if (useleftDouble) left = imagePosition.Get_x() + (int) Math.round(leftDouble * imageSize.Get_x()); if (usetopDouble) top = imagePosition.Get_y() + (int) Math.round(topDouble * imageSize.Get_y()); if (useheightDouble) height = (int) Math.round(heightDouble * imageSize.Get_y()); if (usewidthDouble) width = (int) Math.round(widthDouble * imageSize.Get_x()); if (useRegion) { imageSize.Set_x(width); imageSize.Set_y(height); imagePosition.Set_x(left); imagePosition.Set_y(top); } int reduce = 1 << params.getLevelReductionFactor(); imageSize.Set_x(imageSize.Get_x() * ref_expansion.Get_x()); imageSize.Set_y(imageSize.Get_y() * ref_expansion.Get_y()); imagePosition.Set_x(imagePosition.Get_x() * ref_expansion.Get_x() / reduce - ((ref_expansion.Get_x() / reduce - 1) / 2)); imagePosition.Set_y(imagePosition.Get_y() * ref_expansion.Get_y() / reduce - ((ref_expansion.Get_y() / reduce - 1) / 2)); Kdu_dims view_dims = new Kdu_dims(); view_dims.Assign(image_dims); view_dims.Access_size().Set_x(imageSize.Get_x()); view_dims.Access_size().Set_y(imageSize.Get_y()); int region_buf_size = imageSize.Get_x() * imageSize.Get_y(); int[] region_buf = new int[region_buf_size]; Kdu_region_decompressor decompressor = new Kdu_region_decompressor(); decompressor.Start(codestream, channels, -1, params.getLevelReductionFactor(), 16384, image_dims, ref_expansion, new Kdu_coords(1, 1), false, Kdu_global.KDU_WANT_OUTPUT_COMPONENTS); Kdu_dims new_region = new Kdu_dims(); Kdu_dims incomplete_region = new Kdu_dims(); Kdu_coords viewSize = view_dims.Access_size(); incomplete_region.Assign(image_dims); int[] imgBuffer = new int[viewSize.Get_x() * viewSize.Get_y()]; int[] kduBuffer = null; while (decompressor.Process(region_buf, image_dims.Access_pos(), 0, 0, region_buf_size, incomplete_region, new_region)) { Kdu_coords newOffset = new_region.Access_pos(); Kdu_coords newSize = new_region.Access_size(); newOffset.Subtract(view_dims.Access_pos()); kduBuffer = region_buf; int imgBuffereIdx = newOffset.Get_x() + newOffset.Get_y() * viewSize.Get_x(); int kduBufferIdx = 0; int xDiff = viewSize.Get_x() - newSize.Get_x(); for (int j = 0; j < newSize.Get_y(); j++, imgBuffereIdx += xDiff) { for (int i = 0; i < newSize.Get_x(); i++) { imgBuffer[imgBuffereIdx++] = kduBuffer[kduBufferIdx++]; } } } BufferedImage image = new BufferedImage(imageSize.Get_x(), imageSize.Get_y(), BufferedImage.TYPE_INT_RGB); image.set",
        "ground_truth": "NO",
        "predict": "RGB(0, 0, imageSize.Get_x(), imageSize.Get_y(), imgBuffer, 0, imageSize.Get_x()); return image; } catch (Exception e) { throw new DjatokaException(e); } }\n\n}\n"
    },
    {
        "ID": 1232,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void compressZip(String source, String dest) throws Exception { File baseFolder = new File(source); if (baseFolder.exists()) { if (baseFolder.isDirectory()) { List<File> fileList = getSubFiles(new File(source)); ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest)); zos.setEncoding(\"GBK\"); ZipEntry entry = null; byte[] buf = new byte[2048]; int readLen = 0; for (int i = 0; i < fileList.size(); i++) { File file = fileList.get(i); if (file.isDirectory()) { entry = new ZipEntry(getAbsFileName(source, file) + \"/\"); } else { entry = new ZipEntry(getAbsFileName(source, file)); } entry.setSize(file.length()); entry.setTime(file.lastModified()); zos.putNextEntry(entry); if (file.isFile()) { InputStream in = new BufferedInputStream(new FileInputStream(file)); while ((readLen = in.read(buf, 0, 1024)) != -1) { zos.write(buf, 0, readLen); } in.close(); } } zos.close(); } else { throw new Exception(\"Can not do this operation!.\"); } } else { baseFolder.mkdirs(); compressZip(source, dest); } }. \n Code2: private void doIt() throws Throwable { int numCachedTiles = 0; try { List<MapTile> backTiles = new ArrayList<MapTile>(); final LatLngRectangle bounds = new LatLngRectangle(new LatLngPoint(south, west), new LatLngPoint(north, east)); final String backMapGuid = \"gst\"; final XFile dstDir = new XFile(new XFile(Configuration.getInstance().getPublicMapStorage().toString()), backMapGuid); dstDir.mkdir(); for (int z = Math.min(Tile.getOptimalZoom(bounds, 768), 9); z <= 17; z++) { final Tile tileStart = new Tile(bounds.getSouthWest().getLat(), bounds.getSouthWest().getLng(), z); final Tile tileEnd = new Tile(bounds.getNorthEast().getLat(), bounds.getNorthEast().getLng(), z); for (double y = tileEnd.getTileCoord().getY(); y <= tileStart.getTileCoord().getY(); y++) for (double x = tileStart.getTileCoord().getX(); x <= tileEnd.getTileCoord().getX(); x++) { NASAMapTile tile = new NASAMapTile((int) x, (int) y, z); XFile file = new XFile(dstDir, tile.toKeyString()); if (file.exists() && file.isFile()) continue; backTiles.add(tile); } } logger.info(backTiles.size() + \" tiles to cache\"); for (MapTile tile : backTiles) { InputStream in = null; OutputStream out = null; final URL url = new URL(tile.getPath()); try { int i = 4; while (--i > 0) { final XFile outFile = new XFile(dstDir, tile.toKeyString()); final URLConnection conn = url.openConnection(); if (conn == null || !conn.getContentType().startsWith(\"image\")) { logger.error(\"onearth.jpl.nasa.gov service returns non-image file, \" + \"content-type='\" + conn.getContentType() + \"'\"); Thread.sleep(1000L * (long) Math.pow(2, 8 - i)); continue; } in = conn.getInputStream(); if (in != null) { out = new XFileOutputStream(outFile); IOUtils.copy(in, out); break; } else throw new IllegalStateException(\"opened stream is null\"); } } finally { if (out != null) { out.flush(); out.close(); } if (in != null) in.close(); } if (++numCachedTiles % 10 == 0) { logger.info(numCachedTiles + \" tiles cached\"); Thread.sleep(sleep); } } } catch (Throwable e) { logger.error(\"map tile caching has failed: \", e); throw e; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void loginBitShare() throws Exception { HttpParams params = new BasicHttpParams(); params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\"); DefaultHttpClient httpclient = new DefaultHttpClient(params); System.out.println(\"Trying to log in to bitshare.com\"); HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\"); List<NameValuePair> formparams = new ArrayList<NameValuePair>(); formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\")); formparams.add(new BasicNameValuePair(\"password\", \"\")); formparams.add(new BasicNameValuePair(\"submit\", \"Login\")); UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\"); httppost.setEntity(entity); HttpResponse httpresponse = httpclient.execute(httppost); Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator(); Cookie escookie = null; while (it.hasNext()) { escookie = it.next(); System.out.println(escookie.getName() + \" = \" + escookie.getValue()); } System.out.println(EntityUtils.toString(httpresponse.getEntity())); }. \n Code2: private static InputStream openNamedResource(String name) throws java.io.IOException { InputStream in = null; boolean result = false; boolean httpURL = true; URL propsURL = null; try { propsURL = new URL(name); } catch (MalformedURLException ex) { httpURL = false; propsURL = null; } if (propsURL == null) { propsURL = UserProperties.class.getResource(name); } if (propsURL != null) { URLConnection urlConn = propsURL.openConnection(); if (httpURL) { String hdrVal = urlConn.getHeaderField(0); if (hdrVal != null) { String code = HTTPUtilities.getResultCode(hdrVal); if (code != null) { if (!code.equals(\"200\")) { throw new java.io.IO",
        "ground_truth": "NO",
        "predict": "Exception(\"HTTP error code: \" + code); } } } } in = urlConn.getInputStream(); } else { in = new FileInputStream(propsURL.getFile()); } } return in; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void loginBitShare() throws Exception { HttpParams params = new BasicHttpParams(); params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\"); DefaultHttpClient httpclient = new DefaultHttpClient(params); System.out.println(\"Trying to log in to bitshare.com\"); HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\"); List<NameValuePair"
    },
    {
        "ID": 1235,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void find(String pckgname, Class tosubclass) { String name = new String(pckgname); if (!name.startsWith(\"/\")) { name = \"/\" + name; } name = name.replace('.', '/'); URL url = RTSI.class.getResource(name); System.out.println(name + \"->\" + url); if (url == null) return; File directory = new File(url.getFile()); if (directory.exists()) { String[] files = directory.list(); for (int i = 0; i < files.length; i++) { if (files[i].endsWith(\".class\")) { String classname = files[i].substring(0, files[i].length() - 6); try { Object o = Class.forName(pckgname + \".\" + classname).newInstance(); if (tosubclass.isInstance(o)) { System.out.println(classname); } } catch (ClassNotFoundException cnfex) { System.err.println(cnfex); } catch (InstantiationException iex) { } catch (IllegalAccessException iaex) { } } } } else { try { JarURLConnection conn = (JarURLConnection) url.openConnection(); String starts = conn.getEntryName(); JarFile jfile = conn.getJarFile(); Enumeration e = jfile.entries(); while (e.hasMoreElements()) { ZipEntry entry = (ZipEntry) e.nextElement(); String entryname = entry.getName(); if (entryname.startsWith(starts) && (entryname.lastIndexOf('/') <= starts.length()) && entryname.endsWith(\".class\")) { String classname = entryname.substring(0, entryname.length() - 6); if (classname.startsWith(\"/\")) classname = classname.substring(1); classname = classname.replace('/', '.'); try { Object o = Class.forName(classname).newInstance(); if (tosubclass.isInstance(o)) { System.out.println(classname.substring(classname.lastIndexOf('.') + 1)); } } catch (ClassNotFoundException cnfex) { System.err.println(cnfex); } catch (InstantiationException iex) { } catch (IllegalAccessException iaex) { } } } } catch (IOException ioex) { System.err.println(ioex); } } }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String transformByMD5(String password) throws XSServiceException { MessageDigest md5; byte[] output; StringBuffer bufferPass; try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e); throw new XSServiceException(\"Database error while saving user\"); } md5.reset(); md5.update(password.getBytes()); output = md5.digest(); bufferPass = new StringBuffer(); for (byte b : output) { bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b)); } return bufferPass.toString(); }.",
        "ground_truth": "YES",
        "predict": " \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void save(String password) throws XSServiceException { try { String md5 = transformByMD5(password); if (md5.equals(password)) { logger.info(\"Password is correct\"); } else { logger.warn(\"Password is incorrect\"); } } catch (XSServiceException e) { logger.warn(\"Database error while saving user:\" + e.getMessage(), e); throw new XSServiceException(\"Database error while saving user\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void save(String password) throws XSServiceException { try { String md5 = transformByMD5(password); if (md5.equals(password)) { logger.info(\"Password is"
    },
    {
        "ID": 1245,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public void delete(DeleteInterceptorChain chain, DistinguishedName dn, LDAPConstraints constraints) throws LDAPException { Connection con = (Connection) chain.getRequest().get(JdbcInsert.MYVD_DB_CON + \"LDAPBaseServer\"); if (con == null) { throw new LDAPException(\"Operations Error\", LDAPException.OPERATIONS_ERROR, \"No Database Connection\"); } try { con.setAutoCommit(false); int id = getId(dn, con); HashMap<String, String> db2ldap = (HashMap<String, String>) chain.getRequest().get(JdbcInsert.MYVD_DB_DB2LDAP + \"LDAPBaseServer\"); PreparedStatement ps = con.prepareStatement(\"DELETE FROM users WHERE id=?\"); ps.setInt(1, id); ps.executeUpdate(); ps = con.prepareStatement(\"DELETE FROM locationmap WHERE person=?\"); ps.setInt(1, id); ps.executeUpdate(); ps.close(); con.commit(); } catch (SQLException e) { try { con.rollback(); } catch (SQLException e1) { throw new LDAPException(\"Could not delete entry or rollback transaction\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } throw new LDAPException(\"Could not delete entry\", LDAPException.OPERATIONS_ERROR, e.toString(), e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected String getPasswordHash(String password) { MessageDigest md = null; try { md = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { log.error(\"MD5 algorithm not found\", e); throw new ServiceException(e); } md.update(password.getBytes()); byte[] hash = md.digest(); StringBuffer buf = new StringBuffer(); for (int i = 0; i < hash.length; i++) { buf.append(Integer.toHexString(hash[i] & 0xff)); } return buf.toString(); }. \n Code2: String fetch_pls(String pls) { InputStream pstream = null; if (pls.startsWith(\"http://\")) { try { URL url = null; if (running_as_applet) { url = new URL(getCodeBase(), pls); } else { url = new URL(pls); } URLConnection urlc = url.openConnection(); pstream = urlc.getInputStream(); } catch (Exception ee) { System.err.println(ee); return null; } } if (pstream == null && !running_as",
        "ground_truth": "NO",
        "predict": "_applet) { try { pstream = new FileInputStream(pls); } catch (Exception ee) { System.err.println(ee); return null; } } if (pstream == null) { return null; } try { byte[] buf = new byte[4096]; int len = 0; while ((len = pstream.read(buf)) > 0) { } pstream.close(); } catch (Exception ee) { System.err.println(ee); return null; } return new String(buf); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setPassword(String password) { String hash = getPasswordHash(password); if (hash == null) { return; } try { PreparedStatement ps = con.prepareStatement(\"UPDATE users SET password=? WHERE id=?\"); ps.setString(1, hash); ps.setInt"
    },
    {
        "ID": 1247,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static IProject CreateJavaProject(String name, IPath classpath) throws CoreException { // Create and Open New Project in Workspace IWorkspace workspace = ResourcesPlugin.getWorkspace(); IWorkspaceRoot root = workspace.getRoot(); IProject project = root.getProject(name); project.create(null); project.open(null); // Add Java Nature to new Project IProjectDescription desc = project.getDescription(); desc.setNatureIds(new String[] { JavaCore.NATURE_ID}); project.setDescription(desc, null); // Get Java Project Object IJavaProject javaProj = JavaCore.create(project); // Set Output Folder IFolder binDir = project.getFolder(\"bin\"); IPath binPath = binDir.getFullPath(); javaProj.setOutputLocation(binPath, null); // Set Project's Classpath IClasspathEntry cpe = JavaCore.newLibraryEntry(classpath, null, null); javaProj.setRawClasspath(new IClasspathEntry[] {cpe}, null); return project; }. \n Code2: public static void getResponseAsStream(String _url, Object _stringOrStream, OutputStream _stream, Map<String, String> _headers, Map<String, String> _params, String _contentType, int _timeout) throws IOException { if (_url == null || _url.length() <= 0) throw new IllegalArgumentException(\"Url can not be null.\"); String temp = _url.toLowerCase(); if (!temp.startsWith(\"http://\") && !temp.startsWith(\"https://\")) _url = \"http://\" + _url; _url = encodeURL(_url); HttpMethod method = null; if (_stringOrStream == null && (_params == null || _params.size() <= 0)) method = new GetMethod(_url); else method = new PostMethod(_url); HttpMethodParams methodParams = ((HttpMethodBase) method).getParams(); if (methodParams == null) { methodParams = new HttpMethodParams(); ((HttpMethodBase) method).setParams(methodParams); } if (_timeout < 0) methodParams.setSoTimeout(0); else methodParams.setSoTimeout(_timeout); if (_contentType != null && _contentType.length() > 0) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"Content-Type\", _contentType); } if (_headers == null || !_headers.containsKey(\"User-Agent\")) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"User-Agent\", DEFAULT_USERAGENT); } if (_headers != null) { Iterator<Map.Entry<String, String>> iter = _headers.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); method.setRequestHeader((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof PostMethod && (_params != null && _params.size() > 0)) { Iterator<Map.Entry<String, String>> iter = _params.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); ((PostMethod) method).addParameter((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof EntityEnclosingMethod && _stringOrStream != null) { if (_stringOrStream instanceof InputStream) { RequestEntity entity = new InputStreamRequestEntity((InputStream) _stringOrStream); ((EntityEnclosingMethod) method).setRequestEntity(entity); } else { RequestEntity entity = new StringRequestEntity(_stringOrStream.toString(), _contentType, null); ((EntityEnclosingMethod) method).setRequestEntity(entity); } } HttpClient httpClient = new HttpClient(new org.apache.commons.httpclient.SimpleHttpConnectionManager()); httpClient.getParams().setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true); InputStream instream = null; try { int status = httpClient.executeMethod(method); if (status != HttpStatus.SC_OK) { LOG.warn(\"Http Satus:\" + status + \",Url:\" + _url); if (status >= 500 && status < 600) throw new IOException(\"Remote service<\" + _url + \"> respose a error, status:\" + status); } instream = method.getResponseBodyAsStream(); IOUtils.copy(instream, _stream); } catch (IOException err) { LOG.error(\"Failed to access \" + _url, err); throw err; } finally { IOUtils.closeQuietly(instream); if (method != null) method.releaseConnection(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public String transformSingleFile(X3DEditorSupport.X3dEditor xed) { Node[] node = xed.getActivatedNodes(); X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject(); FileObject mySrc = dob.getPrimaryFile(); File mySrcF = FileUtil.toFile(mySrc); File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\"); TransformListener co = TransformListener.getInstance(); co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\")); co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath()); co.moveToFront(); co.setNode(node[0]); try { String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed); FileInputStream fis = new FileInputStream(new File(x3dvFile)); GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF)); byte[] buf = new byte[4096]; int ret; while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret); gzos.close(); } catch (Exception ex) { co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage()); return null; } co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\")); return myOutF.getAbsolutePath(); }. \n Code2: public void copy(File s, File t) throws IOException { FileChannel in = (new FileInputStream(s)).get",
        "ground_truth": "YES",
        "predict": "Channel(); FileChannel out = (new FileOutputStream(t)).getChannel(); in.transferTo(0, in.size(), out); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public String transformSingleFile(X3DEditorSupport.X3dEditor xed) { Node[] node = xed.getActivatedNodes(); X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject(); FileObject mySrc = dob.getPrimaryFile(); File mySrcF = FileUtil.toFile(mySrc); File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\"); TransformListener co = TransformListener.getInstance(); co.message(NbBundle.getMessage("
    },
    {
        "ID": 1251,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void initialize(Monitor monitor, final JETEmitter jetEmitter) throws JETException { IProgressMonitor progressMonitor = BasicMonitor.toIProgressMonitor(monitor); progressMonitor.beginTask(\"\", 10); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_GeneratingJETEmitterFor_message\", new Object[] { jetEmitter.templateURI })); final IWorkspace workspace = ResourcesPlugin.getWorkspace(); IJavaModel javaModel = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()); try { final JETCompiler jetCompiler = jetEmitter.templateURIPath == null ? new MyBaseJETCompiler(jetEmitter.templateURI, jetEmitter.encoding, jetEmitter.classLoader) : new MyBaseJETCompiler(jetEmitter.templateURIPath, jetEmitter.templateURI, jetEmitter.encoding, jetEmitter.classLoader); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETParsing_message\", new Object[] { jetCompiler.getResolvedTemplateURI() })); jetCompiler.parse(); progressMonitor.worked(1); String packageName = jetCompiler.getSkeleton().getPackageName(); if (jetEmitter.templateURIPath != null) { URI templateURI = URI.createURI(jetEmitter.templateURIPath[0]); URLClassLoader theClassLoader = null; if (templateURI.isPlatformResource()) { IProject project = workspace.getRoot().getProject(templateURI.segment(1)); if (JETNature.getRuntime(project) != null) { List<URL> urls = new ArrayList<URL>(); IJavaProject javaProject = JavaCore.create(project); urls.add(new File(project.getLocation() + \"/\" + javaProject.getOutputLocation().removeFirstSegments(1) + \"/\").toURL()); for (IClasspathEntry classpathEntry : javaProject.getResolvedClasspath(true)) { if (classpathEntry.getEntryKind() == IClasspathEntry.CPE_PROJECT) { IPath projectPath = classpathEntry.getPath(); IProject otherProject = workspace.getRoot().getProject(projectPath.segment(0)); IJavaProject otherJavaProject = JavaCore.create(otherProject); urls.add(new File(otherProject.getLocation() + \"/\" + otherJavaProject.getOutputLocation().removeFirstSegments(1) + \"/\").toURL()); } } theClassLoader = new URLClassLoader(urls.toArray(new URL[0])) { @Override public Class<?> loadClass(String className) throws ClassNotFoundException { try { return super.loadClass(className); } catch (ClassNotFoundException classNotFoundException) { return jetEmitter.classLoader.loadClass(className); } } }; } } else if (templateURI.isPlatformPlugin()) { final Bundle bundle = Platform.getBundle(templateURI.segment(1)); if (bundle != null) { theClassLoader = new URLClassLoader(new URL[0], jetEmitter.classLoader) { @Override public Class<?> loadClass(String className) throws ClassNotFoundException { try { return bundle.loadClass(className); } catch (ClassNotFoundException classNotFoundException) { return super.loadClass(className); } } }; } } if (theClassLoader != null) { String className = (packageName.length() == 0 ? \"\" : packageName + \".\") + jetCompiler.getSkeleton().getClassName(); if (className.endsWith(\"_\")) { className = className.substring(0, className.length() - 1); } try { Class<?> theClass = theClassLoader.loadClass(className); Class<?> theOtherClass = null; try { theOtherClass = jetEmitter.classLoader.loadClass(className); } catch (ClassNotFoundException exception) { } if (theClass != theOtherClass) { String methodName = jetCompiler.getSkeleton().getMethodName(); Method[] methods = theClass.getDeclaredMethods(); for (int i = 0; i < methods.length; ++i) { if (methods[i].getName().equals(methodName)) { jetEmitter.setMethod(methods[i]); break; } } return; } } catch (ClassNotFoundException exception) { } } } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); jetCompiler.generate(outputStream); final InputStream contents = new ByteArrayInputStream(outputStream.toByteArray()); if (!javaModel.isOpen()) { javaModel.open(new SubProgressMonitor(progressMonitor, 1)); } else { progressMonitor.worked(1); } final IProject project = workspace.getRoot().getProject(jetEmitter.getProjectName()); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETPreparingProject_message\", new Object[] { project.getName() })); IJavaProject javaProject; if (!project.exists()) { progressMonitor.subTask(\"JET creating project \" + project.getName()); project.create(new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETCreatingProject_message\", new Object[] { project.getName() })); IProjectDescription description = workspace.newProjectDescription(project.getName()); description.setNatureIds(new String[] { JavaCore.NATURE_ID }); description.setLocation(null); project.open(new SubProgressMonitor(progressMonitor, 1)); project.setDescription(description, new SubProgressMonitor(progressMonitor, 1)); javaProject = JavaCore.create(project); for (Map.Entry<String, String> option : jetEmitter.getJavaOptions().entrySet()) { javaProject.setOption(option.getKey(), option.getValue()); } } else { project.open(new SubProgressMonitor(progressMonitor, 5)); IProjectDescription description = project.getDescription(); description.setNatureIds(new String[] { JavaCore.NATURE_ID }); project.setDescription(description, new SubProgressMonitor(progressMonitor, 1)); javaProject = JavaCore.create(project); } List<IClasspathEntry> classpath = new UniqueEList<IClasspathEntry>(Arrays.asList(javaProject.getRawClasspath())); for (int i = 0, len = classpath.size(); i < len; i++) { IClasspathEntry entry = classpath.get(i); if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE && (\"/\" + project.getName()).equals(entry.getPath().toString())) { classpath.remove(i); } } progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JET",
        "ground_truth": "NO",
        "predict": "CreatingClasspath_message\", new Object[] { javaProject.getElementName() })); javaProject.setRawClasspath(classpath.toArray(new IClasspathEntry[0]), new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETCreatingClasspath_message\", new Object[] { javaProject.getElementName() })); javaProject.setOutputLocation(new Path(jetEmitter.getOutputLocation()), new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETCreatingClasspath_message\", new Object[] { javaProject.getElementName() })); javaProject.setRawClasspath(new IClasspathEntry[] { javaProject.getOutputLocation() }, new SubProgressMonitor(progressMonitor, 1)); progressMonitor.subTask(CodeGenPlugin.getPlugin().getString(\"_UI_JETCreatingClass"
    },
    {
        "ID": 1252,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String pathInfo = request.getPathInfo(); getLog().info(\"Process request \" + pathInfo); if (null != pathInfo) { String pathId = getPathId(pathInfo); JobResources res = ContextUtil.getJobResource(pathId); if (null != res) { RequestType requType = getRequestType(request); ResultAccess access = new ResultAccess(res); Collection<Long> uIdColl = res.getUniqIds(); boolean isFiltered = false; { List<String> postSeqIds = getSeqList(request); if (!postSeqIds.isEmpty()) { isFiltered = true; uIdColl = access.loadIds(postSeqIds); } } try { if ((requType.equals(RequestType.FASTA)) || (requType.equals(RequestType.SWISSPROT))) { OutputStreamWriter out = null; out = new OutputStreamWriter(response.getOutputStream()); for (Long uid : uIdColl) { if (requType.equals(RequestType.FASTA)) { SwissProt sw = access.getSwissprotEntry(uid); if (null != sw) { PrintFactory.instance().print(ConvertFactory.instance().SwissProt2fasta(sw), out); } else { System.err.println(\"Not able to read Swissprot entry \" + uid + \" in project \" + res.getBaseDir()); } } else if (requType.equals(RequestType.SWISSPROT)) { File swissFile = res.getSwissprotFile(uid); if (swissFile.exists()) { InputStream in = null; try { in = new FileInputStream(swissFile); IOUtils.copy(in, out); } catch (IOException e) { e.printStackTrace(); System.err.println(\"Problems with reading file to output stream \" + swissFile); } finally { IOUtils.closeQuietly(in); } } else { System.err.println(\"Swissprot file does not exist: \" + swissFile); } } } out.flush(); } else { if (uIdColl.size() <= 2) { isFiltered = false; uIdColl = res.getUniqIds(); } Tree tree = access.getTreeByUniquId(uIdColl); if (requType.equals(RequestType.TREE)) { response.getWriter().write(tree.toNewHampshireX()); } else if (requType.equals(RequestType.PNG)) { List<SwissProt> sp = access.getSwissprotEntriesByUniquId(uIdColl); ImageMap map = ImageFactory.instance().createProteinCard(sp, tree, true, res); response.setContentType(\"image/png\"); response.addHeader(\"Content-Disposition\", \"filename=ProteinCards.png\"); ImageFactory.instance().printPNG(map.getImage(), response.getOutputStream()); response.getOutputStream().flush(); } else if (requType.equals(RequestType.HTML)) { List<SwissProt> sp = access.getSwissprotEntriesByUniquId(uIdColl); createHtml(res, access, tree, request, response, sp, isFiltered); } } } catch (Exception e) { e.printStackTrace(); getLog().error(\"Problem with Request: \" + pathInfo + \"; type \" + requType, e); } } else { getLog().error(\"Resource is null: \" + pathId + \"; path \" + pathInfo); } } else { getLog().error(\"PathInfo is null!!!\"); } }. \n Code2: private void compress(File target, Set<File> files) throws CacheOperationException, ConfigurationException { ZipOutputStream zipOutput = null; try { zipOutput = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(target))); for (File file : files) { BufferedInputStream fileInput = null; File cachePathName = new File(cacheFolder, file.getPath()); try { if (!cachePathName.exists()) { throw new CacheOperationException(\"Expected to add file ''{0}'' to export archive ''{1}'' (Account : {2}) but it \" + \"has gone missing (cause unknown). This can indicate implementation or deployment \" + \"error. Aborting export operation as a safety precaution.\", cachePathName.getPath(), target.getAbsolutePath(), account.getOid()); } fileInput = new BufferedInputStream(new FileInputStream(cachePathName)); ZipEntry entry = new ZipEntry(file.getPath()); entry.setSize(cachePathName.length()); entry.setTime(cachePathName.lastModified()); zipOutput.putNextEntry(entry); cacheLog.debug(\"Added new export zip entry ''{0}''.\", file.getPath()); int count, total = 0; int buffer = 2048; byte[] data = new byte[buffer]; while ((count = fileInput.read(data, 0, buffer)) != -1) { zipOutput.write(data, 0, count); total += count; } zipOutput.flush(); if (total != cachePathName.length()) { throw new CacheOperationException(\"Only wrote {0} out of {1} bytes when archiving file ''{2}'' (Account : {3}). \" + \"This could have occured either due implementation error or file I/O error. \" + \"Aborting archive operation to prevent a potentially corrupt export archive to \" + \"be created.\", total, cachePathName.length(), cachePathName.getPath(), account.getOid()); } else { cacheLog.debug(\"Wrote {0} out of {1} bytes to zip entry ''{2}''\", total, cachePathName.length(), file.getPath()); } } catch (SecurityException e) { throw new ConfigurationException(\"Security manager has denied r/w access when attempting to read file ''{0}'' and \" + \"write it to archive ''{1}'' (Account : {2}) : {3}\", e, cachePathName.getPath(), target, account.getOid(), e.getMessage()); } catch (IllegalArgumentException e) { throw new CacheOperationException(\"Error creating ZIP archive for account ID = {0} : {1}\", e, account.getOid(), e.getMessage()); } catch (FileNotFoundException e) { throw new CacheOperationException(\"Attempted to include file ''{0}'' in export archive but it has gone missing \" + \"(Account : {1}). Possible implementation error in local file cache. Aborting \" + \"export operation as a precaution ({2})\", e, cachePathName.getPath(), account.getOid(), e.getMessage()); } catch (ZipException e) { throw new CacheOperationException(\"Error writing export archive for",
        "ground_truth": "NO",
        "predict": " account ID = {0} : {1}\", e, account.getOid(), e.getMessage()); } finally { if (null != fileInput) { fileInput.close(); } } } catch (IOException e) { throw new CacheOperationException(\"Error creating ZIP archive for account ID = {0} : {1}\", e, account.getOid(), e.getMessage()); } finally { if (null != zipOutput) { try { zipOutput.close(); } catch (IOException e) { } } } } }\n\n}\n"
    },
    {
        "ID": 1261,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testSystemPropertyConnector() throws Exception { final String rootFolderPath = \"test/ConnectorTest/fs/\".toLowerCase(); final Connector connector = new SystemPropertyConnector(); final ContentResolver contentResolver = new UnionContentResolver(); final FSContentResolver fsContentResolver = new FSContentResolver(); fsContentResolver.setRootFolderPath(rootFolderPath); contentResolver.addContentResolver(fsContentResolver); contentResolver.addContentResolver(new ClasspathContentResolver()); connector.setContentResolver(contentResolver); String resultString; byte[] resultContent; Object resultObject; resultString = connector.getString(\"helloWorldPath\"); assertNull(resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNull(resultContent); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"file:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"file:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNull(resultObject); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"classpath:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"classpath:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); final InputStream helloWorldIS = new ByteArrayInputStream(\"Hello World 2 - Test\".getBytes(\"UTF-8\")); FileUtils.forceMkdir(new File(rootFolderPath + \"/org/settings4j/connector\")); final String helloWorldPath = rootFolderPath + \"/org/settings4j/connector/HelloWorld2.txt\"; final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath)); IOUtils.copy(helloWorldIS, fileOutputStream); IOUtils.closeQuietly(helloWorldIS); IOUtils.closeQuietly(fileOutputStream); LOG.info(\"helloWorld2Path: \" + helloWorldPath); System.setProperty(\"helloWorldPath\", \"file:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"file:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2 - Test\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2 - Test\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"classpath:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"classpath:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); }. \n Code2: public static void copyFile(File in, File out) throws IOException { FileChannel inChannel = new FileInputStream(in).getChannel(); FileChannel outChannel = new FileOutputStream(out).getChannel(); try { if (System.getProperty(\"os.name\").toUpperCase().indexOf(\"WIN\") != -1) { int maxCount = (64 * 1024 * 1024) - (32 * 1024); long size = inChannel.size(); long position = 0; while (position < size) { position += inChannel.transferTo(position, maxCount, outChannel); } } else { inChannel.transferTo(0, inChannel.size(), outChannel); } } finally { if (inChannel != null) inChannel.close(); if (outChannel != null) outChannel.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request); if (delegate == null) { ActionErrors errors = new ActionErrors(); errors.add(null, new ActionError(\"errors.session\")); saveErrors(request, errors); return mapping.findForward(\"fail\"); } AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla(); TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion(); String urlSonido = traAyudaPantalla.getUrlSonido(); if (urlSonido == null) { return null; } URL url = new URL(urlSonido); URLConnection urlConnection = url.openConnection(); urlConnection.connect(); String tipoMime = urlConnection.getContentType(); log.debug(\"Tipo Mime: \" + tipoM",
        "ground_truth": "NO",
        "predict": "ime); if (tipoMime.startsWith(\"audio/\")) { return null; } else { return mapping.findForward(\"fail\"); } }. \n Code2: public void setServletContext(ServletContext servletContext) { this.servletContext = servletContext; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setServletContext(ServletContext servletContext) { this.servletContext = servletContext; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void setServletContext(ServletContext servletContext) { this.servletContext = servletContext; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES"
    },
    {
        "ID": 1265,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void executa(String arquivo, String filial, String ip) { String drive = arquivo.substring(0, 2); if (drive.indexOf(\":\") == -1) drive = \"\"; Properties p = Util.lerPropriedades(arquivo); String servidor = p.getProperty(\"servidor\"); String impressora = p.getProperty(\"fila\"); String arqRel = new String(drive + p.getProperty(\"arquivo\")); String copias = p.getProperty(\"copias\"); if (filial.equalsIgnoreCase(servidor)) { Socket s = null; int tentativas = 0; boolean conectado = false; while (!conectado) { try { tentativas++; System.out.println(\"Tentando conectar \" + ip + \" (\" + tentativas + \")\"); s = new Socket(ip, 7000); conectado = s.isConnected(); } catch (ConnectException ce) { System.err.println(ce.getMessage()); System.err.println(ce.getCause()); } catch (UnknownHostException uhe) { System.err.println(uhe.getMessage()); } catch (IOException ioe) { System.err.println(ioe.getMessage()); } } FileInputStream in = null; BufferedOutputStream out = null; try { in = new FileInputStream(new File(arqRel)); out = new BufferedOutputStream(new GZIPOutputStream(s.getOutputStream())); } catch (FileNotFoundException e3) { e3.printStackTrace(); } catch (IOException e3) { e3.printStackTrace(); } String arqtr = arqRel.substring(2); System.out.println(\"Proximo arquivo: \" + arqRel + \" ->\" + arqtr); while (arqtr.length() < 30) arqtr += \" \"; while (impressora.length() < 30) impressora += \" \"; byte aux[] = new byte[30]; byte cop[] = new byte[2]; try { aux = arqtr.getBytes(\"UTF8\"); out.write(aux); aux = impressora.getBytes(\"UTF8\"); out.write(aux); cop = copias.getBytes(\"UTF8\"); out.write(cop); out.flush(); } catch (UnsupportedEncodingException e2) { e2.printStackTrace(); } catch (IOException e2) { e2.printStackTrace(); } byte b[] = new byte[1024]; int nBytes; try { while ((nBytes = in.read(b)) != -1) out.write(b, 0, nBytes); out.flush(); out.close(); in.close(); s.close(); } catch (IOException e1) { e1.printStackTrace(); } System.out.println(\"Arquivo \" + arqRel + \" foi transmitido. \\n\\n\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } SimpleDateFormat dfArq = new SimpleDateFormat(\"yyyy-MM-dd\"); SimpleDateFormat dfLog = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String arqLog = \"log\" + filial + dfArq.format(new Date()) + \".txt\"; PrintWriter pw = null; try { pw = new PrintWriter(new FileWriter(arqLog, true)); } catch (IOException e) { e.printStackTrace(); } pw.println(\"Arquivo: \" + arquivo + \" \" + dfLog.format(new Date())); pw.flush(); pw.close(); File f = new File(arquivo); while (!f.delete()) { System.out.println(\"Erro apagando \" + arquivo); } } }. \n Code2: protected InputStream acquireInputStream(String filename) throws IOException { Validate.notEmpty(filename); File f = new File(filename); if (f.exists()) { this.originalFilename = f.getName(); return new FileInputStream(f); } URL url = getClass().getClassLoader().getResource(filename); if (url == null) { if (!filename.startsWith(\"/\")) { url = getClass().getClassLoader().getResource(\"/\" + filename); if (url == null) { throw new IllegalArgumentException(\"File [\" + filename + \"] not found in classpath via \" + getClass().getClassLoader().getClass()); } } } this.originalFilename = filename; return url.openStream(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String CheckUrl(String urlvalue) { String inputLine = \"\"; try { URL url = new URL(urlvalue); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); inputLine = in.readLine().toString(); } catch (Exception e) { e.printStackTrace(); } return inputLine; }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=MET",
        "ground_truth": "NO",
        "predict": "RICS border><tr><th>Metrics</th><th>Difference</th></tr>\"); out.write(metricsTable.toString()); out.write(\"</table>\\n\"); out.write(\"</div>\\n\"); out.write(\"</body></html>\"); out.close(); }. \n Code3: public static void main(String[] args) { new LocDiff().execute(args); }. \n Code4: public static void main(String[] args) { new LocDiff().execute(args); }. \n Code5: public static void main(String[] args) { new LocDiff().execute(args); }. \n Code6: public static void main(String[] args) { new LocDiff().execute(args); }. \n Code7: public static void main(String[] args) { new LocDiff().execute(args); }. \n Code8: public static void main(String[] args) { new LocDiff().execute("
    },
    {
        "ID": 1280,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer(); for (int j = 0; j < array.length; ++j) { int b = array[j] & 0xFF; if (b < 0x10) sb.append('0'); sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { System.out.println(\"Error:\" + e); } }. \n Code2: public boolean verifySignature() { try { byte[] data = readFile(name + \".tmp1.bin\"); if (data == null) return false; if (data[data.length - 0x104] != 'N' || data[data.length - 0x103] != 'G' || data[data.length - 0x102] != 'I' || data[data.length - 0x101] != 'S') return false; byte[] signature = new byte[0x100]; byte[] module = new byte[data.length - 0x104]; System.arraycopy(data, data.length - 0x100, signature, 0, 0x100); System.arraycopy(data, 0, module, 0, data.length - 0x104); BigIntegerEx power = new BigIntegerEx(BigIntegerEx.LITTLE_ENDIAN, new byte[] { 0x01, 0x00, 0x01, 0x00 }); BigIntegerEx mod = new BigIntegerEx(BigIntegerEx.LITTLE_ENDIAN, new byte[] { (byte) 0x6B, (byte) 0xCE, (byte) 0xF5, (byte) 0x2D, (byte) 0x2A, (byte) 0x7D, (byte) 0x7A, (byte) 0x67, (byte) 0x21, (byte) 0x21, (byte) 0x84, (byte) 0xC9, (byte) 0xBC, (byte) 0x25, (byte) 0xC7, (byte) 0xBC, (byte) 0xDF, (byte) 0x3D, (byte) 0x8F, (byte) 0xD9, (byte) 0x47, (byte) 0xBC, (byte) 0x45, (byte) 0x48, (byte) 0x8B, (byte) 0x22, (byte) 0x85, (byte) 0x3B, (byte) 0xC5, (byte) 0xC1, (byte) 0xF4, (byte) 0xF5, (byte) 0x3C, (byte) 0x0C, (byte) 0x49, (byte) 0xBB, (byte) 0x56, (byte) 0xE0, (byte) 0x3D, (byte) 0xBC, (byte) 0xA2, (byte) 0xD2, (byte) 0x35, (byte) 0xC1, (byte) 0xF0, (byte) 0x74, (byte) 0x2E, (byte) 0x15, (byte) 0x5A, (byte) 0x06, (byte) 0x8A, (byte) 0x68, (byte) 0x01, (byte) 0x9E, (byte) 0x60, (byte) 0x17, (byte) 0x70, (byte) 0x8B, (byte) 0xBD, (byte) 0xF8, (byte) 0xD5, (byte) 0xF9, (byte) 0x3A, (byte) 0xD3, (byte) 0x25, (byte) 0xB2, (byte) 0x66, (byte) 0x92, (byte) 0xBA, (byte) 0x43, (byte) 0x8A, (byte) 0x81, (byte) 0x52, (byte) 0x0F, (byte) 0x64, (byte) 0x98, (byte) 0xFF, (byte) 0x60, (byte) 0x37, (byte) 0xAF, (byte) 0xB4, (byte) 0x11, (byte) 0x8C, (byte) 0xF9, (byte) 0x2E, (byte) 0xC5, (byte) 0xEE, (byte) 0xCA, (byte) 0xB4, (byte) 0x41, (byte) 0x60, (byte) 0x3C, (byte) 0x7D, (byte) 0x02, (byte) 0xAF, (byte) 0xA1, (byte) 0x2B, (byte) 0x9B, (byte) 0x22, (byte) 0x4B, (byte) 0x3B, (byte) 0xFC, (byte) 0xD2, (byte) 0x5D, (byte) 0x73, (byte) 0xE9, (byte) 0x29, (byte) 0x34, (byte) 0x91, (byte) 0x85, (byte) 0x93, (byte) 0x4C, (byte) 0xBE, (byte) 0xBE, (byte) 0x73, (byte) 0xA9, (byte) 0xD2, (byte) 0x3B, (byte) 0x27, (byte) 0x7A, (byte) 0x47, (byte) 0x76, (byte) 0xEC, (byte) 0xB0, (byte) 0x28, (byte) 0xC9, (byte) 0xC1, (byte) 0xDA, (byte) 0xEE, (byte) 0xAA, (byte) 0xB3, (byte) 0x96, (byte) 0x9C, (byte) 0x1",
        "ground_truth": "YES",
        "predict": "E, (byte) 0xA9, (byte) 0xE9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA9, (byte) 0xA"
    },
    {
        "ID": 1289,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Image storeImage(String title, String pathToImage, Map<String, Object> additionalProperties) { File collectionFolder = ProjectManager.getInstance().getFolder(PropertyHandler.getInstance().getProperty(\"_default_collection_name\")); File imageFile = new File(pathToImage); String filename = \"\"; String format = \"\"; File copiedImageFile; while (true) { filename = \"image\" + UUID.randomUUID().hashCode(); if (!DbEntryProvider.INSTANCE.idExists(filename)) { Path path = new Path(pathToImage); format = path.getFileExtension(); copiedImageFile = new File(collectionFolder.getAbsolutePath() + File.separator + filename + \".\" + format); if (!copiedImageFile.exists()) break; } } try { copiedImageFile.createNewFile(); } catch (IOException e1) { ExceptionHandlingService.INSTANCE.handleException(e1); return null; } BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(imageFile), 4096); out = new BufferedOutputStream(new FileOutputStream(copiedImageFile), 4096); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } catch (FileNotFoundException e) { ExceptionHandlingService.INSTANCE.handleException(e); return null; } catch (IOException e) { ExceptionHandlingService.INSTANCE.handleException(e); return null; } Image image = new ImageImpl(); image.setId(filename); image.setFormat(format); image.setEntryDate(new Date()); image.setTitle(title); image.setAdditionalProperties(additionalProperties); boolean success = DbEntryProvider.INSTANCE.storeNewImage(image); if (success) return image; return null; }. \n Code2: public void writeValue(Value v) throws IOException, SQLException { int type = v.getType(); writeInt(type); switch(type) { case Value.NULL: break; case Value.BYTES: case Value.JAVA_OBJECT: writeBytes(v.getBytesNoCopy()); break; case Value.UUID: { ValueUuid uuid = (ValueUuid) v; writeLong(uuid.getHigh()); writeLong(uuid.getLow()); break; } case Value.BOOLEAN: writeBoolean(v.getBoolean().booleanValue()); break; case Value.BYTE: writeByte(v.getByte()); break; case Value.TIME: writeLong(v.getTimeNoCopy().getTime()); break; case Value.DATE: writeLong(v.getDateNoCopy().getTime()); break; case Value.TIMESTAMP: { Timestamp ts = v.getTimestampNoCopy(); writeLong(ts.getTime()); writeInt(ts.getNanos()); break; } case Value.DECIMAL: writeString(v.getString()); break; case Value.DOUBLE: writeDouble(v.getDouble()); break; case Value.FLOAT: writeFloat(v.getFloat()); break; case Value.INT: writeInt(v.getInt()); break; case Value.LONG: writeLong(v.getLong()); break; case Value.SHORT: writeInt(v.getShort()); break; case Value.STRING: case Value.STRING_IGNORECASE: case Value.STRING_FIXED: writeString(v.getString()); break; case Value.BLOB: { long length = v.getPrecision(); if (SysProperties.CHECK && length < 0) { Message.throwInternalError(\"length: \" + length); } writeLong(length); InputStream in = v.getInputStream(); long written = IOUtils.copyAndCloseInput(in, out); if (SysProperties.CHECK && written != length) { Message.throwInternalError(\"length:\" + length + \" written:\" + written); } writeInt(LOB_MAGIC); break; } case Value.CLOB: { long length = v.getPrecision(); if (SysProperties.CHECK && length < 0) { Message.throwInternalError(\"length: \" + length); } writeLong(length); Reader reader = v.getReader(); java.io.OutputStream out2 = new java.io.FilterOutputStream(out) { public void flush() { } }; Writer writer = new BufferedWriter(new OutputStreamWriter(out2, Constants.UTF8)); long written = IOUtils.copyAndCloseInput(reader, writer); if (SysProperties.CHECK && written != length) { Message.throwInternalError(\"length:\" + length + \" written:\" + written); } writer.flush(); writeInt(LOB_MAGIC); break; } case Value.ARRAY: { Value[] list = ((ValueArray) v).getList(); writeInt(list.length); for (Value value : list) { writeValue(value); } break; } case Value.RESULT_SET: { ResultSet rs = ((ValueResultSet) v).getResultSet(); rs.beforeFirst(); ResultSetMetaData meta = rs.getMetaData(); int columnCount = meta.getColumnCount(); writeInt(columnCount); for (int i = 0; i < columnCount; i++) { writeString(meta.getColumnName(i + 1)); writeInt(meta.getColumnType(i + 1)); writeInt(meta.getPrecision(i + 1)); writeInt(meta.getScale(i + 1)); } while (rs.next()) { writeBoolean(true); for (int i = 0; i < columnCount; i++) { int t = DataType.convertSQLTypeToValueType(meta.getColumnType(i + 1)); Value val = DataType.readValue(session, rs, i + 1, t); writeValue(val); } } writeBoolean(false); rs.beforeFirst(); break; } default: Message.throwInternalError(\"type=\" + type); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File in, File out) throws IOException { FileChannel sourceChannel = new FileInputStream(in).getChannel(); FileChannel destinationChannel = new FileOutputStream(out).getChannel(); sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel); sourceChannel.close(); destinationChannel.close(); }. \n Code2: private InputStream openRemoteStream(String remoteURL, String pathSuffix) { URL url; InputStream in = null; try { url = new URL(remoteURL + pathSuffix); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); in = connection.getInputStream(); } catch (Exception e) { } return in; }. \n Response",
        "ground_truth": "NO",
        "predict": ": YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(File in, File out) throws IOException { FileChannel sourceChannel = new FileInputStream(in).getChannel(); FileChannel destinationChannel = new FileOutputStream(out).getChannel(); sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel); sourceChannel.close(); destinationChannel.close(); }. \n Code2: private OutputStream openRemoteStream(String remoteURL, String pathSuffix) { URL url; OutputStream out = null; try { url = new URL(remoteURL + pathSuffix); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); out = connection.getOutputStream(); } catch (Exception e) { } return out; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to"
    },
    {
        "ID": 1311,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String arg[]) { try { String readFile = arg[0]; String writeFile = arg[1]; java.io.FileInputStream ss = new java.io.FileInputStream(readFile); ManagedMemoryDataSource ms = new ManagedMemoryDataSource(ss, 1024 * 1024, \"foo/data\", true); javax.activation.DataHandler dh = new javax.activation.DataHandler(ms); java.io.InputStream is = dh.getInputStream(); java.io.FileOutputStream fo = new java.io.FileOutputStream(writeFile); byte[] buf = new byte[512]; int read = 0; do { read = is.read(buf); if (read > 0) { fo.write(buf, 0, read); } } while (read > -1); fo.close(); is.close(); } catch (java.lang.Exception e) { log.error(Messages.getMessage(\"exception00\"), e); } }. \n Code2: public static void getResponseAsStream(String _url, Object _stringOrStream, OutputStream _stream, Map<String, String> _headers, Map<String, String> _params, String _contentType, int _timeout) throws IOException { if (_url == null || _url.length() <= 0) throw new IllegalArgumentException(\"Url can not be null.\"); String temp = _url.toLowerCase(); if (!temp.startsWith(\"http://\") && !temp.startsWith(\"https://\")) _url = \"http://\" + _url; _url = encodeURL(_url); HttpMethod method = null; if (_stringOrStream == null && (_params == null || _params.size() <= 0)) method = new GetMethod(_url); else method = new PostMethod(_url); HttpMethodParams methodParams = ((HttpMethodBase) method).getParams(); if (methodParams == null) { methodParams = new HttpMethodParams(); ((HttpMethodBase) method).setParams(methodParams); } if (_timeout < 0) methodParams.setSoTimeout(0); else methodParams.setSoTimeout(_timeout); if (_contentType != null && _contentType.length() > 0) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"Content-Type\", _contentType); } if (_headers == null || !_headers.containsKey(\"User-Agent\")) { if (_headers == null) _headers = new HashMap<String, String>(); _headers.put(\"User-Agent\", DEFAULT_USERAGENT); } if (_headers != null) { Iterator<Map.Entry<String, String>> iter = _headers.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); method.setRequestHeader((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof PostMethod && (_params != null && _params.size() > 0)) { Iterator<Map.Entry<String, String>> iter = _params.entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, String> entry = iter.next(); ((PostMethod) method).addParameter((String) entry.getKey(), (String) entry.getValue()); } } if (method instanceof EntityEnclosingMethod && _stringOrStream != null) { if (_stringOrStream instanceof InputStream) { RequestEntity entity = new InputStreamRequestEntity((InputStream) _stringOrStream); ((EntityEnclosingMethod) method).setRequestEntity(entity); } else { RequestEntity entity = new StringRequestEntity(_stringOrStream.toString(), _contentType, null); ((EntityEnclosingMethod) method).setRequestEntity(entity); } } HttpClient httpClient = new HttpClient(new org.apache.commons.httpclient.SimpleHttpConnectionManager()); httpClient.getParams().setBooleanParameter(HttpClientParams.ALLOW_CIRCULAR_REDIRECTS, true); InputStream instream = null; try { int status = httpClient.executeMethod(method); if (status != HttpStatus.SC_OK) { LOG.warn(\"Http Satus:\" + status + \",Url:\" + _url); if (status >= 500 && status < 600) throw new IOException(\"Remote service<\" + _url + \"> respose a error, status:\" + status); } instream = method.getResponseBodyAsStream(); IOUtils.copy(instream, _stream); } catch (IOException err) { LOG.error(\"Failed to access \" + _url, err); throw err; } finally { IOUtils.closeQuietly(instream); if (method != null) method.releaseConnection(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void update(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try { dbo = (ERDBOperation) createDBOperation(); String url = \"\"; boolean flag = true; StringTokenizer st = null; conn = dbo.getConnection(); conn.setAutoCommit(false); ps = conn.prepareStatement(sqlInitial); rs = ps.executeQuery(); if (rs.next()) url = rs.getString(1); if (!url.equals(\"\")) { st = new StringTokenizer(url, \",\"); String sortDocId = \"\"; while (st.hasMoreTokens()) { if (flag) { sortDocId = \"'\" + st.nextToken() + \"'\"; flag = false; } else { sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\"; } } String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField; ps = conn.prepareStatement(sqlsort); rs = ps.executeQuery(); String sortURL = \"\"; boolean sortflag = true; while (rs.next()) { if (sortflag) { sortURL = rs.getString(1); sortflag = false; } else { sortURL = sortURL + \",\" +",
        "ground_truth": "NO",
        "predict": " rs.getString(1); } } if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL = \"'\" + sortURL + \"'\"; if (sortURL.equals(\"\")) sortURL = \"''\"; else sortURL"
    },
    {
        "ID": 1313,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { Application.getController().notifyProgressStarted(); Application.getController().notifyProgressUpdated(-1); for (int f = 0; f < fileList.size(); f++) { File archive = fileList.get(f); String arname = archive.getName(); String arsuf = arname.substring(arname.lastIndexOf('.'), arname.length()); Algorithm alg = null; Algorithm algs[] = algFactory.getAlgorithms(); for (int i = 0; i < algs.length; i++) { if (algs[i].getSuffix().equalsIgnoreCase(arsuf)) { alg = algs[i]; break; } } if (alg == null) { Application.getController().displayError(bundle.getString(\"unknown_alg_title\"), bundle.getString(\"unknown_alg_text\")); return; } currentAlgorithm = alg; if (!alg.initDecrypt(password)) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } try { ZipArchiveInputStream zis = null; InputStream is = null; if (EncryptionMode.getBestEncryptionMode(alg.getEncryptionMode()) == EncryptionMode.MODE_STREAM) { is = alg.getDecryptionStream(new FileInputStream(archive)); if (is == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } } else if (EncryptionMode.getBestEncryptionMode(alg.getEncryptionMode()) == EncryptionMode.MODE_BLOCK) { is = new BlockCipherInputStream(new FileInputStream(archive), alg); if (is == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } } zis = new ZipArchiveInputStream(is); if (zis == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } File outputDir = getTargetDirectory(); if (outputDir == null) { return; } if (!outputDir.exists()) { if (!outputDir.mkdir()) { Application.getController().displayError(bundle.getString(\"output_dir_fail_title\"), outputDir.getAbsolutePath() + \" \" + bundle.getString(\"output_dir_fail_text\")); return; } } ZipArchiveEntry zae = null; boolean gotEntries = false; while ((zae = zis.getNextZipEntry()) != null) { gotEntries = true; File out = new File(outputDir, zae.getName()); if (out.exists()) { if (!mayOverwrite(out)) { continue; } } Application.getController().displayVerbose(\"writing to file: \" + out.getAbsolutePath()); if (!out.getParentFile().exists()) { out.getParentFile().mkdirs(); } if (zae.isDirectory()) { out.mkdir(); continue; } FileOutputStream os = new FileOutputStream(out); long length = zae.getCompressedSize(), counter = 0; Application.getController().displayVerbose(\"Length of zip entry \" + zae.getName() + \" is \" + length + \"b\"); byte[] buffer = new byte[16384]; MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); DigestInputStream in = new DigestInputStream(zis, md); while ((counter = in.read(buffer)) > 0) { if (Thread.currentThread().isInterrupted()) { os.close(); zis.close(); Application.getController().notifyProgressFinished(); resetModel(true); return; } os.write(buffer, 0, (int) counter); } os.close(); if (zae.getComment() != null && zae.getComment().length() > 0) { if (Arrays.equals(md.digest(), new Base64().decode(zae.getComment()))) { Application.getController().displayVerbose(\"Hash of \" + zae.getName() + \": \" + new Base64().encodeToString(md.digest())); Application.getController().displayError(\"Hash Error\", \"The stored hash of the original file and the hash of the decrypted data do not match. Normally, this means that your data has been manipulated/damaged, but it can also happen if your Java Runtime has a bug in his hash functions.\\nIT IS VERY IMPORTANT TO CHECK THE INTEGRITY OF YOUR DECRYPTED DATA!\"); } else { Application.getController().displayVerbose(\"the hash of \" + zae.getName() + \" was verified succesfully\"); } } } if (!gotEntries) { Application.getController().displayError(bundle.getString(\"error_no_entries_title\"), bundle.getString(\"error_no_entries_text\")); outputDir.delete(); } zis.close(); resetModel(false); } catch (FileNotFoundException ex) { Application.getController().displayError(bundle.getString(\"error_file_not_exist\"), ex.getLocalizedMessage()); } catch (IOException ex) { Application.getController().displayError(bundle.getString(\"error_generic_io\"), ex.getLocalizedMessage()); } catch (NoSuchAlgorithmException ex) { Application.getController().displayError(bundle.getString(\"unknown_alg_text\"), ex.getLocalizedMessage()); } } Application.getController().notifyProgressFinished(); resetModel(true); }. \n Code2: private MimeTypes() { try { final URL url = RES.getURL(\"types\"); final InputStream is = url.openStream(); final BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line = br.readLine(); while (line != null) { line = line.trim(); final int p = line.indexOf('#'); if (p >= 0) { line = line.substring(0, p).trim(); } if (line.length() > 0) { final StringTokenizer st = new StringTokenizer(line, \" \\t\"); if (st.countTokens() > 1) { final String mime = st.nextToken(); while (st.hasMoreTokens()) { extnMap.put(st.nextToken(), mime); } } } line = br.readLine(); } br.close(); } catch (IOException e) { e.printStackTrace(); } canParse.add(TEXT_HTML); canParse.",
        "ground_truth": "NO",
        "predict": "add(TEXT_PLAIN); canParse.add(TEXT_XML); canParse.add(TEXT_X_C); canParse.add(TEXT_X_CHTML); canParse.add(TEXT_X_CSHARP); canParse.add(TEXT_X_CPP); canParse.add(TEXT_X_CSS); canParse.add(TEXT_X_DIFF); canParse.add(TEXT_X_FORTRAN); canParse.add(TEXT_X_JAVA); canParse.add(TEXT_X_LATEX); canParse.add(TEXT_X_LISP); canParse.add(TEXT_X_PERL); canParse.add(TEXT_X_PYTHON); canParse.add(TEXT_X_RUBY); canParse.add(TEXT_X_SH); canParse.add(TEXT_X_"
    },
    {
        "ID": 1318,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean delete(String url, int ip, int port) { try { HttpURLConnection request = (HttpURLConnection) new URL(url).openConnection(); request.setRequestMethod(\"DELETE\"); request.setRequestProperty(GameRecord.GAME_IP_HEADER, String.valueOf(ip)); request.setRequestProperty(GameRecord.GAME_PORT_HEADER, String.valueOf(port)); request.connect(); return request.getResponseCode() == HttpURLConnection.HTTP_OK; } catch (IOException e) { e.printStackTrace(); } return false; }. \n Code2: private void run(String[] args) throws Throwable { ArgParser parser = new ArgParser(\"Run an experiment\"); parser.addOptions(this, true); args = parser.matchAllArgs(args, 0, ArgParserOption.EXIT_ON_ERROR, ArgParserOption.STOP_FIRST_UNMATCHED); if (log4jFile != null) { logger.info(\"Using another log4j configuration: %s\", log4jFile); PropertyConfigurator.configure(log4jFile.getAbsolutePath()); } final TreeMap<TaskName, Class<Task>> tasks = GenericHelper.newTreeMap(); final Enumeration<URL> e = About.class.getClassLoader().getResources(EXPERIMENT_PACKAGES); while (e.hasMoreElements()) { final URL url = e.nextElement(); logger.debug(\"Got URL %s\", url); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); String line; while ((line = in.readLine()) != null) { String packageName = line; getTasks(url, tasks, packageName); } } getTasks(null, tasks, getClass().getPackage().getName()); if (tasks.isEmpty()) { logger.fatal(\"I did not find any valid experiment (service bpiwowar.experiments.ExperimentListProvider)\"); System.exit(1); } if (args.length == 0 || args[0].equals(\"list\")) { System.out.format(\"Available experiments:%n\"); TreeMapArray<PackageName, String> map = TreeMapArray.newInstance(); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { TaskName task = entry.getKey(); if (showClassNames) map.add(task.packageName, String.format(\"%s (%s)\", task.name, entry.getValue().toString())); else map.add(task.packageName, task.name); } Stack<PackageName> ancestors = new Stack<PackageName>(); for (Entry<PackageName, ArrayList<String>> entry : map.entrySet()) { final PackageName key = entry.getKey(); while (!ancestors.isEmpty() && key.commonPrefixLength(ancestors.peek()) != ancestors.peek().getLength()) ancestors.pop(); int nbAncestors = ancestors.size(); int c = nbAncestors > 0 ? ancestors.peek().getLength() : 0; StringBuilder s = new StringBuilder(); for (int i = 0; i < c; i++) s.append(\"|\"); for (int i = c; i < key.getLength(); i++) { s.append(\"|\"); ancestors.add(new PackageName(key, i + 1)); System.out.format(\"%s%n\", s); System.out.format(\"%s+ [%s]%n\", s, ancestors.peek()); nbAncestors++; } String prefix = s.toString(); for (String task : entry.getValue()) System.out.format(\"%s|- %s%n\", prefix, task); ancestors.add(key); } return; } else if (args[0].equals(SEARCH_COMMAND)) { final class Options { @OrderedArgument(required = true) String search; } Options options = new Options(); ArgParser ap = new ArgParser(SEARCH_COMMAND); ap.addOptions(options); ap.matchAllArgs(args, 1); logger.info(\"Searching for %s\", options.search); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { TaskName taskname = entry.getKey(); if (taskname.name.contains(options.search)) { System.err.format(\"[*] %s - %s%n %s%n\", taskname, entry.getValue(), entry.getValue().getAnnotation(TaskDescription.class).description()); } } return; } String taskName = args[0]; args = Arrays.copyOfRange(args, 1, args.length); ArrayList<Class<Task>> matching = GenericHelper.newArrayList(); for (Entry<TaskName, Class<Task>> entry : tasks.entrySet()) { if (entry.getKey().name.equals(taskName)) matching.add(entry.getValue()); } if (matching.isEmpty()) { System.err.println(\"No task match \" + taskName); System.exit(1); } if (matching.size() > 1) { System.err.println(\"Too many tasks match \" + taskName); System.exit(1); } Class<Task> taskClass = matching.get(0); logger.info(\"Running experiment \" + taskClass.getCanonicalName()); Task task = taskClass.newInstance(); int errorCode = 0; try { task.init(args); if (xstreamOutput != null) { OutputStream out; if (xstreamOutput.toString().equals(\"-\")) out = System.out; else out = new FileOutputStream(xstreamOutput); logger.info(\"Serializing the object into %s\", xstreamOutput); new XStream().toXML(task, out); out.close(); } else { errorCode = task.run(); } logger.info(\"Finished task\"); } catch (Throwable t) { if (t instanceof InvocationTargetException && t.getCause() != null) { t = t.getCause(); } logger.error(\"Exception thrown while executing the action:%n%s%n\", t); errorCode = 2; } System.exit(errorCode); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: HttpRepository(Path path) throws IOException { super(path); this.url = new URL(path.toURLString()); HttpURLConnection.setFollowRedirects(true); this.connection = (HttpURLConnection) url.openConnection(); this.ns = Names.getNamespace(path); }. \n Code2: public static void copyFile(File source, File dest) throws IOException { FileChannel in = null, out = null; try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(dest).get",
        "ground_truth": "NO",
        "predict": "Channel(); in.transferTo(0, in.size(), out); } finally { if (in != null) in.close(); if (out != null) out.close(); } }. \n Code3: public static void main(String[] args) throws Throwable { new Main().run(args); }. \n */"
    },
    {
        "ID": 1320,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void bubbleSort(final int[] s) { source = s; if (source.length < 2) return; boolean go = true; while (go) { go = false; for (int i = 0; i < source.length - 1; i++) { int temp = source[i]; if (temp > source[i + 1]) { source[i] = source[i + 1]; source[i + 1] = temp; go = true; } } } }. \n Code2: private static void reconfigureDebug() { useFile = false; logValue = 0; String methodString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.method']/@value\"); String levelString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.level']/@value\"); String quietString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.quiet']/@value\"); String fileString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.file']/@value\"); String filemodeString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.filemode']/@value\"); String calltraceString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.calltrace']/@value\"); String rotateTimeoutString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatetimeout']/@value\"); String rotateDestString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedest']/@value\"); String rotateCompressString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatecompress']/@value\"); String rotateDaysString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedays']/@value\"); String rotateArchiveString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatearchive']/@value\"); String rotateDeleteString = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.debug']/property[@type='engine.rotatedelete']/@value\"); String dirName = \".\"; if (rotateTimeoutString != null) { rotateTimeout = Integer.parseInt(rotateTimeoutString); } if (rotateDestString != null) { rotateDest = rotateDestString; } if (rotateCompressString != null && rotateCompressString.equalsIgnoreCase(\"true\")) { rotateCompress = true; } if (rotateDaysString != null) { rotateDays = Integer.parseInt(rotateDaysString); } if (rotateArchiveString != null) { rotateArchive = rotateArchiveString; } if (rotateDeleteString != null && rotateDeleteString.equalsIgnoreCase(\"true\")) { rotateDelete = true; } if (fileString != null && fileString.indexOf(\"/\") != -1) { dirName = fileString.substring(0, fileString.lastIndexOf(\"/\")); (new File(dirName)).mkdirs(); } if (methodString != null) { logMethod = methodString; } else { logMethod = \"file\"; } if (levelString != null) { logValue = Integer.parseInt(levelString); } else { logValue = 0; } if (calltraceString != null && calltraceString.equalsIgnoreCase(\"true\")) { calltrace = true; } else { calltrace = false; } if (logMethod == null) { logMethod = \"file\"; } if (quietString != null) { if (quietString.equalsIgnoreCase(\"true\")) { beQuiet = true; } } if (logMethod != null) { if (logMethod.equalsIgnoreCase(\"file\")) { if (fileString != null) { logFile = fileString; } else { logFile = \"log.txt\"; } useFile = true; } } else { System.err.println(\"*** A debugging method (debug.method) is required in properties file!\"); System.err.println(\"*** Please refer to configuration documentation.\"); System.exit(-1); } timesRepeated = 0; lastMessage = null; if (useFile) { logfile = new File(logFile); try { if (filemodeString != null && filemodeString.equalsIgnoreCase(\"append\")) { ps = new PrintStream(new FileOutputStream(logfile, true)); } else { ps = new PrintStream(new FileOutputStream(logfile)); } isFile = true; Calendar calendar = new GregorianCalendar(); Date date = calendar.getTime(); DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); ps.println(); ps.println(\"--- Log file opened \" + format1.format(date) + \" ---\"); } catch (FileNotFoundException e) { System.out.println(\"Debug: Unable to instantiate debugger: \" + e.getMessage()); System.exit(-1); } catch (Exception e) { System.out.println(\"Debug: Unable to instantiate debugger - internal error: \" + e.getMessage()); System.exit(-1); } } if (!registeredSchedule) { registeredSchedule = true; if (Server.getScheduler() != null) { Server.getScheduler().register(\"Log File Rotator for '\" + logFile + \"'\", new SchedulerInterface() { public int getScheduleRate() { if (rotateTimeout != 0) { return rotateTimeout / 10; } return 0; } public void handle() { FileChannel srcChannel, destChannel; String destOutFile = logFile + \".\" + System.currentTimeMillis(); String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\"; if (rotateDest != null) { (new File(rotateDest)).mkdirs(); if (destOutFile.indexOf(\"/\") != -1) { destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.",
        "ground_truth": "NO",
        "predict": "lastIndexOf(\"/\") + 1); } if (rotateCompress) { destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1); } } try { srcChannel = new FileInputStream(logFile).getChannel(); destChannel = new FileOutputStream(destOutFile).getChannel(); if (rotateCompress) { GZIPOutputStream gzip = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed)); gzip.write(srcChannel); gzip.close(); } else { destChannel.transferFrom(srcChannel, 0, srcChannel.size()); } } catch (IOException e) { System.out.println(\"Debug: Unable to rotate log file: \" + e.getMessage()); } } }); } }\n"
    },
    {
        "ID": 1331,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(final File in, final File out) throws IOException { final FileChannel sourceChannel = new FileInputStream(in).getChannel(); final FileChannel destinationChannel = new FileOutputStream(out).getChannel(); sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel); sourceChannel.close(); destinationChannel.close(); }. \n Code2: private LinkedList<Datum> processDatum(Datum dataset) { ArrayList<Object[]> markerTestResults = new ArrayList<Object[]>(); ArrayList<Object[]> alleleEstimateResults = new ArrayList<Object[]>(); boolean hasAlleleNames = false; String blank = new String(\"\"); MarkerPhenotypeAdapter theAdapter; if (dataset.getDataType().equals(MarkerPhenotype.class)) { theAdapter = new MarkerPhenotypeAdapter((MarkerPhenotype) dataset.getData()); } else theAdapter = new MarkerPhenotypeAdapter((Phenotype) dataset.getData()); int numberOfMarkers = theAdapter.getNumberOfMarkers(); if (numberOfMarkers == 0) { return calculateBLUEsFromPhenotypes(theAdapter, dataset.getName()); } int numberOfCovariates = theAdapter.getNumberOfCovariates(); int numberOfFactors = theAdapter.getNumberOfFactors(); int numberOfPhenotypes = theAdapter.getNumberOfPhenotypes(); int expectedIterations = numberOfPhenotypes * numberOfMarkers; int iterationsSofar = 0; int percentFinished = 0; File tempFile = null; File ftestFile = null; File blueFile = null; BufferedWriter ftestWriter = null; BufferedWriter BLUEWriter = null; String ftestHeader = \"Trait\\tMarker\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tmarker_F\\tmarker_p\\tperm_p\\tmarkerR2\\tmarkerDF\\tmarkerMS\\terrorDF\\terrorMS\\tmodelDF\\tmodelMS\"; String BLUEHeader = \"Trait\\tMarker\\tObs\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tAllele\\tEstimate\"; if (writeOutputToFile) { String outputbase = outputName; if (outputbase.endsWith(\".txt\")) { int index = outputbase.lastIndexOf(\".\"); outputbase = outputbase.substring(0, index); } String datasetNameNoSpace = dataset.getName().trim().replaceAll(\"\\\\ \", \"_\"); ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.txt\"); int count = 0; while (ftestFile.exists()) { count++; ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest\" + count + \".txt\"); } blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs.txt\"); count = 0; while (blueFile.exists()) { count++; blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs\" + count + \".txt\"); } tempFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.tmp\"); try { if (permute) { ftestWriter = new BufferedWriter(new FileWriter(tempFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } else { ftestWriter = new BufferedWriter(new FileWriter(ftestFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } if (reportBLUEs) { BLUEWriter = new BufferedWriter(new FileWriter(blueFile)); BLUEWriter.write(BLUEHeader); BLUEWriter.newLine(); } } catch (IOException e) { myLogger.error(\"Failed to open file for output\"); myLogger.error(e); return null; } } if (permute) { minP = new double[numberOfPhenotypes][numberOfPermutations]; for (int i = 0; i < numberOfPermutations; i++) { for (int j = 0; j < numberOfPhenotypes; j++) { minP[j][i] = 1; } } } for (int ph = 0; ph < numberOfPhenotypes; ph++) { double[] phenotypeData = theAdapter.getPhenotypeValues(ph); boolean[] missing = theAdapter.getMissingPhenotypes(ph); ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(theAdapter, ph, missing); ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(theAdapter, ph, missing); double[][] permutedData = null; if (permute) { permutedData = permuteData(phenotypeData, missing, factorList, covariateList, theAdapter); } for (int m = 0; m < numberOfMarkers; m++) { Object[] markerData = theAdapter.getMarkerValue(ph, m); boolean[] finalMissing = new boolean[missing.length]; System.arraycopy(missing, 0, finalMissing, 0, missing.length); MarkerPhenotypeAdapterUtils.updateMissing(finalMissing, theAdapter.getMissingMarkers(ph, m)); int[] nonmissingRows = MarkerPhenotypeAdapterUtils.getNonMissingIndex(finalMissing); int numberOfObs = nonmissingRows.length; double[] y = new double[numberOfObs]; for (int i = 0; i < numberOfObs; i++) y[i] = phenotypeData[nonmissingRows[i]]; int firstMarkerAlleleEstimate = 1; ArrayList<ModelEffect> modelEffects = new ArrayList<ModelEffect>(); FactorModelEffect meanEffect = new FactorModelEffect(new int[numberOfObs], false); meanEffect.setID(\"mean\"); modelEffects.add(meanEffect); if (numberOfFactors > 0) { for (int f = 0; f < numberOfFactors; f++) { String[] afactor = factorList.get(f); String[] factorLabels = new String[numberOfObs]; for (int i = 0; i < numberOfObs; i++) factorLabels[i] = afactor[nonmissingRows[i]]; FactorModelEffect fme = new FactorModelEffect(ModelEffectUtils.getIntegerLevels(factorLabels), true, theAdapter.getFactorName(f)); modelEffects.add(fme); firstMarkerAlleleEstimate += fme.getNumberOfLevels() - 1; } } if (numberOfCovariates > 0) { for (int c = 0; c < numberOfCovariates; c++) { double[] covar = new",
        "ground_truth": "NO",
        "predict": " double[numberOfObs]; for (int i = 0; i < numberOfObs; i++) covar[i] = covariateList.get(c)[nonmissingRows[i]]; ModelEffect ce = new CovariateModelEffect(covar); modelEffects.add(ce); } } double[] markerEstimates = MarkerPhenotypeAdapterUtils.getMarkerEstimates(theAdapter, ph, m, finalMissing, modelEffects, permutedData); if (reportBLUEs) { for (int i = 0; i < numberOfObs; i++) { double[] BLUEs = MarkerPhenotypeAdapterUtils.getBLUEs(theAdapter, ph, m, i, finalMissing, modelEffects, permutedData); double[] BLUEsPermutation = MarkerPhenotypeAdapterUtils.getBLUEs(theAdapter, ph, m, i, finalMissing, modelEffects, permutedData); for (int j = 0"
    },
    {
        "ID": 1335,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getScenarioData(String urlForSalesData) throws IOException, Exception { InputStream inputStream = null; BufferedReader bufferedReader = null; DataInputStream input = null; StringBuffer sBuf = new StringBuffer(); Proxy proxy; if (httpWebProxyServer != null && Integer.toString(httpWebProxyPort) != null) { SocketAddress address = new InetSocketAddress(httpWebProxyServer, httpWebProxyPort); proxy = new Proxy(Proxy.Type.HTTP, address); } else { proxy = null; } proxy = null; URL url; try { url = new URL(urlForSalesData); HttpURLConnection httpUrlConnection; if (proxy != null) httpUrlConnection = (HttpURLConnection) url.openConnection(proxy); else httpUrlConnection = (HttpURLConnection) url.openConnection(); httpUrlConnection.setDoInput(true); httpUrlConnection.setRequestMethod(\"GET\"); String name = rb.getString(\"WRAP_NAME\"); String password = rb.getString(\"WRAP_PASSWORD\"); Credentials simpleAuthCrentials = new Credentials(TOKEN_TYPE.SimpleApiAuthToken, name, password); ACSTokenProvider tokenProvider = new ACSTokenProvider(httpWebProxyServer, httpWebProxyPort, simpleAuthCrentials); String requestUriStr1 = \"https://\" + solutionName + \".\" + acmHostName + \"/\" + serviceName; String appliesTo1 = rb.getString(\"SIMPLEAPI_APPLIES_TO\"); String token = tokenProvider.getACSToken(requestUriStr1, appliesTo1); httpUrlConnection.addRequestProperty(\"token\", \"WRAPv0.9 \" + token); httpUrlConnection.addRequestProperty(\"solutionName\", solutionName); httpUrlConnection.connect(); if (httpUrlConnection.getResponseCode() == HttpServletResponse.SC_UNAUTHORIZED) { List<TestSalesOrderService> salesOrderServiceBean = new ArrayList<TestSalesOrderService>(); TestSalesOrderService response = new TestSalesOrderService(); response.setResponseCode(HttpServletResponse.SC_UNAUTHORIZED); response.setResponseMessage(httpUrlConnection.getResponseMessage()); salesOrderServiceBean.add(response); } inputStream = httpUrlConnection.getInputStream(); input = new DataInputStream(inputStream); bufferedReader = new BufferedReader(new InputStreamReader(input)); String str; while (null != ((str = bufferedReader.readLine()))) { sBuf.append(str); } String responseString = sBuf.toString(); return responseString; } catch (MalformedURLException e) { throw e; } catch (IOException e) { throw e; } }. \n Code2: public static DBData resolveDBasURL(java.net.URL url) throws Exception { DBData data = null; InputStream fi = null; EnhancedStreamTokenizer tokenizer = null; try { fi = url.openStream(); tokenizer = new EnhancedStreamTokenizer(new BufferedReader(new InputStreamReader(fi))); initializeTokenizer(tokenizer); } catch (Exception e) { Console.getInstance().println(\"\\nError occured while opening URL '\" + url.toString() + \"'\"); Console.getInstance().println(e); return null; } if (tokenizer != null) { try { } finally { System.gc(); } } return data; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void export(final Library lib) throws PluginException { try { new Thread(new Runnable() { public void run() { formatter.format(lib, writer); writer.flush(); writer.close(); } }).start(); ftp.connect(host); if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) { ftp.disconnect(); throw new PluginException(\"Unable to connect to FTP\"); } ftp.login(user, pass); ftp.pasv(); ftp.changeWorkingDirectory(dir); ftp.storeFile(file, inStream); ftp.logout(); } catch (SocketException e) { throw new PluginException(e); } catch (IOException e) { throw new PluginException(e); } finally { if (ftp.isConnected()) { try { ftp.disconnect(); } catch (IOException e) { } } } }. \n Code2: private static void setup() throws Exception { String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile(); File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\"); if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\"); File f = File.createTempFile(\"tempabca\", \"bdfafad\"); f.delete(); f.mkdir(); String parent = f.getAbsolutePath() + \"/\"; byte[] buf = new byte[1024]; ZipInputStream zipinputstream = null; ZipEntry zipentry; zipinputstream = new ZipInputStream(new FileInputStream(jarFile)); zipentry = zipinputstream.getNextEntry(); while (zipentry != null) { String entryName = zipentry.getName(); if (entryName.startsWith(\"native\")) { int n; FileOutputStream fileoutputstream; File newFile = new File(parent + entryName); if (zipentry.isDirectory()) { newFile.mkdirs(); zipentry = zipinputstream.getNextEntry(); continue; } fileoutputstream = new FileOutputStream(newFile); while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n); fileoutputstream.close(); zipinputstream.closeEntry(); } zipentry = zipinputstream.getNextEntry(); } zipinputstream.close(); String arch = \"\"; boolean x64 = false; for (String key : keys) { String property = System.getProperty(key); if (property != null) { x64 = (property.indexOf(\"64\") >= 0); } } if (JPTrayIcon.isUnix()) { if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\"; } if (JPTrayIcon.isWindows()) { System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\")); if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\"; } if (JPTrayIcon.isMac()) arch = \"macosx-universal\"; System.out.println(\"Using native/\" + arch + \"/\"); addLibraryPath(parent",
        "ground_truth": "NO",
        "predict": " + \"native/\" + arch + \"/\"); }. \n Code1: public static void main(String[] args) throws Exception { Webcam.setup(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { Webcam.setup(); }. \n Code2: public static void main(String[] args) throws Exception { Webcam.setup(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { Webcam.setup(); }. \n Code2: public static void main(String[] args) throws Exception { Webcam.setup(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to"
    },
    {
        "ID": 1336,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected String getOldHash(String text) { String hash = null; try { MessageDigest md = MessageDigest.getInstance(\"SHA\"); md.update(text.getBytes(\"UTF-8\")); byte[] digestedBytes = md.digest(); hash = HexUtils.convert(digestedBytes); } catch (NoSuchAlgorithmException e) { log.log(Level.SEVERE, \"Error creating SHA password hash:\" + e.getMessage()); hash = text; } catch (UnsupportedEncodingException e) { log.log(Level.SEVERE, \"UTF-8 not supported!?!\"); } return hash; }. \n Code2: public void run() { if (getCommand() == null) throw new IllegalArgumentException(\"Given command is null!\"); if (getSocketProvider() == null) throw new IllegalArgumentException(\"Given connection is not open!\"); if (getCommand() instanceof ListCommand) { try { setReply(ReplyWorker.readReply(getSocketProvider(), true)); setStatus(ReplyWorker.FINISHED); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); } return; } else if (getCommand() instanceof RetrieveCommand) { RetrieveCommand retrieveCommand = (RetrieveCommand) getCommand(); if (retrieveCommand.getFromFile().getTransferType().intern() == Command.TYPE_I || retrieveCommand.getFromFile().getTransferType().intern() == Command.TYPE_A) { try { log.debug(\"Download file: \" + retrieveCommand.getFromFile().toString()); FileOutputStream out = null; FileChannel channel = null; if (getDownloadMethod() == RetrieveCommand.FILE_BASED) { out = new FileOutputStream(retrieveCommand.getToFile().getFile()); channel = out.getChannel(); if (retrieveCommand.getResumePosition() != -1) { try { channel.position(retrieveCommand.getResumePosition()); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); try { channel.close(); } catch (IOException ioe2) { } return; } } } else if (getDownloadMethod() == RetrieveCommand.BYTEBUFFER_BASED) { } int amount; try { while ((amount = getSocketProvider().read(buffer)) != -1) { if (amount == 0) { try { Thread.sleep(4); } catch (InterruptedException e) { } } buffer.flip(); while (buffer.hasRemaining()) { if (getDownloadMethod() == RetrieveCommand.STREAM_BASED) { int rem = buffer.remaining(); byte[] buf = new byte[rem]; buffer.get(buf, 0, rem); this.outputPipe.write(buf, 0, rem); } else if (getDownloadMethod() == RetrieveCommand.BYTEBUFFER_BASED) { } else { channel.write(buffer); } } buffer.clear(); } buffer.flip(); while (buffer.hasRemaining()) { if (getDownloadMethod() == RetrieveCommand.STREAM_BASED) { int rem = buffer.remaining(); byte[] buf = new byte[rem]; buffer.get(buf, 0, rem); this.outputPipe.write(buf, 0, rem); } else if (getDownloadMethod() == RetrieveCommand.BYTEBUFFER_BASED) { } else { channel.write(buffer); } } buffer.clear(); setStatus(ReplyWorker.FINISHED); if (channel != null) channel.close(); if (this.outputPipe != null) this.outputPipe.close(); getSocketProvider().close(); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); } finally { try { channel.close(); getSocketProvider().close(); } catch (Exception e) { } } } catch (FileNotFoundException fnfe) { setCaughtException(fnfe); setStatus(ReplyWorker.ERROR_FILE_NOT_FOUND); } } else throw new IllegalArgumentException(\"Unknown file transfer type for download!\"); return; } else if (getCommand() instanceof StoreCommand) { StoreCommand storeCommand = (StoreCommand) getCommand(); if (storeCommand.getToFile().getTransferType().intern() == Command.TYPE_I || storeCommand.getToFile().getTransferType().intern() == Command.TYPE_A) { try { log.debug(\"Upload file: \" + storeCommand.getFromFile()); InputStream in = storeCommand.getStream(); int amount; int socketWrite; int socketAmount = 0; if (in instanceof FileInputStream) { FileChannel channel = ((FileInputStream) in).getChannel(); if (storeCommand.getResumePosition() != -1) { try { channel.position(storeCommand.getResumePosition()); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); try { channel.close(); } catch (IOException ioe2) { } return; } } try { while ((amount = channel.read(buffer)) != -1) { buffer.flip(); socketWrite = 0; while ((socketWrite = getSocketProvider().write(buffer)) != -1) { socketAmount += socketWrite; if (amount <= socketAmount) { break; } if (socketWrite == 0) { try { Thread.sleep(4); } catch (InterruptedException e) { } } } if (socketWrite == -1) { break; } socketAmount = 0; buffer.clear(); } setStatus(ReplyWorker.FINISHED); channel.close(); getSocketProvider().close(); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); } finally { try { channel.close(); getSocketProvider().close(); } catch (Exception e) { } } } else { try { while ((amount = in.read(buffer.array())) != -1) { buffer.flip(); buffer.limit(amount); socketWrite = 0; while ((socketWrite = getSocketProvider().write(buffer)) != -1) { socketAmount = socketWrite; if (amount <= socketAmount) { break; } if (socketWrite == 0) { try { Thread.sleep(4); } catch (InterruptedException e) { } } } if (socketWrite == -1) { break; } socketAmount = 0; buffer.clear(); } setStatus(ReplyWorker.FINISHED); in.close(); getSocketProvider().close(); } catch (IOException ioe) { setCaughtException(ioe); setStatus(ReplyWorker.ERROR_IO_EXCEPTION); } finally { try { in.close(); getSocketProvider().close(); } catch (Exception e) { } } } }",
        "ground_truth": "YES",
        "predict": " catch (FileNotFoundException fnfe) { setCaughtException(fnfe); setStatus(ReplyWorker.ERROR_FILE_NOT_FOUND); } } else throw new IllegalArgumentException(\"Unknown file transfer type for upload!\"); return; } } }\n"
    },
    {
        "ID": 1364,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @org.junit.Test public void testReadWrite() throws Exception { final String reference = \"testString\"; final Reader reader = new StringReader(reference); final StringWriter osString = new StringWriter(); final Reader teeStream = new TeeReaderWriter(reader, osString); IOUtils.copy(teeStream, new NullWriter()); teeStream.close(); osString.toString(); }. \n Code2: public static File insertFileInto(File zipFile, File toInsert, String targetPath) { Zip64File zip64File = null; try { boolean compress = false; zip64File = new Zip64File(zipFile); FileEntry testEntry = getFileEntry(zip64File, targetPath); if (testEntry != null && testEntry.getMethod() == FileEntry.iMETHOD_DEFLATED) { compress = true; } processAndCreateFolderEntries(zip64File, parseTargetPath(targetPath, toInsert), compress); if (testEntry != null) { log.info(\"[insertFileInto] Entry exists: \" + testEntry.getName()); log.info(\"[insertFileInto] Will delete this entry before inserting: \" + toInsert.getName()); if (!testEntry.isDirectory()) { zip64File.delete(testEntry.getName()); } else { log.info(\"[insertFileInto] Entry is a directory. \" + \"Will delete all files contained in this entry and insert \" + toInsert.getName() + \"and all nested files.\"); if (!targetPath.contains(\"/\")) { targetPath = targetPath + \"/\"; } deleteFileEntry(zip64File, testEntry); log.info(\"[insertFileInto] Entry successfully deleted.\"); } log.info(\"[insertFileInto] Writing new Entry: \" + targetPath); EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile); IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } else { EntryOutputStream out = null; if (!compress) { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_STORED, new Date(toInsert.lastModified())); } else { out = zip64File.openEntryOutputStream(targetPath, FileEntry.iMETHOD_DEFLATED, new Date(toInsert.lastModified())); } if (toInsert.isDirectory()) { out.flush(); out.close(); log.info(\"[insertFileInto] Finished writing entry: \" + targetPath); List<String> containedPaths = normalizePaths(toInsert); List<File> containedFiles = listAllFilesAndFolders(toInsert, new ArrayList<File>()); log.info(\"[insertFileInto] Added entry is a folder.\"); log.info(\"[insertFileInto] Adding all nested files: \"); for (int i = 0; i < containedPaths.size(); i++) { File currentFile = containedFiles.get(i); String currentPath = targetPath.replace(\"/\", \"\") + File.separator + containedPaths.get(i); EntryOutputStream loop_out = null; if (!compress) { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_STORED, new Date(currentFile.lastModified())); } else { loop_out = zip64File.openEntryOutputStream(currentPath, FileEntry.iMETHOD_DEFLATED, new Date(currentFile.lastModified())); } if (currentFile.isFile()) { InputStream loop_in = new FileInputStream(currentFile); IOUtils.copyLarge(loop_in, loop_out); loop_in.close(); } log.info(\"[insertFileInto] Added: \" + currentPath); loop_out.flush(); loop_out.close(); } } else { InputStream in = new FileInputStream(toInsert); IOUtils.copyLarge(in, out); in.close(); out.flush(); out.close(); } } log.info(\"[insertFileInto] Done! Added \" + toInsert.getName() + \" to zip.\"); zip64File.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new File(zip64File.getDiskFile().getFileName()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static final String encryptPassword(String loginName, String password) { try { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(loginName.toUpperCase().getBytes(\"UTF-8\")); md5.update(password.getBytes(\"UTF-8\")); byte[] ba = md5.digest(); return byte2hex(ba); } catch (Exception e) { return password; } }. \n Code2: public static void copy(File in, File out) throws IO",
        "ground_truth": "NO",
        "predict": "Exception { FileChannel inChannel = null; FileChannel outChannel = null; try { inChannel = new FileInputStream(in).getChannel(); outChannel = new FileOutputStream(out).getChannel(); inChannel.transferTo(0, inChannel.size(), outChannel); } finally { if (inChannel != null) { inChannel.close(); } if (outChannel != null) { outChannel.close(); } } }. \n Code3: public static void main(String[] args) throws Exception { File zipFile = new File(\"test.zip\"); File toInsert = new File(\"test.txt\"); File out = new File(\"test.zip\"); zipFile.delete(); toInsert.delete(); out.delete(); insertFileInto(zipFile, toInsert, \"test/test\"); out.delete(); }. \n */"
    },
    {
        "ID": 1368,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void write(File file) throws Exception { if (isInMemory()) { FileOutputStream fout = null; try { fout = new FileOutputStream(file); fout.write(get()); } finally { if (fout != null) { fout.close(); } } } else { File outputFile = getStoreLocation(); if (outputFile != null) { size = outputFile.length(); if (!outputFile.renameTo(file)) { BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(outputFile)); out = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copy(in, out); } finally { if (in != null) { try { in.close(); } catch (IOException e) { } } if (out != null) { try { out.close(); } catch (IOException e) { } } } } } else { throw new FileUploadException(\"Cannot write uploaded file to disk!\"); } } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException { HttpClient client = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(downloadUrl); final File outputFile = new File(destinationFile); createParentDirectories(outputFile); FileOutputStream outputStream; outputStream = new FileOutputStream(outputFile); final HttpResponse response = client.execute(httpGet); if (isInterrupted()) { outputStream.close(); return; } final HttpEntity entity = response.getEntity(); InputStream inputStream = null; try { if (entity != null) { inputStream = entity.getContent(); CopyStreamStatusCallback callback = new CopyStreamStatusCallback() { @Override public long getSkipBetweenUpdates() { return entity.getContentLength() * 2 / PERCENTAGE_BASE; } @Override public void onUpdate(final long copiedLength) { int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength()); handleUpdate(STATUS_DOWNLOADING, percentage); } }; copyStreams(inputStream, outputStream, callback); } } finally { try { outputStream.close(); if (inputStream != null) { inputStream.close(); } } catch (IOException e) { Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e); } } }. \n Code2: @Test public void testTrainingBackprop() throws IOException { File temp = File.createTempFile(\"fannj_\", \".tmp\"); temp.deleteOnExit(); IOUtils.copy",
        "ground_truth": "NO",
        "predict": "(new FileInputStream(new File(\"/sdcard/fannj/training_backprop.fann\")), new FileOutputStream(temp)); File fann = new File(\"/sdcard/fannj/training_backprop.fann\"); fann.deleteOnExit(); fann.createNewFile(); fann.deleteOnExit(); File fann2 = new File(\"/sdcard/fannj/training_backprop2.fann\"); fann2.deleteOnExit(); fann2.createNewFile(); fann2.deleteOnExit(); File fann3 = new File(\"/sdcard/fannj/training_backprop3.fann\"); fann3.deleteOnExit(); fann3.createNewFile(); fann3.deleteOnExit(); File fann4 = new File(\"/sdcard/fannj/training_backprop4.fann\"); fann4.deleteOnExit(); fann4.createNewFile();"
    },
    {
        "ID": 1378,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void service(final HttpServletRequest req, final HttpServletResponse res) throws ServletException, IOException { res.setHeader(\"X-Generator\", \"VisualMon\"); String path = req.getPathInfo(); if (null == path || \"\".equals(path)) res.sendRedirect(req.getServletPath() + \"/\"); else if (\"/chart\".equals(path)) { try { res.setHeader(\"Cache-Control\", \"private,no-cache,no-store,must-revalidate\"); res.addHeader(\"Cache-Control\", \"post-check=0,pre-check=0\"); res.setHeader(\"Expires\", \"Sat, 26 Jul 1997 05:00:00 GMT\"); res.setHeader(\"Pragma\", \"no-cache\"); res.setDateHeader(\"Expires\", 0); renderChart(req, res); } catch (InterruptedException e) { log.info(\"Chart generation was interrupted\", e); Thread.currentThread().interrupt(); } } else if (path.startsWith(\"/log_\")) { String name = path.substring(5); LogProvider provider = null; for (LogProvider prov : cfg.getLogProviders()) { if (name.equals(prov.getName())) { provider = prov; break; } } if (null == provider) { log.error(\"Log provider with name \\\"{}\\\" not found\", name); res.sendError(HttpServletResponse.SC_NOT_FOUND); } else { render(res, provider.getLog(filter.getLocale())); } } else if (\"/\".equals(path)) { List<LogEntry> logs = new ArrayList<LogEntry>(); for (LogProvider provider : cfg.getLogProviders()) logs.add(new LogEntry(provider.getName(), provider.getTitle(filter.getLocale()))); render(res, new ProbeDataList(filter.getSnapshot(), filter.getAlerts(), logs, ResourceBundle.getBundle(\"de.frostcode.visualmon.stats\", filter.getLocale()).getString(\"category.empty\"), cfg.getDashboardTitle().get(filter.getLocale()))); } else { URL url = Thread.currentThread().getContextClassLoader().getResource(getClass().getPackage().getName().replace('.', '/') + req.getPathInfo()); if (null == url) { res.sendError(HttpServletResponse.SC_NOT_FOUND); return; } res.setDateHeader(\"Last-Modified\", new File(url.getFile()).lastModified()); res.setDateHeader(\"Expires\", new Date().getTime() + YEAR_IN_SECONDS * 1000L); res.setHeader(\"Cache-Control\", \"max-age=\" + YEAR_IN_SECONDS); URLConnection conn = url.openConnection(); String resourcePath = url.getPath(); String contentType = conn.getContentType(); if (resourcePath.endsWith(\".xsl\")) { contentType = \"text/xml\"; res.setCharacterEncoding(ENCODING); } if (contentType == null || \"content/unknown\".equals(contentType)) { if (resourcePath.endsWith(\".css\")) contentType = \"text/css\"; else contentType = getServletContext().getMimeType(resourcePath); } res.setContentType(contentType); res.setContentLength(conn.getContentLength()); OutputStream out = res.getOutputStream(); IOUtils.copy(conn.getInputStream(), out); IOUtils.closeQuietly(conn.getInputStream()); IOUtils.closeQuietly(out); } }. \n Code2: public void testReleaseOnEntityWriteTo() throws Exception { HttpParams params = defaultParams.copy(); ConnManagerParams.setMaxTotalConnections(params, 1); ConnManagerParams.setMaxConnectionsPerRoute(params, new ConnPerRouteBean(1)); ThreadSafeClientConnManager mgr = createTSCCM(params, null); assertEquals(0, mgr.getConnectionsInPool()); DefaultHttpClient client = new DefaultHttpClient(mgr, params); HttpGet httpget = new HttpGet(\"/random/20000\"); HttpHost target = getServerHttp(); HttpResponse response = client.execute(target, httpget); ClientConnectionRequest connreq = mgr.requestConnection(new HttpRoute(target), null); try { connreq.getConnection(250, TimeUnit.MILLISECONDS); fail(\"ConnectionPoolTimeoutException should have been thrown\"); } catch (ConnectionPoolTimeoutException expected) { } HttpEntity e = response.getEntity(); assertNotNull(e); ByteArrayOutputStream outsteam = new ByteArrayOutputStream(); e.writeTo(outsteam); assertEquals(1, mgr.getConnectionsInPool()); connreq = mgr.requestConnection(new HttpRoute(target), null); ManagedClientConnection conn = connreq.getConnection(250, TimeUnit.MILLISECONDS); mgr.releaseConnection(conn, -1, null); mgr.shutdown(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(File sourceFile, File destinationFile) throws IOException { FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel(); FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel(); sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel); sourceFileChannel.close(); destinationFileChannel.close(); }. \n Code2: public byte[] getResponse() { final ByteArrayInputStream bais = new ByteArrayInputStream(request); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); List<String> lines = Collections.emptyList(); try { @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais); lines = dl; } catch (IOException ioex) { throw new AssertionError(ioex); } String resource = null; for (String line : lines) { if (line.startsWith(\"GET \")) { int endIndex = line.lastIndexOf(' '); resource = line.substring(4, endIndex); } } final PrintStream printStream = new PrintStream(baos); if (resource == null) { printStream.println(\"HTTP/1.1 400 Bad Request\"); } else { final InputStream inputStream = getClass().getResourceAsStream(resource); if (inputStream == null) { printStream.println(\"HTTP/1.1 404 Not Found\"); printStream.println(); } else { printStream.println(\"HTTP/1.1 200 OK\"); printStream.println(); try { IOUtils.copy(inputStream, print",
        "ground_truth": "YES",
        "predict": "Stream); } catch (IOException ioex) { throw new AssertionError(ioex); } } } return baos.toByteArray(); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(File sourceFile, File destinationFile) throws IOException { FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel(); FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel(); sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel); sourceFileChannel.close(); destinationFileChannel.close(); }. \n Code2: public byte[] getResponse() { final ByteArrayInputStream bais = new ByteArrayInputStream(request); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); List<String> lines = Collections.emptyList(); try { @SuppressWarnings(\""
    },
    {
        "ID": 1384,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int process(ProcessorContext context) throws InterruptedException, ProcessorException { logger.info(\"JAISaveTask:process\"); final RenderedOp im = (RenderedOp) context.get(\"RenderedOp\"); final String path = \"s3://s3.amazonaws.com/rssfetch/\" + (new Guid()); final PNGEncodeParam.RGB encPar = new PNGEncodeParam.RGB(); encPar.setTransparentRGB(new int[] { 0, 0, 0 }); File tmpFile = null; try { tmpFile = File.createTempFile(\"thmb\", \".png\"); OutputStream out = new FileOutputStream(tmpFile); final ParameterBlock pb = (new ParameterBlock()).addSource(im).add(out).add(\"png\").add(encPar); JAI.create(\"encode\", pb, null); out.flush(); out.close(); FileInputStream in = new FileInputStream(tmpFile); final XFile xfile = new XFile(path); final XFileOutputStream xout = new XFileOutputStream(xfile); final com.luzan.common.nfs.s3.XFileExtensionAccessor xfa = ((com.luzan.common.nfs.s3.XFileExtensionAccessor) xfile.getExtensionAccessor()); if (xfa != null) { xfa.setMimeType(\"image/png\"); xfa.setContentLength(tmpFile.length()); } IOUtils.copy(in, xout); xout.flush(); xout.close(); in.close(); context.put(\"outputPath\", path); } catch (IOException e) { logger.error(e); throw new ProcessorException(e); } catch (Throwable e) { logger.error(e); throw new ProcessorException(e); } finally { if (tmpFile != null && tmpFile.exists()) { tmpFile.delete(); } } return TaskState.STATE_MO_START + TaskState.STATE_ENCODE; }. \n Code2: private void doIt() throws Throwable { GenericDAO<User> dao = DAOFactory.createDAO(User.class); try { final User user = dao.findUniqueByCriteria(Expression.eq(\"login\", login)); if (user == null) throw new IllegalArgumentException(\"Specified user isn't exist\"); if (srcDir.isDirectory() && srcDir.exists()) { final String[] fileList = srcDir.list(new XFilenameFilter() { public boolean accept(XFile dir, String file) { String[] fNArr = file.split(\"\\\\.\"); return (fNArr.length > 1 && (fNArr[fNArr.length - 1].equalsIgnoreCase(\"map\") || fNArr[fNArr.length - 1].equalsIgnoreCase(\"plt\") || fNArr[fNArr.length - 1].equalsIgnoreCase(\"wpt\"))); } }); int pointsCounter = 0; int tracksCounter = 0; int mapsCounter = 0; for (final String fName : fileList) { try { TransactionManager.beginTransaction(); } catch (Throwable e) { logger.error(e); throw e; } final XFile file = new XFile(srcDir, fName); InputStream in = new XFileInputStream(file); try { ArrayList<UserMapOriginal> maps = new ArrayList<UserMapOriginal>(); ArrayList<MapTrackPointsScaleRequest> tracks = new ArrayList<MapTrackPointsScaleRequest>(); final byte[] headerBuf = new byte[1024]; if (in.read(headerBuf) <= 0) continue; final String fileHeader = new String(headerBuf); final boolean isOziWPT = (fileHeader.indexOf(\"OziExplorer Waypoint File\") >= 0); final boolean isOziPLT = (fileHeader.indexOf(\"OziExplorer Track Point File\") >= 0); final boolean isOziMAP = (fileHeader.indexOf(\"OziExplorer Map Data File\") >= 0); final boolean isKML = (fileHeader.indexOf(\"<kml xmlns=\") >= 0); if (isOziMAP || isOziPLT || isOziWPT || isKML) { in.close(); in = new XFileInputStream(file); } else continue; WPTPoint wp; if (isOziWPT) { try { wp = new WPTPointParser(in, \"Cp1251\").parse(); } catch (Throwable t) { wp = null; } if (wp != null) { Set<WayPointRow> rows = wp.getPoints(); for (WayPointRow row : rows) { final UserMapPoint p = BeanFactory.createUserPoint(row, user); logger.info(\"point:\" + p.getGuid()); } pointsCounter += rows.size(); } } else if (isOziPLT) { PLTTrack plt; try { plt = new PLTTrackParser(in, \"Cp1251\").parse(); } catch (Throwable t) { plt = null; } if (plt != null) { final UserMapTrack t = BeanFactory.createUserTrack(plt, user); tracks.add(new MapTrackPointsScaleRequest(t)); tracksCounter++; logger.info(\"track:\" + t.getGuid()); } } else if (isOziMAP) { MapProjection projection; MAPParser parser = new MAPParser(in, \"Cp1251\"); try { projection = parser.parse(); } catch (Throwable t) { projection = null; } if (projection != null && projection.getPoints() != null && projection.getPoints().size() >= 2) { GenericDAO<UserMapOriginal> mapDao = DAOFactory.createDAO(UserMapOriginal.class); final UserMapOriginal mapOriginal = new UserMapOriginal(); mapOriginal.setName(projection.getTitle()); mapOriginal.setUser(user); mapOriginal.setState(UserMapOriginal.State.UPLOAD); mapOriginal.setSubstate(UserMapOriginal.SubState.COMPLETE); MapManager.updateProjection(projection, mapOriginal); final XFile srcFile = new XFile(srcDir, projection.getPath()); if (!srcFile.exists() || !srcFile.isFile()) throw new IllegalArgumentException(\"file: \" + srcFile.getPath() + \" not found\"); final XFile mapStorage = new XFile(new XFile(Configuration.getInstance().getPrivateMapStorage().toString()), mapOriginal.getGuid()); mapStorage.mkdir(); XFile dstFile = new XFile(mapStorage, mapOriginal.getGuid()); XFileOutputStream out = new XFileOutputStream(dstFile); XFileInputStream inImg = new XFileInputStream(srcFile); IOUtils.copy(inImg, out); out.flush(); out.close(); inImg",
        "ground_truth": "NO",
        "predict": ".close(); mapDao.update(mapOriginal); mapsCounter++; } } catch (Throwable e) { logger.error(e); } finally { if (in != null) in.close(); } } } catch (Throwable e) { logger.error(e); } finally { TransactionManager.commitTransaction(); } } } }\n"
    },
    {
        "ID": 1397,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void writeTo(final TrackRepresentation t, final Class<?> type, final Type genericType, final Annotation[] annotations, final MediaType mediaType, final MultivaluedMap<String, Object> httpHeaders, final OutputStream entityStream) throws WebApplicationException { if (mediaType.isCompatible(MediaType.APPLICATION_OCTET_STREAM_TYPE)) { InputStream is = null; try { httpHeaders.add(\"Content-Type\", \"audio/mp3\"); IOUtils.copy(is = t.getInputStream(mediaType), entityStream); } catch (final IOException e) { LOG.warn(\"IOException : maybe remote client has disconnected\"); } finally { IOUtils.closeQuietly(is); } } }. \n Code2: protected int authenticate(long companyId, String login, String password, String authType, Map headerMap, Map parameterMap) throws PortalException, SystemException { login = login.trim().toLowerCase(); long userId = GetterUtil.getLong(login); if (authType.equals(CompanyImpl.AUTH_TYPE_EA)) { if (!Validator.isEmailAddress(login)) { throw new UserEmailAddressException(); } } else if (authType.equals(CompanyImpl.AUTH_TYPE_SN)) { if (Validator.isNull(login)) { throw new UserScreenNameException(); } } else if (authType.equals(CompanyImpl.AUTH_TYPE_ID)) { if (Validator.isNull(login)) { throw new UserIdException(); } } if (Validator.isNull(password)) { throw new UserPasswordException(UserPasswordException.PASSWORD_INVALID); } int authResult = Authenticator.FAILURE; String[] authPipelinePre = PropsUtil.getArray(PropsUtil.AUTH_PIPELINE_PRE); if (authType.equals(CompanyImpl.AUTH_TYPE_EA)) { authResult = AuthPipeline.authenticateByEmailAddress(authPipelinePre, companyId, login, password, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_SN)) { authResult = AuthPipeline.authenticateByScreenName(authPipelinePre, companyId, login, password, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_ID)) { authResult = AuthPipeline.authenticateByUserId(authPipelinePre, companyId, userId, password, headerMap, parameterMap); } User user = null; try { if (authType.equals(CompanyImpl.AUTH_TYPE_EA)) { user = UserUtil.findByC_EA(companyId, login); } else if (authType.equals(CompanyImpl.AUTH_TYPE_SN)) { user = UserUtil.findByC_SN(companyId, login); } else if (authType.equals(CompanyImpl.AUTH_TYPE_ID)) { user = UserUtil.findByC_U(companyId, GetterUtil.getLong(login)); } } catch (NoSuchUserException nsue) { return Authenticator.DNE; } if (user.isDefaultUser()) { _log.error(\"The default user should never be allowed to authenticate\"); return Authenticator.DNE; } if (!user.isPasswordEncrypted()) { user.setPassword(PwdEncryptor.encrypt(user.getPassword())); user.setPasswordEncrypted(true); UserUtil.update(user); } checkLockout(user); checkPasswordExpired(user); if (authResult == Authenticator.SUCCESS) { if (GetterUtil.getBoolean(PropsUtil.get(PropsUtil.AUTH_PIPELINE_ENABLE_LIFERAY_CHECK))) { String encPwd = PwdEncryptor.encrypt(password, user.getPassword()); if (user.getPassword().equals(encPwd)) { authResult = Authenticator.SUCCESS; } else if (GetterUtil.getBoolean(PropsUtil.get(PropsUtil.AUTH_MAC_ALLOW))) { try { MessageDigest digester = MessageDigest.getInstance(PropsUtil.get(PropsUtil.AUTH_MAC_ALGORITHM)); digester.update(login.getBytes(\"UTF8\")); String shardKey = PropsUtil.get(PropsUtil.AUTH_MAC_SHARED_KEY); encPwd = Base64.encode(digester.digest(shardKey.getBytes(\"UTF8\"))); if (password.equals(encPwd)) { authResult = Authenticator.SUCCESS; } else { authResult = Authenticator.FAILURE; } } catch (NoSuchAlgorithmException nsae) { throw new SystemException(nsae); } catch (UnsupportedEncodingException uee) { throw new SystemException(uee); } } else { authResult = Authenticator.FAILURE; } } } if (authResult == Authenticator.SUCCESS) { String[] authPipelinePost = PropsUtil.getArray(PropsUtil.AUTH_PIPELINE_POST); if (authType.equals(CompanyImpl.AUTH_TYPE_EA)) { authResult = AuthPipeline.authenticateByEmailAddress(authPipelinePost, companyId, login, password, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_SN)) { authResult = AuthPipeline.authenticateByScreenName(authPipelinePost, companyId, login, password, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_ID)) { authResult = AuthPipeline.authenticateByUserId(authPipelinePost, companyId, userId, password, headerMap, parameterMap); } } if (authResult == Authenticator.FAILURE) { try { String[] authFailure = PropsUtil.getArray(PropsUtil.AUTH_FAILURE); if (authType.equals(CompanyImpl.AUTH_TYPE_EA)) { AuthPipeline.onFailureByEmailAddress(authFailure, companyId, login, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_SN)) { AuthPipeline.onFailureByScreenName(authFailure, companyId, login, headerMap, parameterMap); } else if (authType.equals(CompanyImpl.AUTH_TYPE_ID)) { AuthPipeline.onFailureByUserId(authFailure, companyId, userId, headerMap, parameterMap); } if (!PortalLDAPUtil",
        "ground_truth": "NO",
        "predict": ".isLDAPEnabled()) { throw new SystemException(\"LDAP is not enabled\"); } } catch (Exception e) { throw new SystemException(e); } } return authResult; }\n\n}\n"
    },
    {
        "ID": 1399,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testWriteThreadsNoCompression() throws Exception { Bootstrap bootstrap = new Bootstrap(); bootstrap.loadProfiles(CommandLineProcessorFactory.PROFILE.DB, CommandLineProcessorFactory.PROFILE.REST_CLIENT, CommandLineProcessorFactory.PROFILE.COLLECTOR); final LocalLogFileWriter writer = (LocalLogFileWriter) bootstrap.getBean(LogFileWriter.class); writer.init(); writer.setCompressionCodec(null); File fileInput = new File(baseDir, \"testWriteOneFile/input\"); fileInput.mkdirs(); File fileOutput = new File(baseDir, \"testWriteOneFile/output\"); fileOutput.mkdirs(); writer.setBaseDir(fileOutput); int fileCount = 100; int lineCount = 100; File[] inputFiles = createInput(fileInput, fileCount, lineCount); ExecutorService exec = Executors.newFixedThreadPool(fileCount); final CountDownLatch latch = new CountDownLatch(fileCount); for (int i = 0; i < fileCount; i++) { final File file = inputFiles[i]; final int count = i; exec.submit(new Callable<Boolean>() { @Override public Boolean call() throws Exception { FileStatus.FileTrackingStatus status = FileStatus.FileTrackingStatus.newBuilder().setFileDate(System.currentTimeMillis()).setDate(System.currentTimeMillis()).setAgentName(\"agent1\").setFileName(file.getName()).setFileSize(file.length()).setLogType(\"type1\").build(); BufferedReader reader = new BufferedReader(new FileReader(file)); try { String line = null; while ((line = reader.readLine()) != null) { writer.write(status, new ByteArrayInputStream((line + \"\\n\").getBytes())); } } finally { IOUtils.closeQuietly(reader); } LOG.info(\"Thread[\" + count + \"] completed \"); latch.countDown(); return true; } }); } latch.await(); exec.shutdown(); LOG.info(\"Shutdown thread service\"); writer.close(); File[] outputFiles = fileOutput.listFiles(); assertNotNull(outputFiles); File testCombinedInput = new File(baseDir, \"combinedInfile.txt\"); testCombinedInput.createNewFile(); FileOutputStream testCombinedInputOutStream = new FileOutputStream(testCombinedInput); try { for (File file : inputFiles) { FileInputStream f1In = new FileInputStream(file); IOUtils.copy(f1In, testCombinedInputOutStream); } } finally { testCombinedInputOutStream.close(); } File testCombinedOutput = new File(baseDir, \"combinedOutfile.txt\"); testCombinedOutput.createNewFile(); FileOutputStream testCombinedOutOutStream = new FileOutputStream(testCombinedOutput); try { System.out.println(\"----------------- \" + testCombinedOutput.getAbsolutePath()); for (File file : outputFiles) { FileInputStream f1In = new FileInputStream(file); IOUtils.copy(f1In, testCombinedOutOutStream); } } finally { testCombinedOutOutStream.close(); } FileUtils.contentEquals(testCombinedInput, testCombinedOutput); }. \n Code2: public Void doInBackground() { setProgress(0); for (int i = 0; i < uploadFiles.size(); i++) { String filePath = uploadFiles.elementAt(i).getFilePath(); String fileName = uploadFiles.elementAt(i).getFileName(); String fileMsg = \"Uploading file \" + (i + 1) + \"/\" + uploadFiles.size() + \"\\n\"; this.publish(fileMsg); try { File inFile = new File(filePath); FileInputStream in = new FileInputStream(inFile); byte[] inBytes = new byte[(int) chunkSize]; int count = 1; int maxCount = (int) (inFile.length() / chunkSize); if (inFile.length() % chunkSize > 0) { maxCount++; } int readCount = 0; readCount = in.read(inBytes); while (readCount > 0) { File splitFile = File.createTempFile(\"upl\", null, null); String splitName = splitFile.getPath(); FileOutputStream out = new FileOutputStream(splitFile); out.write(inBytes, 0, readCount); out.close(); boolean chunkFinal = (count == maxCount); fileMsg = \" - Sending chunk \" + count + \"/\" + maxCount + \": \"; this.publish(fileMsg); boolean uploadSuccess = false; int uploadTries = 0; while (!uploadSuccess && uploadTries <= 5) { uploadTries++; boolean uploadStatus = upload(splitName, fileName, count, chunkFinal); if (uploadStatus) { fileMsg = \"OK\\n\"; this.publish(fileMsg); uploadSuccess = true; } else { fileMsg = \"ERROR\\n\"; this.publish(fileMsg); uploadSuccess = false; } } if (!uploadSuccess) { fileMsg = \"There was an error uploading your files. Please let the pipeline administrator know about this problem. Cut and paste the messages in this box, and supply them.\\n\"; this.publish(fileMsg); errorFlag = true; return null; } float thisProgress = (count * 100) / (maxCount); float completeProgress = (i * (100 / uploadFiles.size())); float totalProgress = completeProgress + (thisProgress / uploadFiles.size()); setProgress((int) totalProgress); splitFile.delete(); readCount = in.read(inBytes); count++; } } catch (Exception e) { this.publish(e.toString()); } } return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String md5(String uri) throws ConnoteaRuntimeException { try { MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.update(uri.getBytes()); byte[] bytes = messageDigest.digest(); StringBuffer stringBuffer = new StringBuffer(); for (byte b : bytes) { String hex = Integer.toHexString(0xff & b); if (hex.length() == 1) { stringBuffer.append('0'); } stringBuffer.append(hex); } return stringBuffer.toString(); } catch (NoSuchAlgorithmException e) { throw new ConnoteaRuntimeException(e); } }. \n Code2: @Test public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception { Exception e = new UnsuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req",
        "ground_truth": "NO",
        "predict": ", ctx); assertEquals(resp, result); }. \n Code3: @Test public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception { Exception e = new UnsuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req, ctx); assertEquals(resp, result); }. \n Code4: @Test public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception { Exception e = new UnsuccessfulResponseException(resp); expect(mockBackend.execute(host, req, ctx)).andThrow(e); replay(mockBackend); HttpResponse result = impl.execute(host, req, ctx); assertEquals(resp, result); }. \n Code5: @Test public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception { Exception e = new UnsuccessfulResponseException("
    },
    {
        "ID": 1402,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static void copy(File fromFile, File toFile) throws IOException { if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFile.getCanonicalPath()); if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFile.getCanonicalPath()); if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFile.getCanonicalPath()); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFile.getCanonicalPath()); throw new IOException(\"FileCopy: \" + \"existing file was not overwritten.\"); } else { String parent = toFile.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent); if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent); if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(fromFile); to = new FileOutputStream(toFile); byte[] buffer = new byte[1024 * 1024]; int bytesRead; while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); if (fromFile.isHidden()) { } toFile.setLastModified(fromFile.lastModified()); toFile.setExecutable(fromFile.canExecute()); toFile.setReadable(fromFile.canRead()); toFile.setWritable(toFile.canWrite()); } finally { if (from != null) try { from.close(); } catch (IOException e) { ; } if (to != null) try { to.close(); } catch (IOException e) { ; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String str2md5(String str) { try { MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE); alga.update(str.getBytes()); byte[] digesta = alga.digest();",
        "ground_truth": "NO",
        "predict": " return toHex(digesta); } catch (NoSuchAlgorithmException e) { return null; } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String str2md5(String str) { try { MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE); alga.update(str.getBytes()); byte[] digesta = alga.digest(); return toHex(digesta); } catch (NoSuchAlgorithmException e) { return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String str2md5(String str) { try { MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE); al"
    },
    {
        "ID": 1403,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static void copy_file(String fromFileName, String toFileName) throws IOException { File fromFile = new File(fromFileName); File toFile = new File(toFileName); if (!fromFile.exists()) throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName); if (!fromFile.isFile()) throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName); if (!fromFile.canRead()) throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName); if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName()); if (toFile.exists()) { if (!toFile.canWrite()) throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName); System.out.print(\"Overwrite existing file \" + toFile.getName() + \"? (Y/N): \"); System.out.flush(); BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String response = in.readLine(); if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new IOException(\"FileCopy: \" + \"existing file was not overwritten.\"); } else { String parent = toFile.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent); if (dir.isFile()) throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent); if (!dir.canWrite()) throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(fromFile); to = new FileOutputStream(toFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); } finally { if (from != null) try { from.close(); } catch (IOException e) { ; } if (to != null) try { to.close(); } catch (IOException e) { ; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public final void navigate(final URL url) { try { EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url); final URL",
        "ground_truth": "NO",
        "predict": "Connection connection = url.openConnection(); connection.connect(); } catch (final IOException e) { EncogLogging.log(EncogLogging.LEVEL_ERROR, \"Error navigating to page:\" + url); } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public final void navigate(final String url) { try { EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url); final URLConnection connection = new URL(url).openConnection(); connection.connect(); } catch (final IOException e) { EncogLogging.log(EncogLogging.LEVEL_ERROR, \"Error navigating to page:\" + url); } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public final void navigate("
    },
    {
        "ID": 1404,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void runTask(HashMap pjobParms) throws Exception { FTPClient lftpClient = null; FileInputStream lfisSourceFile = null; JBJFPluginDefinition lpluginCipher = null; IJBJFPluginCipher theCipher = null; try { JBJFFTPDefinition lxmlFTP = null; if (getFTPDefinition() != null) { lxmlFTP = getFTPDefinition(); this.mstrSourceDirectory = lxmlFTP.getSourceDirectory(); this.mstrTargetDirectory = lxmlFTP.getTargetDirectory(); this.mstrFilename = lxmlFTP.getFilename(); this.mstrRemoteServer = lxmlFTP.getServer(); if (getResources().containsKey(\"plugin-cipher\")) { lpluginCipher = (JBJFPluginDefinition) getResources().get(\"plugin-cipher\"); } if (lpluginCipher != null) { theCipher = getTaskPlugins().getCipherPlugin(lpluginCipher.getPluginId()); } if (theCipher != null) { this.mstrServerUsr = theCipher.decryptString(lxmlFTP.getUser()); this.mstrServerPwd = theCipher.decryptString(lxmlFTP.getPass()); } else { this.mstrServerUsr = lxmlFTP.getUser(); this.mstrServerPwd = lxmlFTP.getPass(); } } else { throw new Exception(\"Work unit [ \" + SHORT_NAME + \" ] is missing an FTP Definition. Please check\" + \" your JBJF Batch Definition file an make sure\" + \" this work unit has a <resource> element added\" + \" within the <task> element.\"); } lfisSourceFile = new FileInputStream(mstrSourceDirectory + File.separator + mstrFilename); lftpClient = new FTPClient(); lftpClient.connect(mstrRemoteServer); lftpClient.setFileType(lxmlFTP.getFileTransferType()); if (!FTPReply.isPositiveCompletion(lftpClient.getReplyCode())) { throw new Exception(\"FTP server [ \" + mstrRemoteServer + \" ] refused connection.\"); } if (!lftpClient.login(mstrServerUsr, mstrServerPwd)) { throw new Exception(\"Unable to login to server [ \" + mstrTargetDirectory + \" ].\"); } if (!lftpClient.changeWorkingDirectory(mstrTargetDirectory)) { throw new Exception(\"Unable to change to remote directory [ \" + mstrTargetDirectory + \"]\"); } lftpClient.enterLocalPassiveMode(); if (!lftpClient.storeFile(mstrFilename, lfisSourceFile)) { throw new Exception(\"Unable to upload [ \" + mstrSourceDirectory + \"/\" + mstrFilename + \" ]\" + \" to \" + mstrTargetDirectory + File.separator + mstrFilename + \" to \" + mstrRemoteServer); } lfisSourceFile.close(); lftpClient.logout(); } catch (Exception e) { throw e; } finally { if (lftpClient != null && lftpClient.isConnected()) { try { lftpClient.disconnect(); } catch (IOException ioe) { } } if (lfisSourceFile != null) { try { lfisSourceFile.close(); } catch (Exception e) { } } } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen",
        "ground_truth": "NO",
        "predict": " >> 24)); } } catch (Exception e) { throw e; } finally { out.close(); } }\n Code3: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags."
    },
    {
        "ID": 1407,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void copy(final File source, final File dest) throws IOException { final FileInputStream in = new FileInputStream(source); try { final FileOutputStream out = new FileOutputStream(dest); try { final FileChannel inChannel = in.getChannel(); final FileChannel outChannel = out.getChannel(); inChannel.transferTo(0, inChannel.size(), outChannel); } finally { out.close(); } } finally { in.close(); } }. \n Code2: private void anneal(final float maxGamma, final float gammaAccel, final float objectiveTolerance, final float objectiveAccel, final float scoreTolerance, final float paramTolerance, final float distanceLimit, final float randomLimit, final long randomSeed, final BufferedDocuments<Phrase> references, final int n, final int maxNbest, File stateFile, boolean keepState) { float gamma = 0; boolean annealObjective = true; double[] convergedScores = new double[n]; double[] totalLogScores = new double[n]; boolean[] isConverged = new boolean[n]; GradientPoint[] initPoints = new GradientPoint[n]; GradientPoint[] prevInitPoints = new GradientPoint[n]; GradientPoint[] bestInitPoints = new GradientPoint[n]; GradientPoint[] prevMinPoints = new GradientPoint[n]; Random rand = new Random(randomSeed); Time time = new Time(); if (stateFile != null && stateFile.length() > 0) { time.reset(); try { ObjectInputStream stream = new ObjectInputStream(new FileInputStream(stateFile)); gamma = stream.readFloat(); annealObjective = stream.readBoolean(); convergedScores = (double[]) stream.readObject(); totalLogScores = (double[]) stream.readObject(); isConverged = (boolean[]) stream.readObject(); initPoints = (GradientPoint[]) stream.readObject(); prevInitPoints = (GradientPoint[]) stream.readObject(); bestInitPoints = (GradientPoint[]) stream.readObject(); prevMinPoints = (GradientPoint[]) stream.readObject(); rand = (Random) stream.readObject(); int size = stream.readInt(); for (int id = 0; id < size; id++) { Feature feature = FEATURES.getRaw(CONFIG, stream.readUTF(), 0f); if (feature.getId() != id) throw new Exception(\"Features have changed\"); } evaluation.read(stream); stream.close(); output.println(\"# Resuming from previous optimization state (\" + time + \")\"); output.println(); } catch (Exception e) { e.printStackTrace(); Log.getInstance().severe(\"Failed loading optimization state (\" + stateFile + \"): \" + e.getMessage()); } } else { final int evaluations = ProjectedEvaluation.CFG_OPT_HISTORY_SIZE.getValue(); final GradientPoint[] randPoints = new GradientPoint[n * evaluations]; for (int i = 0; i < n; i++) { evaluation.setParallelId(i); for (int j = 0; j < evaluations; j++) { if (i != 0) randPoints[i * n + j] = getRandomPoint(rand, randPoints[0], distanceLimit, null); evaluate(references, i + \":\" + j); if (i == 0) { randPoints[0] = new GradientPoint(evaluation, null); gamma = LogFeatureModel.FEAT_MODEL_GAMMA.getValue(); break; } } } for (int i = 0; i < randPoints.length; i++) if (randPoints[i] != null) randPoints[i] = new GradientPoint(evaluation, randPoints[i], output); for (int i = 0; i < n; i++) { prevInitPoints[i] = null; initPoints[i] = randPoints[i * n]; if (i != 0) for (int j = 1; j < evaluations; j++) if (randPoints[i * n + j].getScore() < initPoints[i].getScore()) initPoints[i] = randPoints[i * n + j]; bestInitPoints[i] = initPoints[i]; convergedScores[i] = Float.MAX_VALUE; } } for (int searchCount = 1; ; searchCount++) { boolean isFinished = true; for (int i = 0; i < n; i++) isFinished = isFinished && isConverged[i]; if (isFinished) { output.println(\"*** N-best list converged. Modifying annealing schedule. ***\"); output.println(); if (annealObjective) { boolean objectiveConverged = true; for (int i = 0; objectiveConverged && i < n; i++) objectiveConverged = isConverged(bestInitPoints[i].getScore(), convergedScores[i], objectiveTolerance, SCORE_EPSILON); annealObjective = false; for (Metric<ProjectedSentenceEvaluation> metric : AbstractEvaluation.CFG_EVAL_METRICS.getValue()) if (metric.doAnnealing()) { float weight = metric.getWeight(); if (weight != 0) if (objectiveConverged) metric.setWeight(0); else { annealObjective = true; metric.setWeight(weight / objectiveAccel); } } } if (!annealObjective) { if (Math.abs(gamma) >= maxGamma) { GradientPoint bestPoint = bestInitPoints[0]; for (int i = 1; i < n; i++) if (bestInitPoints[i].getScore() < bestPoint.getScore()) bestPoint = bestInitPoints[i]; output.format(\"Best Score: %+.7g%n\", bestPoint.getScore()); output.println(); bestPoint = new GradientPoint(evaluation, bestPoint, output); break; } gamma *= gammaAccel; if (Math.abs(gamma) + GAMMA_EPSILON >= maxGamma) gamma = gamma >= 0 ? maxGamma : -maxGamma; } for (int i = 0; i < n; i++) { convergedScores[i] = bestInitPoints[i].getScore(); initPoints[i] = new GradientPoint(evaluation, bestInitPoints[i], gamma, output); bestInitPoints[i] = initPoints[i]; prevInitPoints[i] = null; prevMinPoints[i] = null; isConverged[i] = false; } searchCount = 0; } for (int i = 0; i < n; i++) { if (isConverged[i]) continue; if (n > 1) output.println(\"Minimizing point \" + i); Gradient gradient = initPoints[i].getGradient(); for (int id = 0; id < FEATURES.size(); id++) output.",
        "ground_truth": "NO",
        "predict": "format(\"%s: %+.7g%n\", FEATURES.getRaw(CONFIG, id, 0f), gradient.get(id)); output.println(); } } }\n"
    },
    {
        "ID": 1411,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void reconstruct(final List files, final Map properties, final OutputStream fout, final String base_url, final String producer, final PageSize[] size, final List hf) throws CConvertException { OutputStream out = fout; OutputStream out2 = fout; boolean signed = false; OutputStream oldOut = null; File tmp = null; File tmp2 = null; try { tmp = File.createTempFile(\"yahp\", \"pdf\"); tmp2 = File.createTempFile(\"yahp\", \"pdf\"); oldOut = out; if (\"true\".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_SIGNING))) { signed = true; out2 = new FileOutputStream(tmp2); } else { out2 = oldOut; } out = new FileOutputStream(tmp); com.lowagie.text.Document document = null; PdfCopy writer = null; boolean first = true; Map mapSizeDoc = new HashMap(); int totalPage = 0; for (int i = 0; i < files.size(); i++) { final File fPDF = (File) files.get(i); final PdfReader reader = new PdfReader(fPDF.getAbsolutePath()); reader.consolidateNamedDestinations(); final int n = reader.getNumberOfPages(); if (first) { first = false; document = new com.lowagie.text.Document(reader.getPageSizeWithRotation(1)); writer = new PdfCopy(document, out); writer.setPdfVersion(PdfWriter.VERSION_1_3); writer.setFullCompression(); if (\"true\".equals(properties.get(IHtmlToPdfTransformer.USE_PDF_ENCRYPTION))) { final String password = (String) properties.get(IHtmlToPdfTransformer.PDF_ENCRYPTION_PASSWORD); final int securityType = CDocumentReconstructor.getSecurityFlags(properties); writer.setEncryption(PdfWriter.STRENGTH128BITS, password, null, securityType); } final String title = (String) properties.get(IHtmlToPdfTransformer.PDF_TITLE); if (title != null) { document.addTitle(title); } else if (base_url != null) { document.addTitle(base_url); } final String creator = (String) properties.get(IHtmlToPdfTransformer.PDF_CREATOR); if (creator != null) { document.addCreator(creator); } else { document.addCreator(IHtmlToPdfTransformer.VERSION); } final String author = (String) properties.get(IHtmlToPdfTransformer.PDF_AUTHOR); if (author != null) { document.addAuthor(author); } final String sproducer = (String) properties.get(IHtmlToPdfTransformer.PDF_PRODUCER); if (sproducer != null) { document.addProducer(sproducer); } else { document.addProducer(IHtmlToPdfTransformer.VERSION + \" - http://www.allcolor.org/YaHPConverter/ - \" + producer); } document.open(); } PdfImportedPage page; for (int j = 0; j < n; ) { ++j; totalPage++; mapSizeDoc.put(\"\" + totalPage, \"\" + i); page = writer.getImportedPage(reader, j); writer.addPage(page); } } document.close(); out.flush(); out.close(); { final PdfReader reader = new PdfReader(tmp.getAbsolutePath()); ; final int n = reader.getNumberOfPages(); final PdfStamper stp = new PdfStamper(reader, out2); int i = 0; BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, BaseFont.EMBEDDED); final CHtmlToPdfFlyingSaucerTransformer trans = new CHtmlToPdfFlyingSaucerTransformer(); while (i < n) { i++; int indexSize = Integer.parseInt((String) mapSizeDoc.get(\"\" + i)); final int[] dsize = size[indexSize].getSize(); final int[] dmargin = size[indexSize].getMargin(); for (final Iterator it = hf.iterator(); it.hasNext(); ) { final CHeaderFooter chf = (CHeaderFooter) it.next(); if (chf.getSfor().equals(CHeaderFooter.ODD_PAGES) && (i % 2 == 0)) { continue; } else if (chf.getSfor().equals(CHeaderFooter.EVEN_PAGES) && (i % 2 != 0)) { continue; } final String text = chf.getContent().replaceAll(\"<pagenumber>\", \"\" + i).replaceAll(\"<pagecount>\", \"\" + n); final PdfContentByte over = stp.getOverContent(i); final ByteArrayOutputStream bbout = new ByteArrayOutputStream(); if (chf.getType().equals(CHeaderFooter.HEADER)) { trans.transform(new ByteArrayInputStream(text.getBytes(\"utf-8\")), base_url, new PageSize(dsize[0] - (dmargin[0] + dmargin[1]), dmargin[3]), new ArrayList(), properties, bbout); } else if (chf.getType().equals(CHeaderFooter.FOOTER)) { trans.transform(new ByteArrayInputStream(text.getBytes(\"utf-8\")), base_url, new PageSize(dsize[0] - (dmargin[0] + dmargin[1]), dmargin[2]), new ArrayList(), properties, bbout); } final PdfReader readerHF = new PdfReader(bbout.toByteArray()); if (chf.getType().equals(CHeaderFooter.HEADER)) { over.addTemplate(stp.getImportedPage(readerHF, 1), dmargin[0], dsize[1] - dmargin[3]); } else if (chf.getType().equals(CHeaderFooter.FOOTER)) { over.addTemplate(stp.getImportedPage(readerHF, 1), dmargin[0], 0); } readerHF.close(); } } stp.close(); } try { out2.flush(); } catch (Exception ignore) { } finally { try { out2.close(); } catch (Exception ignore) { } } if (signed) { final String keypassword = (String) properties.get(IHtmlToPdfTransformer.PDF_SIGNING_PRIVATE_KEY_PASSWORD); final String password = (String) properties.get(IHtmlToPdfTransformer.PDF_ENCRYPTION",
        "ground_truth": "YES",
        "predict": "_PASSWORD); final int securityType = CDocumentReconstructor.getSecurityFlags(properties); final PdfReader reader = new PdfReader(tmp2.getAbsolutePath()); final PdfStamper stp = new PdfStamper(reader, out); stp.setEncryption(PdfWriter.STRENGTH128BITS, keypassword, password, securityType); stp.close(); } } catch (Exception e) { throw new CConvertException(e); } }\n"
    },
    {
        "ID": 1421,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Photo createPhoto(String title, String userLogin, String pathToPhoto, String basePathImage) throws NoSuchAlgorithmException, IOException { String id = CryptSHA1.genPhotoID(userLogin, title); String extension = pathToPhoto.substring(pathToPhoto.lastIndexOf(\".\")); String destination = basePathImage + id + extension; FileInputStream fis = new FileInputStream(pathToPhoto); FileOutputStream fos = new FileOutputStream(destination); FileChannel fci = fis.getChannel(); FileChannel fco = fos.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) { int read = fci.read(buffer); if (read == -1) break; buffer.flip(); fco.write(buffer); buffer.clear(); } fci.close(); fco.close(); fos.close(); fis.close(); ImageIcon image; ImageIcon thumb; String destinationThumb = basePathImage + \"thumb/\" + id + extension; image = new ImageIcon(destination); int maxSize = 150; int origWidth = image.getIconWidth(); int origHeight = image.getIconHeight(); if (origWidth > origHeight) { thumb = new ImageIcon(image.getImage().getScaledInstance(maxSize, -1, Image.SCALE_SMOOTH)); } else { thumb = new ImageIcon(image.getImage().getScaledInstance(-1, maxSize, Image.SCALE_SMOOTH)); } BufferedImage bi = new BufferedImage(thumb.getIconWidth(), thumb.getIconHeight(), BufferedImage.TYPE_INT_RGB); Graphics g = bi.getGraphics(); g.drawImage(thumb.getImage(), 0, 0, null); try { ImageIO.write(bi, \"JPG\", new File(destinationThumb)); } catch (IOException ioe) { System.out.println(\"Error occured saving thumbnail\"); } Photo photo = new Photo(id); photo.setTitle(title); photo.basePathImage = basePathImage; return photo; }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected Document getRawResults(String urlString, Map args) throws Exception { int count = 0; Iterator keys = args.keySet().iterator(); while (keys.hasNext()) { String sep = count++ == 0 ? \"?\" : \"&\"; String name = (String) keys.next(); if (args.get(name) != null) { urlString += sep + name + \"=\" + args.get(name); } } URL url = new URL(urlString); URLConnection conn = url.openConnection(); conn.connect(); SAXBuilder",
        "ground_truth": "NO",
        "predict": " builder = new SAXBuilder(); Document doc = builder.build(conn.getInputStream()); return doc; }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains"
    },
    {
        "ID": 1422,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @HttpAction(name = \"map.saveOrUpdate\", method = { HttpAction.Method.post }, responseType = \"text/plain\") @HttpAuthentication(method = { HttpAuthentication.Method.WSSE }) public String saveOrUpdate(FileItem file, User user, MapOriginal map) throws HttpRpcException { File tmpFile; GenericDAO<MapOriginal> mapDao = DAOFactory.createDAO(MapOriginal.class); try { assert (file != null); String jobid = null; if (file.getContentType().startsWith(\"image/\")) { tmpFile = File.createTempFile(\"gmap\", \"img\"); OutputStream out = new FileOutputStream(tmpFile); IOUtils.copy(file.getInputStream(), out); out.flush(); out.close(); map.setState(MapOriginal.MapState.UPLOAD); map.setUser(user); map.setMapPath(tmpFile.getPath()); map.setThumbnailUrl(\"/map/inproc.gif\"); map.setMimeType(file.getContentType()); mapDao.saveOrUpdate(map); jobid = PoolFactory.getClientPool().put(map, TaskState.STATE_MO_FINISH, MapOverrideStrategy.class); } return jobid; } catch (IOException e) { logger.error(e); throw ERROR_INTERNAL; } catch (DAOException e) { logger.error(e); throw ERROR_INTERNAL; } }. \n Code2: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { sMessageID = oMsg.getHeader(\"X-Qmail-Scanner-Message-ID\", null); } catch (Exception ignore) { } } if (sMessageID != null) sMessageID = MimeUtility.decodeText(sMessageID); sContentType = oMsg.getContentType(); if (sContentType != null) sContentType = MimeUtility.decodeText(sContentType); sContentID = oMsg.getContentID(); if (sContentID != null) sContentID = MimeUtility.decodeText(sContentID); sDisposition = oMsg.getDisposition(); if (sDisposition != null) sDisposition = MimeUtility.decodeText(sDisposition); sContentMD5 = oMsg.getContentMD5(); if (sContentMD5 != null) sContentMD5 = MimeUtility.decodeText(sContentMD5); sDescription = oMsg.getDescription(); if (sDescription != null) sDescription = MimeUtility.decodeText(sDescription); sFileName = oMsg.getFileName(); if (sFileName != null) sFileName = MimeUtility.decodeText(sFileName); sEncoding = oMsg.getEncoding(); if (sEncoding != null) sEncoding = MimeUtility.decodeText(sEncoding); sSubject = oMsg.getSubject(); if (sSubject != null) sSubject = MimeUtility.decodeText(sSubject); sPriority = null; sMsgCharSeq = null; } catch (UnsupportedEncodingException uee) { throw new MessagingException(uee.getMessage(), uee); } BigDecimal dPgMessage = null; try { dPgMessage = getNextMessage(); } catch (SQLException sqle) { throw new MessagingException(sqle.getMessage(), sqle); } String sBoundary = getPartsBoundary(oMsg); if (DebugFile.trace) DebugFile.writeln(\"part boundary is \\\"\" + (sBoundary == null ? \"null\" : sBoundary) + \"\\\"\"); if (sMessageID == null) sMessageID = gu_mimemsg; else if (sMessageID.length() == 0) sMessageID = gu_mimemsg; Timestamp tsSent; if (oMsg.getSentDate() != null) tsSent = new Timestamp(oMsg.getSentDate().getTime()); else tsSent = null; Timestamp tsReceived; if (oMsg.getReceivedDate() != null) tsReceived = new Timestamp(oMsg.getReceivedDate().getTime()); else tsReceived = new Timestamp(new java.util.Date().getTime()); try { String sXPriority = oMsg.getHeader(\"X-Priority\", null); if (sXPriority == null) sPriority = null; else { sPriority = \"\"; for (int x = 0; x < sXPriority.length(); x++) { char cAt = sXPriority.charAt(x); if (cAt >= (char) 48 || cAt <= (char) 57) sPriority += c",
        "ground_truth": "YES",
        "predict": "At; } } } catch (Exception ignore) { } try { String sXMsgCharSeq = oMsg.getHeader(\"X-MsgCharSeq\", null); if (sXMsgCharSeq == null) sMsgCharSeq = null; else { sMsgCharSeq = \"\"; for (int x = 0; x < sXMsgCharSeq.length(); x++) { char cAt = sXMsgCharSeq.charAt(x); if (cAt >= (char) 48 || cAt <= (char) 57) sMsgCharSeq += cAt; } } } catch (Exception ignore) { } } catch (MessagingException me) { throw new MessagingException(me.getMessage(), me); } catch (Exception e) { throw new MessagingException(e.getMessage(), e); } }\n"
    },
    {
        "ID": 1431,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void saveDownloadFiles(List downloadFiles) throws SQLException { Connection conn = AppLayerDatabase.getInstance().getPooledConnection(); try { conn.setAutoCommit(false); Statement s = conn.createStatement(); s.executeUpdate(\"DELETE FROM DOWNLOADFILES\"); s.close(); s = null; PreparedStatement ps = conn.prepareStatement(\"INSERT INTO DOWNLOADFILES \" + \"(name,targetpath,size,fnkey,enabled,state,downloadaddedtime,downloadstartedtime,downloadfinishedtime,\" + \"retries,lastdownloadstoptime,gqid,filelistfilesha) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)\"); for (Iterator i = downloadFiles.iterator(); i.hasNext(); ) { FrostDownloadItem dlItem = (FrostDownloadItem) i.next(); int ix = 1; ps.setString(ix++, dlItem.getFilename()); ps.setString(ix++, dlItem.getTargetPath()); ps.setLong(ix++, (dlItem.getFileSize() == null ? 0 : dlItem.getFileSize().longValue())); ps.setString(ix++, dlItem.getKey()); ps.setBoolean(ix++, (dlItem.isEnabled() == null ? true : dlItem.isEnabled().booleanValue())); ps.setInt(ix++, dlItem.getState()); ps.setLong(ix++, dlItem.getDownloadAddedTime()); ps.setLong(ix++, dlItem.getDownloadStartedTime()); ps.setLong(ix++, dlItem.getDownloadFinishedTime()); ps.setInt(ix++, dlItem.getRetries()); ps.setLong(ix++, dlItem.getLastDownloadStopTime()); ps.setString(ix++, dlItem.getGqIdentifier()); ps.setString(ix++, dlItem.getFileListFileObject() == null ? null : dlItem.getFileListFileObject().getSha()); ps.executeUpdate(); } ps.close(); conn.commit(); conn.setAutoCommit(true); } catch (Throwable t) { logger.log(Level.SEVERE, \"Exception during save\", t); try { conn.rollback(); } catch (Throwable t1) { logger.log(Level.SEVERE, \"Exception during rollback\", t1); } try { conn.setAutoCommit(true); } catch (Throwable t1) { } } finally { AppLayerDatabase.getInstance().givePooledConnection(conn); } }. \n Code2: public static void copyResourceFileTo(String destFileName, String resourceFileName) { if (destFileName == null || resourceFileName == null) throw new IllegalArgumentException(\"Argument cannot be null.\"); try { FileInputStream in = null; FileOutputStream out = null; URL url = HelperMethods.class.getResource(resourceFileName); if (url == null) { System.out.println(\"URL \" + resourceFileName + \" cannot be created.\"); return; } String fileName = url.getFile(); fileName = fileName.replaceAll(\"%20\", \" \"); File resourceFile = new File(fileName); if (!resourceFile.isFile()) { System.out.println(fileName + \" cannot be opened.\"); return; } in = new FileInputStream(resourceFile); out = new FileOutputStream(new File(destFileName)); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } catch (IOException ex) { ex.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected String readUrl(String svnUrl) throws IOException { URL url = new URL(svnUrl); URLConnection uc = url.openConnection(); if (url.getProtocol().equals(\"https\")) { String userPassword = user + \":\" + password; String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes()); uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding); } InputStream is = null; String in = null; try { is = uc.getInputStream(); in = read(is); } finally { try { is.close(); } catch (Exception e) { } } return in; }. \n Code2: public void getHttpURL() throws Exception { boolean display = true; boolean allHeaders = false; String url = null; url = \"http://localhost/cubigraf2\"; url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\"; url = \"http://www.uni.pt/img/home-direito.gif\"; url = \"http://www.google.com\"; URLConnection uc = new URL(url).openConnection(); println(\"HEADERS:\"); if (allHeaders) { Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator(); while (itHeaders.hasNext()) { Map.Entry<String, List<String>> e = itHeaders.next(); Iterator<?> itValues = e.getValue().iterator(); while (itValues.hasNext()) { println(e.getKey() + \": \" + itValues.next()); } } } else { showObjectProperty(uc, \"getContentEncoding\"); showObjectProperty(uc, \"getContentLength\"); showObjectProperty(uc, \"getContentType\"); showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP); showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP); showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP); } ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString()); if (display) { println(\"BODY:\"); ExtendedReader reader = new ExtendedReader(in); for (String s = reader.readLine(); s != null; s = reader.readLine()) { println(s); } } else { println(\"(BODY saved to a file)\"); String contentType = uc.getContentType(); StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\"); filename.append(\".\"); filename.append(contentType.substring(contentType.indexOf(\"/\") + 1)); File file = new File(filename.toString()); ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.",
        "ground_truth": "NO",
        "predict": "getName()); for (String s = reader.readLine(); s != null; s = reader.readLine()) { out.write(s.getBytes()); } out.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void saveDownloadFiles(List downloadFiles) throws SQLException { Connection conn = AppLayerDatabase.getInstance().getPooledConnection(); try { conn.setAutoCommit(false); Statement s = conn.createStatement(); s.executeUpdate(\"DELETE FROM DOWNLOADFILES\"); s.close(); s = null; PreparedStatement ps = conn.prepareStatement(\"INSERT INTO DOWNLOADFILES \" + \"(name,targetpath,size,fnkey,enabled,state,downloadaddedtime,downloadstartedtime,downloadfinishedtime,\" + \"retries,lastdownloadstoptime,gqid,filelistfilesha) VALUES"
    },
    {
        "ID": 1435,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static Map<String, File> loadServiceCache() { ArrayList<String> preferredOrder = new ArrayList<String>(); HashMap<String, File> serviceFileMapping = new HashMap<String, File>(); File file = new File(IsqlToolkit.getBaseDirectory(), CACHE_FILE); if (!file.exists()) { return serviceFileMapping; } if (file.canRead()) { FileReader fileReader = null; try { fileReader = new FileReader(file); BufferedReader lineReader = new BufferedReader(fileReader); while (lineReader.ready()) { String data = lineReader.readLine(); if (data.charAt(0) == '#') { continue; } int idx0 = 0; int idx1 = data.indexOf(SERVICE_FIELD_SEPERATOR); String name = StringUtilities.decodeASCII(data.substring(idx0, idx1)); String uri = StringUtilities.decodeASCII(data.substring(idx1 + 1)); if (name.equalsIgnoreCase(KEY_SERVICE_LIST)) { StringTokenizer st = new StringTokenizer(uri, SERVICE_SEPERATOR); while (st.hasMoreTokens()) { String serviceName = st.nextToken(); preferredOrder.add(serviceName.toLowerCase().trim()); } continue; } try { URL url = new URL(uri); File serviceFile = new File(url.getFile()); if (serviceFile.isDirectory()) { logger.warn(messages.format(\"compatability_kit.service_mapped_to_directory\", name, uri)); continue; } else if (!serviceFile.canRead()) { logger.warn(messages.format(\"compatability_kit.service_not_readable\", name, uri)); continue; } else if (!serviceFile.exists()) { logger.warn(messages.format(\"compatability_kit.service_does_not_exist\", name, uri)); continue; } String bindName = name.toLowerCase().trim(); InputStream inputStream = null; try { inputStream = url.openStream(); InputSource inputSource = new InputSource(inputStream); bindName = ServiceDigester.parseService(inputSource, IsqlToolkit.getSharedEntityResolver()).getName(); } catch (Exception error) { continue; } if (serviceFileMapping.put(bindName, serviceFile) != null) { logger.warn(messages.format(\"compatability_kit.service_duplicate_name_error\", name, uri)); } } catch (MalformedURLException e) { logger.error(messages.format(\"compatability_kit.service_uri_error\", name, uri), e); } } } catch (IOException ioe) { logger.error(\"compatability_kit.service_generic_error\", ioe); } finally { if (fileReader != null) { try { fileReader.close(); } catch (Throwable ignored) { } } } } return serviceFileMapping; }. \n Code2: protected PersistenceUnitInfo getPersistenceUnitInfo() { if (this.persistenceUnitInfo == null) { this.persistenceUnitInfo = new PersistenceUnitInfo() { private List<ClassTransformer> transformers; private List<String> managedClasses; private List<String> mappingFileNames; private ClassLoader classLoader; public String getPersistenceUnitName() { return \"jomc-standalone\"; } public String getPersistenceProviderClassName() { return getPersistenceProvider().getClass().getName(); } public PersistenceUnitTransactionType getTransactionType() { return PersistenceUnitTransactionType.JTA; } public DataSource getJtaDataSource() { try { return (DataSource) getContext().lookup(getEnvironment().getJtaDataSourceJndiName()); } catch (final NamingException e) { getLogger().fatal(e); throw new RuntimeException(e); } } public DataSource getNonJtaDataSource() { return null; } public List<String> getMappingFileNames() { try { if (this.mappingFileNames == null) { this.mappingFileNames = new LinkedList<String>(); final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); factory.setValidating(false); final DocumentBuilder documentBuilder = factory.newDocumentBuilder(); for (final Enumeration<URL> e = this.getNewTempClassLoader().getResources(\"META-INF/persistence.xml\"); e.hasMoreElements(); ) { final URL url = e.nextElement(); final InputStream in = url.openStream(); final Document doc = documentBuilder.parse(in); in.close(); final NodeList persistenceUnits = doc.getElementsByTagNameNS(PERSISTENCE_NS, \"persistence-unit\"); for (int i = persistenceUnits.getLength() - 1; i >= 0; i--) { final Element persistenceUnit = (Element) persistenceUnits.item(i); final NodeList mappingFiles = persistenceUnit.getElementsByTagNameNS(PERSISTENCE_NS, \"mapping-file\"); for (int j = mappingFiles.getLength() - 1; j >= 0; j--) { final Element mappingFile = (Element) mappingFiles.item(j); this.mappingFileNames.add(mappingFile.getFirstChild().getNodeValue()); } } } } return this.mappingFileNames; } catch (final SAXException e) { getLogger().fatal(e); throw new RuntimeException(e); } catch (final IOException e) { getLogger().fatal(e); throw new RuntimeException(e); } catch (final ParserConfigurationException e) { getLogger().fatal(e); throw new RuntimeException(e); } } public List<URL> getJarFileUrls() { try { final List<URL> jarFileUrls = new LinkedList<URL>(); for (final Enumeration<URL> unitUrls = this.getClassLoader().getResources(\"META-INF/persistence.xml\"); unitUrls.hasMoreElements(); ) { final URL unitUrl = unitUrls.nextElement(); final String externalForm = unitUrl.toExternalForm(); final String jarUrl = externalForm.substring(0, externalForm.indexOf(\"META-INF\")); jarFileUrls.add(new URL(jarUrl)); } return jarFileUrls; } catch (final IOException e) { getLogger().fatal(e); throw new RuntimeException(e.getMessage(), e); } } public URL getPersistenceUnitRootUrl() { return getEnvironment().getJpaRootUrl(); } public List<String> getManagedClassNames() { try { if (this.managedClasses == null) { this.managedClasses = new LinkedList<String>(); final DocumentBuilder",
        "ground_truth": "NO",
        "predict": "Factory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); factory.setValidating(false); final DocumentBuilder documentBuilder = factory.newDocumentBuilder(); for (final Enumeration<URL> e = this.getNewTempClassLoader().getResources(\"META-INF/persistence.xml\"); e.hasMoreElements(); ) { final URL url = e.nextElement(); final InputStream in = url.openStream(); final Document doc = documentBuilder.parse(in); in.close(); final NodeList persistenceUnits = doc.getElementsByTagNameNS(PERSISTENCE_NS, \"persistence-unit\"); for (int i = persistenceUnits.getLength() - 1; i >= 0; i--) { final Element persistenceUnit = (Element) persistenceUnits.item(i); final NodeList managedClasses = persistenceUnit.getElementsByTagNameNS(PERSISTENCE_NS, \"class\"); for (int"
    },
    {
        "ID": 1437,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run(Preprocessor pp) throws SijappException { for (int i = 0; i < this.filenames.length; i++) { File srcFile = new File(this.srcDir, this.filenames[i]); BufferedReader reader; try { InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile), \"CP1251\"); reader = new BufferedReader(isr); } catch (Exception e) { throw (new SijappException(\"File \" + srcFile.getPath() + \" could not be read\")); } File destFile = new File(this.destDir, this.filenames[i]); BufferedWriter writer; try { (new File(destFile.getParent())).mkdirs(); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile), \"CP1251\"); writer = new BufferedWriter(osw); } catch (Exception e) { throw (new SijappException(\"File \" + destFile.getPath() + \" could not be written\")); } try { pp.run(reader, writer); } catch (SijappException e) { try { reader.close(); } catch (IOException f) { } try { writer.close(); } catch (IOException f) { } try { destFile.delete(); } catch (SecurityException f) { } throw (new SijappException(srcFile.getPath() + \":\" + e.getMessage())); } try { reader.close(); } catch (IOException e) { } try { writer.close(); } catch (IOException e) { } } }. \n Code2: protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String realUrl = \"http:/\" + request.getPathInfo(); if (request.getQueryString() != null) { realUrl += \"?\" + request.getQueryString(); } URL url = new URL(realUrl); URLConnection connection = url.openConnection(); HttpURLConnection http = null; if (connection instanceof HttpURLConnection) { http = (HttpURLConnection) connection; http.setRequestMethod(request.getMethod()); } boolean hasContent = false; Enumeration headers = request.getHeaderNames(); while (headers.hasMoreElements()) { String header = (String) headers.nextElement(); if (\"content-type\".equals(header.toLowerCase())) hasContent = true; Enumeration values = request.getHeaders(header); while (values.hasMoreElements()) { String value = (String) values.nextElement(); if (value != null) { connection.addRequestProperty(header, value); } } } try { connection.setDoInput(true); if (hasContent) { InputStream proxyRequest = request.getInputStream(); connection.setDoOutput(true); IO.copy(proxyRequest, connection.getOutputStream()); } connection.connect(); } catch (Exception e) { context.log(\"proxy\", e); } InputStream proxyResponse = null; int code = 500; if (http != null) { proxyResponse = http.getErrorStream(); code = http.getResponseCode(); response.setStatus(code); } if (proxyResponse == null) { try { proxyResponse = connection.getInputStream(); } catch (Exception e) { if (http != null) proxyResponse = http.getErrorStream(); context.log(\"stream\", e); } } int i = 0; String header = connection.getHeaderFieldKey(i); String value = connection.getHeaderField(i); while (header != null || value != null) { if (header != null && value != null) { response.addHeader(header, value); } ++i; header = connection.getHeaderFieldKey(i); value = connection.getHeaderField(i); } if (proxyResponse != null) { IO.copy(proxyResponse, response.getOutputStream()); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void actionPerformed(ActionEvent e) { if (\"register\".equals(e.getActionCommand())) { buttonClicked = \"register\"; try { String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\"); URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\"); URLConnection conn = url.openConnection(); conn.setDoInput(true); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = rd.readLine()) != null) { } rd.close(); wr.close(); } catch (Exception ex) { } setVisible(false); } else if (\"cancel\".equals(e.getActionCommand())) { buttonClicked = \"cancel\"; setVisible(false); } else if (\"never\".equals(e.getActionCommand())) { buttonClicked = \"never\"; setVisible(false); } }. \n Code2: public static String getMessageDigest(String[] inputs) { if (inputs.length == 0) return null; try { MessageDigest sha = MessageDigest.getInstance(\"SHA-1\"); for (String input : inputs) sha.update(input.getBytes()); byte[] hash = sha.digest(); String CPass = \"\"; int h = 0; String s = \"\"; for (int i = 0; i < 20;",
        "ground_truth": "NO",
        "predict": " i++) { h = (h << 4) + hash[i]; s += Integer.toString(h, 16); } return s; } catch (NoSuchAlgorithmException e) { return null; } }. \n Code3: public static int getAnswers() { return answers; }. \n Code4: public static void setAnswers(int value) { answers = value; }. \n Code5: public static String getButtonClicked() { return buttonClicked; }. \n Code6: public static void setButtonClicked(String value) { buttonClicked = value; }. \n Code7: public static String getName() { return name.getText(); }. \n Code8: public static void setName(String value) { name.setText(value); }. \n Code9: public static String getEmail() { return email.getText(); }. \n Code10: public static void setEmail(String value) { email.setText"
    },
    {
        "ID": 1444,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getClass(EmeraldjbBean eb) throws EmeraldjbException { Entity entity = (Entity) eb; StringBuffer sb = new StringBuffer(); String myPackage = getPackageName(eb); sb.append(\"package \" + myPackage + \";\\n\"); sb.append(\"\\n\"); DaoValuesGenerator valgen = new DaoValuesGenerator(); String values_class_name = valgen.getClassName(entity); sb.append(\"\\n\"); List importList = new Vector(); importList.add(\"java.io.*;\"); importList.add(\"java.sql.Date;\"); importList.add(\"com.emeraldjb.runtime.patternXmlObj.*;\"); importList.add(\"javax.xml.parsers.*;\"); importList.add(\"java.text.ParseException;\"); importList.add(\"org.xml.sax.*;\"); importList.add(\"org.xml.sax.helpers.*;\"); importList.add(valgen.getPackageName(eb) + \".\" + values_class_name + \";\"); Iterator it = importList.iterator(); while (it.hasNext()) { String importName = (String) it.next(); sb.append(\"import \" + importName + \"\\n\"); } sb.append(\"\\n\"); String proto_version = entity.getPatternValue(GeneratorConst.PATTERN_STREAM_PROTO_VERSION, \"1\"); boolean short_version = entity.getPatternBooleanValue(GeneratorConst.PATTERN_STREAM_XML_SHORT, false); StringBuffer preface = new StringBuffer(); StringBuffer consts = new StringBuffer(); StringBuffer f_writer = new StringBuffer(); StringBuffer f_writer_short = new StringBuffer(); StringBuffer f_reader = new StringBuffer(); StringBuffer end_elems = new StringBuffer(); boolean end_elem_needs_catch = false; consts.append(\"\\n public static final String EL_CLASS_TAG=\\\"\" + values_class_name + \"\\\";\"); preface.append(\"\\n xos.print(\\\"<!-- This format is optimised for space, below are the column mappings\\\");\"); boolean has_times = false; boolean has_strings = false; it = entity.getMembers().iterator(); int col_num = 0; while (it.hasNext()) { col_num++; Member member = (Member) it.next(); String nm = member.getName(); preface.append(\"\\n xos.print(\\\"c\" + col_num + \" = \" + nm + \"\\\");\"); String elem_name = nm; String elem_name_short = \"c\" + col_num; String el_name = nm.toUpperCase(); if (member.getColLen() > 0 || !member.isNullAllowed()) { end_elem_needs_catch = true; } String element_const = \"EL_\" + el_name; String element_const_short = \"EL_\" + el_name + \"_SHORT\"; consts.append(\"\\n public static final String \" + element_const + \"=\\\"\" + elem_name + \"\\\";\" + \"\\n public static final String \" + element_const_short + \"=\\\"\" + elem_name_short + \"\\\";\"); String getter = \"obj.\" + methodGenerator.getMethodName(DaoGeneratorUtils.METHOD_GET, member); String setter = \"values_.\" + methodGenerator.getMethodName(DaoGeneratorUtils.METHOD_SET, member); String pad = \" \"; JTypeBase gen_type = EmdFactory.getJTypeFactory().getJavaType(member.getType()); f_writer.append(gen_type.getToXmlCode(pad, element_const, getter + \"()\")); f_writer_short.append(gen_type.getToXmlCode(pad, element_const_short, getter + \"()\")); end_elems.append(gen_type.getFromXmlCode(pad, element_const, setter)); end_elems.append(\"\\n //and also the short version\"); end_elems.append(gen_type.getFromXmlCode(pad, element_const_short, setter)); } preface.append(\"\\n xos.print(\\\"-->\\\");\"); String body_part = f_writer.toString(); String body_part_short = preface.toString() + f_writer_short.toString(); String reader_vars = \"\"; String streamer_class_name = getClassName(entity); sb.append(\"public class \" + streamer_class_name + \" extends DefaultHandler implements TSParser\\n\"); sb.append(\"{\" + consts + \"\\n public static final int PROTO_VERSION=\" + proto_version + \";\" + \"\\n private transient StringBuffer cdata_=new StringBuffer();\" + \"\\n private transient String endElement_;\" + \"\\n private transient TSParser parentParser_;\" + \"\\n private transient XMLReader theReader_;\\n\" + \"\\n private \" + values_class_name + \" values_;\"); sb.append(\"\\n\\n\"); sb.append(\"\\n /**\" + \"\\n * This is really only here as an example. It is very rare to write a single\" + \"\\n * object to a file - far more likely to have a collection or object graph. \" + \"\\n * in which case you can write something similar - maybe using the writeXmlShort\" + \"\\n * version instread.\" + \"\\n */\" + \"\\n public static void writeToFile(String file_nm, \" + values_class_name + \" obj) throws IOException\" + \"\\n {\" + \"\\n if (file_nm==null || file_nm.length()==0) throw new IOException(\\\"Bad file name (null or zero length)\\\");\" + \"\\n if (obj==null) throw new IOException(\\\"Bad value object parameter, cannot write null object to file\\\");\" + \"\\n FileOutputStream fos = new FileOutputStream(file_nm);\" + \"\\n XmlOutputFilter xos = new XmlOutputFilter(fos);\" + \"\\n xos.openElement(\\\"FILE_\\\"+EL_CLASS_TAG);\" + \"\\n writeXml(xos, obj);\" + \"\\n xos.closeElement();\" + \"\\n fos.close();\" + \"\\n } // end of writeToFile\" + \"\\n\" + \"\\n public static void readFromFile(String file_nm, \" + values_class_name + \" obj) throws IOException, SAXException\" + \"\\n {\" + \"\\n if (file_nm==null || file_nm.length()==0) throw new IOException(\\\"Bad file name (null or zero length)\\\");\" + \"\\n if (obj==null) throw new",
        "ground_truth": "NO",
        "predict": " IOException(\\\"Bad value object parameter, cannot write null object to file\\\");\" + \"\\n FileInputStream fis = new FileInputStream(file_nm);\" + \"\\n XmlInputFilter xis = new XmlInputFilter(fis);\" + \"\\n xis.openElement(\\\"FILE_\\\"+EL_CLASS_TAG);\" + \"\\n readXml(xis, obj);\" + \"\\n xis.closeElement();\" + \"\\n fis.close();\" + \"\\n } // end of readFromFile\" + \"\\n\" + \"\\n public static void writeXml(XmlOutputFilter xos, \" + values_class_name + \" obj) throws IOException\" + \"\\n {\" + \"\\n xos.openElement(EL_CLASS_TAG);\" + \"\\n xos.openElement(\\\"COLUMNS\\\");\" + \"\\n xos.openElement(\\\"COLUMN\\\");\" + \"\\n xos.open"
    },
    {
        "ID": 1450,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { DES des = new DES(); StreamBlockReader reader = new StreamBlockReader(new FileInputStream(\"D:\\\\test.txt\")); StreamBlockWriter writer = new StreamBlockWriter(new FileOutputStream(\"D:\\\\test1.txt\")); SingleKey key = new SingleKey(new Block(64), \"\"); key = new SingleKey(new Block(\"1111111100000000111111110000000011111111000000001111111100000000\"), \"\"); Mode mode = new ECBDESMode(des); des.encrypt(reader, writer, key, mode); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: private String getResultFromHttpUrl(String href) { String result = null; try { URL url = new URL(href); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); Object o = conn.getContent(); log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName",
        "ground_truth": "NO",
        "predict": "()); if (o instanceof String) { result = (String) o; } else if (o instanceof InputStream) { result = IOUtils.toString((InputStream) o); } else if (o instanceof byte[]) { result = new String((byte[]) o); } else { result = o.toString(); } } catch (Exception e) { log.error(\"Error getting content from \" + href, e); } return result; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { String[] urls = { \"http://localhost:8080/dicom/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/dicomweb/d"
    },
    {
        "ID": 1465,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { try { String req1xml = jTextArea1.getText(); java.net.URL url = new java.net.URL(\"http://217.34.8.235:8080/newgenlibctxt/PatronServlet\"); java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection(); urlconn.setDoOutput(true); urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\"); java.io.OutputStream os = urlconn.getOutputStream(); java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32()); java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos); java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\"); System.out.println(req1xml); try { java.io.FileOutputStream pw = new java.io.FileOutputStream(\"C:/log.txt\"); pw.write(req1xml.getBytes()); pw.flush(); pw.close(); } catch (Exception exp) { exp.printStackTrace(); } dos.write(req1xml); dos.flush(); dos.close(); System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \" \" + urlconn.getContentType()); java.io.InputStream ios = urlconn.getInputStream(); java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32()); java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis); java.io.BufferedReader br = new java.io.BufferedReader(new java.io.InputStreamReader(gip)); String reqxml = \"\"; while (br.ready()) { String line = br.readLine(); reqxml += line; } try { java.io.FileOutputStream pw = new java.io.FileOutputStream(\"C:/log3.txt\"); pw.write(reqxml.getBytes()); pw.flush(); pw.close(); } catch (Exception exp) { exp.printStackTrace(); } } catch (Exception exp) { exp.printStackTrace(); } }. \n Code2: public String postDownloadRequest(String localFile) throws Exception { String responseString = \"\"; String requestString = \"\"; if (localFile == null) { error = true; errorStr = errorStr.concat(\"No local target for: \" + currentFile.getRelativePath() + \"\\n\"); return \"\"; } try { for (java.util.Iterator i = parameters.entrySet().iterator(); i.hasNext(); ) { java.util.Map.Entry e = (java.util.Map.Entry) i.next(); requestString = requestString + URLEncoder.encode((String) e.getKey(), \"UTF-8\") + \"=\" + URLEncoder.encode((String) e.getValue(), \"UTF-8\") + \"&\"; } URL url = new URL(urlString); URLConnection connection = url.openConnection(); HttpURLConnection httpConn = (HttpURLConnection) connection; httpConn.setRequestProperty(\"Content-Length\", String.valueOf(requestString.length())); httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpConn.setRequestMethod(\"POST\"); httpConn.setDoOutput(true); httpConn.setDoInput(true); connection.connect(); PrintWriter out = new PrintWriter(httpConn.getOutputStream()); out.println(requestString); out.close(); if (httpConn.HTTP_NOT_FOUND == httpConn.getResponseCode()) { error = true; errorStr = errorStr.concat(\"Cannot find file: \" + currentFile.getRelativePath() + \"\\n\"); return responseString; } String localFileName = new String(localFile); File f = new File(localFileName); File dir = new File(f.getParent()); dir.mkdirs(); FileOutputStream fis = new FileOutputStream(f); try { InputStream is = httpConn.getInputStream(); java.util.zip.GZIPInputStream gin = new java.util.zip.GZIPInputStream(new BufferedInputStream(is)); int temp; while ((temp = gin.read()) != -1) { fis.write(temp); } if (fis.getChannel().size() > 0) { fis.getChannel().truncate(fis.getChannel().size() - 1); } responseString = downloadDir + \"/\" + currentFile.getRelativePath(); is.close(); fis.close(); httpConn.disconnect(); } catch (IOException io) { error = true; errorStr = errorStr.concat(\"Cannot find file: \" + currentFile.getRelativePath() + \"\\n\"); return responseString; } } catch (java.net.ConnectException conne) { error = true; finished = true; errorStr = \"Cannot connect to: \" + urlString; } catch (java.io.InterruptedIOException e) { error = true; finished = true; errorStr = \"Connection to Portal lost: communication is timeouted.\"; parentWorkflow.getMenuButtonEventHandler().stopAutomaticRefresh(); } catch (java.net.MalformedURLException e) { error = true; finished = true; errorStr = \"Error in postDownloadRequest()\"; } catch (Exception e) { e.printStackTrace(); error = true; finished = true; errorStr = \"Error in Download: \" + e.getMessage(); } return responseString; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); conn.setRequestProperty(\"Connection\", \"close\"); if (userPassword != null) { conn.setRequestProperty(\"Authorization\", \"Basic \" +",
        "ground_truth": "NO",
        "predict": " new String(Base64.encodeBase64(userPassword.getBytes()))); } conn.connect(); String response = \"\"; if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) { response = IOUtils.toString(conn.getInputStream()); } else { throw new WiseConnectionException(\"Error in transferWSDL()\"); } } catch (IOException e) { throw new WiseConnectionException(\"Error in transferWSDL()\"); } return response; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) { try { String req1xml = jTextArea1.getText(); java.net.URL url = new java.net.URL(\"http://217.34.8.235:8080/newgenlibctxt/Patron"
    },
    {
        "ID": 1466,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActionForward dbExecute(ActionMapping pMapping, ActionForm pForm, HttpServletRequest pRequest, HttpServletResponse pResponse) throws DatabaseException { Integer key; SubmitUserForm form = (SubmitUserForm) pForm; if (pRequest.getParameter(\"key\") == null) { key = form.getPrimaryKey(); } else { key = Integer.parseInt(pRequest.getParameter(\"key\")); } User currentUser = (User) (pRequest.getSession().getAttribute(\"login\")); if ((currentUser == null) || (!currentUser.getAdminRights() && (currentUser.getPrimaryKey() != key))) { return (pMapping.findForward(\"denied\")); } if (currentUser.getAdminRights()) { pRequest.setAttribute(\"isAdmin\", new Boolean(true)); } if (currentUser.getPDFRights()) { pRequest.setAttribute(\"pdfRights\", Boolean.TRUE); } User user = database.acquireUserByPrimaryKey(key); if (user.isSuperAdmin() && !currentUser.isSuperAdmin()) { return (pMapping.findForward(\"denied\")); } pRequest.setAttribute(\"user\", user); pRequest.setAttribute(\"taxonomy\", database.acquireTaxonomy()); if (form.getAction().equals(\"none\")) { form.setPrimaryKey(user.getPrimaryKey()); } if (form.getAction().equals(\"edit\")) { FormError formError = form.validateFields(); if (formError != null) { if (formError.getFormFieldErrors().get(\"firstName\") != null) { pRequest.setAttribute(\"FirstNameBad\", new Boolean(true)); } if (formError.getFormFieldErrors().get(\"lastName\") != null) { pRequest.setAttribute(\"LastNameBad\", new Boolean(true)); } if (formError.getFormFieldErrors().get(\"emailAddress\") != null) { pRequest.setAttribute(\"EmailAddressBad\", new Boolean(true)); } if (formError.getFormFieldErrors().get(\"mismatchPassword\") != null) { pRequest.setAttribute(\"mismatchPassword\", new Boolean(true)); } if (formError.getFormFieldErrors().get(\"shortPassword\") != null) { pRequest.setAttribute(\"shortPassword\", new Boolean(true)); } return (pMapping.findForward(\"invalid\")); } user.setFirstName(form.getFirstName()); user.setLastName(form.getLastName()); user.setEmailAddress(form.getEmailAddress()); if (!form.getFirstPassword().equals(\"\")) { MessageDigest md; try { md = MessageDigest.getInstance(\"SHA\"); } catch (NoSuchAlgorithmException e) { throw new DatabaseException(\"Could not hash password for storage: no such algorithm\"); } try { md.update(form.getFirstPassword().getBytes(\"UTF-8\")); } catch (UnsupportedEncodingException e) { throw new DatabaseException(\"Could not hash password for storage: no such encoding\"); } user.setPassword((new BASE64Encoder()).encode(md.digest())); } user.setTitle(form.getTitle()); user.setDegree(form.getDegree()); user.setAddress(form.getAddress()); user.setNationality(form.getNationality()); user.setLanguages(form.getLanguages()); user.setHomepage(form.getHomepage()); user.setInstitution(form.getInstitution()); if (pRequest.getParameter(\"hideEmail\") != null) { if (pRequest.getParameter(\"hideEmail\").equals(\"on\")) { user.setHideEmail(true); } } else { user.setHideEmail(false); } User storedUser = database.acquireUserByPrimaryKey(user.getPrimaryKey()); if (currentUser.isSuperAdmin()) { if (pRequest.getParameter(\"admin\") != null) { user.setAdminRights(true); } else { if (!storedUser.isSuperAdmin()) { user.setAdminRights(false); } } } else { user.setAdminRights(storedUser.getAdminRights()); } if (currentUser.isAdmin()) if (pRequest.getParameter(\"PDFRights\") != null) user.setPDFRights(true); else user.setPDFRights(false); if (currentUser.isAdmin()) { if (!storedUser.isAdmin() || !storedUser.isSuperAdmin()) { if (pRequest.getParameter(\"active\") != null) { user.setActive(true); } else { user.setActive(false); } } else { user.setActive(storedUser.getActive()); } } if (currentUser.isAdmin() || currentUser.isSuperAdmin()) { String[] categories = pRequest.getParameterValues(\"categories\"); user.setModeratorRights(new Categories()); if (categories != null) { try { for (int i = 0; i < categories.length; i++) { Integer catkey = Integer.parseInt(categories[i]); Category cat = database.acquireCategoryByPrimaryKey(catkey); user.getModeratorRights().add(cat); } } catch (NumberFormatException nfe) { throw new DatabaseException(\"Invalid category key.\"); } } } if (!currentUser.isAdmin() && !currentUser.isSuperAdmin()) { user.setAdminRights(false); user.setSuperAdminRights(false); } database.updateUser(user); if (currentUser.getPrimaryKey() == user.getPrimaryKey()) { pRequest.getSession().setAttribute(\"login\", user); } pRequest.setAttribute(\"helpKey\", key); if (currentUser.isAdmin() || currentUser.isSuperAdmin()) { return (pMapping.findForward(\"adminfinished\")); } return (pMapping.findForward(\"finished\")); } return (pMapping.findForward(\"success\")); }. \n Code2: private static MappedObject sendHttpRequestToUrl(URL url, String method) throws Exception { try { HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(method); connection.connect(); InputStream is = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); StringBuilder buffer = new StringBuilder(); String line = null; while ((line = reader.readLine()) != null) { buffer.append(line); } System.out.println(\"Read: \" + buffer.toString()); connection.disconnect(); JAXBContext context = JAXBContext.newInstance(MappedObject.class); Unmarshaller unmarshaller = context.createUnmarshaller(); MappedObject mapped = (MappedObject) unmarshaller.unmarshal(new StringReader(buffer.toString())); return mapped; } catch (IOException e) { e.printStack",
        "ground_truth": "NO",
        "predict": "Trace(); } }\n\n}\n"
    },
    {
        "ID": 1467,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void onMessage(Message message) { LOG.debug(\"onMessage\"); DownloadMessage downloadMessage; try { downloadMessage = new DownloadMessage(message); } catch (JMSException e) { LOG.error(\"JMS error: \" + e.getMessage(), e); return; } String caName = downloadMessage.getCaName(); boolean update = downloadMessage.isUpdate(); LOG.debug(\"issuer: \" + caName); CertificateAuthorityEntity certificateAuthority = this.certificateAuthorityDAO.findCertificateAuthority(caName); if (null == certificateAuthority) { LOG.error(\"unknown certificate authority: \" + caName); return; } if (!update && Status.PROCESSING != certificateAuthority.getStatus()) { LOG.debug(\"CA status not marked for processing\"); return; } String crlUrl = certificateAuthority.getCrlUrl(); if (null == crlUrl) { LOG.warn(\"No CRL url for CA \" + certificateAuthority.getName()); certificateAuthority.setStatus(Status.NONE); return; } NetworkConfig networkConfig = this.configurationDAO.getNetworkConfig(); HttpClient httpClient = new HttpClient(); if (null != networkConfig) { httpClient.getHostConfiguration().setProxy(networkConfig.getProxyHost(), networkConfig.getProxyPort()); } HttpClientParams httpClientParams = httpClient.getParams(); httpClientParams.setParameter(\"http.socket.timeout\", new Integer(1000 * 20)); LOG.debug(\"downloading CRL from: \" + crlUrl); GetMethod getMethod = new GetMethod(crlUrl); getMethod.addRequestHeader(\"User-Agent\", \"jTrust CRL Client\"); int statusCode; try { statusCode = httpClient.executeMethod(getMethod); } catch (Exception e) { downloadFailed(caName, crlUrl); throw new RuntimeException(); } if (HttpURLConnection.HTTP_OK != statusCode) { LOG.debug(\"HTTP status code: \" + statusCode); downloadFailed(caName, crlUrl); throw new RuntimeException(); } String crlFilePath; File crlFile = null; try { crlFile = File.createTempFile(\"crl-\", \".der\"); InputStream crlInputStream = getMethod.getResponseBodyAsStream(); OutputStream crlOutputStream = new FileOutputStream(crlFile); IOUtils.copy(crlInputStream, crlOutputStream); IOUtils.closeQuietly(crlInputStream); IOUtils.closeQuietly(crlOutputStream); crlFilePath = crlFile.getAbsolutePath(); LOG.debug(\"temp CRL file: \" + crlFilePath); } catch (IOException e) { downloadFailed(caName, crlUrl); if (null != crlFile) { crlFile.delete(); } throw new RuntimeException(e); } try { this.notificationService.notifyHarvester(caName, crlFilePath, update); } catch (JMSException e) { crlFile.delete(); throw new RuntimeException(e); } }. \n Code2: public void save() { final JFileChooser fc = new JFileChooser(); fc.setFileFilter(new FileFilter() { public String getDescription() { return \"PDF File\"; } public boolean accept(File f) { return f.isDirectory() || f.getName().toLowerCase().endsWith(\".pdf\"); } }); if (fc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) { return; } File targetFile = fc.getSelectedFile(); if (!targetFile.getName().toLowerCase().endsWith(\".pdf\")) { targetFile = new File(targetFile.getParentFile(), targetFile.getName() + \".pdf\"); } if (targetFile.exists()) { if (JOptionPane.showConfirmDialog(this, \"Do you want to overwrite the file?\") != JOptionPane.YES_OPTION) { return; } } try { final InputStream is = new FileInputStream(filename); try { final OutputStream os = new FileOutputStream(targetFile); try { final byte[] buffer = new byte[32768]; for (int read; (read = is.read(buffer)) != -1; ) { os.write(buffer, 0, read); } } finally { os.close(); } } finally { is.close(); } } catch (IOException e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Vector parse(String link) { addMessage(\"Parsing: \" + link); links.removeAllElements(); URLConnection conn = null; Reader rd = null; EditorKit kit = new HTMLEditorKit(); Document doc = kit.createDefaultDocument(); doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE); URL url = null; try { url = new URL(link); } catch (MalformedURLException err) { System.out.println(\"Malformed URL\"); return links; } try { conn = new URL(link).openConnection(); rd = new InputStreamReader(conn.getInputStream()); } catch (Exception err) { err.printStackTrace(); return links; } try { kit.read(rd, doc, 0); ElementIterator it = new ElementIterator(doc); javax.swing.text.Element elem; while ((elem = it.next()) != null) { SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A); if (s != null) { if (s.toString().indexOf(\"script\") >= 0) continue; String lnk = \"\"; try { lnk = s.getAttribute(HTML.Attribute.HREF).toString(); } catch (Exception err) { continue; } int j = 0; if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j); URL urlLink = new URL(url, lnk); if (!url.getHost().equals(urlLink.getHost())) continue; String str = urlLink.toString(); if (!str.startsWith(\"http\")) continue; if (str.endsWith(\".pdf\")) { continue; } for (int i = 0; i < leaveSuffix.length; i++) { if ((str.endsWith(leaveSuffix[i]))) continue; } boolean skip = false; for (int i = 0; i < suffix.length; i++) { if ((str.endsWith(suffix[i]))) skip = true; } if (!skip) { try { conn = urlLink.openConnection(); } catch (Exception err) { } String contentType = null; if (contentType ==",
        "ground_truth": "NO",
        "predict": " null) { contentType = conn.getContentType(); } if (contentType != null) { if (contentType.indexOf(\"pdf\") >= 0) { links.addElement(urlLink); } } } } } catch (Exception err) { } } } catch (Exception err) { } } }. \n */"
    },
    {
        "ID": 1470,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void createResource(String resourceUri, boolean publish, User user) throws IOException { PermissionAPI perAPI = APILocator.getPermissionAPI(); Logger.debug(this.getClass(), \"createResource\"); resourceUri = stripMapping(resourceUri); String hostName = getHostname(resourceUri); String path = getPath(resourceUri); String folderName = getFolderName(path); String fileName = getFileName(path); fileName = deleteSpecialCharacter(fileName); if (fileName.startsWith(\".\")) { return; } Host host = HostFactory.getHostByHostName(hostName); Folder folder = FolderFactory.getFolderByPath(folderName, host); boolean hasPermission = perAPI.doesUserHavePermission(folder, PERMISSION_WRITE, user, false); if (hasPermission) { if (!checkFolderFilter(folder, fileName)) { throw new IOException(\"The file doesn't comply the folder's filter\"); } if (host.getInode() != 0 && folder.getInode() != 0) { File file = new File(); file.setTitle(fileName); file.setFileName(fileName); file.setShowOnMenu(false); file.setLive(publish); file.setWorking(true); file.setDeleted(false); file.setLocked(false); file.setModDate(new Date()); String mimeType = FileFactory.getMimeType(fileName); file.setMimeType(mimeType); String author = user.getFullName(); file.setAuthor(author); file.setModUser(author); file.setSortOrder(0); file.setShowOnMenu(false); try { Identifier identifier = null; if (!isResource(resourceUri)) { WebAssetFactory.createAsset(file, user.getUserId(), folder, publish); identifier = IdentifierCache.getIdentifierFromIdentifierCache(file); } else { File actualFile = FileFactory.getFileByURI(path, host, false); identifier = IdentifierCache.getIdentifierFromIdentifierCache(actualFile); WebAssetFactory.createAsset(file, user.getUserId(), folder, identifier, false, false); WebAssetFactory.publishAsset(file); String assetsPath = FileFactory.getRealAssetsRootPath(); new java.io.File(assetsPath).mkdir(); java.io.File workingIOFile = FileFactory.getAssetIOFile(file); DotResourceCache vc = CacheLocator.getVeloctyResourceCache(); vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingIOFile.getPath()); if (file != null && file.getInode() > 0) { byte[] currentData = new byte[0]; FileInputStream is = new FileInputStream(workingIOFile); int size = is.available(); currentData = new byte[size]; is.read(currentData); java.io.File newVersionFile = FileFactory.getAssetIOFile(file); vc.remove(ResourceManager.RESOURCE_TEMPLATE + newVersionFile.getPath()); FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel(); ByteBuffer currentDataBuffer = ByteBuffer.allocate(currentData.length); currentDataBuffer.put(currentData); currentDataBuffer.position(0); channelTo.write(currentDataBuffer); channelTo.force(false); channelTo.close(); } java.util.List<Tree> parentTrees = TreeFactory.getTreesByChild(file); for (Tree tree : parentTrees) { Tree newTree = TreeFactory.getTree(tree.getParent(), file.getInode()); if (newTree.getChild() == 0) { newTree.setParent(tree.getParent()); newTree.setChild(file.getInode()); newTree.setRelationType(tree.getRelationType()); newTree.setTreeOrder(0); TreeFactory.saveTree(newTree); } } } List<Permission> permissions = perAPI.getPermissions(folder); for (Permission permission : permissions) { Permission filePermission = new Permission(); filePermission.setPermission(permission.getPermission()); filePermission.setRoleId(permission.getRoleId()); filePermission.setInode(identifier.getInode()); perAPI.save(filePermission); } } catch (Exception ex) { Logger.debug(this, ex.toString()); } } } else { throw new IOException(\"You don't have access to add that folder/host\"); } }. \n Code2: private File tmpFileFromURL(String name) { if (name == null) { System.out.println(\"ERROR: the provided URL is invalid, aborting download!\"); return null; } try { final URL url = new URL(name); final InputStream in = url.openStream(); final URLConnection conn = url.openConnection(); final int total = conn.getContentLength(); final String contentType = conn.getContentType(); logger.fine(\"DOWNLOADING Content-type: \" + contentType); if (contentType.trim().toLowerCase().indexOf(\"html\") != -1) { return tmpFileFromURL(extractRedirectURL(in)); } final FileManager fileManager = system.getFileManager(); final File dest = fileManager.createTmpModuleFile(); final FileOutputStream out = new FileOutputStream(dest); final byte[] buf = new byte[2048]; logger.fine(\"Total number of bytes to download: \" + total); int len, current = 0; progress(new ProgressEvent(this, \"Downloading \" + name, 0)); while ((len = in.read(buf)) > 0) { current += len; progress(new ProgressEvent(this, \"Downloading \" + name, (int) ((current * 100.0) / total))); out.write(buf, 0, len); out.flush(); } in.close(); out.flush(); out.close(); return dest; } catch (IOException ex) { progress(new ProgressEvent(\" ERROR: downloading of \" + name + \" failed. URL does not exist!\")); return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected String getRequestContent(String urlText) throws Exception { URL url = new URL(urlText); HttpURLConnection urlcon = (HttpURLConnection) url.openConnection(); urlcon.connect(); BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream())); String line = reader.readLine(); reader.close(); urlcon.disconnect(); return line; }. \n Code2: private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception { String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath(); log.println",
        "ground_truth": "NO",
        "predict": "(\"Compressing \" + inputFiles.size() + \" files to \" + outputFile); FileManager fileManager = system.getFileManager(); File f = fileManager.getFileByURI(outputFile); if (f != null) { if (f.isArchived()) { f.unarchive(); } } else { f = fileManager.createFile(outputFile, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\","
    },
    {
        "ID": 1477,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void setupService(MessageContext msgContext) throws Exception { String realpath = msgContext.getStrProp(Constants.MC_REALPATH); String extension = (String) getOption(OPTION_JWS_FILE_EXTENSION); if (extension == null) extension = DEFAULT_JWS_FILE_EXTENSION; if ((realpath != null) && (realpath.endsWith(extension))) { String jwsFile = realpath; String rel = msgContext.getStrProp(Constants.MC_RELATIVE_PATH); File f2 = new File(jwsFile); if (!f2.exists()) { throw new FileNotFoundException(rel); } if (rel.charAt(0) == '/') { rel = rel.substring(1); } int lastSlash = rel.lastIndexOf('/'); String dir = null; if (lastSlash > 0) { dir = rel.substring(0, lastSlash); } String file = rel.substring(lastSlash + 1); String outdir = msgContext.getStrProp(Constants.MC_JWS_CLASSDIR); if (outdir == null) outdir = \".\"; if (dir != null) { outdir = outdir + File.separator + dir; } File outDirectory = new File(outdir); if (!outDirectory.exists()) { outDirectory.mkdirs(); } if (log.isDebugEnabled()) log.debug(\"jwsFile: \" + jwsFile); String jFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"java\"; String cFile = outdir + File.separator + file.substring(0, file.length() - extension.length() + 1) + \"class\"; if (log.isDebugEnabled()) { log.debug(\"jFile: \" + jFile); log.debug(\"cFile: \" + cFile); log.debug(\"outdir: \" + outdir); } File f1 = new File(cFile); String clsName = null; if (clsName == null) clsName = f2.getName(); if (clsName != null && clsName.charAt(0) == '/') clsName = clsName.substring(1); clsName = clsName.substring(0, clsName.length() - extension.length()); clsName = clsName.replace('/', '.'); if (log.isDebugEnabled()) log.debug(\"ClsName: \" + clsName); if (!f1.exists() || f2.lastModified() > f1.lastModified()) { log.debug(Messages.getMessage(\"compiling00\", jwsFile)); log.debug(Messages.getMessage(\"copy00\", jwsFile, jFile)); FileReader fr = new FileReader(jwsFile); FileWriter fw = new FileWriter(jFile); char[] buf = new char[4096]; int rc; while ((rc = fr.read(buf, 0, 4095)) >= 0) fw.write(buf, 0, rc); fw.close(); fr.close(); log.debug(\"javac \" + jFile); Compiler compiler = CompilerFactory.getCompiler(); compiler.setClasspath(ClasspathUtils.getDefaultClasspath(msgContext)); compiler.setDestination(outdir); compiler.addFile(jFile); boolean result = compiler.compile(); (new File(jFile)).delete(); if (!result) { (new File(cFile)).delete(); Document doc = XMLUtils.newDocument(); Element root = doc.createElementNS(\"\", \"Errors\"); StringBuffer message = new StringBuffer(\"Error compiling \"); message.append(jFile); message.append(\":\\n\"); List errors = compiler.getErrors(); int count = errors.size(); for (int i = 0; i < count; i++) { CompilerError error = (CompilerError) errors.get(i); if (i > 0) message.append(\"\\n\"); message.append(\"Line \"); message.append(error.getStartLine()); message.append(\", column \"); message.append(error.getStartColumn()); message.append(\": \"); message.append(error.getMessage()); } root.appendChild(doc.createTextNode(message.toString())); throw new AxisFault(\"Server.compileError\", Messages.getMessage(\"badCompile00\", jFile), null, new Element[] { root }); } ClassUtils.removeClassLoader(clsName); soapServices.remove(clsName); } ClassLoader cl = ClassUtils.getClassLoader(clsName); if (cl == null) { cl = new JWSClassLoader(clsName, msgContext.getClassLoader(), cFile); } msgContext.setClassLoader(cl); SOAPService rpc = (SOAPService) soapServices.get(clsName); if (rpc == null) { rpc = new SOAPService(new RPCProvider()); rpc.setName(clsName); rpc.setOption(RPCProvider.OPTION_CLASSNAME, clsName); rpc.setEngine(msgContext.getAxisEngine()); String allowed = (String) getOption(RPCProvider.OPTION_ALLOWEDMETHODS); if (allowed == null) allowed = \"*\"; rpc.setOption(RPCProvider.OPTION_ALLOWEDMETHODS, allowed); String scope = (String) getOption(RPCProvider.OPTION_SCOPE); if (scope == null) scope = Scope.DEFAULT.getName(); rpc.setOption(RPCProvider.OPTION_SCOPE, scope); rpc.getInitializedServiceDesc(msgContext); soapServices.put(clsName, rpc); } rpc.setEngine(msgContext.getAxisEngine()); rpc.init(); msgContext.setService(rpc); } if (log.isDebugEnabled()) { log.debug(\"Exit: JWSHandler::invoke\"); } }. \n Code2: public static String SHA1(String text) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); md.update(text.getBytes()); byte byteData[] = md.digest(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < byteData.length; i++) { sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1)); } StringBuilder hexString = new StringBuilder(); for (int i = 0; i < byteData.length; i++) { String hex = Integer.toHexString(0xff & byteData[i]); if (hex.length() == 1) hexString.append('0'); hexString.append(hex); } return hexString.toString",
        "ground_truth": "NO",
        "predict": "(); }\n}\n"
    },
    {
        "ID": 1481,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String readTemplateToString(String fileName) { URL url = null; url = classLoader.getResource(fileName); StringBuffer content = new StringBuffer(); if (url == null) { String error = \"Template file could not be found: \" + fileName; throw new RuntimeException(error); } try { BufferedReader breader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); String strLine = \"\"; while ((strLine = breader.readLine()) != null) { content.append(strLine).append(\"\\n\"); } breader.close(); } catch (Exception e) { throw new RuntimeException(\"Problem while loading file: \" + fileName); } return content.toString(); }. \n Code2: @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.listview); HttpGet request = new HttpGet(SERVICE_URI + \"/json/getroutes/1\"); request.setHeader(\"Accept\", \"application/json\"); request.setHeader(\"Content-type\", \"application/json\"); DefaultHttpClient httpClient = new DefaultHttpClient(); String theString = new String(\"\"); try { HttpResponse response = httpClient.execute(request); HttpEntity responseEntity = response.getEntity(); InputStream stream = responseEntity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(stream)); Vector<String> vectorOfStrings = new Vector<String>(); String tempString = new String(); String tempStringAgent = new String(); String tempStringClient = new String(); String tempStringRoute = new String(); String tempStringZone = new String(); StringBuilder builder = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { builder.append(line); } stream.close(); theString = builder.toString(); JSONObject json = new JSONObject(theString); Log.i(\"_GetClient_\", \"<jsonobject>\\n\" + json.toString() + \"\\n</jsonobject>\"); this.dm = new DataManipulator(this); JSONArray nameArray = json.getJSONArray(\"GetRoutesByAgentResult\"); for (int i = 0; i < nameArray.length(); i++) { tempStringAgent = nameArray.getJSONObject(i).getString(\"Agent\"); tempStringClient = nameArray.getJSONObject(i).getString(\"Client\"); tempStringRoute = nameArray.getJSONObject(i).getString(\"Route\"); tempStringZone = nameArray.getJSONObject(i).getString(\"Zone\"); Log.i(\"_GetClient_\", \"<Agent\" + i + \">\" + tempStringAgent + \"</Agent\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Client\" + i + \">\" + tempStringClient + \"</Client\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Route\" + i + \">\" + tempStringRoute + \"</Route\" + i + \">\\n\"); Log.i(\"_GetClient_\", \"<Zone\" + i + \">\" + tempStringZone + \"</Zone\" + i + \">\\n\"); tempString = nameArray.getJSONObject(i).getString(\"Client\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Route\") + \"\\n\" + nameArray.getJSONObject(i).getString(\"Zone\"); vectorOfStrings.add(new String(tempString)); } int orderCount = vectorOfStrings.size(); String[] orderTimeStamps = new String[orderCount]; vectorOfStrings.copyInto(orderTimeStamps); setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, orderTimeStamps)); } catch (Exception e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(String from_name, String to_name) throws IOException { File from_file = new File(from_name); File to_file = new File(to_name); if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name); if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name); if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name); if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName()); if (to_file.exists()) { if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name); } else { String parent = to_file.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent); if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent); if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent); } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(from_file); to = new FileOutputStream(to_file); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } } finally { if (from != null) { try { from.close(); } catch (IOException e) { e.printStackTrace(); } } if (to != null) { try { to.close(); } catch (IOException e) { e.printStackTrace(); } } } }. \n Code2: public static void main(String[] argv) { if (1 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).getChannel(); try { source.transferTo(0L, srclen, target); } finally { target.close(); } System.out.printf(\"Updated %s\\n\", tgt.getPath()); File[] deletes = Delete(src, tgt); if (null != deletes) { for (File del : deletes) { if (SVN) { if (SvnDelete(del)) System",
        "ground_truth": "YES",
        "predict": ".out.printf(\"Deleted %s\\n\", del.getPath()); } else { del.delete(); } } } } catch (IOException e) { e.printStackTrace(); } } } catch (IOException e) { e.printStackTrace(); } } } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(String from_name, String to_name) throws IOException { File from_file = new File(from_name); File to_file = new File(to_name); if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name); if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name); if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from"
    },
    {
        "ID": 1484,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { Option optHelp = new Option(\"h\", \"help\", false, \"print this message\"); Option optCerts = new Option(\"c\", \"cert\", true, \"use external semicolon separated X.509 certificate files\"); optCerts.setArgName(\"certificates\"); Option optPasswd = new Option(\"p\", \"password\", true, \"set password for opening PDF\"); optPasswd.setArgName(\"password\"); Option optExtract = new Option(\"e\", \"extract\", true, \"extract signed PDF revisions to given folder\"); optExtract.setArgName(\"folder\"); Option optListKs = new Option(\"lk\", \"list-keystore-types\", false, \"list keystore types provided by java\"); Option optListCert = new Option(\"lc\", \"list-certificates\", false, \"list certificate aliases in a KeyStore\"); Option optKsType = new Option(\"kt\", \"keystore-type\", true, \"use keystore type with given name\"); optKsType.setArgName(\"keystore_type\"); Option optKsFile = new Option(\"kf\", \"keystore-file\", true, \"use given keystore file\"); optKsFile.setArgName(\"file\"); Option optKsPass = new Option(\"kp\", \"keystore-password\", true, \"password for keystore file (look on -kf option)\"); optKsPass.setArgName(\"password\"); Option optFailFast = new Option(\"ff\", \"fail-fast\", true, \"flag which sets the Verifier to exit with error code on the first validation failure\"); final Options options = new Options(); options.addOption(optHelp); options.addOption(optCerts); options.addOption(optPasswd); options.addOption(optExtract); options.addOption(optListKs); options.addOption(optListCert); options.addOption(optKsType); options.addOption(optKsFile); options.addOption(optKsPass); options.addOption(optFailFast); CommandLine line = null; try { CommandLineParser parser = new PosixParser(); line = parser.parse(options, args); } catch (ParseException exp) { System.err.println(\"Illegal command used: \" + exp.getMessage()); System.exit(-1); } final boolean failFast = line.hasOption(\"ff\"); final String[] tmpArgs = line.getArgs(); if (line.hasOption(\"h\") || args == null || args.length == 0) { HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(70, \"java -jar Verifier.jar [file1.pdf [file2.pdf ...]]\", \"JSignPdf Verifier is a command line tool for verifying signed PDF documents.\", options, null, true); } else if (line.hasOption(\"lk\")) { for (String tmpKsType : KeyStoreUtils.getKeyStores()) { System.out.println(tmpKsType); } } else if (line.hasOption(\"lc\")) { for (String tmpCert : KeyStoreUtils.getCertAliases(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\"))) { System.out.println(tmpCert); } } else { final VerifierLogic tmpLogic = new VerifierLogic(line.getOptionValue(\"kt\"), line.getOptionValue(\"kf\"), line.getOptionValue(\"kp\")); tmpLogic.setFailFast(failFast); if (line.hasOption(\"c\")) { String tmpCertFiles = line.getOptionValue(\"c\"); for (String tmpCFile : tmpCertFiles.split(\";\")) { tmpLogic.addX509CertFile(tmpCFile); } } byte[] tmpPasswd = null; if (line.hasOption(\"p\")) { tmpPasswd = line.getOptionValue(\"p\").getBytes(); } String tmpExtractDir = null; if (line.hasOption(\"e\")) { tmpExtractDir = new File(line.getOptionValue(\"e\")).getPath(); } for (String tmpFilePath : tmpArgs) { System.out.println(\"Verifying \" + tmpFilePath); final File tmpFile = new File(tmpFilePath); if (!tmpFile.canRead()) { System.err.println(\"Couln't read the file. Check the path and permissions.\"); if (failFast) { System.exit(-1); } continue; } final VerificationResult tmpResult = tmpLogic.verify(tmpFilePath, tmpPasswd); if (tmpResult.getException() != null) { tmpResult.getException().printStackTrace(); System.exit(-1); } else { System.out.println(\"Total revisions: \" + tmpResult.getTotalRevisions()); for (SignatureVerification tmpSigVer : tmpResult.getVerifications()) { System.out.println(tmpSigVer.toString()); if (tmpExtractDir != null) { try { File tmpExFile = new File(tmpExtractDir + \"/\" + tmpFile.getName() + \"_\" + tmpSigVer.getRevision() + \".pdf\"); System.out.println(\"Extracting to \" + tmpExFile.getCanonicalPath()); FileOutputStream tmpFOS = new FileOutputStream(tmpExFile.getCanonicalPath()); InputStream tmpIS = tmpLogic.extractRevision(tmpFilePath, tmpPasswd, tmpSigVer.getName()); IOUtils.copy(tmpIS, tmpFOS); tmpIS.close(); tmpFOS.close(); } catch (IOException ioe) { ioe.printStackTrace(); } } } if (failFast && SignatureVerification.isError(tmpResult.getVerificationResultCode())) { System.exit(tmpResult.getVerificationResultCode()); } } } } }. \n Code2: public void unzip(String zipFileName, String outputDirectory) throws Exception { ZipInputStream in = new ZipInputStream(new FileInputStream(zipFileName)); ZipEntry z; while ((z = in.getNextEntry()) != null) { System.out.println(\"unziping \" + z.getName()); if (z.isDirectory()) { String name = z.getName(); name = name.substring(0, name.length() - 1); File f = new File(outputDirectory + File.separator + name); f.mkdir(); System.out.println(\"mkdir \" + outputDirectory + File.separator + name); } else { File f = new File(outputDirectory + File.separator + z.getName()); f.createNewFile(); FileOutputStream out = new FileOutputStream(f); int b; while ((b = in.read()) != -1) out.write(b); out.close(); } } in.close(); }. \n Response: YES. \n Instruction: Is there a colne relation",
        "ground_truth": "YES",
        "predict": " between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { Option optHelp = new Option(\"h\", \"help\", false, \"print this message\"); Option optCerts = new Option(\"c\", \"cert\", true, \"use external semicolon separated X.509 certificate files\"); optCerts.setArgName(\"certificates\"); Option optPasswd = new Option(\"p\", \"password\", true, \"set password for opening PDF\"); optPasswd.setArgName(\"password\"); Option optExtract = new Option(\"e\", \"extract\", true, \"extract signed PDF revisions to given folder\"); optExtract.setArgName(\"folder\"); Option optListKs = new Option(\"lk\", \"list-keystore-types\", false, \"list keystore types provided by java\"); Option optListCert = new Option(\"lc\", \"list-certificates\", false, \"list certificate aliases in a KeyStore\"); Option opt"
    },
    {
        "ID": 1486,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { long timeout = 10 * 1000L; long start = (new Date()).getTime(); try { InputStream is = socket.getInputStream(); boolean available = false; while (!available && !socket.isClosed()) { try { if (is.available() != 0) { available = true; } else { Thread.sleep(100); } } catch (Exception e) { LOG.error(\"Error checking socket\", e); } long curr = (new Date()).getTime(); if ((curr - start) >= timeout) { break; } } if (socket.isClosed()) { } else { tmpFile = File.createTempFile(\"ftp\", \"dat\", new File(\"./tmp\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(tmpFile)); IOUtils.copy(is, bos); bos.flush(); bos.close(); } String msg = FtpResponse.ReadComplete.asString() + ClientCommand.SP + \"Read Complete\" + ClientCommand.CRLF; List<String> list = new ArrayList<String>(); list.add(msg); ClientResponse response = new ClientResponse(list); ftpClient.notifyListeners(response); } catch (Exception e) { LOG.error(\"Error reading server response\", e); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean getContent(String userId, String latestMsgId) { try { String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId; URL url = new URL(targetUrl); InputStream in = url.openStream(); ArrayList<MessageObj> list; if (in != null) { MessageListDOMParser parser = new MessageListDOMParser(); list = (ArrayList<MessageObj>) parser.parseXML(in); TransactionDAO dao = new TransactionDAO(); dao.insert(list); } return true; } catch (Exception e) { e.printStackTrace(); return false; } }. \n Code2: public void setImg() { JFileChooser jFileChooser1 = new JFileChooser(); String separator = \"\"; if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) { setPath(jFileChooser1.getSelectedFile().getPath()); separator = jFileChooser1.getSelectedFile().separator; File dirImg = new File(\".\" + separator + \"images\"); if (!dirImg.exists()) { dirImg.mkdir();",
        "ground_truth": "NO",
        "predict": " } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean getContent(String userId, String latestMsgId) { try { String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId; URL url = new URL(targetUrl); InputStream in = url.openStream(); ArrayList<MessageObj> list; if (in != null) { MessageListDOMParser parser = new MessageListDOMParser(); list = (ArrayList<MessageObj>) parser.parseXML(in); TransactionDAO dao = new TransactionDAO(); dao.insert(list); } return true; } catch (Exception e) { e.printStackTrace(); return false; } }. \n Code2: public void setImg() { JFileCho"
    },
    {
        "ID": 1502,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static boolean predictDataSet(String completePath, String Type, String predictionOutputFileName, String slopeOneDataFolderName) { try { if (Type.equalsIgnoreCase(\"Qualifying\")) { File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"CompleteQualifyingDataInByteFormat.txt\"); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); TShortObjectHashMap qualMap = new TShortObjectHashMap(17770, 1); ByteBuffer qualmappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); while (qualmappedfile.hasRemaining()) { short movie = qualmappedfile.getShort(); int customer = qualmappedfile.getInt(); if (qualMap.containsKey(movie)) { TIntArrayList arr = (TIntArrayList) qualMap.get(movie); arr.add(customer); qualMap.put(movie, arr); } else { TIntArrayList arr = new TIntArrayList(); arr.add(customer); qualMap.put(movie, arr); } } System.out.println(\"Populated qualifying hashmap\"); File outFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + predictionOutputFileName); FileChannel outC = new FileOutputStream(outFile).getChannel(); ByteBuffer buf; TShortObjectHashMap movieDiffStats; double finalPrediction; short[] movies = qualMap.keys(); Arrays.sort(movies); for (int i = 0; i < movies.length; i++) { short movieToProcess = movies[i]; movieDiffStats = loadMovieDiffStats(completePath, movieToProcess, slopeOneDataFolderName); System.out.println(movieDiffStats.size()); TIntArrayList customersToProcess = (TIntArrayList) qualMap.get(movieToProcess); for (int j = 0; j < customersToProcess.size(); j++) { int customerToProcess = customersToProcess.getQuick(j); finalPrediction = predictSlopeOneRating(customerToProcess, movieDiffStats); if (finalPrediction == finalPrediction) { if (finalPrediction < 1.0) finalPrediction = 1.0; else if (finalPrediction > 5.0) finalPrediction = 5.0; } else finalPrediction = GetAveragePrediction(movieToProcess); buf = ByteBuffer.allocate(10); buf.putShort(movieToProcess); buf.putInt(customerToProcess); buf.putFloat(new Double(finalPrediction).floatValue()); buf.flip(); outC.write(buf); } } outC.close(); return true; } else if (",
        "ground_truth": "YES",
        "predict": "Type.equalsIgnoreCase(\"Training\")) { File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"CompleteTrainingDataInByteFormat.txt\"); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); TShortObjectHashMap trainMap = new TShortObjectHashMap(17770, 1); ByteBuffer trainmappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); while (trainmappedfile.hasRemaining()) { short movie = trainmappedfile.getShort(); int customer = trainmappedfile.getInt(); if (trainMap.containsKey(movie)) { TIntArrayList arr = (TIntArrayList) trainMap.get(movie); arr.add(customer); trainMap.put(movie, arr); } else { TIntArrayList arr = new TIntArrayList(); arr"
    },
    {
        "ID": 1510,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static AudioFileFormat getAudioFileFormat(URL url) throws UnsupportedAudioFileException, IOException { InputStream inputStream = null; if (useragent != null) { URLConnection myCon = url.openConnection(); myCon.setUseCaches(false); myCon.setDoInput(true); myCon.setDoOutput(true); myCon.setAllowUserInteraction(false); myCon.setRequestProperty(\"User-Agent\", useragent); myCon.setRequestProperty(\"Accept\", \"*/*\"); myCon.setRequestProperty(\"Icy-Metadata\", \"1\"); myCon.setRequestProperty(\"Connection\", \"close\"); inputStream = new BufferedInputStream(myCon.getInputStream()); } else { inputStream = new BufferedInputStream(url.openStream()); } try { if (DEBUG == true) { System.err.println(\"Using AppletMpegSPIWorkaround to get codec (AudioFileFormat:url)\"); } return getAudioFileFormatForUrl(inputStream); } finally { inputStream.close(); } }. \n Code2: private PluginInfo loadPluginInfo(URL filename) throws PluginNotFoundException { if (filename == null) return null; BufferedReader in = null; InputStream is = null; String mainClass = null; String u = filename.toString(); PluginInfo pi = new PluginInfo(); URL url; try { url = new URL(\"jar:\" + u + \"!/\"); } catch (MalformedURLException mue) { throw new PluginNotFoundException(mue); } pi.setURL(filename); HashMap names = new HashMap(); boolean seemsOK = false; for (int tries = 0; (tries <= 5) && (!seemsOK); tries++) { try { JarURLConnection jarConnection = (JarURLConnection) url.openConnection(); jarConnection.setUseCaches(false); JarFile jf = jarConnection.getJarFile(); is = jf.getInputStream(jf.getJarEntry(\"META-INF/MANIFEST.MF\")); in = new BufferedReader(new InputStreamReader(is)); String line; while ((line = in.readLine()) != null) { if (line.startsWith(\"Frostplugin-Main-Class: \")) { mainClass = line.substring(\"Frostplugin-Main-Class: \".length()).trim(); pi.setMainClass(mainClass); logger.log(Level.SEVERE, \"Found plugin main class \" + mainClass + \" from manifest\"); } } is = jf.getInputStream(jf.getJarEntry(\"pluginname.properties\")); in = new BufferedReader(new InputStreamReader(is)); while ((line = in.readLine()) != null) { if (line.startsWith(\"#\")) { continue; } if (line.length() == 0) { continue; } String[] sa = line.split(\"=\", 2); names.put(sa[0], sa[1]); pi.setPluginNames(names); } seemsOK = true; } catch (Exception e) { if (tries >= 5) throw new PluginNotFoundException(\"Initialization error:\" + filename, e); try { Thread.sleep(100); } catch (Exception ee) { } } finally { try { if (is != null) is.close(); if (in != null) in.close(); } catch (IOException ioe) { } } } return pi; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String checksum(URL url, String algorithm) { MessageDigest messageDigest; try { messageDigest = MessageDigest.getInstance(algorithm); } catch (Exception ex) { throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex); } byte[] bytes = new byte[4 * 1024]; try { InputStream in = null; try { in = url.openStream(); int nBytesRead = 0; while ((nBytesRead = in.read(bytes)) > 0) { messageDigest.update(bytes, 0, nBytesRead); } } finally { if (in != null) { in.close(); } } } catch (Exception e) { throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm); } byte[] checksumValue = messageDigest.digest(); return digestAsString(checksumValue); }. \n Code2: private void parse() throws Exception { BufferedReader br = null; InputStream httpStream = null; URL fileURL = new URL(url); URLConnection urlConnection = fileURL.openConnection(); httpStream = urlConnection.getInputStream(); br = new BufferedReader(new InputStreamReader(httpStream, \"UTF-8\")); String ligne; String post; String date; String titre; String resume; String url2DL; while ((ligne = br.readLine()) != null) { if (ligne.indexOf(\"div class=\\\"post\\\" id=\\\"post\") != -1) { post = null; date = null; titre = null; try { post = ligne.substring(ligne.indexOf(\"post-\") + 5, ligne.indexOf(\"\\\"\", ligne.indexOf(\"post-\"))); ligne = br.readLine(); date = ligne.substring(ligne.indexOf(\"<div class=\\\"date\\\"><span>\") + 24); date = date.replaceAll(\"</span>\", \"\").replaceAll(\"</div>\", \"\").trim(); log.info(\"Post : \" + post + \" du \" + date); ligne = br.readLine(); ligne = br.readLine(); titre = ligne.substring(ligne.indexOf(\">\", ligne.indexOf(\"title\")) + 1, ligne.indexOf(\"</a>\")); titre = titre.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\"); url2DL = ligne.substring(ligne.indexOf(\"<a href=\\\"\") + 9, ligne.indexOf(\"/\\\"\")).trim(); url2DL = url2DL.replace(\"mega-films.net\", \"mega-protect.com\") + \".php\"; log.info(\"Titre : \" + titre); log.info(\"To DL : \" + url2DL); ligne = br.readLine(); ligne = br.readLine(); ligne = br.readLine(); ligne = br.readLine(); ligne = br.readLine(); ligne = br.readLine(); ligne = br.readLine(); resume = ligne.substring(ligne.indexOf(\"<em>\") + 4, ligne.indexOf(\"</em>\")); resume = resume.replaceAll(\"&#8217;\", \"'\").replaceAll(\"&",
        "ground_truth": "NO",
        "predict": "#8220;\", \"\\\"\").replaceAll(\"&#8221;\", \"\\\"\"); } catch (Exception e) { throw new Exception(\"Erreur lors de la lecture du fichier\", e); } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String digestAsString(byte[] digest) { StringBuffer sb = new StringBuffer(); for (int i = 0; i < digest.length; i++) { int halfbyte = (digest[i] >>> 4) & 0x0F; int two_halfs = 0; if (halfbyte < 10) { two_halfs = halfbyte + 0x30; } else { two_halfs = halfbyte + 0x41 - 10; } char hex_digit = (char) (two_halfs); sb.append(hex_digit); } return sb.to"
    },
    {
        "ID": 1521,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected Configuration() { try { Enumeration<URL> resources = getClass().getClassLoader().getResources(\"activejdbc_models.properties\"); while (resources.hasMoreElements()) { URL url = resources.nextElement(); LogFilter.log(logger, \"Load models from: \" + url.toExternalForm()); InputStream inputStream = null; try { inputStream = url.openStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = reader.readLine()) != null) { String[] parts = Util.split(line, ':'); String modelName = parts[0]; String dbName = parts[1]; if (modelsMap.get(dbName) == null) { modelsMap.put(dbName, new ArrayList<String>()); } modelsMap.get(dbName).add(modelName); } } catch (IOException e) { e.printStackTrace(); } finally { if (inputStream != null) inputStream.close(); } } } catch (IOException e) { throw new InitException(e); } if (modelsMap.isEmpty()) { LogFilter.log(logger, \"ActiveJDBC Warning: Cannot locate any models, assuming project without models.\"); return; } try { InputStream in = getClass().getResourceAsStream(\"/activejdbc.properties\"); if (in != null) properties.load(in); } catch (Exception e) { throw new InitException(e); } String cacheManagerClass = properties.getProperty(\"cache.manager\"); if (cacheManagerClass != null) { try { Class cmc = Class.forName(cacheManagerClass); cacheManager = (CacheManager) cmc.newInstance(); } catch (Exception e) { throw new InitException(\"failed to initialize a CacheManager. Please, ensure that the property \" + \"'cache.manager' points to correct class which extends 'activejdbc.cache.CacheManager' class and provides a default constructor.\", e); } } }. \n Code2: public DataRecord addRecord(InputStream input) throws DataStoreException { File temporary = null; try { temporary = newTemporaryFile(); DataIdentifier tempId = new DataIdentifier(temporary.getName()); usesIdentifier(tempId); long length = 0; MessageDigest digest = MessageDigest.getInstance(DIGEST); OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest); try { length = IOUtils.copyLarge(input, output); } finally { output.close(); } DataIdentifier identifier = new DataIdentifier(digest.digest()); File file; synchronized (this) { usesIdentifier(identifier); file = getFile(identifier); System.out.println(\"new file name: \" + file.getName()); File parent = file.getParentFile(); System.out.println(\"parent file: \" + file.getParentFile().getName()); if (!parent.isDirectory()) { parent.mkdirs(); } if (!file.exists()) { temporary.renameTo(file); if (!file.exists()) { throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\"); } } else { long now = System.currentTimeMillis(); if (file.lastModified() < now) { file.setLastModified(now); } } if (!file.isFile()) { throw new IOException(\"Not a file: \" + file); } if (file.length() != length) { throw new IOException(DIGEST + \" collision: \" + file); } } inUse.remove(tempId); return new FileDataRecord(identifier, file); } catch (NoSuchAlgorithmException e) { throw new DataStoreException(DIGEST + \" not available\", e); } catch (IOException e) { throw new DataStoreException(\"Could not add record\", e); } finally { if (temporary != null) { temporary.delete(); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String toMd5(String str) { MessageDigest messageDigest = null; try { messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.reset(); messageDigest.update(str.getBytes(\"UTF-8\")); } catch (NoSuchAlgorithmException e) { System.out.println(\"NoSuchAlgorithmException caught!\"); System.exit(-1); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } byte[] byteArray = messageDigest.digest(); StringBuffer md5StrBuff = new StringBuffer(); for (int i = 0; i < byteArray.length; i++) { if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i])); } return md5StrBuff.toString(); }. \n Code2: private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException { String filePath = null; try { URL endpoint = new URL(wsdlURL); HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection(); conn.setDoOutput(false); conn.setDoInput(true); conn.setUseCaches(false); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\"); conn.setRequestProperty(\"Connection\", \"close\"); if (userPassword != null) { conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes())); } InputStream is = null; if (conn.getResponseCode() == 200) { is = conn.getInputStream(); } else { is = conn.getErrorStream(); InputStreamReader isr = new InputStreamReader(is); StringWriter sw = new StringWriter(); char[] buf = new char[200]; int read = 0; while (read != -1) { read = isr.read(buf); sw.write(buf); } throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString()); } File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\")); if (!outputDir.exists()) { outputDir.mkdir(); wiseProperties.setProperty(\"wise.forceImportObject\", \"true\"); } File file = new File(wiseProperties.getProperty(\"wise.tmp",
        "ground_truth": "NO",
        "predict": "Dir\") + File.separator + \"wsdl.xml\"); if (file.exists()) { file.delete(); } file.createNewFile(); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(file)); osw.write(sw.toString()); osw.close(); } catch (IOException e) { throw new WiseConnectionException(\"Could not connect to remote server\", e); } finally { if (filePath != null) { try { FileUtils.deleteDirectory(new File(filePath)); } catch (IOException e) { } } } return filePath; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String toMd5(String str) { MessageDigest messageDigest = null; try { messageDigest = MessageDigest.getInstance(\"MD5\"); messageDigest.reset(); messageDigest.update(str"
    },
    {
        "ID": 1522,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null && stableBuild != null) { doVersionCheck(view, stableBuild, develBuild); } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }. \n Code2: private void handleNodeDown(long eventID, long nodeID, String eventTime) { Category log = ThreadCategory.getInstance(OutageWriter.class); if (eventID == -1 || nodeID == -1) { log.warn(EventConstants.NODE_DOWN_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid: \" + eventID + \"/\" + nodeID); return; } Connection dbConn = null; try { dbConn = DatabaseConnectionFactory.getInstance().getConnection(); try { dbConn.setAutoCommit(false); } catch (SQLException sqle) { log.error(\"Unable to change database AutoCommit to FALSE\", sqle); return; } PreparedStatement activeSvcsStmt = dbConn.prepareStatement(OutageConstants.DB_GET_ACTIVE_SERVICES_FOR_NODE); PreparedStatement openStmt = dbConn.prepareStatement(OutageConstants.DB_OPEN_RECORD); PreparedStatement newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE); PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID()); newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE); if (log.isDebugEnabled()) log.debug(\"handleNodeDown: creating new outage entries...\"); activeSvcsStmt.setLong(1, nodeID); ResultSet activeSvcsRS = activeSvcsStmt.executeQuery(); while (activeSvcsRS.next()) { String ipAddr = activeSvcsRS.getString(1); long serviceID = activeSvcsRS.getLong(2); if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) { if (log.isDebugEnabled()) log.debug(\"handleNodeDown: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" already down\"); } else { long outageID = -1; ResultSet seqRS = getNextOutageIdStmt.executeQuery(); if (seqRS.next()) { outageID = seqRS.getLong(1); } seqRS.close(); newOutageWriter.setLong(1, outageID); newOutageWriter.setLong(2, eventID); newOutageWriter.setLong(3, nodeID); newOutageWriter.setString(4, ipAddr); newOutageWriter.setLong(5, serviceID); newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime)); newOutageWriter.executeUpdate(); if (log.isDebugEnabled()) log.debug(\"handleNodeDown: Recording outage for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID); } } activeSvcsRS.close(); try { dbConn.commit(); if (log.isDebugEnabled()) log.debug(\"Outage recorded for all active services for \" + nodeID); } catch (SQLException se) { log.warn(\"Rolling back transaction, nodeDown could not be recorded for nodeId: \" + nodeID, se); try { dbConn.rollback(); } catch (SQLException sqle) { log.warn(\"SQL exception during rollback, reason\", sqle); } } activeSvcsStmt.close(); openStmt.close(); newOutageWriter.close(); } catch (SQLException sqle) { log.warn(\"SQL exception while handling \\'nodeDown\\'\", sqle); } finally { try { if (dbConn != null) dbConn.close(); } catch (SQLException e) { log.warn(\"Exception closing JDBC connection\", e); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException { ProgramProfilingMessageSymbol profilingMessageSymbol = null; Connection connection = null; Statement statement = null; ResultSet resultSet = null; try { String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\"; connection = DriverManager.getConnection(CONN_STR); statement = connection.createStatement(); statement.executeUpdate(query); query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID = \" + programMessageSymbolID; resultSet = statement.executeQuery(query); if (!resultSet.next()) { connection.rollback(); String msg = \"Attempt to create program profiling message \" + \"symbol failed.\"; log.error(msg); throw new AdaptationException(msg); } profilingMessageSymbol = getProfilingMessageSymbol(resultSet); connection.commit(); } catch (SQLException ex) { try { connection.rollback(); } catch (Exception e) { } String msg = \"SQLException in createNewProfilingMessageSymbol\"; log.error(msg, ex); throw new AdaptationException(msg, ex); } finally { try { resultSet.close(); } catch (Exception ex) { } try { statement.close(); } catch (Exception ex) { } try { connection.close(); } catch (Exception ex) { } } return profilingMessageSymbol; }. \n Code2: public String encrypt(String password) throws Exception { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); md5.update(password.getBytes()); Big",
        "ground_truth": "NO",
        "predict": "Integer hash = new BigInteger(1, md5.digest()); return hash.toString(16); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String develBuild = null; String stableBuild = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim(); } bin.close(); if (develBuild != null"
    },
    {
        "ID": 1526,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void launchJob(final String workingDir, final AppConfigType appConfig) throws FaultType { logger.info(\"called for job: \" + jobID); MessageContext mc = MessageContext.getCurrentContext(); HttpServletRequest req = (HttpServletRequest) mc.getProperty(HTTPConstants.MC_HTTP_SERVLETREQUEST); String clientDN = (String) req.getAttribute(GSIConstants.GSI_USER_DN); if (clientDN != null) { logger.info(\"Client's DN: \" + clientDN); } else { clientDN = \"Unknown client\"; } String remoteIP = req.getRemoteAddr(); SOAPService service = mc.getService(); String serviceName = service.getName(); if (serviceName == null) { serviceName = \"Unknown service\"; } if (appConfig.isParallel()) { if (AppServiceImpl.drmaaInUse) { if (AppServiceImpl.drmaaPE == null) { logger.error(\"drmaa.pe property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); throw new FaultType(\"drmaa.pe property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); } if (AppServiceImpl.mpiRun == null) { logger.error(\"mpi.run property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); throw new FaultType(\"mpi.run property must be specified in \" + \"opal.properties for parallel execution \" + \"using DRMAA\"); } } else if (!AppServiceImpl.globusInUse) { if (AppServiceImpl.mpiRun == null) { logger.error(\"mpi.run property must be specified in opal.properties \" + \"for parallel execution without using Globus\"); throw new FaultType(\"mpi.run property must be specified in \" + \"opal.properties for parallel execution \" + \"without using Globus\"); } } if (jobIn.getNumProcs() == null) { logger.error(\"Number of processes unspecified for parallel job\"); throw new FaultType(\"Number of processes unspecified for parallel job\"); } else if (jobIn.getNumProcs().intValue() > AppServiceImpl.numProcs) { logger.error(\"Processors required - \" + jobIn.getNumProcs() + \", available - \" + AppServiceImpl.numProcs); throw new FaultType(\"Processors required - \" + jobIn.getNumProcs() + \", available - \" + AppServiceImpl.numProcs); } } try { status.setCode(GramJob.STATUS_PENDING); status.setMessage(\"Launching executable\"); status.setBaseURL(new URI(AppServiceImpl.tomcatURL + jobID)); } catch (MalformedURIException mue) { logger.error(\"Cannot convert base_url string to URI - \" + mue.getMessage()); throw new FaultType(\"Cannot convert base_url string to URI - \" + mue.getMessage()); } if (!AppServiceImpl.dbInUse) { AppServiceImpl.statusTable.put(jobID, status); } else { Connection conn = null; try { conn = DriverManager.getConnection(AppServiceImpl.dbUrl, AppServiceImpl.dbUser, AppServiceImpl.dbPasswd); } catch (SQLException e) { logger.error(\"Cannot connect to database - \" + e.getMessage()); throw new FaultType(\"Cannot connect to database - \" + e.getMessage()); } String time = new SimpleDateFormat(\"MMM d, yyyy h:mm:ss a\", Locale.US).format(new Date()); String sqlStmt = \"insert into job_status(job_id, code, message, base_url, \" + \"client_dn, client_ip, service_name, start_time, last_update) \" + \"values ('\" + jobID + \"', \" + status.getCode() + \", \" + \"'\" + status.getMessage() + \"', \" + \"'\" + status.getBaseURL() + \"', \" + \"'\" + clientDN + \"', \" + \"'\" + remoteIP + \"', \" + \"'\" + serviceName + \"', \" + \"'\" + time + \"', \" + \"'\" + time + \"');\"; try { Statement stmt = conn.createStatement(); stmt.executeUpdate(sqlStmt); conn.close(); } catch (SQLException e) { logger.error(\"Cannot insert job status into database - \" + e.getMessage()); throw new FaultType(\"Cannot insert job status into database - \" + e.getMessage()); } } String args = appConfig.getDefaultArgs(); if (args == null) { args = jobIn.getArgList(); } else { String userArgs = jobIn.getArgList(); if (userArgs != null) args += \" \" + userArgs; } if (args != null) { args = args.trim(); } logger.debug(\"Argument list: \" + args); if (AppServiceImpl.drmaaInUse) { String cmd = null; String[] argsArray = null; if (appConfig.isParallel()) { cmd = \"/bin/sh\"; String newArgs = AppServiceImpl.mpiRun + \" -machinefile $TMPDIR/machines\" + \" -np \" + jobIn.getNumProcs() + \" \" + appConfig.getBinaryLocation(); if (args != null) { args = newArgs + \" \" + args; } else { args = newArgs; } logger.debug(\"CMD: \" + args); argsArray = new String[] { \"-c\", args }; } else { cmd = appConfig.getBinaryLocation(); if (args == null) args = \"\"; logger.debug(\"CMD: \" + cmd + \" \" + args); argsArray = args.split(\" \"); } try { logger.debug(\"Working directory: \" + workingDir); JobTemplate jt = session.createJobTemplate(); if (appConfig.isParallel()) jt.setNativeSpecification(\"-pe \" + AppServiceImpl.drmaaPE + \" \" + jobIn.getNumProcs()); jt.setRemoteCommand(cmd); jt.setArgs(argsArray); jt.setJobName(jobID); jt.setWorkingDirectory(workingDir); jt.setErrorPath(\":\" + workingDir + \"/stderr.txt\"); jt.setOutputPath(\":\" + workingDir + \"/stdout.txt\"); drmaaJobID = session.runJob(jt); logger.info(\"DRMAA job has been submitted with id \" + drmaaJobID); session.deleteJobTemplate(jt); } catch (Exception ex) { logger.error(ex); status.setCode(GramJob.STATUS_FAILED); status.setMessage(\"Error while running executable via DRMAA - \" + ex.getMessage()); if (AppServiceImpl.dbInUse) { try { updateStatusIn",
        "ground_truth": "YES",
        "predict": "DB(jobID, status); } catch (Exception e) { } } } }\n\n}\n"
    },
    {
        "ID": 1531,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyFile(String f_in, String f_out, boolean remove) throws FileNotFoundException, IOException { if (remove) { PogoString readcode = new PogoString(PogoUtil.readFile(f_in)); readcode = PogoUtil.removeLogMessages(readcode); PogoUtil.writeFile(f_out, readcode.str); } else { FileInputStream fid = new FileInputStream(f_in); FileOutputStream fidout = new FileOutputStream(f_out); int nb = fid.available(); byte[] inStr = new byte[nb]; if (fid.read(inStr) > 0) fidout.write(inStr); fid.close(); fidout.close(); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static List runITQLQuery(String itqlQuery) throws Exception { String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\"); String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery; logger.debug(\"url for risearch query: \" + url); URL urlObject = new URL(url); HttpURLConnection con = (HttpURLConnection) urlObject.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream())); logger.debug(\"response code: \" + con.getResponseCode()); if (con.getResponseCode() != 200 && con.getResponseCode() != 302) { throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url); } ArrayList arrayList = new ArrayList(); String inputLine; int counter = 0; while ((inputLine = br.readLine()) != null) { logger.debug(\"reading line:\" + inputLine); if (inputLine.indexOf(\"<html>\") >= 0) { logger.error(\"problem quering the relationship\"); throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery); } if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) { logger.debug(\"adding line:\" + inputLine); inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1); arrayList.add(input",
        "ground_truth": "NO",
        "predict": "Line); } counter++; } br.close(); return arrayList; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static List runITQLQuery(String itqlQuery) throws Exception { String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\"); String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery; logger.debug(\"url for risearch query: \" + url); URL urlObject = new URL(url); Http"
    },
    {
        "ID": 1540,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void saveDraft(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException { try { if (charset == null) { charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName()); } if ((body == null) || body.trim().equals(\"\")) { body = \" \"; } Email email = null; if (isHtml) { email = new HtmlEmail(); } else { email = new MultiPartEmail(); } email.setCharset(charset); Users user = getUser(hsession, repositoryName); Identity identity = getIdentity(hsession, ideIdint, user); InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName()); InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName()); InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName()); InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null); InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null); InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null); if (_from != null) { email.setFrom(_from.getAddress(), _from.getPersonal()); } if (_returnPath != null) { email.addHeader(\"Return-Path\", _returnPath.getAddress()); email.addHeader(\"Errors-To\", _returnPath.getAddress()); email.addHeader(\"X-Errors-To\", _returnPath.getAddress()); } if (_replyTo != null) { email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal()); } if ((_to != null) && (_to.length > 0)) { HashSet aux = new HashSet(_to.length); Collections.addAll(aux, _to); email.setTo(aux); } if ((_cc != null) && (_cc.length > 0)) { HashSet aux = new HashSet(_cc.length); Collections.addAll(aux, _cc); email.setCc(aux); } if ((_bcc != null) && (_bcc.length > 0)) { HashSet aux = new HashSet(_bcc.length); Collections.addAll(aux, _bcc); email.setBcc(aux); } email.setSubject(subject); Date now = new Date(); email.setSentDate(now); File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\"); if (!dir.exists()) { dir.mkdir(); } if ((attachments != null) && (attachments.size() > 0)) { for (int i = 0; i < attachments.size(); i++) { ByteArrayInputStream bais = null; FileOutputStream fos = null; try { MailPartObj obj = (MailPartObj) attachments.get(i); File file = new File(dir, obj.getName()); bais = new ByteArrayInputStream(obj.getAttachent()); fos = new FileOutputStream(file); IOUtils.copy(bais, fos); EmailAttachment attachment = new EmailAttachment(); attachment.setPath(file.getPath()); attachment.setDisposition(EmailAttachment.ATTACHMENT); attachment.setDescription(\"File Attachment: \" + file.getName()); attachment.setName(file.getName()); if (email instanceof MultiPartEmail) { ((MultiPartEmail) email).attach(attachment); } } catch (Exception ex) { } finally { IOUtils.closeQuietly(bais); IOUtils.closeQuietly(fos); } } } if (headers != null) { Header xheader; Enumeration xe = headers.getAllHeaders(); for (; xe.hasMoreElements(); ) { xheader = (Header) xe.nextElement(); if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) { email.addHeader(xheader.getName(), xheader.getValue()); } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) { email.addHeader(xheader.getName(), xheader.getValue()); } } } if (priority != null) { if (priority.equals(\"high\")) { email.addHeader(\"Importance\", priority); email.addHeader(\"X-priority\", \"1\"); } else if (priority.equals(\"low\")) { email.addHeader(\"Importance\", priority); email.addHeader(\"X-priority\", \"5\"); } } if (email instanceof HtmlEmail) { ((HtmlEmail) email).setHtmlMsg(body); } else { email.setMsg(body); } email.setMailSession(session); email.buildMimeMessage(); MimeMessage mime = email.getMimeMessage(); int size = MessageUtilities.getMessageSize(mime); if (!controlQuota(hsession, user, size)) { throw new MailException(\"ErrorMessages.mail.quota.exceded\"); } messageable.storeDraftMessage(getId(), mime, user); } catch (MailException e) { throw e; } catch (Exception e) { throw new MailException(e); } catch (java.lang.OutOfMemoryError ex) { System.gc(); throw new MailException(ex); } catch (Throwable e) { throw new MailException(e); } finally { GeneralOperations.closeHibernateSession(hsession); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inf",
        "ground_truth": "YES",
        "predict": "late = ds.getInt(Tags.InflatedFlag, 0) == 1; if (hasPixelData && !inflate) { System.out.println(\"\\n\" + src + \": already uncompressed\"); return; } if (ds.contains(Tags.PixelData)) { System.out.println(\"\\n\" + src + \": already compressed\"); return; } if (ds.contains(Tags.PixelData)) { System.out.println(\"\\n\" + src + \": already compressed\"); return; } if (ds.contains(Tags.PixelData)) { System.out.println(\"\\n\" + src + \": already compressed\"); return; } if (ds.contains(Tags.PixelData)) { System.out.println(\"\\n\" + src + \": already compressed\"); return; } if (ds.contains(Tags.PixelData)) { System.out.println(\"\\n\" + src + \": already compressed\"); return"
    },
    {
        "ID": 1553,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected String getHashCode(String value) { if (log.isDebugEnabled()) log.debug(\"getHashCode(...) -> begin\"); String retVal = null; try { MessageDigest mdAlgorithm = MessageDigest.getInstance(\"MD5\"); mdAlgorithm.update(value.getBytes()); byte[] digest = mdAlgorithm.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < digest.length; i++) { sb.append(this.toHexString(digest[i])); } retVal = sb.toString(); if (log.isDebugEnabled()) log.debug(\"getHashCode(...) -> hashcode = \" + retVal); } catch (Exception e) { log.error(\"getHashCode(...) -> error occured generating hashcode \", e); } if (log.isDebugEnabled()) log.debug(\"getHashCode(...) -> end\"); return retVal; }. \n Code2: public void launchJob(final String workingDir, final AppConfigType appConfig) throws FaultType { logger.info(\"called for job: \" + jobID); MessageContext mc = MessageContext.getCurrentContext(); HttpServletRequest req = (HttpServletRequest) mc.getProperty(HTTPConstants.MC_HTTP_SERVLETREQUEST); String clientDN = (String) req.getAttribute(GSIConstants.GSI_USER_DN); if (clientDN != null) { logger.info(\"Client's DN: \" + clientDN); } else { clientDN = \"Unknown client\"; } String remoteIP = req.getRemoteAddr(); SOAPService service = mc.getService(); String serviceName = service.getName(); if (serviceName == null) { serviceName = \"Unknown service\"; } if (appConfig.isParallel()) { if (AppServiceImpl.drmaaInUse) { if (AppServiceImpl.drmaaPE == null) { logger.error(\"drmaa.pe property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); throw new FaultType(\"drmaa.pe property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); } if (AppServiceImpl.mpiRun == null) { logger.error(\"mpi.run property must be specified in opal.properties \" + \"for parallel execution using DRMAA\"); throw new FaultType(\"mpi.run property must be specified in \" + \"opal.properties for parallel execution \" + \"using DRMAA\"); } } else if (!AppServiceImpl.globusInUse) { if (AppServiceImpl.mpiRun == null) { logger.error(\"mpi.run property must be specified in opal.properties \" + \"for parallel execution without using Globus\"); throw new FaultType(\"mpi.run property must be specified in \" + \"opal.properties for parallel execution \" + \"without using Globus\"); } } if (jobIn.getNumProcs() == null) { logger.error(\"Number of processes unspecified for parallel job\"); throw new FaultType(\"Number of processes unspecified for parallel job\"); } else if (jobIn.getNumProcs().intValue() > AppServiceImpl.numProcs) { logger.error(\"Processors required - \" + jobIn.getNumProcs() + \", available - \" + AppServiceImpl.numProcs); throw new FaultType(\"Processors required - \" + jobIn.getNumProcs() + \", available - \" + AppServiceImpl.numProcs); } } try { status.setCode(GramJob.STATUS_PENDING); status.setMessage(\"Launching executable\"); status.setBaseURL(new URI(AppServiceImpl.tomcatURL + jobID)); } catch (MalformedURIException mue) { logger.error(\"Cannot convert base_url string to URI - \" + mue.getMessage()); throw new FaultType(\"Cannot convert base_url string to URI - \" + mue.getMessage()); } if (!AppServiceImpl.dbInUse) { AppServiceImpl.statusTable.put(jobID, status); } else { Connection conn = null; try { conn = DriverManager.getConnection(AppServiceImpl.dbUrl, AppServiceImpl.dbUser, AppServiceImpl.dbPasswd); } catch (SQLException e) { logger.error(\"Cannot connect to database - \" + e.getMessage()); throw new FaultType(\"Cannot connect to database - \" + e.getMessage()); } String time = new SimpleDateFormat(\"MMM d, yyyy h:mm:ss a\", Locale.US).format(new Date()); String sqlStmt = \"insert into job_status(job_id, code, message, base_url, \" + \"client_dn, client_ip, service_name, start_time, last_update) \" + \"values ('\" + jobID + \"', \" + status.getCode() + \", \" + \"'\" + status.getMessage() + \"', \" + \"'\" + status.getBaseURL() + \"', \" + \"'\" + clientDN + \"', \" + \"'\" + remoteIP + \"', \" + \"'\" + serviceName + \"', \" + \"'\" + time + \"', \" + \"'\" + time + \"');\"; try { Statement stmt = conn.createStatement(); stmt.executeUpdate(sqlStmt); conn.close(); } catch (SQLException e) { logger.error(\"Cannot insert job status into database - \" + e.getMessage()); throw new FaultType(\"Cannot insert job status into database - \" + e.getMessage()); } } String args = appConfig.getDefaultArgs(); if (args == null) { args = jobIn.getArgList(); } else { String userArgs = jobIn.getArgList(); if (userArgs != null) args += \" \" + userArgs; } if (args != null) { args = args.trim(); } logger.debug(\"Argument list: \" + args); if (AppServiceImpl.drmaaInUse) { String cmd = null; String[] argsArray = null; if (appConfig.isParallel()) { cmd = \"/bin/sh\"; String newArgs = AppServiceImpl.mpiRun + \" -machinefile $TMPDIR/machines\" + \" -np \" + jobIn.getNumProcs() + \" \" + appConfig.getBinaryLocation(); if (args != null) { args = newArgs + \" \" + args; } else { args = newArgs; } logger.debug(\"CMD: \" + args); argsArray = new String[] { \"-c\", args }; } else { cmd = appConfig.getBinaryLocation(); if (args == null) args = \"\"; logger.debug(\"CMD: \" + cmd + \" \" + args); argsArray = args.split(\" \"); } try { logger.debug(\"Working directory: \" + workingDir); JobTemplate jt = session.createJobTemplate(); if (appConfig.isParallel()) jt",
        "ground_truth": "YES",
        "predict": ".setRemoteCommand(cmd); else jt.setRemoteCommand(appConfig.getBinaryLocation()); jt.setArgs(argsArray); jt.setWorkingDirectory(workingDir); jt.setOutputPath(workingDir + \"/\" + jobID + \".out\"); jt.setErrorPath(workingDir + \"/\" + jobID + \".err\"); jt.setRemoteCommand(cmd); jt.setArgs(argsArray); jt.setOutputPath(workingDir + \"/\" + jobID + \".out\"); jt.setErrorPath(workingDir + \"/\" + jobID + \".err\"); jt.setRemoteCommand(cmd); jt.setArgs(argsArray); jt.setOutputPath(workingDir + \"/\" + jobID + \".out\"); jt.setErrorPath(workingDir + \"/\" + jobID + \".err\"); jt.setRemoteCommand(cmd); jt.setArgs(argsArray); jt.setOutputPath"
    },
    {
        "ID": 1555,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: void run(String[] args) { InputStream istream = System.in; System.out.println(\"TradeMaximizer \" + version); String filename = parseArgs(args, false); if (filename != null) { System.out.println(\"Input from: \" + filename); try { if (filename.startsWith(\"http:\") || filename.startsWith(\"ftp:\")) { URL url = new URL(filename); istream = url.openStream(); } else istream = new FileInputStream(filename); } catch (IOException ex) { fatalError(ex.toString()); } } List<String[]> wantLists = readWantLists(istream); if (wantLists == null) return; if (options.size() > 0) { System.out.print(\"Options:\"); for (String option : options) System.out.print(\" \" + option); System.out.println(); } System.out.println(); try { MessageDigest digest = MessageDigest.getInstance(\"MD5\"); for (String[] wset : wantLists) { for (String w : wset) { digest.update((byte) ' '); digest.update(w.getBytes()); } digest.update((byte) '\\n'); } System.out.println(\"Input Checksum: \" + toHexString(digest.digest())); } catch (NoSuchAlgorithmException ex) { } parseArgs(args, true); if (iterations > 1 && seed == -1) { seed = System.currentTimeMillis(); System.out.println(\"No explicit SEED, using \" + seed); } if (!(metric instanceof MetricSumSquares) && priorityScheme != NO_PRIORITIES) System.out.println(\"Warning: using priorities with the non-default metric is normally worthless\"); buildGraph(wantLists); if (showMissing && officialNames != null && officialNames.size() > 0) { for (String name : usedNames) officialNames.remove(name); List<String> missing = new ArrayList<String>(officialNames); Collections.sort(missing); for (String name : missing) { System.out.println(\"**** Missing want list for official name \" + name); } System.out.println(); } if (showErrors && errors.size() > 0) { Collections.sort(errors); System.out.println(\"ERRORS:\"); for (String error : errors) System.out.println(error); System.out.println(); } long startTime = System.currentTimeMillis(); graph.removeImpossibleEdges(); List<List<Graph.Vertex>> bestCycles = graph.findCycles(); int bestMetric = metric.calculate(bestCycles); if (iterations > 1) { System.out.println(metric); graph.saveMatches(); for (int i = 0; i < iterations - 1; i++) { graph.shuffle(); List<List<Graph.Vertex>> cycles = graph.findCycles(); int newMetric = metric.calculate(cycles); if (newMetric < bestMetric) { bestMetric = newMetric; bestCycles = cycles; graph.saveMatches(); System.out.println(metric); } else if (verbose) System.out.println(\"# \" + metric); } System.out.println(); graph.restoreMatches(); } long stopTime = System.currentTimeMillis(); displayMatches(bestCycles); if (showElapsedTime) System.out.println(\"Elapsed time = \" + (stopTime - startTime) + \"ms\"); }. \n Code2: @Override public ArrayList<String> cacheAgeingProcess(int numberOfDays) throws DatabaseException { IMAGE_LIFETIME = numberOfDays; PreparedStatement statement = null; ArrayList<String> ret = new ArrayList<String>(); try { statement = getConnection().prepareStatement(SELECT_ITEMS_FOR_DELETION_STATEMENT); ResultSet rs = statement.executeQuery(); int i = 0; int rowsAffected = 0; while (rs.next()) { ret.add(rs.getString(\"imageFile\")); i++; } if (i > 0) { statement = getConnection().prepareStatement(DELETE_ITEMS_STATEMENT); rowsAffected = statement.executeUpdate(); } if (rowsAffected == i) { getConnection().commit(); LOGGER.debug(\"DB has been updated.\"); LOGGER.debug(i + \" images are going to be removed.\"); } else { getConnection().rollback(); LOGGER.error(\"DB has not been updated -> rollback!\"); } } catch (SQLException e) { LOGGER.error(e); } finally { closeConnection(); } return ret; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static boolean setBundleInfoName(String location, List<BundleInfo> list) { try { URL url = new URL(location); BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\")); while (true) { String line = br.readLine(); if (line == null) { break; } int pos1 = line.indexOf('='); if (pos1 < 0) { continue; } String bundleSymbolicName = line.substring(0, pos1); String bundleName = line.substring(pos1 + 1); for (BundleInfo info : list) { if (info.bundleSymbolicName.equals(bundleSymbolicName)) { info.bundleName = bundleName; break; } } } return true; } catch (IOException e) { e.printStackTrace(); } return false; }. \n Code2: public static void copy(File from_file, File to_file) throws IOException { if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName()); if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName()); if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName()); if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName()); if (to_file.exists()) { if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName()); } else { String parent = to_file.getParent(); if (parent == null) parent = System.getProperty(\"user.dir\"); File dir = new File(parent); if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent); if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \"",
        "ground_truth": "NO",
        "predict": " + parent); if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent); } FileInputStream fis = new FileInputStream(from_file); FileOutputStream fos = new FileOutputStream(to_file); byte[] buf = new byte[1024]; int i; while ((i = fis.read(buf)) != -1) fos.write(buf, 0, i); fis.close(); fos.close(); }. \n Code3: public static void abort(String message) { System.out.println(message); System.exit(1); }. \n Code4: public static void fatalError(String message) { System.out.println(message); System.exit(1); }. \n Code5: public static void main(String[] args) { new TradeMaximizer().run(args); }. \n Code6: public static void main(String[] args) { new TradeMaximizer()."
    },
    {
        "ID": 1557,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public BufferedImage extract() throws DjatokaException { boolean useRegion = false; int left = 0; int top = 0; int width = 50; int height = 50; boolean useleftDouble = false; Double leftDouble = 0.0; boolean usetopDouble = false; Double topDouble = 0.0; boolean usewidthDouble = false; Double widthDouble = 0.0; boolean useheightDouble = false; Double heightDouble = 0.0; if (params.getRegion() != null) { StringTokenizer st = new StringTokenizer(params.getRegion(), \"{},\"); String token; if ((token = st.nextToken()).contains(\".\")) { topDouble = Double.parseDouble(token); usetopDouble = true; } else top = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { leftDouble = Double.parseDouble(token); useleftDouble = true; } else left = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { heightDouble = Double.parseDouble(token); useheightDouble = true; } else height = Integer.parseInt(token); if ((token = st.nextToken()).contains(\".\")) { widthDouble = Double.parseDouble(token); usewidthDouble = true; } else width = Integer.parseInt(token); useRegion = true; } try { if (is != null) { File f = File.createTempFile(\"tmp\", \".jp2\"); f.deleteOnExit(); FileOutputStream fos = new FileOutputStream(f); sourceFile = f.getAbsolutePath(); IOUtils.copyStream(is, fos); is.close(); fos.close(); } } catch (IOException e) { throw new DjatokaException(e); } try { Jp2_source inputSource = new Jp2_source(); Kdu_compressed_source input = null; Jp2_family_src jp2_family_in = new Jp2_family_src(); Jp2_locator loc = new Jp2_locator(); jp2_family_in.Open(sourceFile, true); inputSource.Open(jp2_family_in, loc); inputSource.Read_header(); input = inputSource; Kdu_codestream codestream = new Kdu_codestream(); codestream.Create(input); Kdu_channel_mapping channels = new Kdu_channel_mapping(); if (inputSource.Exists()) channels.Configure(inputSource, false); else channels.Configure(codestream); int ref_component = channels.Get_source_component(0); Kdu_coords ref_expansion = getReferenceExpansion(ref_component, channels, codestream); Kdu_dims image_dims = new Kdu_dims(); codestream.Get_dims(ref_component, image_dims); Kdu_coords imageSize = image_dims.Access_size(); Kdu_coords imagePosition = image_dims.Access_pos(); if (useleftDouble) left = imagePosition.Get_x() + (int) Math.round(leftDouble * imageSize.Get_x()); if (usetopDouble) top = imagePosition.Get_y() + (int) Math.round(topDouble * imageSize.Get_y()); if (useheightDouble) height = (int) Math.round(heightDouble * imageSize.Get_y()); if (usewidthDouble) width = (int) Math.round(widthDouble * imageSize.Get_x()); if (useRegion) { imageSize.Set_x(width); imageSize.Set_y(height); imagePosition.Set_x(left); imagePosition.Set_y(top); } int reduce = 1 << params.getLevelReductionFactor(); imageSize.Set_x(imageSize.Get_x() * ref_expansion.Get_x()); imageSize.Set_y(imageSize.Get_y() * ref_expansion.Get_y()); imagePosition.Set_x(imagePosition.Get_x() * ref_expansion.Get_x() / reduce - ((ref_expansion.Get_x() / reduce - 1) / 2)); imagePosition.Set_y(imagePosition.Get_y() * ref_expansion.Get_y() / reduce - ((ref_expansion.Get_y() / reduce - 1) / 2)); Kdu_dims view_dims = new Kdu_dims(); view_dims.Assign(image_dims); view_dims.Access_size().Set_x(imageSize.Get_x()); view_dims.Access_size().Set_y(imageSize.Get_y()); int region_buf_size = imageSize.Get_x() * imageSize.Get_y(); int[] region_buf = new int[region_buf_size]; Kdu_region_decompressor decompressor = new Kdu_region_decompressor(); decompressor.Start(codestream, channels, -1, params.getLevelReductionFactor(), 16384, image_dims, ref_expansion, new Kdu_coords(1, 1), false, Kdu_global.KDU_WANT_OUTPUT_COMPONENTS); Kdu_dims new_region = new Kdu_dims(); Kdu_dims incomplete_region = new Kdu_dims(); Kdu_coords viewSize = view_dims.Access_size(); incomplete_region.Assign(image_dims); int[] imgBuffer = new int[viewSize.Get_x() * viewSize.Get_y()]; int[] kduBuffer = null; while (decompressor.Process(region_buf, image_dims.Access_pos(), 0, 0, region_buf_size, incomplete_region, new_region)) { Kdu_coords newOffset = new_region.Access_pos(); Kdu_coords newSize = new_region.Access_size(); newOffset.Subtract(view_dims.Access_pos()); kduBuffer = region_buf; int imgBuffereIdx = newOffset.Get_x() + newOffset.Get_y() * viewSize.Get_x(); int kduBufferIdx = 0; int xDiff = viewSize.Get_x() - newSize.Get_x(); for (int j = 0; j < newSize.Get_y(); j++, imgBuffereIdx += xDiff) { for (int i = 0; i < newSize.Get_x(); i++) { imgBuffer[imgBuffereIdx++] = kduBuffer[kduBufferIdx++]; } } } BufferedImage image = new BufferedImage(imageSize.Get_x(), imageSize.Get_y(), BufferedImage.TYPE_INT_RGB); image.set",
        "ground_truth": "NO",
        "predict": "RGB(0, 0, imageSize.Get_x(), imageSize.Get_y(), imgBuffer, 0, imageSize.Get_x()); return image; } catch (Exception e) { throw new DjatokaException(e); } }\n\n}\n"
    },
    {
        "ID": 1570,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public List execute(ComClient comClient) throws Exception { ArrayList outStrings = new ArrayList(); SearchResult sr = Util.getSearchResultByIDAndNum(SearchManager.getInstance(), qID, dwNum); for (int i = 0; i < checkerUrls.length; i++) { String parametrizedURL = checkerUrls[i]; Iterator mtIter = sr.iterateMetatags(); while (mtIter.hasNext()) { Map.Entry mt = (Map.Entry) mtIter.next(); parametrizedURL = parametrizedURL.replaceAll(\"%%\" + mt.getKey() + \"%%\", mt.getValue().toString()); if (mt.getKey().equals(\"fake\") && ((Boolean) mt.getValue()).booleanValue()) { outStrings.add(\"it's a fake.\"); return outStrings; } } parametrizedURL = parametrizedURL.replaceAll(\"%%fileid%%\", sr.getFileHash().toString()); System.out.println(\"parametrizedURL=\" + parametrizedURL); try { URL url = new URL(parametrizedURL); URLConnection connection = url.openConnection(); connection.connect(); BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream())); String str = null; while ((str = br.readLine()) != null) { System.out.println(str); if (str.indexOf(fakeMarks[i]) != -1) { System.out.println(\"FAKEFAKEFAKE\"); sr.addMetatag(\"fake\", Boolean.TRUE); outStrings.add(\"it's a fake.\"); break; } } } catch (MalformedURLException murl_err) { murl_err.printStackTrace(); } catch (IOException io_err) { io_err.printStackTrace(); } catch (Exception err) { err.printStackTrace(); } } return outStrings; }. \n Code2: public static void main(String[] args) { try { URL url = new URL(\"http://localhost:8080/axis/services/Tripcom?wsdl\"); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"POST\"); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestProperty(\"Content-type\", \"text/xml; charset=utf-8\"); connection.setRequestProperty(\"SOAPAction\", \"http://tempuri.org/GetTime\"); String msg = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" + \"<soap:Envelope \" + \" xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n\" + \" <soap:Body>\\n\" + \" <rdTest xmlns=\\\"http://tempuri.org/\\\"> \\n\" + \" <tns:rdTest message=\\\"tns:rdTest\\\"/> \\n\" + \" </rdTest>\" + \" </soap:Body>\\n\" + \"</soap:Envelope>\"; byte[] bytes = msg.getBytes(); connection.setRequestProperty(\"Content-length\", String.valueOf(bytes.length)); System.out.println(\"\\nSOAP Aufruf:\"); System.out.println(\"Content-type:\" + connection.getRequestProperty(\"Content-type\")); System.out.println(\"Content-length:\" + connection.getRequestProperty(\"Content-length\")); System.out.println(\"SOAPAction:\" + connection.getRequestProperty(\"SOAPAction\")); System.out.println(msg); OutputStream out = connection.getOutputStream(); out.write(bytes); out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String inputLine; System.out.println(\"\\nServer Antwort:\"); while ((inputLine = in.readLine()) != null) System.out.println(inputLine); in.close(); } catch (Exception e) { System.out.println(\"FEHLER:\" + e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fileDownload(String fAddress, String destinationDir) { int slashIndex = fAddress.lastIndexOf('/'); int periodIndex = fAddress.lastIndexOf('.'); String fileName = fAddress.substring(slashIndex + 1); URL url; try { url = new URL(fAddress); URLConnection uc = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream())); File file = new File(destinationDir + \"/download.pdf\"); FileOutputStream fos = new FileOutputStream(file); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos)); int inputLine; while ((inputLine = in.read()) != -1) out.write(inputLine); in.close(); } catch (Exception ex) { Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex); } }. \n Code2: public static void copyFromTo(File srcFile, File destFile) { FileChannel in = null, out = null; FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(srcFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + srcFile.toString()); System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\"); System.exit(-1); } try { fos = new FileOutputStream(destFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + destFile.toString()); System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\"); System.exit(-1); } try { in = fis.getChannel(); out = fos.getChannel(); in.transferTo(0, in.size(), out); fos.flush(); fos.close(); out.close(); fis.close(); in.close(); System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString()); } catch (IOException ioe) { System.out.println(\"IOException copying file: \" + ioe.getMessage()); System.exit(-1); } long srcModified = srcFile.lastModified(); if (srcModified > 0L && destFile.exists()) { destFile.set",
        "ground_truth": "NO",
        "predict": "LastModified(srcModified); } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fileDownload(String fAddress, String destinationDir) { int slashIndex = fAddress.lastIndexOf('/'); int periodIndex = fAddress.lastIndexOf('.'); String fileName = fAddress.substring(slashIndex + 1); URL url; try { url = new URL(fAddress); URLConnection uc = url.openConnection(); BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream())); File file = new File(destinationDir + \"/download.pdf\"); FileOutputStream fos = new FileOutputStream(file); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos)); int inputLine; while ((inputLine = in.read()) != -1) out.write(inputLine"
    },
    {
        "ID": 1571,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void verifyAvailability() { for (int i = 0; i < servers.size(); i++) { String hostEntry = (String) servers.get(i); String hostString = hostEntry.substring(0, hostEntry.indexOf(\":\")); String portString = hostEntry.substring(hostEntry.indexOf(\":\") + 1); String urlLocation = \"http://\" + hostString + \":\" + portString + \"/\"; String urlData = null; String urlMatch = null; long startTime = System.currentTimeMillis(); URL url = null; HttpURLConnection conn = null; InputStream istream = null; if (serverRequests.get(hostEntry) != null) { String requestData = (String) serverRequests.get(hostEntry); urlData = requestData.substring(0, requestData.indexOf(\"\\t\")); try { urlMatch = requestData.substring(requestData.indexOf(\"\\t\") + 1); } catch (Exception e) { urlMatch = null; } urlLocation = \"http://\" + hostString + \":\" + portString + \"/\" + urlData; } try { url = new URL(urlLocation); conn = (HttpURLConnection) url.openConnection(); } catch (Exception e) { System.err.println(\"*** Warning: Unable to contact host '\" + hostEntry + \"': \" + e.getMessage()); serverTimes.put(hostEntry, \"0\"); continue; } try { istream = conn.getInputStream(); } catch (Exception e) { try { if (conn.getResponseCode() != 401) { System.err.println(\"*** Warning: Unable to contact host '\" + hostEntry + \"': \" + e); serverTimes.put(hostEntry, \"0\"); continue; } } catch (Exception ee) { System.err.println(\"*** Warning: Unable to contact host '\" + hostEntry + \"': \" + e); serverTimes.put(hostEntry, \"0\"); continue; } } int response = 501; try { response = conn.getResponseCode(); if (response != 200 && response != 401) { System.err.println(\"*** Warning: Connection to host '\" + hostEntry + \"' returns response: \" + response); serverTimes.put(hostEntry, \"0\"); continue; } } catch (Exception e) { System.err.println(\"*** Warning: Unable to contact host '\" + hostString + \"' on port '\" + portString + \"'\"); serverTimes.put(hostEntry, \"0\"); continue; } if (response != 401) { int contentLength = conn.getContentLength(); if (contentLength == -1) { contentLength = 4096; } byte data[] = new byte[contentLength]; int curPos = 0; try { int dataRead = 0; while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) { if (dataRead == 0) { break; } curPos += dataRead; } } catch (Exception e) { System.err.println(\"*** Warning: Unable to contact host '\" + hostEntry + \"': Cannot read response from site.\"); serverTimes.put(hostEntry, \"0\"); continue; } if (urlMatch != null) { String urlContents = new String(data); data = null; if (urlContents.indexOf(urlMatch) == -1) { System.err.println(\"*** Warning: Host '\" + hostEntry + \"' does not match search string. Reports '\" + urlContents + \"'\"); try { istream.close(); conn.disconnect(); } catch (Exception e) { } serverTimes.put(hostEntry, \"0\"); continue; } } } try { istream.close(); conn.disconnect(); } catch (Exception e) { } serverStatus.put(hostEntry, \"1\"); String timeResponse = Long.toString(System.currentTimeMillis() - startTime); Debug.log(\"Response time for '\" + hostEntry + \"' is \" + timeResponse + \" ms.\"); serverTimes.put(hostEntry, timeResponse); } }. \n Code2: public static boolean joinFiles(File dest, Collection<File> sources) { FileInputStream fis = null; FileOutputStream fos = null; boolean rv = false; byte[] buf = new byte[1000000]; int bytesRead = 0; if (!dest.getParentFile().exists()) dest.getParentFile().mkdirs(); try { fos = new FileOutputStream(dest); for (File source : sources) { fis = new FileInputStream(source); while ((bytesRead = fis.read(buf)) > 0) fos.write(buf, 0, bytesRead); fis.close(); fis = null; } fos.close(); fos = null; rv = true; } catch (Throwable t) { throw new ApplicationException(\"error joining files to \" + dest.getAbsolutePath(), t); } finally { if (fis != null) { try { fis.close(); } catch (Exception e) { } fis = null; } if (fos != null) { try { fos.close(); } catch (Exception e) { } fos = null; } } return rv; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException { File dest = new File(this.getRealFile(), name); LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name); if (isOwner) { if (!\".request\".equals(name) && !\".tokens\".equals(name)) { FileOutputStream out = null; try { out = new FileOutputStream(dest); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(out); } } else { if (ServerConfiguration.isDynamicSEL()) { } else { } FileOutputStream out = null; try { out = new FileOutputStream(dest); IOUtils.copy(in, out); } finally { IOUtils.closeQuietly(out); } } return factory.resolveFile(this.host, dest); } else { LOGGER.error(\"User isn't owner of this folder\"); return null; } }. \n Code2: public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) { try { con.setAutoCommit(false); stmt = con.createStatement(); Collection boxes = diagramModel.getBoxes(); BoxModel box; String sqlQuery; if (foreignKeys) { for (Iterator x = boxes.iterator(); x.hasNext(); ) { box = (BoxModel) x.next(); if (!box.isAbstractDef()) { dropForeignKeys(box); } } } int counter = 0; for (Iterator x = boxes.iterator",
        "ground_truth": "NO",
        "predict": "(); x.hasNext(); ) { box = (BoxModel) x.next(); if (!box.isAbstractDef()) { sqlQuery = \"DROP TABLE \" + box.getName(); if (foreignKeys) { sqlQuery += \" CASCADE\"; } stmt.executeUpdate(sqlQuery); counter++; } } con.commit(); } catch (SQLException e) { LOGGER.error(\"Error dropping schema\", e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void dropForeignKeys(BoxModel box) { try { con.setAutoCommit(false); stmt = con.createStatement(); String sqlQuery = \"ALTER TABLE \" + box.getName() + \" DROP CONSTRAINT \" + box.getName() + \"_fk\"; stmt.executeUpdate(sqlQuery); con.commit(); } catch (SQLE"
    },
    {
        "ID": 1572,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override @Transactional public FileData store(FileData data, InputStream stream) { try { FileData file = save(data); file.setPath(file.getGroup() + File.separator + file.getId()); file = save(file); File folder = new File(PATH, file.getGroup()); if (!folder.exists()) folder.mkdirs(); File filename = new File(folder, file.getId() + \"\"); IOUtils.copyLarge(stream, new FileOutputStream(filename)); return file; } catch (IOException e) { throw new ServiceException(\"storage\", e); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void doFinishLoadAttachment(long attachmentId) { if (attachmentId != mLoadAttachmentId) { return; } Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId); Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId); Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri); if (mLoadAttachmentSave) { try { File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName); InputStream in = getContentResolver().openInputStream(contentUri); OutputStream out = new FileOutputStream(file); IOUtils.copy(in, out); out.flush(); out.close(); in.close(); Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show(); new MediaScannerNotifier(this, file, mHandler); } catch (IOException ioe) { Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show(); } } else { try { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(contentUri); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); startActivity(intent); } catch (ActivityNotFoundException e) { mHandler.attachmentViewError(); } } }. \n Code2: private InputStream getInputStream(String item) { InputStream is = null; URLConnection urlc = null; try { URL url = new URL(item); urlc = url.openConnection(); is = urlc.getInputStream(); current_source = url.getProtocol() + \"://\" + url.getHost()",
        "ground_truth": "NO",
        "predict": " + \"/\" + url.getPath(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return is; }. \n Code3: private void doFinishLoadAttachment(long attachmentId) { if (attachmentId != mLoadAttachmentId) { return; } Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId); Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId); Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri); if (mLoadAttachmentSave) { try { File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName); InputStream in = getContentResolver().openInputStream(contentUri); OutputStream out = new FileOutputStream(file);"
    },
    {
        "ID": 1574,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void executeUpdateTransaction(List queries) throws SQLException { assert connection != null; boolean autoCommit = connection.getAutoCommit(); connection.setAutoCommit(false); try { Iterator iterator = queries.iterator(); while (iterator.hasNext()) { String query = (String) iterator.next(); Statement statement = connection.createStatement(); statement.executeUpdate(query); } connection.commit(); connection.setAutoCommit(autoCommit); } catch (SQLException e) { connection.rollback(); throw new SQLException(e.getMessage()); } }. \n Code2: public void seeURLConnection() throws Exception { URL url = new URL(\"http://wantmeet.iptime.org\"); URLConnection uc = url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(uc.getInputStream())); String s = null; StringBuffer sb = new StringBuffer(); while ((",
        "ground_truth": "NO",
        "predict": "s = br.readLine()) != null) { sb.append(s); } br.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void executeUpdateTransaction(List queries) throws SQLException { assert connection != null; boolean autoCommit = connection.getAutoCommit(); connection.setAutoCommit(false); try { Iterator iterator = queries.iterator(); while (iterator.hasNext()) { String query = (String) iterator.next(); Statement statement = connection.createStatement(); statement.executeUpdate(query); } connection.commit(); connection.setAutoCommit(autoCommit); } catch (SQLException e) { connection.rollback(); throw new SQLException(e.getMessage()); } }. \n Code2: public void seeURLConnection() throws Exception { URL url = new URL(\"http://wantmeet.ipt"
    },
    {
        "ID": 1578,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void translateTableMetaData(String baseDir, String tableName, NameSpaceDefinition nsDefinition) throws Exception { setVosiNS(baseDir, \"table\", nsDefinition); String filename = baseDir + \"table.xsl\"; Scanner s = new Scanner(new File(filename)); PrintWriter fw = new PrintWriter(new File(baseDir + tableName + \".xsl\")); while (s.hasNextLine()) { fw.println(s.nextLine().replaceAll(\"TABLENAME\", tableName)); } s.close(); fw.close(); applyStyle(baseDir + \"tables.xml\", baseDir + tableName + \".json\", baseDir + tableName + \".xsl\"); }. \n Code2: public static void download(String args[], boolean forEmu) { if (args.length < 1) { System.err.println(\"usage: java copyURL URL [LocalFile]\"); System.exit(1); } try { String check = args[1]; File chk = new File(check); String ext = check.substring(check.length() - 4); String name = check.substring(0, check.length() - 4); System.out.println(\"Name is:\" + name); System.out.println(\"Ext. is:\" + ext); if (!forEmu) { while (chk.canRead()) { name += \"-\"; chk = new File(name + ext); } args[1] = name + ext; } else { chk = new File(name + ext); chk.delete(); chk = new File(name + ext + \".tmp\"); chk.delete(); } args[1] = name + ext; String dlurl = args[0]; if (dlurl.contains(\"download.php\") && dlurl.contains(\"cpc-live.com\")) { String newurl = \"http://cpc-live.com/data/\"; while (!dlurl.startsWith(\"type=\")) { dlurl = dlurl.substring((1)); } dlurl = dlurl.replace(\"type=\", \"\"); while (!dlurl.startsWith(\"&\")) { newurl += dlurl.charAt(0); dlurl = dlurl.substring(1); } while (!dlurl.startsWith(\"fichier=\")) { dlurl = dlurl.substring((1)); } dlurl = dlurl.replace(\"fichier=\", \"\"); newurl += \"/\" + dlurl; dlurl = newurl; } dlurl = dlurl.replace(\" \", \"%20\"); dlurl = dlurl.replace(\"(\", \"%28\"); dlurl = dlurl.replace(\")\", \"%29\"); dlurl = dlurl.replace(\"[\", \"%5B\"); dlurl = dlurl.replace(\"]\", \"%5D\"); URL url = new URL(dlurl); System.out.println(\"Opening connection to \" + dlurl + \"...\"); HttpURLConnection urlC = (HttpURLConnection) url.openConnection(); urlC.setRequestMethod(\"GET\"); BufferedInputStream is = new BufferedInputStream(url.openStream()); int count = 0; try { System.out.print(\"Copying resource (type: \" + urlC.getContentType()); Date date = new Date(urlC.getLastModified()); int size = urlC.getContentLength(); System.out.println(\", modified on: \" + date.toString() + \")...\"); System.out.flush(); count = 0; BufferedOutputStream fos = null; try { if (args.length < 2) { String localFile = null; StringTokenizer st = new StringTokenizer(url.getFile(), \"/\"); while (st.hasMoreTokens()) { localFile = st.nextToken(); } fos = new BufferedOutputStream(new FileOutputStream(localFile)); } else { fos = new BufferedOutputStream(new FileOutputStream(args[1] + \".tmp\")); } byte[] buf = new byte[BUFSIZE]; int len = 0; while (len >= 0) { len = is.read(buf); if (len > 0) { fos.write(buf, 0, len); } count = count + len; } } finally { fos.close(); } } finally { is.close(); } File temp = new File(args[1] + \".tmp\"); File temp2 = new File(args[1]); temp.renameTo(temp2); System.out.println(\"\\n\" + count + \" byte(s) copied\"); if (forEmu) { CPC.download = true; } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) { try { URL url = new URL(apiUrl); HttpURLConnection request = (HttpURLConnection) url.openConnection(); if (ApplicationConstants.CONNECT_TIMEOUT > -1) { request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT); } if (ApplicationConstants.READ_TIMEOUT > -1) { request.setReadTimeout(ApplicationConstants.READ_TIMEOUT); } for (String headerName : requestHeaders.keySet()) { request.setRequestProperty(headerName, requestHeaders.get(headerName)); } request.setRequestMethod(\"POST\"); request.setDoOutput(true); PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream())); out.print(getParametersString(parameters)); out.flush(); out.close(); request.connect(); if (request.getResponseCode() != expected) { throw new BingMapsException(convertStreamToString(request.getErrorStream())); } else { return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding())); } } catch (IOException e) { throw new BingMapsException(e); } }. \n Code2: private String copyImageFile(String urlString, String filePath) { FileOutputStream destination = null; File destination_file = null; String inLine; String dest_name = \"\"; byte[] buffer; int bytes_read; int last_offset = 0; int offset = 0; InputStream imageFile = null; try { URL url = new URL(urlString); imageFile = url.openStream(); dest_name = url.getFile(); offset = 0; last_offset = 0; offset = dest_name.indexOf('/', offset + 1); while (offset > -1) { last_offset = offset + 1",
        "ground_truth": "NO",
        "predict": "; offset = dest_name.indexOf('/', last_offset + 1); } dest_name = dest_name.substring(last_offset); destination_file = new File(filePath + dest_name); destination = new FileOutputStream(destination_file); buffer = new byte[BUFSIZE]; while ((bytes_read = imageFile.read(buffer)) != -1) { destination.write(buffer, 0, bytes_read); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (destination != null) { destination.close(); } if (imageFile != null) { imageFile.close(); } } catch (IOException e) { e.printStackTrace(); } } return dest_name; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void download(String args[], boolean for"
    },
    {
        "ID": 1581,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UploadFileForm vo = (UploadFileForm) form; String review = request.getParameter(\"review\"); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = request.getParameter(\"inforId\"); request.setAttribute(\"id\", inforId); String str_postFIX = \"\"; int i_p = 0; if (null == review) { FormFile file = vo.getFile(); if (file != null) { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); String strAppend = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); if (file.getFileSize() != 0) { file.getInputStream(); String name = file.getFileName(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); String fullPath = realpath + \"attach/\" + strAppend + str_postFIX; t_attach attach = new t_attach(); attach.setAttach_fullname(fullPath); attach.setAttach_name(name); attach.setInfor_id(Integer.parseInt(inforId)); attach.setInsert_day(new Date()); attach.setUpdate_day(new Date()); t_attach_EditMap attachEdit = new t_attach_EditMap(); attachEdit.add(attach); File sysfile = new File(fullPath); if (!sysfile.exists()) { sysfile.createNewFile(); } java.io.OutputStream out = new FileOutputStream(sysfile); org.apache.commons.io.IOUtils.copy(file.getInputStream(), out); out.close(); } } request.setAttribute(\"operating-status\", \"\ufffd\ufffd\ufffd\ufffd\ufffd\u0279\ufffd! \ufffd\ufffd\u04ed\ufffd\ufffd\ufffd\ufffd\u02b9\ufffd\u00e1\ufffd\"); return \"editsave\"; } else { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append(UploadFileOne.strPath).toString(); FormFile file = vo.getFile(); FormFile file2 = vo.getFile2(); FormFile file3 = vo.getFile3(); t_infor_review newreview = new t_infor_review(); String content = request.getParameter(\"content\"); newreview.setContent(content); if (null != inforId) newreview.setInfor_id(Integer.parseInt(inforId)); newreview.setInsert_day(new Date()); UserDetails user = LoginUtils.getLoginUser(request); newreview.setCreate_name(user.getUsercode()); if (null != file.getFileName() && !\"\".equals(file.getFileName())) { newreview.setAttachname1(file.getFileName()); String strAppend1 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file.getFileName().lastIndexOf(\".\"); str_postFIX = file.getFileName().substring(i_p, file.getFileName().length()); newreview.setAttachfullname1(realpath + \"attach/\" + strAppend1 + str_postFIX); saveFile(file.getInputStream(), realpath + \"attach/\" + strAppend1 + str_postFIX); } if (null != file2.getFileName() && !\"\".equals(file2.getFileName())) { newreview.setAttachname2(file2.getFileName()); String strAppend2 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file2.getFileName().lastIndexOf(\".\"); str_postFIX = file2.getFileName().substring(i_p, file2.getFileName().length()); newreview.setAttachfullname2(realpath + \"attach/\" + strAppend2 + str_postFIX); saveFile(file2.getInputStream(), realpath + \"attach/\" + strAppend2 + str_postFIX); } if (null != file3.getFileName() && !\"\".equals(file3.getFileName())) { newreview.setAttachname3(file3.getFileName()); String strAppend3 = (new StringBuilder(String.valueOf(UUIDGenerator.nextHex()))).append(UploadFileOne.getFileType(file)).toString(); i_p = file3.getFileName().lastIndexOf(\".\"); str_postFIX = file3.getFileName().substring(i_p, file3.getFileName().length()); newreview.setAttachfullname3(realpath + \"attach/\" + strAppend3 + str_postFIX); saveFile(file3.getInputStream(), realpath + \"attach/\" + strAppend3 + str_postFIX); } t_infor_review_EditMap reviewEdit = new t_infor_review_EditMap(); reviewEdit.add(newreview); request.setAttribute(\"review\", \"1\"); return \"aftersave\"; } }. \n Code2: public static void copyFile(File src, File dest, boolean preserveFileDate) throws IOException { if (src.exists() && src.isDirectory()) { throw new IOException(\"source file exists but is a directory\"); } if (dest.exists() && dest.isDirectory()) { dest = new File(dest, src.getName()); } if (!dest.exists()) { dest.createNewFile(); } FileChannel srcCH = null; FileChannel destCH = null; try { srcCH = new FileInputStream(src).getChannel(); destCH = new FileOutputStream(dest).getChannel(); destCH.transferFrom(srcCH, 0, srcCH.size()); } finally { closeQuietly(srcCH); closeQuietly(destCH); } if (src.length() != dest.length()) { throw new IOException(\"Failed to copy full contents from '\" + src + \"' to '\" + dest + \"'\"); } if (preserveFileDate) { dest.setLastModified(src.lastModified()); } }. \n Response: YES. \n Instruction: Is",
        "ground_truth": "NO",
        "predict": " there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String doAdd(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UploadFileForm vo = (UploadFileForm) form; String review = request.getParameter(\"review\"); String realpath = getServlet().getServletContext().getRealPath(\"/\"); realpath = realpath.replaceAll(\"\\\\\\\\\", \"/\"); String inforId = request.getParameter(\"inforId\"); request.setAttribute(\"id\", inforId); String str_postFIX = \"\"; int i_p = 0; if (null == review) { FormFile file = vo.getFile(); if (file != null) { String rootFilePath = getServlet().getServletContext().getRealPath(request.getContextPath()); rootFilePath = (new StringBuilder(String.valueOf(rootFilePath))).append("
    },
    {
        "ID": 1590,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void runGetAppListing() { DataStorage.clearAppListings(); GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId); AppListingList appListingList; try { HttpRequest request = requestFactory.buildGetRequest(url); request.addParser(jsonHttpParser); request.readTimeout = readTimeout; HttpResponse response = request.execute(); appListingList = response.parseAs(AppListingList.class); if (appListingList != null && appListingList.appListings != null) { operationStatus = true; DataStorage.setAppListings(appListingList.appListings); } response.getContent().close(); } catch (IOException e) { AppsMarketplacePluginLog.logError(e); } }. \n Code2: public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); mButton1 = (Button) findViewById(R.id.myButton1); mButton2 = (Button) findViewById(R.id.myButton2); mTextView1 = (TextView) findViewById(R.id.myTextView1); mButton1.setOnClickListener(new Button.OnClickListener() { public void onClick(View v) { String uriAPI = \"http://www.sina.com\"; HttpPost httpRequest = new HttpPost(uriAPI); List<NameValuePair> params = new ArrayList<NameValuePair>(); params.add(new BasicNameValuePair(\"str\", \"post string\")); try {",
        "ground_truth": "NO",
        "predict": " httpRequest.setEntity(new UrlEncodedFormEntity(params)); HttpResponse httpResponse = httpClient.execute(httpRequest); httpResponse.getEntity().getContent().close(); } catch (IOException e) { AppsMarketplacePluginLog.logError(e); } } }); mButton2.setOnClickListener(new Button.OnClickListener() { public void onClick(View v) { String uriAPI = \"http://www.sina.com\"; HttpPost httpRequest = new HttpPost(uriAPI); List<NameValuePair> params = new ArrayList<NameValuePair>(); params.add(new BasicNameValuePair(\"str\", \"post string\")); try { httpRequest.setEntity(new UrlEncodedFormEntity(params)); HttpResponse httpResponse = httpClient.execute(httpRequest); httpResponse.getEntity().getContent().close(); } catch (IOException e) { AppsMarketplacePluginLog.logError(e"
    },
    {
        "ID": 1602,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public ActualTask(TEditor editor, TIGDataBase dataBase, String directoryPath, String myImagesBehaviour) { File myDirectory = new File(directoryPath); String[] list = myDirectory.list(); File fileXML = new File(directoryPath + \"images.xml\"); SAXBuilder builder = new SAXBuilder(false); try { Document docXML = builder.build(fileXML); Element root = docXML.getRootElement(); List images = root.getChildren(\"image\"); Iterator j = images.iterator(); int i = 0; TIGDataBase.activateTransactions(); while (j.hasNext() && !stop && !cancel) { current = i; i++; Element image = (Element) j.next(); String name = image.getAttributeValue(\"name\"); List categories = image.getChildren(\"category\"); Iterator k = categories.iterator(); if (exists(list, name)) { String pathSrc = directoryPath.concat(name); String pathDst = System.getProperty(\"user.dir\") + File.separator + \"images\" + File.separator + name.substring(0, 1).toUpperCase() + File.separator; String folder = System.getProperty(\"user.dir\") + File.separator + \"images\" + File.separator + name.substring(0, 1).toUpperCase(); if (myImagesBehaviour.equals(TLanguage.getString(\"TIGImportDBDialog.REPLACE_IMAGES\"))) { Vector<Vector<String>> aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.'))); if (aux.size() != 0) { int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.'))); TIGDataBase.deleteAsociatedOfImage(idImage); } pathDst = pathDst.concat(name); } if (myImagesBehaviour.equals(TLanguage.getString(\"TIGImportDBDialog.ADD_IMAGES\"))) { Vector aux = new Vector(); aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.'))); int fileCount = 0; if (aux.size() != 0) { while (aux.size() != 0) { fileCount++; aux = TIGDataBase.imageSearchByName(name.substring(0, name.lastIndexOf('.')) + \"_\" + fileCount); } pathDst = pathDst + name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length()); name = name.substring(0, name.lastIndexOf('.')) + '_' + fileCount + name.substring(name.lastIndexOf('.'), name.length()); } else { pathDst = pathDst.concat(name); } } String pathThumbnail = (pathDst.substring(0, pathDst.lastIndexOf(\".\"))).concat(\"_th.jpg\"); File newDirectoryFolder = new File(folder); if (!newDirectoryFolder.exists()) { newDirectoryFolder.mkdirs(); } try { FileChannel srcChannel = new FileInputStream(pathSrc).getChannel(); FileChannel dstChannel = new FileOutputStream(pathDst).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } catch (IOException exc) { System.out.println(exc.getMessage()); System.out.println(exc.toString()); } TIGDataBase.insertImageDB(name.substring(0, name.lastIndexOf('.')), name); int idImage = TIGDataBase.imageKeySearchName(name.substring(0, name.lastIndexOf('.'))); while (k.hasNext()) { Element category = (Element) k.next(); int idCategory = TIGDataBase.insertConceptDB(category.getValue()); TIGDataBase.insertAsociatedDB(idCategory, idImage); } } else { errorImages = errorImages + System.getProperty(\"line.separator\") + name; } } TIGDataBase.executeQueries(); current = lengthOfTask; } catch (JDOMException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }. \n Code2: @SuppressWarnings(\"unchecked\") protected void handleRequest(HttpServletRequest req, HttpServletResponse resp, boolean isPost) throws ServletException, IOException { HttpClient httpclient = WebReader.getHttpClient(); try { StringBuffer sb = new StringBuffer(); sb.append(targetServer); sb.append(req.getRequestURI()); if (req.getQueryString() != null) { sb.append(\"?\" + req.getQueryString()); } HttpRequestBase targetRequest = null; if (isPost) { HttpPost post = new HttpPost(sb.toString()); Enumeration<String> paramNames = req.getParameterNames(); String paramName = null; List<NameValuePair> params = new ArrayList<NameValuePair>(); while (paramNames.hasMoreElements()) { paramName = paramNames.nextElement(); params.add(new BasicNameValuePair(paramName, req.getParameterValues(paramName)[0])); } post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8)); targetRequest = post; } else { System.out.println(\"GET\"); HttpGet get = new HttpGet(sb.toString()); targetRequest = get; } HttpResponse targetResponse = httpclient.execute(targetRequest); HttpEntity entity = targetResponse.getEntity(); InputStream input = entity.getContent(); OutputStream output = resp.getOutputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(input)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output)); String line = reader.readLine(); while (line != null) { writer.write(line + \"\\n\"); line = reader.readLine(); } reader.close(); writer.close(); } finally { WebReader.returnHttpClient(httpclient); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { if (args.length != 2) { System.out.println(\"arguments: sourcefile destfile\"); System.exit(1); } FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while (in.read",
        "ground_truth": "NO",
        "predict": "(buffer) != -1) { buffer.flip(); out.write(buffer); buffer.clear(); } in.close(); out.close(); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { if (args.length != 2) { System.out.println(\"arguments: sourcefile destfile\"); System.exit(1); } FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while (in.read(buffer) != -1) { buffer.flip(); out.write(buffer); buffer.clear(); } in.close(); out.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2,"
    },
    {
        "ID": 1605,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected int insertRecord(PutMetadataRequest request, PutMetadataInfo info) throws ImsServiceException, SQLException { Connection con = null; boolean autoCommit = true; PreparedStatement st = null; ResultSet rs = null; int nRows = 0; String sXml = info.getXml(); String sUuid = info.getUuid(); String sName = info.getName(); String sThumbnailBinary = info.getThumbnailBinary(); String sTable = this.getResourceTableName(); String sDataTable = this.getResourceDataTableName(); long id = doesRecordExist(sTable, sUuid); try { ManagedConnection mc = returnConnection(); con = mc.getJdbcConnection(); autoCommit = con.getAutoCommit(); con.setAutoCommit(false); if (id < 0) { StringBuffer sql = new StringBuffer(); sql.append(\"INSERT INTO \").append(sTable); sql.append(\" (\"); sql.append(\"DOCUUID,\"); sql.append(\"TITLE,\"); sql.append(\"OWNER\"); sql.append(\")\"); sql.append(\" VALUES(?,?,?)\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); int n = 1; st.setString(n++, sUuid); st.setString(n++, sName); st.setInt(n++, this.publisher.getLocalID()); nRows = st.executeUpdate(); closeStatement(st); if (nRows > 0) { if (getIsDbCaseSensitive(this.getRequestContext())) { st = con.prepareStatement(\"SELECT id FROM \" + sTable + \" WHERE UPPER(docuuid)=?\"); } else { st = con.prepareStatement(\"SELECT id FROM \" + sTable + \" WHERE docuuid=?\"); } st.setString(1, sUuid.toUpperCase()); rs = st.executeQuery(); rs.next(); id = rs.getLong(1); closeStatement(st); request.setActionStatus(ImsRequest.ACTION_STATUS_OK); sql = new StringBuffer(); sql.append(\"INSERT INTO \").append(sDataTable); sql.append(\" (DOCUUID,ID,XML)\"); sql.append(\" VALUES(?,?,?)\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); st.setString(1, sUuid); st.setLong(2, id); st.setString(3, sXml); st.executeUpdate(); } } else { this.authorize(request, sUuid); StringBuffer sql = new StringBuffer(); sql.append(\"UPDATE \").append(sTable); sql.append(\" SET \"); if (!request.getLockTitle()) { sql.append(\"TITLE=?, \"); } sql.append(\"OWNER=?, \"); sql.append(\"UPDATEDATE=?\"); sql.append(\" WHERE DOCUUID=?\"); logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); int n = 1; if (!request.getLockTitle()) { st.setString(n++, sName); } st.setInt(n++, this.publisher.getLocalID()); st.setTimestamp(n++, new Timestamp(System.currentTimeMillis())); st.setString(n++, sUuid); nRows = st.executeUpdate(); if (nRows > 0) { request.setActionStatus(ImsRequest.ACTION_STATUS_REPLACED); } closeStatement(st); sql = new StringBuffer(); if (doesRecordExist(sDataTable, sUuid) >= 0) { sql.append(\"UPDATE \").append(sDataTable); sql.append(\" SET DOCUUID=?, XML=?, THUMBNAIL=?\"); sql.append(\" WHERE ID=?\"); } else { sql.append(\"INSERT INTO \").append(sDataTable); sql.append(\" (DOCUUID, XML,THUMBNAIL,ID)\"); sql.append(\" VALUES(?,?,?,?)\"); } logExpression(sql.toString()); st = con.prepareStatement(sql.toString()); st.setString(1, sUuid); st.setString(2, sXml); st.setBytes(3, null); st.setLong(4, id); st.executeUpdate(); } con.commit(); } catch (ImsServiceException ex) { if (con != null) { con.rollback(); } throw ex; } catch (SQLException ex) { if (con != null) { con.rollback(); } throw ex; } finally { closeResultSet(rs); closeStatement(st); if (con != null) { con.setAutoCommit(autoCommit); } } if ((sThumbnailBinary != null) && (sThumbnailBinary.length() > 0)) { this.updateThumbnail(sThumbnailBinary, sUuid); } return nRows; }. \n Code2: public void writeTo(OutputStream out) throws IOException { if (!closed) { throw new IOException(\"Stream not closed\"); } if (isInMemory()) { memoryOutputStream.writeTo(out); } else { FileInputStream fis = new FileInputStream(outputFile); try { IOUtils.copy(fis, out); } finally { IOUtils.closeQuietly(fis); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException { String fullname = System.mapLibraryName(name); String path = \"native/\" + sysName + \"/\" + fullname; URL url = Thread.currentThread().getContextClassLoader().getResource(path); if (url == null) { if (!warning) { logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname }); } return; } URLConnection conn = url.openConnection(); InputStream in = conn.getInputStream(); File targetFile = new File(getExtractionDir(), fullname); OutputStream out = null; try { if (targetFile.exists()) { long targetLastModified = targetFile.lastModified(); long sourceLastModified = conn.getLastModified(); if (targetLastModified + 1000 > sourceLastModified) { logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname); return; } } out = new FileOutputStream(targetFile); int len; while ((len = in.read(buf)) > 0) { out.write(buf, 0, len); } in.close(); in = null;",
        "ground_truth": "NO",
        "predict": " out.close(); out = null; } finally { IOUtils.closeQuietly(in); IOUtils.closeQuietly(out); } }. \n Code3: public static void main(String[] args) { try { new ImsService().extractNativeLib(\"linux\", \"libjpeg.so\", true, true); } catch (IOException ex) { ex.printStackTrace(); } }. \n */\n"
    },
    {
        "ID": 1610,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Algorithm(name = \"EXT\") public void execute() { Connection conn = null; try { Class.forName(jdbcDriver).newInstance(); conn = DriverManager.getConnection(jdbcUrl, username, password); conn.setAutoCommit(false); l.debug(\"Connected to the database\"); Statement stmt = conn.createStatement(); l.debug(sql); ResultSet rs = stmt.executeQuery(sql); List<Map<String, String>> res = DbUtil.listFromRS(rs); if (null != res && !res.isEmpty()) { docs = new ArrayList<Doc>(); List<String> keys = new ArrayList<String>(); for (Map<String, String> map : res) { docs.add(convert(map)); String key = map.get(pk); keys.add(key); } String sql2 = updateSQL + \" where \" + pk + \" in (\" + CollectionUtil.toString(keys) + \")\"; l.debug(sql2); stmt.executeUpdate(sql2); conn.commit(); } } catch (Exception e) { l.error(e.getMessage(), e); if (null != conn) { try { conn.rollback(); } catch (Exception ex) { l.error(ex.getMessage(), ex); } } throw new RuntimeException(e.getMessage()); } finally { try { if (null != conn) { conn.close(); l.debug(\"Disconnected from database\"); } } catch (Exception ex) { l.error(ex.getMessage(), ex); } } if (null != docs && !docs.isEmpty()) { triggerEvent(\"EO\"); } else { triggerEvent(\"EMPTY\"); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String executePost(String targetURL, String urlParameters) { URL url; HttpURLConnection connection = null; try { url = new URL(targetURL); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"POST\"); connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length)); connection.setRequestProperty(\"Content-Language\", \"en-US\"); connection.setUseCaches(false); connection.setDoInput(true); connection.setDoOutput(true); DataOutputStream wr = new DataOutputStream(connection.getOutputStream()); wr.writeBytes(urlParameters); wr.flush(); wr.close(); InputStream is = connection.getInputStream(); BufferedReader rd = new BufferedReader(new InputStreamReader(is)); String line; String",
        "ground_truth": "NO",
        "predict": "Buffer response = new StringBuffer(); while ((line = rd.readLine()) != null) { response.append(line); } rd.close(); } catch (Exception e) { l.error(e.getMessage(), e); } finally { try { if (connection != null) { connection.disconnect(); } } catch (Exception ex) { l.error(ex.getMessage(), ex); } } return response.toString(); }. \n */"
    },
    {
        "ID": 1627,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override @RemoteMethod public synchronized boolean copy(int idAnexo) { try { Anexo anexo = selectById(idAnexo); Authentication auth = SecurityContextHolder.getContext().getAuthentication(); Usuario usuario = (Usuario) auth.getPrincipal(); if (anexo.getAssinado() == 1 && anexo.getIdAssinadoPor() != usuario.getIdUsuario()) { deleteAnexoFromTemp(anexo); return false; } Carteira carteiraUsuario = carteiraService.selectById(usuario.getIdCarteira()); DocumentoDetalhes documentoDetalhes = anexo.getDocumentoDetalhes(); Set<Documento> documentos = documentoDetalhes.getDocumentosByCarteira(); boolean havePermission = false; for (Documento documento : documentos) { Carteira carteiraDocumento = documento.getCarteira(); if (carteiraDocumento != null) { if (carteiraDocumento.getIdCarteira() == carteiraUsuario.getIdCarteira()) { havePermission = true; System.out.println(\"tem permisssao: \" + havePermission); break; } } } if (!havePermission) { System.out.println(\"N\u00e3o tem permissao.\"); return false; } FileInputStream fis = new FileInputStream(new File(config.baseDir + \"/temp/\" + anexo.getAnexoCaminho())); FileOutputStream fos = new FileOutputStream(new File(config.baseDir + \"/arquivos_upload_direto/\" + anexo.getAnexoCaminho())); IOUtils.copy(fis, fos); String txtHistorico = \"(Edi\u00e7\u00e3o) -\" + anexo.getAnexoNome() + \"-\"; txtHistorico += usuario.getUsuLogin(); Historico historico = new Historico(); historico.setCarteira(carteiraUsuario); historico.setDataHoraHistorico(new Date()); historico.setHistorico(txtHistorico); historico.setDocumentoDetalhes(documentoDetalhes); historico.setUsuario(usuario); historicoService.save(historico); return deleteAnexoFromTemp(anexo); } catch (FileNotFoundException e) { System.out.println(\"FileNotFoundException\"); e.printStackTrace(); return false; } catch (IOException e) { System.out.println(\"IOException\"); e.printStackTrace(); return false; } catch (Exception e) { System.out.println(\"AnexoServiceImpl.copy ERRO DESCONHECIDO\"); e.printStackTrace(); return false; } }. \n Code2: public void process(Group group, List resourcesName, List excludeResources, ServletContext servletContext, Writer out, String location) throws IOException { LOG.debug(\"Merging content of group : \" + group.getName()); for (Iterator iterator = group.getSubgroups().iterator(); iterator.hasNext(); ) { Group subGroup = (Group) iterator.next(); String subLocation = subGroup.getBestLocation(location); ResourcesProcessor subGroupProcessor = null; if (subGroup.isMinimize() == null) subGroupProcessor = this; else subGroupProcessor = subGroup.getJSProcessor(); subGroupProcessor.process(subGroup, subGroup.getJsNames(), excludeResources, servletContext, out, subLocation); } for (Iterator it = resourcesName.iterator(); it.hasNext(); ) { URL url = null; String path = (String) it.next(); if (!excludeResources.contains(path)) { url = URLUtils.getLocalURL(path, servletContext); if (url == null) { String webPath = URLUtils.concatUrlWithSlaches(group.getBestLocation(location), path); url = URLUtils.getWebUrlResource(webPath); } if (url == null) { throw new IOException(\"The resources '\" + path + \"' could not be found neither in the webapp folder nor in a jar\"); } InputStream in = null; try { in = url.openStream(); IOUtils.copy(in, out, URLUtils.DEFAULT_ENCODING); out.write(\"\\n\\n\"); } catch (Exception e) { LOG.error(\"Merge failed for file \" + path, e); } finally { if (in != null) in.close(); } excludeResources.add(path); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void conMail(MailObject mail) throws NetworkException, ContentException { HttpClient client = HttpConfig.newInstance(); String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber(); HttpGet get = new HttpGet(url); try { HttpResponse response = client.execute(get); HttpEntity entity = response.getEntity(); if (HTTPUtil.isXmlContentType(response)) { Document doc = XmlOperator.readDocument(entity.getContent()); BBSBodyParseHelper.parseMailContent(doc, mail); } else { String msg = BBSBodyParseHelper.parseFailMsg(entity); throw new ContentException(msg); } } catch (ClientProtocolException e) { e.printStackTrace(); throw new NetworkException(e); } catch (IOException e) { e.printStackTrace(); throw new NetworkException(e); } }. \n Code2: public String insertSmsInf(Sms sms) throws Exception { String smsId = null; Connection conn = null; PreparedStatement pstmt = null; StringBuffer buffer = new StringBuffer(); try { buffer.append(\"INSERT INTO COMTNSMS\\n\"); buffer.append(\" (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\"); buffer.append(\" FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\"); buffer.append(\"VALUES\\n\"); buffer.append(\"(?, ?, ?, ?, SYSDATE())\"); conn = SmsBasicDBUtil.getConnection(); conn.setAutoCommit(false); smsId = getNextId(conn); pstmt = conn.prepareStatement(buffer.toString()); int index = 0; pstmt.setString(++index, smsId);",
        "ground_truth": "NO",
        "predict": " pstmt.setString(++index, sms.getTelno()); pstmt.setString(++index, sms.getCn()); pstmt.setString(++index, sms.getFrstRegisterId()); pstmt.executeUpdate(); conn.commit(); } catch (Exception e) { LOG.error(\"insertSmsInf ERRO\", e); throw e; } finally { if (pstmt != null) pstmt.close(); if (conn != null) conn.close(); } return smsId; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void conMail(MailObject mail) throws NetworkException, ContentException { HttpClient client = HttpConfig.newInstance(); String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&"
    },
    {
        "ID": 1629,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void doRender() throws IOException { File file = new File(fileName); if (!file.exists()) { logger.error(\"Static resource not found: \" + fileName); isNotFound = true; return; } if (fileName.endsWith(\"xml\") || fileName.endsWith(\"asp\")) servletResponse.setContentType(\"text/xml\"); else if (fileName.endsWith(\"css\")) servletResponse.setContentType(\"text/css\"); else if (fileName.endsWith(\"js\")) servletResponse.setContentType(\"text/javascript\"); InputStream in = null; try { in = new FileInputStream(file); IOUtils.copy(in, servletResponse.getOutputStream()); logger.debug(\"Static resource rendered: \".concat(fileName)); } catch (FileNotFoundException e) { logger.error(\"Static resource not found: \" + fileName); isNotFound = true; } finally { IOUtils.closeQuietly(in); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME); while (urls.hasMoreElements()) { URL url = urls.nextElement(); log.debug(\"Found: \" + url); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); String className = null; while ((className = reader.readLine()) != null) { className = className.trim(); if (!\"\".equals(className) && !className.startsWith(\"#\")) { log.debug(\"Found class: \" + className); Class<?> clazz = classLoader.loadClass(className); addClass(clazz); } } } } catch (IOException e) { e.printStackTrace(); log.error(e); } catch (ClassNotFoundException e) { e.printStackTrace(); log.error(e); } }. \n Code2: private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) { try { File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile); FileChannel inC = new FileInputStream(inFile).getChannel(); File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep",
        "ground_truth": "NO",
        "predict": " + CustRatingFileName); FileChannel outC1 = new FileOutputStream(outFile1).getChannel(); File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName); FileChannel outC2 = new FileOutputStream(outFile2).getChannel(); inC.transferTo(0, inC.size(), outC1); inC.transferTo(0, inC.size(), outC2); outC1.close(); outC2.close(); return true; } catch (IOException e) { e.printStackTrace(); return false; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void init(ServletContext context) throws ScratchException { try { log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME); ClassLoader class"
    },
    {
        "ID": 1634,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static FTPClient createConnection(String hostname, int port, char[] username, char[] password, String workingDirectory, FileSystemOptions fileSystemOptions) throws FileSystemException { if (username == null) username = \"anonymous\".toCharArray(); if (password == null) password = \"anonymous\".toCharArray(); try { final FTPClient client = new FTPClient(); String key = FtpFileSystemConfigBuilder.getInstance().getEntryParser(fileSystemOptions); if (key != null) { FTPClientConfig config = new FTPClientConfig(key); String serverLanguageCode = FtpFileSystemConfigBuilder.getInstance().getServerLanguageCode(fileSystemOptions); if (serverLanguageCode != null) config.setServerLanguageCode(serverLanguageCode); String defaultDateFormat = FtpFileSystemConfigBuilder.getInstance().getDefaultDateFormat(fileSystemOptions); if (defaultDateFormat != null) config.setDefaultDateFormatStr(defaultDateFormat); String recentDateFormat = FtpFileSystemConfigBuilder.getInstance().getRecentDateFormat(fileSystemOptions); if (recentDateFormat != null) config.setRecentDateFormatStr(recentDateFormat); String serverTimeZoneId = FtpFileSystemConfigBuilder.getInstance().getServerTimeZoneId(fileSystemOptions); if (serverTimeZoneId != null) config.setServerTimeZoneId(serverTimeZoneId); String[] shortMonthNames = FtpFileSystemConfigBuilder.getInstance().getShortMonthNames(fileSystemOptions); if (shortMonthNames != null) { StringBuffer shortMonthNamesStr = new StringBuffer(40); for (int i = 0; i < shortMonthNames.length; i++) { if (shortMonthNamesStr.length() > 0) shortMonthNamesStr.append(\"|\"); shortMonthNamesStr.append(shortMonthNames[i]); } config.setShortMonthNames(shortMonthNamesStr.toString()); } client.configure(config); } FTPFileEntryParserFactory myFactory = FtpFileSystemConfigBuilder.getInstance().getEntryParserFactory(fileSystemOptions); if (myFactory != null) client.setParserFactory(myFactory); try { client.connect(hostname, port); int reply = client.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) throw new FileSystemException(\"vfs.provider.ftp/connect-rejected.error\", hostname); if (!client.login(UserAuthenticatorUtils.toString(username), UserAuthenticatorUtils.toString(password))) throw new FileSystemException(\"vfs.provider.ftp/login.error\", new Object[] { hostname, UserAuthenticatorUtils.toString(username) }, null); if (!client.setFileType(FTP.BINARY_FILE_TYPE)) throw new FileSystemException(\"vfs.provider.ftp/set-binary.error\", hostname); Integer dataTimeout = FtpFileSystemConfigBuilder.getInstance().getDataTimeout(fileSystemOptions); if (dataTimeout != null) client.setDataTimeout(dataTimeout.intValue()); try { FtpFileSystemConfigBuilder.getInstance().setHomeDir(fileSystemOptions, client.printWorkingDirectory()); } catch (IOException ex) { throw new FileSystemException(\"Error obtaining working directory!\"); } Boolean userDirIsRoot = FtpFileSystemConfigBuilder.getInstance().getUserDirIsRoot(fileSystemOptions); if (workingDirectory != null && (userDirIsRoot == null || !userDirIsRoot.booleanValue())) if (!client.changeWorkingDirectory(workingDirectory)) throw new FileSystemException(\"vfs.provider.ftp/change-work-directory.error\", workingDirectory); Boolean passiveMode = FtpFileSystemConfigBuilder.getInstance().getPassiveMode(fileSystemOptions); if (passiveMode != null && passiveMode.booleanValue()) client.enterLocalPassiveMode(); } catch (final IOException e) { if (client.isConnected()) client.disconnect(); throw e; } return client; } catch (final Exception exc) { throw new FileSystemException(\"vfs.provider.ftp/connect.error\", new Object[] { hostname }, exc); } }. \n Code2: public URLConnection makeURLConnection(String server) throws IOException { if (server == null) { connection = null; } else { URL url = new URL(\"http://\" + server + \"/Bob/QueryXindice\"); connection = url.openConnection(); connection.setDoOutput(true); } return connection; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private boolean getWave(String url, String Word) { try { File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\"); FF.mkdir(); URL url2 = new URL(url); BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream())); File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\"); if (!Fdel.exists()) { FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\"); BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream)); char[] binput = new char[1024]; int len = stream.read(binput, 0, 1024); while (len > 0) { bwriter.write(binput, 0, len); len = stream.read(binput, 0, 1024); } bwriter.close(); outstream.close(); } stream.close(); } catch (Exception e) { System.out.println(e.getMessage()); return false; } return true; }. \n Code2: public void postData(String protocol, String host, String form, String data) throws Exception { if ((protocol == null) || (protocol.equals(\"\"))) { protocol = DEFAULT_PROTOCOL; } if ((host == null) || (host.equals(\"\"))) { host = DEFAULT_HOST; } if (form == null) { form = DEFAULT_FORM; } if (data == null) { throw new IllegalArgumentException(\"Invalid data\"); } URL url = new URL(protocol, host, form); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setDoInput(true); con.setUseCaches(false); con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\"); con.setRequestProperty(\"Content-length\", String.valueOf(data.length())); PrintStream out = new PrintStream(con.getOutputStream(), true); out.print(data); out.close(); BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); while (in.read",
        "ground_truth": "NO",
        "predict": "Line() != null) { } in.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void postData(String protocol, String host, String form, String data) throws Exception { if ((protocol == null) || (protocol.equals(\"\"))) { protocol = DEFAULT_PROTOCOL; } if ((host == null) || (host.equals(\"\"))) { host = DEFAULT_HOST; } if (form == null) { form = DEFAULT_FORM; } if (data == null) { throw new IllegalArgumentException(\"Invalid data\"); } URL url = new URL(protocol, host, form); URLConnection con = url.openConnection(); con.setDoOutput(true); con.setDoInput(true); con.setUseCaches(false); con.setRequestProperty(\"Content-type\", \"application/x-"
    },
    {
        "ID": 1637,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void read(String url) { session.beginTransaction(); try { Document doc = reader.read(new URL(url).openStream()); Element root = doc.getRootElement(); Dict dic = new Dict(); Vector<Cent> v = new Vector<Cent>(); for (Object o : root.elements()) { Element e = (Element) o; if (e.getName().equals(\"key\")) { dic.setName(e.getTextTrim()); } else if (e.getName().equals(\"audio\")) { dic.setAudio(e.getTextTrim()); } else if (e.getName().equals(\"pron\")) { dic.setPron(e.getTextTrim()); } else if (e.getName().equals(\"def\")) { dic.setDef(e.getTextTrim()); } else if (e.getName().equals(\"sent\")) { Cent cent = new Cent(); for (Object subo : e.elements()) { Element sube = (Element) subo; if (sube.getName().equals(\"orig\")) { cent.setOrig(sube.getTextTrim()); } else if (sube.getName().equals(\"trans\")) { cent.setTrans(sube.getTextTrim()); } } v.add(cent); } } if (dic.getName() == null || \"\".equals(dic.getName())) { session.getTransaction().commit(); return; } session.save(dic); dic.setCent(new HashSet<Cent>()); for (Cent c : v) { c.setDict(dic); dic.getCent().add(c); } session.getTransaction().commit(); } catch (Exception e) { e.printStackTrace(); session.getTransaction().rollback(); } }. \n Code2: public Constructor run() throws Exception { String path = \"META-INF/services/\" + ComponentApplicationContext.class.getName(); ClassLoader loader = Thread.currentThread().getContextClassLoader(); final Enumeration<URL> urls; if (loader == null) { urls = ComponentApplicationContext.class.getClassLoader().getResources(path); } else { urls = loader.getResources(path); } while (urls.hasMoreElements()) { URL url = urls.nextElement(); BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream())); try { String className = null; while ((className = reader.readLine()) != null) { final String name = className.trim(); if (!name.startsWith(\"#\") && !name.startsWith(\";\") && !name.startsWith(\"//\")) { final Class<?> cls; if (loader == null) { cls = Class.forName(name); } else { cls = Class.forName(name, true, loader); } int m = cls.getModifiers(); if (ComponentApplicationContext.class.isAssignableFrom(cls) && !Modifier.isAbstract(m) && !Modifier.isInterface(m)) { Constructor constructor = cls.getDeclaredConstructor(); if (!Modifier.isPublic(constructor.getModifiers())) { constructor.setAccessible(true); } return constructor; } else { throw new ClassCastException(cls.getName()); } } } } finally { reader.close(); } } throw new ComponentApplicationException(\"No \" + \"ComponentApplicationContext implementation \" + \"found.\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public FileChooserTestFrame() throws HeadlessException, MalformedURLException { super(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent aEvent) { System.exit(0); } }); Dimension dim = getToolkit().getScreenSize(); Rectangle abounds = getBounds(); setLocation((dim.width - abounds.width) / 2, (dim.height - abounds.height) / 2); setVisible(true); URL url = new URL(\"ftp://cendantstp/\"); char[] password = \"spnr\".toCharArray(); PasswordAuthentication passwordAuthentication = new PasswordAuthentication(\"spnr\", password); FTPRemoteFileSystemView remoteFileSystemView = new FTPRemoteFileSystemView(url, passwordAuthentication); JFileChooser fileChooser = new InsightRemoteFileChooser(remoteFileSystemView); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setMultiSelectionEnabled(true); File[] selectedFiles = null; if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) { selectedFiles = fileChooser.getSelectedFiles(); for (int i = 0; i < selectedFiles.length; i++) { if (selectedFiles[i] instanceof FTPFileFile) { FTPFileFile ftpFile = (FTPFileFile) selectedFiles[i]; logger.fine(ftpFile.getName()); logger.fine(ftpFile.getPath()); } else { logger.fine(selectedFiles[i].toString()); logger.fine(selectedFiles[i].getAbsolutePath()); } } } remoteFileSystemView.disconnect(); try { if (null != selectedFiles) { FTPClient ftpClient = new FTPClient(); InetAddress inetAddress = InetAddress.getByName(url.getHost()); ftpClient.connect(inetAddress); if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) { throw new FTPBrowseException(ftpClient.getReplyString()); } if (null != passwordAuthentication) { ftpClient.login(passwordAuthentication.getUserName(), new StringBuffer().append(passwordAuthentication.getPassword()).toString()); } for (int i = 0; i < selectedFiles.length; i++) { FTPFileFile file = (FTPFileFile) selectedFiles[i]; logger.fine(file.getPath()); FileOutputStream fos = new FileOutputStream(new File(\"d:/junk/ftp/test.txt\")); logger.fine(\"\" + ftpClient.retrieveFile(file.getPath().replaceAll(\"\\\\\\\\\", \"/\"), fos)); fos.close(); } } } catch (UnknownHostException e) { e.printStackTrace(); } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } System.exit(0); }. \n Code2: public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException { String urlStr = System.getProperty(propertyName); if (urlStr == null || urlStr.length() == 0) { return null; }",
        "ground_truth": "NO",
        "predict": " URL url = new URL(urlStr); InputStream in = url.openStream(); XMLConfigurator configurator = new XMLConfigurator(in); return configurator; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { new FileChooserTestFrame().run(); }. \n Code2: public static void main(String[] args) throws Exception { new FileChooserTestFrame().run(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { new FileChooserTestFrame().run(); }. \n Code2: public static void main(String[] args) throws Exception { new FileChooserTestFrame().run(); }. \n Response: YES"
    },
    {
        "ID": 1641,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static IProject createSimplemodelEnabledJavaProject() throws CoreException { IWorkspaceDescription desc = ResourcesPlugin.getWorkspace().getDescription(); desc.setAutoBuilding(false); ResourcesPlugin.getWorkspace().setDescription(desc); String name = \"TestProject\"; for (int i = 0; i < 1000; i++) { IProject project = ResourcesPlugin.getWorkspace().getRoot().getProject(name + i); if (project.exists()) continue; project.create(null); project.open(null); IProjectDescription description = project.getDescription(); String[] natures = description.getNatureIds(); String[] newNatures = new String[natures.length + 2]; System.arraycopy(natures, 0, newNatures, 0, natures.length); newNatures[natures.length] = JavaCore.NATURE_ID; newNatures[natures.length + 1] = SimplemodelNature.NATURE_ID; description.setNatureIds(newNatures); project.setDescription(description, null); IJavaProject javaProject = JavaCore.create(project); Set<IClasspathEntry> entries = new HashSet<IClasspathEntry>(); IVMInstall vmInstall = JavaRuntime.getDefaultVMInstall(); Path containerPath = new Path(JavaRuntime.JRE_CONTAINER); IPath vmPath = containerPath.append(vmInstall.getVMInstallType().getId()).append(vmInstall.getName()); entries.add(JavaCore.newContainerEntry(vmPath)); LibraryLocation[] locations = JavaRuntime.getLibraryLocations(vmInstall); for (LibraryLocation element : locations) { entries.add(JavaCore.newLibraryEntry(element.getSystemLibraryPath(), null, null)); } final Path srcPath = new Path(\"src\"); final IFolder src = project.getFolder(srcPath); final Path binPath = new Path(\"bin\"); final IFolder bin = project.getFolder(binPath); src.create(true, true, null); bin.create(true, true, null); entries.add(JavaCore.newSourceEntry(project.getFullPath().append(srcPath))); javaProject.setOutputLocation(project.getFullPath().append(binPath), null); javaProject.setRawClasspath(entries.toArray(new IClasspathEntry[entries.size()]), null); return project; } throw new RuntimeException(\"Failed\"); }. \n Code2: private void gravaOp(Vector<?> op) { PreparedStatement ps = null; String sql = null; ResultSet rs = null; int seqop = 0; Date dtFabrOP = null; try { sql = \"SELECT MAX(SEQOP) FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { seqop = rs.getInt(1) + 1; } rs.close(); ps.close(); con.commit(); sql = \"SELECT DTFABROP FROM PPOP WHERE CODEMP=? AND CODFILIAL=? AND CODOP=? AND SEQOP=?\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, txtSeqOP.getVlrInteger().intValue()); rs = ps.executeQuery(); if (rs.next()) { dtFabrOP = rs.getDate(1); } rs.close(); ps.close(); con.commit(); sql = \"INSERT INTO PPOP (CODEMP,CODFILIAL,CODOP,SEQOP,CODEMPPD,CODFILIALPD,CODPROD,SEQEST,DTFABROP,\" + \"QTDPREVPRODOP,QTDFINALPRODOP,DTVALIDPDOP,CODEMPLE,CODFILIALLE,CODLOTE,CODEMPTM,CODFILIALTM,CODTIPOMOV,\" + \"CODEMPAX,CODFILIALAX,CODALMOX,CODEMPOPM,CODFILIALOPM,CODOPM,SEQOPM,QTDDISTIOP,QTDSUGPRODOP)\" + \" VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"; ps = con.prepareStatement(sql); ps.setInt(1, Aplicativo.iCodEmp); ps.setInt(2, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(3, txtCodOP.getVlrInteger().intValue()); ps.setInt(4, seqop); ps.setInt(5, Aplicativo.iCodEmp); ps.setInt(6, ListaCampos.getMasterFilial(\"PPESTRUTURA\")); ps.setInt(7, ((Integer) op.elementAt(4)).intValue()); ps.setInt(8, ((Integer) op.elementAt(6)).intValue()); ps.setDate(9, dtFabrOP); ps.setFloat(10, ((BigDecimal) op.elementAt(7)).floatValue()); ps.setFloat(11, 0); ps.setDate(12, (Funcoes.strDateToSqlDate((String) op.elementAt(11)))); ps.setInt(13, Aplicativo.iCodEmp); ps.setInt(14, ListaCampos.getMasterFilial(\"EQLOTE\")); ps.setString(15, ((String) op.elementAt(10))); ps.setInt(16, Aplicativo.iCodEmp); ps.setInt(17, ListaCampos.getMasterFilial(\"EQTIPOMOV\")); ps.setInt(18, buscaTipoMov()); ps.setInt(19, ((Integer) op.elementAt(13)).intValue()); ps.setInt(20, ((Integer) op.elementAt(14)).intValue()); ps.setInt(21, ((Integer) op.elementAt(12)).intValue()); ps.setInt(22, Aplicativo.iCodEmp); ps.setInt(23, ListaCampos.getMasterFilial(\"PPOP\")); ps.setInt(24, t",
        "ground_truth": "NO",
        "predict": "xtCodOP.getVlrInteger().intValue()); ps.setInt(25, txtSeqOP.getVlrInteger().intValue()); ps.setFloat(26, ((BigDecimal) op.elementAt(8)).floatValue()); ps.setFloat(27, ((BigDecimal) op.elementAt(9)).floatValue()); ps.executeUpdate(); con.commit(); } catch (SQLException e) { e.printStackTrace(); } finally {\n try { rs.close(); ps.close(); con.commit(); } catch (SQLException e) { e.printStackTrace(); } } }\n\n}\n"
    },
    {
        "ID": 1644,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: public void appendMessage(MimeMessage oMsg) throws FolderClosedException, StoreClosedException, MessagingException { if (DebugFile.trace) { DebugFile.writeln(\"Begin DBFolder.appendMessage()\"); DebugFile.incIdent(); } final String EmptyString = \"\"; if (!((DBStore) getStore()).isConnected()) { if (DebugFile.trace) DebugFile.decIdent(); throw new StoreClosedException(getStore(), \"Store is not connected\"); } if (0 == (iOpenMode & READ_WRITE)) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open is READ_WRITE mode\"); } if ((0 == (iOpenMode & MODE_MBOX)) && (0 == (iOpenMode & MODE_BLOB))) { if (DebugFile.trace) DebugFile.decIdent(); throw new javax.mail.FolderClosedException(this, \"Folder is not open in MBOX nor BLOB mode\"); } String gu_mimemsg; if (oMsg.getClass().getName().equals(\"com.knowgate.hipermail.DBMimeMessage\")) { gu_mimemsg = ((DBMimeMessage) oMsg).getMessageGuid(); if (((DBMimeMessage) oMsg).getFolder() == null) ((DBMimeMessage) oMsg).setFolder(this); } else { gu_mimemsg = Gadgets.generateUUID(); } String gu_workarea = ((DBStore) getStore()).getUser().getString(DB.gu_workarea); int iSize = oMsg.getSize(); if (DebugFile.trace) DebugFile.writeln(\"MimeMessage.getSize() = \" + String.valueOf(iSize)); String sContentType, sContentID, sMessageID, sDisposition, sContentMD5, sDescription, sFileName, sEncoding, sSubject, sPriority, sMsgCharSeq; long lPosition = -1; try { sMessageID = oMsg.getMessageID(); if (sMessageID == null || EmptyString.equals(sMessageID)) { try { sMessageID = oMsg.getHeader(\"X-Qmail-Scanner-Message-ID\", null); } catch (Exception ignore) { } } if (sMessageID != null) sMessageID = MimeUtility.decodeText(sMessageID); sContentType = oMsg.getContentType(); if (sContentType != null) sContentType = MimeUtility.decodeText(sContentType); sContentID = oMsg.getContentID(); if (sContentID != null) sContentID = MimeUtility.decodeText(sContentID); sDisposition = oMsg.getDisposition(); if (sDisposition != null) sDisposition = MimeUtility.decodeText(sDisposition); sContentMD5 = oMsg.getContentMD5(); if (sContentMD5 != null) sContentMD5 = MimeUtility.decodeText(sContentMD5); sDescription = oMsg.getDescription(); if (sDescription != null) sDescription = MimeUtility.decodeText(sDescription); sFileName = oMsg.getFileName(); if (sFileName != null) sFileName = MimeUtility.decodeText(sFileName); sEncoding = oMsg.getEncoding(); if (sEncoding != null) sEncoding = MimeUtility.decodeText(sEncoding); sSubject = oMsg.getSubject(); if (sSubject != null) sSubject = MimeUtility.decodeText(sSubject); sPriority = null; sMsgCharSeq = null; } catch (UnsupportedEncodingException uee) { throw new MessagingException(uee.getMessage(), uee); } BigDecimal dPgMessage = null; try { dPgMessage = getNextMessage(); } catch (SQLException sqle) { throw new MessagingException(sqle.getMessage(), sqle); } String sBoundary = getPartsBoundary(oMsg); if (DebugFile.trace) DebugFile.writeln(\"part boundary is \\\"\" + (sBoundary == null ? \"null\" : sBoundary) + \"\\\"\"); if (sMessageID == null) sMessageID = gu_mimemsg; else if (sMessageID.length() == 0) sMessageID = gu_mimemsg; Timestamp tsSent; if (oMsg.getSentDate() != null) tsSent = new Timestamp(oMsg.getSentDate().getTime()); else tsSent = null; Timestamp tsReceived; if (oMsg.getReceivedDate() != null) tsReceived = new Timestamp(oMsg.getReceivedDate().getTime()); else tsReceived = new Timestamp(new java.util.Date().getTime()); try { String sXPriority = oMsg.getHeader(\"X-Priority\", null); if (sXPriority == null) sPriority = null; else { sPriority = \"\"; for (int x = 0; x < sXPriority.length(); x++) { char cAt = sXPriority.charAt(x); if (cAt >= (char) 48 || cAt <= (char) 57) sPriority += cAt; } sPriority = Gadgets.left(sPriority, 10); } } catch (MessagingException msge) { if (DebugFile.trace) DebugFile.writeln(\"MessagingException \" + msge.getMessage()); } boolean bIsSpam = false; try { String sXSpam = oMsg.getHeader(\"X-Spam-Flag\", null); if (sXSpam != null) bIsSpam = (sXSpam.toUpperCase().indexOf(\"YES\") >= 0 || sXSpam.toUpperCase().index",
        "ground_truth": "YES",
        "predict": "Of(\"NO\") >= 0); } catch (MessagingException msge) { if (DebugFile.trace) DebugFile.writeln(\"MessagingException \" + msge.getMessage()); } if (DebugFile.trace) { DebugFile.writeln(\"MimeMessage.getMessageID() = \" + sMessageID); DebugFile.writeln(\"MimeMessage.getContentType() = \" + sContentType); DebugFile.writeln(\"MimeMessage.getContentID() = \" + sContentID); DebugFile.writeln(\"MimeMessage.getDisposition() = \" + sDisposition); DebugFile.writeln(\"MimeMessage.getContentMD5() = \" + sContentMD5); DebugFile.writeln(\"MimeMessage.getDescription() = \" + sDescription); DebugFile.writeln(\"MimeMessage.getFileName() = \" + sFileName); DebugFile.writeln(\"MimeMessage.getEncoding() = \" + sEnc"
    },
    {
        "ID": 1651,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public int addRecipe(Recipe recipe) throws Exception { PreparedStatement pst1 = null; PreparedStatement pst2 = null; ResultSet rs = null; int retVal = -1; try { conn = getConnection(); pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\"); pst1.setString(1, recipe.getName()); pst1.setString(2, recipe.getInstructions()); pst1.setInt(3, recipe.getCategoryId()); if (pst1.executeUpdate() > 0) { pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\"); pst2.setString(1, recipe.getName()); pst2.setString(2, recipe.getInstructions()); pst2.setInt(3, recipe.getCategoryId()); rs = pst2.executeQuery(); conn.commit(); if (rs.next()) { int id = rs.getInt(1); addIngredients(recipe, id); MainFrame.recipePanel.update(); retVal = id; } else { retVal = -1; } } else { retVal = -1; } conn.commit(); } catch (Exception e) { conn.rollback(); MainFrame.appendStatusText(\"Can't add recipe, the exception was \" + e.getMessage()); } finally { try { if (rs != null) rs.close(); rs = null; if (pst1 != null) pst1.close(); pst1 = null; if (pst2 != null) pst2.close(); pst2 = null; } catch (SQLException sqle) { MainFrame.appendStatusText(\"Can't close database connection.\"); } } return retVal; }. \n Code2: protected Object insertSingle(Object name, Object fact) throws SQLException { DFAgentDescription dfd = (DFAgentDescription) fact; AID agentAID = dfd.getName(); String agentName = agentAID.getName(); DFAgentDescription dfdToReturn = null; String batchErrMsg = \"\"; Connection conn = getConnectionWrapper().getConnection(); PreparedStatements pss = getPreparedStatements(); try { dfdToReturn = (DFAgentDescription) removeSingle(dfd.getName()); Date leaseTime = dfd.getLeaseTime(); long lt = (leaseTime != null ? leaseTime.getTime() : -1); String descrId = getGUID(); pss.stm_insAgentDescr.setString(1, descrId); pss.stm_insAgentDescr.setString(2, agentName); pss.stm_insAgentDescr.setString(3, String.valueOf(lt)); pss.stm_insAgentDescr.executeUpdate(); saveAID(agentAID); Iterator iter = dfd.getAllLanguages(); if (iter.hasNext()) { pss.stm_insLanguage.clearBatch(); while (iter.hasNext()) { pss.stm_insLanguage.setString(1, descrId); pss.stm_insLanguage.setString(2, (String) iter.next()); pss.stm_insLanguage.addBatch(); } pss.stm_insLanguage.executeBatch(); } iter = dfd.getAllOntologies(); if (iter.hasNext()) { pss.stm_insOntology.clearBatch(); while (iter.hasNext()) { pss.stm_insOntology.setString(1, descrId); pss.stm_insOntology.setString(2, (String) iter.next()); pss.stm_insOntology.addBatch(); } pss.stm_insOntology.executeBatch(); } iter = dfd.getAllProtocols(); if (iter.hasNext()) { pss.stm_insProtocol.clearBatch(); while (iter.hasNext()) { pss.stm_insProtocol.setString(1, descrId); pss.stm_insProtocol.setString(2, (String) iter.next()); pss.stm_insProtocol.addBatch(); } pss.stm_insProtocol.executeBatch(); } saveServices(descrId, dfd.getAllServices()); regsCnt++; if (regsCnt > MAX_REGISTER_WITHOUT_CLEAN) { regsCnt = 0; clean(); } conn.commit(); } catch (SQLException sqle) { try { conn.rollback(); } catch (SQLException se) { logger.log(Logger.SEVERE, \"Rollback for incomplete insertion of DFD for agent \" + dfd.getName() + \" failed.\", se); } throw sqle; } return dfdToReturn; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static List<Properties> findExtensions() { URL url = null; try { List<Properties> extensions = new ArrayList<Properties>(); Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\"); while (res.hasMoreElements()) { url = res.nextElement(); Properties prop = new Properties(); prop.load(url.openStream()); extensions.add(prop); } return extensions; } catch (IOException ioe) { String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm(); throw new RuntimeException(msg, ioe); } }. \n Code2: protected Control createDialogArea(Composite parent) { Composite composite = (Composite) super.createDialogArea(parent); setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\")); setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\")); Composite content = new Composite(composite, SWT.NONE); content.setLayoutData(new GridData(GridData.FILL_BOTH)); final int ncol = 1; GridLayout layout = new GridLayout(1, false); layout.numColumns = ncol; content.setLayout(layout); Browser browser = null; Text text = null; try { browser = new Browser(content, SWT.NONE); browser.setLayoutData(new GridData(GridData.FILL_BOTH)); } catch (Throwable t) { text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL); text.setLayoutData(new GridData(GridData.FILL_BOTH",
        "ground_truth": "NO",
        "predict": ")); } return composite; }. \n Code3: public void setVisible(boolean visible) { if (visible) { if (browser != null) browser.setUrl(getURL()); } super.setVisible(visible); }. \n Code4: public void setVisible(boolean visible) { if (visible) { if (text != null) text.setText(getText()); } super.setVisible(visible); }. \n Code5: public void setVisible(boolean visible) { if (visible) { if (browser != null) browser.setUrl(getURL()); } super.setVisible(visible); }. \n Code6: public void setVisible(boolean visible) { if (visible) { if (text != null) text.setText(getText()); } super.setVisible(visible); }. \n Code7: public void setVisible(boolean visible) { if (visible) { if (browser !="
    },
    {
        "ID": 1654,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String merge(int width, int height) throws Exception { htErrors.clear(); sendGetImageRequests(width, height); Vector files = new Vector(); ConcurrentHTTPTransactionHandler c = new ConcurrentHTTPTransactionHandler(); c.setCache(cache); c.checkIfModified(false); for (int i = 0; i < vImageUrls.size(); i++) { if ((String) vImageUrls.get(i) != null) { c.register((String) vImageUrls.get(i)); } else { } } c.doTransactions(); vTransparency = new Vector(); for (int i = 0; i < vImageUrls.size(); i++) { if (vImageUrls.get(i) != null) { String path = c.getResponseFilePath((String) vImageUrls.get(i)); if (path != null) { String contentType = c.getHeaderValue((String) vImageUrls.get(i), \"content-type\"); if (contentType.startsWith(\"image\")) { files.add(path); vTransparency.add(htTransparency.get(vRank.get(i))); } } } } if (files.size() > 1) { File output = TempFiles.getFile(); String path = output.getPath(); ImageMerger.mergeAndSave(files, vTransparency, path, ImageMerger.GIF); imageName = output.getName(); imagePath = output.getPath(); return (imageName); } else if (files.size() == 1) { File f = new File((String) files.get(0)); File out = TempFiles.getFile(); BufferedInputStream is = new BufferedInputStream(new FileInputStream(f)); BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(out)); byte buf[] = new byte[1024]; for (int nRead; (nRead = is.read(buf, 0, 1024)) > 0; os.write(buf, 0, nRead)) ; os.flush(); os.close(); is.close(); imageName = out.getName(); return imageName; } else return \"\"; }. \n Code2: public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { long time = System.currentTimeMillis(); String text = request.getParameter(\"text\"); String parsedQueryString = request.getQueryString(); if (text == null) { String[] fonts = new File(ctx.getRealPath(\"/WEB-INF/fonts/\")).list(); text = \"accepted params: text,font,size,color,background,nocache,aa,break\"; response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(\"<html>\"); out.println(\"<body>\"); out.println(\"<p>\"); out.println(\"Usage: \" + request.getServletPath() + \"?params[]<BR>\"); out.println(\"Acceptable Params are: <UL>\"); out.println(\"<LI><B>text</B><BR>\"); out.println(\"The body of the image\"); out.println(\"<LI><B>font</B><BR>\"); out.println(\"Available Fonts (in folder '/WEB-INF/fonts/') <UL>\"); for (int i = 0; i < fonts.length; i++) { if (!\"CVS\".equals(fonts[i])) { out.println(\"<LI>\" + fonts[i]); } } out.println(\"</UL>\"); out.println(\"<LI><B>size</B><BR>\"); out.println(\"An integer, i.e. size=100\"); out.println(\"<LI><B>color</B><BR>\"); out.println(\"in rgb, i.e. color=255,0,0\"); out.println(\"<LI><B>background</B><BR>\"); out.println(\"in rgb, i.e. background=0,0,255\"); out.println(\"transparent, i.e. background=''\"); out.println(\"<LI><B>aa</B><BR>\"); out.println(\"antialias (does not seem to work), aa=true\"); out.println(\"<LI><B>nocache</B><BR>\"); out.println(\"if nocache is set, we will write out the image file every hit. Otherwise, will write it the first time and then read the file\"); out.println(\"<LI><B>break</B><BR>\"); out.println(\"An integer greater than 0 (zero), i.e. break=20\"); out.println(\"</UL>\"); out.println(\"</UL>\"); out.println(\"Example:<BR>\"); out.println(\"&lt;img border=1 src=\\\"\" + request.getServletPath() + \"?font=arial.ttf&text=testing&color=255,0,0&size=100\\\"&gt;<BR>\"); out.println(\"<img border=1 src='\" + request.getServletPath() + \"?font=arial.ttf&text=testing&color=255,0,0&size=100'><BR>\"); out.println(\"</body>\"); out.println(\"</html>\"); return; } String myFile = (request.getQueryString() == null) ? \"empty\" : PublicEncryptionFactory.digestString(parsedQueryString).replace('\\\\', '_').replace('/', '_'); myFile = Config.getStringProperty(\"PATH_TO_TITLE_IMAGES\") + myFile + \".png\"; File file = new File(ctx.getRealPath(myFile)); if (!file.exists() || (request.getParameter(\"nocache\") != null)) { StringTokenizer st = null; Iterator i = hm.entrySet().iterator(); while (i.hasNext()) { Map.Entry entry = (Map.Entry) i.next(); String key = (String) entry.getKey(); if (parsedQueryString.indexOf(key) > -1) { String val = (String) entry.getValue(); parsedQueryString = UtilMethods.replace(parsedQueryString, key, val); } } st = new StringTokenizer(parsedQueryString, \"&\"); while (st.hasMoreTokens()) { try { String x = st.nextToken(); String key = x.split(\"=\")[0]; String val = x.split(\"=\")[1]; if (\"text\".equals(key)) { text = val; } } catch (Exception e) { } } text = URLDecoder.decode(text, \"UTF-8\"); Logger.debug(this.getClass(), \"building title image:\" + file.getAbsolutePath()); file.createNewFile(); try { String font_file = \"/WEB-INF/fonts/arial.ttf\";",
        "ground_truth": "NO",
        "predict": " if (text.indexOf(\"font\") > -1) { font_file = text.split(\"font=\")[1].split(\"&\")[0]; } if (text.indexOf(\"size\") > -1) { size = text.split(\"size=\")[1].split(\"&\")[0]; } if (text.indexOf(\"color\") > -1) { color = text.split(\"color=\")[1].split(\"&\")[0]; } if (text.indexOf(\"background\") > -1) { background = text.split(\"background=\")[1].split(\"&\")[0]; } if (text.indexOf(\"aa\") > -1) { aa = text.split(\"aa=\")[1].split(\"&\")[0]; } if (text.indexOf(\"nocache\") > -1) { nocache = text.split(\"nocache=\")[1].split(\"&\")[0]; } if (text.indexOf(\"break\")"
    },
    {
        "ID": 1661,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static NotaFiscal insert(NotaFiscal objNF) { final Connection c = DBConnection.getConnection(); PreparedStatement pst = null; int result; if (c == null) { return null; } if (objNF == null) { return null; } try { c.setAutoCommit(false); String sql = \"\"; int idNotaFiscal; idNotaFiscal = NotaFiscalDAO.getLastCodigo(); if (idNotaFiscal < 1) { return null; } sql = \"INSERT INTO nota_fiscal \" + \"(id_nota_fiscal, id_fornecedor, total, data_emissao, data_cadastro, numero) \" + \"VALUES(?, ?, TRUNCATE(?,2), STR_TO_DATE(?,'%d/%m/%Y'), now(), ?) \"; pst = c.prepareStatement(sql); pst.setInt(1, idNotaFiscal); pst.setLong(2, objNF.getFornecedor().getCodigo()); pst.setString(3, new DecimalFormat(\"#0.00\").format(objNF.getValor())); pst.setString(4, objNF.getDataEmissaoFormatada()); pst.setString(5, objNF.getNumero()); result = pst.executeUpdate(); pst = null; if (result > 0) { Iterator<ItemNotaFiscal> itINF = (objNF.getItemNotaFiscal()).iterator(); while ((itINF != null) && (itINF.hasNext())) { ItemNotaFiscal objINF = (ItemNotaFiscal) itINF.next(); sql = \"\"; sql = \"INSERT INTO item_nota_fiscal \" + \"(id_nota_fiscal, id_produto, quantidade, subtotal) \" + \"VALUES(?, ?, ?, TRUNCATE(?,2))\"; pst = c.prepareStatement(sql); pst.setInt(1, idNotaFiscal); pst.setInt(2, objINF.getProduto().getCodigo()); pst.setInt(3, objINF.getQuantidade()); pst.setString(4, new DecimalFormat(\"#0.00\").format(objINF.getSubtotal())); result = pst.executeUpdate(); } } c.commit(); objNF.setCodigo(idNotaFiscal); } catch (final Exception e) { try { c.rollback(); } catch (final Exception e1) { System.out.println(\"[NotaFiscalDAO.insert.rollback] Erro ao inserir -> \" + e1.getMessage()); } System.out.println(\"[NotaFiscalDAO.insert] Erro ao inserir -> \" + e.getMessage()); objNF = null; } finally { DBConnection.closePreparedStatement(pst); DBConnection.closeConnection(c); } return objNF; }. \n Code2: protected boolean check(String username, String password, String realm, String nonce, String nc, String cnonce, String qop, String uri, String response, HttpServletRequest request) { try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(username.getBytes()); md.update((byte) ':'); md.update(realm.getBytes()); md.update((byte) ':'); md.update(password.getBytes()); byte[] ha1 = md.digest(); md.reset(); md.update(request.getMethod().getBytes()); md.update((byte) ':'); md.update(uri.getBytes()); byte[] ha2 = md.digest(); md.update(TypeUtil.toString(ha1, 16).getBytes()); md.update((byte) ':'); md.update(nonce.getBytes()); md.update((byte) ':'); md.update(nc.getBytes()); md.update((byte) ':'); md.update(cnonce.getBytes()); md.update((byte) ':'); md.update(qop.getBytes()); md.update((byte) ':'); md.update(TypeUtil.toString(ha2, 16).getBytes()); byte[] digest = md.digest(); return response.equals(encode(digest)); } catch (Exception e) { e.printStackTrace(); return false; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: String getLocation(Class clazz) { try { java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation(); String location = url.toString(); if (location.startsWith(\"jar\")) { url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL(); location = url.toString(); } if (location.startsWith(\"file\")) { java.io.File file = new java.io.File(url.getFile()); return file.getAbsolutePath(); } else { return url.toString(); } } catch (Throwable t) { } return Messages.getMessage(\"happyClientUnknownLocation\"); }. \n Code2: public String insertSmsInf(Sms sms) throws Exception { String smsId = null; Connection conn = null; PreparedStatement pstmt = null; StringBuffer buffer = new StringBuffer(); try { buffer.append(\"INSERT INTO COMTNSMS\\n\"); buffer.append(\" (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\"); buffer.append(\" FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\"); buffer.append(\"VALUES\\n\"); buffer.append(\"(?, ?, ?, ?, SYSDATE())\"); conn = SmsBasicDBUtil.getConnection(); conn.setAutoCommit(false); smsId = getNextId(conn); pstmt = conn.prepareStatement(buffer.toString()); int index = 0; pstmt.setString(++index, smsId); pstmt.setString(++index, sms.getTrnsmitTelno()); pstmt.setString(++index, sms.getTrnsmitCn()); pstmt.setString(++index, sms.getFrstRegisterId()); pstmt.executeUpdate(); conn.commit(); return smsId; } catch (Exception ex) { if (conn != null) { conn.rollback(); } throw ex; } finally { SmsBasicDBUtil.close(null, pstmt, conn); }",
        "ground_truth": "NO",
        "predict": " }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: String getLocation(Class clazz) { try { java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation(); String location = url.toString(); if (location.startsWith(\"jar\")) { url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL(); location = url.toString(); } if (location.startsWith(\"file\")) { java.io.File file = new java.io.File(url.getFile()); return file.getAbsolutePath(); } else { return url.toString(); } } catch (Throwable t) { } return Messages.getMessage(\"happyClientUnknownLocation\"); }. \n Code2: public String insertSmsInf(Sms sms) throws Exception { String smsId = null; Connection"
    },
    {
        "ID": 1663,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private final int copyFiles(File[] list, String dest, boolean dest_is_full_name) throws InterruptedException { Context c = ctx; File file = null; for (int i = 0; i < list.length; i++) { boolean existed = false; FileChannel in = null; FileChannel out = null; File outFile = null; file = list[i]; if (file == null) { error(c.getString(R.string.unkn_err)); break; } String uri = file.getAbsolutePath(); try { if (isStopReq()) { error(c.getString(R.string.canceled)); break; } long last_modified = file.lastModified(); String fn = file.getName(); outFile = dest_is_full_name ? new File(dest) : new File(dest, fn); if (file.isDirectory()) { if (depth++ > 40) { error(ctx.getString(R.string.too_deep_hierarchy)); break; } else if (outFile.exists() || outFile.mkdir()) { copyFiles(file.listFiles(), outFile.getAbsolutePath(), false); if (errMsg != null) break; } else error(c.getString(R.string.cant_md, outFile.getAbsolutePath())); depth--; } else { if (existed = outFile.exists()) { int res = askOnFileExist(c.getString(R.string.file_exist, outFile.getAbsolutePath()), commander); if (res == Commander.SKIP) continue; if (res == Commander.REPLACE) { if (outFile.equals(file)) continue; else outFile.delete(); } if (res == Commander.ABORT) break; } if (move) { long len = file.length(); if (file.renameTo(outFile)) { counter++; totalBytes += len; int so_far = (int) (totalBytes * conv); sendProgress(outFile.getName() + \" \" + c.getString(R.string.moved), so_far, 0); continue; } } in = new FileInputStream(file).getChannel(); out = new FileOutputStream(outFile).getChannel(); long size = in.size(); final long max_chunk = 524288; long pos = 0; long chunk = size > max_chunk ? max_chunk : size; long t_chunk = 0; long start_time = 0; int speed = 0; int so_far = (int) (totalBytes * conv); String sz_s = Utils.getHumanSize(size); String rep_s = c.getString(R.string.copying, fn); for (pos = 0; pos < size; ) { if (t_chunk == 0) start_time = System.currentTimeMillis(); sendProgress(rep_s + sizeOfsize(pos, sz_s), so_far, (int) (totalBytes * conv), speed); long transferred = in.transferTo(pos, chunk, out); pos += transferred; t_chunk += transferred; totalBytes += transferred; if (isStopReq()) { Log.d(TAG, \"Interrupted!\"); error(c.getString(R.string.canceled)); return counter; } long time_delta = System.currentTimeMillis() - start_time; if (time_delta > 0) { speed = (int) (1000 * t_chunk / time_delta); t_chunk = 0; } } in.close(); out.close(); in = null; out = null; if (i >= list.length - 1) sendProgress(c.getString(R.string.copied_f, fn) + sizeOfsize(pos, sz_s), (int) (totalBytes * conv)); counter++; } if (move) file.delete(); outFile.setLastModified(last_modified); final int GINGERBREAD = 9; if (android.os.Build.VERSION.SDK_INT >= GINGERBREAD) ForwardCompat.setFullPermissions(outFile); } catch (SecurityException e) { error(c.getString(R.string.sec_err, e.getMessage())); } catch (FileNotFoundException e) { error(c.getString(R.string.not_accs, e.getMessage())); } catch (ClosedByInterruptException e) { error(c.getString(R.string.canceled)); } catch (IOException e) { String msg = e.getMessage(); error(c.getString(R.string.acc_err, uri, msg != null ? msg : \"\")); } catch (RuntimeException e) { error(c.getString(R.string.rtexcept, uri, e.getMessage())); } finally { try { if (in != null) in.close(); if (out != null) out.close(); if (!move && errMsg != null && outFile != null && !existed) { Log.i(TAG, \"Deleting failed output file\"); outFile.delete(); } } catch (IOException e) { error(c.getString(R.string.acc_err, uri, e.getMessage())); } } } return counter; }. \n Code2: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getRead",
        "ground_truth": "NO",
        "predict": "VR(), dcmParser.getReadLength()); pdWriter.writePixelData(); out.flush(); out.close(); iis.close(); }\n Code3: private static void error(String msg) { Log.e(TAG, msg); }\n Code4: private static void sendProgress(String msg, int so_far, int total, int speed) { if (progress != null) progress.sendProgress(msg, so_far, total, speed); }\n Code5: private static void sendProgress(String msg, int so_far, int total) { sendProgress(msg, so_far, total, 0); }\n Code6: private static void sendProgress(String msg, int so_far) { sendProgress(msg, so_far, 0); }\n Code7: private static void sendProgress(String msg) { sendProgress(msg, 0); }\n Code8: private static void sendProgress(int so_far, int total) { sendProgress(null, so_"
    },
    {
        "ID": 1664,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void initialize(OAIRepository repo, String u, String v, String params) throws OAIException { oParent = repo; strVerb = v; strBaseURL = u; strParams = params; strResumptionToken = \"\"; iResumptionCount = 0; boolInitialized = false; boolValidResponse = false; iIndex = 1; iCount = -1; iCursor = -1; iRealCursor = -1; iCompleteListSize = -1; if (!strVerb.equals(\"ListIdentifiers\") && !strVerb.equals(\"ListMetadataFormats\") && !strVerb.equals(\"ListRecords\") && !strVerb.equals(\"ListSets\")) { throw new OAIException(OAIException.INVALID_VERB_ERR, \"Invalid verb\"); } if (strBaseURL.length() == 0) { throw new OAIException(OAIException.NO_BASE_URL_ERR, \"No baseURL\"); } if (params.length() > 0) { if (params.charAt(0) != '&') { params = \"&\" + params; } } try { URL url = new URL(strBaseURL + \"?verb=\" + strVerb + params); HttpURLConnection http = (HttpURLConnection) url.openConnection(); http = oParent.frndTrySend(http); DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance(); docFactory.setNamespaceAware(true); if (oParent.getValidation() == OAIRepository.VALIDATION_VERY_STRICT) { docFactory.setValidating(true); } else { docFactory.setValidating(false); } DocumentBuilder docBuilder = docFactory.newDocumentBuilder(); try { xml = docBuilder.parse(http.getInputStream()); boolValidResponse = true; } catch (IllegalArgumentException iae) { throw new OAIException(OAIException.CRITICAL_ERR, iae.getMessage()); } catch (SAXException se) { if (oParent.getValidation() != OAIRepository.VALIDATION_LOOSE) { throw new OAIException(OAIException.XML_PARSE_ERR, se.getMessage() + \" Try loose validation.\"); } else { try { http.disconnect(); url = new URL(strBaseURL + \"?verb=\" + strVerb + params); http = (HttpURLConnection) url.openConnection(); http = oParent.frndTrySend(http); xml = docBuilder.parse(priCreateDummyResponse(http.getInputStream())); } catch (SAXException se2) { throw new OAIException(OAIException.XML_PARSE_ERR, se2.getMessage()); } } } namespaceNode = xml.createElement(strVerb); namespaceNode.setAttribute(\"xmlns:oai\", OAIRepository.XMLNS_OAI + strVerb); namespaceNode.setAttribute(\"xmlns:dc\", OAIRepository.XMLNS_DC); PrefixResolverDefault prefixResolver = new PrefixResolverDefault(namespaceNode); XPath xpath = new XPath(\"//oai:\" + strVerb + \"/oai:\" + priGetMainNodeName(), null, prefixResolver, XPath.SELECT, null); XPathContext xpathSupport = new XPathContext(); int ctxtNode = xpathSupport.getDTMHandleFromNode(xml); XObject list = xpath.execute(xpathSupport, ctxtNode, prefixResolver); Node node = list.nodeset().nextNode(); if (node == null) { namespaceNode.setAttribute(\"xmlns:oai\", OAIRepository.XMLNS_OAI_2_0); prefixResolver = new PrefixResolverDefault(namespaceNode); xpath = new XPath(\"/oai:OAI-PMH\", null, prefixResolver, XPath.SELECT, null); list = xpath.execute(xpathSupport, ctxtNode, prefixResolver); node = list.nodeset().nextNode(); if (node == null) { namespaceNode.setAttribute(\"xmlns:oai\", OAIRepository.XMLNS_OAI_1_0 + strVerb); } else { xpath = new XPath(\"oai:OAI-PMH/oai:error\", null, prefixResolver, XPath.SELECT, null); list = xpath.execute(xpathSupport, ctxtNode, prefixResolver); NodeList nl = list.nodelist(); if (nl.getLength() > 0) { oParent.frndSetErrors(nl); throw new OAIException(OAIException.OAI_ERR, oParent.getLastOAIError().getCode() + \": \" + oParent.getLastOAIError().getReason()); } } } xpath = new XPath(\"//oai:\" + strVerb + \"/oai:\" + priGetMainNodeName(), null, prefixResolver, XPath.SELECT, null); list = xpath.execute(xpathSupport, ctxtNode, prefixResolver); nodeList = list.nodelist(); boolInitialized = true; oParent.frndSetNamespaceNode(namespaceNode); xpath = new XPath(\"//oai:requestURL | //oai:request\", null, prefixResolver, XPath.SELECT, null); node = xpath.execute(xpathSupport, ctxtNode, prefixResolver).nodeset().nextNode(); if (node != null) { oParent.frndSetRequest(node); } oParent.frndSetResponseDate(getResponseDate()); docFactory = null; docBuilder = null; url = null; prefixResolver = null; xpathSupport = null; xpath = null; } catch (TransformerException te) { throw new OAIException(OAIException.CRITICAL_ERR, te.getMessage()); } catch (MalformedURLException mue) { throw new OAIException(OAIException.CRITICAL_ERR, mue.getMessage()); } catch (FactoryConfigurationError fce) { throw new OAIException(OAIException.CRITICAL_ERR, fce.getMessage()); } catch (ParserConfigurationException pce) { throw new OAIException(OAIException.CRITICAL_ERR, pce.getMessage()); } catch (IOException ie) { throw new OAIException(OAIException.CRITICAL_ERR, ie.getMessage()); } }. \n Code2: private byte[] szyfrujKlucz(byte[] kluczSesyjny) { byte[] zaszyfrowanyKlucz = null; byte[] klucz = null; try { MessageDigest skrot = MessageDigest.getInstance(\"SHA-1\"); skrot.update(haslo.getBytes()); byte[] skrot",
        "ground_truth": "NO",
        "predict": "Klucz = skrot.digest(); klucz = new byte[kluczSesyjny.length + skrotKlucz.length]; for (int i = 0; i < kluczSesyjny.length; i++) { klucz[i] = kluczSesyjny[i]; } for (int i = 0; i < skrotKlucz.length; i++) { klucz[i + kluczSesyjny.length] = skrotKlucz[i]; } } catch (NoSuchAlgorithmException e) { } return klucz; }\n Code3: private String szyfrujKlucz(String kluczSesyjny) { String zaszyfrowanyKlucz = null; try { MessageDigest skrot = MessageDigest.getInstance(\"SHA-1\"); skrot.update(kl"
    },
    {
        "ID": 1667,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public void sortPlayersTurn() { Token tempT = new Token(); Player tempP = new Player(\"test name\", tempT); int tempN = 0; boolean exchangeMade = true; for (int i = 0; i < playerNum - 1 && exchangeMade; i++) { exchangeMade = false; for (int j = 0; j < playerNum - 1 - i; j++) { if (diceSum[j] < diceSum[j + 1]) { tempP = players[j]; tempN = diceSum[j]; players[j] = players[j + 1]; diceSum[j] = diceSum[j + 1]; players[j + 1] = tempP; diceSum[j + 1] = tempN; exchangeMade = true; } } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] argv) { if (1 < argv.length) { File[] sources = Source(argv[0]); if (null != sources) { for (File src : sources) { File[] targets = Target(src, argv); if (null != targets) { final long srclen = src.length(); try { FileChannel source = new FileInputStream(src).getChannel(); try { for (File tgt : targets) { FileChannel target = new FileOutputStream(tgt).getChannel(); try { source.transferTo(0L, srclen, target); } finally { target.close(); } System.out.printf(\"Updated %s\\n\", tgt.getPath()); File[] deletes = Delete(src, tgt); if (null != deletes) { for (File del : deletes) { if (SVN) { if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath()); } } if (SVN) SvnAdd(tgt); } } finally { source.close(); } } catch (Exception exc) { exc.printStackTrace(); System.exit(1); } } } System.exit(0); } else { System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]); System.exit(1); } } else { usage(); System.exit(1); } }. \n Code2: public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String",
        "ground_truth": "YES",
        "predict": " rutaDestino) { try { FileChannel canalOrigen = new FileInputStream(rutaFicheroOrigen).getChannel(); FileChannel canalDestino = new FileOutputStream(rutaDestino).getChannel(); canalOrigen.transferTo(0L, canalOrigen.size(), canalDestino); canalOrigen.close(); canalDestino.close(); return true; } catch (Exception exc) { return false; } }. \n Code2: public boolean SvnAdd(File fichero) { return SvnAdd(fichero.getPath()); }. \n Code2: public boolean SvnAdd(String fichero) { return SvnAdd(fichero, true); }. \n Code2: public boolean SvnAdd(String fichero, boolean commit) { return SvnAdd(fichero, commit, false); }. \n Code2: public boolean SvnAdd(String fichero, boolean commit, boolean force) {"
    },
    {
        "ID": 1669,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Code2: public static String MD5(String str, String encoding) { MessageDigest messageDigest = null; try { messageDigest = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } messageDigest.reset(); try { messageDigest.update(str.getBytes(encoding)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } byte[] byteArray = messageDigest.digest(); StringBuffer md5StrBuff = new StringBuffer(); for (int i = 0; i < byteArray.length; i++) { if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i])); } return md5StrBuff.toString(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run() { long time = System.currentTimeMillis(); logger.info(\"Version: \" + version); String hostname = properties.getProperty(\"mercuriushost\"); String protocol = properties.getProperty(\"mercuriusprotocol\"); String port = properties.getProperty(\"mercuriusport\"); String path = properties.getProperty(\"mercuriuspath\"); String action = properties.getProperty(\"mercuriusaction\"); logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time)); String xml = timexfrmk.getUnsynchedSessionsXMLFormat(); logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time)); if (timexfrmk.getSessionCount() > 0) { try { logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time)); String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\"); data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\"); if (isAdminFeedKeySet()) { data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\"); logger.debug(\"Using adminfeedkey to authenticate\"); } else { Authenticator.setDefault(new CustomAuthenticator(user, password)); logger.debug(\"Using user/pwd to authenticate\"); } String u = protocol + \"://\" + hostname + \":\" + port + path; logger.debug(\"Posting xml data to: \" + u); URL url = new URL(u); URLConnection conn = url.openConnection(); conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version); conn.setDoOutput(true); OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream()); wr.write(data); wr.flush(); BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; StringBuffer s = new StringBuffer(); while ((line = rd.readLine()) != null) { s.append(line); } if (s.length() > 0) { logger.debug(s.to",
        "ground_truth": "NO",
        "predict": "String()); } wr.close(); rd.close(); } catch (Exception e) { e.printStackTrace(); } }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void run() { long time = System.currentTimeMillis(); logger.info(\"Version: \" + version); String hostname = properties.getProperty(\"mercuriushost\"); String protocol = properties.getProperty(\"mercuriusprotocol\"); String port = properties.getProperty(\"mercuriusport\"); String path = properties.getProperty(\"mercuriuspath\"); String action = properties.getProperty(\"mercuriusaction\"); logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time)); String xml = timexfrmk.getUnsynchedSessionsXMLFormat(); logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time)); if (timexfrmk."
    },
    {
        "ID": 1675,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static boolean writeProperties(Map<String, String> customProps, File destination) throws IOException { synchronized (PropertiesIO.class) { L.info(Msg.msg(\"PropertiesIO.writeProperties.start\")); File tempFile = null; BufferedInputStream existingCfgInStream = null; FileInputStream in = null; FileOutputStream out = null; PrintStream ps = null; FileChannel fromChannel = null, toChannel = null; String line = null; try { existingCfgInStream = new BufferedInputStream(destination.exists() ? new FileInputStream(destination) : defaultPropertiesStream()); tempFile = File.createTempFile(\"properties-\", \".tmp\", null); ps = new PrintStream(tempFile); while ((line = Utils.readLine(existingCfgInStream)) != null) { String lineReady2write = setupLine(line, customProps); ps.println(lineReady2write); } destination.getParentFile().mkdirs(); in = new FileInputStream(tempFile); out = new FileOutputStream(destination, false); fromChannel = in.getChannel(); toChannel = out.getChannel(); fromChannel.transferTo(0, fromChannel.size(), toChannel); L.info(Msg.msg(\"PropertiesIO.writeProperties.done\").replace(\"#file#\", destination.getAbsolutePath())); return true; } finally { if (existingCfgInStream != null) existingCfgInStream.close(); if (ps != null) ps.close(); if (fromChannel != null) fromChannel.close(); if (toChannel != null) toChannel.close(); if (out != null) out.close(); if (in != null) in.close(); if (tempFile != null && tempFile.exists()) tempFile.delete(); } } }. \n Code2: private LinkedList<Datum> processDatum(Datum dataset) { ArrayList<Object[]> markerTestResults = new ArrayList<Object[]>(); ArrayList<Object[]> alleleEstimateResults = new ArrayList<Object[]>(); boolean hasAlleleNames = false; String blank = new String(\"\"); MarkerPhenotypeAdapter theAdapter; if (dataset.getDataType().equals(MarkerPhenotype.class)) { theAdapter = new MarkerPhenotypeAdapter((MarkerPhenotype) dataset.getData()); } else theAdapter = new MarkerPhenotypeAdapter((Phenotype) dataset.getData()); int numberOfMarkers = theAdapter.getNumberOfMarkers(); if (numberOfMarkers == 0) { return calculateBLUEsFromPhenotypes(theAdapter, dataset.getName()); } int numberOfCovariates = theAdapter.getNumberOfCovariates(); int numberOfFactors = theAdapter.getNumberOfFactors(); int numberOfPhenotypes = theAdapter.getNumberOfPhenotypes(); int expectedIterations = numberOfPhenotypes * numberOfMarkers; int iterationsSofar = 0; int percentFinished = 0; File tempFile = null; File ftestFile = null; File blueFile = null; BufferedWriter ftestWriter = null; BufferedWriter BLUEWriter = null; String ftestHeader = \"Trait\\tMarker\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tmarker_F\\tmarker_p\\tperm_p\\tmarkerR2\\tmarkerDF\\tmarkerMS\\terrorDF\\terrorMS\\tmodelDF\\tmodelMS\"; String BLUEHeader = \"Trait\\tMarker\\tObs\\tLocus\\tLocus_pos\\tChr\\tChr_pos\\tAllele\\tEstimate\"; if (writeOutputToFile) { String outputbase = outputName; if (outputbase.endsWith(\".txt\")) { int index = outputbase.lastIndexOf(\".\"); outputbase = outputbase.substring(0, index); } String datasetNameNoSpace = dataset.getName().trim().replaceAll(\"\\\\ \", \"_\"); ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.txt\"); int count = 0; while (ftestFile.exists()) { count++; ftestFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest\" + count + \".txt\"); } blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs.txt\"); count = 0; while (blueFile.exists()) { count++; blueFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_BLUEs\" + count + \".txt\"); } tempFile = new File(outputbase + \"_\" + datasetNameNoSpace + \"_ftest.tmp\"); try { if (permute) { ftestWriter = new BufferedWriter(new FileWriter(tempFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } else { ftestWriter = new BufferedWriter(new FileWriter(ftestFile)); ftestWriter.write(ftestHeader); ftestWriter.newLine(); } if (reportBLUEs) { BLUEWriter = new BufferedWriter(new FileWriter(blueFile)); BLUEWriter.write(BLUEHeader); BLUEWriter.newLine(); } } catch (IOException e) { myLogger.error(\"Failed to open file for output\"); myLogger.error(e); return null; } } if (permute) { minP = new double[numberOfPhenotypes][numberOfPermutations]; for (int i = 0; i < numberOfPermutations; i++) { for (int j = 0; j < numberOfPhenotypes; j++) { minP[j][i] = 1; } } } for (int ph = 0; ph < numberOfPhenotypes; ph++) { double[] phenotypeData = theAdapter.getPhenotypeValues(ph); boolean[] missing = theAdapter.getMissingPhenotypes(ph); ArrayList<String[]> factorList = MarkerPhenotypeAdapterUtils.getFactorList(theAdapter, ph, missing); ArrayList<double[]> covariateList = MarkerPhenotypeAdapterUtils.getCovariateList(theAdapter, ph, missing); double[][] permutedData = null; if (permute) { permutedData = permuteData(phenotypeData, missing, factorList, covariateList, theAdapter); } for (int m = 0; m < numberOfMarkers; m++) { Object[] markerData = theAdapter.getMarkerValue(ph, m); boolean[] finalMissing = new boolean[missing.length]; System.arraycopy(missing, 0, finalMissing, 0, missing.length); MarkerPhenotypeAdapterUtils.updateMissing(finalMissing, theAdapter.getMissingMarkers(ph, m)); int[]",
        "ground_truth": "NO",
        "predict": " permutation = null; if (permute) { permutation = permute(phenotypeData, finalMissing, factorList, covariateList, theAdapter); } for (int p = 0; p < numberOfPermutations; p++) { if (permute) { markerTestResults.add(new Object[]{markerData[0], markerData[1], markerData[2], markerData[3], markerData[4], markerData[5], markerData[6], markerData[7], markerData[8], markerData[9], markerData[10], markerData[11], markerData[12], markerData[13], markerData[14], markerData[15], markerData[16], markerData[17], markerData[18], markerData[19], markerData[20], markerData[21], markerData[22], markerData[23], markerData[24], markerData[25], markerData[26], markerData[27], markerData[28], marker"
    },
    {
        "ID": 1688,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private String getEncoding() throws IOException { BufferedReader reader = null; String encoding = null; try { URLConnection connection = url.openConnection(); Map<String, List<String>> header = connection.getHeaderFields(); for (Map.Entry<String, List<String>> entry : header.entrySet()) { if (entry.getKey().toLowerCase().equals(\"content-type\")) { String item = entry.getValue().toString().toLowerCase(); if (item.contains(\"charset\")) { encoding = extractEncoding(item); if (encoding != null && !encoding.isEmpty()) return encoding; } } } reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line; while ((line = reader.readLine()) != null) { line = line.toLowerCase(); if (line.contains(\"charset\") || line.contains(\"encoding\")) { encoding",
        "ground_truth": "NO",
        "predict": " = extractEncoding(line); if (encoding != null && !encoding.isEmpty()) return encoding; } } } finally { if (reader != null) reader.close(); } return encoding; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static String extractEncoding(String item) { if (item.contains(\"charset\")) { String[] split = item.split(\"=\"); return split[1].trim(); } return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static String uid(String uid) { return uid.replaceAll(\"\\\\s\", \"\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO."
    },
    {
        "ID": 1691,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static final String hash(String input, String algorithm) { try { MessageDigest dig = MessageDigest.getInstance(algorithm); dig.update(input.getBytes()); StringBuffer result = new StringBuffer(); byte[] digest = dig.digest(); String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" }; for (int i = 0; i < digest.length; i++) { int u = digest[i]; u &= 0x000000FF; int highCount = u / 16; int lowCount = u - (highCount * 16); result.append(hex[highCount]); result.append(hex[lowCount]); } return result.toString(); } catch (NoSuchAlgorithmException e) { return null; } }. \n Code2: public",
        "ground_truth": "NO",
        "predict": " static void main(String[] args) throws Exception { if (args.length != 3) { System.out.println(\"Usage: java -cp .:dcm4che.jar org.dcm4che.imageio.plugins.Dcm2Nema convert <src> <dest>\"); return; } String src = args[0]; String dest = args[1]; String studyUID = args[2]; String seriesUID = args[3]; String instUID = args[4]; String classUID = args[5]; String fmi = args[6]; String skipGroupLen = args[7]; String encodeParam = args[8]; String hash = args[9]; String algorithm = args[10]; if (src.startsWith(\"file:\")) { src = src.substring(5); } if (src.startsWith(\"http:\")) { src = src.substring(5); } if (src.startsWith(\"https:\")) { src = src.substring(6"
    },
    {
        "ID": 1697,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { LogFrame.getInstance(); for (int i = 0; i < args.length; i++) { String arg = args[i]; if (arg.trim().startsWith(DEBUG_PARAMETER_NAME + \"=\")) { properties.put(DEBUG_PARAMETER_NAME, arg.trim().substring(DEBUG_PARAMETER_NAME.length() + 1).trim()); if (properties.getProperty(DEBUG_PARAMETER_NAME).toLowerCase().equals(DEBUG_TRUE)) { DEBUG = true; } } else if (arg.trim().startsWith(MODE_PARAMETER_NAME + \"=\")) { properties.put(MODE_PARAMETER_NAME, arg.trim().substring(MODE_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(AUTOCONNECT_PARAMETER_NAME + \"=\")) { properties.put(AUTOCONNECT_PARAMETER_NAME, arg.trim().substring(AUTOCONNECT_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(SITE_CONFIG_URL_PARAMETER_NAME + \"=\")) { properties.put(SITE_CONFIG_URL_PARAMETER_NAME, arg.trim().substring(SITE_CONFIG_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(LOAD_PLUGINS_PARAMETER_NAME + \"=\")) { properties.put(LOAD_PLUGINS_PARAMETER_NAME, arg.trim().substring(LOAD_PLUGINS_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(ONTOLOGY_URL_PARAMETER_NAME + \"=\")) { properties.put(ONTOLOGY_URL_PARAMETER_NAME, arg.trim().substring(ONTOLOGY_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(REPOSITORY_PARAMETER_NAME + \"=\")) { properties.put(REPOSITORY_PARAMETER_NAME, arg.trim().substring(REPOSITORY_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(ONTOLOGY_TYPE_PARAMETER_NAME + \"=\")) { properties.put(ONTOLOGY_TYPE_PARAMETER_NAME, arg.trim().substring(ONTOLOGY_TYPE_PARAMETER_NAME.length() + 1).trim()); if (!(properties.getProperty(ONTOLOGY_TYPE_PARAMETER_NAME).equals(ONTOLOGY_TYPE_RDFXML) || properties.getProperty(ONTOLOGY_TYPE_PARAMETER_NAME).equals(ONTOLOGY_TYPE_TURTLE) || properties.getProperty(ONTOLOGY_TYPE_PARAMETER_NAME).equals(ONTOLOGY_TYPE_NTRIPPLES))) System.out.println(\"WARNING! Unknown ontology type: '\" + properties.getProperty(ONTOLOGY_TYPE_PARAMETER_NAME) + \"' (Known types are: '\" + ONTOLOGY_TYPE_RDFXML + \"', '\" + ONTOLOGY_TYPE_TURTLE + \"', '\" + ONTOLOGY_TYPE_NTRIPPLES + \"')\"); } else if (arg.trim().startsWith(OWLIMSERVICE_URL_PARAMETER_NAME + \"=\")) { properties.put(OWLIMSERVICE_URL_PARAMETER_NAME, arg.trim().substring(OWLIMSERVICE_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOCSERVICE_URL_PARAMETER_NAME + \"=\")) { properties.put(DOCSERVICE_URL_PARAMETER_NAME, arg.trim().substring(DOCSERVICE_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOC_ID_PARAMETER_NAME + \"=\")) { properties.put(DOC_ID_PARAMETER_NAME, arg.trim().substring(DOC_ID_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(ANNSET_NAME_PARAMETER_NAME + \"=\")) { properties.put(ANNSET_NAME_PARAMETER_NAME, arg.trim().substring(ANNSET_NAME_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(EXECUTIVE_SERVICE_URL_PARAMETER_NAME + \"=\")) { properties.put(EXECUTIVE_SERVICE_URL_PARAMETER_NAME, arg.trim().substring(EXECUTIVE_SERVICE_URL_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(USER_ID_PARAMETER_NAME + \"=\")) { properties.put(USER_ID_PARAMETER_NAME, arg.trim().substring(USER_ID_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(USER_PASSWORD_PARAMETER_NAME + \"=\")) { properties.put(USER_PASSWORD_PARAMETER_NAME, arg.trim().substring(USER_PASSWORD_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(EXECUTIVE_PROXY_FACTORY_PARAMETER_NAME + \"=\")) { properties.put(EXECUTIVE_PROXY_FACTORY_PARAMETER_NAME, arg.trim().substring(EXECUTIVE_PROXY_FACTORY_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME + \"=\")) { properties.put(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME, arg.trim().substring(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME.length() + 1).trim()); Rich",
        "ground_truth": "NO",
        "predict": "DocumentsService.setProxyFactory(new ProxyFactory(properties.getProperty(DOCSERVICE_PROXY_FACTORY_PARAMETER_NAME))); } else if (arg.trim().startsWith(EXECUTIVE_PROXY_PARAMETER_NAME + \"=\")) { properties.put(EXECUTIVE_PROXY_PARAMETER_NAME, arg.trim().substring(EXECUTIVE_PROXY_PARAMETER_NAME.length() + 1).trim()); } else if (arg.trim().startsWith(DOCSERVICE_PROXY_PARAMETER_NAME + \"=\")) { properties.put(DOCSERVICE_PROXY_PARAMETER_NAME, arg.trim().substring(DOCSERVICE_PROXY_PARAMETER_NAME.length() + 1).trim()); RichDocumentsService.setProxy(properties.getProperty(DOCSERVICE_PROXY_PAR"
    },
    {
        "ID": 1701,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Throwable { Options options = new Options(); options.addOption(new CommandLineOptionBuilder(\"cas\", \"cas file\").isRequired(true).build()); options.addOption(new CommandLineOptionBuilder(\"o\", \"output directory\").longName(\"outputDir\").isRequired(true).build()); options.addOption(new CommandLineOptionBuilder(\"tempDir\", \"temp directory\").build()); options.addOption(new CommandLineOptionBuilder(\"prefix\", \"file prefix for all generated files ( default \" + DEFAULT_PREFIX + \" )\").build()); options.addOption(new CommandLineOptionBuilder(\"trim\", \"trim file in sfffile's tab delimmed trim format\").build()); options.addOption(new CommandLineOptionBuilder(\"trimMap\", \"trim map file containing tab delimited trimmed fastX file to untrimmed counterpart\").build()); options.addOption(new CommandLineOptionBuilder(\"chromat_dir\", \"directory of chromatograms to be converted into phd \" + \"(it is assumed the read data for these chromatograms are in a fasta file which the .cas file knows about\").build()); options.addOption(new CommandLineOptionBuilder(\"s\", \"cache size ( default \" + DEFAULT_CACHE_SIZE + \" )\").longName(\"cache_size\").build()); options.addOption(new CommandLineOptionBuilder(\"useIllumina\", \"any FASTQ files in this assembly are encoded in Illumina 1.3+ format (default is Sanger)\").isFlag(true).build()); options.addOption(new CommandLineOptionBuilder(\"useClosureTrimming\", \"apply additional contig trimming based on JCVI Closure rules\").isFlag(true).build()); CommandLine commandLine; try { commandLine = CommandLineUtils.parseCommandLine(options, args); int cacheSize = commandLine.hasOption(\"s\") ? Integer.parseInt(commandLine.getOptionValue(\"s\")) : DEFAULT_CACHE_SIZE; File casFile = new File(commandLine.getOptionValue(\"cas\")); File casWorkingDirectory = casFile.getParentFile(); ReadWriteDirectoryFileServer outputDir = DirectoryFileServer.createReadWriteDirectoryFileServer(commandLine.getOptionValue(\"o\")); String prefix = commandLine.hasOption(\"prefix\") ? commandLine.getOptionValue(\"prefix\") : DEFAULT_PREFIX; TrimDataStore trimDatastore; if (commandLine.hasOption(\"trim\")) { List<TrimDataStore> dataStores = new ArrayList<TrimDataStore>(); final String trimFiles = commandLine.getOptionValue(\"trim\"); for (String trimFile : trimFiles.split(\",\")) { System.out.println(\"adding trim file \" + trimFile); dataStores.add(new DefaultTrimFileDataStore(new File(trimFile))); } trimDatastore = MultipleDataStoreWrapper.createMultipleDataStoreWrapper(TrimDataStore.class, dataStores); } else { trimDatastore = TrimDataStoreUtil.EMPTY_DATASTORE; } CasTrimMap trimToUntrimmedMap; if (commandLine.hasOption(\"trimMap\")) { trimToUntrimmedMap = new DefaultTrimFileCasTrimMap(new File(commandLine.getOptionValue(\"trimMap\"))); } else { trimToUntrimmedMap = new UnTrimmedExtensionTrimMap(); } boolean useClosureTrimming = commandLine.hasOption(\"useClosureTrimming\"); TraceDataStore<FileSangerTrace> sangerTraceDataStore = null; Map<String, File> sangerFileMap = null; ReadOnlyDirectoryFileServer sourceChromatogramFileServer = null; if (commandLine.hasOption(\"chromat_dir\")) { sourceChromatogramFileServer = DirectoryFileServer.createReadOnlyDirectoryFileServer(new File(commandLine.getOptionValue(\"chromat_dir\"))); sangerTraceDataStore = new SingleSangerTraceDirectoryFileDataStore(sourceChromatogramFileServer, \".scf\"); sangerFileMap = new HashMap<String, File>(); Iterator<String> iter = sangerTraceDataStore.getIds(); while (iter.hasNext()) { String id = iter.next(); sangerFileMap.put(id, sangerTraceDataStore.get(id).getFile()); } } PrintWriter logOut = new PrintWriter(new FileOutputStream(outputDir.createNewFile(prefix + \".log\")), true); PrintWriter consensusOut = new PrintWriter(new FileOutputStream(outputDir.createNewFile(prefix + \".consensus.fasta\")), true); PrintWriter traceFilesOut = new PrintWriter(new FileOutputStream(outputDir.createNewFile(prefix + \".traceFiles.txt\")), true); PrintWriter referenceFilesOut = new PrintWriter(new FileOutputStream(outputDir.createNewFile(prefix + \".referenceFiles.txt\")), true); long startTime = System.currentTimeMillis(); logOut.println(System.getProperty(\"user.dir\")); final ReadWriteDirectoryFileServer tempDir; if (!commandLine.hasOption(\"tempDir\")) { tempDir = DirectoryFileServer.createTemporaryDirectoryFileServer(DEFAULT_TEMP_DIR); } else { File t = new File(commandLine.getOptionValue(\"tempDir\")); IOUtil.mkdirs(t); tempDir = DirectoryFileServer.createTemporaryDirectoryFileServer(t); } try { if (!outputDir.contains(\"chromat_dir\")) { outputDir.createNewDir(\"chromat_dir\"); } if (sourceChromatogramFileServer != null) { for (File f : sourceChromatogramFileServer) { String name = f.getName(); OutputStream out = new FileOutputStream(outputDir.createNewFile(\"chromat_dir/\" + name)); final FileInputStream fileInputStream = new FileInputStream(f); try { IOUtils.copy(fileInputStream, out); } finally { IOUtils.closeQuietly(out); IOUtils.closeQuietly(fileInputStream); } } } FastQQualityCodec qualityCodec = commandLine.hasOption(\"useIllumina\") ? FastQQualityCodec.ILLUMINA : FastQQualityCodec.SANGER; CasDataStoreFactory casDataStoreFactory = new MultiCasDataStoreFactory(new H2SffCasDataStoreFactory(casWorkingDirectory, tempDir, EmptyDataStoreFilter.INSTANCE), new H2FastQCasDataStoreFactory(casWorkingDirectory, trimToUntrimmedMap, qualityCodec, tempDir.getRootDir()), new FastaCasDataStoreFactory(casWorkingDirectory, trimToUntrimmedMap, cacheSize)); final SliceMapFactory sliceMapFactory = new LargeNoQualitySliceMapFactory(); CasAssembly casAssembly = new DefaultCasAssembly.Builder(casFile, casDataStoreFactory, trimDatastore, trimTo",
        "ground_truth": "NO",
        "predict": "UntrimmedMap, sliceMapFactory, useClosureTrimming).build(); final CasTrimResult result = new DefaultCasTrimResult(casAssembly, trimDatastore, trimToUntrimmedMap, sangerTraceDataStore, sangerFileMap, sangerTraceDataStore.getIds(), logOut, consensusOut, traceFilesOut, referenceFilesOut); final long endTime = System.currentTimeMillis(); final long totalTime = endTime - startTime; logOut.println(\"Total time: \" + totalTime + \" ms\"); logOut.println(\"Done.\"); logOut.flush(); logOut.close(); } catch (Exception e) { e.printStackTrace(); } }\n"
    },
    {
        "ID": 1706,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Action(value = \"ajaxFileUploads\", results = { }) public void ajaxFileUploads() throws IOException { String extName = \"\"; String newFilename = \"\"; String nowTimeStr = \"\"; String realpath = \"\"; if (Validate.StrNotNull(this.getImgdirpath())) { realpath = \"Uploads/\" + this.getImgdirpath() + \"/\"; } else { realpath = this.isexistdir(); } SimpleDateFormat sDateFormat; Random r = new Random(); String savePath = ServletActionContext.getServletContext().getRealPath(\"\"); savePath = savePath + realpath; HttpServletResponse response = ServletActionContext.getResponse(); int rannum = (int) (r.nextDouble() * (99999 - 1000 + 1)) + 10000; sDateFormat = new SimpleDateFormat(\"yyyyMMddHHmmss\"); nowTimeStr = sDateFormat.format(new Date()); String filename = request.getHeader(\"X-File-Name\"); if (filename.lastIndexOf(\".\") >= 0) { extName = filename.substring(filename.lastIndexOf(\".\")); } newFilename = nowTimeStr + rannum + extName; PrintWriter writer = null; InputStream is = null; FileOutputStream fos = null; try { writer = response.getWriter(); } catch (IOException ex) { log.debug(ImgTAction.class.getName() + \"has thrown an exception:\" + ex.getMessage()); } try { is = request.getInputStream(); fos = new FileOutputStream(new File(savePath + newFilename)); IOUtils.copy(is, fos); response.setStatus(response.SC_OK); writer.print(\"{success:'\" + realpath + newFilename + \"'}\"); } catch (FileNotFoundException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log.debug(ImgTAction.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } catch (IOException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log.debug(ImgTAction.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } finally { try { this.setImgdirpath(null); fos.close(); is.close(); } catch (IOException ignored) { } } writer.flush(); writer.close(); }. \n Code2: private void addEMInformation() { try { long emDate = System.currentTimeMillis(); if (_local == true) { File emFile = new File(\"emprotz.dat\"); if (!emFile.exists()) { return; } emDate = emFile.lastModified(); } if (emDate > this._emFileDate) { this._emFileDate = emDate; this._emDate = emDate; for (int ii = 0; ii < this._projectInfo.size(); ii++) { Information info = getInfo(ii); if (info != null) { info._emDeadline = null; info._emFrames = null; info._emValue = null; } } Reader reader = null; if (_local == true) { reader = new FileReader(\"emprotz.dat\"); } else { StringBuffer urlName = new StringBuffer(); urlName.append(\"http://home.comcast.net/\"); urlName.append(\"~wxdude1/emsite/download/\"); urlName.append(\"emprotz.zip\"); try { URL url = new URL(urlName.toString()); InputStream stream = url.openStream(); ZipInputStream zip = new ZipInputStream(stream); zip.getNextEntry(); reader = new InputStreamReader(zip); } catch (MalformedURLException mue) { mue.printStackTrace(); } } BufferedReader file = new BufferedReader(reader); try { String line1 = null; int count = 0; while ((line1 = file.readLine()) != null) { String line2 = (line1 != null) ? file.readLine() : null; String line3 = (line2 != null) ? file.readLine() : null; String line4 = (line3 != null) ? file.readLine() : null; count++; if ((count > 1) && (line1 != null) && (line2 != null) && (line3 != null) && (line4 != null)) { if (line1.length() > 2) { int posBegin = line1.indexOf(\"\\\"\", 0); int posEnd = line1.indexOf(\"\\\"\", posBegin + 1); if ((posBegin >= 0) && (posEnd >= 0)) { String project = line1.substring(posBegin + 1, posEnd - posBegin); int projectNum = Integer.parseInt(project); Integer deadline = Integer.valueOf(line2.trim()); Double value = Double.valueOf(line3.trim()); Integer frames = Integer.valueOf(line4.trim()); Information info = getInfo(projectNum); if (info == null) { info = createInfo(projectNum); } if (info._emValue == null) { info._emDeadline = deadline; info._emFrames = frames; info._emValue = value; } } } } } } catch (Exception e) { e.printStackTrace(); } finally { file.close(); } } } catch (FileNotFoundException e) { } catch (IOException e) { } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else { GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]); } } } catch (IOException e) { String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() }; GUIUtilities.error(view, \"read-error\", args); } view.hideWaitCursor(); }",
        "ground_truth": "NO",
        "predict": ". \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void doVersionCheck(View view) { view.showWaitCursor(); try { URL url = new URL(jEdit.getProperty(\"version-check.url\")); InputStream in = url.openStream(); BufferedReader bin = new BufferedReader(new InputStreamReader(in)); String line; String version = null; String build = null; while ((line = bin.readLine()) != null) { if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim(); } bin.close(); if (version != null && build != null) { if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url);"
    },
    {
        "ID": 1709,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void unzipEntry(final ZipFile zipfile, final ZipEntry entry, final File outputDir) throws IOException { if (entry.isDirectory()) { createDir(new File(outputDir, entry.getName())); return; } File outputFile = new File(outputDir, entry.getName()); if (!outputFile.getParentFile().exists()) { createDir(outputFile.getParentFile()); } BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry)); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile)); try { IOUtils.copy(inputStream, outputStream); } finally { outputStream.close(); inputStream.close(); } }. \n Code2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\"export_page\"); query = query.replace(\"[RANDOM_INT]\", \"\" + random.nextInt()); int statusCode = -1; GetMethod get = new GetMethod(query); if (log.isInfoEnabled()) log.info(\"getting all contacts ...\"); try { statusCode = client.executeMethod(get); if (statusCode != 200) throw new GmailException(\"In contacts export page: Status code expected: 200 -> Status code returned: \" + statusCode); } catch (HttpException e) { throw new GmailException(\"HttpException in contacts export page:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in contacts export page:\" + e.getMessage()); } finally { get.releaseConnection(); } if (log.isTraceEnabled()) log.trace(\"accessing contacts export page successful...\"); String query_post = properties.getString(\"outlook_export_page\"); PostMethod post = new PostMethod(query_post); post.addRequestHeader(\"Accept-Encoding\", \"gzip,deflate\"); post.addRequestHeader(\"Accept-Charset\", \"ISO-8859-1,utf-8;q=0.7,*;q=0.8\"); NameValuePair[] data = { new NameValuePair(\"at\", getCookie(\"GMAIL_AT\")), new NameValuePair(\"ecf\", \"o\"), new NameValuePair(\"ac\", \"Export Contacts\") }; post.setRequestBody(data); if (log.isTraceEnabled()) log.trace(\"getting contacts csv file...\"); try { statusCode = client.executeMethod(post); if (statusCode != 200) throw new GmailException(\"In csv file post: Status code expected: 200 -> Status code returned: \" + statusCode); if (log.isTraceEnabled()) log.trace(\"Gmail: csv charset: \" + post.getResponseCharSet()); GMAIL_OUTPUT_CHARSET = post.getResponseCharSet(); InputStreamReader isr = new InputStreamReader(new GZIPInputStream(post.getResponseBodyAsStream()), post.getResponseCharSet()); CSVReader reader = new CSVReader(isr); List csvEntries = reader.readAll(); reader.close(); ArrayList<GmailContact> contacts = new ArrayList<GmailContact>(); MessageDigest m = MessageDigest.getInstance(\"MD5\"); if (log.isTraceEnabled()) log.trace(\"creating Gmail contacts...\"); for (int i = 1; i < csvEntries.size(); i++) { GmailContact contact = new GmailContact(); String[] value = (String[]) csvEntries.get(i); for (int j = 0; j < value.length; j++) { switch(j) { case 0: contact.setName(value[j]); break; case 1: contact.setEmail(value[j]); if (contact.getName() == null) contact.setIdName(value[j]); else contact.setIdName(contact.getName() + value[j]); break; case 2: contact.setNotes(value[j]); break; case 3: contact.setEmail2(value[j]); break; case 4: contact.setEmail3(value[j]); break; case 5: contact.setMobilePhone(value[j]); break; case 6: contact.setPager(value[j]); break; case 7: contact.setCompany(value[j]); break; case 8: contact.setJobTitle(value[j]); break; case 9: contact.setHomePhone(value[j]); break; case 10: contact.setHomePhone2(value[j]); break; case 11: contact.setHomeFax(value[j]); break; case 12: contact.setHomeAddress(value[j]); break; case 13: contact.setBusinessPhone(value[j]); break; case 14: contact.setBusinessPhone2(value[j]); break; case 15: contact.setBusinessFax(value[j]); break; case 16: contact.setBusinessAddress(value[j]); break; case 17: contact.setOtherPhone(value[j]); break; case 18: contact.setOtherFax(value[j]); break; case 19: contact.setOtherAddress(value[j]); break; } } m.update(contact.toString().getBytes()); if (log.isTraceEnabled()) log.trace(\"setting Md5 Hash...\"); contact.setMd5Hash(new BigInteger(m.digest()).toString()); contacts.add(contact); } if (log.isTraceEnabled()) log.trace(\"Mapping contacts uid...\"); Collections.sort(contacts); ArrayList<GmailContact> idList = getAllContactsID(); for (int i = 0; i < idList.size(); i++) { contacts.get(i).setId(idList.get(i).getId()); } if (log.isInfoEnabled()) log.info(\"getting all contacts info successful...\"); return contacts; } catch (HttpException e) { throw new GmailException(\"HttpException in csv file post:\" + e.getMessage()); } catch (IOException e) { throw new GmailException(\"IOException in csv file post:\" + e.getMessage()); } catch (NoSuchAlgorithmException e) { throw new GmailException(\"No such md5 algorithm \" + e.getMessage()); } finally { post.releaseConnection(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) { String code = \"\"; UserFunction function = null; ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\"); try { URL url = new URL(codeBase, directoryAndFile); InputStream in = url.openStream(); BufferedReader inReader = new BufferedReader(new InputStreamReader(in)); String line; while ((line",
        "ground_truth": "NO",
        "predict": " = inReader.readLine()) != null) { code += line; } inReader.close(); } catch (MalformedURLException e) { ErrorLogger.error(\"MFileLoader: Malformed URL: \" + e.getMessage()); } catch (IOException e) { ErrorLogger.error(\"MFileLoader: IOException: \" + e.getMessage()); } if (code.length() > 0) { ErrorLogger.debugLine(\"MFileLoader: code: \" + code); } if (log.isTraceEnabled()) log.trace(\"MFileLoader: code: \" + code); try { function = new UserFunction(code); } catch (Exception e) { ErrorLogger.error(\"MFileLoader: Exception: \" + e.getMessage()); } return function; }. \n Code2: @SuppressWarnings(\"unchecked\") public ArrayList<GmailContact> getAllContacts() throws GmailException { String query = properties.getString(\""
    },
    {
        "ID": 1713,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void executeInterruptible() { encodingTerminated = false; File destinationFile = null; try { Runtime runtime = Runtime.getRuntime(); IconAndFileListElement element; while ((element = getNextFileElement()) != null) { File origFile = element.getFile(); destinationFile = new File(encodeFileCard.getDestinationFolder().getValue(), origFile.getName()); if (!destinationFile.getParentFile().exists()) { destinationFile.getParentFile().mkdirs(); } actualFileLabel.setText(origFile.getName()); actualFileModel.setMaximum((int) origFile.length()); actualFileModel.setValue(0); int bitrate; synchronized (bitratePattern) { Matcher bitrateMatcher = bitratePattern.matcher(encodeFileCard.getBitrate().getValue()); bitrateMatcher.find(); bitrate = Integer.parseInt(bitrateMatcher.group(1)); } List<String> command = new LinkedList<String>(); command.add(encoderFile.getCanonicalPath()); command.add(\"--mp3input\"); command.add(\"-m\"); command.add(\"j\"); String sampleFreq = Settings.getSetting(\"encode.sample.freq\"); if (Util.isNotEmpty(sampleFreq)) { command.add(\"--resample\"); command.add(sampleFreq); } QualityElement quality = (QualityElement) ((JComboBox) encodeFileCard.getQuality().getValueComponent()).getSelectedItem(); command.add(\"-q\"); command.add(Integer.toString(quality.getValue())); command.add(\"-b\"); command.add(Integer.toString(bitrate)); command.add(\"--cbr\"); command.add(\"-\"); command.add(destinationFile.getCanonicalPath()); if (LOG.isDebugEnabled()) { StringBuilder commandLine = new StringBuilder(); boolean first = true; for (String part : command) { if (!first) commandLine.append(\" \"); commandLine.append(part); first = false; } LOG.debug(\"Command line: \" + commandLine.toString()); } encodingProcess = runtime.exec(command.toArray(new String[0])); lastPosition = 0l; InputStream fileStream = null; try { fileStream = new PositionNotifierInputStream(new FileInputStream(origFile), origFile.length(), 2048, this); IOUtils.copy(fileStream, encodingProcess.getOutputStream()); encodingProcess.getOutputStream().close(); } finally { IOUtils.closeQuietly(fileStream); if (LOG.isDebugEnabled()) { InputStream processOut = null; try { processOut = encodingProcess.getInputStream(); StringWriter sw = new StringWriter(); IOUtils.copy(processOut, sw); LOG.debug(\"Process output stream:\\n\" + sw); IOUtils.closeQuietly(processOut); processOut = encodingProcess.getErrorStream(); sw = new StringWriter(); IOUtils.copy(processOut, sw); LOG.debug(\"Process error stream:\\n\" + sw); } finally { IOUtils.closeQuietly(processOut); } } } int result = encodingProcess.waitFor(); encodingProcess = null; if (result != 0) { LOG.warn(\"Encoder process returned error code \" + result); } if (Boolean.parseBoolean(encodeFileCard.getCopyTag().getValue())) { MP3File mp3Input = new MP3File(origFile); MP3File mp3Output = new MP3File(destinationFile); boolean write = false; if (mp3Input.hasID3v2tag()) { ID3v2Tag id3v2Tag = new ID3v2Tag(); for (ID3v2Frame frame : mp3Input.getID3v2tag().getAllframes()) { id3v2Tag.addFrame(frame); } mp3Output.setID3v2tag(id3v2Tag); write = true; } if (mp3Input.hasID3v11tag()) { mp3Output.setID3v11tag(mp3Input.getID3v11tag()); write = true; } if (write) mp3Output.write(); } } actualFileLabel.setText(Messages.getString(\"operations.file.encode.execute.actualfile.terminated\")); actualFileModel.setValue(actualFileModel.getMaximum()); } catch (Exception e) { LOG.error(\"Cannot encode files\", e); if (!(e instanceof IOException && encodingTerminated)) MainWindowInterface.showError(e); if (destinationFile != null) destinationFile.delete(); } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags",
        "ground_truth": "NO",
        "predict": ".SOPClassUID, UIDs.WaveformStorage); ds.putUI(Tags.WaveformBitsAllocated, 16); ds.putUI(Tags.WaveformSampleInterpretation, \"Mono\"); ds.putIS(Tags.PixelAspectRatio, 1); ds.putIS(Tags.PixelData, pxlen); ds.putIS(Tags.Rows, ds.getInt(Tags.Rows, 0)); ds.putIS(Tags.Columns, ds.getInt(Tags.Columns, 0)); ds.putIS(Tags.NumberOfFrames, ds.getInt(Tags.NumberOfFrames, 1)); ds.putIS(Tags.BitsStored, ds.getInt(Tags.BitsAllocated, 0)); ds.putIS(Tags.HighBit, ds.getInt(Tags.BitsAllocated, 0) - 1); ds.putIS"
    },
    {
        "ID": 1732,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void fixEol(File fin) throws IOException { File fout = File.createTempFile(fin.getName(), \".fixEol\", fin.getParentFile()); FileChannel in = new FileInputStream(fin).getChannel(); if (0 != in.size()) { FileChannel out = new FileOutputStream(fout).getChannel(); byte[] eol = AStringUtilities.systemNewLine.getBytes(); ByteBuffer bufOut = ByteBuffer.allocateDirect(1024 * eol.length); boolean previousIsCr = false; ByteBuffer buf = ByteBuffer.allocateDirect(1024); while (in.read(buf) > 0) { buf.limit(buf.position()); buf.position(0); while (buf.remaining() > 0) { byte b = buf.get(); if (b == '\\r') { previousIsCr = true; bufOut.put(eol); } else { if (b == '\\n') { if (!previousIsCr) bufOut.put(eol); } else bufOut.put(b); previousIsCr = false; } } bufOut.limit(bufOut.position()); bufOut.position(0); out.write(bufOut); bufOut.clear(); buf.clear(); } out.close(); } in.close(); fin.delete(); fout.renameTo(fin); }. \n Code2: public void save() throws IOException { CodeTimer saveTimer; if (!dirty) { return; } saveTimer = new CodeTimer(\"PackedFile.save\"); saveTimer.setEnabled(log.isDebugEnabled()); File newFile = new File(tmpDir.getAbsolutePath() + \"/\" + new GUID() + \".pak\"); ZipOutputStream zout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(newFile))); zout.setLevel(1); try { saveTimer.start(\"contentFile\"); if (hasFile(CONTENT_FILE)) { zout.putNextEntry(new ZipEntry(CONTENT_FILE)); InputStream is = getFileAsInputStream(CONTENT_FILE); IOUtils.copy(is, zout); zout.closeEntry(); } saveTimer.stop(\"contentFile\"); saveTimer.start(\"propertyFile\"); if (getPropertyMap().isEmpty()) { removeFile(PROPERTY_FILE); } else { zout.putNextEntry(new ZipEntry(PROPERTY_FILE)); xstream.toXML(getPropertyMap(), zout); zout.closeEntry(); } saveTimer.stop(\"propertyFile\"); saveTimer.start(\"addFiles\"); addedFileSet.remove(CONTENT_FILE); for (String path : addedFileSet) { zout.putNextEntry(new ZipEntry(path)); InputStream is = getFileAsInputStream(path); IOUtils.copy(is, zout); zout.closeEntry(); } saveTimer.stop(\"addFiles\"); saveTimer.start(\"copyFiles\"); if (file.exists()) { Enumeration<? extends ZipEntry> entries = zFile.entries(); while (entries.hasMoreElements()) { ZipEntry entry = entries.nextElement(); if (!entry.isDirectory() && !addedFileSet.contains(entry.getName()) && !removedFileSet.contains(entry.getName()) && !CONTENT_FILE.equals(entry.getName()) && !PROPERTY_FILE.equals(entry.getName())) { zout.putNextEntry(entry); InputStream is = getFileAsInputStream(entry.getName()); IOUtils.copy(is, zout); zout.closeEntry(); } else if (entry.isDirectory()) { zout.putNextEntry(entry); zout.closeEntry(); } } } try { if (zFile != null) zFile.close(); } catch (IOException e) { } zFile = null; saveTimer.stop(\"copyFiles\"); saveTimer.start(\"close\"); zout.close(); zout = null; saveTimer.stop(\"close\"); saveTimer.start(\"backup\"); File backupFile = new File(tmpDir.getAbsolutePath() + \"/\" + new GUID() + \".mv\"); if (file.exists()) { backupFile.delete(); if (!file.renameTo(backupFile)) { FileUtil.copyFile(file, backupFile); file.delete(); } } saveTimer.stop(\"backup\"); saveTimer.start(\"finalize\"); if (!newFile.renameTo(file)) FileUtil.copyFile(newFile, file); if (backupFile.exists()) backupFile.delete(); saveTimer.stop(\"finalize\"); dirty = false; } finally { saveTimer.start(\"cleanup\"); try { if (zFile != null) zFile.close(); } catch (IOException e) { } if (newFile.exists()) newFile.delete(); try { if (zout != null) zout.close(); } catch (IOException e) { } saveTimer.stop(\"cleanup\"); if (log.isDebugEnabled()) log.debug(saveTimer); saveTimer = null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copyOverWarFile() { System.out.println(\"Copy Over War File:\"); File dir = new File(theAppsDataDir); FileFilter ff = new WildcardFileFilter(\"*.war\"); if (dir.listFiles(ff).length == 0) { dir = new File(System.getProperty(\"user.dir\") + \"/war\"); if (dir.exists()) { File[] files = dir.listFiles(ff); for (File f : files) { try { File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName()); System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\"); newFile.createNewFile(); InputStream fi = new FileInputStream(f); OutputStream fo = new FileOutputStream(newFile); IOUtils.copy(fi, fo); moveUnzipAndExtract(newFile); } catch (Exception ex) { Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex); } } } } else { System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\"); } new JFileChooser().setCurrentDirectory(new File(theAppsDataDir)); System.setProperty(\"user.dir\", theAppsDataDir); System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\")); }. \n Code2: protected String getRequestContent(String urlText) throws Exception { URL url = new URL(urlText); HttpURLConnection urlcon = (HttpURLConnection) url.openConnection(); urlcon.connect(); BufferedReader reader = new Buffered",
        "ground_truth": "NO",
        "predict": "Reader(new InputStreamReader(urlcon.getInputStream())); StringBuilder sb = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { sb.append(line); } reader.close(); return sb.toString(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void moveUnzipAndExtract(File file) throws IOException { File destDir = new File(theAppsDataDir); if (!destDir.exists()) { destDir.mkdirs(); } File destFile = new File(theAppsDataDir + \"/\" + file.getName()); if (file.exists()) { destFile.createNewFile(); FileUtil.copyFile(file, destFile); } }. \n Code2: public static void main(String[] args) throws Exception { AppDataDir.getInstance().save"
    },
    {
        "ID": 1745,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private InputStream callService(String text) { InputStream in = null; try { URL url = new URL(SERVLET_URL); URLConnection conn = url.openConnection(); HttpURLConnection httpConn = (HttpURLConnection) conn; httpConn.setRequestMethod(\"POST\"); httpConn.setDoInput(true); httpConn.setDoOutput(true); httpConn.connect(); DataOutputStream dataStream = new DataOutputStream(conn.getOutputStream()); dataStream.writeBytes(text); dataStream.flush(); dataStream.close(); int responseCode = httpConn.getResponseCode(); if (responseCode == HttpURLConnection.HTTP_OK) { in = httpConn.getInputStream(); } } catch (Exception ex) { ex.printStackTrace(); } return in; }. \n Code2: public boolean saveNote(NoteData n) { String query; try { conn.setAutoCommit(false); Statement stmt = null; ResultSet rset = null; stmt = conn.createStatement(); query = \"select * from notes where noteid = \" + n.getID(); rset = stmt.executeQuery(query); if (rset.next()) { query = \"UPDATE notes SET title = '\" + escapeCharacters(n.getTitle()) + \"', keywords = '\" + escapeCharacters(n.getKeywords()) + \"' WHERE noteid = \" + n.getID(); try { stmt.executeUpdate(query); } catch (SQLException e) { e.printStackTrace(); conn.rollback(); conn.setAutoCommit(true); return false; } LinkedList<FieldData> fields = n.getFields(); ListIterator<FieldData> iter = fields.listIterator(0); FieldData f = null; PreparedStatement pstmt = conn.prepareStatement(\"UPDATE fielddata SET data = ? WHERE noteid = ? AND fieldid = ?\"); try { while (iter.hasNext()) { f = iter.next(); if (f instanceof FieldDataImage) { System.out.println(\"field is an image.\"); pstmt.setBytes(1, ((FieldDataImage) f).getDataBytes()); } else { System.out.println(\"field is not an image\"); pstmt.setString(1, f.getData()); } pstmt.setInt(2, n.getID()); pstmt.setInt(3, f.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } query = \"DELETE FROM links WHERE (note1id = \" + n.getID() + \" OR note2id = \" + n.getID() + \")\"; try { stmt.execute(query); } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } Vector<Link> associations = n.getAssociations(); ListIterator<Link> itr = associations.listIterator(); Link association = null; pstmt = conn.prepareStatement(\"INSERT INTO links (note1id, note2id) VALUES (?, ?)\"); try { while (itr.hasNext()) { association = itr.next(); pstmt.setInt(1, n.getID()); pstmt.setInt(2, association.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } } else { query = \"INSERT INTO notes (templateid, title, keywords) VALUES (\" + n.getTemplate().getID() + \", '\" + escapeCharacters(n.getTitle()) + \"', '\" + escapeCharacters(n.getKeywords()) + \"')\"; try { stmt.executeUpdate(query); } catch (SQLException e) { e.printStackTrace(); conn.rollback(); conn.setAutoCommit(true); return false; } LinkedList<FieldData> fields = n.getFields(); ListIterator<FieldData> iter = fields.listIterator(0); FieldData f = null; n.setID(Integer.parseInt(executeMySQLGet(\"SELECT LAST_INSERT_ID()\"))); PreparedStatement pstmt; try { pstmt = conn.prepareStatement(\"INSERT INTO fielddata (noteid, fieldid, data) VALUES (?,?,?)\"); while (iter.hasNext()) { f = iter.next(); if (f instanceof FieldDataImage) { System.out.println(\"field is an image.\"); pstmt.setBytes(3, ((FieldDataImage) f).getDataBytes()); } else { System.out.println(\"field is not an image\"); pstmt.setString(3, f.getData()); } pstmt.setInt(1, n.getID()); pstmt.setInt(2, f.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } Vector<Link> assoc = n.getAssociations(); Iterator<Link> itr = assoc.listIterator(); Link l = null; pstmt = conn.prepareStatement(\"INSERT INTO links (note1id, note2id) VALUES (?,?)\"); try { while (itr.hasNext()) { l = itr.next(); pstmt.setInt(1, n.getID()); pstmt.setInt(2, l.getID()); pstmt.execute(); } } catch (SQLException e) { conn.rollback(); conn.setAutoCommit(true); e.printStackTrace(); return false; } } conn.commit(); conn.setAutoCommit(true); } catch (SQLException ex) { ex.printStackTrace(); return false; } return true; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static final void main(String[] args) throws Exception { HttpClient httpclient = new DefaultHttpClient(); HttpGet httpget = new HttpGet(\"http://www.apache.org/\"); System.out.println(\"executing request \" + httpget.getURI()); HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) { System.out.println(\"Response content length: \" + entity.getContentLength()); } System.out.println(\"----------------------------------------\"); httpget.abort(); }. \n Code2",
        "ground_truth": "NO",
        "predict": ": public static final void main(String[] args) throws Exception { HttpClient httpclient = new DefaultHttpClient(); HttpGet httpget = new HttpGet(\"http://www.apache.org/\"); System.out.println(\"executing request \" + httpget.getURI()); HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity(); System.out.println(\"----------------------------------------\"); System.out.println(response.getStatusLine()); if (entity != null) { System.out.println(\"Response content length: \" + entity.getContentLength()); } System.out.println(\"----------------------------------------\"); httpget.abort(); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static final void main(String[] args) throws Exception { HttpClient httpclient = new DefaultHttpClient(); HttpGet httpget = new Http"
    },
    {
        "ID": 1751,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void fetchKey() throws IOException { String strurl = MessageFormat.format(keyurl, new Object[] { username, secret, login, session }); StringBuffer result = new StringBuffer(); BufferedReader reader = null; URL url = null; try { url = new URL(strurl); reader = new BufferedReader(new InputStreamReader(url.openStream())); String line = null; while ((line = reader.readLine()) != null) { result.append(line); } } finally { try { if (reader != null) reader.close(); } catch (Exception e) { } } Pattern p = Pattern.compile(\"<key>(.*)</key>\"); Matcher m = p.matcher(result.toString()); if (m.matches()) { this.key = m.group(1); } }. \n Code2: @Override public void backup() { Connection connection = null; PreparedStatement prestm = null; try { if (logger.isInfoEnabled()) logger.info(\"backup table \" + getOrigin() + \" start...\"); Class.forName(driver); connection = DriverManager.getConnection(url, username, password); String tableExistsResult = \"\"; prestm = connection.prepareStatement(\"show tables from \" + schema + \" like '\" + getDestination() + \"';\"); ResultSet rs = prestm.executeQuery(); if (rs.next()) tableExistsResult = rs.getString(1); rs.close(); prestm.close(); if (StringUtils.isBlank(tableExistsResult)) { String createTableSql = \"\"; prestm = connection.prepareStatement(\"show create table \" + getOrigin() + \";\"); rs = prestm.executeQuery(); if (rs.next()) createTableSql = rs.getString(2); rs.close(); prestm.close(); createTableSql = createTableSql.replaceAll(\"`\" + getOrigin() + \"`\", \"`\" + getDestination() + \"`\"); createTableSql = createTableSql.replaceAll(\"auto_increment\", \"\"); createTableSql = createTableSql.replaceAll(\"AUTO_INCREMENT\", \"\"); Matcher matcher = stripRelationTablePattern.matcher(createTableSql); if (matcher.find()) createTableSql = matcher.replaceAll(\"\"); matcher = normalizePattern.matcher(createTableSql); if (matcher.find()) createTableSql = matcher.replaceAll(\"\\n )\"); Statement stm = connection.createStatement(); stm.execute(createTableSql); if (logger.isDebugEnabled()) logger.debug(\"table '\" + getDestination() + \"' created!\"); } else if (logger.isDebugEnabled()) logger.debug(\"table '\" + getDestination() + \"' already exists\"); Date date = new Date(); date.setTime(TimeUtil.addHours(date, -getHours()).getTimeInMillis()); date.setTime(TimeUtil.getTodayAtMidnight().getTimeInMillis()); if (logger.isInfoEnabled()) logger.info(\"backuping records before: \" + date); long currentRows = 0L; prestm = connection.prepareStatement(\"select count(*) from \" + getOrigin() + \" where \" + getCondition() + \"\"); java.sql.Date sqlDate = new java.sql.Date(date.getTime()); prestm.setDate(1, sqlDate); rs = prestm.executeQuery(); if (rs.next()) currentRows = rs.getLong(1); rs.close(); prestm.close(); if (currentRows > 0) { connection.setAutoCommit(false); prestm = connection.prepareStatement(\"INSERT INTO \" + getDestination() + \" SELECT * FROM \" + getOrigin() + \" WHERE \" + getCondition()); prestm.setDate(1, sqlDate); int rows = prestm.executeUpdate(); prestm.close(); if (logger.isInfoEnabled()) logger.info(rows + \" rows backupped\"); prestm = connection.prepareStatement(\"DELETE FROM \" + getOrigin() + \" WHERE \" + getCondition()); prestm.setDate(1, sqlDate); rows = prestm.executeUpdate(); prestm.close(); connection.commit(); if (logger.isInfoEnabled()) logger.info(rows + \" rows deleted\"); } else if (logger.isInfoEnabled()) logger.info(\"no backup need\"); if (logger.isInfoEnabled()) logger.info(\"backup table \" + getOrigin() + \" end\"); } catch (SQLException e) { logger.error(e, e); if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, \"dbcon\", \"Errore SQL durante il backup dei dati della tabella \" + getOrigin(), e)); try { connection.rollback(); } catch (SQLException e1) { } } catch (Throwable e) { logger.error(e, e); if (applicationContext != null) applicationContext.publishEvent(new TrapEvent(this, \"generic\", \"Errore generico durante il backup dei dati della tabella \" + getOrigin(), e)); try { connection.rollback(); } catch (SQLException e1) { } } finally { try { if (prestm != null) prestm.close(); } catch (SQLException e) { } try { if (connection != null) connection.close(); } catch (SQLException e) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void copyFileTo(File destination) throws IOException { logger.fine(\"Copying from \" + destination + \"...\"); FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel(); logger.fine(\"...got source channel \" + srcChannel + \"...\"); FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel(); logger.fine(\"...got destination channel \" + destChannel + \"...\"); logger.fine(\"...Got channels...\"); destChannel.transferFrom(srcChannel, 0, srcChannel.size()); logger.fine(\"...transferred.\"); srcChannel.close(); destChannel.close(); }. \n Code2: public Bitmap retrieveBitmap(String urlString) { Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString); Bitmap bitmap = null; try { URL url = new URL(urlString); URLConnection conn = url.openConnection(); conn.setConnectTimeout(3000); conn.setReadTimeout(5000); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); } catch (MalformedURLException e) { Log.e(Constants.LOG",
        "ground_truth": "NO",
        "predict": "_TAG, \"MalformedURLException\", e); } catch (IOException e) { Log.e(Constants.LOG_TAG, \"IOException\", e); } catch (Exception e) { Log.e(Constants.LOG_TAG, \"Exception\", e); } return bitmap; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void fetchBitmap(String urlString) { Bitmap bitmap = null; try { URL url = new URL(urlString); URLConnection conn = url.openConnection(); conn.setConnectTimeout(3000); conn.setReadTimeout(5000); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); } catch (MalformedURLException e) { Log.e(Constants.LOG_TAG, \"MalformedURLException\", e); } catch (IOException e) { Log."
    },
    {
        "ID": 1753,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void decompress(final File file, final File folder, final boolean deleteZipAfter) throws IOException { final ZipInputStream zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(file.getCanonicalFile()))); ZipEntry ze; try { while (null != (ze = zis.getNextEntry())) { final File f = new File(folder.getCanonicalPath(), ze.getName()); if (f.exists()) f.delete(); if (ze.isDirectory()) { f.mkdirs(); continue; } f.getParentFile().mkdirs(); final OutputStream fos = new BufferedOutputStream(new FileOutputStream(f)); try { try { final byte[] buf = new byte[8192]; int bytesRead; while (-1 != (bytesRead = zis.read(buf))) fos.write(buf, 0, bytesRead); } finally { fos.close(); } } catch (final IOException ioe) { f.delete(); throw ioe; } } } finally { zis.close(); } if (deleteZipAfter) file.delete(); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\"); logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString); URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString); logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile()); HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection(); HttpURLConnection.setFollowRedirects(false); httpURLConnection.connect(); response.setStatus(httpURLConnection.getResponseCode()); logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\"); logger.debug(\"[headers]\"); for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) { if (header.getKey() != null) { for (String value : header.getValue()) { if (value != null) { logger.debug(header.getKey() + \": \" + value); if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) { response.addHeader(header.getKey(), value); }",
        "ground_truth": "NO",
        "predict": " } } } } } }. \n */"
    },
    {
        "ID": 1760,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void delUser(User user) throws SQLException, IOException, ClassNotFoundException { String dbUserID; String stockSymbol; Statement stmt = con.createStatement(); try { con.setAutoCommit(false); dbUserID = user.getUserID(); if (getUser(dbUserID) != null) { ResultSet rs1 = stmt.executeQuery(\"SELECT userID, symbol \" + \"FROM UserStocks WHERE userID = '\" + dbUserID + \"'\"); while (rs1.next()) { try { stockSymbol = rs1.getString(\"symbol\"); delUserStocks(dbUserID, stockSymbol); } catch (SQLException ex) { throw new SQLException(\"Deletion of user stock holding failed: \" + ex.getMessage()); } } try { stmt.executeUpdate(\"DELETE FROM Users WHERE \" + \"userID = '\" + dbUserID + \"'\"); } catch (SQLException ex) { throw new SQLException(\"User deletion failed: \" + ex.getMessage()); } } else throw new IOException(\"User not found in database - cannot delete.\"); try { con.commit(); } catch (SQLException ex) { throw new SQLException(\"Transaction commit failed: \" + ex.getMessage()); } } catch (SQLException ex) { try { con.rollback(); } catch (SQLException sqx) { throw new SQLException(\"Transaction failed then rollback failed: \" + sqx.getMessage()); } throw new SQLException(\"Transaction failed; was rolled back: \" + ex.getMessage()); } stmt.close(); }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void insertDocumentToURL(String file, String target) throws IOException { InputStream is = null; OutputStream os = null; try { is = new FileInputStream(file); final URL url = new URL(target); final URLConnection connection = url.openConnection(); os = connection.getOutputStream(); TestTools.copyStream(is, os); } finally { if (is != null) { is.close(); } if (os != null) { os.close(); } } }. \n Code2: public static void copyFromTo(File srcFile, File destFile) { FileChannel in = null, out = null; FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(srcFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + srcFile.toString()); System.out.println(\"file does not exist, \" + \"is a",
        "ground_truth": "NO",
        "predict": " directory or cannot be accessed\"); return; } try { fos = new FileOutputStream(destFile); } catch (FileNotFoundException fnfe) { System.out.println(\"File: \" + destFile.toString()); System.out.println(\"file does not exist, \" + \"is a directory or cannot be accessed\"); return; } try { in = fis.getChannel(); out = fos.getChannel(); in.transferTo(0, in.size(), out); } catch (IOException ioe) { System.out.println(\"File: \" + srcFile.toString()); System.out.println(\"file does not exist, \" + \"is a directory or cannot be accessed\"); } finally { if (in != null) { try { in.close(); } catch (IOException ioe) { } } } if (out != null) { try { out.close(); } catch (IOException ioe) { } } }. \n Response: YES. \n Instruction:"
    },
    {
        "ID": 1767,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private Datastream addManagedDatastreamVersion(Entry entry) throws StreamIOException, ObjectIntegrityException { Datastream ds = new DatastreamManagedContent(); setDSCommonProperties(ds, entry); ds.DSLocationType = \"INTERNAL_ID\"; ds.DSMIME = getDSMimeType(entry); IRI contentLocation = entry.getContentSrc(); if (contentLocation != null) { if (m_obj.isNew()) { ValidationUtility.validateURL(contentLocation.toString(), ds.DSControlGrp); } if (m_format.equals(ATOM_ZIP1_1)) { if (!contentLocation.isAbsolute() && !contentLocation.isPathAbsolute()) { File f = getContentSrcAsFile(contentLocation); contentLocation = new IRI(DatastreamManagedContent.TEMP_SCHEME + f.getAbsolutePath()); } } ds.DSLocation = contentLocation.toString(); ds.DSLocation = (DOTranslationUtility.normalizeDSLocationURLs(m_obj.getPid(), ds, m_transContext)).DSLocation; return ds; } try { File temp = File.createTempFile(\"binary-datastream\", null); OutputStream out = new FileOutputStream(temp); if (MimeTypeHelper.isText(ds.DSMIME) || MimeTypeHelper.isXml(ds.DSMIME)) { IOUtils.copy(new StringReader(entry.getContent()), out, m_encoding); } else { IOUtils.copy(entry.getContentStream(), out); } ds.DSLocation = DatastreamManagedContent.TEMP_SCHEME + temp.getAbsolutePath(); } catch (IOException e) { throw new StreamIOException(e.getMessage(), e); } return ds; }. \n Code2: public String[] getLine(String prefecture) { HttpClient httpclient = null; String[] lines = null; try { httpclient = new DefaultHttpClient(); List<NameValuePair> qparams = new ArrayList<NameValuePair>(); qparams.add(new BasicNameValuePair(\"method\", \"getLines\")); qparams.add(new BasicNameValuePair(\"prefecture\", prefecture)); URI uri = URIUtils.createURI(\"http\", \"express.heartrails.com\", -1, \"/api/xml\", URLEncodedUtils.format(qparams, \"UTF-8\"), null); HttpGet httpget = new HttpGet(uri); HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity(); InputStream instream = entity.getContent(); BufferedReader reader = new BufferedReader(new InputStreamReader(instream, \"UTF-8\")); StringBuffer buf = new StringBuffer(); String str; while ((str = reader.readLine()) != null) { buf.append(str); buf.append(\"\\n\"); } reader.close(); LineResponse res = new LineResponse(buf.toString()); lines = res.getLineAsString(); } catch (URISyntaxException ex) { ex.printStackTrace(); } catch (ClientProtocolException ex) { ex.printStackTrace(); } catch (IOException ex) { ex.printStackTrace(); } catch (SAXException ex) { ex.printStackTrace(); } catch (ParserConfigurationException ex) { ex.printStackTrace(); } finally { httpclient.getConnectionManager().shutdown(); } return lines; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getPasswordMD5() { try { MessageDigest algorithm = MessageDigest.getInstance(\"MD5\"); algorithm.reset(); algorithm.update(password.getBytes()); byte messageDigest[] = algorithm.digest(); StringBuffer hexString = new StringBuffer(); for (int i = 0; i < messageDigest.length; i++) { hexString.append(Integer.toHexString(0xFF & messageDigest[i])); } return hexString.toString(); } catch (NoSuchAlgorithmException nsae) { } return null; }. \n Code2: private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception { Properties list = new Properties(); list.load(new FileInputStream(fileWithListOfImages)); long current = 0; long startTime = System.currentTimeMillis(); System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir); System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\"); System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\"); for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\"); } for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) { String urlString = it.next().toString().replace('\\\\', '/'); URL url = new URL(uriPrefix + urlString); File file = new File(outputDir + \"/\" + imageNameToFileName(urlString)); current++; if (!file.exists()) { try { BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000); int c; while ((c = in.read()) != -1) { out.write(c); } out.close(); in.close(); System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \"); System.out.println(\"saved\"); } catch (Exception e) { System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage()); } } else { System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \"); System.out.println(\"already exists\"); } if (current / 100 == current / 100.0) { long delta = (System.currentTimeMillis() - startTime); System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\"); } } long delta = (System.currentTimeMillis() - startTime); System.out.",
        "ground_truth": "NO",
        "predict": "println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\"); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getPasswordMD5() { try { MessageDigest algorithm = MessageDigest.getInstance(\"MD5\"); algorithm.reset(); algorithm.update(password.getBytes()); byte messageDigest[] = algorithm.digest(); StringBuffer hexString = new StringBuffer(); for (int i = 0; i < messageDigest.length; i++) { hexString.append(Integer.toHexString(0xFF & messageDigest[i])); } return hexString.toString(); } catch (NoSuchAlgorithmException nsae) { } return null; }. \n Code2: public static void main(String[] args) { try { downloadImages(\"http://www.heartrails.com/"
    },
    {
        "ID": 1770,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static MapEntry<String, Properties> loadFpmConf() throws ConfigurationReadException { MapEntry<String, Properties> ret = null; Scanner sc = new Scanner(CONF_PATHS).useDelimiter(SEP_P); String prev = \"\"; while (sc.hasNext() && !hasLoaded) { Properties fpmConf = null; boolean relative = false; String path = sc.next(); if (path.startsWith(PREV_P)) { path = path.replace(PREV_P, prev.substring(0, prev.length() - 1)); } else if (path.startsWith(REL_P)) { path = path.replace(REL_P + FS, \"\"); relative = true; } else if (path.contains(HOME_P)) { path = path.replace(HOME_P, USER_HOME); } prev = path; path = path.concat(MAIN_CONF_FILE); try { InputStream is = null; if (relative) { is = ClassLoader.getSystemResourceAsStream(path); path = getSystemConfDir(); Strings.getOne().createPath(path); path += MAIN_CONF_FILE; FileOutputStream os = new FileOutputStream(path); IOUtils.copy(is, os); os.flush(); os.close(); os = null; } else { is = new FileInputStream(path); } fpmConf = new Properties(); fpmConf.load(is); if (fpmConf.isEmpty()) { throw new ConfigurationReadException(); } ret = new MapEntry<String, Properties>(path, fpmConf); hasLoaded = true; } catch (FileNotFoundException e) { fpmConf = null; singleton = null; hasLoaded = false; } catch (IOException e) { throw new ConfigurationReadException(); } } return ret; }. \n Code2: public static boolean predictDataSet(String completePath, String Type, String predictionOutputFileName, String slopeOneDataFolderName) { try { if (Type.equalsIgnoreCase(\"Qualifying\")) { File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"CompleteQualifyingDataInByteFormat.txt\"); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); TShortObjectHashMap qualMap = new TShortObjectHashMap(17770, 1); ByteBuffer qualmappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); while (qualmappedfile.hasRemaining()) { short movie = qualmappedfile.getShort(); int customer = qualmappedfile.getInt(); if (qualMap.containsKey(movie)) { TIntArrayList arr = (TIntArrayList) qualMap.get(movie); arr.add(customer); qualMap.put(movie, arr); } else { TIntArrayList arr = new TIntArrayList(); arr.add(customer); qualMap.put(movie, arr); } } System.out.println(\"Populated qualifying hashmap\"); File outFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + predictionOutputFileName); FileChannel outC = new FileOutputStream(outFile).getChannel(); ByteBuffer buf; TShortObjectHashMap movieDiffStats; double finalPrediction; short[] movies = qualMap.keys(); Arrays.sort(movies); for (int i = 0; i < movies.length; i++) { short movieToProcess = movies[i]; movieDiffStats = loadMovieDiffStats(completePath, movieToProcess, slopeOneDataFolderName); System.out.println(movieDiffStats.size()); TIntArrayList customersToProcess = (TIntArrayList) qualMap.get(movieToProcess); for (int j = 0; j < customersToProcess.size(); j++) { int customerToProcess = customersToProcess.getQuick(j); finalPrediction = predictSlopeOneRating(customerToProcess, movieDiffStats); if (finalPrediction == finalPrediction) { if (finalPrediction < 1.0) finalPrediction = 1.0; else if (finalPrediction > 5.0) finalPrediction = 5.0; } else finalPrediction = GetAveragePrediction(movieToProcess); buf = ByteBuffer.allocate(10); buf.putShort(movieToProcess); buf.putInt(customerToProcess); buf.putFloat(new Double(finalPrediction).floatValue()); buf.flip(); outC.write(buf); } } outC.close(); return true; } else if (Type.equalsIgnoreCase(\"Probe\")) { File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"CompleteProbeDataInByteFormat.txt\"); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); TShortObjectHashMap probeMap = new TShortObjectHashMap(17770, 1); ByteBuffer probemappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); while (probemappedfile.hasRemaining()) { short movie = probemappedfile.getShort(); int customer = probemappedfile.getInt(); byte rating = probemappedfile.get(); if (probeMap.containsKey(movie)) { TIntByteHashMap actualRatings = (TIntByteHashMap) probeMap.get(movie); actualRatings.put(customer, rating); probeMap.put(movie, actualRatings); } else { TIntByteHashMap actualRatings = new TIntByteHashMap(); actualRatings.put(customer, rating); probeMap.put(movie, actualRatings); } } System.out.println(\"Populated probe hashmap\"); File outFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + predictionOutputFileName); FileChannel outC = new FileOutputStream(outFile).getChannel(); ByteBuffer buf; double finalPrediction; TShortObjectHashMap movieDiffStats; short[] movies = probeMap.keys(); Arrays.sort(movies); for (int i = 0; i < movies.length; i++) { short movieToProcess = movies[i]; movieDiffStats = loadMovieDiffStats(completePath, movieToProcess, slopeOneDataFolderName); TIntByteHashMap custRatingsToProcess = (TIntByteHashMap) probeMap.get(movieToProcess); TIntArrayList customersToProcess = new TIntArrayList(custRatingsToProcess.keys()); for (int j = 0; j < customersToProcess.size(); j++) { int customerToProcess = customersToProcess.getQuick(j); byte rating = custRatingsToProcess.get(customerToProcess); finalPrediction = predictSlopeOneRating(custom",
        "ground_truth": "NO",
        "predict": "erToProcess, movieDiffStats); if (finalPrediction == finalPrediction) { if (finalPrediction < 1.0) finalPrediction = 1.0; else if (finalPrediction > 5.0) finalPrediction = 5.0; } else finalPrediction = GetAveragePrediction(movieToProcess); buf = ByteBuffer.allocate(10); buf.putShort(movieToProcess); buf.putInt(customerToProcess); buf.putFloat(new Double(finalPrediction).floatValue()); buf.flip(); outC.write(buf); } } outC.close(); return true; } else if (Type.equalsIgnoreCase(\"All\")) { File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"CompleteAllDataInByteFormat.txt\"); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); TShortObjectHash"
    },
    {
        "ID": 1773,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean isPasswordCorrect(String attempt) { try { MessageDigest digest = MessageDigest.getInstance(attempt); digest.update(salt); digest.update(attempt.getBytes(\"UTF-8\")); byte[] attemptHash = digest.digest(); return attemptHash.equals(hash); } catch (UnsupportedEncodingException ex) { Logger.getLogger(UserRecord.class.getName()).log(Level.SEVERE, null, ex); return false; } catch (NoSuchAlgorithmException ex) { Logger.getLogger(UserRecord.class.getName()).log(Level.SEVERE, null, ex); return false; } }. \n Code2: @Override public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { resp.setContentType(\"application/json\"); resp.setCharacterEncoding(\"utf-8\"); String format = req.getParameter(\"format\"); EntityManager em = EMF.get().createEntityManager(); String uname = (req.getParameter(\"uname\") == null) ? \"\" : req.getParameter(\"uname\"); String passwd = (req.getParameter(\"passwd\") == null) ? \"\" : req.getParameter(\"passwd\"); String name = (req.getParameter(\"name\") == null) ? \"\" : req.getParameter(\"name\"); String email = (req.getParameter(\"email\") == null) ? \"\" : req.getParameter(\"email\"); if (uname == null || uname.equals(\"\") || uname.length() < 4) { if (format != null && format.equals(\"xml\")) resp.getWriter().print(Error.unameTooShort(uname).toXML(em)); else resp.getWriter().print(Error.unameTooShort(uname).toJSON(em)); resp.setStatus(HttpServletResponse.SC_BAD_REQUEST); return; } if (User.fromUserName(em, uname) != null) { if (format != null && format.equals(\"xml\")) resp.getWriter().print(Error.userExists(uname).toXML(em)); else resp.getWriter().print(Error.userExists(uname).toJSON(em)); resp.setStatus(HttpServletResponse.SC_CONFLICT); em.close(); return; } if (passwd.equals(\"\") || passwd.length() < 6) { resp.setStatus(HttpServletResponse.SC_BAD_REQUEST); if (format != null && format.equals(\"xml\")) resp.getWriter().print(Error.passwdTooShort(uname).toXML(em)); else resp.getWriter().print(Error.passwdTooShort(uname).toJSON(em)); em.close(); return; } User u = new User(); u.setUsername(uname); u.setPasswd(passwd); u.setName(name); u.setEmail(email); u.setPaid(false); StringBuffer apikey = new StringBuffer(); try { MessageDigest algorithm = MessageDigest.getInstance(\"MD5\"); algorithm.reset(); String api = System.nanoTime() + \"\" + System.identityHashCode(this) + \"\" + uname; algorithm.update(api.getBytes()); byte[] digest = algorithm.digest(); for (int i = 0; i < digest.length; i++) { apikey.append(Integer.toHexString(0xFF & digest[i])); } } catch (NoSuchAlgorithmException e) { resp.setStatus(500); if (format != null && format.equals(\"xml\")) resp.getWriter().print(Error.unknownError().toXML(em)); else resp.getWriter().print(Error.unknownError().toJSON(em)); log.severe(e.toString()); em.close(); return; } u.setApiKey(apikey.toString()); EntityTransaction tx = em.getTransaction(); tx.begin(); try { em.persist(u); tx.commit(); } catch (Throwable t) { log.severe(\"Error adding user \" + uname + \" Reason:\" + t.getMessage()); tx.rollback(); resp.setStatus(500); if (format != null && format.equals(\"xml\")) resp.getWriter().print(Error.unknownError().toXML(em)); else resp.getWriter().print(Error.unknownError().toJSON(em)); return; } log.info(\"User \" + u.getName() + \" was created successfully\"); resp.setStatus(HttpServletResponse.SC_CREATED); if (format != null && format.equals(\"xml\")) resp.getWriter().print(u.toXML(em)); else resp.getWriter().print(u.toJSON(em)); em.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) { String[] files; files = dir.list(); File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding); if (!checkdir.isDirectory()) { checkdir.mkdir(); } ; Date date = new Date(); long msec = date.getTime(); checkdir.setLastModified(msec); File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\"); if (checkFile.exists()) { checkFile.setLastModified(msec); } try { for (int i = 0; i < files.length; i++) { File f = new File(dir, files[i]); File g = new File(files[i]); if (f.isDirectory()) { } else { String destinationFile = checkdir + System.getProperty(\"file.separator\") + g; String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g; FileInputStream infile = new FileInputStream(sourceFile); FileOutputStream outfile = new FileOutputStream(destinationFile); int c; while ((c = infile.read()) != -1) outfile.write(c); infile.close(); outfile.close(); } } } catch (Exception e) { e.printStackTrace(); } }. \n Code2: @Test public void testCopyUnknownSize() throws IOException { final InputStream in = new ByteArrayInputStream(TEST_DATA); final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length); final int cpySize = ExtraIOUtils.copy(in, out, (-1)); assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize); final byte[] outArray = out.toByteArray();",
        "ground_truth": "YES",
        "predict": " assertArrayEquals(\"Mismatched copy result\", TEST_DATA, outArray); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) { String[] files; files = dir.list(); File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding); if (!checkdir.isDirectory()) { checkdir.mkdir(); } ; Date date = new Date(); long msec = date.getTime(); checkdir.setLastModified(msec); File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\"); if (checkFile.exists()) { checkFile.setLastModified(msec); } try { for (int i = 0;"
    },
    {
        "ID": 1774,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public Source resolve(String href, String base) throws TransformerException { if (href.endsWith(\".txt\")) { try { URL url = new URL(new URL(base), href); java.io.InputStream in = url.openConnection().getInputStream(); java.io.InputStreamReader reader = new java.io.InputStreamReader(in, \"iso-8859-1\"); StringBuffer sb = new StringBuffer(); while (true) { int c = reader.read(); if (c < 0) break; sb.append((char) c); } com.icl.saxon.expr.TextFragmentValue tree = new com.icl.saxon.expr.TextFragmentValue(sb.toString(), url.toString(), (com.icl.saxon.Controller) transformer); return tree.getFirst(); } catch (Exception err) { throw new TransformerException(err); } } else { return null; } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private boolean readUrlFile(String fullUrl, PrintWriter out) { try { URL url = new URL(fullUrl); String encoding = \"gbk\"; BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream(), encoding)); return fileEditor.pushStream(out, in, fullUrl, false); } catch (Exception e) { } return false; }. \n Code2: private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception { List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST); for (int i = 0; i < list.size(); i++) { long langId = ((Language) list.get(i)).getId(); try { String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\"; boolean copy = false; File from = new java.io.File(filePath); if (!from.exists()) { from.createNewFile(); copy = true; } String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\"; File to = new java.io.File(tmpFilePath); if (!to.exists()) { to.createNewFile(); copy = true; } if (copy) { FileChannel srcChannel = new FileInputStream(from).getChannel(); FileChannel dstChannel = new FileOutputStream(to).getChannel(); dstChannel.transferFrom(srcChannel, 0, srcChannel.size()); srcChannel.close(); dstChannel.close(); } } catch (IOException e) { Logger.error(this, \"_",
        "ground_truth": "NO",
        "predict": "checkLanguagesFiles\", e); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private boolean readUrlFile(String fullUrl, PrintWriter out) { try { URL url = new URL(fullUrl); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); return fileEditor.pushStream(out, in, fullUrl, false); } catch (Exception e) { } return false; }. \n Code2: private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception { List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST); for (int i = 0; i < list.size(); i++) { long langId = ((Language) list.get(i)).getId(); try { String filePath"
    },
    {
        "ID": 1778,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public CasAssembly build() { try { prepareForBuild(); File casWorkingDirectory = casFile.getParentFile(); DefaultCasFileReadIndexToContigLookup read2contigMap = new DefaultCasFileReadIndexToContigLookup(); AbstractDefaultCasFileLookup readIdLookup = new DefaultReadCasFileLookup(casWorkingDirectory); CasParser.parseOnlyMetaData(casFile, MultipleWrapper.createMultipleWrapper(CasFileVisitor.class, read2contigMap, readIdLookup)); ReadWriteDirectoryFileServer consedOut = DirectoryFileServer.createReadWriteDirectoryFileServer(commandLine.getOptionValue(\"o\")); long startTime = DateTimeUtils.currentTimeMillis(); int numberOfCasContigs = read2contigMap.getNumberOfContigs(); for (long i = 0; i < numberOfCasContigs; i++) { File outputDir = consedOut.createNewDir(\"\" + i); Command aCommand = new Command(new File(\"fakeCommand\")); aCommand.setOption(\"-casId\", \"\" + i); aCommand.setOption(\"-cas\", commandLine.getOptionValue(\"cas\")); aCommand.setOption(\"-o\", outputDir.getAbsolutePath()); aCommand.setOption(\"-tempDir\", tempDir.getAbsolutePath()); aCommand.setOption(\"-prefix\", \"temp\"); if (commandLine.hasOption(\"useIllumina\")) { aCommand.addFlag(\"-useIllumina\"); } if (commandLine.hasOption(\"useClosureTrimming\")) { aCommand.addFlag(\"-useClosureTrimming\"); } if (commandLine.hasOption(\"trim\")) { aCommand.setOption(\"-trim\", commandLine.getOptionValue(\"trim\")); } if (commandLine.hasOption(\"trimMap\")) { aCommand.setOption(\"-trimMap\", commandLine.getOptionValue(\"trimMap\")); } if (commandLine.hasOption(\"chromat_dir\")) { aCommand.setOption(\"-chromat_dir\", commandLine.getOptionValue(\"chromat_dir\")); } submitSingleCasAssemblyConversion(aCommand); } waitForAllAssembliesToFinish(); int numContigs = 0; int numReads = 0; for (int i = 0; i < numberOfCasContigs; i++) { File countMap = consedOut.getFile(i + \"/temp.counts\"); Scanner scanner = new Scanner(countMap); if (!scanner.hasNextInt()) { throw new IllegalStateException(\"single assembly conversion # \" + i + \" did not complete\"); } numContigs += scanner.nextInt(); numReads += scanner.nextInt(); scanner.close(); } System.out.println(\"num contigs =\" + numContigs); System.out.println(\"num reads =\" + numReads); consedOut.createNewDir(\"edit_dir\"); consedOut.createNewDir(\"phd_dir\"); String prefix = commandLine.hasOption(\"prefix\") ? commandLine.getOptionValue(\"prefix\") : DEFAULT_PREFIX; OutputStream masterAceOut = new FileOutputStream(consedOut.createNewFile(\"edit_dir/\" + prefix + \".ace.1\")); OutputStream masterPhdOut = new FileOutputStream(consedOut.createNewFile(\"phd_dir/\" + prefix + \".phd.ball\")); OutputStream masterConsensusOut = new FileOutputStream(consedOut.createNewFile(prefix + \".consensus.fasta\")); OutputStream logOut = new FileOutputStream(consedOut.createNewFile(prefix + \".log\")); try { masterAceOut.write(String.format(\"AS %d %d%n\", numContigs, numReads).getBytes()); for (int i = 0; i < numberOfCasContigs; i++) { InputStream aceIn = consedOut.getFileAsStream(i + \"/temp.ace\"); IOUtils.copy(aceIn, masterAceOut); InputStream phdIn = consedOut.getFileAsStream(i + \"/temp.phd\"); IOUtils.copy(phdIn, masterPhdOut); InputStream consensusIn = consedOut.getFileAsStream(i + \"/temp.consensus.fasta\"); IOUtils.copy(consensusIn, masterConsensusOut); IOUtil.closeAndIgnoreErrors(aceIn, phdIn, consensusIn); File tempDir = consedOut.getFile(i + \"\"); IOUtil.recursiveDelete(tempDir); } consedOut.createNewSymLink(\"../phd_dir/\" + prefix + \".phd.ball\", \"edit_dir/phd.ball\"); if (commandLine.hasOption(\"chromat_dir\")) { consedOut.createNewDir(\"chromat_dir\"); File originalChromatDir = new File(commandLine.getOptionValue(\"chromat_dir\")); for (File chromat : originalChromatDir.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return name.endsWith(\".scf\"); } })) { File newChromatFile = consedOut.createNewFile(\"chromat_dir/\" + FilenameUtils.getBaseName(chromat.getName())); FileOutputStream newChromat = new FileOutputStream(newChromatFile); InputStream in = new FileInputStream(chromat); IOUtils.copy(in, newChromat); IOUtil.closeAndIgnoreErrors(in, newChromat); } } System.out.println(\"finished making casAssemblies\"); for (File traceFile : readIdLookup.getFiles()) { final String name = traceFile.getName(); String extension = FilenameUtils.getExtension(name); if (name.contains(\"fastq\")) { if (!consedOut.contains(\"solexa_dir\")) { consedOut.createNewDir(\"solexa_dir\"); } if (consedOut.contains(\"solexa_dir/\" + name)) { IOUtil.delete(consedOut.getFile(\"solexa_dir/\" + name)); } consedOut.createNewSymLink(traceFile.getAbsolutePath(), \"solexa_dir/\" + name); } else if (\"sff\".equals(extension)) { if (!consedOut.contains(\"sff_dir\")) { consedOut.createNewDir(\"sff_dir\"); } if (consedOut.contains(\"sff_dir/\" + name)) { IOUtil.delete(consedOut.getFile(\"sff_dir/\" + name)); } consedOut.createNewSymLink(traceFile.getAbsolutePath(), \"sff_dir/\" + name); } } long endTime = DateTimeUtils.currentTimeMillis(); logOut.write(String.format(\"t",
        "ground_truth": "NO",
        "predict": "ook %d seconds to convert %d casAssemblies%n\", (endTime - startTime) / 1000, numberOfCasContigs).getBytes()); logOut.close(); } catch (IOException e) { throw new RuntimeException(e); } }\n"
    },
    {
        "ID": 1782,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private void setManagedContent(Entry entry, Datastream vds) throws StreamIOException { if (m_transContext == DOTranslationUtility.SERIALIZE_EXPORT_ARCHIVE && !m_format.equals(ATOM_ZIP1_1)) { String mimeType = vds.DSMIME; if (MimeTypeHelper.isText(mimeType) || MimeTypeHelper.isXml(mimeType)) { try { entry.setContent(IOUtils.toString(vds.getContentStream(), m_encoding), mimeType); } catch (IOException e) { throw new StreamIOException(e.getMessage(), e); } } else { entry.setContent(vds.getContentStream(), mimeType); } } else { String dsLocation; IRI iri; if (m_format.equals(ATOM_ZIP1_1) && m_transContext != DOTranslationUtility.AS_IS) { dsLocation = vds.DSVersionID + \".\" + MimeTypeUtils.fileExtensionForMIMEType(vds.DSMIME); try { m_zout.putNextEntry(new ZipEntry(dsLocation)); InputStream is = vds.getContentStream(); IOUtils.copy(is, m_zout); is.close(); m_zout.closeEntry(); } catch (IOException e) { throw new StreamIOException(e.getMessage(), e); } } else { dsLocation = StreamUtility.enc(DOTranslationUtility.normalizeDSLocationURLs(m_obj.getPid(), vds, m_transContext).DSLocation); } iri = new IRI(dsLocation); entry.setSummary(vds.DSVersionID); entry.setContent(iri, vds.DSMIME); } }. \n Code2: @SuppressWarnings(\"static-access\") @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException { PrintWriter writer = null; InputStream is = null; FileOutputStream fos = null; try { writer = response.getWriter(); } catch (IOException ex) { log(OctetStreamReader.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } String filename = request.getHeader(\"X-File-Name\"); try { filename = URLDecoder.decode(filename, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } try { is = request.getInputStream(); File newFile = new File(realPath + filename); if (!newFile.exists()) { fos = new FileOutputStream(new File(realPath + filename)); IOUtils.copy(is, fos); response.setStatus(response.SC_OK); writer.print(\"{success: true,detailMsg}\"); } else { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false,detailMsg:'\u6587\u4ef6\u5df2\u7ecf\u5b58\u5728\uff01\u8bf7\u91cd\u547d\u540d\u540e\u4e0a\u4f20\uff01'}\"); log(OctetStreamReader.class.getName() + \"has thrown an exception: \" + filename + \" has existed!\"); } } catch (FileNotFoundException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log(OctetStreamReader.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } catch (IOException ex) { response.setStatus(response.SC_INTERNAL_SERVER_ERROR); writer.print(\"{success: false}\"); log(OctetStreamReader.class.getName() + \"has thrown an exception: \" + ex.getMessage()); } finally { try { fos.close(); is.close(); } catch (IOException ignored) { } } writer.flush(); writer.close(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL().toString()); } else if (item.getType() == Type.ANY_URI) { LOG.debug(\"Streaming xs:anyURI\"); String url = item.getStringValue(); if (url.startsWith(\"/\")) { url = \"xmldb:exist://\" + url; } InputStream is = new URL(url).openStream(); streamSource.setInputStream(is); streamSource.setSystemId(url); } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) { LOG.debug(\"Streaming element or document node\"); if (item instanceof NodeProxy) { NodeProxy np = (NodeProxy) item; String url = \"xmldb:exist://\" + np.getDocument().getBaseURI(); LOG.debug(\"Document detected, adding URL \" + url); streamSource.setSystemId(url); } Serializer serializer = context.getBroker().newSerializer(); NodeValue node = (NodeValue) item; InputStream is = new NodeInputStream(serializer, node); streamSource.setInputStream(is); } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) { LOG.debug(\"Streaming base64 binary\"); BinaryValue binary = (BinaryValue) item; byte[] data = (byte[]) binary.toJavaObject(byte[].class); InputStream is = new ByteArrayInputStream(data); streamSource.setInputStream(is); if (item instanceof Base64BinaryDocument) { Base64BinaryDocument b64doc = (Base64BinaryDocument) item; String url = \"xmldb:exist://\" + b64doc.getUrl(); LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url); streamSource.setSystemId(url); } } else { LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType())); throw new XPathException(\"wrong",
        "ground_truth": "NO",
        "predict": " item type\"); } return streamSource; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException { StreamSource streamSource = new StreamSource(); if (item.getType() == Type.JAVA_OBJECT) { LOG.debug(\"Streaming Java object\"); Object obj = ((JavaObjectValue) item).getObject(); if (!(obj instanceof File)) { throw new XPathException(\"Passed java object should be a File\"); } File inputFile = (File) obj; InputStream is = new FileInputStream(inputFile); streamSource.setInputStream(is); streamSource.setSystemId(inputFile.toURI().toURL().toString()); } else if (item.getType() == Type.ANY_URI) { LOG"
    },
    {
        "ID": 1784,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private final long test(final boolean applyFilter, final int executionCount) throws NoSuchAlgorithmException, NoSuchPaddingException, FileNotFoundException, IOException, RuleLoadingException { final boolean stripHtmlEnabled = true; final boolean injectSecretTokensEnabled = true; final boolean encryptQueryStringsEnabled = true; final boolean protectParamsAndFormsEnabled = true; final boolean applyExtraProtectionForDisabledFormFields = true; final boolean applyExtraProtectionForReadonlyFormFields = false; final boolean applyExtraProtectionForRequestParamValueCount = false; final ContentInjectionHelper helper = new ContentInjectionHelper(); final RuleFileLoader ruleFileLoaderModificationExcludes = new ClasspathZipRuleFileLoader(); ruleFileLoaderModificationExcludes.setPath(WebCastellumFilter.MODIFICATION_EXCLUDES_DEFAULT); final ContentModificationExcludeDefinitionContainer containerModExcludes = new ContentModificationExcludeDefinitionContainer(ruleFileLoaderModificationExcludes); containerModExcludes.parseDefinitions(); helper.setContentModificationExcludeDefinitions(containerModExcludes); final AttackHandler attackHandler = new AttackHandler(null, 123, 600000, 100000, 300000, 300000, null, \"MOCK\", false, false, 0, false, false, Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), true); final SessionCreationTracker sessionCreationTracker = new SessionCreationTracker(attackHandler, 0, 600000, 300000, 0, \"\", \"\", \"\", \"\"); final RequestWrapper request = new RequestWrapper(new RequestMock(), helper, sessionCreationTracker, \"123.456.789.000\", false, true, true); final RuleFileLoader ruleFileLoaderResponseModifications = new ClasspathZipRuleFileLoader(); ruleFileLoaderResponseModifications.setPath(WebCastellumFilter.RESPONSE_MODIFICATIONS_DEFAULT); final ResponseModificationDefinitionContainer container = new ResponseModificationDefinitionContainer(ruleFileLoaderResponseModifications); container.parseDefinitions(); final ResponseModificationDefinition[] responseModificationDefinitions = downCast(container.getAllEnabledRequestDefinitions()); final List tmpPatternsToExcludeCompleteTag = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeCompleteScript = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToExcludeLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPatternsToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeCompleteTag = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeCompleteScript = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToExcludeLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpPrefiltersToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); final List tmpGroupNumbersToCaptureLinksWithinScripts = new ArrayList(responseModificationDefinitions.length); final List tmpGroupNumbersToCaptureLinksWithinTags = new ArrayList(responseModificationDefinitions.length); for (int i = 0; i < responseModificationDefinitions.length; i++) { final ResponseModificationDefinition responseModificationDefinition = responseModificationDefinitions[i]; if (responseModificationDefinition.isMatchesScripts()) { tmpPatternsToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPattern()); tmpPrefiltersToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPrefilter()); tmpPatternsToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinScripts.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } if (responseModificationDefinition.isMatchesTags()) { tmpPatternsToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPattern()); tmpPrefiltersToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPrefilter()); tmpPatternsToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinTags.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } } final Matcher[] matchersToExcludeCompleteTag = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteTag); final Matcher[] matchersToExcludeCompleteScript = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteScript); final Matcher[] matchersToExcludeLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinScripts); final Matcher[] matchersToExcludeLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinTags); final Matcher[] matchersToCaptureLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinScripts); final Matcher[] matchersToCaptureLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinTags); final WordDictionary[] prefiltersToExcludeCompleteTag = (WordDictionary[]) tmpPrefiltersToExcludeCompleteTag.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeCompleteScript = (WordDictionary[]) tmpPrefiltersToExclude",
        "ground_truth": "NO",
        "predict": "CompleteScript.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeLinksWithinScripts = (WordDictionary[]) tmpPrefiltersToExcludeLinksWithinScripts.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToExcludeLinksWithinTags = (WordDictionary[]) tmpPrefiltersToExcludeLinksWithinTags.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToCaptureLinksWithinScripts = (WordDictionary[]) tmpPrefiltersToCaptureLinksWithinScripts.toArray(new WordDictionary[0]); final WordDictionary[] prefiltersToCaptureLinksWithinTags = (WordDictionary[]) tmpPrefiltersToCaptureLinksWithinTags.toArray(new WordDictionary[0]); final int[] groupNumbersToCaptureLinksWithinScripts = (int[]) tmpGroupNumbersToCaptureLinksWithinScripts.toArray(new int[0]); final"
    },
    {
        "ID": 1790,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void copy(String src, String dest) throws IOException { File ifp = new File(src); File ofp = new File(dest); if (ifp.exists() == false) { throw new IOException(\"file '\" + src + \"' does not exist\"); } FileInputStream fis = new FileInputStream(ifp); FileOutputStream fos = new FileOutputStream(ofp); byte[] b = new byte[1024]; while (fis.read(b) > 0) fos.write(b); fis.close(); fos.close(); }. \n Code2: public void upload() throws UnknownHostException, SocketException, FTPConnectionClosedException, LoginFailedException, DirectoryChangeFailedException, CopyStreamException, RefusedConnectionException, IOException { final int NUM_XML_FILES = 2; final String META_XML_SUFFIX = \"_meta.xml\"; final String FILES_XML_SUFFIX = \"_files.xml\"; final String username = getUsername(); final String password = getPassword(); if (getFtpServer() == null) { throw new IllegalStateException(\"ftp server not set\"); } if (getFtpPath() == null) { throw new IllegalStateException(\"ftp path not set\"); } if (username == null) { throw new IllegalStateException(\"username not set\"); } if (password == null) { throw new IllegalStateException(\"password not set\"); } final String metaXmlString = serializeDocument(getMetaDocument()); final String filesXmlString = serializeDocument(getFilesDocument()); final byte[] metaXmlBytes = metaXmlString.getBytes(); final byte[] filesXmlBytes = filesXmlString.getBytes(); final int metaXmlLength = metaXmlBytes.length; final int filesXmlLength = filesXmlBytes.length; final Collection files = getFiles(); final int totalFiles = NUM_XML_FILES + files.size(); final String[] fileNames = new String[totalFiles]; final long[] fileSizes = new long[totalFiles]; final String metaXmlName = getIdentifier() + META_XML_SUFFIX; fileNames[0] = metaXmlName; fileSizes[0] = metaXmlLength; final String filesXmlName = getIdentifier() + FILES_XML_SUFFIX; fileNames[1] = filesXmlName; fileSizes[1] = filesXmlLength; int j = 2; for (Iterator i = files.iterator(); i.hasNext(); ) { final ArchiveFile f = (ArchiveFile) i.next(); fileNames[j] = f.getRemoteFileName(); fileSizes[j] = f.getFileSize(); j++; } for (int i = 0; i < fileSizes.length; i++) { _fileNames2Progress.put(fileNames[i], new UploadFileProgress(fileSizes[i])); _totalUploadSize += fileSizes[i]; } FTPClient ftp = new FTPClient(); try { if (isCancelled()) { return; } ftp.enterLocalPassiveMode(); if (isCancelled()) { return; } ftp.connect(getFtpServer()); final int reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { throw new RefusedConnectionException(getFtpServer() + \"refused FTP connection\"); } if (isCancelled()) { return; } if (!ftp.login(username, password)) { throw new LoginFailedException(); } try { if (!ftp.changeWorkingDirectory(getFtpPath())) { if (!isFtpDirPreMade() && !ftp.makeDirectory(getFtpPath())) { throw new DirectoryChangeFailedException(); } if (isCancelled()) { return; } if (!ftp.changeWorkingDirectory(getFtpPath())) { throw new DirectoryChangeFailedException(); } } if (isCancelled()) { return; } connected(); uploadFile(metaXmlName, new ByteArrayInputStream(metaXmlBytes), ftp); uploadFile(filesXmlName, new ByteArrayInputStream(filesXmlBytes), ftp); if (isCancelled()) { return; } ftp.setFileType(FTP.BINARY_FILE_TYPE); for (final Iterator i = files.iterator(); i.hasNext(); ) { final ArchiveFile f = (ArchiveFile) i.next(); uploadFile(f.getRemoteFileName(), new FileInputStream(f.getIOFile()), ftp); } } catch (InterruptedIOException ioe) { return; } finally { ftp.logout(); } } finally { try { ftp.disconnect(); } catch (IOException e) { } } if (isCancelled()) { return; } checkinStarted(); if (isCancelled()) { return; } checkin(); if (isCancelled()) { return; } checkinCompleted(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public List load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace(\"load \" + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = \"MbeansDescriptorsDynamicMBeanSource\"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString(); type = param; inputsource = url.openStream(); if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof File) { location = ((File) source).getAbsolutePath(); inputsource = new FileInputStream((File) source); type = param; if (sourceType == null) { sourceType = sourceTypeFromExt(location); } } else if (source instanceof InputStream) { type = param; inputsource = source; } else if (source instanceof Class) { location = ((Class) source).getName(); type = param; inputsource = source; if (sourceType == null) { sourceType = \"MbeansDescriptorsIntrospectionSource\"; } } if (sourceType == null) { sourceType = \"MbeansDescriptorsDigesterSource\"; } ModelerSource ds = getModelerSource(sourceType); List mbeans = ds.loadDescriptors(this, location, type, inputsource); return mbeans; }. \n Code2: @Test public void test_validate_geo_getEvents() { try { SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\"); File schemaLocation = new File(\"tes.xsd\"); Schema schema = factory.newSche",
        "ground_truth": "NO",
        "predict": "ma(schemaLocation); Validator validator = schema.newValidator(); Source source = new StreamSource(new StringReader(getEvents())); validator.validate(source); } catch (SAXException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public List load(String sourceType, Object source, String param) throws Exception { if (log.isTraceEnabled()) { log.trace(\"load \" + source); } String location = null; String type = null; Object inputsource = null; if (source instanceof DynamicMBean) { sourceType = \"MbeansDescriptorsDynamicMBeanSource\"; inputsource = source; } else if (source instanceof URL) { URL url = (URL) source; location = url.toString"
    },
    {
        "ID": 1806,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void elimina(Pedido pe) throws errorSQL, errorConexionBD { System.out.println(\"GestorPedido.elimina()\"); int id = pe.getId(); String sql; Statement stmt = null; try { gd.begin(); sql = \"DELETE FROM pedido WHERE id=\" + id; System.out.println(\"Ejecutando: \" + sql); stmt = gd.getConexion().createStatement(); stmt.executeUpdate(sql); System.out.println(\"executeUpdate\"); gd.commit(); System.out.println(\"commit\"); stmt.close(); } catch (SQLException e) { gd.rollback(); throw new errorSQL(e.toString()); } catch (errorConexionBD e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } catch (errorSQL e) { System.err.println(\"Error en GestorPedido.elimina(): \" + e); } }. \n Code2: public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException { PageContext pageContext = null; HttpSession session = null; ServletContext application = null; ServletConfig config = null; JspWriter out = null; Object page = this; JspWriter _jspx_out = null; PageContext _jspx_page_context = null; try { response.setContentType(\"text/html;charset=UTF-8\"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; _jspx_resourceInjector = (org.apache.jasper.runtime.ResourceInjector) application.getAttribute(\"com.sun.appserv.jsp.resource.injector\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); String username = \"test\"; String password = \"test\"; int providerId = 1; if (request.getParameter(\"providerId\") != null) providerId = Integer.parseInt(request.getParameter(\"providerId\")); String thisPageContextAddress = \"http://localhost:8080\" + request.getContextPath(); String thisPageServingAddress = thisPageContextAddress + \"/index.jsp\"; String token = \"\"; String token_timeout = (String) request.getParameter(\"token_timeout\"); String referer = request.getHeader(\"Referer\"); if (token_timeout != null && token_timeout.equals(\"true\")) { System.out.println(\"token timeout for referer\" + referer); if (referer != null) { if (request.getSession().getServletContext().getAttribute(\"token_timeout_processing_lock\") == null) { request.getSession().getServletContext().setAttribute(\"token_timeout_processing_lock\", true); byte[] buff = null; BufferedInputStream bis = null; URL url = new URL(thisPageContextAddress + \"/ServerAdminServlet?action=login&username=\" + username + \"&password=\" + password); URLConnection urlc = url.openConnection(); int length = urlc.getContentLength(); InputStream in = urlc.getInputStream(); buff = new byte[length]; int bytesRead = 0; while (bytesRead < length) { bytesRead += in.read(buff, bytesRead, in.available()); } token = new String(buff); token = token.replaceAll(\"[\\\\r\\\\f]\", \"\"); token = token.trim(); request.getSession().getServletContext().setAttribute(\"token\", token); out.println(token); request.getSession().getServletContext().removeAttribute(\"token_timeout_processing_lock\"); } else out.println(\"token_timeout_processing_lock\"); } } else { if (request.getSession().getServletContext().getAttribute(\"token\") == null || request.getSession().getServletContext().getAttribute(\"token\").equals(\"\")) { byte[] buff = null; BufferedInputStream bis = null; URL url = new URL(thisPageContextAddress + \"/ServerAdminServlet?action=login&username=\" + username + \"&password=\" + password); URLConnection urlc = url.openConnection(); int length = urlc.getContentLength(); InputStream in = urlc.getInputStream(); buff = new byte[length]; int bytesRead = 0; while (bytesRead < length) { bytesRead += in.read(buff, bytesRead, in.available()); } token = new String(buff); token = token.replaceAll(\"[\\\\r\\\\f]\", \"\"); token = token.trim(); request.getSession().getServletContext().setAttribute(\"token\", token); } out.write(\"\\n\"); out.write(\"<html>\\n\"); out.write(\" <head>\\n\"); out.write(\" <title>AJAX test </title>\\n\"); out.write(\" <link rel=\\\"stylesheet\\\" href=\\\"css/default.css\\\" type=\\\"text/css\\\" />\\n\"); out.write(\"\\n\"); out.write(\" <script type=\\\"text/javascript\\\" src=\\\"../OpenLayers-2.8/OpenLayers.js\\\"></script>\\n\"); out.write(\" <script type=\\\"text/javascript\\\">\\n\"); out.write(\"\\n\"); out.write(\" var map, layer;\\n\"); out.write(\"\\n\"); out.write(\" var token = \\\"\"); out.print(request.getSession().getServletContext().getAttribute(\"token\")); out.write(\"\\\";\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\" function init(){\\n\"); out.write(\"\\n\"); out.write(\" OpenLayers.IMAGE_RELOAD_ATTEMPTS = 5;\\n\"); out.write(\"\\n\"); out.write(\" var options = {\\n\"); out.write(\" maxExtent: new OpenLayers.Bounds(0, 0, 3000000, 9000000),\\n\"); out.write(\" tileSize :new OpenLayers.Size(250, 250),\\n\"); out.write(\" units: 'm',\\n\"); out.write(\" projection: 'EPSG:3006',\\n\"); out.write(\" resolutions : [1.3,2.6,4,6.6,13.2,26.5,66.1,132.3,264.6,793.8,1322.9,2645.8,13229.2,26458.3]\\n\"); out.write(\" }\\n\"); out.write(\"",
        "ground_truth": "NO",
        "predict": "\\n\"); out.write(\" var map = new OpenLayers.Map('map', options);\\n\"); out.write(\"\\n\"); out.write(\" var layer = new OpenLayers.Layer.TMS(\\\"World_Topo_Map\\\", \\\"http://maps.opengeo.org/geowebcache/service/tms/1.0.0/\\\", {\\n\"); out.write(\"\\n\"); out.write(\" type: 'TMS',\\n\"); out.write(\"\\n\"); out.write(\" tms_version: '1.0.0',\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n\"); out.write(\"\\n"
    },
    {
        "ID": 1808,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) throws Exception { PatternLayout pl = new PatternLayout(\"%d{ISO8601} %-5p %c: %m\\n\"); ConsoleAppender ca = new ConsoleAppender(pl); Logger.getRoot().addAppender(ca); Logger.getRoot().setLevel(Level.INFO); Options options = new Options(); options.addOption(\"p\", \"put\", false, \"put a file in the DHT overlay\"); options.addOption(\"g\", \"get\", false, \"get a file from the DHT\"); options.addOption(\"r\", \"remove\", false, \"remove a file from the DHT\"); options.addOption(\"u\", \"update\", false, \"updates the lease\"); options.addOption(\"j\", \"join\", false, \"join the DHT overlay\"); options.addOption(\"c\", \"config\", true, \"the configuration file\"); options.addOption(\"k\", \"key\", true, \"the key to read a file from\"); options.addOption(\"f\", \"file\", true, \"the file to read or write\"); options.addOption(\"a\", \"app\", true, \"the application ID\"); options.addOption(\"s\", \"secret\", true, \"the secret used to hide data\"); options.addOption(\"t\", \"ttl\", true, \"how long in seconds data should persist\"); CommandLineParser parser = new PosixParser(); CommandLine cmd = parser.parse(options, args); String configFile = null; String mode = null; String secretStr = null; int ttl = 9999; String keyStr = null; String file = null; int appId = 0; if (cmd.hasOption(\"j\")) { mode = \"join\"; } if (cmd.hasOption(\"p\")) { mode = \"put\"; } if (cmd.hasOption(\"g\")) { mode = \"get\"; } if (cmd.hasOption(\"r\")) { mode = \"remove\"; } if (cmd.hasOption(\"u\")) { mode = \"update\"; } if (cmd.hasOption(\"c\")) { configFile = cmd.getOptionValue(\"c\"); } if (cmd.hasOption(\"k\")) { keyStr = cmd.getOptionValue(\"k\"); } if (cmd.hasOption(\"f\")) { file = cmd.getOptionValue(\"f\"); } if (cmd.hasOption(\"s\")) { secretStr = cmd.getOptionValue(\"s\"); } if (cmd.hasOption(\"t\")) { ttl = Integer.parseInt(cmd.getOptionValue(\"t\")); } if (cmd.hasOption(\"a\")) { appId = Integer.parseInt(cmd.getOptionValue(\"a\")); } if (mode == null) { System.err.println(\"ERROR: --put or --get or --remove or --join or --update is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (configFile == null) { System.err.println(\"ERROR: --config is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } Properties conf = new Properties(); conf.load(new FileInputStream(configFile)); DHT dht = new DHT(conf); if (mode.equals(\"join\")) { dht.join(); } else if (mode.equals(\"put\")) { if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"putting file \" + file); FileInputStream in = new FileInputStream(file); byte[] tmp = new byte[1000000]; int num = in.read(tmp); byte[] value = new byte[num]; System.arraycopy(tmp, 0, value, 0, num); in.close(); if (dht.put((short) appId, keyStr.getBytes(), value, ttl, secretStr.getBytes()) < 0) { logger.info(\"There was an error while putting a key-value.\"); System.exit(0); } System.out.println(\"Ok!\"); } else if (mode.equals(\"get\")) { if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"getting file \" + file); ArrayList<byte[]> values = new ArrayList<byte[]>(); if (dht.get((short) appId, keyStr.getBytes(), Integer.MAX_VALUE, values) < 0) { logger.info(\"There was an error while getting a value.\"); System.exit(0); } if (values.size() == 0 || values == null) { System.out.println(\"No values returned.\"); System.exit(0); } FileOutputStream out = new FileOutputStream(file); System.out.println(\"Found \" + values.size() + \" values -- saving the first one only.\"); out.write(values.get(0)); out.close(); System.out.println(\"Ok!\"); } else if (mode.equals(\"remove\")) { if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"removing <key,value> for key=\" + keyStr); if (dht.remove((short) appId, keyStr.getBytes(), secretStr.getBytes()) < 0) { logger.info(\"There was an error while removing a key.\"); System.exit(0); } System.out.println(\"Ok!\"); } else if (mode.equals(\"update\")) { if (keyStr == null) { System.err.println(\"ERROR: --key is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options);",
        "ground_truth": "NO",
        "predict": " System.exit(1); } if (secretStr == null) { System.err.println(\"ERROR: --secret is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } if (file == null) { System.err.println(\"ERROR: --file is required\"); HelpFormatter formatter = new HelpFormatter(); formatter.printHelp(\"DHT\", options); System.exit(1); } logger.info(\"updating <key,value> for key=\" + keyStr); FileInputStream in = new FileInputStream(file); byte[] tmp = new byte[1000000]; int num = in.read(tmp); byte[] value = new byte[num]; System.arraycopy(tmp, 0, value, 0, num); in.close(); if (dht.update((short) appId, keyStr.getBytes(), value, secretStr.getBytes()) < 0) { logger.info"
    },
    {
        "ID": 1825,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void copyAndDelete(final URL _src, final long _temp) throws IOException { final File storage = getStorageFile(_src, _temp); final File dest = new File(_src.getFile()); FileChannel in = null; FileChannel out = null; if (storage.equals(dest)) { return; } try { readWriteLock_.lockWrite(); if (dest.exists()) { dest.delete(); } if (storage.exists() && !storage.renameTo(dest)) { in = new FileInputStream(storage).getChannel(); out = new FileOutputStream(dest).getChannel(); final long len = in.size(); final long copied = out.transferFrom(in, 0, in.size()); if (len != copied) { throw new IOException(\"unable to complete write\"); } } } finally { readWriteLock_.unlockWrite(); try { if (in != null) { in.close(); } } catch (final IOException _evt) { FuLog.error(_evt); } try { if (out != null) { out.close(); } } catch (final IOException _evt) { FuLog.error(_evt); } storage.delete(); } }. \n Code2: public static void main(String[] args) throws IOException { String paramFileName = args[0]; BufferedReader inFile_params = new BufferedReader(new FileReader(paramFileName)); String cands_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String alignSrcCand_phrasal_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String alignSrcCand_word_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String source_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String trainSrc_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String trainTgt_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String trainAlign_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String alignCache_fileName = (inFile_params.readLine().split(\"\\\\s+\"))[0]; String alignmentsType = \"AlignmentGrids\"; int maxCacheSize = 1000; inFile_params.close(); int numSentences = countLines(source_fileName); InputStream inStream_src = new FileInputStream(new File(source_fileName)); BufferedReader srcFile = new BufferedReader(new InputStreamReader(inStream_src, \"utf8\")); String[] srcSentences = new String[numSentences]; for (int i = 0; i < numSentences; ++i) { srcSentences[i] = srcFile.readLine(); } srcFile.close(); println(\"Creating src vocabulary @ \" + (new Date())); srcVocab = new Vocabulary(); int[] sourceWordsSentences = Vocabulary.initializeVocabulary(trainSrc_fileName, srcVocab, true); int numSourceWords = sourceWordsSentences[0]; int numSourceSentences = sourceWordsSentences[1]; println(\"Reading src corpus @ \" + (new Date())); srcCorpusArray = SuffixArrayFactory.createCorpusArray(trainSrc_fileName, srcVocab, numSourceWords, numSourceSentences); println(\"Creating src SA @ \" + (new Date())); srcSA = SuffixArrayFactory.createSuffixArray(srcCorpusArray, maxCacheSize); println(\"Creating tgt vocabulary @ \" + (new Date())); tgtVocab = new Vocabulary(); int[] targetWordsSentences = Vocabulary.initializeVocabulary(trainTgt_fileName, tgtVocab, true); int numTargetWords = targetWordsSentences[0]; int numTargetSentences = targetWordsSentences[1]; println(\"Reading tgt corpus @ \" + (new Date())); tgtCorpusArray = SuffixArrayFactory.createCorpusArray(trainTgt_fileName, tgtVocab, numTargetWords, numTargetSentences); println(\"Creating tgt SA @ \" + (new Date())); tgtSA = SuffixArrayFactory.createSuffixArray(tgtCorpusArray, maxCacheSize); int trainingSize = srcCorpusArray.getNumSentences(); if (trainingSize != tgtCorpusArray.getNumSentences()) { throw new RuntimeException(\"Source and target corpora have different number of sentences. This is bad.\"); } println(\"Reading alignment data @ \" + (new Date())); alignments = null; if (\"AlignmentArray\".equals(alignmentsType)) { alignments = SuffixArrayFactory.createAlignments(trainAlign_fileName, srcSA, tgtSA); } else if (\"AlignmentGrids\".equals(alignmentsType) || \"AlignmentsGrid\".equals(alignmentsType)) { alignments = new AlignmentGrids(new Scanner(new File(trainAlign_fileName)), srcCorpusArray, tgtCorpusArray, trainingSize, true); } else if (\"MemoryMappedAlignmentGrids\".equals(alignmentsType)) { alignments = new MemoryMappedAlignmentGrids(trainAlign_fileName, srcCorpusArray, tgtCorpusArray); } if (!fileExists(alignCache_fileName)) { alreadyResolved_srcSet = new HashMap<String, TreeSet<Integer>>(); alreadyResolved_tgtSet = new HashMap<String, TreeSet<Integer>>(); } else { try { ObjectInputStream in = new ObjectInputStream(new FileInputStream(alignCache_fileName)); alreadyResolved_srcSet = (HashMap<String, TreeSet<Integer>>) in.readObject(); alreadyResolved_tgtSet = (HashMap<String, TreeSet<Integer>>) in.readObject(); in.close(); } catch (FileNotFoundException e) { System.err.println(\"FileNotFoundException in AlignCandidates.main(String[]): \" + e.getMessage()); System.exit(99901); } catch (IOException e) { System.err.println(\"IOException in AlignCandidates.main(String[]): \" + e.getMessage()); System.exit(99902); } catch (ClassNotFoundException e) { System.err.println(\"ClassNotFoundException in AlignCandidates.main(String[]): \" + e.getMessage()); System.exit(99904); } } println(\"Processing candidates @ \" + (new Date())); PrintWriter outFile_alignSrcCand_phrasal = new PrintWriter(alignSrcCand_phrasal_fileName); PrintWriter outFile_alignSrcCand_word = new PrintWriter(alignSrcCand_word_fileName); Input",
        "ground_truth": "NO",
        "predict": "Stream inStream_alignSrcCand_phrasal = new FileInputStream(new File(alignSrcCand_phrasal_fileName)); BufferedReader inFile_alignSrcCand_phrasal = new BufferedReader(new InputStreamReader(inStream_alignSrcCand_phrasal, \"utf8\")); InputStream inStream_alignSrcCand_word = new FileInputStream(new File(alignSrcCand_word_fileName)); BufferedReader inFile_alignSrcCand_word = new BufferedReader(new InputStreamReader(inStream_alignSrcCand_word, \"utf8\")); PrintWriter outFile_alignSrcCand_phrasal_temp = new PrintWriter(alignSrcCand_phrasal_fileName + \".temp\"); PrintWriter outFile_alignSrcCand_word_temp = new PrintWriter(alignSrcCand_word_fileName + \".temp\"); int numSentences = countL"
    },
    {
        "ID": 1827,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Code2: public static boolean copyFile(File outFile, File inFile) { InputStream inStream = null; OutputStream outStream = null; try { if (outFile.createNewFile()) { inStream = new FileInputStream(inFile); outStream = new FileOutputStream(outFile); byte[] buffer = new byte[1024]; int length; while ((length = inStream.read(buffer)) > 0) outStream.write(buffer, 0, length); inStream.close(); outStream.close(); } else return false; } catch (IOException iox) { iox.printStackTrace(); return false; } return true; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public APIResponse create(Application application) throws Exception { APIResponse response = new APIResponse(); connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection(); connection.setDoOutput(true); connection.setRequestMethod(\"POST\"); connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\"); connection.setUseCaches(false); connection.setConnectTimeout(TIMEOUT); connection.connect(); marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\"))); connection.getOutputStream().flush(); connection.getOutputStream().close(); if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) { JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine())); response.setDone(true); response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration())))); connection.getInputStream().close(); } else { response.setDone(false); response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\"); } connection.disconnect(); return response; }. \n Code2: private static void copy(String sourceName, String destName) throws IOException { File source = new File(sourceName); File dest = new File(destName); FileChannel in = null, out = null; try { in = new FileInputStream(source).getChannel(); out = new FileOutputStream(dest).getChannel(); long size = in.size(); MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size); out.write(buf); } finally { if (in != null)",
        "ground_truth": "NO",
        "predict": " in.close(); if (out != null) out.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public APIResponse create(Application application) throws Exception { APIResponse response = new APIResponse(); connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection(); connection.setDoOutput(true); connection.setRequestMethod(\"POST\"); connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\"); connection.setUseCaches(false); connection.setConnectTimeout(TIMEOUT); connection.connect(); marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\"))); connection.getOutputStream().flush(); connection.get"
    },
    {
        "ID": 1829,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Code2: protected IStatus run(IProgressMonitor monitor) { try { updateRunning = true; distributor = getFromFile(\"[SERVER]\", \"csz\", getAppPath() + \"/server.ini\"); MAC = getFromFile(\"[SPECIFICINFO]\", \"MAC\", getAppPath() + \"/register.ini\"); serial = getFromFile(\"[SPECIFICINFO]\", \"serial\", getAppPath() + \"/register.ini\"); if (MAC.equals(\"not_found\") || serial.equals(\"not_found\") || !serial.startsWith(distributor)) { try { MAC = getFromFile(\"[SPECIFICINFO]\", \"MAC\", getAppPath() + \"/register.ini\"); serial = getFromFile(\"[SPECIFICINFO]\", \"serial\", getAppPath() + \"/register.ini\"); } catch (Exception e) { System.out.println(e); } } else { try { url = new URL(\"http://\" + getFromFile(\"[SERVER]\", \"url\", getAppPath() + \"/server.ini\")); } catch (MalformedURLException e) { System.out.println(e); } download = \"/download2.php?distributor=\" + distributor + \"&&mac=\" + MAC + \"&&serial=\" + serial; readXML(); if (htmlMessage.contains(\"error\")) { try { PrintWriter pw = new PrintWriter(getAppPath() + \"/register.ini\"); pw.write(\"\"); pw.close(); } catch (IOException e) { System.out.println(e); } setProperty(IProgressConstants.ICON_PROPERTY, IconImg.liveUpIco); if (isModal(this)) { showResults2(); } else { setProperty(IProgressConstants.KEEP_PROPERTY, Boolean.TRUE); setProperty(IProgressConstants.ACTION_PROPERTY, getUpdateCompletedAction2()); } } else { if (!getDBVersion().equals(latestVersion)) { try { OutputStream out = null; HttpURLConnection conn = null; InputStream in = null; int size; try { URL url = new URL(fileLoc); String outFile = getAppPath() + \"/temp/\" + getFileName(url); File oFile = new File(outFile); oFile.delete(); out = new BufferedOutputStream(new FileOutputStream(outFile)); monitor.beginTask(\"Connecting to NWD Server\", 100); conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(20000); conn.connect(); if (conn.getResponseCode() / 100 != 2) { System.out.println(\"Error: \" + conn.getResponseCode()); return null; } monitor.worked(100); monitor.done(); size = conn.getContentLength(); monitor.beginTask(\"Download Worm Definition\", size); in = conn.getInputStream(); byte[] buffer; String downloadedSize; long numWritten = 0; boolean status = true; while (status) { if (size - numWritten > 1024) { buffer = new byte[1024]; } else { buffer = new byte[(int) (size - numWritten)]; } int read = in.read(buffer); if (read == -1) { break; } out.write(buffer, 0, read); numWritten += read; downloadedSize = Long.toString(numWritten / 1024) + \" KB\"; monitor.worked(read); monitor.subTask(downloadedSize + \" of \" + Integer.toString(size / 1024) + \" KB\"); if (size == numWritten) { status = false; } if (monitor.isCanceled()) return Status.CANCEL_STATUS; } if (in != null) { in.close(); } if (out != null) { out.close(); } try { ZipFile zFile = new ZipFile(outFile); Enumeration all = zFile.entries(); while (all.hasMoreElements()) { ZipEntry zEntry = (ZipEntry) all.nextElement(); long zSize = zEntry.getSize(); if (zSize > 0) { if (zEntry.getName().endsWith(\"script\")) { InputStream instream = zFile.getInputStream(zEntry); FileOutputStream fos = new FileOutputStream(oldLoc[0]); int ch; while ((ch = instream.read()) != -1) { fos.write(ch); } instream.close(); fos.close(); } else if (zEntry.getName().endsWith(\"data\")) { InputStream instream = zFile.getInputStream(zEntry); FileOutputStream fos = new FileOutputStream(oldLoc[1]); int ch; while ((ch = instream.read()) != -1) { fos.write(ch); } instream.close(); fos.close(); } } } File xFile = new File(outFile); xFile.deleteOnExit(); } catch (Exception e) { e.printStackTrace(); } try { monitor.done(); monitor.beginTask(\"Install Worm Definition\", 10000); monitor.worked(2500); CorePlugin.getDefault().getRawPacketHandler().removeRawPacketListener(p); p = null; if (!wormDB.getConn().isClosed()) { shutdownDB(); } System.out.println(wormDB.getConn().isClosed()); for (int i = 0; i < 2; i++) { try { Process pid = Runtime.getRuntime().exec(\"cmd /c copy \\\"\" + oldLoc[i].replace(\"/\", \"\\\\\") + \"\\\" \\\"\" + newLoc[i].replace(\"/\", \"\\\\\") + \"\\\"/y\"); } catch (Exception e) { e.printStackTrace(); } new File(oldLoc[i]).deleteOnExit(); } monitor.worked(2500); initialArray(); p = new PacketPrinter(); CorePlugin.getDefault().getRawPacketHandler().addRawPacketListener(p); monitor.worked(2500); monitor.done(); setProperty(IProgressConstants.ICON_PROPERTY, IconImg.live",
        "ground_truth": "NO",
        "predict": "UpIco); if (isModal(this)) { showResults2(); } else { setProperty(IProgressConstants.KEEP_PROPERTY, Boolean.TRUE); setProperty(IProgressConstants.ACTION_PROPERTY, getUpdateCompletedAction2()); } } catch (Exception e) { e.printStackTrace(); } } catch (Exception e) { e.printStackTrace(); } } } catch (Exception e) { e.printStackTrace(); } } }\n"
    },
    {
        "ID": 1832,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testSystemPropertyConnector() throws Exception { final String rootFolderPath = \"test/ConnectorTest/fs/\".toLowerCase(); final Connector connector = new SystemPropertyConnector(); final ContentResolver contentResolver = new UnionContentResolver(); final FSContentResolver fsContentResolver = new FSContentResolver(); fsContentResolver.setRootFolderPath(rootFolderPath); contentResolver.addContentResolver(fsContentResolver); contentResolver.addContentResolver(new ClasspathContentResolver()); connector.setContentResolver(contentResolver); String resultString; byte[] resultContent; Object resultObject; resultString = connector.getString(\"helloWorldPath\"); assertNull(resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNull(resultContent); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"file:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"file:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNull(resultObject); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"classpath:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"classpath:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); final InputStream helloWorldIS = new ByteArrayInputStream(\"Hello World 2 - Test\".getBytes(\"UTF-8\")); FileUtils.forceMkdir(new File(rootFolderPath + \"/org/settings4j/connector\")); final String helloWorldPath = rootFolderPath + \"/org/settings4j/connector/HelloWorld2.txt\"; final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath)); IOUtils.copy(helloWorldIS, fileOutputStream); IOUtils.closeQuietly(helloWorldIS); IOUtils.closeQuietly(fileOutputStream); LOG.info(\"helloWorld2Path: \" + helloWorldPath); System.setProperty(\"helloWorldPath\", \"file:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"file:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2 - Test\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2 - Test\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); System.setProperty(\"helloWorldPath\", \"classpath:org/settings4j/connector/HelloWorld2.txt\"); resultString = connector.getString(\"helloWorldPath\"); assertNotNull(resultString); assertEquals(\"classpath:org/settings4j/connector/HelloWorld2.txt\", resultString); resultContent = connector.getContent(\"helloWorldPath\"); assertNotNull(resultContent); assertEquals(\"Hello World 2\", new String(resultContent, \"UTF-8\")); resultObject = connector.getObject(\"helloWorldPath\"); assertNull(resultObject); }. \n Code2: public static boolean decodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { try { in.close(); } catch (Exception exc) { } try { out.close(); } catch (Exception exc) { } } return success; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String hashPasswordForOldMD5(String password) { try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(password.getBytes(\"UTF-8\")); byte messageDigest[] = md.digest(); StringBuffer hexString = new StringBuffer(); for (int i = 0; i < messageDigest.length; i++) { String hex = Integer.toHexString(0xFF & messageDigest[i]); if (hex.length() == 1) { hexString.append('0'); } hexString.append(hex); } return hexString.toString(); } catch (NoSuchAlgorithmException nsae) { throw new IllegalStateException(nsae.getMessage()); } catch (UnsupportedEncodingException uee) { throw new IllegalStateException(uee.getMessage()); } }. \n Code2: public InputStream loadResource(String location) throws GenericConfigException { URL url = get",
        "ground_truth": "NO",
        "predict": "Class().getResource(location); if (url == null) { throw new GenericConfigException(\"Resource not found: \" + location); } return url.openStream(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static String getString(String key) { return System.getProperty(key); }. \n Code2: public static String getString(String key) { return System.getProperty(key); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Object getObject(String key) { return System.getProperty(key); }. \n Code2: public static Object getObject(String key) { return System.getProperty(key); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and"
    },
    {
        "ID": 1839,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getSummaryText() { if (summaryText == null) { for (Iterator iter = xdcSources.values().iterator(); iter.hasNext(); ) { XdcSource source = (XdcSource) iter.next(); File packageFile = new File(source.getFile().getParentFile(), \"xdc-package.html\"); if (packageFile.exists()) { Reader in = null; try { in = new FileReader(packageFile); StringWriter out = new StringWriter(); IOUtils.copy(in, out); StringBuffer buf = out.getBuffer(); int pos1 = buf.indexOf(\"<body>\"); int pos2 = buf.lastIndexOf(\"</body>\"); if (pos1 >= 0 && pos1 < pos2) { summaryText = buf.substring(pos1 + 6, pos2); } else { summaryText = \"\"; } } catch (FileNotFoundException e) { LOG.error(e.getMessage(), e); summaryText = \"\"; } catch (IOException e) { LOG.error(e.getMessage(), e); summaryText = \"\"; } finally { if (in != null) { try { in.close(); } catch (IOException e) { LOG.error(e.getMessage(), e); } } } break; } else { summaryText = \"\"; } } } return summaryText; }. \n Code2: public void handleEvent(Event event) { if (fileDialog == null) { fileDialog = new FileDialog(getShell(), SWT.OPEN); fileDialog.setText(\"Open device profile file...\"); fileDialog.setFilterNames(new String[] { \"Device profile (*.jar)\" }); fileDialog.setFilterExtensions(new String[] { \"*.jar\" }); } fileDialog.open(); if (fileDialog.getFileName() != null) { File file; String manifestDeviceName = null; URL[] urls = new URL[1]; ArrayList descriptorEntries = new ArrayList(); try { file = new File(fileDialog.getFilterPath(), fileDialog.getFileName()); JarFile jar = new JarFile(file); Manifest manifest = jar.getManifest(); if (manifest != null) { Attributes attrs = manifest.getMainAttributes(); manifestDeviceName = attrs.getValue(\"Device-Name\"); } for (Enumeration en = jar.entries(); en.hasMoreElements(); ) { String entry = ((JarEntry) en.nextElement()).getName(); if ((entry.toLowerCase().endsWith(\".xml\") || entry.toLowerCase().endsWith(\"device.txt\")) && !entry.toLowerCase().startsWith(\"meta-inf\")) { descriptorEntries.add(entry); } } jar.close(); urls[0] = file.toURL(); } catch (IOException ex) { Message.error(\"Error reading file: \" + fileDialog.getFileName() + \", \" + Message.getCauseMessage(ex), ex); return; } if (descriptorEntries.size() == 0) { Message.error(\"Cannot find any device profile in file: \" + fileDialog.getFileName()); return; } if (descriptorEntries.size() > 1) { manifestDeviceName = null; } ClassLoader classLoader = Common.createExtensionsClassLoader(urls); HashMap devices = new HashMap(); for (Iterator it = descriptorEntries.iterator(); it.hasNext(); ) { JarEntry entry = (JarEntry) it.next(); try { devices.put(entry.getName(), DeviceImpl.create(emulatorContext, classLoader, entry.getName(), SwtDevice.class)); } catch (IOException ex) { Message.error(\"Error parsing device profile, \" + Message.getCauseMessage(ex), ex); return; } } for (int i = 0; i < deviceModel.size(); i++) { DeviceEntry entry = (DeviceEntry) deviceModel.elementAt(i); if (devices.containsKey(entry.getDescriptorLocation())) { devices.remove(entry.getDescriptorLocation()); } } if (devices.size() == 0) { Message.info(\"Device profile already added\"); return; } try { File deviceFile = new File(Config.getConfigPath(), file.getName()); if (deviceFile.exists()) { deviceFile = File.createTempFile(\"device\", \".jar\", Config.getConfigPath()); } IOUtils.copyFile(file, deviceFile); DeviceEntry entry = null; for (Iterator it = devices.keySet().iterator(); it.hasNext(); ) { String descriptorLocation = (String) it.next(); Device device = (Device) devices.get(descriptorLocation); if (manifestDeviceName != null) { entry = new DeviceEntry(manifestDeviceName, deviceFile.getName(), descriptorLocation, false); } else { entry = new DeviceEntry(device.getName(), deviceFile.getName(), descriptorLocation, false); } deviceModel.addElement(entry); for (int i = 0; i < deviceModel.size(); i++) { if (deviceModel.elementAt(i) == entry) { lsDevices.add(entry.getName()); lsDevices.select(i); } } Config.addDeviceEntry(entry); } lsDevicesListener.widgetSelected(null); } catch (IOException ex) { Message.error(\"Error adding device profile, \" + Message.getCauseMessage(ex), ex); return; } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void processAddByURLSubmit(URL url, String invalidUrlMsg) { if (!this.hasError()) { try { StringWriter xmlSourceWriter = new StringWriter(); IOUtils.copy(url.openStream(), xmlSourceWriter); processSubmittedDoap(xmlSourceWriter.toString()); } catch (FileNotFoundException e) { Session.get().error(invalidUrlMsg); logger.warn(\"Error processing URL: \" + invalidUrlMsg); } catch (IOException e) { setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e))); logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e); } } }. \n Code2: public static void Sample1(String myField, String condition1, String condition2) throws SQLException { Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\"); connection.setAutoCommit(false); PreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\"); ps.setString(1, myField); ps.setString(2, condition1); ps.setString(3, condition2); // If more than 10 entries change, panic and",
        "ground_truth": "NO",
        "predict": " rollback.\n ps.executeUpdate(); connection.commit(); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void processSubmittedDoap(String xml) { if (!this.hasError()) { try { processDoap(xml); } catch (Exception e) { setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap\", DoapFormPage.class, e))); } } }. \n Code2: public static void Sample2(String myField, String condition1, String condition2) throws SQLException { Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\"); connection.setAutoCommit(false); PreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2"
    },
    {
        "ID": 1841,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { String command = \"java -jar \"; String linkerJarPath = \"\"; String path = \"\"; String osName = System.getProperty(\"os.name\"); String temp = Launcher.class.getResource(\"\").toString(); int index = temp.indexOf(\".jar\"); int start = index - 1; while (Character.isLetter(temp.charAt(start))) { start--; } String jarName = temp.substring(start + 1, index + 4); System.out.println(jarName); if (osName.startsWith(\"Linux\")) { temp = temp.substring(temp.indexOf(\"/\"), temp.indexOf(jarName)); } else if (osName.startsWith(\"Windows\")) { temp = temp.substring(temp.indexOf(\"file:\") + 5, temp.indexOf(jarName)); } else { System.exit(0); } path = path + temp; try { path = java.net.URLDecoder.decode(path, \"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } File dir = new File(path); File[] files = dir.listFiles(); String exeJarName = null; for (File f : files) { if (f.getName().endsWith(\".jar\") && !f.getName().startsWith(jarName)) { exeJarName = f.getName(); break; } } if (exeJarName == null) { System.out.println(\"no exefile\"); System.exit(0); } linkerJarPath = path + exeJarName; String pluginDirPath = path + \"plugin\" + File.separator; File[] plugins = new File(pluginDirPath).listFiles(); StringBuffer pluginNames = new StringBuffer(\"\"); for (File plugin : plugins) { if (plugin.getAbsolutePath().endsWith(\".jar\")) { pluginNames.append(\"plugin/\" + plugin.getName() + \" \"); } } String libDirPath = path + \"lib\" + File.separator; File[] libs = new File(libDirPath).listFiles(); StringBuffer libNames = new StringBuffer(\"\"); for (File lib : libs) { if (lib.getAbsolutePath().endsWith(\".jar\")) { libNames.append(\"lib/\" + lib.getName() + \" \"); } } try { JarFile jarFile = new JarFile(linkerJarPath); Manifest manifest = jarFile.getManifest(); if (manifest == null) { manifest = new Manifest(); } Attributes attributes = manifest.getMainAttributes(); attributes.putValue(\"Class-Path\", pluginNames.toString() + libNames.toString()); String backupFile = linkerJarPath + \"back\"; FileInputStream copyInput = new FileInputStream(linkerJarPath); FileOutputStream copyOutput = new FileOutputStream(backupFile); byte[] buffer = new byte[4096]; int s; while ((s = copyInput.read(buffer)) > -1) { copyOutput.write(buffer, 0, s); } copyOutput.flush(); copyOutput.close(); copyInput.close(); JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(linkerJarPath), manifest); JarInputStream jarIn = new JarInputStream(new FileInputStream(backupFile)); byte[] buf = new byte[4096]; JarEntry entry; while ((entry = jarIn.getNextJarEntry()) != null) { if (\"META-INF/MANIFEST.MF\".equals(entry.getName())) continue; jarOut.putNextEntry(entry); int read; while ((read = jarIn.read(buf)) != -1) { jarOut.write(buf, 0, read); } jarOut.closeEntry(); } jarOut.flush(); jarOut.close(); jarIn.close(); File file = new File(backupFile); if (file.exists()) { file.delete(); } } catch (IOException e1) { e1.printStackTrace(); } try { if (System.getProperty(\"os.name\").startsWith(\"Linux\")) { Runtime runtime = Runtime.getRuntime(); String[] commands = new String[] { \"java\", \"-jar\", path + exeJarName }; runtime.exec(commands); } else { path = path.substring(1); command = command + \"\\\"\" + path + exeJarName + \"\\\"\"; System.out.println(command); Runtime.getRuntime().exec(command); } } catch (IOException e) { e.printStackTrace(); } }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr",
        "ground_truth": "NO",
        "predict": "><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(added + deleted + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"</table>\\n\" + \"</div></body></html>\"); out.close(); }. \n Code3: private void displayDiffResults(String file1, String file2) throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" +"
    },
    {
        "ID": 1846,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { try { String completePath = null; String predictionFileName = null; if (args.length == 2) { completePath = args[0]; predictionFileName = args[1]; } else { System.out.println(\"Please provide complete path to training_set parent folder as an argument. EXITING\"); System.exit(0); } File inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName); FileChannel inC = new FileInputStream(inputFile).getChannel(); int filesize = (int) inC.size(); ByteBuffer mappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); MovieLimitsTHash = new TShortObjectHashMap(17770, 1); int i = 0, totalcount = 0; short movie; int startIndex, endIndex; TIntArrayList a; while (mappedfile.hasRemaining()) { movie = mappedfile.getShort(); startIndex = mappedfile.getInt(); endIndex = mappedfile.getInt(); a = new TIntArrayList(2); a.add(startIndex); a.add(endIndex); MovieLimitsTHash.put(movie, a); } inC.close(); mappedfile = null; System.out.println(\"Loaded movie index hash\"); inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustIndexFileName); inC = new FileInputStream(inputFile).getChannel(); filesize = (int) inC.size(); mappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); CustomerLimitsTHash = new TIntObjectHashMap(480189, 1); int custid; while (mappedfile.hasRemaining()) { custid = mappedfile.getInt(); startIndex = mappedfile.getInt(); endIndex = mappedfile.getInt(); a = new TIntArrayList(2); a.add(startIndex); a.add(endIndex); CustomerLimitsTHash.put(custid, a); } inC.close(); mappedfile = null; System.out.println(\"Loaded customer index hash\"); MoviesAndRatingsPerCustomer = InitializeMovieRatingsForCustomerHashMap(completePath, CustomerLimitsTHash); System.out.println(\"Populated MoviesAndRatingsPerCustomer hashmap\"); File outfile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + predictionFileName); FileChannel out = new FileOutputStream(outfile, true).getChannel(); inputFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + \"formattedProbeData.txt\"); inC = new FileInputStream(inputFile).getChannel(); filesize = (int) inC.size(); ByteBuffer probemappedfile = inC.map(FileChannel.MapMode.READ_ONLY, 0, filesize); int custAndRatingSize = 0; TIntByteHashMap custsandratings = new TIntByteHashMap(); int ignoreProcessedRows = 0; int movieViewershipSize = 0; while (probemappedfile.hasRemaining()) { short testmovie = probemappedfile.getShort(); int testCustomer = probemappedfile.getInt(); if ((CustomersAndRatingsPerMovie != null) && (CustomersAndRatingsPerMovie.containsKey(testmovie))) { } else { CustomersAndRatingsPerMovie = InitializeCustomerRatingsForMovieHashMap(completePath, testmovie); custsandratings = (TIntByteHashMap) CustomersAndRatingsPerMovie.get(testmovie); custAndRatingSize = custsandratings.size(); } TShortByteHashMap testCustMovieAndRatingsMap = (TShortByteHashMap) MoviesAndRatingsPerCustomer.get(testCustomer); short[] testCustMovies = testCustMovieAndRatingsMap.keys(); float finalPrediction = 0; finalPrediction = predictRating(testCustomer, testmovie, custsandratings, custAndRatingSize, testCustMovies, testCustMovieAndRatingsMap); System.out.println(\"prediction for movie: \" + testmovie + \" for customer \" + testCustomer + \" is \" + finalPrediction); ByteBuffer buf = ByteBuffer.allocate(11); buf.putShort(testmovie); buf.putInt(testCustomer); buf.putFloat(finalPrediction); buf.flip(); out.write(buf); buf = null; testCustMovieAndRatingsMap = null; testCustMovies = null; } } catch (Exception e) { e.printStackTrace(); } }. \n Code2: public void fileCopy(File inFile, File outFile) { try { FileInputStream in = new FileInputStream(inFile); FileOutputStream out = new FileOutputStream(outFile); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } catch (IOException e) { System.err.println(\"Hubo un error de entrada/salida!!!\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean check(String urlStr) { try { URL url = new URL(urlStr); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setConnectTimeout(2000); urlConnection.getContent(); } catch (Exception e) { logger.error(\"There is no internet connection\", e); return false; } return true; }. \n Code2: public void update(String channelPath, String dataField, String fatherDocId) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \"; Connection conn = null; ResultSet rs = null; PreparedStatement ps = null; try { dbo = (ERDBOperation) createDBOperation(); String url = \"\"; boolean flag = true; StringTokenizer st = null; conn = dbo.getConnection(); conn.setAutoCommit(false); ps = conn.prepareStatement(sqlInitial); rs = ps.executeQuery(); if (rs.next()) url = rs.getString(1); if (!url.equals(\"\")) { st = new StringTokenizer(url, \",\"); String sort",
        "ground_truth": "NO",
        "predict": "URL = \"\"; while (st.hasMoreTokens()) { sortURL += st.nextToken() + \",\"; } sortURL = sortURL.substring(0, sortURL.length() - 1); } else { flag = false; } if (flag) { ps = conn.prepareStatement(sqlsortURL); ps.setString(1, sortURL); ps.executeUpdate(); } } catch (Exception e) { logger.error(\"Error in update\", e); } finally { try { if (rs != null) rs.close(); if (ps != null) ps.close(); if (conn != null) conn.close(); } catch (Exception e) { logger.error(\"Error in closing connection\", e); } } }. \n Code3: public void update(String channelPath, String dataField, String fatherDocId, String fatherDocId2) { String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDoc"
    },
    {
        "ID": 1852,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void copy(File from_file, File to_file) throws IOException { if (!from_file.exists()) { throw new IOException(\"FileCopy: no such source file: \" + from_file.getPath()); } if (!from_file.isFile()) { throw new IOException(\"FileCopy: can't copy directory: \" + from_file.getPath()); } if (!from_file.canRead()) { throw new IOException(\"FileCopy: source file is unreadable: \" + from_file.getPath()); } if (to_file.isDirectory()) { to_file = new File(to_file, from_file.getName()); } if (to_file.exists()) { if (!to_file.canWrite()) { throw new IOException(\"FileCopy: destination file is unwriteable: \" + to_file.getPath()); } int choice = JOptionPane.showConfirmDialog(null, \"Overwrite existing file \" + to_file.getPath(), \"File Exists\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE); if (choice != JOptionPane.YES_OPTION) { throw new IOException(\"FileCopy: existing file was not overwritten.\"); } } else { String parent = to_file.getParent(); if (parent == null) { parent = Globals.getDefaultPath(); } File dir = new File(parent); if (!dir.exists()) { throw new IOException(\"FileCopy: destination directory doesn't exist: \" + parent); } if (dir.isFile()) { throw new IOException(\"FileCopy: destination is not a directory: \" + parent); } if (!dir.canWrite()) { throw new IOException(\"FileCopy: destination directory is unwriteable: \" + parent); } } FileInputStream from = null; FileOutputStream to = null; try { from = new FileInputStream(from_file); to = new FileOutputStream(to_file); byte[] buffer = new byte[4096]; int bytes_read; while ((bytes_read = from.read(buffer)) != -1) { to.write(buffer, 0, bytes_read); } } finally { if (from != null) { try { from.close(); } catch (IOException e) { } } if (to != null) { try { to.close(); } catch (IOException e) { } } } }. \n Code2: public static void main(String[] args) { if (args.length <= 0) { System.out.println(\" *** SQL script generator and executor ***\"); System.out.println(\" You must specify name of the file with SQL script data\"); System.out.println(\" Fisrt rows of this file must be:\"); System.out.println(\" 1) JDBC driver class for your DBMS\"); System.out.println(\" 2) URL for your database instance\"); System.out.println(\" 3) user in that database (with administrator priviliges)\"); System.out.println(\" 4) password of that user\"); System.out.println(\" Next rows can have: '@' before schema to create,\"); System.out.println(\" '#' before table to create, '&' before table to insert,\"); System.out.println(\" '$' before trigger (inverse 'FK on delete cascade') to create,\"); System.out.println(\" '>' before table to drop, '<' before schema to drop.\"); System.out.println(\" Other rows contain parameters of these actions:\"); System.out.println(\" for & action each parameter is a list of values,\"); System.out.println(\" for @ -//- is # acrion, for # -//- is column/constraint \"); System.out.println(\" definition or $ action. $ syntax to delete from table:\"); System.out.println(\" fullNameOfTable:itsColInWhereClause=matchingColOfThisTable\"); System.out.println(\" '!' before row means that it is a comment.\"); System.out.println(\" If some exception is occured, all script is rolled back.\"); System.out.println(\" If you specify 2nd command line argument - file name too -\"); System.out.println(\" connection will be established but all statements will\"); System.out.println(\" be saved in that output file and not transmitted to DB\"); System.out.println(\" If you specify 3nd command line argument - connect_string -\"); System.out.println(\" connect information will be added to output file\"); System.out.println(\" in the form 'connect user/password@connect_string'\"); System.exit(0); } try { String[] info = new String[4]; BufferedReader reader = new BufferedReader(new FileReader(new File(args[0]))); Writer writer = null; try { for (int i = 0; i < 4; i++) info[i] = reader.readLine(); try { Class.forName(info[0]); Connection connection = DriverManager.getConnection(info[1], info[2], info[3]); SQLScript script = new SQLScript(connection); if (args.length > 1) { writer = new FileWriter(args[1]); if (args.length > 2) writer.write(\"connect \" + info[2] + \"/\" + info[3] + \"@\" + args[2] + script.statementTerminator); } try { System.out.println(script.executeScript(reader, writer) + \" updates has been performed during script execution\"); } catch (SQLException e4) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Script execution error: \" + e4); } connection.close(); } catch (Exception e3) { reader.close(); if (writer != null) writer.close(); System.out.println(\" Connection error: \" + e3); } } catch (IOException e2) { System.out.println(\"Error in file \" + args[0]); } } catch (FileNotFoundException e1) { System.out.println(\"File \" + args[0] + \" not found\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException { byte[] hash; try { MessageDigest digest = MessageDigest.getInstance(\"SHA-256\"); digest.reset(); digest.update(PasswordSalt.getBytes(\"UTF-16\")); hash = digest.digest(passwordHash.getBytes(\"UTF-16\")); return bytesToHex(hash); } catch (NoSuchAlgorithmException ex) { throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\"); } catch (UnsupportedEncodingException ex) { throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\"); } }. \n Code2: public static void do",
        "ground_truth": "NO",
        "predict": "Nothing() { }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void main(String[] args) { if (args.length <= 0) { System.out.println(\" *** SQL script generator and executor ***\"); System.out.println(\" You must specify name of the file with SQL script data\"); System.out.println(\" Fisrt rows of this file must be:\"); System.out.println(\" 1) JDBC driver class for your DBMS\"); System.out.println(\" 2) URL for your database instance\"); System.out.println(\" 3) user in that database (with administrator priviliges)\"); System.out.println(\" 4) password of that user\"); System.out.println(\" Next rows can have: '@' before schema to create,\"); System.out.println(\" '#' before table to create, '&' before table to insert,\");"
    },
    {
        "ID": 1854,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static boolean encodeFileToFile(String infile, String outfile) { boolean success = false; java.io.InputStream in = null; java.io.OutputStream out = null; try { in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE); out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile)); byte[] buffer = new byte[65536]; int read = -1; while ((read = in.read(buffer)) >= 0) { out.write(buffer, 0, read); } success = true; } catch (java.io.IOException exc) { exc.printStackTrace(); } finally { closeQuietly(in); closeQuietly(out); } return success; }. \n Code2: protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String pathInfo = request.getPathInfo(); getLog().info(\"Process request \" + pathInfo); if (null != pathInfo) { String pathId = getPathId(pathInfo); JobResources res = ContextUtil.getJobResource(pathId); if (null != res) { RequestType requType = getRequestType(request); ResultAccess access = new ResultAccess(res); Collection<Long> uIdColl = res.getUniqIds(); boolean isFiltered = false; { List<String> postSeqIds = getSeqList(request); if (!postSeqIds.isEmpty()) { isFiltered = true; uIdColl = access.loadIds(postSeqIds); } } try { if ((requType.equals(RequestType.FASTA)) || (requType.equals(RequestType.SWISSPROT))) { OutputStreamWriter out = null; out = new OutputStreamWriter(response.getOutputStream()); for (Long uid : uIdColl) { if (requType.equals(RequestType.FASTA)) { SwissProt sw = access.getSwissprotEntry(uid); if (null != sw) { PrintFactory.instance().print(ConvertFactory.instance().SwissProt2fasta(sw), out); } else { System.err.println(\"Not able to read Swissprot entry \" + uid + \" in project \" + res.getBaseDir()); } } else if (requType.equals(RequestType.SWISSPROT)) { File swissFile = res.getSwissprotFile(uid); if (swissFile.exists()) { InputStream in = null; try { in = new FileInputStream(swissFile); IOUtils.copy(in, out); } catch (IOException e) { e.printStackTrace(); System.err.println(\"Problems with reading file to output stream \" + swissFile); } finally { IOUtils.closeQuietly(in); } } else { System.err.println(\"Swissprot file does not exist: \" + swissFile); } } } out.flush(); } else { if (uIdColl.size() <= 2) { isFiltered = false; uIdColl = res.getUniqIds(); } Tree tree = access.getTreeByUniquId(uIdColl); if (requType.equals(RequestType.TREE)) { response.getWriter().write(tree.toNewHampshireX()); } else if (requType.equals(RequestType.PNG)) { List<SwissProt> sp = access.getSwissprotEntriesByUniquId(uIdColl); ImageMap map = ImageFactory.instance().createProteinCard(sp, tree, true, res); response.setContentType(\"image/png\"); response.addHeader(\"Content-Disposition\", \"filename=ProteinCards.png\"); ImageFactory.instance().printPNG(map.getImage(), response.getOutputStream()); response.getOutputStream().flush(); } else if (requType.equals(RequestType.HTML)) { List<SwissProt> sp = access.getSwissprotEntriesByUniquId(uIdColl); createHtml(res, access, tree, request, response, sp, isFiltered); } } } catch (Exception e) { e.printStackTrace(); getLog().error(\"Problem with Request: \" + pathInfo + \"; type \" + requType, e); } } else { getLog().error(\"Resource is null: \" + pathId + \"; path \" + pathInfo); } } else { getLog().error(\"PathInfo is null!!!\"); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) { if (monitor != null && monitor.isCanceled()) { return; } try { ftpClient = new FTPClient(); ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST))); ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT)); ftpClient.connect(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD))); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } if (from != null) { FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false); synchedSet.add(ftpHolder); } JobHandler.aquireFTPLock(); for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) { if (monitor != null && monitor.isCanceled()) { JobHandler.releaseFTPLock(); ftpClient.quit(); return; } Thread.yield(); FTPHolder element = (FTPHolder) iter.next(); ftpClient.setType(FTPTransferType.ASCII); ftpClient.put(element.from, element.to); if (element.renameTo != null) { try { ftpClient.delete(element.renameTo); } catch (Exception e) { } ftpClient.rename(element.to, element.renameTo); log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo); } } JobHandler.releaseFTPLock(); ftpClient.quit(); } catch (UnknownHostException e) { e.printStackTrace();",
        "ground_truth": "NO",
        "predict": " } catch (IOException e) { e.printStackTrace(); } } }. \n */"
    },
    {
        "ID": 1865,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void write(File file) throws Exception { if (isInMemory()) { FileOutputStream fout = null; try { fout = new FileOutputStream(file); fout.write(get()); } finally { if (fout != null) { fout.close(); } } } else { File outputFile = getStoreLocation(); if (outputFile != null) { size = outputFile.length(); if (!outputFile.renameTo(file)) { BufferedInputStream in = null; BufferedOutputStream out = null; try { in = new BufferedInputStream(new FileInputStream(outputFile)); out = new BufferedOutputStream(new FileOutputStream(file)); IOUtils.copy(in, out); } finally { if (in != null) { try { in.close(); } catch (IOException e) { } } if (out != null) { try { out.close(); } catch (IOException e) { } } } } } else { throw new FileUploadException(\"Cannot write uploaded file to disk!\"); } } }. \n Code2: public void convert(File src, File dest) throws IOException { InputStream in = new BufferedInputStream(new FileInputStream(src)); DcmParser p = pfact.newDcmParser(in); Dataset ds = fact.newDataset(); p.setDcmHandler(ds.getDcmHandler()); try { FileFormat format = p.detectFileFormat(); if (format != FileFormat.ACRNEMA_STREAM) { System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\"); return; } p.parseDcmFile(format, Tags.PixelData); if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) { System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\"); return; } boolean hasPixelData = p.getReadTag() == Tags.PixelData; boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12; int pxlen = p.getReadLength(); if (hasPixelData) { if (inflate) { ds.putUS(Tags.BitsAllocated, 16); pxlen = pxlen * 4 / 3; } if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) { System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\"); return; } } ds.putUI(Tags.StudyInstanceUID, uid(studyUID)); ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID)); ds.putUI(Tags.SOPInstanceUID, uid(instUID)); ds.putUI(Tags.SOPClassUID, classUID); if (!ds.contains(Tags.NumberOfSamples)) { ds.putUS(Tags.NumberOfSamples, 1); } if (!ds.contains(Tags.PhotometricInterpretation)) { ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\"); } if (fmi) { ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian)); } OutputStream out = new BufferedOutputStream(new FileOutputStream(dest)); try { } finally { ds.writeFile(out, encodeParam()); if (hasPixelData) { if (!skipGroupLen) { out.write(PXDATA_GROUPLEN); int grlen = pxlen + 8; out.write((byte) grlen); out.write((byte) (grlen >> 8)); out.write((byte) (grlen >> 16)); out.write((byte) (grlen >> 24)); } out.write(PXDATA_TAG); out.write((byte) pxlen); out.write((byte) (pxlen >> 8)); out.write((byte) (pxlen >> 16)); out.write((byte) (pxlen >> 24)); } if (inflate) { int b2, b3; for (; pxlen > 0; pxlen -= 3) { out.write(in.read()); b2 = in.read(); b3 = in.read(); out.write(b2 & 0x0f); out.write(b2 >> 4 | ((b3 & 0x0f) << 4)); out.write(b3 >> 4); } } else { for (; pxlen > 0; --pxlen) { out.write(in.read()); } } out.close(); } System.out.print('.'); } finally { in.close(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"unchecked\") private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException { String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag; if (cache.containsKey(key)) { return (ReaderFeed) cache.get(key); } List<Post> postList = new ArrayList<Post>(); URL url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\"GET\"); connection.setRequestProperty(\"Cookie\", \"SID=\" + sid); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\")); SAXBuilder builder = new SAXBuilder(false); Document doc = builder.build(reader); Element root = doc.getRootElement(); Namespace grNamespace = root.getNamespace(\"gr\"); Namespace namespace = root.getNamespace(); String newflag = root.getChildText(\"continuation\", grNamespace); String title = root.getChildText(\"title\", namespace); String subTitle = root.getChildText(\"subtitle\", namespace); List<Element> entryList = root.getChildren(\"entry\", namespace); DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\"); for (Element e : entryList) { Post post = new Post(); post.setTitle(e.getChildText(\"title\", namespace)); try { post.setDate(sdf.parse(",
        "ground_truth": "NO",
        "predict": "e.getChildText(\"date\", namespace))); } catch (ParseException e1) { } post.setSubTitle(e.getChildText(\"subtitle\", namespace)); post.setUrl(e.getChildText(\"url\", namespace)); post.setFlag(newflag); post.setContent(e.getChildText(\"content\", namespace)); post.setAuthor(e.getChildText(\"author\", namespace)); post.setTags(e.getChildText(\"tags\", namespace)); postList.add(post); } cache.put(key, postList.toArray(new Post[postList.size()])); return postList.toArray(new Post[postList.size()]); }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @SuppressWarnings(\"unchecked\") private ReaderFeed processEntrys(String urlStr, String currentFlag) throws Un"
    },
    {
        "ID": 1874,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void actionPerformed(ActionEvent event) { if (event.getSource() == btnChange) { Error.log(7002, \"Bot\ufffdo alterar pressionado por \" + login + \".\"); if (new String(passwordUser1.getPassword()).compareTo(\"\") == 0) { JOptionPane.showMessageDialog(null, \"Campo senha requerido\"); passwordUser1.setFocusable(true); return; } String password1 = new String(passwordUser1.getPassword()); String password2 = new String(passwordUser2.getPassword()); if (password1.compareTo(password2) != 0) { JOptionPane.showMessageDialog(null, \"Senhas n\ufffdo casam\"); passwordUser1.setText(\"\"); passwordUser2.setText(\"\"); passwordUser1.setFocusable(true); return; } char c = passwordUser1.getPassword()[0]; int j = 1; for (j = 1; j < password1.length(); j++) { if (passwordUser1.getPassword()[j] != c) { break; } c = passwordUser1.getPassword()[j]; } if (j == password1.length()) { JOptionPane.showMessageDialog(null, \"Senha fraca\"); return; } if (password1.length() < 6) { JOptionPane.showMessageDialog(null, \"Senha deve ter mais que 6 digitos\"); return; } if (numPasswordOneUseUser.getText().compareTo(\"\") == 0) { JOptionPane.showMessageDialog(null, \"Campo n\ufffdmero de senhas de uso \ufffdnico requerido\"); return; } if (!(Integer.parseInt(numPasswordOneUseUser.getText()) > 0 && Integer.parseInt(numPasswordOneUseUser.getText()) < 41)) { JOptionPane.showMessageDialog(null, \"N\ufffdmero de senhas de uso \ufffdnico entre 1 e 40\"); return; } String outputDigest = \"\"; try { MessageDigest messageDigest = MessageDigest.getInstance(\"SHA1\"); messageDigest.update(password1.getBytes()); BigInteger bigInt = new BigInteger(1, messageDigest.digest()); outputDigest = bigInt.toString(16); } catch (NoSuchAlgorithmException exception) { exception.printStackTrace(); } Statement stmt; String sql; sql = \"update Usuarios set password = '\" + outputDigest + \"' where login='\" + login + \"'\"; try { theConn = DatabaseConnection.getConnection(); stmt = theConn.createStatement(); stmt.executeUpdate(sql); stmt.close(); } catch (Exception exception) { exception.printStackTrace(); } finally { try { if (theConn != null) theConn.close(); } catch (Exception exception) { } } sql = \"delete from Senhas_De_Unica_Vez where login='\" + login + \"'\"; try { theConn = DatabaseConnection.getConnection(); stmt = theConn.createStatement(); stmt.executeUpdate(sql); stmt.close(); } catch (Exception exception) { exception.printStackTrace(); } finally { try { if (theConn != null) theConn.close(); } catch (Exception exception) { } } Random rn = new Random(); int r; Vector<Integer> passwordVector = new Vector<Integer>(); for (int i = 0; i < Integer.parseInt(numPasswordOneUseUser.getText()); i++) { r = rn.nextInt() % 10000; if (r < 0) r = r * (-1); passwordVector.add(r); } try { BufferedWriter out = new BufferedWriter(new FileWriter(login + \".txt\", false)); for (int i = 0; i < Integer.parseInt(numPasswordOneUseUser.getText()); i++) { out.append(\"\" + i + \" \" + passwordVector.get(i) + \"\\n\"); } out.close(); try { for (int i = 0; i < Integer.parseInt(numPasswordOneUseUser.getText()); i++) { MessageDigest messageDigest = MessageDigest.getInstance(\"SHA1\"); messageDigest.update(passwordVector.get(i).toString().getBytes()); BigInteger bigInt = new BigInteger(1, messageDigest.digest()); String digest = bigInt.toString(16); sql = \"insert into Senhas_De_Unica_Vez (login,key,password) values \" + \"('\" + login + \"',\" + i + \",'\" + digest + \"')\"; try { theConn = DatabaseConnection.getConnection(); stmt = theConn.createStatement(); stmt.executeUpdate(sql); stmt.close(); } catch (Exception exception) { exception.printStackTrace(); } finally { try { if (theConn != null) theConn.close(); } catch (Exception exception) { } } } } catch (NoSuchAlgorithmException exception) { exception.printStackTrace(); } } catch (IOException exception) { exception.printStackTrace(); } JOptionPane.showMessageDialog(null, \"Usu\ufffdrio \" + login + \" foi alterado com sucesso.\"); dispose(); } if (event.getSource() == btnCancel) { Error.log(7003, \"Bot\ufffdo voltar de alterar para o menu principal pressionado por \" + login + \".\"); dispose(); } }. \n Code2: private void getRandomGUID(boolean secure) { MessageDigest md5 = null; StringBuffer sbValueBeforeMD5 = new StringBuffer(); try { md5 = MessageDigest.getInstance(\"MD5\"); } catch (NoSuchAlgorithmException e) { System.out.println(\"Error: \" + e); } try { long time = System.currentTimeMillis(); long rand = 0; if (secure) { rand = mySecureRand.nextLong(); } else { rand = myRand.nextLong(); } sbValueBeforeMD5.append(s_id); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(time)); sbValueBeforeMD5.append(\":\"); sbValueBeforeMD5.append(Long.toString(rand)); valueBeforeMD5 = sbValueBeforeMD5.toString(); md5.update(valueBeforeMD5.getBytes()); byte[] array = md5.digest(); StringBuffer sb = new StringBuffer(); for (int j = 0; j < array.length; ++j) { int b = array[j] & 0xFF; if (b < 0x10) sb.append('0'); sb.append(Integer.toHexString(b)); } valueAfterMD5 = sb.toString(); } catch (Exception e) { System.out.println(\"Error:\" + e); }",
        "ground_truth": "YES",
        "predict": " }\n Code3: private void getRandomGUID() { getRandomGUID(false); }\n Code4: private void getRandomGUID(boolean secure) { getRandomGUID(secure); }\n Code5: private void getRandomGUID() { getRandomGUID(false); }\n Code6: private void getRandomGUID(boolean secure) { getRandomGUID(secure); }\n Code7: private void getRandomGUID() { getRandomGUID(false); }\n Code8: private void getRandomGUID(boolean secure) { getRandomGUID(secure); }\n Code9: private void getRandomGUID() { getRandomGUID(false); }\n Code10: private void getRandomGUID(boolean secure) { getRandomGUID(secure); }\n Code11: private void getRandomGUID() { getRandomGUID(false); }\n Code12: private void getRandomGUID(boolean secure) { getRandomG"
    },
    {
        "ID": 1877,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static synchronized String toMD5(String str) { Nulls.failIfNull(str, \"Cannot create an MD5 encryption form a NULL string\"); String hashword = null; try { MessageDigest md5 = MessageDigest.getInstance(MD5); md5.update(str.getBytes()); BigInteger hash = new BigInteger(1, md5.digest()); hashword = hash.toString(16); return Strings.padLeft(hashword, 32, \"0\"); } catch (NoSuchAlgorithmException ex) { ex.printStackTrace(); } return hashword; }. \n Code2: public void insertQuotation(final String sText, final Source aSource) throws ConfigHandlerError, com.sun.star.uno.Exception { final XTextDocument xTextDocument = (XTextDocument) this.docController.getXInterface(XTextDocument.class, this.docController.getXFrame().getController().getModel()); final XMultiServiceFactory xMultiServiceFactory = (XMultiServiceFactory) this.docController.getXInterface(XMultiServiceFactory.class, xTextDocument); final XText xText = xTextDocument.getText(); final XTextViewCursor xTextViewCursor = ((XTextViewCursorSupplier) this.docController.getXInterface(XTextViewCursorSupplier.class, this.docController.getXFrame().getController())).getViewCursor(); final XTextRange xTextRange = xTextViewCursor.getStart(); if (aSource.getSourceType() == SourceType.QUOTE || aSource.getSourceType() == SourceType.WEBQUOTE || aSource.getSourceType() == SourceType.WEBQUOTE) { final XPropertySet xQuoteProps = (XPropertySet) this.docController.getXInterface(XPropertySet.class, xTextViewCursor); if (this.docController.getTemplateController().isIndentation()) { xText.insertControlCharacter(xTextViewCursor, ControlCharacter.PARAGRAPH_BREAK, false); xQuoteProps.setPropertyValue(\"ParaStyleName\", new String(\"Quotations\")); } xQuoteProps.setPropertyValue(\"CharStyleName\", new String(\"Citation\")); final Object aBookmark = xMultiServiceFactory.createInstance(\"com.sun.star.text.Bookmark\"); this.sourceUtils.setNameToObject(aBookmark, this.docController.getLanguageController().__(\"Quote: \") + aSource.getShortinfo()); final XTextContent xTextContent = (XTextContent) this.docController.getXInterface(XTextContent.class, aBookmark); xText.insertTextContent(xTextRange, xTextContent, false); this.sourceUtils.insertBibliographyEntry(xMultiServiceFactory, xTextRange, aSource, sText); if (this.docController.getTemplateController().isIndentation()) { xText.insertControlCharacter(xTextViewCursor, ControlCharacter.PARAGRAPH_BREAK, false); xQuoteProps.setPropertyValue(\"ParaStyleName\", new String(this.docController.getLanguageController().__(\"Default\"))); } xQuoteProps.setPropertyValue(\"CharStyleName\", new String(this.docController.getLanguageController().__(\"Default\"))); } else if (aSource.getSourceType() == SourceType.IMAGE || aSource.getSourceType() == SourceType.TABLE) { xText.insertControlCharacter(xTextRange, ControlCharacter.PARAGRAPH_BREAK, false); final XTextFrame xFrame = this.sourceUtils.getTextFrame(aSource.getShortinfo(), xMultiServiceFactory); xText.insertTextContent(xTextRange, xFrame, false); final XText xFrameText = xFrame.getText(); final XTextCursor xFrameCursor = xFrameText.createTextCursor(); final Size aNewSize = new Size(); XPropertySet xBaseFrameProps = null; final Size aPageTextAreaSize = this.sourceUtils.getPageTextAreaSize(xTextDocument, xTextViewCursor); if (aSource.getSourceType() == SourceType.IMAGE) { try { this.sourceUtils.setNameToObject(xFrame, this.docController.getLanguageController().__(\"Caption illustration: \") + aSource.getShortinfo()); final XNameContainer xBitmapContainer = (XNameContainer) this.docController.getXInterface(XNameContainer.class, xMultiServiceFactory.createInstance(\"com.sun.star.drawing.BitmapTable\")); final XTextContent xImage = (XTextContent) this.docController.getXInterface(XTextContent.class, xMultiServiceFactory.createInstance(\"com.sun.star.text.TextGraphicObject\")); this.sourceUtils.setNameToObject(xImage, this.docController.getLanguageController().__(\"Illustration: \") + aSource.getShortinfo()); final String graphicURL = this.docController.getPathUtils().getFileURLFromSystemPath(((Image) aSource).getFile().getPath(), ((Image) aSource).getFile().getPath()); xBaseFrameProps = (XPropertySet) this.docController.getXInterface(XPropertySet.class, xImage); xBaseFrameProps.setPropertyValue(\"AnchorType\", com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH); xBaseFrameProps.setPropertyValue(\"GraphicURL\", graphicURL); final MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(graphicURL.getBytes(), 0, graphicURL.length()); final String internalName = new BigInteger(1, md.digest()).toString(16); xBitmapContainer.insertByName(internalName, graphicURL); final String internalURL = (String) (xBitmapContainer.getByName(internalName)); xBaseFrameProps.setPropertyValue(\"GraphicURL\", internalURL); float imageRatio = (float) this.sourceUtils.getImageSize(((Image) aSource).getFile()).Height / (float) this.sourceUtils.getImageSize(((Image) aSource).getFile()).Width; final Size aUsedAreaSize = new Size(this.sourceUtils.getImageSize(((Image) aSource).getFile()).Width * 26, this.sourceUtils.getImageSize(((Image) aSource).getFile()).Height * 26); if (aUsedAreaSize.Width >= aPageTextAreaSize.Width) { aNewSize.Width = aPageTextAreaSize.Width; aNewSize.Height = (int) (aPageTextAreaSize.Width * imageRatio); } else { aNewSize.Width = aUsedAreaSize.Width; aNewSize.Height = aUsedArea",
        "ground_truth": "NO",
        "predict": "Size.Height; } } catch (final NoSuchAlgorithmException ex) { ex.printStackTrace(); } catch (final com.sun.star.uno.Exception ex) { ex.printStackTrace(); } } else if (aSource.getSourceType() == SourceType.TABLE) { try { this.sourceUtils.setNameToObject(xFrame, this.docController.getLanguageController().__(\"Table: \") + aSource.getShortinfo()); xBaseFrameProps = (XPropertySet) this.docController.getXInterface(XPropertySet.class, xImage); xBaseFrameProps.setPropertyValue(\"AnchorType\", com.sun.star.text.TextContentAnchorType.AT_PARAGRAPH); xBaseFrameProps.setPropertyValue(\"GraphicURL\", \"\"); } catch (final com.sun.star.uno.Exception ex) { ex.printStackTrace(); } } xFrameCursor"
    },
    {
        "ID": 1880,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void alterarQuestaoDiscursiva(QuestaoDiscursiva q) throws SQLException { PreparedStatement stmt = null; String sql = \"UPDATE discursiva SET gabarito=? WHERE id_questao=?\"; try { stmt = conexao.prepareStatement(sql); stmt.setString(1, q.getGabarito()); stmt.setInt(2, q.getIdQuestao()); stmt.executeUpdate(); conexao.commit(); } catch (SQLException e) { conexao.rollback(); throw e; } }. \n Code2: public SukuData updatePerson(String usertext, SukuData req) { String insPers; String userid = Utils.toUsAscii(usertext); if (userid != null && userid.length() > 16) { userid = userid.substring(0, 16); } StringBuilder sb = new StringBuilder(); sb.append(\"insert into unit (pid,tag,privacy,groupid,sex,sourcetext,privatetext,userrefn\"); if (userid != null) { sb.append(\",createdby\"); } sb.append(\") values (?,?,?,?,?,?,?,? \"); if (userid != null) { sb.append(\",'\" + userid + \"'\"); } sb.append(\")\"); insPers = sb.toString(); String updPers; sb = new StringBuilder(); sb.append(\"update unit set privacy=?,groupid=?,sex=?,sourcetext=?,\" + \"privatetext=?,userrefn=?,Modified=now()\"); if (userid != null) { sb.append(\",modifiedby = '\" + userid + \"' where pid = ?\"); } else { sb.append(\" where pid = ?\"); } updPers = sb.toString(); sb = new StringBuilder(); String updSql; sb.append(\"update unitnotice set \"); sb.append(\"surety=?,Privacy=?,NoticeType=?,Description=?,\"); sb.append(\"DatePrefix=?,FromDate=?,ToDate=?,Place=?,\"); sb.append(\"Village=?,Farm=?,Croft=?,Address=?,\"); sb.append(\"PostalCode=?,PostOffice=?,State=?,Country=?,Email=?,\"); sb.append(\"NoteText=?,MediaFilename=?,MediaTitle=?,Prefix=?,\"); sb.append(\"Surname=?,Givenname=?,Patronym=?,PostFix=?,\"); sb.append(\"SourceText=?,PrivateText=?,RefNames=?,RefPlaces=?,Modified=now()\"); if (userid != null) { sb.append(\",modifiedby = '\" + userid + \"'\"); } sb.append(\" where pnid = ?\"); updSql = sb.toString(); sb = new StringBuilder(); String insSql; sb.append(\"insert into unitnotice (\"); sb.append(\"surety,Privacy,NoticeType,Description,\"); sb.append(\"DatePrefix,FromDate,ToDate,Place,\"); sb.append(\"Village,Farm,Croft,Address,\"); sb.append(\"PostalCode,PostOffice,State,Country,Email,\"); sb.append(\"NoteText,MediaFilename,MediaTitle,Prefix,\"); sb.append(\"Surname,Givenname,Patronym,PostFix,\"); sb.append(\"SourceText,PrivateText,RefNames,Refplaces,pnid,pid,tag\"); if (userid != null) { sb.append(\",createdby\"); } sb.append(\") values (\"); sb.append(\"?,?,?,?,?,?,?,?,\" + \"?,?,?,?,?,?,?,?,\" + \"?,?,?,?,?,?,?,?,\"); sb.append(\"?,?,?,?,?,?,?,?\"); if (userid != null) { sb.append(\",'\" + userid + \"'\"); } sb.append(\")\"); insSql = sb.toString(); sb = new StringBuilder(); String updLangSql; sb.append(\"update unitlanguage set \"); sb.append(\"NoticeType=?,Description=?,\" + \"Place=?,\"); sb.append(\"NoteText=?,MediaTitle=?,Modified=now() \"); if (userid != null) { sb.append(\",modifiedby = '\" + userid + \"'\"); } sb.append(\"where pnid=? and langCode = ?\"); updLangSql = sb.toString(); sb = new StringBuilder(); String insLangSql; sb.append(\"insert into unitlanguage (pnid,pid,tag,langcode,\"); sb.append(\"NoticeType,Description,Place,\"); sb.append(\"NoteText,MediaTitle\"); if (userid != null) { sb.append(\",createdby\"); } sb.append(\") values (?,?,?,?,?,?,?,?,?\"); if (userid != null) { sb.append(\",'\" + userid + \"'\"); } sb.append(\")\"); insLangSql = sb.toString(); String delOneLangSql = \"delete from unitlanguage where pnid = ? and langcode = ? \"; String updRowSql = \"update unitnotice set noticerow = ? where pnid = ? \"; String delSql = \"delete from unitnotice where pnid = ? \"; String delAllLangSql = \"delete from Unitlanguage where pnid = ? \"; SukuData res = new SukuData(); UnitNotice[] nn = req.persLong.getNotices(); if (nn != null) { String prevName = \"\"; String prevOccu = \"\"; for (int i = 0; i < nn.length; i++) { if (nn[i].getTag().equals(\"NAME\")) { String thisName = Utils.nv(nn[i].getGivenname()) + \"/\" + Utils.nv(nn[i].getPatronym()) + \"/\" + Utils.nv(nn[i].getPrefix()) + \"/\" + Utils.nv(nn[i].getSurname()) + \"/\" + Utils.nv(nn[i].getPostfix()); if (thisName.equals(prevName) && !prevName.equals(\"\")) { if (nn[i].isToBeDeleted() == false) { String e = Resurses.getString(\"IDENTICAL_NAMES_ERROR\") + \" [\" + req.persLong.getPid() + \"] idx [\" + i + \"] = \" + thisName; logger.warning(e); if (req.persLong.getPid() > 0) { res",
        "ground_truth": "NO",
        "predict": ".addError(e); } } } else { prevName = thisName; prevOccu = nn[i].getOccurrence(); } } } } }\n return res; }\n}\n"
    },
    {
        "ID": 1889,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static Vector webService(String siteUrl, String login, String password, String table, String station, String element, String dayFrom, String dayTo, String filePath) throws Exception { Service service = new Service(); Call call = (Call) service.createCall(); if (login != null) { call.setUsername(login); if (password != null) { call.setPassword(password); } System.err.println(\"Info: authentication user=\" + login + \" passwd=\" + password + \" at \" + siteUrl); } call.setTargetEndpointAddress(new URL(siteUrl)); call.setOperationName(\"syncData\"); Vector exportList = (Vector) call.invoke(new Object[] { table, station, element, dayFrom, dayTo }); if (exportList != null) { for (int k = 0; k < exportList.size(); k++) { HashMap exportDescr = (HashMap) exportList.get(k); String url = (String) exportDescr.get(\"fileName\"); log.debug(\"result URL is \" + url); String fileName = null; URL dataurl = new URL(url); String filePart = dataurl.getFile(); if (filePart == null) { throw new Exception(\"Error: file part in the data URL is null\"); } else { fileName = filePart.substring(filePart.lastIndexOf(\"/\") < 0 ? 0 : filePart.lastIndexOf(\"/\") + 1); if (filePath != null) { fileName = filePath + fileName; } log.debug(\"local file name is \" + fileName); } FileOutputStream fos = new FileOutputStream(fileName); if (fos == null) { throw new Exception(\"Error: file output stream is null\"); } InputStream strm = dataurl.openStream(); if (strm == null) { throw new Exception(\"Error: data input stream is null\"); } else { int c; while ((c = strm.read()) != -1) { fos.write(c); } } strm.close(); fos.close(); File file = new File(fileName); exportDescr.put(\"fileName\", file.getCanonicalPath()); } } return exportList; }. \n Code2: private void displayDiffResults() throws IOException { File outFile = File.createTempFile(\"diff\", \".htm\"); outFile.deleteOnExit(); FileOutputStream outStream = new FileOutputStream(outFile); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream)); out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\"); if (addedTable.length() > 0) { out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\"); out.write(addedTable.toString()); out.write(\"</table><br><br>\"); } if (modifiedTable.length() > 0) { out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\"); out.write(modifiedTable.toString()); out.write(\"</table><br><br>\"); } if (deletedTable.length() > 0) { out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\"); out.write(deletedTable.toString()); out.write(\"</table><br><br>\"); } out.write(\"<table name=METRICS BORDER>\\n\"); if (modifiedTable.length() > 0 || deletedTable.length() > 0) { out.write(\"<tr><td>Base:&nbsp;</td><td>\"); out.write(Long.toString(base)); out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\"); out.write(Long.toString(deleted)); out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\"); out.write(Long.toString(modified)); out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\"); out.write(Long.toString(added)); out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\"); out.write(Long.toString(added + modified)); out.write(\"</td></tr>\\n\"); } out.write(\"<tr><td>Total:&nbsp;</td><td>\"); out.write(Long.toString(total)); out.write(\"</td></tr>\\n</table></div>\"); redlinesOut.close(); out.flush(); InputStream redlines = new FileInputStream(redlinesTempFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead); outStream.write(\"</BODY></HTML>\".getBytes()); outStream.close(); Browser.launch(outFile.toURL().toString()); }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void handleHandshake(Packet2Handshake par1Packet2Handshake) { boolean flag = true; String s = par1Packet2Handshake.username; if (s == null || s.trim().length() == 0) { flag = false; } else if (!s.equals(\"-\")) { try { Long.parseLong(s, 16); } catch (NumberFormatException numberformatexception) { flag = false; } } if (!flag) { netManager.networkShutdown(\"disconnect.genericReason\", new Object[] { \"The server responded with an invalid server key\" }); } else if (par1Packet2Handshake.username.equals(\"-\")) { addToSendQueue(new Packet1Login(mc.session.username, 29)); } else { try { URL url = new URL((new StringBuilder()).append(\"http://session.minecraft.net/game/joinserver.jsp?user=\").append(mc.session.username).append(\"&sessionId=\").append(mc.session.sessionId).append(\"&serverId=\").append(par1Packet2Handshake.username).toString()); BufferedReader bufferedreader = new BufferedReader(new",
        "ground_truth": "NO",
        "predict": " InputStreamReader(url.openStream())); String s1 = bufferedreader.readLine(); bufferedreader.close(); } catch (Exception exception) { } } }. \n Code1: public static void main(String[] args) throws Exception { new Thread(new Runnable() { public void run() { try { new Minecraft(new NetLoginHandler(\"-\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \""
    },
    {
        "ID": 1891,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void GetFile(ClientConnector cc, Map<String, String> attributes) throws Exception { log.debug(\"Starting FTP FilePull\"); String sourceNode = attributes.get(\"src_name\"); String sourceUser = attributes.get(\"src_user\"); String sourcePassword = attributes.get(\"src_password\"); String sourceFile = attributes.get(\"src_file\"); String messageID = attributes.get(\"messageID\"); String sourceMD5 = attributes.get(\"src_md5\"); String sourceFileType = attributes.get(\"src_file_type\"); Integer sourcePort = 21; String sourcePortString = attributes.get(\"src_port\"); if ((sourcePortString != null) && (sourcePortString.equals(\"\"))) { try { sourcePort = Integer.parseInt(sourcePortString); } catch (Exception e) { sourcePort = 21; log.debug(\"Destination Port \\\"\" + sourcePortString + \"\\\" was not valid. Using Default (21)\"); } } log.info(\"Starting FTP pull of \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode); if ((sourceUser == null) || (sourceUser.equals(\"\"))) { List userDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, \"ftpUser\"); if (userDBVal.size() < 1) { sourceUser = DEFAULTUSER; } else { sourceUser = (String) userDBVal.get(0); } } if ((sourcePassword == null) || (sourcePassword.equals(\"\"))) { List passwordDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, \"ftpPassword\"); if (passwordDBVal.size() < 1) { sourcePassword = DEFAULTPASSWORD; } else { sourcePassword = (String) passwordDBVal.get(0); } } String stageFile = null; int stageFileID; try { stageFileID = axt.db.GeneralDAO.getStageFile(messageID); stageFile = STAGINGDIR + \"/\" + stageFileID; } catch (Exception e) { throw new Exception(\"Failed to assign a staging file \\\"\" + stageFile + \"\\\" - ERROR: \" + e); } FileOutputStream fos; try { fos = new FileOutputStream(stageFile); } catch (FileNotFoundException fileNFException) { throw new Exception(\"Failed to assign the staging file \\\"\" + stageFile + \"\\\" - ERROR: \" + fileNFException); } FTPClient ftp = new FTPClient(); try { log.debug(\"Connecting\"); ftp.connect(sourceNode, sourcePort); log.debug(\"Checking Status\"); int reply = ftp.getReplyCode(); if (!FTPReply.isPositiveCompletion(reply)) { ftp.disconnect(); throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ftp.getReplyString()); } log.debug(\"Logging In\"); if (!ftp.login(sourceUser, sourcePassword)) { ftp.disconnect(); throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: Login Failed\"); } } catch (SocketException socketException) { throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + socketException); } catch (IOException ioe) { throw new Exception(\"Failed to connect to \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ioe); } log.debug(\"Performing Site Commands\"); Iterator siteIterator = GeneralDAO.getNodeValue(sourceNode, \"ftpSite\").iterator(); while (siteIterator.hasNext()) { String siteCommand = null; try { siteCommand = (String) siteIterator.next(); ftp.site(siteCommand); } catch (IOException e) { throw new Exception(\"FTP \\\"site\\\" command \\\"\" + siteCommand + \"\\\" failed - ERROR: \" + e); } } if (sourceFileType != null) { if (sourceFileType.equals(\"A\")) { log.debug(\"Set File Type to ASCII\"); ftp.setFileType(FTP.ASCII_FILE_TYPE); } else if (sourceFileType.equals(\"B\")) { log.debug(\"Set File Type to BINARY\"); ftp.setFileType(FTP.BINARY_FILE_TYPE); } else if (sourceFileType.equals(\"E\")) { log.debug(\"Set File Type to EBCDIC\"); ftp.setFileType(FTP.EBCDIC_FILE_TYPE); } } log.debug(\"Opening the File Stream\"); InputStream in = null; try { in = ftp.retrieveFileStream(sourceFile); if (in == null) { throw new Exception(\"Failed get the file \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode + \"\\\" - ERROR: \" + ftp.getReplyString()); } } catch (IOException ioe2) { ftp.disconnect(); log.error(\"Failed get the file \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode + \"\\\" - ERROR: \" + ioe2); throw new Exception(\"Failed to retrieve file from \\\"\" + sourceNode + \"\\\" as user \\\"\" + sourceUser + \"\\\" - ERROR: \" + ioe2); } log.debug(\"Starting the read\"); DESCrypt encrypter = null; try { encrypter = new DESCrypt(); } catch (Exception cryptInitError) { log.error(\"Failed to initialize the encrypt process - ERROR: \" + cryptInitError); } String receivedMD5 = null; try { Object[] returnValues = encrypter.encrypt(in, fos); receivedMD5 = (String) returnValues[0]; GeneralDAO.setStageFileSize(stageFileID, (Long) returnValues[1]); } catch (Exception cryptError) { log.error(\"Encrypt Error: \" + cryptError); throw new Exception(\"Encrypt Error: \" + cryptError); } log.debug(\"Logging Out\"); try { ftp.logout(); fos.close(); } catch (Exception ioe3) { log.error(\"Failed close connection to \\\"\" + sourceNode + \"\\\" - ERROR: \" + ioe3); } log.debug(\"Setting the File Digest\"); GeneralDAO.setStageFileDigest(stageFileID, receivedMD5); if ((sourceMD5 != null) && (!sourceMD5.equals(\"\"))) { log.debug(\"File DIGEST compare - Source: \" + sourceMD5.toLowerCase() + \" | Received: \" + receivedMD5); if (!receivedMD5.equals(sourceMD5.toLowerCase())) { throw new Exception(\"MD5 validation on file failed.\"); } } return; }. \n Code2: public FTPClient sample2a(String server, int port, String username, String password",
        "ground_truth": "YES",
        "predict": ", String file, String messageID) throws Exception { log.debug(\"Starting FTP FilePull\"); String sourceNode = server; String sourceUser = username; String sourcePassword = password; String sourceFile = file; String messageID2 = messageID; String sourceMD5 = null; String sourceFileType = null; Integer sourcePort = 21; String sourcePortString = null; if ((sourcePortString != null) && (sourcePortString.equals(\"\"))) { try { sourcePort = Integer.parseInt(sourcePortString); } catch (Exception e) { sourcePort = 21; log.debug(\"Destination Port \\\"\" + sourcePortString + \"\\\" was not valid. Using Default (21)\"); } } log.info(\"Starting FTP pull of \\\"\" + sourceFile + \"\\\" from \\\"\" + sourceNode); if ((sourceUser == null) || (sourceUser.equals(\"\"))) { List userDBVal = axt.db.GeneralDAO.getNodeValue(sourceNode, \""
    },
    {
        "ID": 1901,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public static int fileUpload(long lngFileSize, InputStream inputStream, String strFilePath, String strFileName) throws IOException { String SEPARATOR = System.getProperty(\"file.separator\"); if (lngFileSize > (10 * 1024 * 1024)) { return -1; } InputStream is = null; FileOutputStream fos = null; try { File dir = new File(strFilePath); if (!dir.exists()) dir.mkdirs(); is = inputStream; fos = new FileOutputStream(new File(strFilePath + SEPARATOR + strFileName)); IOUtils.copy(is, fos); } catch (Exception ex) { return -2; } finally { try { fos.close(); is.close(); } catch (Exception ex2) { } } return 0; }. \n Code2: public void _saveWebAsset(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form, User user, String subcmd) throws WebAssetException, Exception { long maxsize = 50; long maxwidth = 3000; long maxheight = 3000; long minheight = 10; ActionRequestImpl reqImpl = (ActionRequestImpl) req; HttpServletRequest httpReq = reqImpl.getHttpServletRequest(); try { UploadPortletRequest uploadReq = PortalUtil.getUploadPortletRequest(req); String parent = ParamUtil.getString(req, \"parent\"); int countFiles = ParamUtil.getInteger(req, \"countFiles\"); int fileCounter = 0; Folder folder = (Folder) InodeFactory.getInode(parent, Folder.class); _checkUserPermissions(folder, user, PERMISSION_WRITE); String userId = user.getUserId(); String customMessage = \"Some file does not match the filters specified by the folder: \"; boolean filterError = false; for (int k = 0; k < countFiles; k++) { File file = new File(); String title = ParamUtil.getString(req, \"title\" + k); String friendlyName = ParamUtil.getString(req, \"friendlyName\" + k); Date publishDate = new Date(); String fileName = ParamUtil.getString(req, \"fileName\" + k); fileName = checkMACFileName(fileName); if (!FolderFactory.matchFilter(folder, fileName)) { customMessage += fileName + \", \"; filterError = true; continue; } if (fileName.length() > 0) { String mimeType = FileFactory.getMimeType(fileName); String URI = folder.getPath() + fileName; String suffix = UtilMethods.getFileExtension(fileName); file.setTitle(title); file.setFileName(fileName); file.setFriendlyName(friendlyName); file.setPublishDate(publishDate); file.setModUser(userId); InodeFactory.saveInode(file); String filePath = FileFactory.getRealAssetsRootPath(); new java.io.File(filePath).mkdir(); java.io.File uploadedFile = uploadReq.getFile(\"uploadedFile\" + k); Logger.debug(this, \"bytes\" + uploadedFile.length()); file.setSize((int) uploadedFile.length() - 2); file.setMimeType(mimeType); Host host = HostFactory.getCurrentHost(httpReq); Identifier ident = IdentifierFactory.getIdentifierByURI(URI, host); String message = \"\"; if ((FileFactory.existsFileName(folder, fileName))) { InodeFactory.deleteInode(file); message = \"The uploaded file \" + fileName + \" already exists in this folder\"; SessionMessages.add(req, \"custommessage\", message); } else { String fileInodePath = String.valueOf(file.getInode()); if (fileInodePath.length() == 1) { fileInodePath = fileInodePath + \"0\"; } fileInodePath = fileInodePath.substring(0, 1) + java.io.File.separator + fileInodePath.substring(1, 2); new java.io.File(filePath + java.io.File.separator + fileInodePath.substring(0, 1)).mkdir(); new java.io.File(filePath + java.io.File.separator + fileInodePath).mkdir(); java.io.File f = new java.io.File(filePath + java.io.File.separator + fileInodePath + java.io.File.separator + file.getInode() + \".\" + suffix); java.io.FileOutputStream fout = new java.io.FileOutputStream(f); FileChannel outputChannel = fout.getChannel(); FileChannel inputChannel = new java.io.FileInputStream(uploadedFile).getChannel(); outputChannel.transferFrom(inputChannel, 0, inputChannel.size()); outputChannel.force(false); outputChannel.close(); inputChannel.close(); Logger.debug(this, \"SaveFileAction New File in =\" + filePath + java.io.File.separator + fileInodePath + java.io.File.separator + file.getInode() + \".\" + suffix); if (suffix.equals(\"jpg\") || suffix.equals(\"gif\")) { com.dotmarketing.util.Thumbnail.resizeImage(filePath + java.io.File.separator + fileInodePath + java.io.File.separator, String.valueOf(file.getInode()), suffix); int height = javax.imageio.ImageIO.read(f).getHeight(); file.setHeight(height); Logger.debug(this, \"File height=\" + height); int width = javax.imageio.ImageIO.read(f).getWidth(); file.setWidth(width); Logger.debug(this, \"File width=\" + width); long size = (f.length() / 1024); WebAssetFactory.createAsset(file, userId, folder); } else { WebAssetFactory.createAsset(file, userId, folder); } WorkingCache.addToWorkingAssetToCache(file); _setFilePermissions(folder, file, user); fileCounter += 1; if ((subcmd != null) && subcmd.equals(com.dotmarketing.util.Constants.PUBLISH)) { try { PublishFactory.publishAsset(file, httpReq); if (fileCounter > 1) { SessionMessages.add(req, \"message\", \"message.file_asset.save\"); } else { SessionMessages.add(req, \"message\", \"message.fileupload.save\"); } } catch (WebAssetException wax) { Logger.error(this, wax.getMessage(), wax); SessionMessages.add(req, \"error\", \"message.webasset.published.failed\"); } } } } } if (filterError)",
        "ground_truth": "NO",
        "predict": " { SessionMessages.add(req, \"error\", customMessage); } } catch (Exception ex) { Logger.error(this, ex.toString()); } }\n\n}\n"
    },
    {
        "ID": 1920,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private FeedIF retrieveFeed(String uri) throws FeedManagerException { try { URL urlToRetrieve = new URL(uri); URLConnection conn = null; try { conn = urlToRetrieve.openConnection(); if (conn instanceof HttpURLConnection) { HttpURLConnection httpConn = (HttpURLConnection) conn; httpConn.setInstanceFollowRedirects(true); HttpHeaderUtils.setUserAgent(httpConn, \"Informa Java API\"); logger.debug(\"retr feed at url \" + uri + \": ETag\" + HttpHeaderUtils.getETagValue(httpConn) + \" if-modified :\" + HttpHeaderUtils.getLastModified(httpConn)); this.httpHeaders.setETag(HttpHeaderUtils.getETagValue(httpConn)); this.httpHeaders.setIfModifiedSince(HttpHeaderUtils.getLastModified(httpConn)); } } catch (java.lang.ClassCastException e) { conn = null; logger.warn(\"problem cast to HttpURLConnection \" + uri, e); throw new FeedManagerException(e); } catch (NullPointerException e) { logger.error(\"problem NPE \" + uri + \" conn=\" + conn, e); conn = null; throw new FeedManagerException(e); } ChannelIF channel = null; channel = FeedParser.parse(getChannelBuilder(), conn.getInputStream()); this.timeToExpire = getTimeToExpire(channel); this.feed = new Feed(channel); Date currDate = new Date(); this.feed.setLastUpdated(currDate); this.feed.setDateFound(currDate); this.feed.setLocation(urlToRetrieve); logger.info(\"feed retrieved \" + uri); } catch (IOException e) { logger.error(\"IOException \" + feedUri + \" e=\" + e); e.printStackTrace(); throw new FeedManagerException(e); } catch (ParseException e) { e.printStackTrace(); throw new FeedManagerException(e); } return this.feed; }. \n Code2: private static void createNonCompoundData(String dir, String type) { try { Set s = new HashSet(); File nouns = new File(dir + \"index.\" + type); FileInputStream fis = new FileInputStream(nouns); InputStreamReader reader = new InputStreamReader(fis); StringBuffer sb = new StringBuffer(); int chr = reader.read(); while (chr >= 0) { if (chr == '\\n' || chr == '\\r') { String line = sb.toString(); if (line.length() > 0) { if (line.charAt(0) != ' ') { String[] spaceSplit = PerlHelp.split(line); if (spaceSplit[0].indexOf('_') < 0) { s.add(spaceSplit[0]); } } } sb.setLength(0); } else { sb.append((char) chr); } chr = reader.read(); } System.out.println(type + \" size=\" + s.size()); File output = new File(dir + \"nonCompound.\" + type + \"s.gz\"); FileOutputStream fos = new FileOutputStream(output); GZIPOutputStream gzos = new GZIPOutputStream(new BufferedOutputStream(fos)); PrintWriter writer = new PrintWriter(gzos); writer.println(\"# This file was extracted from WordNet data, the following copyright notice\"); writer.println(\"# from WordNet is attached.\"); writer.println(\"#\"); writer.println(\"# This software and database is being provided to you, the LICENSEE, by \"); writer.println(\"# Princeton University under the following license. By obtaining, using \"); writer.println(\"# and/or copying this software and database, you agree that you have \"); writer.println(\"# read, understood, and will comply with these terms and conditions.: \"); writer.println(\"# \"); writer.println(\"# Permission to use, copy, modify and distribute this software and \"); writer.println(\"# database and its documentation for any purpose and without fee or \"); writer.println(\"# royalty is hereby granted, provided that you agree to comply with \"); writer.println(\"# the following copyright notice and statements, including the disclaimer, \"); writer.println(\"# and that the same appear on ALL copies of the software, database and \"); writer.println(\"# documentation, including modifications that you make for internal \"); writer.println(\"# use or for distribution. \"); writer.println(\"# \"); writer.println(\"# WordNet 1.7 Copyright 2001 by Princeton University. All rights reserved. \"); writer.println(\"# \"); writer.println(\"# THIS SOFTWARE AND DATABASE IS PROVIDED \\\"AS IS\\\" AND PRINCETON \"); writer.println(\"# UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR \"); writer.println(\"# IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PRINCETON \"); writer.println(\"# UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCHANT- \"); writer.println(\"# ABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE \"); writer.println(\"# OF THE LICENSED SOFTWARE, DATABASE OR DOCUMENTATION WILL NOT \"); writer.println(\"# INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR \"); writer.println(\"# OTHER RIGHTS. \"); writer.println(\"# \"); writer.println(\"# The name of Princeton University or Princeton may not be used in\"); writer.println(\"# advertising or publicity pertaining to distribution of the software\"); writer.println(\"# and/or database. Title to copyright in this software, database and\"); writer.println(\"# any associated documentation shall at all times remain with\"); writer.println(\"# Princeton University and LICENSEE agrees to preserve same. \"); for (Iterator i = s.iterator(); i.hasNext(); ) { String mwe = (String) i.next(); writer.println(mwe); } writer.close(); } catch (Exception e) { e.printStackTrace(); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private JButton getButtonSonido() { if (buttonSonido == null) { buttonSonido = new JButton(); buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\")); buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\"))); buttonSonido.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt",
        "ground_truth": "NO",
        "predict": ".event.ActionEvent e) { JOptionPane.showMessageDialog(null, Messages.getString(\"gui.AdministracionResorces.16\")); } }); } return buttonSonido; }. \n Response: NO. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private JButton getButtonSonido() { if (buttonSonido == null) { buttonSonido = new JButton(); buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.17\")); buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\"))); buttonSonido.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent e) { JOption"
    },
    {
        "ID": 1923,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected URLConnection openURLConnection() throws IOException { final String locator = getMediaLocator(); if (locator == null) { return null; } final URL url; try { url = new URL(locator); } catch (MalformedURLException ex) { throw new IllegalArgumentException(ex); } final URLConnection connection = url.openConnection(); connection.connect(); return connection; }. \n Code2: protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { Session session = HibernateUtil.getInstance().getSession(); response.setBufferSize(65536); ServletOutputStream outStream = response.getOutputStream(); File file = null; FileData fileData = null; try { String fileParameter = request.getParameter(\"file\"); String disposition = request.getParameter(\"disposition\"); if (fileParameter == null || fileParameter.equals(\"\")) { String pi = request.getPathInfo(); int lastSlashIndex = pi.lastIndexOf(\"/\") + 1; fileParameter = pi.substring(lastSlashIndex, pi.indexOf(\"_\", pi.lastIndexOf(\"/\"))); } if (fileParameter == null || fileParameter.equals(\"\")) { response.sendError(HttpServletResponse.SC_BAD_REQUEST); response.setStatus(HttpServletResponse.SC_BAD_REQUEST); response.flushBuffer(); Logger.log(\"file parameter not specified\"); return; } if (disposition == null || disposition.equals(\"\")) { String pi = request.getPathInfo(); String filename = pi.substring(pi.lastIndexOf(\"/\") + 1); int underscoreIndex = filename.indexOf(\"_\") + 1; disposition = filename.substring(underscoreIndex, filename.indexOf(\"_\", underscoreIndex)); } file = (File) session.load(File.class, new Long(fileParameter)); Logger.log(\"Content requested=\" + file.getName() + \":\" + fileParameter + \" Referral: \" + request.getParameter(\"referer\")); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); long fileDate = file.getLastModifiedDate() - (file.getLastModifiedDate() % 1000); if (fileDate <= ifModifiedSince) { response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); if (\"attachment\".equals(disposition)) { response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\"); } else { response.setHeader(\"Content-Disposition\", \"inline; filename=\\\"\" + file.getName() + \"\\\"\"); } response.setContentType(file.getContentType()); response.setHeader(\"Content-Description\", file.getName()); response.setDateHeader(\"Last-Modified\", file.getLastModifiedDate()); response.setDateHeader(\"Expires\", System.currentTimeMillis() + 31536000000L); response.setContentLength((int) file.getSize()); response.flushBuffer(); Logger.log(\"Conditional GET: \" + file.getName()); return; } User authUser = baseService.getAuthenticatedUser(session, request, response); if (!SecurityHelper.doesUserHavePermission(session, authUser, file, Permission.PERM.READ)) { response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden\"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.flushBuffer(); Logger.log(\"Forbidden content requested: \" + fileParameter); return; } String contentType = file.getContentType(); response.setContentType(contentType); if (\"attachment\".equals(disposition)) { response.setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + file.getName() + \"\\\"\"); } else { response.setHeader(\"Content-Disposition\", \"inline; filename=\\\"\" + file.getName() + \"\\\"\"); } String name = file.getName(); response.setHeader(\"Content-Description\", name); response.setDateHeader(\"Last-Modified\", file.getLastModifiedDate()); response.setDateHeader(\"Expires\", System.currentTimeMillis() + 31536000000L); response.setContentLength((int) file.getSize()); java.io.File possibleDataFile = new java.io.File(BaseSystem.getTempDir() + file.getNameOnDisk()); if (possibleDataFile.exists()) { Logger.log(\"File exists in \" + BaseSystem.getTempDir() + \" pulling \" + possibleDataFile.getName()); FileInputStream fileInputStream = new FileInputStream(possibleDataFile); try { IOUtils.copy(fileInputStream, outStream); } finally { try { fileInputStream.close(); } catch (Throwable t) { } } } else { List<FileData> fileDataList = HibernateUtil.getInstance().executeQuery(session, \"from \" + FileData.class.getSimpleName() + \" where permissibleObject.id = \" + file.getId()); if (fileDataList.size() == 0) { response.sendError(HttpServletResponse.SC_NOT_FOUND); response.setStatus(HttpServletResponse.SC_NOT_FOUND); Logger.log(\"Requested content not found: \" + fileParameter); response.flushBuffer(); return; } fileData = (FileData) fileDataList.get(0); FileOutputStream fileOutputStream = null; try { java.io.File tmpDir = new java.io.File(BaseSystem.getTempDir()); tmpDir.mkdirs(); fileOutputStream = new FileOutputStream(possibleDataFile); IOUtils.write(fileData.getData(), fileOutputStream); } catch (Throwable t) { Logger.log(t); } finally { try { fileOutputStream.close(); } catch (Throwable t) { } } IOUtils.write(fileData.getData(), outStream); } } catch (Throwable t) { Logger.log(t); try { response.sendError(HttpServletResponse.SC_NOT_FOUND); response.setStatus(HttpServletResponse.SC_NOT_FOUND); response.flushBuffer(); } catch (Throwable tt) { } try { response.reset(); response.resetBuffer(); } catch (Throwable tt) { } } finally { file = null; fileData = null; try { outStream.flush(); } catch (Throwable t) { } try { outStream.close(); } catch (Throwable t) { } try { session.close(); } catch (Throwable t) { } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getSHA256Che",
        "ground_truth": "NO",
        "predict": "cksum(String fileName) { return null; }. \n Code2: public String getSHA256Checksum(String fileName) { return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getSHA256Checksum(String fileName) { return null; }. \n Code2: public String getSHA256Checksum(String fileName) { return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public String getSHA256Checksum(String fileName) { return null; }. \n Code2: public String getSHA256Checksum(String fileName) { return null; }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and"
    },
    {
        "ID": 1925,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public File addFile(File file, String suffix) throws IOException { if (file.exists() && file.isFile()) { File nf = File.createTempFile(prefix, \".\" + suffix, workdir); nf.delete(); if (!file.renameTo(nf)) { IOUtils.copy(file, nf); } synchronized (fileList) { fileList.add(nf); } if (log.isDebugEnabled()) { log.debug(\"Add file [\" + file.getPath() + \"] -> [\" + nf.getPath() + \"]\"); } return nf; } return file; }. \n Code2: static synchronized Person lookup(PhoneNumber number, String siteName) { Vector<Person> foundPersons = new Vector<Person>(5); if (number.isFreeCall()) { Person p = new Person(\"\", \"FreeCall\"); p.addNumber(number); foundPersons.add(p); } else if (number.isSIPNumber() || number.isQuickDial()) { Person p = new Person(); p.addNumber(number); foundPersons.add(p); } else if (ReverseLookup.rlsMap.containsKey(number.getCountryCode())) { nummer = number.getAreaNumber(); rls_list = ReverseLookup.rlsMap.get(number.getCountryCode()); Debug.info(\"Begin reverselookup for: \" + nummer); if (nummer.startsWith(number.getCountryCode())) nummer = nummer.substring(number.getCountryCode().length()); city = \"\"; for (int i = 0; i < rls_list.size(); i++) { yield(); rls = rls_list.get(i); if (!siteName.equals(\"\") && !siteName.equals(rls.getName())) { Debug.warning(\"This lookup should be done using a specific site, skipping\"); continue; } prefix = rls.getPrefix(); ac_length = rls.getAreaCodeLength(); if (!nummer.startsWith(prefix)) nummer = prefix + nummer; urlstr = rls.getURL(); if (urlstr.contains(\"$AREACODE\")) { urlstr = urlstr.replaceAll(\"\\\\$AREACODE\", nummer.substring(prefix.length(), ac_length + prefix.length())); urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer.substring(prefix.length() + ac_length)); } else if (urlstr.contains(\"$PFXAREACODE\")) { urlstr = urlstr.replaceAll(\"\\\\$PFXAREACODE\", nummer.substring(0, prefix.length() + ac_length)); urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer.substring(prefix.length() + ac_length)); } else urlstr = urlstr.replaceAll(\"\\\\$NUMBER\", nummer); Debug.info(\"Reverse lookup using: \" + urlstr); url = null; data = new String[dataLength]; try { url = new URL(urlstr); if (url != null) { try { con = url.openConnection(); con.setConnectTimeout(5000); con.setReadTimeout(15000); con.addRequestProperty(\"User-Agent\", userAgent); con.connect(); header = \"\"; charSet = \"\"; for (int j = 0; ; j++) { String headerName = con.getHeaderFieldKey(j); String headerValue = con.getHeaderField(j); if (headerName == null && headerValue == null) { break; } if (\"content-type\".equalsIgnoreCase(headerName)) { String[] split = headerValue.split(\";\", 2); for (int k = 0; k < split.length; k++) { if (split[k].trim().toLowerCase().startsWith(\"charset=\")) { String[] charsetSplit = split[k].split(\"=\"); charSet = charsetSplit[1].trim(); } } } header += headerName + \": \" + headerValue + \" | \"; } Debug.debug(\"Header of \" + rls.getName() + \":\" + header); Debug.debug(\"CHARSET : \" + charSet); BufferedReader d; if (charSet.equals(\"\")) { d = new BufferedReader(new InputStreamReader(con.getInputStream(), \"ISO-8859-1\")); } else { d = new BufferedReader(new InputStreamReader(con.getInputStream(), charSet)); } int lines = 0; while (null != ((str = d.readLine()))) { data[lines] = str; yield(); if (lines >= dataLength) { System.err.println(\"Result > \" + dataLength + \" Lines\"); break; } lines++; } d.close(); Debug.info(\"Begin processing response from \" + rls.getName()); for (int j = 0; j < rls.size(); j++) { yield(); firstname = \"\"; lastname = \"\"; company = \"\"; street = \"\"; zipcode = \"\"; city = \"\"; Person p = null; patterns = rls.getEntry(j); Pattern namePattern = null; Pattern streetPattern = null; Pattern cityPattern = null; Pattern zipcodePattern = null; Pattern firstnamePattern = null; Pattern lastnamePattern = null; Matcher nameMatcher = null; Matcher streetMatcher = null; Matcher cityMatcher = null; Matcher zipcodeMatcher = null; Matcher firstnameMatcher = null; Matcher lastnameMatcher = null; if (!patterns[ReverseLookupSite.NAME].equals(\"\") && (patterns[ReverseLookupSite.FIRSTNAME].equals(\"\") && patterns[ReverseLookupSite.LASTNAME].equals(\"\"))) { namePattern = Pattern.compile(patterns[ReverseLookupSite.NAME]); } if (!patterns[ReverseLookupSite.STREET].equals(\"\")) { streetPattern = Pattern.compile(patterns[ReverseLookupSite.STREET]); } if (!patterns[ReverseLookupSite.CITY].equals(\"\")) { cityPattern = Pattern.compile(patterns[ReverseLookupSite.CITY]); } if (!patterns[ReverseLookupSite.ZIPCODE].equals(\"\")) { zipcodePattern = Pattern.compile(patterns[ReverseLookupSite.ZIPCODE]); } if (!patterns[ReverseLookupSite.FIRSTNAME].equals(\"\")) { firstnamePattern = Pattern.compile(patterns[ReverseLookupSite.FIRSTNAME]); } if (!patterns[ReverseLookupSite.LASTNAME].equals(\"\")) { lastnamePattern = Pattern.compile(patterns[ReverseLookupSite.LASTNAME]); } for (",
        "ground_truth": "NO",
        "predict": "int i = 0; i < data.length; i++) { yield(); if (namePattern != null) { nameMatcher = namePattern.matcher(data[i]); if (nameMatcher.find()) { firstname = nameMatcher.group(1); lastname = nameMatcher.group(2); } } if (streetPattern != null) { streetMatcher = streetPattern.matcher(data[i]); if (streetMatcher.find()) { street = streetMatcher.group(1); } } if (cityPattern != null) { cityMatcher = cityPattern.matcher(data[i]); if (cityMatcher.find()) { city = cityMatcher.group(1); } } if (zipcodePattern != null) { zipcodeMatcher = zipcodePattern.matcher(data[i]); if (zipcodeMatcher.find()) { zipcode = zipcodeMatcher.group(1); } } if (firstnamePattern != null) { first"
    },
    {
        "ID": 1933,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public void createZipCopy(IUIContext ui, final String zipFileName, final File[] filesToZip, final FilenameFilter fileFilter, Timestamp timestamp) { TestCase.assertNotNull(ui); TestCase.assertNotNull(zipFileName); TestCase.assertFalse(zipFileName.trim().length() == 0); TestCase.assertNotNull(filesToZip); TestCase.assertNotNull(timestamp); String nameCopy = zipFileName; if (nameCopy.endsWith(\".zip\")) { nameCopy = nameCopy.substring(0, zipFileName.length() - 4); } nameCopy = nameCopy + \"_\" + timestamp.toString() + \".zip\"; final String finalZip = nameCopy; IWorkspaceRunnable noResourceChangedEventsRunner = new IWorkspaceRunnable() { public void run(IProgressMonitor runnerMonitor) throws CoreException { try { Map<String, File> projectFiles = new HashMap<String, File>(); IPath basePath = new Path(\"/\"); for (File nextLocation : filesToZip) { projectFiles.putAll(getFilesToZip(nextLocation, basePath, fileFilter)); } if (projectFiles.isEmpty()) { PlatformActivator.logDebug(\"Zip file (\" + zipFileName + \") not created because there were no files to zip\"); return; } IPath resultsPath = PlatformActivator.getDefault().getResultsPath(); File copyRoot = resultsPath.toFile(); copyRoot.mkdirs(); IPath zipFilePath = resultsPath.append(new Path(finalZip)); String zipFileName = zipFilePath.toPortableString(); ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFileName)); try { out.setLevel(Deflater.DEFAULT_COMPRESSION); for (String filePath : projectFiles.keySet()) { File nextFile = projectFiles.get(filePath); FileInputStream fin = new FileInputStream(nextFile); try { out.putNextEntry(new ZipEntry(filePath)); try { byte[] bin = new byte[4096]; int bread = fin.read(bin, 0, 4096); while (bread != -1) { out.write(bin, 0, bread); bread = fin.read(bin, 0, 4096); } } finally { out.closeEntry(); } } finally { fin.close(); } } } finally { out.close(); } } catch (FileNotFoundException e) { Status error = new Status(Status.ERROR, PlatformActivator.PLUGIN_ID, Status.ERROR, e.getLocalizedMessage(), e); throw new CoreException(error); } catch (IOException e) { Status error = new Status(Status.ERROR, PlatformActivator.PLUGIN_ID, Status.ERROR, e.getLocalizedMessage(), e); throw new CoreException(error); } } }; try { IWorkspace workspace = ResourcesPlugin.getWorkspace(); workspace.run(noResourceChangedEventsRunner, workspace.getRoot(), IWorkspace.AVOID_UPDATE, new NullProgressMonitor()); } catch (CoreException ce) { PlatformActivator.logException(ce); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testCodingEmptyFile() throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); WritableByteChannel channel = newChannel(baos); HttpParams params = new BasicHttpParams(); SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params); HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl(); LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16); encoder.write(wrap(\"stuff;\")); File tmpFile = File.createTempFile(\"testFile\", \"txt\"); FileOutputStream fout = new FileOutputStream(tmpFile); OutputStreamWriter wrtout = new OutputStreamWriter(fout); wrtout.flush(); wrtout.close(); FileChannel fchannel = new FileInputStream(tmpFile).getChannel(); encoder.transfer(fchannel, 0, 20); encoder.write(wrap(\"more stuff\")); String s = baos.toString(\"US-ASCII\"); assertTrue(encoder.isCompleted()); assertEquals(\"stuff;more stuff\", s); tmpFile.delete(); }. \n Code2: protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) { try { URL url = new URL(apiUrl); HttpURLConnection request = (HttpURLConnection) url.openConnection(); if (ApplicationConstants.CONNECT_TIMEOUT > -1) { request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT); } if (ApplicationConstants.READ_TIMEOUT > -1) { request.setReadTimeout(ApplicationConstants.READ_TIMEOUT); } for (String headerName : requestHeaders.keySet()) { request.setRequestProperty(headerName, requestHeaders.get(headerName)); } request.setRequestMethod(\"POST\"); request.setDoOutput(true); PrintStream out = new PrintStream(new Buffered",
        "ground_truth": "NO",
        "predict": "OutputStream(request.getOutputStream())); for (String key : parameters.keySet()) { for (String value : parameters.get(key)) { out.print(key + \"=\" + value + \"\\n\"); } } out.close(); request.connect(); request.getInputStream(); return request.getInputStream(); } catch (IOException e) { return null; } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testCodingEmptyFile() throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); WritableByteChannel channel = newChannel(baos); HttpParams params = new BasicHttpParams(); SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params); HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl(); LengthDelimitedEncoder encoder = new LengthDelimited"
    },
    {
        "ID": 1934,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void testAddFiles() throws Exception { File original = ZipPlugin.getFileInPlugin(new Path(\"testresources/test.zip\")); File copy = new File(original.getParentFile(), \"1test.zip\"); InputStream in = null; OutputStream out = null; try { in = new FileInputStream(original); out = new FileOutputStream(copy); byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); } finally { Util.close(in); Util.close(out); } ArchiveFile archive = new ArchiveFile(ZipPlugin.createArchive(copy.getPath())); archive.addFiles(new String[] { ZipPlugin.getFileInPlugin(new Path(\"testresources/add.txt\")).getPath() }, new NullProgressMonitor()); IArchive[] children = archive.getChildren(); boolean found = false; for (IArchive child : children) { if (child.getLabel(IArchive.NAME).equals(\"add.txt\")) found = true; } assertTrue(found); copy.delete(); }. \n Code2: public void run() { LogPrinter.log(Level.FINEST, \"Started Download at : {0, date, long}\", new Date()); if (!PipeConnected) { throw new IllegalStateException(\"You should connect the pipe before with getInputStream()\"); } InputStream ins = null; if (IsAlreadyDownloaded) { LogPrinter.log(Level.FINEST, \"The file already Exists open and foward the byte\"); try { ContentLength = (int) TheAskedFile.length(); ContentType = URLConnection.getFileNameMap().getContentTypeFor(TheAskedFile.getName()); ins = new FileInputStream(TheAskedFile); byte[] buffer = new byte[BUFFER_SIZE]; int read = ins.read(buffer); while (read >= 0) { Pipe.write(buffer, 0, read); read = ins.read(buffer); } } catch (IOException e) { e.printStackTrace(); } finally { if (ins != null) { try { ins.close(); } catch (IOException e) { } } } } else { LogPrinter.log(Level.FINEST, \"the file does not exist locally so we try to download the thing\"); File theDir = TheAskedFile.getParentFile(); if (!theDir.exists()) { theDir.mkdirs(); } for (URL url : ListFastest) { FileOutputStream fout = null; boolean OnError = false; long timestart = System.currentTimeMillis(); long bytecount = 0; try { URL newUrl = new URL(url.toString() + RequestedFile); LogPrinter.log(Level.FINEST, \"the download URL = {0}\", newUrl); URLConnection conn = newUrl.openConnection(); ContentType = conn.getContentType(); ContentLength = conn.getContentLength(); ins = conn.getInputStream(); fout = new FileOutputStream(TheAskedFile); byte[] buffer = new byte[BUFFER_SIZE]; int read = ins.read(buffer); while (read >= 0) { fout.write(buffer, 0, read); Pipe.write(buffer, 0, read); read = ins.read(buffer); bytecount += read; } Pipe.flush(); } catch (IOException e) { OnError = true; } finally { if (ins != null) { try { ins.close(); } catch (IOException e) { } } if (fout != null) { try { fout.close(); } catch (IOException e) { } } } long timeend = System.currentTimeMillis(); if (OnError) { continue; } else { long timetook = timeend - timestart; BigDecimal speed = new BigDecimal(bytecount).multiply(new BigDecimal(1000)).divide(new BigDecimal(timetook), MathContext.DECIMAL32); for (ReportCalculatedStatistique report : Listener) { report.reportUrlStat(url, speed, timetook); } break; } } } LogPrinter.log(Level.FINEST, \"download finished at {0,date,long}\", new Date()); if (Pipe != null) { try { Pipe.close(); } catch (IOException e) { e.printStackTrace(); } } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException { ServletContext servletContext = this.getServletConfig().getServletContext(); WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); String szUrl = request.getParameter(\"url\"); System.out.println(szUrl); URL url; InputStream is = null; ServletOutputStream sout = null; try { url = new URL(szUrl); HttpURLConnection con = (HttpURLConnection) url.openConnection(); Enumeration hNames = request.getHeaderNames(); while (hNames.hasMoreElements()) { String txt = hNames.nextElement().toString(); con.setRequestProperty(txt, request.getHeader(txt)); } con.setRequestProperty(\"host\", url.getHost()); con.setRequestProperty(\"refer\", szUrl); con.setRequestMethod(method); con.setDoOutput(true); con.setDoInput(true); InputStreamReader inBody = new InputStreamReader(request.getInputStream()); char bufCh[] = new char[1024]; int r; OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream()); while ((r = inBody.read(bufCh)) != -1) { System.out.println(bufCh); outReq.write(bufCh, 0, r); } outReq.flush(); outReq.close(); inBody.close(); System.out.println(con.getResponseCode()); System.out.println(con.getResponseMessage()); if (con.getResponseCode() == con.HTTP_OK) { response.setContentType(con.getContentType()); response.addHeader(\"Content-Encoding\", con.getContentEncoding()); sout = response.getOutputStream(); is = con.getInputStream(); byte buff[] = new byte[1024]; while ((r = is.read(buff)) != -1) { sout.write(buff, 0, r); System.out.print(buff); } sout.flush(); is.close(); sout.close(); } else { response.sendError(con.getResponseCode(), con.getResponseMessage()); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }",
        "ground_truth": "YES",
        "predict": ". \n Code1: public void testAddFiles() throws Exception { File original = ZipPlugin.getFileInPlugin(new Path(\"testresources/test.zip\")); File copy = new File(original.getParentFile(), \"1test.zip\"); InputStream in = null; OutputStream out = null; try { in = new FileInputStream(original); out = new FileOutputStream(copy); byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) > 0) out.write(buf, 0, len); } finally { Util.close(in); Util.close(out); } ArchiveFile archive = new ArchiveFile(ZipPlugin.createArchive(copy.getPath())); archive.addFiles(new String[] { ZipPlugin.getFileInPlugin(new Path(\"testresources/add.txt\")).getPath() }, new NullProgressMonitor()); IArchive[] children = archive.getChildren(); boolean found = false; for ("
    },
    {
        "ID": 1940,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private final long test(final boolean applyFilter, final int executionCount) throws NoSuchAlgorithmException, NoSuchPaddingException, FileNotFoundException, IOException, RuleLoadingException { final boolean stripHtmlEnabled = true; final boolean injectSecretTokensEnabled = true; final boolean encryptQueryStringsEnabled = true; final boolean protectParamsAndFormsEnabled = true; final boolean applyExtraProtectionForDisabledFormFields = true; final boolean applyExtraProtectionForReadonlyFormFields = false; final boolean applyExtraProtectionForRequestParamValueCount = false; final ContentInjectionHelper helper = new ContentInjectionHelper(); final RuleFileLoader ruleFileLoaderModificationExcludes = new ClasspathZipRuleFileLoader(); ruleFileLoaderModificationExcludes.setPath(RuleParameter.MODIFICATION_EXCLUDES_DEFAULT.getValue()); final ContentModificationExcludeDefinitionContainer containerModExcludes = new ContentModificationExcludeDefinitionContainer(ruleFileLoaderModificationExcludes); containerModExcludes.parseDefinitions(); helper.setContentModificationExcludeDefinitions(containerModExcludes); final AttackHandler attackHandler = new AttackHandler(null, 123, 600000, 100000, 300000, 300000, null, \"MOCK\", false, false, 0, false, false, Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), Pattern.compile(\"sjghggfakgfjagfgajgfjasgfs\"), true, new AttackMailHandler()); final SessionCreationTracker sessionCreationTracker = new SessionCreationTracker(attackHandler, 0, 600000, 300000, 0, \"\", \"\", \"\", \"\"); final RequestWrapper request = new RequestWrapper(new RequestMock(), helper, sessionCreationTracker, \"123.456.789.000\", false, true, true); final RuleFileLoader ruleFileLoaderResponseModifications = new ClasspathZipRuleFileLoader(); ruleFileLoaderResponseModifications.setPath(RuleParameter.RESPONSE_MODIFICATIONS_DEFAULT.getValue()); final ResponseModificationDefinitionContainer container = new ResponseModificationDefinitionContainer(ruleFileLoaderResponseModifications); container.parseDefinitions(); final ResponseModificationDefinition[] responseModificationDefinitions = downCast(container.getAllEnabledRequestDefinitions()); final List<Pattern> tmpPatternsToExcludeCompleteTag = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<Pattern> tmpPatternsToExcludeCompleteScript = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<Pattern> tmpPatternsToExcludeLinksWithinScripts = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<Pattern> tmpPatternsToExcludeLinksWithinTags = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<Pattern> tmpPatternsToCaptureLinksWithinScripts = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<Pattern> tmpPatternsToCaptureLinksWithinTags = new ArrayList<Pattern>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToExcludeCompleteTag = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToExcludeCompleteScript = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToExcludeLinksWithinScripts = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToExcludeLinksWithinTags = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToCaptureLinksWithinScripts = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<WordDictionary> tmpPrefiltersToCaptureLinksWithinTags = new ArrayList<WordDictionary>(responseModificationDefinitions.length); final List<Integer[]> tmpGroupNumbersToCaptureLinksWithinScripts = new ArrayList<Integer[]>(responseModificationDefinitions.length); final List<Integer[]> tmpGroupNumbersToCaptureLinksWithinTags = new ArrayList<Integer[]>(responseModificationDefinitions.length); for (int i = 0; i < responseModificationDefinitions.length; i++) { final ResponseModificationDefinition responseModificationDefinition = responseModificationDefinitions[i]; if (responseModificationDefinition.isMatchesScripts()) { tmpPatternsToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPattern()); tmpPrefiltersToExcludeCompleteScript.add(responseModificationDefinition.getScriptExclusionPrefilter()); tmpPatternsToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinScripts.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinScripts.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinScripts.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } if (responseModificationDefinition.isMatchesTags()) { tmpPatternsToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPattern()); tmpPrefiltersToExcludeCompleteTag.add(responseModificationDefinition.getTagExclusionPrefilter()); tmpPatternsToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPattern()); tmpPrefiltersToExcludeLinksWithinTags.add(responseModificationDefinition.getUrlExclusionPrefilter()); tmpPatternsToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPattern()); tmpPrefiltersToCaptureLinksWithinTags.add(responseModificationDefinition.getUrlCapturingPrefilter()); tmpGroupNumbersToCaptureLinksWithinTags.add(ServerUtils.convertSimpleToObjectArray(responseModificationDefinition.getCapturingGroupNumbers())); } } final Matcher[] matchersToExcludeCompleteTag = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteTag); final Matcher[] matchersToExcludeCompleteScript = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeCompleteScript); final Matcher[] matchersToExcludeLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinScripts); final Matcher[] matchersToExcludeLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToExcludeLinksWithinTags); final Matcher[] matchersToCaptureLinksWithinScripts = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinScripts);",
        "ground_truth": "NO",
        "predict": " final Matcher[] matchersToCaptureLinksWithinTags = ServerUtils.convertListOfPatternToArrayOfMatcher(tmpPatternsToCaptureLinksWithinTags); final Matcher[] matchersToCaptureLinksWithinScriptsAndTags = new Matcher[matchersToCaptureLinksWithinScripts.length + matchersToCaptureLinksWithinTags.length]; System.arraycopy(matchersToCaptureLinksWithinScripts, 0, matchersToCaptureLinksWithinScriptsAndTags, 0, matchersToCaptureLinksWithinScripts.length); System.arraycopy(matchersToCaptureLinksWithinTags, 0, matchersToCaptureLinksWithinScriptsAndTags, matchersToCaptureLinksWithinScripts.length, matchersToCaptureLinksWithinTags.length); final Matcher[] matchersToExcludeScripts = new Matcher[matchersToExcludeLinksWithinScriptsAndTags.length + matchersToExcludeLinksWithinTags.length]; System.arraycopy(matchersToExcludeLinksWithin"
    },
    {
        "ID": 1943,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { Application.getController().notifyProgressStarted(); Application.getController().notifyProgressUpdated(-1); for (int f = 0; f < fileList.size(); f++) { File archive = fileList.get(f); String arname = archive.getName(); String arsuf = arname.substring(arname.lastIndexOf('.'), arname.length()); Algorithm alg = null; Algorithm algs[] = algFactory.getAlgorithms(); for (int i = 0; i < algs.length; i++) { if (algs[i].getSuffix().equalsIgnoreCase(arsuf)) { alg = algs[i]; break; } } if (alg == null) { Application.getController().displayError(bundle.getString(\"unknown_alg_title\"), bundle.getString(\"unknown_alg_text\")); return; } currentAlgorithm = alg; if (!alg.initDecrypt(password)) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } try { ZipArchiveInputStream zis = null; InputStream is = null; if (EncryptionMode.getBestEncryptionMode(alg.getEncryptionMode()) == EncryptionMode.MODE_STREAM) { is = alg.getDecryptionStream(new FileInputStream(archive)); if (is == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } } else if (EncryptionMode.getBestEncryptionMode(alg.getEncryptionMode()) == EncryptionMode.MODE_BLOCK) { is = new BlockCipherInputStream(new FileInputStream(archive), alg); if (is == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } } zis = new ZipArchiveInputStream(is); if (zis == null) { Application.getController().displayError(bundle.getString(\"dec_init_fail_title\"), bundle.getString(\"dec_init_fail_text\")); return; } File outputDir = getTargetDirectory(); if (outputDir == null) { return; } if (!outputDir.exists()) { if (!outputDir.mkdir()) { Application.getController().displayError(bundle.getString(\"output_dir_fail_title\"), outputDir.getAbsolutePath() + \" \" + bundle.getString(\"output_dir_fail_text\")); return; } } ZipArchiveEntry zae = null; boolean gotEntries = false; while ((zae = zis.getNextZipEntry()) != null) { gotEntries = true; File out = new File(outputDir, zae.getName()); if (out.exists()) { if (!mayOverwrite(out)) { continue; } } Application.getController().displayVerbose(\"writing to file: \" + out.getAbsolutePath()); if (!out.getParentFile().exists()) { out.getParentFile().mkdirs(); } if (zae.isDirectory()) { out.mkdir(); continue; } FileOutputStream os = new FileOutputStream(out); long length = zae.getCompressedSize(), counter = 0; Application.getController().displayVerbose(\"Length of zip entry \" + zae.getName() + \" is \" + length + \"b\"); byte[] buffer = new byte[16384]; MessageDigest md = MessageDigest.getInstance(\"SHA-1\"); DigestInputStream in = new DigestInputStream(zis, md); while ((counter = in.read(buffer)) > 0) { if (Thread.currentThread().isInterrupted()) { os.close(); zis.close(); Application.getController().notifyProgressFinished(); resetModel(true); return; } os.write(buffer, 0, (int) counter); } os.close(); if (zae.getComment() != null && zae.getComment().length() > 0) { if (Arrays.equals(md.digest(), new Base64().decode(zae.getComment()))) { Application.getController().displayVerbose(\"Hash of \" + zae.getName() + \": \" + new Base64().encodeToString(md.digest())); Application.getController().displayError(\"Hash Error\", \"The stored hash of the original file and the hash of the decrypted data do not match. Normally, this means that your data has been manipulated/damaged, but it can also happen if your Java Runtime has a bug in his hash functions.\\nIT IS VERY IMPORTANT TO CHECK THE INTEGRITY OF YOUR DECRYPTED DATA!\"); } else { Application.getController().displayVerbose(\"the hash of \" + zae.getName() + \" was verified succesfully\"); } } } if (!gotEntries) { Application.getController().displayError(bundle.getString(\"error_no_entries_title\"), bundle.getString(\"error_no_entries_text\")); outputDir.delete(); } zis.close(); resetModel(false); } catch (FileNotFoundException ex) { Application.getController().displayError(bundle.getString(\"error_file_not_exist\"), ex.getLocalizedMessage()); } catch (IOException ex) { Application.getController().displayError(bundle.getString(\"error_generic_io\"), ex.getLocalizedMessage()); } catch (NoSuchAlgorithmException ex) { Application.getController().displayError(bundle.getString(\"unknown_alg_text\"), ex.getLocalizedMessage()); } } Application.getController().notifyProgressFinished(); resetModel(true); }. \n Code2: private MimeTypes() { try { final URL url = RES.getURL(\"types\"); final InputStream is = url.openStream(); final BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line = br.readLine(); while (line != null) { line = line.trim(); final int p = line.indexOf('#'); if (p >= 0) { line = line.substring(0, p).trim(); } if (line.length() > 0) { final StringTokenizer st = new StringTokenizer(line, \" \\t\"); if (st.countTokens() > 1) { final String mime = st.nextToken(); while (st.hasMoreTokens()) { extnMap.put(st.nextToken(), mime); } } } line = br.readLine(); } br.close(); } catch (IOException e) { e.printStackTrace(); } canParse.add(TEXT_HTML); canParse.",
        "ground_truth": "NO",
        "predict": "add(TEXT_PLAIN); canParse.add(TEXT_XML); canParse.add(TEXT_X_C); canParse.add(TEXT_X_CHTML); canParse.add(TEXT_X_CSHARP); canParse.add(TEXT_X_CPP); canParse.add(TEXT_X_CSS); canParse.add(TEXT_X_DIFF); canParse.add(TEXT_X_FORTRAN); canParse.add(TEXT_X_JAVA); canParse.add(TEXT_X_LATEX); canParse.add(TEXT_X_LISP); canParse.add(TEXT_X_PERL); canParse.add(TEXT_X_PYTHON); canParse.add(TEXT_X_RUBY); canParse.add(TEXT_X_SH); canParse.add(TEXT_X_"
    },
    {
        "ID": 1960,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: private static void readAndRewrite(File inFile, File outFile) throws IOException { ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile))); DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis); Dataset ds = DcmObjectFactory.getInstance().newDataset(); dcmParser.setDcmHandler(ds.getDcmHandler()); dcmParser.parseDcmFile(null, Tags.PixelData); PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); System.out.println(\"reading \" + inFile + \"...\"); pdReader.readPixelData(false); ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile))); DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE; ds.writeDataset(out, dcmEncParam); ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength()); System.out.println(\"writing \" + outFile + \"...\"); PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR()); pdWriter.writePixelData(); out.flush(); out.close(); System.out.println(\"done!\"); }. \n Code2: public static IProject createEMFProject(IPath javaSource, URI projectLocationURI, List<IProject> referencedProjects, Monitor monitor, int style, List<?> pluginVariables) { IProgressMonitor progressMonitor = BasicMonitor.toIProgressMonitor(monitor); String projectName = javaSource.segment(0); IProject project = null; try { List<IClasspathEntry> classpathEntries = new UniqueEList<IClasspathEntry>(); progressMonitor.beginTask(\"\", 10); progressMonitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(\"_UI_CreatingEMFProject_message\", new Object[] { projectName, projectLocationURI != null ? projectLocationURI.toString() : projectName })); IWorkspace workspace = ResourcesPlugin.getWorkspace(); project = workspace.getRoot().getProject(projectName); if (!project.exists()) { URI location = projectLocationURI; if (location == null) { location = URI.createFileURI(workspace.getRoot().getLocation().append(projectName).toOSString()); } location = location.appendSegment(\".project\"); File projectFile = new File(location.toString()); if (projectFile.exists()) { projectFile.renameTo(new File(location.toString() + \".old\")); } } IJavaProject javaProject = JavaCore.create(project); IProjectDescription projectDescription = null; if (!project.exists()) { projectDescription = ResourcesPlugin.getWorkspace().newProjectDescription(projectName); if (projectLocationURI != null) { projectDescription.setLocationURI(new java.net.URI(projectLocationURI.toString())); } project.create(projectDescription, new SubProgressMonitor(progressMonitor, 1)); project.open(new SubProgressMonitor(progressMonitor, 1)); } else { projectDescription = project.getDescription(); project.open(new SubProgressMonitor(progressMonitor, 1)); if (project.hasNature(JavaCore.NATURE_ID)) { classpathEntries.addAll(Arrays.asList(javaProject.getRawClasspath())); } } boolean isInitiallyEmpty = classpathEntries.isEmpty(); { if (referencedProjects.size() != 0 && (style & (EMF_PLUGIN_PROJECT_STYLE | EMF_EMPTY_PROJECT_STYLE)) == 0) { projectDescription.setReferencedProjects(referencedProjects.toArray(new IProject[referencedProjects.size()])); for (IProject referencedProject : referencedProjects) { IClasspathEntry referencedProjectClasspathEntry = JavaCore.newProjectEntry(referencedProject.getFullPath()); classpathEntries.add(referencedProjectClasspathEntry); } } String[] natureIds = projectDescription.getNatureIds(); if (natureIds == null) { natureIds = new String[] { JavaCore.NATURE_ID, \"org.eclipse.pde.PluginNature\" }; } else { if (!project.hasNature(JavaCore.NATURE_ID)) { String[] oldNatureIds = natureIds; natureIds = new String[oldNatureIds.length + 1]; System.arraycopy(oldNatureIds, 0, natureIds, 0, oldNatureIds.length); natureIds[oldNatureIds.length] = JavaCore.NATURE_ID; } if (!project.hasNature(\"org.eclipse.pde.PluginNature\")) { String[] oldNatureIds = natureIds; natureIds = new String[oldNatureIds.length + 1]; System.arraycopy(oldNatureIds, 0, natureIds, 0, oldNatureIds.length); natureIds[oldNatureIds.length] = \"org.eclipse.pde.PluginNature\"; } } projectDescription.setNatureIds(natureIds); ICommand[] builders = projectDescription.getBuildSpec(); if (builders == null) { builders = new ICommand[0]; } boolean hasManifestBuilder = false; boolean hasSchemaBuilder = false; for (int i = 0; i < builders.length; ++i) { if (\"org.eclipse.pde.ManifestBuilder\".equals(builders[i].getBuilderName())) { hasManifestBuilder = true; } if (\"org.eclipse.pde.SchemaBuilder\".equals(builders[i].getBuilderName())) { hasSchemaBuilder = true; } } if (!hasManifestBuilder) { ICommand[] oldBuilders = builders; builders = new ICommand[oldBuilders.length + 1]; System.arraycopy(oldBuilders, 0, builders, 0, oldBuilders.length); builders[oldBuilders.length] = projectDescription.newCommand(); builders[oldBuilders.length].setBuilderName(\"org.eclipse.pde.ManifestBuilder\"); } if (!hasSchemaBuilder) { ICommand[] oldBuilders = builders; builders = new ICommand[oldBuilders.length + 1]; System.arraycopy(oldBuilders, 0, builders, 0, oldBuilders.length); builders[oldBuilders.length] = projectDescription.newCommand(); builders[oldBuilders.length].setBuilderName(\"org.",
        "ground_truth": "NO",
        "predict": "eclipse.pde.SchemaBuilder\"); } projectDescription.setBuildSpec(builders); project.setDescription(projectDescription, new SubProgressMonitor(progressMonitor, 1)); } catch (CoreException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (URISyntaxException e) { e.printStackTrace(); } finally { if (project != null && !project.exists()) { project.delete(true, new SubProgressMonitor(progressMonitor, 1)); } } if (isInitiallyEmpty) { project.refreshLocal(IResource.DEPTH_INFINITE, new SubProgressMonitor(progressMonitor, 1)); } } }\n"
    },
    {
        "ID": 1973,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public void importarHistoricoDeCotacoesDosPapeis(File[] pArquivosTXT, boolean pApagarDadosImportadosAnteriormente, Andamento pAndamento) throws FileNotFoundException, SQLException { if (pApagarDadosImportadosAnteriormente) { Statement stmtLimpezaInicialDestino = conDestino.createStatement(); String sql = \"TRUNCATE TABLE TMP_TB_COTACAO_AVISTA_LOTE_PDR\"; stmtLimpezaInicialDestino.executeUpdate(sql); sql = \"TRUNCATE TABLE TMP_TB_COTACAO_OUTROS_MERCADOS\"; stmtLimpezaInicialDestino.executeUpdate(sql); } final int TAMANHO_DO_REGISTRO = 245; long TAMANHO_DOS_METADADOS_DO_ARQUIVO = 2 * TAMANHO_DO_REGISTRO; long tamanhoDosArquivos = 0; for (File arquivoTXT : pArquivosTXT) { long tamanhoDoArquivo = arquivoTXT.length(); tamanhoDosArquivos += tamanhoDoArquivo; } int quantidadeEstimadaDeRegistros = (int) ((tamanhoDosArquivos - (pArquivosTXT.length * TAMANHO_DOS_METADADOS_DO_ARQUIVO)) / TAMANHO_DO_REGISTRO); String sqlMercadoAVistaLotePadrao = \"INSERT INTO TMP_TB_COTACAO_AVISTA_LOTE_PDR(DATA_PREGAO, CODBDI, CODNEG, TPMERC, NOMRES, ESPECI, PRAZOT, MODREF, PREABE, PREMAX, PREMIN, PREMED, PREULT, PREOFC, PREOFV, TOTNEG, QUATOT, VOLTOT, PREEXE, INDOPC, DATVEN, FATCOT, PTOEXE, CODISI, DISMES) VALUES(:DATA_PREGAO, :CODBDI, :CODNEG, :TPMERC, :NOMRES, :ESPECI, :PRAZOT, :MODREF, :PREABE, :PREMAX, :PREMIN, :PREMED, :PREULT, :PREOFC, :PREOFV, :TOTNEG, :QUATOT, :VOLTOT, :PREEXE, :INDOPC, :DATVEN, :FATCOT, :PTOEXE, :CODISI, :DISMES)\"; OraclePreparedStatement stmtDestinoMercadoAVistaLotePadrao = (OraclePreparedStatement) conDestino.prepareStatement(sqlMercadoAVistaLotePadrao); stmtDestinoMercadoAVistaLotePadrao.setExecuteBatch(COMANDOS_POR_LOTE); String sqlOutrosMercados = \"INSERT INTO TMP_TB_COTACAO_OUTROS_MERCADOS(DATA_PREGAO, CODBDI, CODNEG, TPMERC, NOMRES, ESPECI, PRAZOT, MODREF, PREABE, PREMAX, PREMIN, PREMED, PREULT, PREOFC, PREOFV, TOTNEG, QUATOT, VOLTOT, PREEXE, INDOPC, DATVEN, FATCOT, PTOEXE, CODISI, DISMES) VALUES(:DATA_PREGAO, :CODBDI, :CODNEG, :TPMERC, :NOMRES, :ESPECI, :PRAZOT, :MODREF, :PREABE, :PREMAX, :PREMIN, :PREMED, :PREULT, :PREOFC, :PREOFV, :TOTNEG, :QUATOT, :VOLTOT, :PREEXE, :INDOPC, :DATVEN, :FATCOT, :PTOEXE, :CODISI, :DISMES)\"; OraclePreparedStatement stmtDestinoOutrosMercados = (OraclePreparedStatement) conDestino.prepareStatement(sqlOutrosMercados); stmtDestinoOutrosMercados.setExecuteBatch(COMANDOS_POR_LOTE); int quantidadeDeRegistrosImportadosDosArquivos = 0; Scanner in = null; int numeroDoRegistro = -1; try { for (File arquivoTXT : pArquivosTXT) { int quantidadeDeRegistrosImportadosDoArquivoAtual = 0; int vDATA_PREGAO; try { in = new Scanner(new FileInputStream(arquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name()); String registro; numeroDoRegistro = 0; while (in.hasNextLine()) { ++numeroDoRegistro; registro = in.nextLine(); if (registro.length() != TAMANHO_DO_REGISTRO) throw new ProblemaNaImportacaoDeArquivo(); if (registro.startsWith(\"01\")) { stmtDestinoMercadoAVistaLotePadrao.clearParameters(); stmtDestinoOutrosMercados.clearParameters(); vDATA_PREGAO = Integer.parseInt(registro.substring(2, 10).trim()); int vCODBDI = Integer.parseInt(registro.substring(10, 12).trim()); String vCODNEG = registro.substring(12, 24).trim(); int vTPMERC = Integer.parseInt(registro.substring(24, 27).trim()); String vNOMRES = registro.substring(27, 39).trim(); String vESPECI = registro.substring(39, 49).trim(); String vPRAZOT = registro.substring(49, 52).trim(); String vMODREF = registro.substring(52, 56).trim(); BigDecimal vPREABE = obterBigDecimal(registro.substring(56, 69).trim(), 13, 2); BigDecimal vPREMAX = obterBigDecimal(registro.substring(69, 82).trim(), 13, 2); BigDecimal vPREMIN = obterBigDecimal(registro.substring(82, 95).trim(), 13, 2); BigDecimal vPREMED = obterBig",
        "ground_truth": "NO",
        "predict": "Decimal(registro.substring(95, 108).trim(), 13, 2); BigDecimal vPREULT = obterBigDecimal(registro.substring(108, 121).trim(), 13, 2); BigDecimal vPREOFC = obterBigDecimal(registro.substring(121, 134).trim(), 13, 2); BigDecimal vPREOFV = obterBigDecimal(registro.substring(134, 147).trim(), 13, 2); BigDecimal vTOTNEG = obterBigDecimal(registro.substring(147, 160).trim(), 13, 2); BigDecimal vQUATOT = obterBigDecimal(registro.substring(160, 173).trim(), 13, 2); BigDecimal vVOLTOT = obterBigDecimal(registro.substring(173, 186).trim(), 13, 2); BigDecimal"
    },
    {
        "ID": 1980,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: @Override public void run() { try { jButton1.setEnabled(false); jButton2.setEnabled(false); URL url = new URL(updatePath + \"currentVersion.txt\"); URLConnection con = url.openConnection(); con.connect(); BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); String line; for (int i = 0; (line = in.readLine()) != null; i++) { URL fileUrl = new URL(updatePath + line); URLConnection filecon = fileUrl.openConnection(); InputStream stream = fileUrl.openStream(); int oneChar, count = 0; int size = filecon.getContentLength(); jProgressBar1.setMaximum(size); jProgressBar1.setValue(0); File testFile = new File(line); String build = \"\"; for (String dirtest : line.split(\"/\")) { build += dirtest; if (!build.contains(\".\")) { File dirfile = new File(build); if (!dirfile.exists()) { dirfile.mkdir(); } } build += \"/\"; } if (testFile.length() == size) { } else { transferFile(line, fileUrl, size); if (line.endsWith(\"documents.zip\")) { ZipInputStream in2 = new ZipInputStream(new FileInputStream(line)); ZipEntry entry; String pathDoc = line.split(\"documents.zip\")[0]; File docDir = new File(pathDoc + \"documents\"); if (!docDir.exists()) { docDir.mkdir(); } while ((entry = in2.getNextEntry()) != null) { String outFilename = pathDoc + \"documents/\" + entry.getName(); OutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename)); byte[] buf = new byte[1024]; int len; while ((len = in2.read(buf)) > 0) { out.write(buf, 0, len); } out.close(); } in2.close(); } if (line.endsWith(\"mysql.zip\")) { ZipFile zipfile = new ZipFile(line); Enumeration entries = zipfile.entries(); String pathDoc = line.split(\"mysql.zip\")[0]; File docDir = new File(pathDoc + \"mysql\"); if (!docDir.exists()) { docDir.mkdir(); } while (entries.hasMoreElements()) { ZipEntry entry = (ZipEntry) entries.nextElement(); if (entry.isDirectory()) { System.err.println(\"Extracting directory: \" + entry.getName()); (new File(pathDoc + \"mysql/\" + entry.getName())).mkdir(); continue; } System.err.println(\"Extracting file: \" + entry.getName()); InputStream in2 = zipfile.getInputStream(entry); OutputStream out = new BufferedOutputStream(new FileOutputStream(pathDoc + \"mysql/\" + entry.getName())); byte[] buf = new byte[1024]; int len; while ((len = in2.read(buf)) > 0) { out.write(buf, 0, len); } in2.close(); out.close(); } } } jProgressBar2.setValue(i + 1); labelFileProgress.setText((i + 1) + \"/\" + numberFiles); } labelStatus.setText(\"Update Finished\"); jButton1.setVisible(false); jButton2.setText(\"Finished\"); jButton1.setEnabled(true); jButton2.setEnabled(true); } catch (IOException ex) { Logger.getLogger(Updater.class.getName()).log(Level.SEVERE, null, ex); } }. \n Code2: public void movePrior(String[] showOrder, String[] orgID, String targetShowOrder, String targetOrgID) throws Exception { Connection con = null; PreparedStatement ps = null; ResultSet result = null; int moveCount = showOrder.length; DBOperation dbo = factory.createDBOperation(POOL_NAME); String strQuery = \"select show_order from \" + Common.ORGANIZE_TABLE + \" where show_order=\" + showOrder[moveCount - 1] + \" and organize_id= '\" + orgID[moveCount - 1] + \"'\"; try { con = dbo.getConnection(); con.setAutoCommit(false); ps = con.prepareStatement(strQuery); result = ps.executeQuery(); int maxOrderNo = 0; if (result.next()) { maxOrderNo = result.getInt(1); } String[] sqls = new String[moveCount + 1]; sqls[0] = \"update \" + Common.ORGANIZE_TABLE + \" set show_order=\" + maxOrderNo + \" where show_order=\" + targetShowOrder + \" and organize_id= '\" + targetOrgID + \"'\"; for (int i = 0; i < showOrder.length; i++) { sqls[i + 1] = \"update \" + Common.ORGANIZE_TABLE + \" set show_order=show_order-1\" + \" where show_order=\" + showOrder[i] + \" and organize_id= '\" + orgID[i] + \"'\"; } for (int j = 0; j < sqls.length; j++) { ps = con.prepareStatement(sqls[j]); int resultCount = ps.executeUpdate(); if (resultCount != 1) { throw new CesSystemException(\"Organize.movePrior(): ERROR Inserting data \" + \"in T_SYS_ORGANIZE update !! resultCount = \" + resultCount); } } con.commit(); } catch (SQLException se) { if (con != null) { con.rollback(); } throw new CesSystemException(\"Organize.movePrior(): SQLException while mov organize order \" + \" :\\n\\t\" + se); } finally { con.setAutoCommit(true); close(dbo, ps, result); } }. \n Response: YES. \n Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: static void populateResources() throws BasicException { try { List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage()); if (templates.size() == 0) { templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\"); } for (URL url : templates) { String fileName = url.getFile(); fileName = fileName.substring(fileName.lastIndexOf('/') + 1); if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) { Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4)); InputStream is = url.openStream(); StringBuffer",
        "ground_truth": "NO",
        "predict": " template = new StringBuffer(); try { template.append(IOUtils.toString(is)); } catch (IOException ex) { Logger.getLogger(Updater.class.getName()).log(Level.SEVERE, null, ex); } templateResource.setContent(template.toString()); templateResource.setName(fileName); templateResource.setType(Resource.TYPE_TEMPLATE); templateResource.setDescription(fileName); templateResource.setParent(null); templateResource.setRoot(null); templateResource.setType(Resource.TYPE_TEMPLATE); templateResource.setVersion(1); templateResource.setAuthor(Common.getUserName()); templateResource.setCreationDate(new Date()); templateResource.setModificationDate(new Date()); templateResource.setPublic(true); templateResource.setPublicURL(url.toString()); templateResource.setPublicURL(url.toString()); templateResource.setPublicURL("
    },
    {
        "ID": 1998,
        "prompt": "Instruction: Is there a colne relation between the Code1 and Code2, and respond to YES or NO. Code1: public boolean initFile(String filename) { showStatus(\"Loading the file, please wait...\"); x_units = \"?\"; y_units = \"ARBITRARY\"; Datatype = \"UNKNOWN\"; if (filename.toLowerCase().endsWith(\".spc\")) { try { URL url = new URL(getDocumentBase(), filename); InputStream stream = url.openStream(); DataInputStream fichier = new DataInputStream(stream); byte ftflgs = fichier.readByte(); byte fversn = fichier.readByte(); if (((ftflgs != 0) && (ftflgs != 0x20)) || (fversn != 0x4B)) { Current_Error = \", support only Evenly Spaced new version 4B\"; return false; } byte fexp = fichier.readByte(); if (fexp != 0x80) YFactor = Math.pow(2, fexp) / Math.pow(2, 32); Nbpoints = NumericDataUtils.convToIntelInt(fichier.readInt()); if (Firstx == shitty_starting_constant) { Firstx = NumericDataUtils.convToIntelDouble(fichier.readLong()); Lastx = NumericDataUtils.convToIntelDouble(fichier.readLong()); } byte fxtype = fichier.readByte(); switch(fxtype) { case 0: x_units = \"Arbitrary\"; break; case 1: x_units = \"Wavenumber (cm -1)\"; break; case 2: x_units = \"Micrometers\"; break; case 3: x_units = \"Nanometers\"; break; case 4: x_units = \"Seconds\"; break; case 5: x_units = \"Minuts\"; break; case 6: x_units = \"Hertz\"; break; case 7: x_units = \"Kilohertz\"; break; case 8: x_units = \"Megahertz\"; break; case 9: x_units = \"Mass (M/z)\"; break; case 10: x_units = \"Parts per million\"; break; case 11: x_units = \"Days\"; break; case 12: x_units = \"Years\"; break; case 13: x_units = \"Raman Shift (cm -1)\"; break; case 14: x_units = \"Electron Volt (eV)\"; break; case 16: x_units = \"Diode Number\"; break; case 17: x_units = \"Channel\"; break; case 18: x_units = \"Degrees\"; break; case 19: x_units = \"Temperature (F)\"; break; case 20: x_units = \"Temperature (C)\"; break; case 21: x_units = \"Temperature (K)\"; break; case 22: x_units = \"Data Points\"; break; case 23: x_units = \"Milliseconds (mSec)\"; break; case 24: x_units = \"Microseconds (uSec)\"; break; case 25: x_units = \"Nanoseconds (nSec)\"; break; case 26: x_units = \"Gigahertz (GHz)\"; break; case 27: x_units = \"Centimeters (cm)\"; break; case 28: x_units = \"Meters (m)\"; break; case 29: x_units = \"Millimeters (mm)\"; break; case 30: x_units = \"Hours\"; break; case -1: x_units = \"(double interferogram)\"; break; } byte fytype = fichier.readByte(); switch(fytype) { case 0: y_units = \"Arbitrary Intensity\"; break; case 1: y_units = \"Interfeogram\"; break; case 2: y_units = \"Absorbance\"; break; case 3: y_units = \"Kubelka-Munk\"; break; case 4: y_units = \"Counts\"; break; case 5: y_units = \"Volts\"; break; case 6: y_units = \"Degrees\"; break; case 7: y_units = \"Milliamps\"; break; case 8: y_units = \"Millimeters\"; break; case 9: y_units = \"Millivolts\"; break; case 10: y_units = \"Log (1/R)\"; break; case 11: y_units = \"Percent\"; break; case 12: y_units = \"Intensity\"; break; case 13: y_units = \"Relative Intensity\"; break; case 14: y_units = \"Energy\"; break; case 16: y_units = \"Decibel\"; break; case 19: y_units = \"Temperature (F)\"; break; case 20: y_units = \"Temperature (C)\"; break; case 21: y_units = \"Temperature (K)\"; break; case 22: y_units = \"Index of Refraction [N]\"; break; case 23: y_units = \"Extinction Coeff. [K]\"; break; case 24: y_units = \"Real\"; break; case 25: y_units = \"Imaginary\"; break; case 26: y_units = \"Complex\"; break; case -128: y_units = \"Transmission\"; break; case -127: y_units = \"Reflectance\"; break; case -126: y_units = \"Arbitrary or Single Beam with Valley Peaks\"; break; case -125: y_units = \"Emission\"; break; } if (ftflgs == 0) { fichier.skipBytes(512 - 30); } else { fichier.skipBytes(188); byte b; int i = 0; x_units = \"\"; do { b = fichier.readByte(); x_units += (char) b; i++; } while (b != 0); int j = 0; y_units = \"\"; do { b = fichier.readByte(); y_units += (char) b; j++; } while (b != 0); fichier.skipBytes(512 - 30 - 188 - i - j); } fichier.skipBytes(32); My_ZoneVisu.tableau_points = new double[Nbpoints]; if (fexp == 0x80) { for (int i = 0; i < Nbpoints; i++) { My_ZoneVisu.tableau_points[i] = NumericDataUtils.convToIntelFloat(fichier.readInt()); } } else { for (int i = 0; i < Nbpoints; i++) { My_ZoneVisu.tableau_points[i] = NumericDataUtils.convToIntelInt(fichier.readInt()); } } } catch (Exception e) { Current_Error = \"SPC file corrupted\"; return false; } Datatype = \"XYDATA\"; return true; } try { URL url = new URL(getDocumentBase(), filename); InputStream stream = url.openStream(); BufferedReader fichier = new BufferedReader(new InputStreamReader(",
        "ground_truth": "NO",
        "predict": "stream)); String ligne = \"\"; while ((ligne = fichier.readLine()) != null) { if (ligne.startsWith(\"#\")) { continue; } } } catch (Exception e) { Current_Error = \"SPC file corrupted\"; return false; } }\n\n}\n"
    }
]