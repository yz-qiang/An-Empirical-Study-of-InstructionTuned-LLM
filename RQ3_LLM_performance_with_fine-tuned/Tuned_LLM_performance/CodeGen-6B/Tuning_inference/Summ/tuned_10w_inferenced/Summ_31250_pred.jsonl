{"ID": 1, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) { final Observer<? super V> observer = downstream; final SimplePlainQueue<U> q = queue; if (wip.get() == 0 && wip.compareAndSet(0, 1)) { if (q.isEmpty()) { accept(observer, value); if (leave(-1) == 0) { return; } } else { q.offer(value); } } else { q.offer(value); if (!enter()) { return; } } QueueDrainHelper.drainLoop(q, observer, delayError, disposable, this); } \nResponse:", "ground_truth": "Makes sure the fast-path emits in order.\n@param value the value to emit or queue up\n@param delayError if true, errors are delayed until the source has terminated\n@param disposable the resource to dispose if the drain terminates", "predict": " Processing complexity is O(1) thus it can be executed in the fast-path.\n */"}
{"ID": 2, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public static <T> Observable<T> wrap(ObservableSource<T> source) { ObjectHelper.requireNonNull(source, \"source is null\"); if (source instanceof Observable) { return RxJavaPlugins.onAssembly((Observable<T>)source); } return RxJavaPlugins.onAssembly(new ObservableFromUnsafeSource<T>(source)); } \nResponse:", "ground_truth": "Wraps an ObservableSource into an Observable if not already an Observable.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code wrap} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <T> the value type\n@param source the source ObservableSource instance\n@return the new Observable instance or the same as the source\n@throws NullPointerException if source is null", "predict": " Wraps an ObservableSource into a new ObservableSource by emitting each item from the source ObservableSource and completing if the other ObservableSource emits an item. @param source the source ObservableSource @return the new ObservableSource\n*/"}
{"ID": 3, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Observable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction is null\"); return toList().toObservable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns an Observable that emits the events emitted by source ObservableSource, in a\nsorted order based on a specified comparison function.\n\n<p>Note that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param sortFunction\na function that compares two items emitted by the source ObservableSource and returns an Integer\nthat indicates their sort order\n@return an Observable that emits the items emitted by the source ObservableSource in sorted order", "predict": " Returns an Observable that emits items that are sorted by a key that has been extracted from each item emitted by the source Observable. Each item emitted by the Observable must have a value of type Comparable<?>, which is extracted by calling a supplied function on that item. The Observable emits the extracted values sorted by the extracted key values. @param sortFunction a function that, when applied to an item emitted by the source Observable, returns a Comparable<?> that describes how the item should be sorted. @return an Observable that emits items that are sorted by the sort function\n"}
{"ID": 4, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) { final Observable<T> observable = co.observeOn(scheduler); return RxJavaPlugins.onAssembly(new Replay<T>(co, observable)); } \nResponse:", "ground_truth": "Child Observers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param <T> the value type\n@param co the connectable observable instance\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": " Instructs an Observable to pass control to another Observable rather than invoking <code>subscribe()</code> immediately. <p> <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png\" alt=\"\"> <dl>\n <dt><b>Scheduler:</b></dt>\n <dd>you specify which {@link Scheduler} this operator will use</dd>\n </dl>\n @param co the ConnectableObservable to transform\n @param scheduler the {@link Scheduler} to perform the subscription action on\n @param <T> the type of the items emitted by the source and the result\n @return the source Observable modified so that its subscriptions happen on the given Scheduler\n @see <a href=\"http://reactivex.io/documentation/operators/connectable.html\">ReactiveX operators documentation:"}
{"ID": 5, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint) { return new UnicastProcessor<T>(capacityHint); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint.\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastProcessor instance", "predict": " Creates a UnicastProcessor with the given capacity hint.\n @param capacityHint the capacity hint for the UnicastProcessor\n @param <T> the type of item emitted by the UnicastProcessor\n @return the UnicastProcessor wrapping an unbounded hot unbounded buffer\n*/"}
{"ID": 6, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastProcessor<T> create(int capacityHint, Runnable onCancelled) { ObjectHelper.requireNonNull(onCancelled, \"onTerminate\"); return new UnicastProcessor<T>(capacityHint, onCancelled); } \nResponse:", "ground_truth": "Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onCancelled the non null callback\n@return an UnicastProcessor instance", "predict": " Creates a UnicastProcessor with the ability to hold onto Items while waiting for the next Subscriber.\n * <p>The UnicastProcessor doesn't call the Subscriber.onSubscribe method until the first Subscriber subscribes. This means that all subscribers will receive the same Subscription. Each subscription will receive a unique Disposable. Canceling either of these Subscriptions will affect all subscriptions.\n * <p>The UnicastProcessor uses an unbounded concurrent linked queue as the internal data structure. Conceptually, the UnicastProcessor is similar to a Scala Maybe type.\n * <p>The UnicastProcessor uses the {@link RxJavaPlugins#onAssembly} hook to pass the particular QueueSubscription to the StateHolder.\n * <p>Note that the UnicastProcessor doesn't support cancellation. Use {@link RxJavaPlugins#setErrorHandler(Consumer)} to provide your own cancellation handler.\n * @param capacityHint the hint for the backing"}
{"ID": 7, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(Publisher<T> source, Subscriber<? super R> subscriber, Function<? super T, ? extends Publisher<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (t == null) { EmptySubscription.complete(subscriber); return true; } Publisher<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, subscriber); return true; } if (u == null) { EmptySubscription.complete(subscriber); return true; } subscriber.onSubscribe(new ScalarSubscription<R>(subscriber, u)); } else { r.subscribe(subscriber); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped Publisher.\n@param <T> the input value type\n@param <R> the output value type\n@param source the source Publisher\n@param subscriber the subscriber\n@param mapper the function mapping a scalar value into a Publisher\n@return true if successful, false if the caller should continue with the regular path.", "predict": " ScalarXMapSubscribe tries to cast the source Publisher to a Single or Maybe. If this succeeds, the Maybe/Single is subscribes to this Single/Maybe instead of the original Publisher. This allows fluent API such as flux.just(1).map(v -> flux.just(v * 10)).subscribe(... )\n * @param <T> the value type\n * @param <R> the result type\n * @param source the source Publisher\n * @param subscriber the subscriber to be subscribed to the Maybe/Single\n * @param mapper the mapper function to be applied on the Maybe/Single\n * @return true if cast was successful\n */"}
{"ID": 8, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Flowable<U> scalarXMap(final T value, final Function<? super T, ? extends Publisher<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapFlowable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into a Publisher and emits its values.\n\n@param <T> the scalar value type\n@param <U> the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\na Publisher that gets streamed\n@return the new Flowable instance", "predict": " Scalar flatMap for Publishers.\n* @param <T> the value type\n* @param <U> the output type\n* @param mapper the mapper function to be applied to the value emitted by the source Publisher, not null\n* @return the new Flowable instance\n*/"}
{"ID": 9, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { setErrorHandler(null); setScheduleHandler(null); setComputationSchedulerHandler(null); setInitComputationSchedulerHandler(null); setIoSchedulerHandler(null); setInitIoSchedulerHandler(null); setSingleSchedulerHandler(null); setInitSingleSchedulerHandler(null); setNewThreadSchedulerHandler(null); setInitNewThreadSchedulerHandler(null); setOnFlowableAssembly(null); setOnFlowableSubscribe(null); setOnObservableAssembly(null); setOnObservableSubscribe(null); setOnSingleAssembly(null); setOnSingleSubscribe(null); setOnCompletableAssembly(null); setOnCompletableSubscribe(null); setOnConnectableFlowableAssembly(null); setOnConnectableObservableAssembly(null); setOnMaybeAssembly(null); setOnMaybeSubscribe(null); setOnParallelAssembly(null); setFailOnNonBlockingScheduler(false); setOnBeforeBlocking(null); } \nResponse:", "ground_truth": "Removes all handlers and resets to default behavior.", "predict": " Reset RxJava operators to defaults. Useful for injecting mocked schedulers. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful for resetting operators to their initial state. Useful"}
{"ID": 10, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) { ObjectHelper.requireNonNull(completableSource, \"completableSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource)); } \nResponse:", "ground_truth": "Wraps a CompletableSource into a Maybe.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param <T> the target type\n@param completableSource the CompletableSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if completable is null", "predict": " Converts a CompletableSource into a MaybeSource. @param completableSource the completable source to convert @return the MaybeSource instance\n*/"}
{"ID": 11, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @SchedulerSupport(SchedulerSupport.NONE) public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) { ObjectHelper.requireNonNull(singleSource, \"singleSource is null\"); return RxJavaPlugins.onAssembly(new MaybeFromSingle<T>(singleSource)); } \nResponse:", "ground_truth": "Wraps a SingleSource into a Maybe.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code fromSingle} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param <T> the target type\n@param singleSource the SingleSource to convert from\n@return the new Maybe instance\n@throws NullPointerException if single is null", "predict": " Converts a Single into a Maybe. @param singleSource SingleSource to convert @return Maybe that emits items emitted by the source Single\n */"}
{"ID": 12, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @SchedulerSupport(SchedulerSupport.NONE) public final Maybe<T> retry(long times, Predicate<? super Throwable> predicate) { return toFlowable().retry(times, predicate).singleElement(); } \nResponse:", "ground_truth": "Retries at most times or until the predicate returns false, whichever happens first.\n\n<dl>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code retry} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n@param times the number of times to resubscribe if the current Maybe fails\n@param predicate the predicate called with the failure Throwable and should return true to trigger a retry.\n@return the new Maybe instance", "predict": " Retries the source Maybe up to the specified number of times. @param times the number of times to retry @param predicate the predicate to filter the source items @return the new Maybe instance\n*/"}
{"ID": 13, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T requireNonNull(T object, String message) { if (object == null) { throw new NullPointerException(message); } return object; } \nResponse:", "ground_truth": "Verifies if the object is not null and returns it or throws a NullPointerException\nwith the given message.\n@param <T> the value type\n@param object the object to verify\n@param message the message to use with the NullPointerException\n@return the object itself\n@throws NullPointerException if object is null", "predict": " Ensures that an object reference passed as a parameter to the calling method is not null. In case it is null, it throws a NullPointerException with the specified message. @param object the object reference to check for nullity. @param message the exception message to use in case the check fails. @return the validated object reference.\n"}
{"ID": 14, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> Function<T, T> identity() { return (Function<T, T>)IDENTITY; } \nResponse:", "ground_truth": "Returns an identity function that simply returns its argument.\n@param <T> the input and output value type\n@return the identity function", "predict": " Singleton identity function. Useful for composing functional operators.\n */ Melee expects functions to be stateless and pure. Thus, this function is a good fit.\n * Melee will optimize your program by eliminating redundant computations.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating unnecessary casting.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating unnecessary casting.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating unnecessary casting.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating unnecessary casting.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating unnecessary casting.\n * Melee will also optimize your program by eliminating unnecessary boxing and unboxing.\n * Melee will also optimize your program by eliminating"}
{"ID": 15, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> justCallable(T value) { return new JustValue<Object, T>(value); } \nResponse:", "ground_truth": "Returns a Callable that returns the given value.\n@param <T> the value type\n@param value the value to return\n@return the new Callable instance", "predict": " Justfy a value to be returned as a Callable. Useful for mocking purposes. @param value The value to be returned. @return A Callable that will return the given value."}
{"ID": 16, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> justFunction(U value) { return new JustValue<T, U>(value); } \nResponse:", "ground_truth": "Returns a Function that ignores its parameter and returns the given value.\n@param <T> the function's input type\n@param <U> the value and return type of the function\n@param value the value to return\n@return the new Function instance", "predict": " Just a functional interface to supply a constant value. Useful for situations where you want to supply a constant value to a lambda but don't want to create lots of unnecessary lambda expressions.\nExample usage: <pre>{@code Just.justFunction(42).apply(null); }</pre>\n@param <T> Functional parameter type. @param value Supplies constant value. @return Functional interface supplying constant value."}
{"ID": 17, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Function<T, U> castFunction(Class<U> target) { return new CastToClass<T, U>(target); } \nResponse:", "ground_truth": "Returns a function that cast the incoming values via a Class object.\n@param <T> the input value type\n@param <U> the output and target type\n@param target the target class\n@return the new Function instance", "predict": " Cast a Function to a target class. Useful for statically typed functional programming. @param target Target class to cast to. @param <T> Target type. @param <U> Source type. @return Casted Function."}
{"ID": 18, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create() { return new UnicastSubject<T>(bufferSize(), true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16.\n@param <T> the value type\n@return an UnicastSubject instance", "predict": " Creates a UnicastSubject with unbounded buffer.\n @since 2.0\n @param <T> the value type\n @return the UnicastSubject instance\n*/"}
{"ID": 19, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint) { return new UnicastSubject<T>(capacityHint, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint.\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@return an UnicastSubject instance", "predict": " Creates a UnicastSubject with the given capacity hint.\n @param capacityHint the capacity hint @return the UnicastSubject instance\n @since 2.0\n */ @NonNull\npublic static <T> UnicastSubject<T> create(int capacityHint) {\n    return new UnicastSubject<T>(capacityHint, true);\n}\n"}
{"ID": 20, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) { return new UnicastSubject<T>(capacityHint, onTerminate, true); } \nResponse:", "ground_truth": "Creates an UnicastSubject with the given internal buffer capacity hint and a callback for\nthe case when the single Subscriber cancels its subscription.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n\n@param <T> the value type\n@param capacityHint the hint to size the internal unbounded buffer\n@param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed\n@return an UnicastSubject instance", "predict": " Creates a UnicastSubject with the given capacity hint.\n @param capacityHint the capacity hint @param onTerminate the termination handler\n @return the UnicastSubject instance\n @since 2.0\n */ @NonNull\npublic static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {\n    requireNonNull(onTerminate, ERROR_TERMINATED);\n    return new UnicastSubject<T>(capacityHint, onTerminate, false);\n}\n"}
{"ID": 21, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull public static <T> UnicastSubject<T> create(boolean delayError) { return new UnicastSubject<T>(bufferSize(), delayError); } \nResponse:", "ground_truth": "Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.\n\n<p>The callback, if not null, is called exactly once and\nnon-overlapped with any active replay.\n<p>History: 2.0.8 - experimental\n@param <T> the value type\n@param delayError deliver pending onNext events before onError\n@return an UnicastSubject instance\n@since 2.2", "predict": " Creates a UnicastSubject with unbounded buffer.\n @param <T> the value type\n @return the UnicastSubject instance\n*/"}
{"ID": 22, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError() { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); await(); } catch (InterruptedException ex) { dispose(); return ex; } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or null if no\nerror happened.\n@return the error received or null", "predict": " Await termination of computation and return computation's error. Blocks until computation terminates or throws InterruptedException. @return computation's error.\n*/"}
{"ID": 23, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Throwable blockingGetError(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit))); } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } return error; } \nResponse:", "ground_truth": "Block until the latch is counted down and return the error received or\nwhen the wait is interrupted or times out, null otherwise.\n@param timeout the timeout value\n@param unit the time unit\n@return the error received or null", "predict": " Await the completion of the computation without leaking timing information to outsiders. Unlike other wait methods, this method releases the lock **after** blocking. Care should be taken to ensure that the wait completes without interruption. Otherwise, unexpected behavior will result. @param timeout how long to wait before giving up, in the desired time unit @param unit a time unit that expresses the tolerance of the system time being wrong @return the computation's result\n*/"}
{"ID": 24, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean blockingAwait(long timeout, TimeUnit unit) { if (getCount() != 0) { try { BlockingHelper.verifyNonBlocking(); if (!await(timeout, unit)) { dispose(); return false; } } catch (InterruptedException ex) { dispose(); throw ExceptionHelper.wrapOrThrow(ex); } } Throwable ex = error; if (ex != null) { throw ExceptionHelper.wrapOrThrow(ex); } return true; } \nResponse:", "ground_truth": "Block until the observer terminates and return true; return false if\nthe wait times out.\n@param timeout the timeout value\n@param unit the time unit\n@return true if the observer terminated in time, false otherwise", "predict": " Await termination of this Future. This method blocks until the Future completes or the timeout expires. @param timeout the maximum time to wait @param unit the time unit of the timeout argument @return true if Future terminated normally, false if Future terminated abnormally\n */"}
{"ID": 25, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> void drainMaxLoop(SimplePlainQueue<T> q, Subscriber<? super U> a, boolean delayError, Disposable dispose, QueueDrain<T, U> qd) { int missed = 1; for (;;) { for (;;) { boolean d = qd.done(); T v = q.poll(); boolean empty = v == null; if (checkTerminated(d, empty, a, delayError, q, qd)) { if (dispose != null) { dispose.dispose(); } return; } if (empty) { break; } long r = qd.requested(); if (r != 0L) { if (qd.accept(a, v)) { if (r != Long.MAX_VALUE) { qd.produced(1); } } } else { q.clear(); if (dispose != null) { dispose.dispose(); } a.onError(new MissingBackpressureException(\"Could not emit value due to lack of requests.\")); return; } } missed = qd.leave(-missed); if (missed == 0) { break; } } } \nResponse:", "ground_truth": "Drain the queue but give up with an error if there aren't enough requests.\n@param <T> the queue value type\n@param <U> the emission value type\n@param q the queue\n@param a the subscriber\n@param delayError true if errors should be delayed after all normal items\n@param dispose the disposable to call when termination happens and cleanup is necessary\n@param qd the QueueDrain instance that gives status information to the drain logic", "predict": " Doesn't permit nulls and doesn't delay errors. Doesn't support backpressure. Doesn't support cancellation. Doesn't support late emissions. Doesn't support blocking. Doesn't support blocking terminals. Doesn't support fusion. Doesn't support conditional fusion. Doesn't support non-fusion. Doesn't support late fusion. Doesn't support eager fusion. Doesn't support unbounded fusion. Doesn't support conditional unbounded fusion. Doesn't support eager unbounded fusion. Doesn't support bounded replay. Doesn't support unbounded replay. Doesn't support fusion of unbounded replay. Doesn't support conditional fusion of unbounded replay. Doesn't support eager fusion of unbounded replay. Doesn't support bounded replay. Doesn't support unbounded replay. Doesn't support fusion of bounded replay. Doesn't support conditional fusion of bounded replay. Doesn't support eager fusion of bounded replay. Doesn't support bounded replay. Doesn't support unbounded replay. Doesn't support fusion of bounded replay. Doesn't support conditional fusion of bounded replay. Doesn't support eager fusion of bounded replay. Doesn't support"}
{"ID": 26, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void request(Subscription s, int prefetch) { s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch); } \nResponse:", "ground_truth": "Requests Long.MAX_VALUE if prefetch is negative or the exact\namount if prefetch is positive.\n@param s the Subscription to request from\n@param prefetch the prefetch value", "predict": " Requests a specified number of messages from the subscription. Messages are delivered to the supplied MessageListener. Messages will be delivered no faster than the subscriber can process them. Therefore, fewer than the requested number of messages may be delivered. However, fewer messages will be delivered than requested. Therefore, it is possible for consumers to receive gaps in delivered messages. Suitable for fire-and-forget use. @param s Subscription to receive messages from. @param prefetch Maximum number of messages to receive. Negative values mean unlimited. Zero is treated as unlimited. Negative values are treated as unlimited."}
{"ID": 27, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> void postComplete(Subscriber<? super T> actual, Queue<T> queue, AtomicLong state, BooleanSupplier isCancelled) { if (queue.isEmpty()) { actual.onComplete(); return; } if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) { return; } for (; ; ) { long r = state.get(); if ((r & COMPLETED_MASK) != 0L) { return; } long u = r | COMPLETED_MASK; // (active, r) -> (complete, r) transition if (state.compareAndSet(r, u)) { // if the requested amount was non-zero, drain the queue if (r != 0L) { postCompleteDrain(u, actual, queue, state, isCancelled); } return; } } } \nResponse:", "ground_truth": "Signals the completion of the main sequence and switches to post-completion replay mode.\n\n<p>\nDon't modify the queue after calling this method!\n\n<p>\nPost-completion backpressure handles the case when a source produces values based on\nrequests when it is active but more values are available even after its completion.\nIn this case, the onComplete() can't just emit the contents of the queue but has to\ncoordinate with the requested amounts. This requires two distinct modes: active and\ncompleted. In active mode, requests flow through and the queue is not accessed but\nin completed mode, requests no-longer reach the upstream but help in draining the queue.\n<p>\nThe algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since\nrequest amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't\nallowed.\n\n@param <T> the value type emitted\n@param actual the target Subscriber to send events to\n@param queue the queue to drain if in the post-complete state\n@param state holds the request amount and the post-completed flag\n@param isCancelled a supplier that returns true if the drain has been cancelled", "predict": " Drains the queue to determine if termination has been signaled. Upon draining, the subscriber is notified of termination via onComplete unless termination has already been signaled. Upon draining, the subscriber is notified of cancellation via onError unless cancellation has already been signaled. Upon draining, the subscriber receives the terminal signal via onComplete unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onError unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onComplete unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onError unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onComplete unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onError unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onComplete unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives the terminal signal via onError unless termination or cancellation has signaled otherwise. Upon draining, the subscriber receives"}
{"ID": 28, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void complete(R n) { long p = produced; if (p != 0) { BackpressureHelper.produced(this, p); } for (;;) { long r = get(); if ((r & COMPLETE_MASK) != 0) { onDrop(n); return; } if ((r & REQUEST_MASK) != 0) { lazySet(COMPLETE_MASK + 1); downstream.onNext(n); downstream.onComplete(); return; } value = n; if (compareAndSet(0, COMPLETE_MASK)) { return; } value = null; } } \nResponse:", "ground_truth": "Signals the given value and an onComplete if the downstream is ready to receive the final value.\n@param n the value to emit", "predict": " Atomically decrements and propagates downstream requests up to upstream producers and downstream observers. @param n the amount of elements produced upstream @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)\n"}
{"ID": 29, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") @Nullable public T getValue() { Object o = value; if (o != null && !NotificationLite.isError(o)) { return (T)value; } return null; } \nResponse:", "ground_truth": "Returns the contained value if this notification is an onNext\nsignal, null otherwise.\n@return the value contained or null\n@see #isOnNext()", "predict": " Returns the value held by this NotificationLite. Unlike other ObservableSources, this doesn't do conversion. Instead, it allows nulls and Errors. @throws NullPointerException if the value is null and this NotificationLite wraps an ObservableSource that does not permit nulls. @throws NoSuchElementException if the value is null and this NotificationLite wraps an ObservableSource that emits no items. @return the value held by this NotificationLite.\n */"}
{"ID": 30, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Throwable getError() { Object o = value; if (NotificationLite.isError(o)) { return NotificationLite.getError(o); } return null; } \nResponse:", "ground_truth": "Returns the container Throwable error if this notification is an onError\nsignal, null otherwise.\n@return the Throwable error contained or null\n@see #isOnError()", "predict": " Access the terminal error if any or null otherwise. Unlike other methods it won't cause future emissions to the source Observable. @return the terminal Throwable or null if there wasn't one.\n*/"}
{"ID": 31, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Disposable upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.dispose(); if (upstream != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Disposable is null and returns true, otherwise\ndisposes the next Disposable and if the upstream is not the shared\ndisposed instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Disposable to check for nullness and dispose if necessary\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the upstream was non null", "predict": " Validates that the given upstream disposable is not disposed and next disposable is not disposed. If disposing happens, the upstream disposable is disposed. If disposing happens, the downstream disposable is disposed. If upstream disposable is disposed, downstream disposable is disposed. @param upstream disposable to validate. @param next disposable to validate. @param observer Observer to notify about errors. @return true if disposing happened, false otherwise.\n*/"}
{"ID": 32, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.dispose(); if (upstream.get() != DisposableHelper.DISPOSED) { reportDoubleSubscription(observer); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Disposable, otherwise disposes next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared disposed indicator.\n@param upstream the target AtomicReference to update\n@param next the Disposable to set on it atomically\n@param observer the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Disposable.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " Sets the disposable upstream to the next disposable. Unlike the other setNext methods, this doesn't swallow exceptions. Instead, they are propagated to the caller. However, if the upstream disposable is disposed, the downstream will receive a terminal event immediately. In this case, the upstream disposable will be disposed automatically.\n * @param upstream the upstream disposable to set\n * @param next the disposable to set as the next disposable\n * @param observer the observer to signal downstream\n * @return true if the upstream disposable was set, false otherwise\n */"}
{"ID": 33, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validate(Subscription upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (upstream != null) { next.cancel(); if (upstream != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Ensures that the upstream Subscription is null and returns true, otherwise\ncancels the next Subscription and if the upstream is not the shared\ncancelled instance, reports a ProtocolViolationException due to\nmultiple subscribe attempts.\n@param upstream the upstream current value\n@param next the Subscription to check for nullness and cancel if necessary\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the upstream was non null", "predict": " Validates that there are no subscriptions to the upstream and next Subscription. If there are subscriptions, they are cancelled. @param upstream the upstream Subscription. Can be null. @param next the next Subscription. Can be null. @param subscriber the Subscriber to validate. @return true if subscriptions were cancelled. False otherwise.\n*/"}
{"ID": 34, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) { next.cancel(); if (upstream.get() != SubscriptionHelper.CANCELLED) { reportDoubleSubscription(subscriber); } return false; } return true; } \nResponse:", "ground_truth": "Atomically updates the target upstream AtomicReference from null to the non-null\nnext Subscription, otherwise cancels next and reports a ProtocolViolationException\nif the AtomicReference doesn't contain the shared cancelled indicator.\n@param upstream the target AtomicReference to update\n@param next the Subscription to set on it atomically\n@param subscriber the class of the consumer to have a personalized\nerror message if the upstream already contains a non-cancelled Subscription.\n@return true if successful, false if the content of the AtomicReference was non null", "predict": " Atomically set a new subscriber-to-source if there is none or replace an old one. @param upstream the upstream disposable @param next the next subscriber-to-source to set @param subscriber the subscriber-to-source to set or null @return true if successful, false if the current subscriber-to-source is not null @see #replace(Subscription, Subscriber)\n */"}
{"ID": 35, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long addCap(long a, long b) { long u = a + b; if (u < 0L) { return Long.MAX_VALUE; } return u; } \nResponse:", "ground_truth": "Adds two long values and caps the sum at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the sum capped at Long.MAX_VALUE", "predict": " Addition with overflow detection. @param a The first operand. @param b The second operand. @return The sum of a and b. If overflow occurs, MAX_VALUE is returned."}
{"ID": 36, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long multiplyCap(long a, long b) { long u = a * b; if (((a | b) >>> 31) != 0) { if (u / a != b) { return Long.MAX_VALUE; } } return u; } \nResponse:", "ground_truth": "Multiplies two long values and caps the product at Long.MAX_VALUE.\n@param a the first value\n@param b the second value\n@return the product capped at Long.MAX_VALUE", "predict": " Multiply two numbers in the interval [Long.MIN_VALUE, Long.MAX_VALUE] and saturate the result to Long.MIN_VALUE or Long.MAX_VALUE. The saturation is carried out by reducing the magnitude of the upper 32 bits of the result to their greatest common divisor. The saturated multiplication overflows to Long.MAX_VALUE or Long.MIN_VALUE as appropriate. The division saturates to Long.MIN_VALUE or Long.MAX_VALUE as appropriate. @param a The first operand. @param b The second operand. @return The product of a and b saturated to Long.MIN_VALUE or Long.MAX_VALUE."}
{"ID": 37, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long add(AtomicLong requested, long n) { for (;;) { long r = requested.get(); if (r == Long.MAX_VALUE) { return Long.MAX_VALUE; } long u = addCap(r, n); if (requested.compareAndSet(r, u)) { return r; } } } \nResponse:", "ground_truth": "Atomically adds the positive value n to the requested value in the AtomicLong and\ncaps the result at Long.MAX_VALUE and returns the previous value.\n@param requested the AtomicLong holding the current requested value\n@param n the value to add, must be positive (not verified)\n@return the original value before the add", "predict": " Atomically adds n to the current value. Returns the previous value.\n"}
{"ID": 38, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static NullPointerException toNpe(Throwable ex) { NullPointerException npe = new NullPointerException(\"Actually not, but can't pass out an exception otherwise...\"); npe.initCause(ex); return npe; } \nResponse:", "ground_truth": "Creates a NullPointerException instance and sets the given Throwable as its initial cause.\n@param ex the Throwable instance to use as cause, not null (not verified)\n@return the created NullPointerException", "predict": " Convert a checked exception to a nasty looking NPE. Useful for wrapping checked exceptions in lambdas. @param ex The checked exception to convert @return A nasty looking NPE"}
{"ID": 39, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Object o) { // if no value yet, create the first array if (size == 0) { head = new Object[capacityHint + 1]; tail = head; head[0] = o; indexInTail = 1; size = 1; } else // if the tail is full, create a new tail and link if (indexInTail == capacityHint) { Object[] t = new Object[capacityHint + 1]; t[0] = o; tail[capacityHint] = t; tail = t; indexInTail = 1; size++; } else { tail[indexInTail] = o; indexInTail++; size++; } } \nResponse:", "ground_truth": "Adds a new element to this list.\n@param o the object to add, nulls are accepted", "predict": " Add an element to the queue. If the queue is empty, create a new array and link it to the head. Otherwise, link the tail to the new tail. Increases the size of the queue.\n*/"}
{"ID": 40, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void shutdown() { ScheduledExecutorService exec = PURGE_THREAD.getAndSet(null); if (exec != null) { exec.shutdownNow(); } POOLS.clear(); } \nResponse:", "ground_truth": "Stops the purge thread.", "predict": " Shutdowns the executor pools. Useful for forcing orderly shutdown when unforeseen issues arise."}
{"ID": 41, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec; } \nResponse:", "ground_truth": "Creates a ScheduledExecutorService with the given factory.\n@param factory the thread factory\n@return the ScheduledExecutorService", "predict": " Creates a ScheduledExecutorService with a single thread pool that uses the supplied ThreadFactory. The ThreadFactory must produce threads that are suitable for use by the ScheduledExecutorService. Most ThreadFactories produce threads that cannot keep up with scheduled tasks, so consider supplying one that produces threads that can keep up with scheduled tasks. @param factory The ThreadFactory to use. @return The ScheduledExecutorService.\n*/"}
{"ID": 42, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void setSubscription(Subscription s) { if (cancelled) { s.cancel(); return; } ObjectHelper.requireNonNull(s, \"s is null\"); if (get() == 0 && compareAndSet(0, 1)) { Subscription a = actual; if (a != null && cancelOnReplace) { a.cancel(); } actual = s; long r = requested; if (decrementAndGet() != 0) { drainLoop(); } if (r != 0L) { s.request(r); } return; } Subscription a = missedSubscription.getAndSet(s); if (a != null && cancelOnReplace) { a.cancel(); } drain(); } \nResponse:", "ground_truth": "Atomically sets a new subscription.\n@param s the subscription to set, not null (verified)", "predict": " Sets the current subscription. It does not matter if an old or new subscription is set. However, the old one must be cancelled, if the new subscription is not cancelled.\n */"}
{"ID": 43, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emitLoop() { for (;;) { AppendOnlyLinkedArrayList<Object> q; synchronized (this) { q = queue; if (q == null) { emitting = false; return; } queue = null; } q.forEachWhile(this); } } \nResponse:", "ground_truth": "Loops until all notifications in the queue has been processed.", "predict": " Drain queue and emit all buffered elements.\n*/"}
{"ID": 44, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RuntimeException wrapOrThrow(Throwable error) { if (error instanceof Error) { throw (Error)error; } if (error instanceof RuntimeException) { return (RuntimeException)error; } return new RuntimeException(error); } \nResponse:", "ground_truth": "If the provided Throwable is an Error this method\nthrows it, otherwise returns a RuntimeException wrapping the error\nif that error is a checked exception.\n@param error the error to wrap or throw\n@return the (wrapped) error", "predict": " Wrap the given error into a RuntimeException if it isn't already. Otherwise, return it unchanged. Useful for propagating errors up through APIs that don't accept a throwable. @param error The error to wrap. @return The error, wrapped into a RuntimeException if necessary."}
{"ID": 45, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Throwable> flatten(Throwable t) { List<Throwable> list = new ArrayList<Throwable>(); ArrayDeque<Throwable> deque = new ArrayDeque<Throwable>(); deque.offer(t); while (!deque.isEmpty()) { Throwable e = deque.removeFirst(); if (e instanceof CompositeException) { CompositeException ce = (CompositeException) e; List<Throwable> exceptions = ce.getExceptions(); for (int i = exceptions.size() - 1; i >= 0; i--) { deque.offerFirst(exceptions.get(i)); } } else { list.add(e); } } return list; } \nResponse:", "ground_truth": "Returns a flattened list of Throwables from tree-like CompositeException chain.\n@param t the starting throwable\n@return the list of Throwables flattened in a depth-first manner", "predict": " Flatten nested exceptions. Inspired by discussions on the mailing list, and StackOverflow. Thanks to Dmitriy Kopylenko. @param t The Throwable to examine. @return The flattened list of Throwables. The returned list will be empty if t is null or if it contains no exceptions."}
{"ID": 46, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <E extends Throwable> Exception throwIfThrowable(Throwable e) throws E { if (e instanceof Exception) { return (Exception)e; } throw (E)e; } \nResponse:", "ground_truth": "Workaround for Java 6 not supporting throwing a final Throwable from a catch block.\n@param <E> the generic exception type\n@param e the Throwable error to return or throw\n@return the Throwable e if it is a subclass of Exception\n@throws E the generic exception thrown", "predict": " Throw an exception if the argument is an instance of Throwable, wrapping it in a RuntimeException. Otherwise, simply return the argument. @param e The Throwable to test. @return Whatever was passed in.\n*/"}
{"ID": 47, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void clear() { if (disposed) { return; } OpenHashSet<Disposable> set; synchronized (this) { if (disposed) { return; } set = resources; resources = null; } dispose(set); } \nResponse:", "ground_truth": "Atomically clears the container, then disposes all the previously contained Disposables.", "predict": " Clears the disposable pool. After this method is called, disposing of disposable resources is no longer possible. Resources that were disposed previously can be reused again.\n*/"}
{"ID": 48, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int size() { if (disposed) { return 0; } synchronized (this) { if (disposed) { return 0; } OpenHashSet<Disposable> set = resources; return set != null ? set.size() : 0; } } \nResponse:", "ground_truth": "Returns the number of currently held Disposables.\n@return the number of currently held Disposables", "predict": " Returns the number of currently held resources.\n<p>Note that disposing a resource has no effect on its count.\n */"}
{"ID": 49, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T, R> boolean tryScalarXMapSubscribe(ObservableSource<T> source, Observer<? super R> observer, Function<? super T, ? extends ObservableSource<? extends R>> mapper) { if (source instanceof Callable) { T t; try { t = ((Callable<T>)source).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (t == null) { EmptyDisposable.complete(observer); return true; } ObservableSource<? extends R> r; try { r = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (r instanceof Callable) { R u; try { u = ((Callable<R>)r).call(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return true; } if (u == null) { EmptyDisposable.complete(observer); return true; } ScalarDisposable<R> sd = new ScalarDisposable<R>(observer, u); observer.onSubscribe(sd); sd.run(); } else { r.subscribe(observer); } return true; } return false; } \nResponse:", "ground_truth": "Tries to subscribe to a possibly Callable source's mapped ObservableSource.\n@param <T> the input value type\n@param <R> the output value type\n@param source the source ObservableSource\n@param observer the subscriber\n@param mapper the function mapping a scalar value into an ObservableSource\n@return true if successful, false if the caller should continue with the regular path.", "predict": " Rx Design Guidelines 5.2"}
{"ID": 50, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T, U> Observable<U> scalarXMap(T value, Function<? super T, ? extends ObservableSource<? extends U>> mapper) { return RxJavaPlugins.onAssembly(new ScalarXMapObservable<T, U>(value, mapper)); } \nResponse:", "ground_truth": "Maps a scalar value into an Observable and emits its values.\n\n@param <T> the scalar value type\n@param <U> the output value type\n@param value the scalar value to map\n@param mapper the function that gets the scalar value and should return\nan ObservableSource that gets streamed\n@return the new Observable instance", "predict": " Scalar flatMap for lifting an ObservableSource acting as a mapper to Observables. @param <T> the value type\n @param <U> the output type\n @param mapper the mapper function to be applied to the source value @return the new Observable instance\n */"}
{"ID": 51, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Subscriber<? super U> subscriber) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, subscriber)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Subscriber method.\n\n@param <U> the target type\n@param subscriber the subscriber to emit the events to\n@return true if a terminal event has been reached", "predict": " Drain all buffered subscribers and return true if any subscriber accept the value.\n */ @SuppressWarnings(\"unchecked\")\npublic final boolean drainBufferedSubscribers() {\n    Object[] a = head;\n    final int c = capacity;\n    while (a!= null) {\n        for (int i = 0; i < c; i++) {\n            Object o = a[i];\n            if (o == null) {\n                break;\n            }\n            if (NotificationLite.acceptFull(o, this)) {\n                clear();\n                return true;\n            }\n        }\n        a = (Object[])a[c];\n    }\n    return false;\n}\n}\n"}
{"ID": 52, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <U> boolean accept(Observer<? super U> observer) { Object[] a = head; final int c = capacity; while (a != null) { for (int i = 0; i < c; i++) { Object o = a[i]; if (o == null) { break; } if (NotificationLite.acceptFull(o, observer)) { return true; } } a = (Object[])a[c]; } return false; } \nResponse:", "ground_truth": "Interprets the contents as NotificationLite objects and calls\nthe appropriate Observer method.\n\n@param <U> the target type\n@param observer the observer to emit the events to\n@return true if a terminal event has been reached", "predict": " Accepts notification if all inner observers have finished emitting items. Returns false if the emission has not completed. Upon false emission, the observer is guaranteed to be removed from the list of observers. Although the emission has not necessarily completed, observers may receive items after the emission completes. @param observer Observer to add. May not be null. @return True if the observer was added, false if the observer was not added because it was already in the list. Upon false emission, the observer is guaranteed to be removed from the list of observers. Although the emission has not necessarily completed, observers may receive items after the emission completes."}
{"ID": 53, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses a fixed buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " Starts the emission of notifications from upstream. Upon termination of this method, no further emissions will occur unless the subscribe() method is invoked again.\n */"}
{"ID": 54, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startUnbounded() { if (SubscriptionHelper.setOnce(upstream, EmptySubscription.INSTANCE)) { queue = new SpscLinkedArrayQueue<T>(bufferSize); } } \nResponse:", "ground_truth": "Initializes this Processor by setting an upstream Subscription that\nignores request amounts, uses an unbounded buffer\nand allows using the onXXX and offer methods\nafterwards.", "predict": " Starts unbounded replay"}
{"ID": 55, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean offer(T t) { if (once.get()) { return false; } ObjectHelper.requireNonNull(t, \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (fusionMode == QueueSubscription.NONE) { if (queue.offer(t)) { drain(); return true; } } return false; } \nResponse:", "ground_truth": "Tries to offer an item into the internal queue and returns false\nif the queue is full.\n@param t the item to offer, not null\n@return true if successful, false if the queue is full", "predict": " Offer a new item to the queue. If the queue is full, this method will return false.\n * @param t the item to add\n * @return true if the item was accepted, false otherwise\n */"}
{"ID": 56, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Nullable public Disposable get() { Disposable d = resource.get(); if (d == DisposableHelper.DISPOSED) { return Disposables.disposed(); } return d; } \nResponse:", "ground_truth": "Returns the currently contained Disposable or null if this container is empty.\n@return the current Disposable, may be null", "predict": " Returns the disposable wrapping the resource held by this Single. If the resource has not yet been set, it will be eager.\n@NonNull @Override public final Disposable get() { return resource.get(); }\n"}
{"ID": 57, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete(T value) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } Observer<? super T> a = downstream; if (state == FUSED_EMPTY) { this.value = value; lazySet(FUSED_READY); a.onNext(null); } else { lazySet(TERMINATED); a.onNext(value); } if (get() != DISPOSED) { a.onComplete(); } } \nResponse:", "ground_truth": "Complete the target with a single value or indicate there is a value available in\nfusion mode.\n@param value the value to signal, not null (not verified)", "predict": " Terminate the fusion mode and deliver the terminal event downstream.\n */ @SuppressWarnings(\"unchecked\")\npublic final void complete(T value) {\n    Objects.requireNonNull(value, \"value is null\");\n    int state = get();\n    if ((state & FUSED_READY)!= 0) {\n        lazySet(TERMINATED);\n        downstream.onNext((T)value);\n        if (state!= TERMINATED) {\n            downstream.onComplete();\n        }\n    } else if (state == FUSED_EMPTY) {\n        lazySet(TERMINATED);\n        downstream.onNext((T)value);\n        downstream.onComplete();\n    } else {\n        lazySet(TERMINATED);\n        downstream.onNext(value);\n        downstream.onComplete();\n    }\n}\n"}
{"ID": 58, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void error(Throwable t) { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { RxJavaPlugins.onError(t); return; } lazySet(TERMINATED); downstream.onError(t); } \nResponse:", "ground_truth": "Complete the target with an error signal.\n@param t the Throwable to signal, not null (not verified)", "predict": " Subscriber method called by the upstream producer.\n@param t the exception encountered by the producer\n */"}
{"ID": 59, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void complete() { int state = get(); if ((state & (FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED)) != 0) { return; } lazySet(TERMINATED); downstream.onComplete(); } \nResponse:", "ground_truth": "Complete the target without any value.", "predict": " Terminal operation notification. Subsequent {@code onSuccess} calls are ignored because it is impossible to recover cumulative effect. Unlike {@link #tryTerminate}, unconditional invocation here does not imply fusion suppression.\n */ ghost wolfram @Pure @Override public final void complete() {\n    if ((get() & FUSED_MASK) == FUSED_MASK) {\n        return; // fusion mode prevented completion\n    }\n    int state = get();\n    if ((state & TERMINATED)!= 0) {\n        return; // terminated\n    }\n    if ((state & FUSED_MASK) == FUSED_MASK) {\n        return; // fusion mode prevented completion\n    }\n    if ((state & FUSED_READY)!= 0) {\n        return; // fusion mode prevented completion\n    }\n    if ((state & FUSED_CONSUMED)!= 0) {\n        return; // fusion mode prevented completion\n    }"}
{"ID": 60, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper) { return concatMapDelayError(mapper, 2, true); } \nResponse:", "ground_truth": "Maps each of the items into a Publisher, subscribes to them one after the other,\none at a time and emits their values in order\nwhile delaying any error from either this or any of the inner Publishers\ntill all of them terminate.\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor\nbackpressure, that <em>may</em> throw an {@code IllegalStateException} when that\n{@code Publisher} completes.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <R> the result value type\n@param mapper the function that maps the items of this Publisher into the inner Publishers.\n@return the new Publisher instance with the concatenation behavior", "predict": " Maps each emitted item into a Publisher, subscribes to them one after the other and delays any errors till the all inner Publishers terminate.\nAll errors of the first inner Publisher are delayed till the Publisher returned by the function emits an item.\nThe resulting Publisher behaves like a zipped sequence of the Publishers returned by applying the function to the emitted items of the source Publisher.\nWhen this Publisher reaches its end, the currently delayed Publishers are unsubscribed.\nThe upstream is unbounded. @param mapper the function that maps a source item into a Publisher of results\n @return the new Publisher\n*/"}
{"ID": 61, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final <U> Flowable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) { return concatMapIterable(mapper, 2); } \nResponse:", "ground_truth": "Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an\nIterable corresponding to that item that is generated by a selector.\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream. The source {@code Publisher}s is\nexpected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will\nsignal a {@code MissingBackpressureException}.</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param <U>\nthe type of item emitted by the resulting Publisher\n@param mapper\na function that returns an Iterable sequence of values for when given an item emitted by the\nsource Publisher\n@return a Flowable that emits the results of concatenating the items emitted by the source Publisher with\nthe values in the Iterables corresponding to those items, as generated by {@code collectionSelector}\n@see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX operators documentation: FlatMap</a>", "predict": " Maps each element of the upstream Flowable into an Iterable and subscribes to each of these iterables in sequence, one after the other. Each item emitted by the upstream will be emitted by the downstream as a separate item.\n<p>History: 2.2.7 - experimental\n<dl>\n  <dt><b>Backpressure Support:</b></dt>\n  <dd>This operator honors backpressure.</td>\n  <dt><b>Scheduler:</b></dt>\n  <dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n @param <U> the result type of the inner Observables and the output type of the result Flowable\n @param mapper a function that returns an Iterable sequence of values for when given an item emitted by the source Observable\n @return an Observable that emits the results of applying the transformation function to each item emitted by the source Observable"}
{"ID": 62, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @CheckReturnValue @NonNull @BackpressureSupport(BackpressureKind.FULL) @SchedulerSupport(SchedulerSupport.NONE) public final Flowable<T> sorted(Comparator<? super T> sortFunction) { ObjectHelper.requireNonNull(sortFunction, \"sortFunction\"); return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.<List<T>>identity()); } \nResponse:", "ground_truth": "Returns a Flowable that emits the events emitted by source Publisher, in a\nsorted order based on a specified comparison function.\n\n<p>Note that calling {@code sorted} with long, non-terminating or infinite sources\nmight cause {@link OutOfMemoryError}\n\n<dl>\n<dt><b>Backpressure:</b></dt>\n<dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an\nunbounded manner (i.e., without applying backpressure to it).</dd>\n<dt><b>Scheduler:</b></dt>\n<dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.</dd>\n</dl>\n\n@param sortFunction\na function that compares two items emitted by the source Publisher and returns an Integer\nthat indicates their sort order\n@return a Flowable that emits the items emitted by the source Publisher in sorted order", "predict": " Returns a Publisher sorted by the keys generated by the specified {@code keySelector}. Each item emitted by this Publisher takes the form of a List containing its current key and value. The emitted List is sorted by the Comparator imposed by the provided {@code sortFunction}. <p>Example:\n * <pre><code> Flowable.range(1, 10).flatMap(new Function&lt;Integer, Publisher&lt;List&lt;Integer&gt;&gt;() {\n *     &#64;Override\n *     public Publisher&lt;List&lt;Integer&gt;&gt; apply(Integer i) {\n *         return Flowable.just(Tuples.of(i, i)).sorted(Comparator.naturalOrder());\n *     }\n * }) // ParallelFlowableOrdered of (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8,"}
{"ID": 63, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PerfAsyncConsumer await(int count) { if (count <= 1000) { while (getCount() != 0) { } } else { try { await(); } catch (InterruptedException ex) { throw new RuntimeException(ex); } } return this; } \nResponse:", "ground_truth": "Wait for the terminal signal.\n@param count if less than 1001, a spin-wait is used\n@return this", "predict": " Await completion of all outstanding exchanges. Useful for testing scenarios where you want to await completion of exchanges before the test exits. @param count Number of exchanges to await before terminating @return this async consumer\n */"}
{"ID": 64, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void request(long n) { Subscription s = this.upstream; if (s != null) { s.request(n); } } \nResponse:", "ground_truth": "Requests from the upstream Subscription.\n@param n the request amount, positive", "predict": " Requests up to n notifications without consuming them. Unlike other methods, cancellation barriers are propagated to the downstream Subscription rather than being applied locally.\n */ ghost var Subscription s = this.upstream; // Subscription to replenish upon request but propagate cancellation barriers downstream"}
{"ID": 65, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: boolean add(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int n = a.length; @SuppressWarnings(\"unchecked\") PublishDisposable<T>[] b = new PublishDisposable[n + 1]; System.arraycopy(a, 0, b, 0, n); b[n] = ps; if (subscribers.compareAndSet(a, b)) { return true; } } } \nResponse:", "ground_truth": "Tries to add the given subscriber to the subscribers array atomically\nor returns false if the subject has terminated.\n@param ps the subscriber to add\n@return true if successful, false if the subject has terminated", "predict": " Adds a PublishSubscriber to the subscribers array atomically. Upon successful addition, the subscriber's onStart method is called (if subscribed). The new subscriber is set to be the last in the subscribers array. @param ps The subscriber to add.\n@return True if the subscriber was added, false if the subscriber was rejected because all subscribers were subscribed.\n*/"}
{"ID": 66, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") void remove(PublishDisposable<T> ps) { for (;;) { PublishDisposable<T>[] a = subscribers.get(); if (a == TERMINATED || a == EMPTY) { return; } int n = a.length; int j = -1; for (int i = 0; i < n; i++) { if (a[i] == ps) { j = i; break; } } if (j < 0) { return; } PublishDisposable<T>[] b; if (n == 1) { b = EMPTY; } else { b = new PublishDisposable[n - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, n - j - 1); } if (subscribers.compareAndSet(a, b)) { return; } } } \nResponse:", "ground_truth": "Atomically removes the given subscriber if it is subscribed to the subject.\n@param ps the subject to remove", "predict": " Removes a PublishSubscriber from the subscribers array atomically."}
{"ID": 67, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> cf, final Scheduler scheduler) { final Flowable<T> flowable = cf.observeOn(scheduler); return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(cf, flowable)); } \nResponse:", "ground_truth": "Child Subscribers will observe the events of the ConnectableObservable on the\nspecified scheduler.\n@param <T> the value type\n@param cf the ConnectableFlowable to wrap\n@param scheduler the target scheduler\n@return the new ConnectableObservable instance", "predict": " Returns a ConnectableFlowable that emits the emissions of this ConnectableFlowable followed by the emissions of the other Flowable. @param other the other Flowable that will be subscribed after emissions from this ConnectableFlowable. @param scheduler Scheduler to run the subscription on. @return the new ConnectableFlowable\n     */ @SuppressWarnings(\"unchecked\")\n    @CheckReturnValue\n    public final ConnectableFlowable<T> observeOn(Flowable<? extends T> other, Scheduler scheduler) {\n        ObjectHelper.requireNonNull(other, \"other is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n        return RxJavaPlugins.onAssembly(new ConnectableFlowableReplay<T>(this, other, scheduler));\n    }\n\n    /**\n     * Returns a ConnectableFlowable that upon connection causes the buffered items in the source Publisher to be emitted to downstream subscribers. Upon cancellation of either Publisher"}
{"ID": 68, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) { Type[] parameterTypes = method.getGenericParameterTypes(); Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) { // Unwrap the actual body type from Response<T>. responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); } else { adapterType = method.getGenericReturnType(); } CallAdapter<ResponseT, ReturnT> callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); if (responseType == okhttp3.Response.class) { throw methodError(method, \"'\" + getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); } if (responseType == Response.class) { throw methodError(method, \"Response must include generic type (e.g., Response<String>)\"); } // TODO support Unit for Kotlin? if (requestFactory.httpMethod.equals(\"HEAD\") && !Void.class.equals(responseType)) { throw methodError(method, \"HEAD method must use Void as response type.\"); } Converter<ResponseBody, ResponseT> responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; if (!isKotlinSuspendFunction) { return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter); } else if (continuationWantsResponse) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter); } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory, callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter, continuationBodyNullable); } } \nResponse:", "ground_truth": "Inspects the annotations on an interface method to construct a reusable service method that\nspeaks HTTP. This requires potentially-expensive reflection so it is best to build each service\nmethod only once and reuse it.", "predict": " Parses method annotations and collects information about the HTTP request body. May be null if no such information is available."}
{"ID": 69, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDelay(long amount, TimeUnit unit) { if (amount < 0) { throw new IllegalArgumentException(\"Amount must be positive value.\"); } this.delayMs = unit.toMillis(amount); } \nResponse:", "ground_truth": "Set the network round trip delay.", "predict": " Sets the amount of delay between polls. Default is 1000 milliseconds. @param amount Delay amount expressed in milliseconds. Must be positive. @param unit Delay amount unit. Must be milliseconds.\n*/"}
{"ID": 70, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response<?> createErrorResponse() { Response<?> call; try { call = errorFactory.call(); } catch (Exception e) { throw new IllegalStateException(\"Error factory threw an exception.\", e); } if (call == null) { throw new IllegalStateException(\"Error factory returned null.\"); } if (call.isSuccessful()) { throw new IllegalStateException(\"Error factory returned successful response.\"); } return call; } \nResponse:", "ground_truth": "The HTTP error to be used when an error is triggered.", "predict": " Creates an error response. @return The error response."}
{"ID": 71, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long calculateDelay(TimeUnit unit) { float delta = variancePercent / 100f; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta; // 0.2f --> 0.8f float upperBound = 1f + delta; // 0.2f --> 1.2f float bound = upperBound - lowerBound; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + (random.nextFloat() * bound); // 0.8 + (rnd * 0.4) long callDelayMs = (long) (delayMs * delayPercent); return MILLISECONDS.convert(callDelayMs, unit); } \nResponse:", "ground_truth": "Get the delay that should be used for delaying a response in accordance with configured\nbehavior.", "predict": " Calculates the delay for throttling decisions. The delay varies randomly between floor and ceiling multiplied by variancePercent. Floor and ceiling are chosen to bound the delay so that excessively aggressive throttling leads to excessive redelivery while overly conservative throttling does not lead to excessive redelivery. Conversely, overly aggressive throttling leads to excessive CPU consumption while overly conservative throttling does not lead to excessive CPU consumption. Choosing floor and ceiling too large or too small can lead to excessive redelivery without bound. Choosing these values too conservatively may result in excessive CPU consumption without bound. Choosing these values too aggressively can lead to excessive redelivery without bound. However, overly aggressive throttling leads to excessive CPU consumption, while overly conservative throttling does not lead to excessive CPU consumption. Therefore, it is advisable to choose floor and ceiling conservatively. Choosing floor excessively conservatively leads to excessive CPU consumption, whereas choosing ceiling excessively aggressively leads to excessive redelivery. Conversely, choosing ceiling excessively conservatively leads to excessive CPU consumption, whereas choosing floor excessively aggressively leads to excessive"}
{"ID": 72, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createSampleData(String username, String password) { Assert.notNull(documentDao, \"DocumentDao required\"); Assert.hasText(username, \"Username required\"); Authentication auth = new UsernamePasswordAuthenticationToken(username, password); try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder.getContext().setAuthentication(auth); // Create the home directory first Directory home = new Directory(username, Directory.ROOT_DIRECTORY); documentDao.create(home); addPermission(documentDao, home, username, LEVEL_GRANT_ADMIN); addPermission(documentDao, home, \"ROLE_USER\", LEVEL_GRANT_READ); createFiles(documentDao, home); // Now create the confidential directory Directory confid = new Directory(\"confidential\", home); documentDao.create(confid); addPermission(documentDao, confid, \"ROLE_USER\", LEVEL_NEGATE_READ); createFiles(documentDao, confid); // Now create the shared directory Directory shared = new Directory(\"shared\", home); documentDao.create(shared); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_READ); addPermission(documentDao, shared, \"ROLE_USER\", LEVEL_GRANT_WRITE); createFiles(documentDao, shared); } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder.clearContext(); } } \nResponse:", "ground_truth": "Creates a directory for the user, and a series of sub-directories. The root\ndirectory is the parent for the user directory. The sub-directories are\n\"confidential\" and \"shared\". The ROLE_USER will be given read and write access to\n\"shared\".", "predict": " Create sample data for testing purposes. @param username Username of the user creating the home directory and files. @param password Password of the user creating the home directory and files."}
{"ID": 73, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HttpMethod valueOf(String method) { try { return HttpMethod.valueOf(method); } catch (IllegalArgumentException e) { } return null; } \nResponse:", "ground_truth": "Provides a save way of obtaining the HttpMethod from a String. If the method is\ninvalid, returns null.\n\n@param method the HTTP method to use.\n\n@return the HttpMethod or null if method is invalid.", "predict": " Parses the HTTP method string and returns the corresponding HttpMethod enum value. Returns null if the HTTP method string is null or cannot be parsed. @param method HTTP method string @return HttpMethod enum value"}
{"ID": 74, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public DirContextOperations searchForUser(String username) { if (logger.isDebugEnabled()) { logger.debug(\"Searching for user '\" + username + \"', with user search \" + this); } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate( contextSource); template.setSearchControls(searchControls); try { return template.searchForSingleEntry(searchBase, searchFilter, new String[] { username }); } catch (IncorrectResultSizeDataAccessException notFound) { if (notFound.getActualSize() == 0) { throw new UsernameNotFoundException(\"User \" + username + \" not found in directory.\"); } // Search should never return multiple results if properly configured, so just // rethrow throw notFound; } } \nResponse:", "ground_truth": "Return the LdapUserDetails containing the user's information\n\n@param username the username to search for.\n\n@return An LdapUserDetails object containing the details of the located user's\ndirectory entry\n\n@throws UsernameNotFoundException if no matching entry is found.", "predict": " Searches for the LDAP entry for the supplied username. The DN of the entry found is returned as the username. If no entry is found, an LDAP NoSuchObjectResultException is raised. If more than one entry is found, an LDAP MultipleResultsException is raised. If no username can be found, an LDAP UsernameNotFoundException is raised. @param username the username to search for. Typically, this will be a String representation of an DN @return the username found, or null if none found.\n */"}
{"ID": 75, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(CharSequence rawPassword) { String salt = PREFIX + this.saltGenerator.generateKey() + SUFFIX; return digest(salt, rawPassword); } \nResponse:", "ground_truth": "Encodes the rawPass using a MessageDigest. If a salt is specified it will be merged\nwith the password before encoding.\n\n@param rawPassword The plain text password\n@return Hex string of password digest (or base64 encoded string if\nencodeHashAsBase64 is enabled.", "predict": " Encodes the raw password using the BCrypt scheme. @param rawPassword The plaintext password to encode. @return The encoded password.\n*/"}
{"ID": 76, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matches(CharSequence rawPassword, String encodedPassword) { String salt = extractSalt(encodedPassword); String rawPasswordEncoded = digest(salt, rawPassword); return PasswordEncoderUtils.equals(encodedPassword.toString(), rawPasswordEncoded); } \nResponse:", "ground_truth": "Takes a previously encoded password and compares it with a rawpassword after mixing\nin the salt and encoding that value\n\n@param rawPassword plain text password\n@param encodedPassword previously encoded password\n@return true or false", "predict": " Determines whether a plaintext password matches a hashed one. @param rawPassword plaintext password @param encodedPassword hashed password @return true if the passwords match, false otherwise"}
{"ID": 77, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void performVersionChecks(String minSpringVersion) { if (minSpringVersion == null) { return; } // Check Spring Compatibility String springVersion = SpringVersion.getVersion(); String version = getVersion(); if (disableChecks(springVersion, version)) { return; } logger.info(\"You are running with Spring Security Core \" + version); if (new ComparableVersion(springVersion) .compareTo(new ComparableVersion(minSpringVersion)) < 0) { logger.warn(\"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion); } } \nResponse:", "ground_truth": "Perform version checks with specific min Spring Version\n\n@param minSpringVersion", "predict": " Perform version compatibility checks. Will issue a warning if incompatibility is detected."}
{"ID": 78, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean disableChecks(String springVersion, String springSecurityVersion) { if (springVersion == null || springVersion.equals(springSecurityVersion)) { return true; } return Boolean.getBoolean(DISABLE_CHECKS); } \nResponse:", "ground_truth": "Disable if springVersion and springSecurityVersion are the same to allow working\nwith Uber Jars.\n\n@param springVersion\n@param springSecurityVersion\n@return", "predict": " Disable Spring Security checks for the current Spring Framework version. Useful for IDE integration. @param springVersion Spring Framework version @param springSecurityVersion Spring Security version @return True if checks should be disabled\n */"}
{"ID": 79, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSpringVersion() { Properties properties = new Properties(); try { properties.load(SpringSecurityCoreVersion.class.getClassLoader().getResourceAsStream(\"META-INF/spring-security.versions\")); } catch (IOException | NullPointerException e) { return null; } return properties.getProperty(\"org.springframework:spring-core\"); } \nResponse:", "ground_truth": "Loads the spring version or null if it cannot be found.\n@return", "predict": " Get the Spring Security version. @return The Spring Security version or null if it cannot be determined."}
{"ID": 80, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AttributeExchangeConfigurer attributeExchange(String identifierPattern) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer( identifierPattern); this.attributeExchangeConfigurers.add(attributeExchangeConfigurer); return attributeExchangeConfigurer; } \nResponse:", "ground_truth": "Sets up OpenID attribute exchange for OpenID's matching the specified pattern.\n\n@param identifierPattern the regular expression for matching on OpenID's (i.e.\n\"https://www.google.com/.*\", \".*yahoo.com.*\", etc)\n@return a {@link AttributeExchangeConfigurer} for further customizations of the\nattribute exchange", "predict": " Allows you to add an Attribute Exchange configurer. The identifierPattern is how the exchange interacts with the repository. @param identifierPattern The identifierPattern to identify how the exchange interacts with the repository. @return The AttributeExchangeConfigurer that was just added.\n */"}
{"ID": 81, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ClientConfigurer<HttpSecurity> oauth2Client() throws Exception { OAuth2ClientConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ClientConfigurer<>()); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Client support.\n\n@since 5.1\n@see <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc6749#section-1.1\">OAuth 2.0 Authorization Framework</a>\n@return the {@link OAuth2ClientConfigurer} for further customizations\n@throws Exception", "predict": " Allows registering an instance of OAuth2ClientConfigurer instead of a lambda expression when configuring OAuth2Client. This method is analogous to Springs DominoControllerSupport::handlebarsTemplateEngine. @return the {@link OAuth2ClientConfigurer} for further customizations.\n */"}
{"ID": 82, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public OAuth2ResourceServerConfigurer<HttpSecurity> oauth2ResourceServer() throws Exception { OAuth2ResourceServerConfigurer<HttpSecurity> configurer = getOrApply(new OAuth2ResourceServerConfigurer<>(getContext())); this.postProcess(configurer); return configurer; } \nResponse:", "ground_truth": "Configures OAuth 2.0 Resource Server support.\n\n@since 5.1\n@see <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc6749#section-1.1\">OAuth 2.0 Authorization Framework</a>\n@return the {@link OAuth2ResourceServerConfigurer} for further customizations\n@throws Exception", "predict": " Allows customization of the access token issued by this component. Often times access tokens are issued to resource owners rather than relying parties. Therefore, you can use this component to revoke tokens issued to resource owners rather than relying parties. The default revokeAtTokenUsage value is false, allowing tokens to be revoked at any time. Setting revokeAtTokenUsage to true revokes tokens issued to resource owners rather than relying parties. @return the {@link OAuth2ResourceServerConfigurer} for further customization of the OAuth2SecurityConfigurerAdapter. @throws Exception\n*/"}
{"ID": 83, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelSecurityConfigurer<HttpSecurity>.ChannelRequestMatcherRegistry requiresChannel() throws Exception { ApplicationContext context = getContext(); return getOrApply(new ChannelSecurityConfigurer<>(context)) .getRegistry(); } \nResponse:", "ground_truth": "Configures channel security. In order for this configuration to be useful at least\none mapping to a required channel must be provided.\n\n<h2>Example Configuration</h2>\n\nThe example below demonstrates how to require HTTPs for every request. Only\nrequiring HTTPS for some requests is supported, but not recommended since an\napplication that allows for HTTP introduces many security vulnerabilities. For one\nsuch example, read about <a\nhref=\"https://en.wikipedia.org/wiki/Firesheep\">Firesheep</a>.\n\n<pre>\n&#064;Configuration\n&#064;EnableWebSecurity\npublic class ChannelSecurityConfig extends WebSecurityConfigurerAdapter {\n\n&#064;Override\nprotected void configure(HttpSecurity http) throws Exception {\nhttp.authorizeRequests().antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;).and().formLogin()\n.and().requiresChannel().anyRequest().requiresSecure();\n}\n\n&#064;Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\nauth.inMemoryAuthentication().withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;);\n}\n}\n</pre>\n\n\n@return the {@link ChannelSecurityConfigurer} for further customizations\n@throws Exception", "predict": " Allows securing one or more channels. Typically used in combination with @annotationDrivenSecurity. @return the ChannelSecurityConfigurerRegistry\n@since 4.0\n */"}
{"ID": 84, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean compare(final String dn, final String attributeName, final Object value) { final String comparisonFilter = \"(\" + attributeName + \"={0})\"; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext(DirContext ctx) throws NamingException { SearchControls ctls = new SearchControls(); ctls.setReturningAttributes(NO_ATTRS); ctls.setSearchScope(SearchControls.OBJECT_SCOPE); NamingEnumeration<SearchResult> results = ctx.search(dn, comparisonFilter, new Object[] { value }, ctls); Boolean match = Boolean.valueOf(results.hasMore()); LdapUtils.closeEnumeration(results); return match; } } Boolean matches = (Boolean) executeReadOnly(new LdapCompareCallback()); return matches.booleanValue(); } \nResponse:", "ground_truth": "Performs an LDAP compare operation of the value of an attribute for a particular\ndirectory entry.\n\n@param dn the entry who's attribute is to be used\n@param attributeName the attribute who's value we want to compare\n@param value the value to be checked against the directory value\n\n@return true if the supplied value matches that in the directory", "predict": " Perform a comparison bind anonymously against the directory. Useful for determining if a DN exists without revealing passwords. @param dn The DN to authenticate against. @param attributeName The attribute to compare. @param value The value to compare. @return True if the DN exists in the directory, false otherwise."}
{"ID": 85, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirContextOperations retrieveEntry(final String dn, final String[] attributesToRetrieve) { return (DirContextOperations) executeReadOnly(new ContextExecutor() { public Object executeWithContext(DirContext ctx) throws NamingException { Attributes attrs = ctx.getAttributes(dn, attributesToRetrieve); // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter(attrs, new DistinguishedName(dn), new DistinguishedName(ctx.getNameInNamespace())); } }); } \nResponse:", "ground_truth": "Composes an object from the attributes of the given DN.\n\n@param dn the directory entry which will be read\n@param attributesToRetrieve the named attributes which will be retrieved from the\ndirectory entry.\n\n@return the object created by the mapper", "predict": " Retrieve an entry from the LDAP. @param dn The DN of the entry to retrieve. @param attributesToRetrieve The attributes to retrieve. @return The retrieved entry.\n*/"}
{"ID": 86, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<String> searchForSingleAttributeValues(final String base, final String filter, final Object[] params, final String attributeName) { String[] attributeNames = new String[] { attributeName }; Set<Map<String, List<String>>> multipleAttributeValues = searchForMultipleAttributeValues( base, filter, params, attributeNames); Set<String> result = new HashSet<>(); for (Map<String, List<String>> map : multipleAttributeValues) { List<String> values = map.get(attributeName); if (values != null) { result.addAll(values); } } return result; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the union of the values of\nthe named attribute found in all entries matched by the search. Note that one\ndirectory entry may have several values for the attribute. Intended for role\nsearches and similar scenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeName the attribute who's values are to be retrieved.\n\n@return the set of String values for the attribute as a union of the values found\nin all the matching entries.", "predict": " Searches for all values of a certain attribute in the LDAP directory. The search filter is formulated according to RFC 2254. @param base The DN of the base entry to search in. @param filter The LDAP search filter. @param params The parameters to substitute in the search filter. @param attributeName The attribute name to search for. @return A set of all values found. Never <code>null</code>."}
{"ID": 87, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<Map<String, List<String>>> searchForMultipleAttributeValues( final String base, final String filter, final Object[] params, final String[] attributeNames) { // Escape the params acording to RFC2254 Object[] encodedParams = new String[params.length]; for (int i = 0; i < params.length; i++) { encodedParams[i] = LdapEncoder.filterEncode(params[i].toString()); } String formattedFilter = MessageFormat.format(filter, encodedParams); logger.debug(\"Using filter: \" + formattedFilter); final HashSet<Map<String, List<String>>> set = new HashSet<Map<String, List<String>>>(); ContextMapper roleMapper = new ContextMapper() { public Object mapFromContext(Object ctx) { DirContextAdapter adapter = (DirContextAdapter) ctx; Map<String, List<String>> record = new HashMap<String, List<String>>(); if (attributeNames == null || attributeNames.length == 0) { try { for (NamingEnumeration ae = adapter.getAttributes().getAll(); ae .hasMore();) { Attribute attr = (Attribute) ae.next(); extractStringAttributeValues(adapter, record, attr.getID()); } } catch (NamingException x) { org.springframework.ldap.support.LdapUtils .convertLdapException(x); } } else { for (String attributeName : attributeNames) { extractStringAttributeValues(adapter, record, attributeName); } } record.put(DN_KEY, Arrays.asList(getAdapterDN(adapter))); set.add(record); return null; } }; SearchControls ctls = new SearchControls(); ctls.setSearchScope(searchControls.getSearchScope()); ctls.setReturningAttributes(attributeNames != null && attributeNames.length > 0 ? attributeNames : null); search(base, formattedFilter, ctls, roleMapper); return set; } \nResponse:", "ground_truth": "Performs a search using the supplied filter and returns the values of each named\nattribute found in all entries matched by the search. Note that one directory entry\nmay have several values for the attribute. Intended for role searches and similar\nscenarios.\n\n@param base the DN to search in\n@param filter search filter to use\n@param params the parameters to substitute in the search filter\n@param attributeNames the attributes' values that are to be retrieved.\n\n@return the set of String values for each attribute found in all the matching\nentries. The attribute name is the key for each set of values. In addition each map\ncontains the DN as a String with the key predefined key {@link #DN_KEY}.", "predict": " Searches for multiple attribute values. @param base The base DN. @param filter The filter. @param params The parameters. @param attributeNames The names of the attributes to extract. @return The set of matching records."}
{"ID": 88, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DirContextOperations searchForSingleEntryInternal(DirContext ctx, SearchControls searchControls, String base, String filter, Object[] params) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName( ctx.getNameInNamespace()); final DistinguishedName searchBaseDn = new DistinguishedName(base); final NamingEnumeration<SearchResult> resultsEnum = ctx.search(searchBaseDn, filter, params, buildControls(searchControls)); if (logger.isDebugEnabled()) { logger.debug(\"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\"); } Set<DirContextOperations> results = new HashSet<>(); try { while (resultsEnum.hasMore()) { SearchResult searchResult = resultsEnum.next(); DirContextAdapter dca = (DirContextAdapter) searchResult.getObject(); Assert.notNull(dca, \"No object returned by search, DirContext is not correctly configured\"); if (logger.isDebugEnabled()) { logger.debug(\"Found DN: \" + dca.getDn()); } results.add(dca); } } catch (PartialResultException e) { LdapUtils.closeEnumeration(resultsEnum); logger.info(\"Ignoring PartialResultException\"); } if (results.size() == 0) { throw new IncorrectResultSizeDataAccessException(1, 0); } if (results.size() > 1) { throw new IncorrectResultSizeDataAccessException(1, results.size()); } return results.iterator().next(); } \nResponse:", "ground_truth": "Internal method extracted to avoid code duplication in AD search.", "predict": " Search for a single entry under the given DN. The DN is assumed to be absolute. The DN is expected to be fully qualified. The DN is expected to be relative to the base DN. The base DN is expected to be relative to the context DN. The base DN is expected to be an absolute DN. The filter is expected to be a valid LDAP search filter. The search controls are expected to be valid LDAP controls. The search controls are expected to be applied BEFORE the filter is applied. The search controls are expected to be applied BEFORE the base DN is applied. The search controls are expected to be applied BEFORE the context DN is applied. The search controls are expected to be applied BEFORE the DN is applied. The search controls are expected to be applied BEFORE the DN is applied. The search controls are expected to be applied BEFORE the DN is applied. The search controls are expected to be applied BEFORE the DN is applied. The search controls are expected to be applied BEFORE the DN is applied. The search controls are expected to be applied BEFORE the DN is applied."}
{"ID": 89, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static SearchControls buildControls(SearchControls originalControls) { return new SearchControls(originalControls.getSearchScope(), originalControls.getCountLimit(), originalControls.getTimeLimit(), originalControls.getReturningAttributes(), RETURN_OBJECT, originalControls.getDerefLinkFlag()); } \nResponse:", "ground_truth": "We need to make sure the search controls has the return object flag set to true, in\norder for the search to return DirContextAdapter instances.\n@param originalControls\n@return", "predict": " Build a new search controls object with the following modifications: - Count Limit: Removed - Time Limit: Removed - Return Attributes: Removed - Dereference Link Flag: Removed - Return Objects: Removed - SearchScope: Removed - Return Duplicates Flag: Removed - Return No Types: Removed - Return No Attributes: Removed - Return No Identities: Removed - Return No Compiled Attribute Rules: Removed - Return No Effective Attribute Rules: Removed - Return No Attribute Rules: Removed - Return No Identity Rules: Removed - Return No BaseType Rules: Removed - Return No Base Rules: Removed - Return No Base Types: Removed - Return No Base Attribute Rules: Removed - Return No Base Attribute Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No BaseType Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed - Return No Base Definition Rules: Removed"}
{"ID": 90, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void lookupPrimaryKeys(final Map<Serializable, Acl> acls, final Set<Long> findNow, final List<Sid> sids) { Assert.notNull(acls, \"ACLs are required\"); Assert.notEmpty(findNow, \"Items to find now required\"); String sql = computeRepeatingSql(lookupPrimaryKeysWhereClause, findNow.size()); Set<Long> parentsToLookup = jdbcTemplate.query(sql, new PreparedStatementSetter() { public void setValues(PreparedStatement ps) throws SQLException { int i = 0; for (Long toFind : findNow) { i++; ps.setLong(i, toFind); } } }, new ProcessResultSet(acls, sids)); // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if (parentsToLookup.size() > 0) { lookupPrimaryKeys(acls, parentsToLookup, sids); } } \nResponse:", "ground_truth": "Locates the primary key IDs specified in \"findNow\", adding AclImpl instances with\nStubAclParents to the \"acls\" Map.\n\n@param acls the AclImpls (with StubAclParents)\n@param findNow Long-based primary keys to retrieve\n@param sids", "predict": " Lookup primary keys for the parents of each item to find. Necessary because databases don't support correlated subqueries, so we must manually assemble the parent PKs together. Necessary because databases don't support correlated subqueries, so we must manually assemble the parent PKs together. Much easier than understanding why you can't just use correlated subqueries in the lookupPrimaryKeysWhereClause. ;) @param acls Map of ACL information to populate @param findNow Set of IDs to find (will be altered as we populate) @param sids List of SIDs to correlate against IDs\n*/"}
{"ID": 91, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails( HttpServletRequest context) { Collection<String> j2eeUserRoles = getUserRoles(context); Collection<? extends GrantedAuthority> userGas = j2eeUserRoles2GrantedAuthoritiesMapper .getGrantedAuthorities(j2eeUserRoles); if (logger.isDebugEnabled()) { logger.debug(\"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\"); } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails( context, userGas); return result; } \nResponse:", "ground_truth": "Builds the authentication details object.\n\n@see org.springframework.security.authentication.AuthenticationDetailsSource#buildDetails(Object)", "predict": " Build details about the granted authorities. @param context the request context. @return GrantedAuthoritiesWebDetails instance."}
{"ID": 92, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RootBeanDefinition createEmbeddedServer(Element element, ParserContext parserContext) { Object source = parserContext.extractSource(element); String suffix = element.getAttribute(ATT_ROOT_SUFFIX); if (!StringUtils.hasText(suffix)) { suffix = OPT_DEFAULT_ROOT_SUFFIX; } String port = element.getAttribute(ATT_PORT); if (!StringUtils.hasText(port)) { port = getDefaultPort(); if (logger.isDebugEnabled()) { logger.debug(\"Using default port of \" + port); } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder .rootBeanDefinition(CONTEXT_SOURCE_CLASS); contextSource.addConstructorArgValue(url); contextSource.addPropertyValue(\"userDn\", \"uid=admin,ou=system\"); contextSource.addPropertyValue(\"password\", \"secret\"); RootBeanDefinition apacheContainer = new RootBeanDefinition( \"org.springframework.security.ldap.server.ApacheDSContainer\", null, null); apacheContainer.setSource(source); apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(suffix); String ldifs = element.getAttribute(ATT_LDIF_FILE); if (!StringUtils.hasText(ldifs)) { ldifs = OPT_DEFAULT_LDIF_FILE; } apacheContainer.getConstructorArgumentValues().addGenericArgumentValue(ldifs); apacheContainer.getPropertyValues().addPropertyValue(\"port\", port); logger.info(\"Embedded LDAP server bean definition created for URL: \" + url); if (parserContext.getRegistry() .containsBeanDefinition(BeanIds.EMBEDDED_APACHE_DS)) { parserContext.getReaderContext().error( \"Only one embedded server bean is allowed per application context\", element); } parserContext.getRegistry().registerBeanDefinition(BeanIds.EMBEDDED_APACHE_DS, apacheContainer); return (RootBeanDefinition) contextSource.getBeanDefinition(); } \nResponse:", "ground_truth": "Will be called if no url attribute is supplied.\n\nRegisters beans to create an embedded apache directory server.\n\n@return the BeanDefinition for the ContextSource for the embedded server.\n\n@see ApacheDSContainer", "predict": " Creates the embedded LDAP server definition. @param element the element that specifies the embedded LDAP server bean definition. @param parserContext the parser context. @return the RootBeanDefinition for the embedded LDAP server bean.\n*/"}
{"ID": 93, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createServletApiFilter(BeanReference authenticationManager) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\"; final String DEF_SERVLET_API_PROVISION = \"true\"; String provideServletApi = httpElt.getAttribute(ATT_SERVLET_API_PROVISION); if (!StringUtils.hasText(provideServletApi)) { provideServletApi = DEF_SERVLET_API_PROVISION; } if (\"true\".equals(provideServletApi)) { servApiFilter = GrantedAuthorityDefaultsParserUtils.registerWithDefaultRolePrefix(pc, SecurityContextHolderAwareRequestFilterBeanFactory.class); servApiFilter.getPropertyValues().add(\"authenticationManager\", authenticationManager); } } \nResponse:", "ground_truth": "Adds the servlet-api integration filter if required", "predict": " Wire up SecurityContextHolderAwareRequestFilter unless told not to"}
{"ID": 94, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void createJaasApiFilter() { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\"; final String DEF_JAAS_API_PROVISION = \"false\"; String provideJaasApi = httpElt.getAttribute(ATT_JAAS_API_PROVISION); if (!StringUtils.hasText(provideJaasApi)) { provideJaasApi = DEF_JAAS_API_PROVISION; } if (\"true\".equals(provideJaasApi)) { jaasApiFilter = new RootBeanDefinition(JaasApiIntegrationFilter.class); } } \nResponse:", "ground_truth": "Adds the jaas-api integration filter if required", "predict": " Create the JaasApiIntegrationFilter bean.\n*/"}
{"ID": 95, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static TypeResolverBuilder<? extends TypeResolverBuilder> createWhitelistedDefaultTyping() { TypeResolverBuilder<? extends TypeResolverBuilder> result = new WhitelistTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL); result = result.init(JsonTypeInfo.Id.CLASS, null); result = result.inclusion(JsonTypeInfo.As.PROPERTY); return result; } \nResponse:", "ground_truth": "Creates a TypeResolverBuilder that performs whitelisting.\n@return a TypeResolverBuilder that performs whitelisting.", "predict": " Although Jackson doesn't enforce this, it's good hygiene. Specifically, Jackson won't serialize a class unless it's either final or effectively final (ie Jackson understands all subclasses won't need to be considered). Therefore, Jackson won't consider a class to be final unless it's whitelisted here.\n * @return Whitelisted Jackson default typing strategy.\n */"}
{"ID": 96, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void insertSpringSecurityFilterChain(ServletContext servletContext) { String filterName = DEFAULT_FILTER_NAME; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy( filterName); String contextAttribute = getWebApplicationContextAttribute(); if (contextAttribute != null) { springSecurityFilterChain.setContextAttribute(contextAttribute); } registerFilter(servletContext, true, filterName, springSecurityFilterChain); } \nResponse:", "ground_truth": "Registers the springSecurityFilterChain\n@param servletContext the {@link ServletContext}", "predict": " Insert Spring Security Filter Chain into Servlet Context. @param servletContext Servlet Context.\n*/"}
{"ID": 97, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PersistentRememberMeToken getTokenForSeries(String seriesId) { try { return getJdbcTemplate().queryForObject(tokensBySeriesSql, new RowMapper<PersistentRememberMeToken>() { public PersistentRememberMeToken mapRow(ResultSet rs, int rowNum) throws SQLException { return new PersistentRememberMeToken(rs.getString(1), rs .getString(2), rs.getString(3), rs.getTimestamp(4)); } }, seriesId); } catch (EmptyResultDataAccessException zeroResults) { if (logger.isDebugEnabled()) { logger.debug(\"Querying token for series '\" + seriesId + \"' returned no results.\", zeroResults); } } catch (IncorrectResultSizeDataAccessException moreThanOne) { logger.error(\"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\"); } catch (DataAccessException e) { logger.error(\"Failed to load token for series \" + seriesId, e); } return null; } \nResponse:", "ground_truth": "Loads the token data for the supplied series identifier.\n\nIf an error occurs, it will be reported and null will be returned (since the result\nshould just be a failed persistent login).\n\n@param seriesId\n@return the token matching the series, or null if no match found or an exception\noccurred.", "predict": " Retrieve a persisted token for a given series. @param seriesId token series id. @return the token or null if none found\n*/"}
{"ID": 98, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { List<GrantedAuthority> result = new ArrayList<>(attributes.size()); for (String attribute : attributes) { result.add(getGrantedAuthority(attribute)); } return result; } \nResponse:", "ground_truth": "Map the given list of string attributes one-to-one to Spring Security\nGrantedAuthorities.", "predict": " Convert a collection of attributes to authorities. Attributes are assumed to be prefixed with ATTRIBUTE_SEPARATOR. @param attributes Attributes to convert. @return Authorities.\n*/"}
{"ID": 99, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cipher newCipher(String algorithm) { try { return Cipher.getInstance(algorithm); } catch (NoSuchAlgorithmException e) { throw new IllegalArgumentException(\"Not a valid encryption algorithm\", e); } catch (NoSuchPaddingException e) { throw new IllegalStateException(\"Should not happen\", e); } } \nResponse:", "ground_truth": "Constructs a new Cipher.", "predict": " Creates a Cipher instance for the given algorithm. @param algorithm The algorithm to use. @return The Cipher instance.\n*/"}
{"ID": 100, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void afterPropertiesSet() { try { super.afterPropertiesSet(); } catch (ServletException e) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException(e); } Assert.notNull(authenticationManager, \"An AuthenticationManager must be set\"); } \nResponse:", "ground_truth": "Check whether all required properties have been set.", "predict": " Initializes the filter. Ensures that a Spring AuthenticationManager is present. Throws ServletException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Ensures that a Spring Security AuthenticationManager is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Ensures that a Spring Security AuthenticationManager is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Ensures that a Spring Security AuthenticationManager is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Ensures that a Spring Security AuthenticationManager is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is present. Ensures that a Spring Security AuthenticationManager is present. Throws RuntimeException on Spring StartupException. Ensures that a Spring Security FilterChainProxy is"}
{"ID": 101, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication()); } if (requiresAuthentication((HttpServletRequest) request)) { doAuthenticate((HttpServletRequest) request, (HttpServletResponse) response); } chain.doFilter(request, response); } \nResponse:", "ground_truth": "Try to authenticate a pre-authenticated user with Spring Security if the user has\nnot yet been authenticated.", "predict": " Authenticate the request and proceed filtering. @param request The servlet request. @param response The servlet response. @param chain The filter chain. @throws IOException If an IOException occurs. @throws ServletException If a servlet exception occurs."}
{"ID": 102, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean principalChanged(HttpServletRequest request, Authentication currentAuthentication) { Object principal = getPreAuthenticatedPrincipal(request); if ((principal instanceof String) && currentAuthentication.getName().equals(principal)) { return false; } if (principal != null && principal.equals(currentAuthentication.getPrincipal())) { return false; } if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\"); } return true; } \nResponse:", "ground_truth": "Determines if the current principal has changed. The default implementation tries\n\n<ul>\n<li>If the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is a String, the {@link Authentication#getName()} is compared against the pre authenticated principal</li>\n<li>Otherwise, the {@link #getPreAuthenticatedPrincipal(HttpServletRequest)} is compared against the {@link Authentication#getPrincipal()}\n</ul>\n\n<p>\nSubclasses can override this method to determine when a principal has changed.\n</p>\n\n@param request\n@param currentAuthentication\n@return true if the principal has changed, else false", "predict": " Called prior to proceeding to authenticate the credential previously obtained from this source. Implementations may use the principal from the request to determine whether subsequent authentications should proceed. For example, one might wish to enforce security contexts for each request and only proceed if the principal has changed. Note, however, that merely returning false/true would also preclude any kind of introspection of the principal as that is outside the purview of subclasses of AuthenticationManager. Implementations wishing to discriminate based on the principal should override AuthenticationManager.supports(Authentication.class). Alternatively, subclasses wishing to introspect principals prior to proceeding with authentication need not override this method. However, note that introspection of the principal should not be performed in this method but rather prior to invoking AuthenticationManager.authenticate(Authentication.class). Implementations wishing to enforce security contexts prior to authenticating need not override this method. Instead, they can enforce security contexts prior to invoking AuthenticationManager.authenticate(Authentication.class). However, note that invoking AuthenticationManager.authenticate(Authentication."}
{"ID": 103, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAuthenticate(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { Authentication authResult; Object principal = getPreAuthenticatedPrincipal(request); Object credentials = getPreAuthenticatedCredentials(request); if (principal == null) { if (logger.isDebugEnabled()) { logger.debug(\"No pre-authenticated principal found in request\"); } return; } if (logger.isDebugEnabled()) { logger.debug(\"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\"); } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken( principal, credentials); authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); authResult = authenticationManager.authenticate(authRequest); successfulAuthentication(request, response, authResult); } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); if (!continueFilterChainOnUnsuccessfulAuthentication) { throw failed; } } } \nResponse:", "ground_truth": "Do the actual authentication for a pre-authenticated user.", "predict": " Actually commence authentication. Called from AuthenticationFilter.doFilter(). Authentication involves making a call to authenticate(), which prompts LdapAuthenticator to authenticate against an LDAP directory. Upon successful authentication, the resulting Principal is passed to successfulAuthentication(HttpServletRequest, HttpServletResponse, Authentication) to perform any additional operations, such as populating the SecurityContextHolder. Finally, the user is redirected to the originally requested resource. @param request The servlet request we are processing @param response The servlet response we are creating @throws IOException if an input/output error occurs\n@throws ServletException if a servlet-specified error occurs"}
{"ID": 104, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkContentLength(long contentLengthToWrite) { this.contentWritten += contentLengthToWrite; boolean isBodyFullyWritten = this.contentLength > 0 && this.contentWritten >= this.contentLength; int bufferSize = getBufferSize(); boolean requiresFlush = bufferSize > 0 && this.contentWritten >= bufferSize; if (isBodyFullyWritten || requiresFlush) { doOnResponseCommitted(); } } \nResponse:", "ground_truth": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if\nthe response should be written.\n\n@param contentLengthToWrite the size of the content that is about to be written.", "predict": " Check to make sure that the content length hasn't been set after we've written some data. Setting a content length once the stream has been written will cause a 411 Length Required exception. Instead, we just remember that the content length has been set and then throw an exception if we try to write again without first writing everything originally intended to be written. @param contentLengthToWrite The length to write @throws IllegalStateException If the content length has been set\n*/"}
{"ID": 105, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<GrantedAuthority> mapAuthorities( Collection<? extends GrantedAuthority> authorities) { HashSet<GrantedAuthority> mapped = new HashSet<>( authorities.size()); for (GrantedAuthority authority : authorities) { mapped.add(mapAuthority(authority.getAuthority())); } if (defaultAuthority != null) { mapped.add(defaultAuthority); } return mapped; } \nResponse:", "ground_truth": "Creates a mapping of the supplied authorities based on the case-conversion and\nprefix settings. The mapping will be one-to-one unless duplicates are produced\nduring the conversion. If a default authority has been set, this will also be\nassigned to each mapping.\n\n@param authorities the original authorities\n\n@return the converted set of authorities", "predict": " Maps Granted Authorities to roles. @param authorities granted authorities. @return roles."}
{"ID": 106, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T loginProcessingUrl(String loginProcessingUrl) { this.loginProcessingUrl = loginProcessingUrl; authFilter .setRequiresAuthenticationRequestMatcher(createLoginProcessingUrlMatcher(loginProcessingUrl)); return getSelf(); } \nResponse:", "ground_truth": "Specifies the URL to validate the credentials.\n\n@param loginProcessingUrl the URL to validate username and password\n@return the {@link FormLoginConfigurer} for additional customization", "predict": " Login processing url @param loginProcessingUrl login url @return Fluent API\n*/"}
{"ID": 107, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAuthenticationDefaults() { if (loginProcessingUrl == null) { loginProcessingUrl(loginPage); } if (failureHandler == null) { failureUrl(loginPage + \"?error\"); } final LogoutConfigurer<B> logoutConfigurer = getBuilder().getConfigurer( LogoutConfigurer.class); if (logoutConfigurer != null && !logoutConfigurer.isCustomLogoutSuccess()) { logoutConfigurer.logoutSuccessUrl(loginPage + \"?logout\"); } } \nResponse:", "ground_truth": "Updates the default values for authentication.\n\n@throws Exception", "predict": " Updates the authentication defaults for this login module. Often referred to as realms. These realms are traditionally obtained from a login form.\n */"}
{"ID": 108, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void updateAccessDefaults(B http) { if (permitAll) { PermitAllSupport.permitAll(http, loginPage, loginProcessingUrl, failureUrl); } } \nResponse:", "ground_truth": "Updates the default values for access.", "predict": " Updates the access restrictions imposed by BASIC authentication based on the security constraints of the web application deployment descriptor. Specifically, the following issues are addressed: <ol> <li>Setting the appropriate security constraint(s) on the BASIC authentication entry</li> <li>Reflecting back the security constraint(s) settings on the BASIC authentication entry back to the deployment descriptor</li> </ol> Subclasses may choose to override this method to impose stricter BASIC restrictions than imposed by the Servlet Specification. <p>Note that restricting access to authenticated users poses serious security risks. Please consult your auditor regarding the impact of restricting access to authenticated users. @param http the HTTP servlet being protected\n*/"}
{"ID": 109, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String mapPassword(Object passwordValue) { if (!(passwordValue instanceof String)) { // Assume it's binary passwordValue = new String((byte[]) passwordValue); } return (String) passwordValue; } \nResponse:", "ground_truth": "Extension point to allow customized creation of the user's password from the\nattribute stored in the directory.\n\n@param passwordValue the value of the password attribute\n@return a String representation of the password.", "predict": " Map the password to a String. If the password is binary, convert it to a String. Otherwise assume it's a String. @param passwordValue Password to map. @return Password mapped to a String."}
{"ID": 110, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String extractRememberMeCookie(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); if ((cookies == null) || (cookies.length == 0)) { return null; } for (Cookie cookie : cookies) { if (cookieName.equals(cookie.getName())) { return cookie.getValue(); } } return null; } \nResponse:", "ground_truth": "Locates the Spring Security remember me cookie in the request and returns its\nvalue. The cookie is searched for by name and also by matching the context path to\nthe cookie path.\n\n@param request the submitted request which is to be authenticated\n@return the cookie value (if present), null otherwise.", "predict": " Extract Remember Me cookie from request. @param request incoming servlet request. @return Remember Me cookie value or null if cookie doesn't exist.\n"}
{"ID": 111, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String encodeCookie(String[] cookieTokens) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < cookieTokens.length; i++) { try { sb.append(URLEncoder.encode(cookieTokens[i], StandardCharsets.UTF_8.toString())); } catch (UnsupportedEncodingException e) { logger.error(e.getMessage(), e); } if (i < cookieTokens.length - 1) { sb.append(DELIMITER); } } String value = sb.toString(); sb = new StringBuilder(new String(Base64.getEncoder().encode(value.getBytes()))); while (sb.charAt(sb.length() - 1) == '=') { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); } \nResponse:", "ground_truth": "Inverse operation of decodeCookie.\n\n@param cookieTokens the tokens to be encoded.\n@return base64 encoding of the tokens concatenated with the \":\" delimiter.", "predict": " Encodes the cookie value using Base64 encoding. @param cookieTokens Cookie tokens. @return Cookie value encoded using Base64.\n*/"}
{"ID": 112, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setCookie(String[] tokens, int maxAge, HttpServletRequest request, HttpServletResponse response) { String cookieValue = encodeCookie(tokens); Cookie cookie = new Cookie(cookieName, cookieValue); cookie.setMaxAge(maxAge); cookie.setPath(getCookiePath(request)); if (cookieDomain != null) { cookie.setDomain(cookieDomain); } if (maxAge < 1) { cookie.setVersion(1); } if (useSecureCookie == null) { cookie.setSecure(request.isSecure()); } else { cookie.setSecure(useSecureCookie); } cookie.setHttpOnly(true); response.addCookie(cookie); } \nResponse:", "ground_truth": "Sets the cookie on the response.\n\nBy default a secure cookie will be used if the connection is secure. You can set\nthe {@code useSecureCookie} property to {@code false} to override this. If you set\nit to {@code true}, the cookie will always be flagged as secure. By default the cookie\nwill be marked as HttpOnly.\n\n@param tokens the tokens which will be encoded to make the cookie value.\n@param maxAge the value passed to {@link Cookie#setMaxAge(int)}\n@param request the request\n@param response the response to add the cookie to.", "predict": " Set the cookie value. @param tokens Cookie tokens. @param maxAge Cookie age. @param request The request. @param response The response.\n*/"}
{"ID": 113, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Mono<Object> resolveArgument(MethodParameter parameter, BindingContext bindingContext, ServerWebExchange exchange) { ReactiveAdapter adapter = getAdapterRegistry().getAdapter(parameter.getParameterType()); Mono<SecurityContext> reactiveSecurityContext = ReactiveSecurityContextHolder.getContext(); if (reactiveSecurityContext == null) { return null; } return reactiveSecurityContext.flatMap( a -> { Object p = resolveSecurityContext(parameter, a); Mono<Object> o = Mono.justOrEmpty(p); return adapter == null ? o : Mono.just(adapter.fromPublisher(o)); }); } \nResponse:", "ground_truth": "resolve the argument to inject into the controller parameter.\n@param parameter the method parameter.\n@param bindingContext the binding context.\n@param exchange the server web exchange.\n@return the reactive mono object result.", "predict": " Resolves the security context from the reactive security context holder. @param parameter the method parameter @param bindingContext the binding context @param exchange the exchange @return the resolved security context\n*/"}
{"ID": 114, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String getQueryString(final HttpServletRequest request, final Pattern artifactPattern) { final String query = request.getQueryString(); if (query == null) { return null; } final String result = artifactPattern.matcher(query).replaceFirst(\"\"); if (result.length() == 0) { return null; } // strip off the trailing & only if the artifact was the first query param return result.startsWith(\"&\") ? result.substring(1) : result; } \nResponse:", "ground_truth": "If present, removes the artifactParameterName and the corresponding value from the\nquery String.\n@param request\n@return the query String minus the artifactParameterName and the corresponding\nvalue.", "predict": " Strip off the leading ampersand and everything after it. Stripping off the leading ampersand is important because artifacts are often prefixed with an ampersand. Stripping everything after the leading ampersand leaves us with the artifact name. @param request The servlet request. @param artifactPattern The pattern to match artifacts. @return The artifact name."}
{"ID": 115, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getServicePort(URL casServiceUrl) { int port = casServiceUrl.getPort(); if (port == -1) { port = casServiceUrl.getDefaultPort(); } return port; } \nResponse:", "ground_truth": "Gets the port from the casServiceURL ensuring to return the proper value if the\ndefault port is being used.\n@param casServiceUrl the casServerUrl to be used (i.e.\n\"https://example.com/context/login/cas\")\n@return the port that is configured for the casServerUrl", "predict": " Gets the service port. @param casServiceUrl the cas service url\n @return the service port\n*/"}
{"ID": 116, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPrincipal() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); if (authentication == null) { log.warn(\"No Authentication object set in SecurityContext - returning empty String as Principal\"); return \"\"; } Object principal = authentication.getPrincipal(); if (principal instanceof LdapUserDetails) { LdapUserDetails details = (LdapUserDetails) principal; return details.getDn(); } else if (authentication instanceof AnonymousAuthenticationToken) { if (log.isDebugEnabled()) { log.debug(\"Anonymous Authentication, returning empty String as Principal\"); } return \"\"; } else { throw new IllegalArgumentException( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\"); } } \nResponse:", "ground_truth": "Get the principals of the logged in user, in this case the distinguished name.\n\n@return the distinguished name of the logged in user.", "predict": " Returns the distinguished name of the authenticated user. If the user is authenticated as an AnonymousUser, returns an empty string. @return distinguished name of the authenticated user\n*/"}
{"ID": 117, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { Assert.notNull(request, \"HttpServletRequest required\"); if (invalidateHttpSession) { HttpSession session = request.getSession(false); if (session != null) { logger.debug(\"Invalidating session: \" + session.getId()); session.invalidate(); } } if (clearAuthentication) { SecurityContext context = SecurityContextHolder.getContext(); context.setAuthentication(null); } SecurityContextHolder.clearContext(); } \nResponse:", "ground_truth": "Requires the request to be passed in.\n\n@param request from which to obtain a HTTP session (cannot be null)\n@param response not used (can be <code>null</code>)\n@param authentication not used (can be <code>null</code>)", "predict": " Logout a user out by clearing their SecurityContextHolder context. Registered listeners are fired for the logout event. Further cleanup may be performed, depending on the {@link SecurityContextHolder} configuration. @param request the request @param response the response @param authentication the authentication that was used to authenticate the principal (which is now cleared from the SecurityContextHolder)\n*/"}
{"ID": 118, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Authentication authenticate(Authentication auth) throws AuthenticationException { if (!(auth instanceof UsernamePasswordAuthenticationToken)) { return null; } UsernamePasswordAuthenticationToken request = (UsernamePasswordAuthenticationToken) auth; Set<GrantedAuthority> authorities; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext( new InternalCallbackHandler(auth)); // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext.login(); // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet<>(); // Get the subject principals and pass them to each of the AuthorityGranters Set<Principal> principals = loginContext.getSubject().getPrincipals(); for (Principal principal : principals) { for (AuthorityGranter granter : this.authorityGranters) { Set<String> roles = granter.grant(principal); // If the granter doesn't wish to grant any authorities, it should // return null. if ((roles != null) && !roles.isEmpty()) { for (String role : roles) { authorities.add(new JaasGrantedAuthority(role, principal)); } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken( request.getPrincipal(), request.getCredentials(), new ArrayList<>(authorities), loginContext); // Publish the success event publishSuccessEvent(result); // we're done, return the token. return result; } catch (LoginException loginException) { AuthenticationException ase = this.loginExceptionResolver .resolveException(loginException); publishFailureEvent(request, ase); throw ase; } } \nResponse:", "ground_truth": "Attempts to login the user given the Authentication objects principal and\ncredential\n\n@param auth The Authentication object to be authenticated.\n\n@return The authenticated Authentication object, with it's grantedAuthorities set.\n\n@throws AuthenticationException This implementation does not handle 'locked' or\n'disabled' accounts. This method only throws a AuthenticationServiceException, with\nthe message of the LoginException that will be thrown, should the\nloginContext.login() method fail.", "predict": " Authenticate the given authentication token. @param auth the authentication token to authenticate @return the authenticated principal @throws AuthenticationException if authentication failed\n*/"}
{"ID": 119, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildProviderUrl(List<String> urls, String baseDn) { Assert.notNull(baseDn, \"The Base DN for the LDAP server must not be null.\"); Assert.notEmpty(urls, \"At least one LDAP server URL must be provided.\"); String trimmedBaseDn = baseDn.trim(); StringBuilder providerUrl = new StringBuilder(); for (String serverUrl : urls) { String trimmedUrl = serverUrl.trim(); if (\"\".equals(trimmedUrl)) { continue; } providerUrl.append(trimmedUrl); if (!trimmedUrl.endsWith(\"/\")) { providerUrl.append(\"/\"); } providerUrl.append(trimmedBaseDn); providerUrl.append(\" \"); } return providerUrl.toString(); } \nResponse:", "ground_truth": "Builds a Spring LDAP-compliant Provider URL string, i.e. a space-separated list of\nLDAP servers with their base DNs. As the base DN must be identical for all servers,\nit needs to be supplied only once.\n\n@param urls A list of string values which are LDAP server URLs. An example would be\n\n<pre>\nldap://ldap.company.com:389\n</pre>\n\n. LDAPS URLs may be used as well, given that Spring Security is able to connect to\nthe server.\n@param baseDn The common Base DN for all provided servers, e.g.\n\n<pre>\ndc=company,dc=com\n</pre>\n\n.\n@return A Spring Security/Spring LDAP-compliant Provider URL string.", "predict": " Builds the LDAP provider URL based on the provided LDAP server URLs and Base DN. @param urls the LDAP server URLs @param baseDn the Base DN for the LDAP server @return the LDAP provider URL\n*/"}
{"ID": 120, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setContextEnvironmentProperties(Map<String, Object> environment) { Assert.notEmpty(environment, \"environment must not be empty\"); this.contextEnvironmentProperties = new Hashtable<>(environment); } \nResponse:", "ground_truth": "Allows a custom environment properties to be used to create initial LDAP context.\n\n@param environment the additional environment parameters to use when creating the LDAP Context", "predict": " Setter for Spring's Environment abstraction @param environment Properties to expose to the Spring application context. Ideally, this would be populated by a bean definition of type Environment, but this is not possible if there are \"legacy\" tests in the classpath that still use EnvironmentLocator @see EnvironmentLocator\n */"}
{"ID": 121, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String getRedirectUrl() { return UrlUtils.buildFullRequestUrl(scheme, serverName, serverPort, requestURI, queryString); } \nResponse:", "ground_truth": "Indicates the URL that the user agent used for this request.\n\n@return the full URL of this request", "predict": " Returns the redirect url. @return Redirect url."}
{"ID": 122, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int doEndTag() throws JspException { try { if (!authorized && TagLibConfig.isUiSecurityDisabled()) { pageContext.getOut().write(TagLibConfig.getSecuredUiSuffix()); } } catch (IOException e) { throw new JspException(e); } return EVAL_PAGE; } \nResponse:", "ground_truth": "Default processing of the end tag returning EVAL_PAGE.\n\n@return EVAL_PAGE\n@see Tag#doEndTag()", "predict": " Finalizes the HTML escaping. @return SKIP_PAGE to skip the page, EVAL_PAGE to evaluate the body, and CONTINUE_EVAL to evaluate the body again. @throws JspException if an IOException occurs.\n*/"}
{"ID": 123, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void initUserDetailsService() throws Exception { for (UserDetailsBuilder userBuilder : userBuilders) { getUserDetailsService().createUser(userBuilder.build()); } for (UserDetails userDetails : this.users) { getUserDetailsService().createUser(userDetails); } } \nResponse:", "ground_truth": "Populates the users that have been added.\n\n@throws Exception", "predict": " Initializes the UserDetailsService. @throws Exception Exception\n*/"}
{"ID": 124, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private UserDetailsService getUserDetailsService() { Map<String, ?> beans = getBeansOfType(CachingUserDetailsService.class); if (beans.size() == 0) { beans = getBeansOfType(UserDetailsService.class); } if (beans.size() == 0) { throw new ApplicationContextException(\"No UserDetailsService registered.\"); } else if (beans.size() > 1) { throw new ApplicationContextException( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\"); } return (UserDetailsService) beans.values().toArray()[0]; } \nResponse:", "ground_truth": "Obtains a user details service for use in RememberMeServices etc. Will return a\ncaching version if available so should not be used for beans which need to separate\nthe two.", "predict": " Obtains the UserDetailsService bean from Spring Security. If none is found, then an ApplicationContextException is thrown.\n * @return the UserDetailsService bean from Spring Security\n */"}
{"ID": 125, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addPkceParameters(Map<String, Object> attributes, Map<String, Object> additionalParameters) { String codeVerifier = this.codeVerifierGenerator.generateKey(); attributes.put(PkceParameterNames.CODE_VERIFIER, codeVerifier); try { String codeChallenge = createCodeChallenge(codeVerifier); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeChallenge); additionalParameters.put(PkceParameterNames.CODE_CHALLENGE_METHOD, \"S256\"); } catch (NoSuchAlgorithmException e) { additionalParameters.put(PkceParameterNames.CODE_CHALLENGE, codeVerifier); } } \nResponse:", "ground_truth": "Creates and adds additional PKCE parameters for use in the OAuth 2.0 Authorization and Access Token Requests\n\n@param attributes where {@link PkceParameterNames#CODE_VERIFIER} is stored for the token request\n@param additionalParameters where {@link PkceParameterNames#CODE_CHALLENGE} and, usually,\n{@link PkceParameterNames#CODE_CHALLENGE_METHOD} are added to be used in the authorization request.\n\n@since 5.2\n@see <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7636#section-1.1\">1.1.  Protocol Flow</a>\n@see <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7636#section-4.1\">4.1.  Client Creates a Code Verifier</a>\n@see <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc7636#section-4.2\">4.2.  Client Creates the Code Challenge</a>", "predict": " Adds PKCE parameters to the attributes map. Also adds the additional parameters map. @param attributes the attributes map. @param additionalParameters the additional parameters map."}
{"ID": 126, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean requiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) { final boolean serviceTicketRequest = serviceTicketRequest(request, response); final boolean result = serviceTicketRequest || proxyReceptorRequest(request) || (proxyTicketRequest(serviceTicketRequest, request)); if (logger.isDebugEnabled()) { logger.debug(\"requiresAuthentication = \" + result); } return result; } \nResponse:", "ground_truth": "Overridden to provide proxying capabilities.", "predict": " Determine whether authentication is required for this request. @param request the HTTP request @param response the HTTP response @return whether authentication is required\n*/"}
{"ID": 127, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean serviceTicketRequest(final HttpServletRequest request, final HttpServletResponse response) { boolean result = super.requiresAuthentication(request, response); if (logger.isDebugEnabled()) { logger.debug(\"serviceTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a service ticket. This method exists\nfor readability.\n@param request\n@param response\n@return", "predict": " This is tightly coupled to the commons-codec implementation. Ideally we would use their API but they don't publicly expose how to configure the encoder so this exposes our configuration via a poorly documented publicly undocumented SPI. Fortunately commons-codec doesn't use this SPI so integrating with them is trivial. Unfortunately they didn't cleanly expose a way to configure the decoder so we have to do it manually. Fortunately we can rely on their encodeURL variant so we can just call it. Oh joyous hacks. Again thankfully we don't have to worry about someone maliciously subverting our service ticket endpoint. :) @param request HTTP request. @param response HTTP response. @return Always returns true.\n*/"}
{"ID": 128, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyTicketRequest(final boolean serviceTicketRequest, final HttpServletRequest request) { if (serviceTicketRequest) { return false; } final boolean result = authenticateAllArtifacts && obtainArtifact(request) != null && !authenticated(); if (logger.isDebugEnabled()) { logger.debug(\"proxyTicketRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to process a proxy ticket.\n@param request\n@return", "predict": " Attempts to acquire an Artifact. Depending on the expectations expressed through the configuration, either a service ticket or a proxy ticket will be acquired. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned. Depending on the expectations expressed through the configuration, either a ticket granting ticket or a ticket granting ticket and a service ticket will be returned"}
{"ID": 129, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean authenticated() { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); return authentication != null && authentication.isAuthenticated() && !(authentication instanceof AnonymousAuthenticationToken); } \nResponse:", "ground_truth": "Determines if a user is already authenticated.\n@return", "predict": " Authenticated helper method. @return True if authenticated, false otherwise."}
{"ID": 130, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean proxyReceptorRequest(final HttpServletRequest request) { final boolean result = proxyReceptorConfigured() && proxyReceptorMatcher.matches(request); if (logger.isDebugEnabled()) { logger.debug(\"proxyReceptorRequest = \" + result); } return result; } \nResponse:", "ground_truth": "Indicates if the request is elgible to be processed as the proxy receptor.\n@param request\n@return", "predict": " Determine whether the request should be proxied by the receptor servlet. @param request incoming HTTP request\n@return true if the request should be proxied, false otherwise\n*/"}
{"ID": 131, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MethodSecurityExpressionOperations createSecurityExpressionRoot( Authentication authentication, MethodInvocation invocation) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot( authentication); root.setThis(invocation.getThis()); root.setPermissionEvaluator(getPermissionEvaluator()); root.setTrustResolver(getTrustResolver()); root.setRoleHierarchy(getRoleHierarchy()); root.setDefaultRolePrefix(getDefaultRolePrefix()); return root; } \nResponse:", "ground_truth": "Creates the root object for expression evaluation.", "predict": " Allows customization of the expression root prior to the expression being evaluated. Useful for adjusting the namespace, etc. This customization could be done in a subclass and overriding this method would be sufficient. However, by overriding this method you can gain fine grain control over the expression being evaluated. @param authentication Authentication object for evaluating secure expressions @param invocation the spring MethodInvocation object for evaluating expressions @return Expression root prior to invoking the expression evaluator. Useful for customization purposes. Subclasses may return a new expression root. Returning null will result in no customization. Returning an instance of this class will result in evaluating the expression using the default expression root customization (@link ExpressionRoot} customization). Returning an instance of a subclass of ExpressionRoot will result in evaluating the expression using that customization. Returning an instance of a different class will result in an IllegalArgumentException being thrown. Returning null will result in no customization. Returning an instance of a subclass of ExpressionRoot will result in evaluating the expression using that customization. Returning an instance of a different class will result in an IllegalArgumentException being"}
{"ID": 132, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Mono<JWKSet> getJWKSet() { return this.webClient.get() .uri(this.jwkSetURL) .retrieve() .bodyToMono(String.class) .map(this::parse) .doOnNext(jwkSet -> this.cachedJWKSet.set(Mono.just(jwkSet))) .cache(); } \nResponse:", "ground_truth": "Updates the cached JWK set from the configured URL.\n\n@return The updated JWK set.\n\n@throws RemoteKeySourceException If JWK retrieval failed.", "predict": " Retrieve the JWK Set from the Discovery document.\n* @return The JWK Set."}
{"ID": 133, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String utf8UrlEncode(String value) { try { return URLEncoder.encode(value, \"UTF-8\"); } catch (UnsupportedEncodingException e) { Error err = new AssertionError( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\"); err.initCause(e); throw err; } } \nResponse:", "ground_truth": "Performs URL encoding with UTF-8\n\n@param value the value to URL encode\n@return the encoded value", "predict": " Percent-encode a string so that it can be safely placed in a URL. This is accomplished by converting non-ASCII characters to their percent-encoded equivalents (%nn). Note that this routine assumes ASCII characters only. Percent-encoding of non-ASCII characters will probably fail. @param value The string to encode. @return The percent-encoded string.\n*/"}
{"ID": 134, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<? extends GrantedAuthority> getWebSphereGroupsBasedGrantedAuthorities() { List<String> webSphereGroups = wasHelper.getGroupsForCurrentUser(); Collection<? extends GrantedAuthority> userGas = webSphereGroups2GrantedAuthoritiesMapper .getGrantedAuthorities(webSphereGroups); if (logger.isDebugEnabled()) { logger.debug(\"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas); } return userGas; } \nResponse:", "ground_truth": "Get a list of Granted Authorities based on the current user's WebSphere groups.\n\n@return authorities mapped from the user's WebSphere groups.", "predict": " WAS-specific authorities extraction logic. Taken from TomcatRealm.java class."}
{"ID": 135, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails loadUserByAssertion(final Assertion assertion) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken( assertion, \"\"); return this.authenticationUserDetailsService.loadUserDetails(token); } \nResponse:", "ground_truth": "Template method for retrieving the UserDetails based on the assertion. Default is\nto call configured userDetailsService and pass the username. Deployers can override\nthis method and retrieve the user based on any criteria they desire.\n\n@param assertion The CAS Assertion.\n@return the UserDetails.", "predict": " Load user by assertion. @param assertion the assertion\n @return the user details\n*/"}
{"ID": 136, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = wasHelper.getCurrentUserName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated WebSphere principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the WebSphere user name.", "predict": " Get WAS principal from the HttpServletRequest. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from WAS SSO cookie. WAS principal is used to authenticate the user in WAS SSO cookie. WAS principal is obtained from"}
{"ID": 137, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] concatenate(byte[]... arrays) { int length = 0; for (byte[] array : arrays) { length += array.length; } byte[] newArray = new byte[length]; int destPos = 0; for (byte[] array : arrays) { System.arraycopy(array, 0, newArray, destPos, array.length); destPos += array.length; } return newArray; } \nResponse:", "ground_truth": "Combine the individual byte arrays into one array.", "predict": " Concatenates byte arrays into one large array. Useful for combining many small arrays together. @param arrays The arrays to concatenate together. @return A single large array containing all the concatenated arrays.\n*/"}
{"ID": 138, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] subArray(byte[] array, int beginIndex, int endIndex) { int length = endIndex - beginIndex; byte[] subarray = new byte[length]; System.arraycopy(array, beginIndex, subarray, 0, length); return subarray; } \nResponse:", "ground_truth": "Extract a sub array of bytes out of the byte array.\n@param array the byte array to extract from\n@param beginIndex the beginning index of the sub array, inclusive\n@param endIndex the ending index of the sub array, exclusive", "predict": " Extracts a subsection of an array. @param array The array to extract from. @param beginIndex The beginning index of the extraction (inclusive). @param endIndex The ending index of the extraction (exclusive). @return The extracted subsection of the original array."}
{"ID": 139, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<GrantedAuthority> getGrantedAuthorities(Collection<String> attributes) { ArrayList<GrantedAuthority> gaList = new ArrayList<>(); for (String attribute : attributes) { Collection<GrantedAuthority> c = attributes2grantedAuthoritiesMap .get(attribute); if (c != null) { gaList.addAll(c); } } gaList.trimToSize(); return gaList; } \nResponse:", "ground_truth": "Map the given array of attributes to Spring Security GrantedAuthorities.", "predict": " Returns granted authorities according authorities granted in the attributes. @param attributes Attributes to be analysed. @return Granted authorities according authorities granted in the attributes."}
{"ID": 140, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<String, Collection<GrantedAuthority>> preProcessMap(Map<?, ?> orgMap) { Map<String, Collection<GrantedAuthority>> result = new HashMap<String, Collection<GrantedAuthority>>( orgMap.size()); for (Map.Entry<?, ?> entry : orgMap.entrySet()) { Assert.isInstanceOf(String.class, entry.getKey(), \"attributes2grantedAuthoritiesMap contains non-String objects as keys\"); result.put((String) entry.getKey(), getGrantedAuthorityCollection(entry.getValue())); } return result; } \nResponse:", "ground_truth": "Preprocess the given map to convert all the values to GrantedAuthority collections\n\n@param orgMap The map to process\n@return the processed Map", "predict": " Convert the flat granted authorities map to a hierarchical granted authorities map.\nThe resulting map will have the granted authorities arranged hierarchically, e.g.: ROLE_A > ROLE_AUTHORITY > ROLE_USER, etc.\nThe hierarchical granted authorities map will be in the form: ROLE_AUTHORITY > ROLE_USER > ROLE_ADMIN, etc.\nThe ROLE_AUTHORITY granted authorities will have no parents. ROLE_USER and ROLE_ADMIN granted authorities will have ROLE_AUTHORITY as their parent. ROLE_USER granted authorities will inherit ROLE_AUTHORITY's authorities, and ROLE_ADMIN granted authorities will inherit ROLE_USER authorities.\nThe hierarchical granted authorities map will be in alphabetical order.\nThe flat granted authorities map will be in alphabetical order.\nThe flat granted authorities map will be converted to a hierarchical granted authorities map.\nThe hierarchical granted authorities map will be in alphabetical order.\nThe flat"}
{"ID": 141, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Collection<GrantedAuthority> getGrantedAuthorityCollection(Object value) { Collection<GrantedAuthority> result = new ArrayList<>(); addGrantedAuthorityCollection(result, value); return result; } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " Convert a GrantedAuthoritiesHolder to a GrantedAuthority Collection. @param value The GrantedAuthoritiesHolder to convert. @return The GrantedAuthority Collection."}
{"ID": 142, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addGrantedAuthorityCollection(Collection<GrantedAuthority> result, Object value) { if (value == null) { return; } if (value instanceof Collection<?>) { addGrantedAuthorityCollection(result, (Collection<?>) value); } else if (value instanceof Object[]) { addGrantedAuthorityCollection(result, (Object[]) value); } else if (value instanceof String) { addGrantedAuthorityCollection(result, (String) value); } else if (value instanceof GrantedAuthority) { result.add((GrantedAuthority) value); } else { throw new IllegalArgumentException(\"Invalid object type: \" + value.getClass().getName()); } } \nResponse:", "ground_truth": "Convert the given value to a collection of Granted Authorities, adding the result\nto the given result collection.\n\n@param value The value to convert to a GrantedAuthority Collection\n@return Collection containing the GrantedAuthority Collection", "predict": " Adds granted authorities to the collection. Supports three types of authorities: GrantedAuthority[], GrantedAuthority, and String authorities. GrantedAuthority[] authorities : Granted Authorities granted authorities : String authorities authorities : GrantedAuthority authorities authorities : GrantedAuthority authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities authorities"}
{"ID": 143, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) { Object principal = httpRequest.getUserPrincipal() == null ? null : httpRequest .getUserPrincipal().getName(); if (logger.isDebugEnabled()) { logger.debug(\"PreAuthenticated J2EE principal: \" + principal); } return principal; } \nResponse:", "ground_truth": "Return the J2EE user name.", "predict": " Get the authenticated principal from the incoming request. Subclasses may override this method to customize how principals are obtained. @param httpRequest incoming ServletRequest @return Principal - authenticated principal from the incoming request.\n*/"}
{"ID": 144, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <C> C getSharedObject(Class<C> sharedType) { return (C) this.sharedObjects.get(sharedType); } \nResponse:", "ground_truth": "Gets a shared Object. Note that object heirarchies are not considered.\n\n@param sharedType the type of the shared Object\n@return the shared Object or null if it is not found", "predict": " Get a shared object from the registry. @param sharedType The type of the shared object to retrieve. @return The shared object. Never <code>null</code>.\n*/"}
{"ID": 145, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String buildHttpsRedirectUrlForRequest(HttpServletRequest request) throws IOException, ServletException { int serverPort = portResolver.getServerPort(request); Integer httpsPort = portMapper.lookupHttpsPort(Integer.valueOf(serverPort)); if (httpsPort != null) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder(); urlBuilder.setScheme(\"https\"); urlBuilder.setServerName(request.getServerName()); urlBuilder.setPort(httpsPort.intValue()); urlBuilder.setContextPath(request.getContextPath()); urlBuilder.setServletPath(request.getServletPath()); urlBuilder.setPathInfo(request.getPathInfo()); urlBuilder.setQuery(request.getQueryString()); return urlBuilder.getUrl(); } // Fall through to server-side forward with warning message logger.warn(\"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort); return null; } \nResponse:", "ground_truth": "Builds a URL to redirect the supplied request to HTTPS. Used to redirect the\ncurrent request to HTTPS, before doing a forward to the login page.", "predict": " Builds a HTTPS redirect URL based upon the request. Follows the redirects and applies the port remapping. Falls back to a 302 Found status code if unsuccessful. @param request The request to inspect. @return The HTTPS redirect URL or null if unsuccessful.\n*/"}
{"ID": 146, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(JoinPoint jp, AspectJCallback advisorProceed) { InterceptorStatusToken token = super .beforeInvocation(new MethodInvocationAdapter(jp)); Object result; try { result = advisorProceed.proceedWithObject(); } finally { super.finallyInvocation(token); } return super.afterInvocation(token, result); } \nResponse:", "ground_truth": "Method that is suitable for user with traditional AspectJ-code aspects.\n\n@param jp The AspectJ joint point being invoked which requires a security decision\n@param advisorProceed the advice-defined anonymous class that implements\n{@code AspectJCallback} containing a simple {@code return proceed();} statement\n\n@return The returned value from the method invocation", "predict": " Proceed advice. Proceed advice wraps around advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice advice"}
{"ID": 147, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String hasRole(String role) { Assert.isTrue( !role.startsWith(\"ROLE_\"), () -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\"); return \"ROLE_\" + role; } \nResponse:", "ground_truth": "Creates a String for specifying a user requires a role.\n\n@param role the role that should be required which is prepended with ROLE_\nautomatically (i.e. USER, ADMIN, etc). It should not start with ROLE_\n@return the {@link ConfigAttribute} expressed as a String", "predict": " Prepends ROLE_ to the role name to facilitate comparison with Spring Security authorities.\n"}
{"ID": 148, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String[] hasAnyRole(String... roles) { for (int i = 0; i < roles.length; i++) { roles[i] = \"ROLE_\" + roles[i]; } return roles; } \nResponse:", "ground_truth": "Creates a String for specifying that a user requires one of many roles.\n\n@param roles the roles that the user should have at least one of (i.e. ADMIN, USER,\netc). Each role should not start with ROLE_ since it is automatically prepended\nalready.\n@return the {@link ConfigAttribute} expressed as a String", "predict": " Generates role names for the given roles. Role names are prefixed with ROLE_ to facilitate easy comparison with Spring Security GrantedAuthority implementations. @param roles The roles to generate role names for. @return The role names."}
{"ID": 149, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) { if (cookieTokens.length != 2) { throw new InvalidCookieException(\"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays.asList(cookieTokens) + \"'\"); } final String presentedSeries = cookieTokens[0]; final String presentedToken = cookieTokens[1]; PersistentRememberMeToken token = tokenRepository .getTokenForSeries(presentedSeries); if (token == null) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException( \"No persistent token found for series id: \" + presentedSeries); } // We have a match for this user/series combination if (!presentedToken.equals(token.getTokenValue())) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository.removeUserTokens(token.getUsername()); throw new CookieTheftException( messages.getMessage( \"PersistentTokenBasedRememberMeServices.cookieStolen\", \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\")); } if (token.getDate().getTime() + getTokenValiditySeconds() * 1000L < System .currentTimeMillis()) { throw new RememberMeAuthenticationException(\"Remember-me login has expired\"); } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if (logger.isDebugEnabled()) { logger.debug(\"Refreshing persistent login token for user '\" + token.getUsername() + \"', series '\" + token.getSeries() + \"'\"); } PersistentRememberMeToken newToken = new PersistentRememberMeToken( token.getUsername(), token.getSeries(), generateTokenData(), new Date()); try { tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate()); addCookie(newToken, request, response); } catch (Exception e) { logger.error(\"Failed to update token: \", e); throw new RememberMeAuthenticationException( \"Autologin failed due to data access problem\"); } return getUserDetailsService().loadUserByUsername(token.getUsername()); } \nResponse:", "ground_truth": "Locates the presented cookie data in the token repository, using the series id. If\nthe data compares successfully with that in the persistent store, a new token is\ngenerated and stored with the same series. The corresponding cookie value is set on\nthe response.\n\n@param cookieTokens the series and token values\n\n@throws RememberMeAuthenticationException if there is no stored token corresponding\nto the submitted cookie, or if the token in the persistent store has expired.\n@throws InvalidCookieException if the cookie doesn't have two tokens as expected.\n@throws CookieTheftException if a presented series value is found, but the stored\ntoken is different from the one presented.", "predict": " Process the auto login cookie for this request. @param cookieTokens Cookie token details (@see org.springframework.security.web.authentication.rememberme.PersistentRememberMeToken) @param request The request details @param response The response details @return UserDetails for the logged in user\n*/"}
{"ID": 150, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) { String username = successfulAuthentication.getName(); logger.debug(\"Creating new persistent login for user \" + username); PersistentRememberMeToken persistentToken = new PersistentRememberMeToken( username, generateSeriesData(), generateTokenData(), new Date()); try { tokenRepository.createNewToken(persistentToken); addCookie(persistentToken, request, response); } catch (Exception e) { logger.error(\"Failed to save persistent token \", e); } } \nResponse:", "ground_truth": "Creates a new persistent login token with a new series number, stores the data in\nthe persistent token repository and adds the corresponding cookie to the response.", "predict": " Hook point for customizing the auto-creation of a persistent token after successful authentication. Default is to create a new token and store it. @param request @param response @param successfulAuthentication @see TokenBasedRememberMeServices#onLoginSuccess\n*/"}
{"ID": 151, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest; String username = request.getParameter(this.usernameParameter); if (username == null) { username = \"\"; } if (this.logger.isDebugEnabled()) { this.logger.debug(\"Attempt to switch to user [\" + username + \"]\"); } UserDetails targetUser = this.userDetailsService.loadUserByUsername(username); this.userDetailsChecker.check(targetUser); // OK, create the switch user token targetUserRequest = createSwitchUserToken(request, targetUser); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Switch User Token [\" + targetUserRequest + \"]\"); } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser)); } return targetUserRequest; } \nResponse:", "ground_truth": "Attempt to switch to another user. If the user does not exist or is not active,\nreturn null.\n\n@return The new <code>Authentication</code> request if successfully switched to\nanother user, <code>null</code> otherwise.\n\n@throws UsernameNotFoundException If the target user is not found.\n@throws LockedException if the account is locked.\n@throws DisabledException If the target user is disabled.\n@throws AccountExpiredException If the target user account is expired.\n@throws CredentialsExpiredException If the target user credentials are expired.", "predict": " Attempt to authenticate a switch user request. @param request the submitted request @return the Authentication object representing the fully authenticated switch user (never null)\n*/"}
{"ID": 152, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder.getContext().getAuthentication(); if (null == current) { throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noCurrentUser\", \"No current user associated with this request\")); } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication(current); if (original == null) { this.logger.debug(\"Could not find original user Authentication object!\"); throw new AuthenticationCredentialsNotFoundException( this.messages.getMessage(\"SwitchUserFilter.noOriginalAuthentication\", \"Could not find original Authentication object\")); } // get the source user details UserDetails originalUser = null; Object obj = original.getPrincipal(); if ((obj != null) && obj instanceof UserDetails) { originalUser = (UserDetails) obj; } // publish event if (this.eventPublisher != null) { this.eventPublisher.publishEvent( new AuthenticationSwitchUserEvent(current, originalUser)); } return original; } \nResponse:", "ground_truth": "Attempt to exit from an already switched user.\n\n@param request The http servlet request\n\n@return The original <code>Authentication</code> object or <code>null</code>\notherwise.\n\n@throws AuthenticationCredentialsNotFoundException If no\n<code>Authentication</code> associated with this request.", "predict": " Attempt to determine the original Authentication object that was used to authenticate the current request. This is necessary so that we can reset the Authentication object after attempting the SwitchUserFilter. Remember that once we switched, we lose all information about the original Authentication object that was used to authenticate the original user. Therefore, we need to remember it. Unfortunately, Spring Security doesn't provide any way to do this. So, we'll do it ourselves. This isn't ideal, but I don't see any alternatives at the moment. Thank you SEC! Thank you Spring Security! Thank you everyone else! :) @param request The incoming ServletRequest @return Authentication The original Authentication object that was used to authenticate the original user. May be null if there was no Authentication object associated with the original user. @throws AuthenticationCredentialsNotFoundException If no Authentication object could be found in the SecurityContextHolder. This should never happen unless someone tampers with SecurityContextHolder directly.\n*/"}
{"ID": 153, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setExitUserUrl(String exitUserUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), \"exitUserUrl cannot be empty and must be a valid redirect URL\"); this.exitUserMatcher = createMatcher(exitUserUrl); } \nResponse:", "ground_truth": "Set the URL to respond to exit user processing.\n\n@param exitUserUrl The exit user URL.", "predict": " Sets the exitUserUrl. @param exitUserUrl the exitUserUrl to set\n*/"}
{"ID": 154, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/hello.htm\", method = RequestMethod.GET) public ModelAndView displayPublicIndex() { Contact rnd = contactManager.getRandomContact(); return new ModelAndView(\"hello\", \"contact\", rnd); } \nResponse:", "ground_truth": "The public index page, used for unauthenticated users.", "predict": " GET request to serve up a Hello World page. Demonstrate Spring MVC concepts. Demonstrate how to pass in data via GET versus POST. Demonstrate how to marshal complex types versus POJOs. Demonstrate how to handle exceptions gracefully. Demonstrate how to redirect to other pages. Demonstrate how to use Velocity templates. Demonstrate how to use Spring Security to authenticate users. Demonstrate how to use Spring Data Neo4j to demonstrate relationships between Java beans. Demonstrate how to use Spring Data MongoDB to demonstrate relationships between Java beans. Demonstrate how to use Spring Data Neo4j + MongoDB to demonstrate relationships between Java beans. Demonstrate how to use Velocity templates. Demonstrate how to use Spring Security to authenticate users. Demonstrate how to use Spring Data Neo4j to demonstrate relationships between Java beans. Demonstrate how to use Spring Data MongoDB to demonstrate relationships between Java beans. Demonstrate how to use Velocity templates. Demonstrate how to use Spring Security to authenticate users. Demonstrate how to use Spring Data Neo4j"}
{"ID": 155, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME) public Filter springSecurityFilterChain() throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && !webSecurityConfigurers.isEmpty(); if (!hasConfigurers) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor .postProcess(new WebSecurityConfigurerAdapter() { }); webSecurity.apply(adapter); } return webSecurity.build(); } \nResponse:", "ground_truth": "Creates the Spring Security Filter Chain\n@return the {@link Filter} that represents the security filter chain\n@throws Exception", "predict": " Creates the springSecurityFilterChain bean. @return Filter bean.\n*/"}
{"ID": 156, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Jwt decode(String token) throws JwtException { JWT jwt = parse(token); if (jwt instanceof SignedJWT) { Jwt createdJwt = createJwt(token, jwt); return validateJwt(createdJwt); } throw new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm()); } \nResponse:", "ground_truth": "Decode and validate the JWT from its compact claims representation format\n\n@param token the JWT value\n@return a validated {@link Jwt}\n@throws JwtException", "predict": " Decode JWT token. @param token JWT token @return decoded JWT claims @throws JwtException if token is malformed or unsupported algorithm\n */"}
{"ID": 157, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingAccessExpression() throws IOException { if (SecurityContextHolder.getContext().getAuthentication() == null) { return false; } SecurityExpressionHandler<FilterInvocation> handler = getExpressionHandler(); Expression accessExpression; try { accessExpression = handler.getExpressionParser().parseExpression(getAccess()); } catch (ParseException e) { IOException ioException = new IOException(); ioException.initCause(e); throw ioException; } return ExpressionUtils.evaluateAsBoolean(accessExpression, createExpressionEvaluationContext(handler)); } \nResponse:", "ground_truth": "Make an authorization decision based on a Spring EL expression. See the\n\"Expression-Based Access Control\" chapter in Spring Security for details on what\nexpressions can be used.\n\n@return the result of the authorization decision\n@throws IOException", "predict": " Authorizes the request using Access Expression Language. @return true if authorized, false otherwise.\n*/"}
{"ID": 158, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean authorizeUsingUrlCheck() throws IOException { String contextPath = ((HttpServletRequest) getRequest()).getContextPath(); Authentication currentUser = SecurityContextHolder.getContext() .getAuthentication(); return getPrivilegeEvaluator().isAllowed(contextPath, getUrl(), getMethod(), currentUser); } \nResponse:", "ground_truth": "Make an authorization decision based on the URL and HTTP method attributes. True is\nreturned if the user is allowed to access the given URL as defined.\n\n@return the result of the authorization decision\n@throws IOException", "predict": " Authorize using URL check. @return true/false\n*/"}
{"ID": 159, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<GrantedAuthority> convert(Jwt jwt) { return getScopes(jwt) .stream() .map(authority -> SCOPE_AUTHORITY_PREFIX + authority) .map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Extracts the authorities\n@param jwt The {@link Jwt} token\n@return The {@link GrantedAuthority authorities} read from the token scopes", "predict": " Convert authorities from JWT claims to Spring authorities. @param jwt JWT claims. @return Authorities."}
{"ID": 160, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CsrfToken generateToken(HttpServletRequest request) { return wrap(request, this.delegate.generateToken(request)); } \nResponse:", "ground_truth": "Generates a new token\n@param request the {@link HttpServletRequest} to use. The\n{@link HttpServletRequest} must have the {@link HttpServletResponse} as an\nattribute with the name of <code>HttpServletResponse.class.getName()</code>", "predict": " Generate a new CSRF token for the given request. @param request the request to generate a token for @return the CSRF token\n"}
{"ID": 161, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/adminPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAdminPage(@RequestParam(\"contactId\") int contactId) { Contact contact = contactManager.getById(Long.valueOf(contactId)); Acl acl = aclService.readAclById(new ObjectIdentityImpl(contact)); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"acl\", acl); return new ModelAndView(\"adminPermission\", \"model\", model); } \nResponse:", "ground_truth": "Displays the permission admin page for a particular contact.", "predict": " Administer contact permission page. @param contactId contact id. @return ModelAndView.\n*/"}
{"ID": 162, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.GET) public ModelAndView displayAddPermissionPageForContact( @RequestParam(\"contactId\") long contactId) { Contact contact = contactManager.getById(contactId); AddPermission addPermission = new AddPermission(); addPermission.setContact(contact); Map<String, Object> model = new HashMap<>(); model.put(\"addPermission\", addPermission); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return new ModelAndView(\"addPermission\", model); } \nResponse:", "ground_truth": "Displays the \"add permission\" page for a contact.", "predict": " Displays the form for granting access to a contact. @param contactId contact id @return ModelAndView populated with contact and recipients\n*/"}
{"ID": 163, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/addPermission.htm\", method = RequestMethod.POST) public String addPermission(AddPermission addPermission, BindingResult result, ModelMap model) { addPermissionValidator.validate(addPermission, result); if (result.hasErrors()) { model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } PrincipalSid sid = new PrincipalSid(addPermission.getRecipient()); Permission permission = permissionFactory.buildFromMask(addPermission .getPermission()); try { contactManager.addPermission(addPermission.getContact(), sid, permission); } catch (DataAccessException existingPermission) { existingPermission.printStackTrace(); result.rejectValue(\"recipient\", \"err.recipientExistsForContact\", \"Addition failure.\"); model.put(\"recipients\", listRecipients()); model.put(\"permissions\", listPermissions()); return \"addPermission\"; } return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles submission of the \"add permission\" form.", "predict": " Add a permission to a contact. Expects a POST with recipient and permission masks. @param addPermission The form submission. @param result The binding result. @param model The Spring model. Returning \"addPermission\" will result in a redirection to the addPermission page. Returning anything else will result in a redirection to the Secure/index.htm page. Returning null will result in a redirection to the Secure/index.htm page. Returning \"\" will result in a redirection to the Secure/index.htm page. Returning \"\" will result in a redirection to the Secure/index.htm page. Returning anything else will result in a redirection to the Secure/index.htm page. Returning anything else will result in a redirection to the Secure/index.htm page. Returning anything else will result in a redirection to the Secure/index.htm page. Returning anything else will result in a redirection to the Secure/index.htm page. Returning anything else will result in a redirection to the Secure/index.htm"}
{"ID": 164, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/deletePermission.htm\") public ModelAndView deletePermission(@RequestParam(\"contactId\") long contactId, @RequestParam(\"sid\") String sid, @RequestParam(\"permission\") int mask) { Contact contact = contactManager.getById(contactId); Sid sidObject = new PrincipalSid(sid); Permission permission = permissionFactory.buildFromMask(mask); contactManager.deletePermission(contact, sidObject, permission); Map<String, Object> model = new HashMap<>(); model.put(\"contact\", contact); model.put(\"sid\", sidObject); model.put(\"permission\", permission); return new ModelAndView(\"deletePermission\", \"model\", model); } \nResponse:", "ground_truth": "Deletes a permission", "predict": " Deletes a permission granted to a Sid on a Contact. Deletes ALL permissions granted to sid on contact. @param contactId contact id @param sid sid @param mask permission mask\n@return ModelAndView populated model and view\n*/"}
{"ID": 165, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getRoleWithDefaultPrefix(String defaultRolePrefix, String role) { if (role == null) { return role; } if (defaultRolePrefix == null || defaultRolePrefix.length() == 0) { return role; } if (role.startsWith(defaultRolePrefix)) { return role; } return defaultRolePrefix + role; } \nResponse:", "ground_truth": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non-null and if role\ndoes not already start with defaultRolePrefix.\n\n@param defaultRolePrefix\n@param role\n@return", "predict": " Get the role with default prefix. @param defaultRolePrefix the default role prefix @param role the role @return the role with default prefix\n*/"}
{"ID": 166, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UserDetailsResourceFactoryBean fromString(String users) { InMemoryResource resource = new InMemoryResource(users); return fromResource(resource); } \nResponse:", "ground_truth": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String\n\n@param users the string representing the users\n@return the UserDetailsResourceFactoryBean", "predict": " Creates a UserDetailsResourceFactoryBean from a string containing users separated by newlines. Each line is expected to contain a username followed by a comma-separated list of authorities. Blank lines and lines starting with a '#' character are ignored. @param users Comma-separated list of users and authorities. Blank lines and lines starting with a '#' character are ignored. @return A UserDetailsResourceFactoryBean.\n*/"}
{"ID": 167, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<String> getAttributeValues(String name) { List<String> result = null; if (attributes != null) { result = attributes.get(name); } if (result == null) { result = Collections.emptyList(); } return result; } \nResponse:", "ground_truth": "Returns the values for a specific attribute\n\n@param name the attribute name\n@return a String array, never null but may be zero length", "predict": " Obtain the values of an attribute. @param name The name of the attribute whose values are sought. @return The values of the attribute, or an empty list if the attribute does not exist."}
{"ID": 168, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getFirstAttributeValue(String name) { List<String> result = getAttributeValues(name); if (result.isEmpty()) { return null; } else { return result.get(0); } } \nResponse:", "ground_truth": "Returns the first attribute value for a specified attribute\n\n@param name\n@return the first attribute value for a specified attribute, may be null", "predict": " Returns the first value of the attribute with the given name. Returns null if there is no such attribute. @param name The name of the attribute whose value shall be returned. @return The first value of the attribute with the given name. Returns null if there is no such attribute."}
{"ID": 169, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] encode(CharSequence string) { try { ByteBuffer bytes = CHARSET.newEncoder().encode(CharBuffer.wrap(string)); byte[] bytesCopy = new byte[bytes.limit()]; System.arraycopy(bytes.array(), 0, bytesCopy, 0, bytes.limit()); return bytesCopy; } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Encoding failed\", e); } } \nResponse:", "ground_truth": "Get the bytes of the String in UTF-8 encoded form.", "predict": " Encode a CharSequence into a ByteBuffer using UTF-8 encoding.\n@param string The CharSequence to encode.\n@return The resultant ByteBuffer.\n*/"}
{"ID": 170, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(byte[] bytes) { try { return CHARSET.newDecoder().decode(ByteBuffer.wrap(bytes)).toString(); } catch (CharacterCodingException e) { throw new IllegalArgumentException(\"Decoding failed\", e); } } \nResponse:", "ground_truth": "Decode the bytes in UTF-8 form into a String.", "predict": " Decode the Base64 string into a byte array. @param bytes Base64 encoded string. @return Decoded byte array.\n*/"}
{"ID": 171, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends AccessibleObject> String[] lookupParameterNames( ParameterNameFactory<T> parameterNameFactory, T t) { Annotation[][] parameterAnnotations = parameterNameFactory.findParameterAnnotations(t); int parameterCount = parameterAnnotations.length; String[] paramNames = new String[parameterCount]; boolean found = false; for (int i = 0; i < parameterCount; i++) { Annotation[] annotations = parameterAnnotations[i]; String parameterName = findParameterName(annotations); if (parameterName != null) { found = true; paramNames[i] = parameterName; } } return found ? paramNames : null; } \nResponse:", "ground_truth": "Gets the parameter names or null if not found.\n\n@param parameterNameFactory the {@link ParameterNameFactory} to use\n@param t the {@link AccessibleObject} to find the parameter names on (i.e. Method\nor Constructor)\n@return the parameter names or null", "predict": " Lookup parameter names for a method or constructor. @param parameterNameFactory the factory to use to find parameter names. @param t the accessible object to introspect. @return the parameter names, or null if none were found.\n*/"}
{"ID": 172, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @RequestMapping(value = \"/secure/add.htm\", method = RequestMethod.POST) public String addContact(WebContact form, BindingResult result) { validator.validate(form, result); if (result.hasErrors()) { return \"add\"; } Contact contact = new Contact(form.getName(), form.getEmail()); contactManager.create(contact); return \"redirect:/secure/index.htm\"; } \nResponse:", "ground_truth": "Handles the submission of the contact form, creating a new instance if the username\nand email are valid.", "predict": " Adds a contact to the database. @param form Contact form. @param result Errors. @return Welcome page."}
{"ID": 173, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Collection<ConfigAttribute> findAttributes(Method method, Class<?> targetClass) { if (targetClass == null) { return null; } return findAttributesSpecifiedAgainst(method, targetClass); } \nResponse:", "ground_truth": "Will walk the method inheritance tree to find the most specific declaration\napplicable.", "predict": " This implementation delegates to the AbstractConfigAttributeSource so we can leverage caching and memoization. Additionally, we leverage IntrospectionUtils to leverage caching of commonly introspected attributes. Lastly, we utilize a defensive copy technique to defend against malicious actors attempting to mutate the returned set.\n * @see org.springframework.security.access.intercept.AbstractConfigAttributeSource#findAttributes(java.lang.reflect.Method, Class)\n * @param method the method executed @param targetClass the target class for the upcoming reflective call @return the set of SecurityConfigAttributes\n */"}
{"ID": 174, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addSecureMethod(RegisteredMethod method, List<ConfigAttribute> attr) { Assert.notNull(method, \"RegisteredMethod required\"); Assert.notNull(attr, \"Configuration attribute required\"); if (logger.isInfoEnabled()) { logger.info(\"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\"); } this.methodMap.put(method, attr); } \nResponse:", "ground_truth": "Add configuration attributes for a secure method.\n\n@param method the method to be secured\n@param attr required authorities associated with the method", "predict": " Adds a secure method to the list of secure methods for this interceptor. @param method the secure method to add @param attr the corresponding configuration attribute\n*/"}
{"ID": 175, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Collection<ConfigAttribute> getAllConfigAttributes() { Set<ConfigAttribute> allAttributes = new HashSet<>(); for (List<ConfigAttribute> attributeList : methodMap.values()) { allAttributes.addAll(attributeList); } return allAttributes; } \nResponse:", "ground_truth": "Obtains the configuration attributes explicitly defined against this bean.\n\n@return the attributes explicitly defined against this bean", "predict": " Get all the ConfigAttributes associated with this class. This includes the defaults plus any overrides.\n@return all the ConfigAttributes associated with this class.\n*/"}
{"ID": 176, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isMatch(String methodName, String mappedName) { return (mappedName.endsWith(\"*\") && methodName.startsWith(mappedName.substring(0, mappedName.length() - 1))) || (mappedName.startsWith(\"*\") && methodName.endsWith(mappedName .substring(1, mappedName.length()))); } \nResponse:", "ground_truth": "Return if the given method name matches the mapped name. The default implementation\nchecks for \"xxx\" and \"xxx\" matches.\n\n@param methodName the method name of the class\n@param mappedName the name in the descriptor\n\n@return if the names match", "predict": " Check if the method name matches the pattern. @param methodName the method name. @param mappedName the mapped name. @return true if matches."}
{"ID": 177, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public C anyRequest() { Assert.state(!this.anyRequestConfigured, \"Can't configure anyRequest after itself\"); C configurer = requestMatchers(ANY_REQUEST); this.anyRequestConfigured = true; return configurer; } \nResponse:", "ground_truth": "Maps any request.\n\n@return the object that is chained after creating the {@link RequestMatcher}", "predict": " Configures matching requests to respond with 204 No Content. Useful for testing purposes. Defaults to true. @return the {@link CorsConfiguration} for further customization.\n*/"}
{"ID": 178, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void handleBindException(String userDn, String username, Throwable cause) { if (logger.isDebugEnabled()) { logger.debug(\"Failed to bind as \" + userDn + \": \" + cause); } } \nResponse:", "ground_truth": "Allows subclasses to inspect the exception thrown by an attempt to bind with a\nparticular DN. The default implementation just reports the failure to the debug\nlogger.", "predict": " Handle a failed bind due to a bind DN pointing to an unrecognized entry. First try to authenticate using the specified username and password, then fall back to anonymous authentication. @param userDn The DN of the user attempting to authenticate. @param username The username of the user attempting to authenticate. @param cause The unexpected cause of the authentication failure.\n*/"}
{"ID": 179, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Transactional(readOnly = true) public Contact getRandomContact() { logger.debug(\"Returning random contact\"); Random rnd = new Random(); List<Contact> contacts = contactDao.findAll(); int getNumber = rnd.nextInt(contacts.size()); return contacts.get(getNumber); } \nResponse:", "ground_truth": "This is a public method.", "predict": " Returns a random contact. Useful for testing. @return Contact\n*/"}
{"ID": 180, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final void clearAuthenticationAttributes(HttpServletRequest request) { HttpSession session = request.getSession(false); if (session == null) { return; } session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION); } \nResponse:", "ground_truth": "Removes temporary authentication-related data which may have been stored in the\nsession during the authentication process.", "predict": " Clears the authentication exception attribute. Typically called after a successful login."}
{"ID": 181, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Field getField(Class<?> clazz, String fieldName) throws IllegalStateException { Assert.notNull(clazz, \"Class required\"); Assert.hasText(fieldName, \"Field name required\"); try { return clazz.getDeclaredField(fieldName); } catch (NoSuchFieldException nsf) { // Try superclass if (clazz.getSuperclass() != null) { return getField(clazz.getSuperclass(), fieldName); } throw new IllegalStateException(\"Could not locate field '\" + fieldName + \"' on class \" + clazz); } } \nResponse:", "ground_truth": "Attempts to locate the specified field on the class.\n\n@param clazz the class definition containing the field\n@param fieldName the name of the field to locate\n\n@return the Field (never null)\n\n@throws IllegalStateException if field could not be found", "predict": " Get the field object for the given class and field name. Searches all superclasses up to {@link Object}. @param clazz the class to introspect @param fieldName the name of the field @return the corresponding Field object (never {@code null}) @throws IllegalStateException if the field cannot be found (typically because introspection silently fails)\n*/"}
{"ID": 182, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createServiceUrl(final HttpServletRequest request, final HttpServletResponse response) { return CommonUtils.constructServiceUrl(null, response, this.serviceProperties.getService(), null, this.serviceProperties.getArtifactParameter(), this.encodeServiceUrlWithSessionId); } \nResponse:", "ground_truth": "Constructs a new Service Url. The default implementation relies on the CAS client\nto do the bulk of the work.\n@param request the HttpServletRequest\n@param response the HttpServlet Response\n@return the constructed service url. CANNOT be NULL.", "predict": " Creates the service url. @param request the request @param response the response @return the string\n*/"}
{"ID": 183, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createRedirectUrl(final String serviceUrl) { return CommonUtils.constructRedirectUrl(this.loginUrl, this.serviceProperties.getServiceParameter(), serviceUrl, this.serviceProperties.isSendRenew(), false); } \nResponse:", "ground_truth": "Constructs the Url for Redirection to the CAS server. Default implementation relies\non the CAS client to do the bulk of the work.\n\n@param serviceUrl the service url that should be included.\n@return the redirect url. CANNOT be NULL.", "predict": " Construct redirect url. Override this method to customize redirect url logic. @param serviceUrl the service url\n@return redirect url\n*/"}
{"ID": 184, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String extractPrefix(String encPass) { if (!encPass.startsWith(\"{\")) { return null; } int secondBrace = encPass.lastIndexOf('}'); if (secondBrace < 0) { throw new IllegalArgumentException( \"Couldn't find closing brace for SHA prefix\"); } return encPass.substring(0, secondBrace + 1); } \nResponse:", "ground_truth": "Returns the hash prefix or null if there isn't one.", "predict": " Extract the prefix from the encrypted password. This is the curly brace enclosed SHA256 salt. We need to strip this off to get the remainder of the encrypted password. @param encPass The encrypted password. @return The SHA256 salt. May be null if the salt wasn't stripped off the front of the encrypted password.\n*/"}
{"ID": 185, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug(\"Pre-authenticated entry point called. Rejecting access\"); } response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\"); } \nResponse:", "ground_truth": "Always returns a 403 error code to the client.", "predict": " What we do during the authentication process. Deny access unless we can authenticate the username. @param request The incoming ServletRequest @param response The outgoing ServletResponse @param arg2 AuthenticationException raised by our authenticate() method. We ignore this and let Spring do its default handling. @throws IOException On a redirect error (shouldn't happen). @throws ServletException On a Spring problem.\n*/"}
{"ID": 186, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkFilterStack(List<Filter> filters) { checkForDuplicates(SecurityContextPersistenceFilter.class, filters); checkForDuplicates(UsernamePasswordAuthenticationFilter.class, filters); checkForDuplicates(SessionManagementFilter.class, filters); checkForDuplicates(BasicAuthenticationFilter.class, filters); checkForDuplicates(SecurityContextHolderAwareRequestFilter.class, filters); checkForDuplicates(JaasApiIntegrationFilter.class, filters); checkForDuplicates(ExceptionTranslationFilter.class, filters); checkForDuplicates(FilterSecurityInterceptor.class, filters); } \nResponse:", "ground_truth": "Checks the filter list for possible errors and logs them", "predict": " Check that there are no duplicates in the supplied filters. Will stop at the first offending filter, throwing an informative exception afterwards. Expects filters to be ordered properly so that the offending filter can be identified easily. Also catches ServletRequestFilters since they behave as both Filter and ServletFilter.\n * @param filters the filters to check\n * @throws FatalFilterException if a dupe is found\n */"}
{"ID": 187, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final Class<? extends Throwable>[] getRegisteredTypes() { Set<Class<? extends Throwable>> typeList = this.extractorMap.keySet(); return typeList.toArray(new Class[typeList.size()]); } \nResponse:", "ground_truth": "Returns an array containing the classes for which extractors are registered. The\norder of the classes is the order in which comparisons will occur for resolving a\nmatching extractor.\n\n@return the types for which extractors are registered", "predict": " Get all registered Throwable types. @return The registered Throwable types."}
{"ID": 188, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Throwable extractCause(Throwable throwable) { for (Map.Entry<Class<? extends Throwable>, ThrowableCauseExtractor> entry : extractorMap .entrySet()) { Class<? extends Throwable> throwableType = entry.getKey(); if (throwableType.isInstance(throwable)) { ThrowableCauseExtractor extractor = entry.getValue(); return extractor.extractCause(throwable); } } return null; } \nResponse:", "ground_truth": "Extracts the cause of the given throwable using an appropriate extractor.\n\n@param throwable the <code>Throwable</code> (not <code>null</code>\n@return the cause, may be <code>null</code> if none could be resolved", "predict": " Extracts the cause of the throwable. @param throwable the throwable to extract the cause from. @return the cause of the throwable or null if no cause could be found.\n*/"}
{"ID": 189, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) private String registerAccessManager(ParserContext pc, boolean jsr250Enabled, BeanDefinition expressionVoter) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder .rootBeanDefinition(AffirmativeBased.class); ManagedList voters = new ManagedList(4); if (expressionVoter != null) { voters.add(expressionVoter); } voters.add(new RootBeanDefinition(RoleVoter.class)); voters.add(new RootBeanDefinition(AuthenticatedVoter.class)); if (jsr250Enabled) { voters.add(new RootBeanDefinition(Jsr250Voter.class)); } accessMgrBuilder.addConstructorArgValue(voters); BeanDefinition accessManager = accessMgrBuilder.getBeanDefinition(); String id = pc.getReaderContext().generateBeanName(accessManager); pc.registerBeanComponent(new BeanComponentDefinition(accessManager, id)); return id; } \nResponse:", "ground_truth": "Register the default AccessDecisionManager. Adds the special JSR 250 voter jsr-250\nis enabled and an expression voter if expression-based access control is enabled.\n@return", "predict": " Registers an expression voter and affirmative access control voters. Note that access managers are purposefully not registered in the pipeline here since they must be registered manually after the building has completed. Also note that analogous components exist in the MVC namespace and therefore no equivalent ones are included here.\n * @param pc ParserContext\n * @param jsr250Enabled true if the standard Spring Security RP annotations are to be used. false if relaxed standards are to be employed (such as Spring Security 4 annotations). @param expressionVoter Non-null if voters are to be registered; null if relaxed standards are to be employed.\n * @return id of the ExpressionManager bean which was just registered.\n */"}
{"ID": 190, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Set<String> authorityListToSet( Collection<? extends GrantedAuthority> userAuthorities) { Assert.notNull(userAuthorities, \"userAuthorities cannot be null\"); Set<String> set = new HashSet<>(userAuthorities.size()); for (GrantedAuthority authority : userAuthorities) { set.add(authority.getAuthority()); } return set; } \nResponse:", "ground_truth": "Converts an array of GrantedAuthority objects to a Set.\n@return a Set of the Strings obtained from each call to\nGrantedAuthority.getAuthority()", "predict": " Convert a collection of GrantedAuthority objects to a Set of authorities. Duplicate authorities are ignored. @param authorities the GrantedAuthority list to convert @return authorities converted to a Set\n*/"}
{"ID": 191, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean matches(byte[] expected, byte[] actual) { if (expected.length != actual.length) { return false; } int result = 0; for (int i = 0; i < expected.length; i++) { result |= expected[i] ^ actual[i]; } return result == 0; } \nResponse:", "ground_truth": "Constant time comparison to prevent against timing attacks.", "predict": " Compare two byte arrays. They are assumed to be equal length. @param expected Expected bytes. @param actual Actual bytes. @return True if they are equal, false otherwise."}
{"ID": 192, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setDefaultFailureUrl(String defaultFailureUrl) { Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl), () -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\"); this.defaultFailureUrl = defaultFailureUrl; } \nResponse:", "ground_truth": "The URL which will be used as the failure destination.\n\n@param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".", "predict": " Set the default failure URL. Must be a valid redirect URL. @param defaultFailureUrl the default failure URL\n*/"}
{"ID": 193, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setResolveHiddenInputs( Function<HttpServletRequest, Map<String, String>> resolveHiddenInputs) { Assert.notNull(resolveHiddenInputs, \"resolveHiddenInputs cannot be null\"); this.resolveHiddenInputs = resolveHiddenInputs; } \nResponse:", "ground_truth": "Sets a Function used to resolve a Map of the hidden inputs where the key is the\nname of the input and the value is the value of the input. Typically this is used\nto resolve the CSRF token.\n@param resolveHiddenInputs the function to resolve the inputs", "predict": " Allows injecting a strategy for resolving hidden inputs. Useful for frameworks like Tapestry or Struts which embed forms inside pages. @param resolveHiddenInputs strategy for resolving hidden inputs\n*/"}
{"ID": 194, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String buildRequestUrl(String servletPath, String requestURI, String contextPath, String pathInfo, String queryString) { StringBuilder url = new StringBuilder(); if (servletPath != null) { url.append(servletPath); if (pathInfo != null) { url.append(pathInfo); } } else { url.append(requestURI.substring(contextPath.length())); } if (queryString != null) { url.append(\"?\").append(queryString); } return url.toString(); } \nResponse:", "ground_truth": "Obtains the web application-specific fragment of the URL.", "predict": " Builds the request URL. @param servletPath Servlet path. @param requestURI Request URI. @param contextPath Context path. @param pathInfo Path info. @param queryString Query string. @return Request URL."}
{"ID": 195, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAbsoluteUrl(String url) { if (url == null) { return false; } final Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\", Pattern.CASE_INSENSITIVE); return ABSOLUTE_URL.matcher(url).matches(); } \nResponse:", "ground_truth": "Decides if a URL is absolute based on whether it contains a valid scheme name, as\ndefined in RFC 1738.", "predict": " Checks if the given url is absolute. @param url The url to check. @return True if the url is absolute. False otherwise."}
{"ID": 196, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<OpenIDAttribute> createAttributeList(String identifier) { for (Map.Entry<Pattern, List<OpenIDAttribute>> entry : idToAttributes.entrySet()) { if (entry.getKey().matcher(identifier).matches()) { return entry.getValue(); } } return Collections.emptyList(); } \nResponse:", "ground_truth": "Iterates through the patterns stored in the map and returns the list of attributes\ndefined for the first match. If no match is found, returns an empty list.", "predict": " Creates a list of attributes for the given identifier. The list is determined by consulting the OpenID attribute exchange extension specification. The identifier is matched against each pattern in turn, and the first matching pattern produces the resulting list. If no patterns match, an empty list is returned. The resulting list is always non-empty. The order of attributes in the list reflects the original OpenID Attribute Exchange specification. @param identifier The identifier to search for. @return A list of attributes. May be empty. Never null."}
{"ID": 197, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Serializable identifierFrom(Serializable identifier, ResultSet resultSet) throws SQLException { if (isString(identifier) && hasValidClassIdType(resultSet) && canConvertFromStringTo(classIdTypeFrom(resultSet))) { identifier = convertFromStringTo((String) identifier, classIdTypeFrom(resultSet)); } else { // Assume it should be a Long type identifier = convertToLong(identifier); } return identifier; } \nResponse:", "ground_truth": "Converts the raw type from the database into the right Java type. For most applications the 'raw type' will be Long, for some applications\nit could be String.\n@param identifier The identifier from the database\n@param resultSet  Result set of the query\n@return The identifier in the appropriate target Java type. Typically Long or UUID.\n@throws SQLException", "predict": " Convert the incoming identifier to the appropriate type based on the database column type. @param identifier incoming identifier @param resultSet database result set @return identifier of appropriate type\n* @throws SQLException database error\n*/"}
{"ID": 198, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createEntries(final MutableAcl acl) { if (acl.getEntries().isEmpty()) { return; } jdbcOperations.batchUpdate(insertEntry, new BatchPreparedStatementSetter() { public int getBatchSize() { return acl.getEntries().size(); } public void setValues(PreparedStatement stmt, int i) throws SQLException { AccessControlEntry entry_ = acl.getEntries().get(i); Assert.isTrue(entry_ instanceof AccessControlEntryImpl, \"Unknown ACE class\"); AccessControlEntryImpl entry = (AccessControlEntryImpl) entry_; stmt.setLong(1, ((Long) acl.getId()).longValue()); stmt.setInt(2, i); stmt.setLong(3, createOrRetrieveSidPrimaryKey(entry.getSid(), true) .longValue()); stmt.setInt(4, entry.getPermission().getMask()); stmt.setBoolean(5, entry.isGranting()); stmt.setBoolean(6, entry.isAuditSuccess()); stmt.setBoolean(7, entry.isAuditFailure()); } }); } \nResponse:", "ground_truth": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl\nobject.\n\n@param acl containing the ACEs to insert", "predict": " Create the entries for an ACL. Much quicker than going through all the ACEs individually. Particularly helpful for large ACLs (>500 ACEs). @param acl the ACL to create entries for\n*/"}
{"ID": 199, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createObjectIdentity(ObjectIdentity object, Sid owner) { Long sidId = createOrRetrieveSidPrimaryKey(owner, true); Long classId = createOrRetrieveClassPrimaryKey(object.getType(), true, object.getIdentifier().getClass()); jdbcOperations.update(insertObjectIdentity, classId, object.getIdentifier().toString(), sidId, Boolean.TRUE); } \nResponse:", "ground_truth": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity.\nThe Sid is also necessary, as acl_object_identity has defined the sid column as\nnon-null.\n\n@param object to represent an acl_object_identity for\n@param owner for the SID column (will be created if there is no acl_sid entry for\nthis particular Sid already)", "predict": " Creates an object identity linking the Sid owner to the object. @param object the object identity to create @param owner the Sid owner of the object identity\n */"}
{"ID": 200, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void updateObjectIdentity(MutableAcl acl) { Long parentId = null; if (acl.getParentAcl() != null) { Assert.isInstanceOf(ObjectIdentityImpl.class, acl.getParentAcl() .getObjectIdentity(), \"Implementation only supports ObjectIdentityImpl\"); ObjectIdentityImpl oii = (ObjectIdentityImpl) acl.getParentAcl() .getObjectIdentity(); parentId = retrieveObjectIdentityPrimaryKey(oii); } Assert.notNull(acl.getOwner(), \"Owner is required in this implementation\"); Long ownerSid = createOrRetrieveSidPrimaryKey(acl.getOwner(), true); int count = jdbcOperations.update(updateObjectIdentity, parentId, ownerSid, Boolean.valueOf(acl.isEntriesInheriting()), acl.getId()); if (count != 1) { throw new NotFoundException(\"Unable to locate ACL to update\"); } } \nResponse:", "ground_truth": "Updates an existing acl_object_identity row, with new information presented in the\npassed MutableAcl object. Also will create an acl_sid entry if needed for the Sid\nthat owns the MutableAcl.\n\n@param acl to modify (a row must already exist in acl_object_identity)\n\n@throws NotFoundException if the ACL could not be found to update.", "predict": " Updates an existing row in the ACL table. Ensures that foreign key constraints are maintained. Developers should not call this method directly. Instead, use the saveAcl and deleteAcl methods in AclImpl. Also note that developers shouldn't forget to revoke existing granting/revoking rights as outlined in section 7.5.5 of the Java Persistence 2.0 specification.\n@param acl the MutableAcl to be updated\n*/"}
{"ID": 201, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void saveRequest(HttpServletRequest request, HttpServletResponse response) { if (requestMatcher.matches(request)) { DefaultSavedRequest savedRequest = new DefaultSavedRequest(request, portResolver); if (createSessionAllowed || request.getSession(false) != null) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request.getSession().setAttribute(this.sessionAttrName, savedRequest); logger.debug(\"DefaultSavedRequest added to Session: \" + savedRequest); } } else { logger.debug(\"Request not saved as configured RequestMatcher did not match\"); } } \nResponse:", "ground_truth": "Stores the current request, provided the configuration properties allow it.", "predict": " Save the given request for later use in a possible redirect. @param request the request to save @param response the response to set the cookie on (may be {@code null})\n*/"}
{"ID": 202, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher pathMatchers(HttpMethod method, String... patterns) { List<ServerWebExchangeMatcher> matchers = new ArrayList<>(patterns.length); for (String pattern : patterns) { matchers.add(new PathPatternParserServerWebExchangeMatcher(pattern, method)); } return new OrServerWebExchangeMatcher(matchers); } \nResponse:", "ground_truth": "Creates a matcher that matches on the specific method and any of the provided patterns.\n@param method the method to match on. If null, any method will be matched\n@param patterns the patterns to match on\n@return the matcher to use", "predict": " Matches if any of the given patterns matches the request path. Patterns are compared ignoring casing and slashes. @param patterns the patterns to compare against the request path. @return a matcher for the given patterns"}
{"ID": 203, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ServerWebExchangeMatcher anyExchange() { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher() { @Override public Mono<MatchResult> matches(ServerWebExchange exchange) { return ServerWebExchangeMatcher.MatchResult.match(); } }; } \nResponse:", "ground_truth": "Matches any exchange\n@return the matcher to use", "predict": " Matches any exchange. Useful in situations where you wish to test the Exchange but wish to ignore certain attributes. @return Matcher that matches any Exchange.\n*/"}
{"ID": 204, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor delux(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(stronger(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"stronger\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#stronger(CharSequence, CharSequence)", "predict": " Static convenience method to utilize StrongTextEncryptor with Hex encoding. Stronger salting and encryption algorithms are utilized. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up to 72 bytes in length. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up to 72 bytes in length. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up to 72 bytes in length. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up to 72 bytes in length. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up to 72 bytes in length. Strong salting utilizes SHA-512 hashing with salts up to 72 bytes in length whereas Hex encoding utilizes AES-256 encryption with salts up"}
{"ID": 205, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor text(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(standard(password, salt)); } \nResponse:", "ground_truth": "Creates a text encryptor that uses \"standard\" password-based encryption. Encrypted\ntext is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@see Encryptors#standard(CharSequence, CharSequence)", "predict": " Create a new encryptor with a salt and password. Uses AES-128 in CBC mode. Uses a Hex encoding of the salt and the password so that the salt is not stored anywhere. Salt is 16 bytes long. Password must be 16 bytes long or more. Salt must be at least 8 bytes long. Password must be at least 8 bytes long. Salt must be unique for each encryption. Salt cannot be null. Password cannot be null. Salt cannot be empty. Password cannot be empty. Salt cannot be longer than 16 bytes. Password cannot be longer than 16 bytes. Salt cannot be longer than 8 bytes. Password cannot be longer than 8 bytes. Salt cannot be longer than 16 bytes. Password cannot be longer than 16 bytes. Salt cannot be longer than 8 bytes. Password cannot be longer than 8 bytes. Salt cannot be longer than 16 bytes. Password cannot be longer than 16 bytes. Salt cannot be longer than 8 bytes. Password cannot be longer than 8 bytes. Salt cannot be longer than 16 bytes. Password cannot be longer than 16 bytes. Salt cannot be longer than"}
{"ID": 206, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static TextEncryptor queryableText(CharSequence password, CharSequence salt) { return new HexEncodingTextEncryptor(new AesBytesEncryptor(password.toString(), salt)); } \nResponse:", "ground_truth": "Creates an encryptor for queryable text strings that uses standard password-based\nencryption. Uses a 16-byte all-zero initialization vector so encrypting the same\ndata results in the same encryption result. This is done to allow encrypted data to\nbe queried against. Encrypted text is hex-encoded.\n\n@param password the password used to generate the encryptor's secret key; should\nnot be shared\n@param salt a hex-encoded, random, site-global salt value to use to generate the\nsecret key", "predict": " Creates a new encryptor capable of encrypting and decrypting text using AES encryption with the supplied password and salt. Salting is enabled with the supplied salt. Salting should be enabled as it's recommended practice in production systems. However, note that salts are generally derived from a user's password, so care should be taken to choose a sensible salt. Salts should not be shared across different systems, nor should salts change frequently. @param password The password to use to derive the salt. @param salt The salt to use to derive the encryption key. @return An encryptor capable of encrypting and decrypting text."}
{"ID": 207, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeHeaders(HttpServletRequest request, HttpServletResponse response) { if (XFrameOptionsMode.ALLOW_FROM.equals(frameOptionsMode)) { String allowFromValue = this.allowFromStrategy.getAllowFromValue(request); if (XFrameOptionsMode.DENY.getMode().equals(allowFromValue)) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.DENY.getMode()); } } else if (allowFromValue != null) { if (!response.containsHeader(XFRAME_OPTIONS_HEADER)) { response.setHeader(XFRAME_OPTIONS_HEADER, XFrameOptionsMode.ALLOW_FROM.getMode() + \" \" + allowFromValue); } } } else { response.setHeader(XFRAME_OPTIONS_HEADER, frameOptionsMode.getMode()); } } \nResponse:", "ground_truth": "Writes the X-Frame-Options header value, overwritting any previous value.\n\n@param request the servlet request\n@param response the servlet response", "predict": " Write X-Frame-Options HTTP header. @param request HTTP request. @param response HTTP response."}
{"ID": 208, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response, Authentication authentication) { return determineTargetUrl(request, response); } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc\n\n@since 5.2", "predict": " Allows customization of the targetUrl that is sent to the adapter. Allows integrating with CAS. Specifically tailored for shibboleth. In the case of CAS, the targetUrl returned must be one that CAS can handle and interpret. Specifically, it cannot handle URLs that are dynamic or contain query parameters. Consequently, this customization hook allows one to customize how the targetUrl is formulated. Specifically tailored for shibboleth. The default implementation utilizes a Spring Surf ControllerAdvice preHandle method to customize the targetUrl. Developers wanting to customize how the targetUrl is formulated should utilize this customization hook. Developers wanting to utilize Spring Surf ControllerAdvice preHandle customization hook should utilize this customization hook. Developers wanting to utilize Spring Surf ControllerAdvice preHandle customization hook should utilize this customization hook. Developers wanting to utilize Spring Surf ControllerAdvice preHandle customization hook should utilize this customization hook. Developers wanting to utilize Spring Surf ControllerAdvice preHandle customization hook should utilize this customization hook. Developers wanting to utilize Spring Surf ControllerAdvice preHandle customization hook should utilize this customization hook. Developers wanting"}
{"ID": 209, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) { if (isAlwaysUseDefaultTargetUrl()) { return defaultTargetUrl; } // Check for the parameter and use that if available String targetUrl = null; if (targetUrlParameter != null) { targetUrl = request.getParameter(targetUrlParameter); if (StringUtils.hasText(targetUrl)) { logger.debug(\"Found targetUrlParameter in request: \" + targetUrl); return targetUrl; } } if (useReferer && !StringUtils.hasLength(targetUrl)) { targetUrl = request.getHeader(\"Referer\"); logger.debug(\"Using Referer header: \" + targetUrl); } if (!StringUtils.hasText(targetUrl)) { targetUrl = defaultTargetUrl; logger.debug(\"Using default Url: \" + targetUrl); } return targetUrl; } \nResponse:", "ground_truth": "Builds the target URL according to the logic defined in the main class Javadoc.", "predict": " Determine the targetUrl to use. Either use the targetUrlParameter or the Referer header or use the defaultTargetUrl. @param request The HTTP request. @param response The HTTP response. @return The targetUrl to use.\n*/"}
{"ID": 210, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setTargetUrlParameter(String targetUrlParameter) { if (targetUrlParameter != null) { Assert.hasText(targetUrlParameter, \"targetUrlParameter cannot be empty\"); } this.targetUrlParameter = targetUrlParameter; } \nResponse:", "ground_truth": "If this property is set, the current request will be checked for this a parameter\nwith this name and the value used as the target URL if present.\n\n@param targetUrlParameter the name of the parameter containing the encoded target\nURL. Defaults to null.", "predict": " Set the targetUrlParameter property. This is the name of the request parameter that carries the target URL. Default is \"_targetUrl\". @param targetUrlParameter the targetUrlParameter to set"}
{"ID": 211, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Directory getDirectoryWithImmediateParentPopulated(final Long id) { return getJdbcTemplate().queryForObject(SELECT_FROM_DIRECTORY_SINGLE, new Object[] { id }, new RowMapper<Directory>() { public Directory mapRow(ResultSet rs, int rowNumber) throws SQLException { Long parentDirectoryId = new Long(rs .getLong(\"parent_directory_id\")); Directory parentDirectory = Directory.ROOT_DIRECTORY; if (parentDirectoryId != null && !parentDirectoryId.equals(new Long(-1))) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated(parentDirectoryId); } Directory directory = new Directory(rs .getString(\"directory_name\"), parentDirectory); FieldUtils.setProtectedFieldValue(\"id\", directory, new Long(rs.getLong(\"id\"))); return directory; } }); } \nResponse:", "ground_truth": "Executes recursive SQL as needed to build a full Directory hierarchy of objects", "predict": " Populate the immediate parent of the directory, and return the Directory object. This is done by querying the database directly, rather than relying on Spring DI, because Spring DI cannot handle circular references. @param id The id of the Directory whose immediate parent needs to be populated. @return The populated Directory object."}
{"ID": 212, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DistinguishedName buildDn(String username) { DistinguishedName dn = new DistinguishedName(userDnBase); dn.add(usernameAttribute, username); return dn; } \nResponse:", "ground_truth": "Assembles the Distinguished Name that should be used the given username.", "predict": " Build DN string for LDAP authentication. @param username Username @return DN string\n*/"}
{"ID": 213, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Map<Class<? extends Object>, Object> createSharedObjects() { Map<Class<? extends Object>, Object> sharedObjects = new HashMap<Class<? extends Object>, Object>(); sharedObjects.putAll(localConfigureAuthenticationBldr.getSharedObjects()); sharedObjects.put(UserDetailsService.class, userDetailsService()); sharedObjects.put(ApplicationContext.class, context); sharedObjects.put(ContentNegotiationStrategy.class, contentNegotiationStrategy); sharedObjects.put(AuthenticationTrustResolver.class, trustResolver); return sharedObjects; } \nResponse:", "ground_truth": "Creates the shared objects\n\n@return the shared Objects", "predict": " Creates a Map of shared Objects. These Objects are ThreadLocal variables that are cleaned up automatically once the AuthenticationFlow completes. Specifically, they are cleaned up upon encountering an AuthenticationException.\n * @return Map of shared Objects."}
{"ID": 214, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void configureJaasUsingLoop() throws IOException { String loginConfigUrl = convertLoginConfigToUrl(); boolean alreadySet = false; int n = 1; final String prefix = \"login.config.url.\"; String existing; while ((existing = Security.getProperty(prefix + n)) != null) { alreadySet = existing.equals(loginConfigUrl); if (alreadySet) { break; } n++; } if (!alreadySet) { String key = prefix + n; log.debug(\"Setting security property [\" + key + \"] to: \" + loginConfigUrl); Security.setProperty(key, loginConfigUrl); } } \nResponse:", "ground_truth": "Loops through the login.config.url.1,login.config.url.2 properties looking for the\nlogin configuration. If it is not set, it will be set to the last available\nlogin.config.url.X property.", "predict": " Loop through all Security properties trying to find the login config url. If found, break and return. Otherwise, add the login config url to the Security properties.\n * @throws IOException\n */"}
{"ID": 215, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getCurrentDate() { long now = System.currentTimeMillis(); if ((now - currentDateGenerated) > 1000) { synchronized (format) { if ((now - currentDateGenerated) > 1000) { currentDateGenerated = now; currentDate = format.format(new Date(now)); } } } return currentDate; } \nResponse:", "ground_truth": "Gets the current date in HTTP format.\n\n@return Current date in HTTP format", "predict": " Returns the current date formatted. The date is generated once per second. @return The current date formatted."}
{"ID": 216, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Long internalParseDate(String value, DateFormat[] formats) { Date date = null; for (int i = 0; (date == null) && (i < formats.length); i++) { try { date = formats[i].parse(value); } catch (ParseException ignored) { } } if (date == null) { return null; } return new Long(date.getTime()); } \nResponse:", "ground_truth": "Parses date with given formatters.\n\n@param value The string to parse\n@param formats Array of formats to use\n\n@return Parsed date (or <code>null</code> if no formatter mached)", "predict": " Parses the date string using the supplied date formats. The first non-null date is returned. If all supplied date formats fail to parse the date string, null is returned. @param value The date string to parse. @param formats The date formats to use. @return The parsed date or null if parsing fails."}
{"ID": 217, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static void updateCache(HashMap cache, Object key, Object value) { if (value == null) { return; } if (cache.size() > 1000) { cache.clear(); } cache.put(key, value); } \nResponse:", "ground_truth": "Updates cache.\n\n@param cache Cache to be updated\n@param key Key to be updated\n@param value New value", "predict": " Update cache with new value.\n@param cache cache to update\n@param key key to update\n@param value value to update\n*/"}
{"ID": 218, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) { authRequest.setDetails(authenticationDetailsSource.buildDetails(request)); } \nResponse:", "ground_truth": "Provided so that subclasses may configure what is put into the authentication\nrequest's details property.\n\n@param request that an authentication request is being created for\n@param authRequest the authentication request object that should have its details\nset", "predict": " Populate the given AuthenticationDetails object from the given Spring Security context. @param request Spring Security context. @param authRequest AuthenticationDetails to populate."}
{"ID": 219, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String getSecurityName(final Subject subject) { if (logger.isDebugEnabled()) { logger.debug(\"Determining Websphere security name for subject \" + subject); } String userSecurityName = null; if (subject != null) { // SEC-803 Object credential = subject.getPublicCredentials(getWSCredentialClass()) .iterator().next(); if (credential != null) { userSecurityName = (String) invokeMethod(getSecurityNameMethod(), credential); } } if (logger.isDebugEnabled()) { logger.debug(\"Websphere security name is \" + userSecurityName + \" for subject \" + subject); } return userSecurityName; } \nResponse:", "ground_truth": "Get the security name for the given subject.\n\n@param subject The subject for which to retrieve the security name\n@return String the security name for the given subject", "predict": " Determine the security name of the authenticated subject. @param subject authenticated Subject @return security name\n*/"}
{"ID": 220, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private static List<String> getWebSphereGroups(final String securityName) { Context ic = null; try { // TODO: Cache UserRegistry object ic = new InitialContext(); Object objRef = ic.lookup(USER_REGISTRY); Object userReg = invokeMethod(getNarrowMethod(), null , objRef, Class.forName(\"com.ibm.websphere.security.UserRegistry\")); if (logger.isDebugEnabled()) { logger.debug(\"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg); } final Collection groups = (Collection) invokeMethod(getGroupsForUserMethod(), userReg, new Object[] { securityName }); if (logger.isDebugEnabled()) { logger.debug(\"Groups for user \" + securityName + \": \" + groups.toString()); } return new ArrayList(groups); } catch (Exception e) { logger.error(\"Exception occured while looking up groups for user\", e); throw new RuntimeException( \"Exception occured while looking up groups for user\", e); } finally { try { if (ic != null) { ic.close(); } } catch (NamingException e) { logger.debug(\"Exception occured while closing context\", e); } } } \nResponse:", "ground_truth": "Get the WebSphere group names for the given security name.\n\n@param securityName The security name for which to retrieve the WebSphere group\nnames\n@return the WebSphere group names for the given security name", "predict": " Get the groups for the given security name. Uses reflection to avoid introducing dependency on WASAPI.jar. @param securityName Security name of the user whose groups are sought. @return List of groups for the given security name. May be empty but never null."}
{"ID": 221, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void changePassword(final String oldPassword, final String newPassword) { Authentication authentication = SecurityContextHolder.getContext() .getAuthentication(); Assert.notNull( authentication, \"No authentication object found in security context. Can't change current user's password!\"); String username = authentication.getName(); logger.debug(\"Changing password for user '\" + username); DistinguishedName userDn = usernameMapper.buildDn(username); if (usePasswordModifyExtensionOperation) { changePasswordUsingExtensionOperation(userDn, oldPassword, newPassword); } else { changePasswordUsingAttributeModification(userDn, oldPassword, newPassword); } } \nResponse:", "ground_truth": "Changes the password for the current user. The username is obtained from the\nsecurity context.\n\nThere are two supported strategies for modifying the user's password depending on\nthe capabilities of the corresponding LDAP server.\n\n<p>\nConfigured one way, this method will modify the user's password via the\n<a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc3062\">\nLDAP Password Modify Extended Operation\n</a>.\n\nSee {@link LdapUserDetailsManager#setUsePasswordModifyExtensionOperation(boolean)} for details.\n</p>\n\n<p>\nBy default, though, if the old password is supplied, the update will be made by rebinding as the user,\nthus modifying the password using the user's permissions. If\n<code>oldPassword</code> is null, the update will be attempted using a standard\nread/write context supplied by the context source.\n</p>\n\n@param oldPassword the old password\n@param newPassword the new value of the password.", "predict": " Change password for current authenticated user. @param oldPassword old password @param newPassword new password"}
{"ID": 222, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DistinguishedName buildGroupDn(String group) { DistinguishedName dn = new DistinguishedName(groupSearchBase); dn.add(groupRoleAttributeName, group.toLowerCase()); return dn; } \nResponse:", "ground_truth": "Creates a DN from a group name.\n\n@param group the name of the group\n@return the DN of the corresponding group, including the groupSearchBase", "predict": " Build DN for group membership. @param group group name @return DN for group membership\n*/"}
{"ID": 223, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void allowableSessionsExceeded(List<SessionInformation> sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException { if (exceptionIfMaximumExceeded || (sessions == null)) { throw new SessionAuthenticationException(messages.getMessage( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\", new Object[] { Integer.valueOf(allowableSessions) }, \"Maximum sessions of {0} for this principal exceeded\")); } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null; for (SessionInformation session : sessions) { if ((leastRecentlyUsed == null) || session.getLastRequest() .before(leastRecentlyUsed.getLastRequest())) { leastRecentlyUsed = session; } } leastRecentlyUsed.expireNow(); } \nResponse:", "ground_truth": "Allows subclasses to customise behaviour when too many sessions are detected.\n\n@param sessions either <code>null</code> or all unexpired sessions associated with\nthe principal\n@param allowableSessions the number of concurrent sessions the user is allowed to\nhave\n@param registry an instance of the <code>SessionRegistry</code> for subclass use", "predict": " Determine the least recently used session, and expire it. Then, if appropriate, throw an exception indicating maximum exceeded. @param sessions The sessions to expire. @param allowableSessions The maximum allowable sessions for this principal. @param registry The registry to expire sessions from. @throws SessionAuthenticationException Indicating maximum exceeded."}
{"ID": 224, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void copyDetails(Authentication source, Authentication dest) { if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) { AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest; token.setDetails(source.getDetails()); } } \nResponse:", "ground_truth": "Copies the authentication details from a source Authentication object to a\ndestination one, provided the latter does not already have one set.\n\n@param source source authentication\n@param dest the destination authentication object", "predict": " Copy the details from the source authentication to the destination authentication. This avoids modifying the original source Authentication object. @param source Authentication object to copy details from. @param dest Authentication object to copy details to."}
{"ID": 225, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Filter> getFilters(HttpServletRequest request) { for (SecurityFilterChain chain : filterChains) { if (chain.matches(request)) { return chain.getFilters(); } } return null; } \nResponse:", "ground_truth": "Returns the first filter chain matching the supplied URL.\n\n@param request the request to match\n@return an ordered array of Filters defining the filter chain", "predict": " Get the filters for the given request. @param request The HTTP request. @return The filters, or null if none match."}
{"ID": 226, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Filter> getFilters(String url) { return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, \"GET\") .getRequest()))); } \nResponse:", "ground_truth": "Convenience method, mainly for testing.\n\n@param url the URL\n@return matching filter list", "predict": " Get the filters applied to the given URL. @param url The URL to inspect. @return A list of Filter objects. May be empty but will never be null."}
{"ID": 227, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ApplicationContext getContext(PageContext pageContext) { ServletContext servletContext = pageContext.getServletContext(); return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext); } \nResponse:", "ground_truth": "Allows test cases to override where application context obtained from.\n\n@param pageContext so the <code>ServletContext</code> can be accessed as required\nby Spring's <code>WebApplicationContextUtils</code>\n\n@return the Spring application context (never <code>null</code>)", "predict": " Retrieve the Spring application context from the page context. @param pageContext the page context @return the Spring application context\n*/"}
{"ID": 228, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DistinguishedName getFullDn(DistinguishedName dn, Context baseCtx) throws NamingException { DistinguishedName baseDn = new DistinguishedName(baseCtx.getNameInNamespace()); if (dn.contains(baseDn)) { return dn; } baseDn.append(dn); return baseDn; } \nResponse:", "ground_truth": "Gets the full dn of a name by prepending the name of the context it is relative to.\nIf the name already contains the base name, it is returned unaltered.", "predict": " Returns a DistinguishedName with the base DN prepended to the DN. Useful for doing searches. @param dn The DistinguishedName to modify. @param baseCtx The Context to use as the base DN. @return The DistinguishedName with the base DN prepended. @throws NamingException If there is a problem getting the base DN."}
{"ID": 229, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecification sessionAttrs(Map<String, Object> sessionAttributes) { notNull(sessionAttributes, \"sessionAttributes\"); parameterUpdater.updateParameters(convert(cfg.getMockMvcParamConfig().sessionAttributesUpdateStrategy()), sessionAttributes, this.sessionAttributes); return this; } \nResponse:", "ground_truth": "Set session attributes.\n\n@param sessionAttributes the session attributes", "predict": " Allows MockMvc to maintain session attributes between requests. Useful for testing scenarios where business logic depends on attributes between requests. Sessions are maintained across requests, so you typically only want to reset attributes on each request. @param sessionAttributes The sessionAttributes to set. Must be a map. @return The RequestSpecification so you can chain this call.\n */"}
{"ID": 230, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AuthenticationScheme basic(String userName, String password) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme(); preemptiveBasicAuthScheme.setUserName(userName); preemptiveBasicAuthScheme.setPassword(password); return preemptiveBasicAuthScheme; } \nResponse:", "ground_truth": "Use preemptive http basic authentication. This means that the authentication details are sent in the request\nheader regardless if the server has challenged for authentication or not.\n\n@param userName The user name.\n@param password The password.\n\n@return The Request specification", "predict": " Basic authentication scheme. Provide basic authentication credentials. @param userName Username @param password Password @return Scheme\n*/"}
{"ID": 231, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(List<Filter> filters) { Validate.notNull(filters, \"Filter list cannot be null\"); RestAssured.filters.addAll(filters); } \nResponse:", "ground_truth": "Add default filters that will be applied to each request.\n\n@param filters The filter list", "predict": " Add filters to be used with the request. @param filters The filters that'll be used instead of the defaults. @see Filter\n*/"}
{"ID": 232, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void filters(Filter filter, Filter... additionalFilters) { Validate.notNull(filter, \"Filter cannot be null\"); RestAssured.filters.add(filter); if (additionalFilters != null) { Collections.addAll(RestAssured.filters, additionalFilters); } } \nResponse:", "ground_truth": "Add default filters to apply to each request.\n\n@param filter            The filter to add\n@param additionalFilters An optional array of additional filters to add", "predict": " Add the given filter(s) to the list of filters that'll be used in the request. Useful when you have added your own filters or want to enhance existing ones. <p> Note that this method doesn't apply to built in filters (such as cookies, authentication, redirection, etc.), see {@link #addFilter(Filter)} instead.</p> @param filter The filter(s) to add. @param additionalFilters Additional filters to add."}
{"ID": 233, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme basic(String userName, String password) { final BasicAuthScheme scheme = new BasicAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); return scheme; } \nResponse:", "ground_truth": "Create a http basic authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@return The authentication scheme", "predict": " Basic authentication scheme. @param userName Username. @param password Password. @return Scheme."}
{"ID": 234, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme ntlm(String userName, String password, String workstation, String domain) { final NTLMAuthScheme scheme = new NTLMAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setWorkstation(workstation); scheme.setDomain(domain); return scheme; } \nResponse:", "ground_truth": "Create a NTLM authentication scheme.\n\n@param userName The user name.\n@param password The password.\n@param workstation The NTLM workstation.\n@param domain The NTLM workstation.\n@return The authentication scheme", "predict": " NTLM authentication with NTLM challenge. @param userName The username. @param password The password. @param workstation The workstation. @param domain The domain. @return The authentication scheme."}
{"ID": 235, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AuthenticationScheme form(String userName, String password, FormAuthConfig config) { if (userName == null) { throw new IllegalArgumentException(\"Username cannot be null\"); } if (password == null) { throw new IllegalArgumentException(\"Password cannot be null\"); } final FormAuthScheme scheme = new FormAuthScheme(); scheme.setUserName(userName); scheme.setPassword(password); scheme.setConfig(config); return scheme; } \nResponse:", "ground_truth": "Use form authentication with the supplied configuration.\n\n@param userName The user name.\n@param password The password.\n@param config   The form authentication config\n@return The authentication scheme", "predict": " Creates BASIC authentication scheme with BASIC authorization credentials. @param userName Username for BASIC authentication. Cannot be null. @param password Password for BASIC authentication. Cannot be null. @param config Other BASIC configuration options. Cannot be null. @return BASIC authentication scheme. Never null."}
{"ID": 236, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void proxy(URI uri) { if (uri == null) { throw new IllegalArgumentException(\"Proxy URI cannot be null\"); } proxy(new ProxySpecification(uri.getHost(), uri.getPort(), uri.getScheme())); } \nResponse:", "ground_truth": "Instruct REST Assured to connect to a proxy using a URI.\n\n@param uri The URI of the proxy", "predict": " Establish a proxy connection to the given URI. The proxy specification is used to determine the proxy host and port. The scheme of the URI is used to determine the proxy transport protocol. The default transport protocol is HTTPS. @param uri URI to connect to. Cannot be null. @throws IllegalArgumentException if the URI is null."}
{"ID": 237, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) { final StringBuilder builder = new StringBuilder(); if (logDetail == ALL || logDetail == STATUS) { builder.append(responseOptions.statusLine()); } if (logDetail == ALL || logDetail == HEADERS) { final Headers headers = responseOptions.headers(); if (headers.exist()) { appendNewLineIfAll(logDetail, builder).append(toString(headers)); } } else if (logDetail == COOKIES) { final Cookies cookies = responseOptions.detailedCookies(); if (cookies.exist()) { appendNewLineIfAll(logDetail, builder).append(cookies.toString()); } } if (logDetail == ALL || logDetail == BODY) { String responseBodyToAppend; if (shouldPrettyPrint) { responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody); } else { responseBodyToAppend = responseBody.asString(); } if (logDetail == ALL && !isBlank(responseBodyToAppend)) { builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR); } builder.append(responseBodyToAppend); } String response = builder.toString(); stream.println(response); return response; } \nResponse:", "ground_truth": "Prints the response to the print stream\n\n@return A string of representing the response", "predict": " Prints the response to the PrintStream. @param responseOptions the response options @param responseBody the response body @param stream the PrintStream to write to @param logDetail the detail level of logging @param shouldPrettyPrint pretty print the body if possible\n * @return the response\n */"}
{"ID": 238, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredConfig redirect(RedirectConfig redirectConfig) { notNull(redirectConfig, \"Redirect config\"); return new RestAssuredConfig(redirectConfig, conf(HttpClientConfig.class), conf(LogConfig.class), conf(EncoderConfig.class), conf(DecoderConfig.class), conf(SessionConfig.class), conf(ObjectMapperConfig.class), conf(ConnectionConfig.class), conf(JsonConfig.class), conf(XmlConfig.class), conf(SSLConfig.class), conf(MatcherConfig.class), conf(HeaderConfig.class), conf(MultiPartConfig.class), conf(ParamConfig.class), conf(OAuthConfig.class), conf(FailureConfig.class)); } \nResponse:", "ground_truth": "Set the redirect config.\n\n@param redirectConfig The {@link RedirectConfig} to set\n@return An updated RestAssuredConfiguration", "predict": " Configure redirection settings for REST Assured. Typically you don't configure these settings yourself but let Rest Assured handle the redirection automatically. RedirectConfig follows the redirect mechnism explained in Wikipedia. You can learn more about Wikipedia's redirections here http://en.wikipedia.org/wiki/Redirection_(computer_science). Note that this setting override all default settings configured by the {@link RestAssuredConfig} and {@link HttpClientConfig} settings. @param redirectConfig The RedirectConfig to use when performing the redirection. @return The updated RestAssuredConfig instance so that additional method invocations can be chained together.\n*/"}
{"ID": 239, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EncoderConfig defaultQueryParameterCharset(String charset) { return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true); } \nResponse:", "ground_truth": "Specify the default charset for query parameters\n\n@param charset The charset to use.\n@return A new instance of {@link EncoderConfig}", "predict": " Sets the default query parameter encoding. @param charset the default query parameter encoding. @return a new instance of EncoderConfig\n*/"}
{"ID": 240, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig defaultObjectMapperType(ObjectMapperType defaultObjectMapperType) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Creates an object mapper configuration that uses the specified object mapper as default.\n\n@param defaultObjectMapperType The object mapper to use. If <code>null</code> then classpath scanning will be used.", "predict": " Provide a default implementation of the Jackson ObjectMapperFactory. This implementation will configure the Jackson ObjectMapperFactory to use Gson instead of Jackson 1.x. @param defaultObjectMapperType The default Jackson ObjectMapperFactory implementation to use. @return A new ObjectMapperConfig instance with the default Jackson ObjectMapperFactory wired up to the Gson implementation.\n*/"}
{"ID": 241, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ObjectMapperConfig jaxbObjectMapperFactory(JAXBObjectMapperFactory jaxbObjectMapperFactory) { return new ObjectMapperConfig(defaultObjectMapper, defaultObjectMapperType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, jaxbObjectMapperFactory, johnzonObjectMapperFactory, true); } \nResponse:", "ground_truth": "Specify a custom JAXB object mapper factory.\n\n@param jaxbObjectMapperFactory The object mapper factory", "predict": " Configure the ObjectMappers to use for Jackson, Gson, Johnzon, and JAXB. @param jaxbObjectMapperFactory The JAXB ObjectMapper factory to use. @return A new builder instance. Never null."}
{"ID": 242, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig logConfig(LogConfig logConfig) { notNull(logConfig, \"Log config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Log config.\n\n@param logConfig The {@link LogConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Configure logging of both request and response. @param logConfig The log config to use. @return A new RestAssuredMockMvcConfig instance."}
{"ID": 243, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig sessionConfig(SessionConfig sessionConfig) { notNull(sessionConfig, \"Session config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the session config.\n\n@param sessionConfig The {@link SessionConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Configure the session configuration that'll be used in all subsequent requests. @param sessionConfig The session configuration to use. @return A new instance of {@link RestAssuredMockMvcConfig}\n */"}
{"ID": 244, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig objectMapperConfig(ObjectMapperConfig objectMapperConfig) { notNull(objectMapperConfig, \"Object mapper config\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the object mapper config.\n\n@param objectMapperConfig The {@link ObjectMapperConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Configure REST Assured Mock Mvc to use a configurer that allows you to configure how Jackson works when extracting values from JSON response bodies. @param objectMapperConfig The object mapper configurer that allows you to configure how Jackson works when extracting values from JSON response bodies. @see RestAssuredMockMvcConfig#objectMapperConfig(ObjectMapperConfig)\n */"}
{"ID": 245, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig jsonConfig(JsonConfig jsonConfig) { notNull(jsonConfig, \"JsonConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Json config.\n\n@param jsonConfig The {@link JsonConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of JSON content encoding and pretty printing in the request content. @param jsonConfig The JSON config @return The updated RestAssuredMockMvcConfig object."}
{"ID": 246, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig xmlConfig(XmlConfig xmlConfig) { notNull(xmlConfig, \"XmlConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the Xml config.\n\n@param xmlConfig The {@link XmlConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Configure REST Assured Mock Mvc to use a predefined XmlConfig instance instead of creating a new one when parsing multipart request bodies. Note that this configuration setting will affect all requests that uses multipart encoding. @param xmlConfig The predefined XmlConfig instance to use instead of creating a new one when parsing multipart request bodies. @return The updated RestAssuredMockMvcConfig object."}
{"ID": 247, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig encoderConfig(EncoderConfig encoderConfig) { notNull(encoderConfig, \"EncoderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the encoder config\n\n@param encoderConfig The {@link EncoderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvc instance created by this MockMvcBuilder. Useful for advanced configuration of MockMvc. @param encoderConfig EncoderConfig instance @return MockMvcConfig instance that allows tweaking of MockMvc configuration."}
{"ID": 248, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig headerConfig(HeaderConfig headerConfig) { notNull(headerConfig, \"HeaderConfig\"); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the header config\n\n@param headerConfig The {@link HeaderConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvc instance created by REST Assured MockMvc DSL. Useful for advanced customization of how the MockMvc instance is created. For example it is possible to pass in a MockMvc instance preconfigured with some MockHttp expectations. In order to use this feature effectively you need to specify MockMvcConfig instance when constructing MockMvcRequestSpecification. Refer to the javadoc of MockMvcRequestSpecification for more details. <p> Note that if you wish for global headers to be sent you should use the configure() method instead. </p> Example usage: <pre> RestAssuredMockMvc.given().standaloneSetup(new CustomMockMvcConfigurer().withGlobalResponseHeaders().configureMockMvc()).when().get(\"...\").then().assertThat().body(containsString(\"x-something\")); </pre> Note that this method is designed to be used with {@link MockMvcRequestSpecification} and not standalone. You"}
{"ID": 249, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig asyncConfig(AsyncConfig asyncConfig) { notNull(asyncConfig, AsyncConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the async config\n\n@param asyncConfig The {@link AsyncConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvc instances created by this MockMvcFactory. Useful for fine grained control of MockMvc instances. @param asyncConfig The AsyncConfig instance to use. @return A new RestAssuredMockMvcConfig instance with the supplied asyncConfig settings applied.\n*/"}
{"ID": 250, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig mockMvcConfig(MockMvcConfig mockMvcConfig) { notNull(mockMvcConfig, MockMvcConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the MockMVC config\n\n@param mockMvcConfig The {@link MockMvcConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvcConfigurer instances that will be applied to every request made by the DSL. @param mockMvcConfig MockMvcConfigurer @return A new RestAssuredMockMvcConfig instance that has been configured using the supplied MockMvcConfigurer instances.\n */"}
{"ID": 251, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig multiPartConfig(MultiPartConfig multiPartConfig) { notNull(multiPartConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the multi-part config\n\n@param multiPartConfig The {@link MultiPartConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvc instance created by this MockMvcBuilder. Useful for advanced configuration of MockMvc. @param multiPartConfig The multiPartConfig to set. @return A new RestAssuredMockMvcConfig instance with the supplied multiPartConfig.\n*/"}
{"ID": 252, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig paramConfig(MockMvcParamConfig paramConfig) { notNull(paramConfig, MultiPartConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the parameter config\n\n@param paramConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvc instance. @param paramConfig The MockMvcParamConfig to use. @return A new RestAssuredMockMvcConfig instance"}
{"ID": 253, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RestAssuredMockMvcConfig matcherConfig(MatcherConfig matcherConfig) { notNull(matcherConfig, MatcherConfig.class); return new RestAssuredMockMvcConfig(logConfig, encoderConfig, decoderConfig, sessionConfig, objectMapperConfig, jsonConfig, xmlConfig, headerConfig, asyncConfig, multiPartConfig, mockMvcConfig, paramConfig, matcherConfig); } \nResponse:", "ground_truth": "Set the matcher config\n\n@param matcherConfig The {@link MockMvcParamConfig} to set\n@return An updated RestAssuredMockMvcConfig", "predict": " Allows configuring of MockMvcConfigurer. @param matcherConfig The matcher config to use. @return A new RestAssuredMockMvcConfig instance."}
{"ID": 254, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CertificateAuthSettings allowAllHostnames() { return new CertificateAuthSettings(keystoreType, trustStoreType, port, trustStore, keyStore, ALLOW_ALL_HOSTNAME_VERIFIER, sslSocketFactory); } \nResponse:", "ground_truth": "Configure the CertificateAuthSettings to allow all host names.\n\n@return A new CertificateAuthSettings instance\n@see org.apache.http.conn.ssl.SSLSocketFactory#ALLOW_ALL_HOSTNAME_VERIFIER", "predict": " Allows all hostnames. Truststore and keystore certs are automatically installed into the cacerts truststore. Truststore password is admin. Keystore password is admin. Trustore and keystore type are auto detected. Trustore and keystore location are auto detected. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location are prompted for interactively. Trustore and keystore password are prompted for interactively. Trustore and keystore location"}
{"ID": 255, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declareNamespaces(Map<String, String> namespacesToDeclare) { return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, namespacesToDeclare, properties, validating, namespaceAware, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Specify declared namespaces that will be used when parsing XML.\n\n@param namespacesToDeclare A map containing features that will be used by the underlying {@link groovy.util.XmlSlurper}.\n@return A new instance of XmlPathConfig\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Allows overriding of the default NamespaceAware Marshaller. Useful for declaring a Namespace unaware XML document marshaller. Useful for marshalling non-wellformed XML documents. Useful for marshalling untyped XML documents. Useful for marshalling XML documents with mixed namespaces. Useful for marshalling XML documents with mixed namespace prefixes. Useful for marshalling XML documents with mixed namespace URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs. Useful for marshalling XML documents with mixed namespace prefixes and URIs."}
{"ID": 256, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public XmlPathConfig declaredNamespace(String prefix, String namespaceURI) { Validate.notEmpty(prefix, \"Prefix cannot be empty\"); Validate.notEmpty(namespaceURI, \"Namespace URI cannot be empty\"); Map<String, String> updatedNamespaces = new HashMap<String, String>(declaredNamespaces); updatedNamespaces.put(prefix, namespaceURI); return new XmlPathConfig(jaxbObjectMapperFactory, defaultParserType, defaultDeserializer, charset, features, updatedNamespaces, properties, validating, true, allowDocTypeDeclaration); } \nResponse:", "ground_truth": "Declares a namespace.\n\n@param prefix       The feature name, which is a fully-qualified URI.\n@param namespaceURI The requested value of the feature (true or false).\n@return A new XmlPathConfig instance\n@see org.xml.sax.XMLReader#setFeature(java.lang.String, boolean)", "predict": " Allows you to declare a namespace on the root element of your XML document. Useful for declaring your own prefixes on the root element. @param prefix Prefix to declare on the root element @param namespaceURI Namespace URI to declare on the root element @return New XmlPathConfig instance with declared namespace declaration\n*/"}
{"ID": 257, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object request(String method, boolean hasBody, Closure configClosure) throws ClientProtocolException, IOException { return this.doRequest(this.defaultURI.toURI(), method, this.defaultContentType, hasBody, configClosure); } \nResponse:", "ground_truth": "Make an HTTP request to the default URI, and parse using the default\ncontent-type.\n\n@param method        {@link HttpRequestFactory HTTP method}\n@param configClosure request configuration options\n@return whatever value was returned by the executed response handler.\n@throws ClientProtocolException\n@throws IOException\n@see #request(Object, HttpRequestFactory, Object, Closure)", "predict": " Makes a RESTful request to the configured endpoint. @param method The HTTP method to use for the request. @param hasBody Whether or not there is a request body to be sent. @param configClosure Closure to accept configuration options. May be null. @return The response body. @throws IOException If there is a connectivity problem or if there is an HTTP problem. If an HTTP problem occurs, an IOException will be thrown.\n"}
{"ID": 258, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setHeaders(Map<?, ?> headers) { this.defaultRequestHeaders.clear(); if (headers == null) return; for (Object key : headers.keySet()) { Object val = headers.get(key); if (val == null) continue; this.defaultRequestHeaders.put(key.toString(), val.toString()); } } \nResponse:", "ground_truth": "Set the default headers to add to all requests made by this builder\ninstance.  These values will replace any previously set default headers.\n\n@param headers map of header names & values.", "predict": " Set default headers for outgoing requests. These will be applied to every outgoing request made through this client instance. Individual requests can override these defaults through their headers as well. @param headers The headers to apply to outgoing requests. May be null."}
{"ID": 259, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setProxy(String host, int port, String scheme) { getClient().getParams().setParameter( ConnRoutePNames.DEFAULT_PROXY, new HttpHost(host, port, scheme)); } \nResponse:", "ground_truth": "Set the default HTTP proxy to be used for all requests.\n\n@param host   host name or IP\n@param port   port, or -1 for the default port\n@param scheme usually \"http\" or \"https,\" or <code>null</code> for the default\n@see HttpHost#HttpHost(String, int, String)", "predict": " Set proxy settings. Useful for tunneling HTTPS through a HTTP proxy. Consult with your HTTP proxy vendor for details on setting up HTTPS through a proxy. Setting these parameters permanently is not recommended when using libcurl. Instead, use setopt(CURLOPT_PROXY) and setopt(CURLPROXY_HTTP) for libcurl. Consult with your HTTP proxy vendor for details on tunneling HTTPS through a proxy. Consult with your HTTP proxy vendor for details on setting up HTTPS through a proxy. Setting these parameters permanently is not recommended when using libcurl. Instead, use setopt(CURLOPT_PROXY) and setopt(CURLPROXY_HTTP_1_1) for libcurl. Consult with your HTTP proxy vendor for details on tunneling HTTPS through a proxy. Consult with your HTTP proxy vendor for details on setting up HTTPS through a proxy. Setting these parameters permanently is not recommended when using libcurl. Instead, use setopt(CURLOPT_PROXY) and setopt(C"}
{"ID": 260, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder controlName(String controlName) { Validate.notEmpty(controlName, \"Control name cannot be empty\"); this.controlName = controlName; this.isControlNameExplicit = true; return this; } \nResponse:", "ground_truth": "Specify the control name of this multi-part.\n\n@param controlName The control name to use. Default is <code>file</code>.\n@return An instance of MultiPartSpecBuilder", "predict": " Specify the control name. This is an optional parameter. If not specified, the default control name will be used. @param controlName Control name. Cannot be empty. @return Fluent API.\n*/"}
{"ID": 261, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartSpecBuilder header(String name, String value) { Validate.notEmpty(name, \"Header name cannot be empty\"); Validate.notEmpty(value, \"Header value cannot be empty\"); // Replace previous header if exists final Set<String> headerNames = headers.keySet(); final String trimmedName = name.trim(); for (String headerName : headerNames) { if (headerName.equalsIgnoreCase(trimmedName)) { headers.remove(headerName); } } // Put the name header in the header list headers.put(name, value); return this; } \nResponse:", "ground_truth": "Add a header to this multipart specification.\n\n@param name The name of the header\n@param value The value of the header\n@return An instance of MultiPartSpecBuilder", "predict": " Set a header value. Replaces previous header with the same name. @param name Header name @param value Header value @return Fluent API\n*/"}
{"ID": 262, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void basic(String host, int port, String user, String pass) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new UsernamePasswordCredentials(user, pass) ); } \nResponse:", "ground_truth": "Set authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass", "predict": " Basic authentication. @param host Host. @param port Port. @param user Username. @param pass Password."}
{"ID": 263, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void ntlm(String host, int port, String user, String pass, String workstation, String domain) { builder.getClient().getCredentialsProvider().setCredentials( new AuthScope(host, port), new NTCredentials(user, pass, workstation, domain) ); } \nResponse:", "ground_truth": "Set NTLM authentication credentials to be used for the given host and port.\n\n@param host\n@param port\n@param user\n@param pass\n@param workstation\n@param domain", "predict": " Authenticate with NTLMv2. @param host Hostname or IP address. @param port Port number. @param user Username. @param pass Password. @param workstation Client computer's hostname. @param domain Domain to authenticate with.\n*/"}
{"ID": 264, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Headers headers(Header header, Header... additionalHeaders) { notNull(header, \"Header\"); final List<Header> headerList = new LinkedList<Header>(); headerList.add(header); if (additionalHeaders != null) { Collections.addAll(headerList, additionalHeaders); } return new Headers(headerList); } \nResponse:", "ground_truth": "An alternative way to create a Headers object from the constructor.\n\n@param header            The header to be included\n@param additionalHeaders Additional headers to be included (optional)\n@return A new headers object containing the specified headers", "predict": " Headers factory method. @param header Mandatory {@link Header} instance. @param additionalHeaders Optional other {@link Header} instances. @return Fresh Headers instance."}
{"ID": 265, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void reset() { mockMvcFactory = null; config = null; basePath = \"/\"; resultHandlers.clear(); requestPostProcessors.clear(); responseSpecification = null; requestSpecification = null; authentication = null; } \nResponse:", "ground_truth": "Reset all static configurations to their default values.", "predict": " Clears Spring Security's MockMvcFactory so that it can be recreated fresh. Useful for tests that modify Spring Security via SPI.\n*/"}
{"ID": 266, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseBuilder setHeader(String name, String value) { notNull(name, \"Header name\"); notNull(value, \"Header value\"); List<Header> newHeaders = new ArrayList<Header>(restAssuredResponse.headers().asList()); newHeaders.add(new Header(name, value)); restAssuredResponse.setResponseHeaders(new Headers(newHeaders)); if (trim(name).equalsIgnoreCase(CONTENT_TYPE)) { restAssuredResponse.setContentType(value); } return this; } \nResponse:", "ground_truth": "Set a specific header\n\n@return The builder", "predict": " Set a new header value. Will remove all previous occurrences of the header name. @param name The header name @param value The header value @return The response specification\n*/"}
{"ID": 267, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Response build() { final int statusCode = restAssuredResponse.statusCode(); if (statusCode < 100 || statusCode >= 600) { throw new IllegalArgumentException(format(\"Status code must be greater than 100 and less than 600, was %d.\", statusCode)); } if (StringUtils.isBlank(restAssuredResponse.statusLine())) { restAssuredResponse.setStatusLine(restAssuredResponse.statusCode()); } restAssuredResponse.setRpr(new ResponseParserRegistrar()); return restAssuredResponse; } \nResponse:", "ground_truth": "Build the actual response\n\n@return The response object", "predict": " Build the response based on the Rest Assured response. @return The response based on the Rest Assured response."}
{"ID": 268, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher value(Matcher<? super String> valueMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"value\", valueMatcher))); } \nResponse:", "ground_truth": "Verifies whether value of cookie satisfies specified matcher.\n@param valueMatcher value assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed value property assertion", "predict": " Allows fluently building CookieMatchers. Useful when coupled with other methods like {@link #hasPath(String)}. @param valueMatcher The matcher used to evaluate the cookie value. @return A DetailedCookieMatcher that wraps the delegate Matcher.\n */"}
{"ID": 269, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher comment(Matcher<? super String> commentMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"comment\", commentMatcher))); } \nResponse:", "ground_truth": "Verifies whether comment of cookie satisfies specified matcher.\n@param commentMatcher comment assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed comment property assertion", "predict": " Matches cookies that have comments matching the given matcher. @param commentMatcher The matcher to apply to cookie comments. @return The matcher.\n*/"}
{"ID": 270, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher expiryDate(Matcher<? super Date> expiryDateMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"expiryDate\", expiryDateMatcher))); } \nResponse:", "ground_truth": "Verifies whether expiry date of cookie satisfies specified matcher.\n@param expiryDateMatcher expiry date assertion\n@return A {@link DetailedCookieMatcher} instance with and-composed expiry date property assertion", "predict": " Matches cookies that have an expiry date. The expiry date is expressed in terms of milliseconds since midnight GMT on January 1, 1970. @param expiryDateMatcher the matcher to apply to the cookie expiry date. @return the cookie matcher."}
{"ID": 271, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher domain(Matcher<? super String> domainMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"domain\", domainMatcher))); } \nResponse:", "ground_truth": "Verifies whether domain of cookie satisfies specified matcher.\n@param domainMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed domain property assertion", "predict": " Allows cookie domains to be restricted to those domains. Useful for restricting cookies to specific subdomains. @param domainMatcher The matcher to use against the cookie domains. @return The detailed cookie matcher."}
{"ID": 272, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher path(Matcher<? super String> pathMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"path\", pathMatcher))); } \nResponse:", "ground_truth": "Verifies whether path of cookie satisfies specified matcher.\n@param pathMatcher assertion for path property\n@return A {@link DetailedCookieMatcher} instance with and-composed path property assertion", "predict": " Matches cookies that have the given path. The path may contain wildcards, which are interpreted literally. Wildcards are not interpreted as regex wildcards. @param pathMatcher the matcher to apply to the cookie path @return the cookie matcher\n*/"}
{"ID": 273, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher secured(Matcher<? super Boolean> securedMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"secured\", securedMatcher))); } \nResponse:", "ground_truth": "Verifies whether secured property of cookie satisfies specified matcher.\n@param securedMatcher assertion for secured property\n@return A {@link DetailedCookieMatcher} instance with and-composed secured property assertion", "predict": " Matches cookies that are secured. @param securedMatcher Matcher for determining securedness of cookie @return Matcher for secured cookies\n*/"}
{"ID": 274, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher httpOnly(Matcher<? super Boolean> httpOnlyMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"httpOnly\", httpOnlyMatcher))); } \nResponse:", "ground_truth": "Verifies whether http-only property of cookie satisfies specified matcher.\n@param httpOnlyMatcher assertion for domain property\n@return A {@link DetailedCookieMatcher} instance with and-composed http-only property assertion", "predict": " Matches cookies that are marked as HTTP only. @param httpOnlyMatcher the matcher to apply to the HTTPOnly property of the cookie @return cookie matcher\n*/"}
{"ID": 275, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher version(Matcher<? super Integer> versionMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"version\", versionMatcher))); } \nResponse:", "ground_truth": "Verifies whether version of cookie satisfies specified matcher.\n@param versionMatcher assertion for version property\n@return A {@link DetailedCookieMatcher} instance with and-composed version property assertion", "predict": " Matches cookies with a given version. @param versionMatcher the matcher for the cookie version @return the cookie matcher\n*/"}
{"ID": 276, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DetailedCookieMatcher maxAge(Matcher<? super Integer> maxAgeMatcher) { return new DetailedCookieMatcher(and(Matchers.hasProperty(\"maxAge\", maxAgeMatcher))); } \nResponse:", "ground_truth": "Verifies whether max age of cookie satisfies specified matcher.\n@param maxAgeMatcher assertion for max age property\n@return A {@link DetailedCookieMatcher} instance with and-composed max age property assertion", "predict": " Matches cookies with a maxAge greater than the given matcher. @param maxAgeMatcher the matcher to apply to the maxAge property of the cookie @return cookie matcher\n*/"}
{"ID": 277, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, Matcher<String> expectedValueMatcher) { spec.header(headerName, expectedValueMatcher); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied header name and hamcrest matcher.\n\n@param headerName           The name of the expected header\n@param expectedValueMatcher The Hamcrest matcher that must conform to the value\n@return The builder", "predict": " Expects the header value of the response to match the specified Hamcrest matcher. E.g. expectHeader(\"Content-Type\", equalTo(\"text/plain\")) @param headerName The name of the header to expect. @param expectedValueMatcher The Hamcrest matcher that must conform to the value.\n * @return the response specification builder\n */"}
{"ID": 278, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectHeader(String headerName, String expectedValue) { spec.header(headerName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response header matches the supplied name and value.\n\n@param headerName    The name of the expected header\n@param expectedValue The value of the expected header\n@return The builder", "predict": " Expect the given header value. E.g. expectHeader(\"Content-type\", \"text/plain\").then().expect().body(equalTo(\"something\")).when().get(\"/header\"); @param headerName The HTTP header name @param expectedValue The expected HTTP header value @return the response specification\n*/"}
{"ID": 279, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResponseSpecBuilder expectCookie(String cookieName, String expectedValue) { spec.cookie(cookieName, expectedValue); return this; } \nResponse:", "ground_truth": "Expect that a response cookie matches the supplied name and value.\n\n@param cookieName    The name of the expected cookie\n@param expectedValue The value of the expected cookie\n@return The builder", "predict": " Expect that cookie matching the cookie name with expected value. E.g. expectCookie(\"cookieName\", \"expectedValue\").andRespond(withSuccess()); @param cookieName Name of cookie @param expectedValue Cookie value @return Builder DSL\n */"}
{"ID": 280, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProxySpecification withHost(String host) { return new ProxySpecification(host, port, scheme, username, password); } \nResponse:", "ground_truth": "Specify the hostname of the proxy.\n\n@param host The hostname of the proxy.\n@return A new ProxySpecification instance", "predict": " Specify the hostname of the proxy server. @param host The hostname of the proxy server. @return A ProxySpecification with the hostname set.\n*/"}
{"ID": 281, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig numberReturnType(NumberReturnType numberReturnType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers.\n\n@param numberReturnType The choice.\n@return A new instance of JsonPathConfig with the given configuration", "predict": " Allows to define how many digits after decimal separator should be considered as fraction. Important notes: fractions are supported only for numbers, not for booleans or strings. Booleans use caseInsensitive comparison, so fractional digits are irrelevant. Strings are compared literally, so fractional digits may influence the outcome. Therefore fractionDigits irrelevant for strings. @param numberReturnType defines how many digits after decimal separator should be considered as fraction. Possible values are INTEGER, FLOAT, BIG_DECIMAL. Default value is BIG_DECIMAL. @return current object for chaining."}
{"ID": 282, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonPathConfig defaultParserType(JsonParserType defaultParserType) { return new JsonPathConfig(numberReturnType, defaultParserType, gsonObjectMapperFactory, jackson1ObjectMapperFactory, jackson2ObjectMapperFactory, johnzonObjectMapperFactory, defaultDeserializer, charset); } \nResponse:", "ground_truth": "Creates an json path configuration that uses the specified parser type as default.\n\n@param defaultParserType The parser type to use. If <code>null</code> then classpath scanning will be used.", "predict": " Allows to specify default parser type to use. @param defaultParserType default parser type to use. @return updated configuration\n*/"}
{"ID": 283, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig defaultStream(PrintStream printStream) { return new LogConfig(printStream, true, logDetailIfValidationFails, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Specify a new default stream to the print to.\n\n@param printStream The stream\n@return A new LogConfig instance", "predict": " Configure Raven's logging to use the provided PrintStream. This will also set the logging level to ERROR unless Raven is already configured to a lower logging level. Raven recommends ERROR unless you're a Sentry dev. @param printStream The PrintStream to capture Raven's logs. @return A RavenLogger instance that Raven can use to log requests.\n"}
{"ID": 284, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails(LogDetail logDetail) { return new LogConfig(defaultPrintStream, prettyPrintingEnabled, logDetail, urlEncodeRequestUri, true); } \nResponse:", "ground_truth": "Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail\n\n@param logDetail The log detail to show in the log\n@return A new LogConfig instance", "predict": " Allows to enable logging of request and response if validation fails. Useful for troubleshooting purposes. @param logDetail The detail level of logging. Can be one of DEBUG, INFO, WARN, ERROR, FATAL, OFF. Default is INFO. @return The modified builder instance so you can chain calls.\n*/"}
{"ID": 285, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static HttpRequestBase createHttpRequest(URI uri, String httpMethod, boolean hasBody) { String method = notNull(upperCase(trimToNull(httpMethod)), \"Http method\"); Class<? extends HttpRequestBase> type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE.get(method); final HttpRequestBase httpRequest; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if (type == null || (!(type.isInstance(HttpEntityEnclosingRequest.class)) && hasBody)) { httpRequest = new CustomHttpMethod(method, uri); } else { try { httpRequest = type.newInstance(); } catch (Exception e) { throw new RuntimeException(e); } httpRequest.setURI(uri); } return httpRequest; } \nResponse:", "ground_truth": "Get the HttpRequest class that represents this request type.\n\n@return a non-abstract class that implements {@link HttpRequest}", "predict": " Creates http request. @param uri uri @param httpMethod http method @param hasBody has body @return http request\n*/"}
{"ID": 286, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MultiPartConfig defaultBoundary(String defaultBoundary) { return new MultiPartConfig(defaultControlName, defaultFileName, defaultSubtype, defaultBoundary, defaultCharset, true); } \nResponse:", "ground_truth": "Specify an explicit default multipart boundary to use when sending multi-part data.\n\n@param defaultBoundary The boundary to set\n@return An updated MultiPartConfig", "predict": " Sets the default multipart boundary string. The default boundary string can be overridden when constructing the request (@link MultipartRequestBuilder} or when setting the boundary in the content-type header in the request (@link HttpRequestBase#setContentType(String)). @param defaultBoundary The default multipart boundary string. @return The updated MultiPartConfig object.\n*/"}
{"ID": 287, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addAttribute(String attributeName, Object attributeValue) { spec.attribute(attributeName, attributeValue); return this; } \nResponse:", "ground_truth": "Add request attribute\n\n@param attributeName  The attribute name\n@param attributeValue The attribute value\n@return The request specification builder", "predict": " Add an attribute to be included in the request. @param attributeName The attribute name @param attributeValue The attribute value @return MockMvcRequestSpecBuilder\n*/"}
{"ID": 288, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addHeader(String headerName, String headerValue) { spec.header(headerName, headerValue); return this; } \nResponse:", "ground_truth": "Add a header to be sent with the request\n\n@param headerName  The header name\n@param headerValue The header value\n@return The request specification builder", "predict": " Add header value to be sent with the request. Same as calling: MockMvcRequestBuilders.header(headerName, headerValue).and() @param headerName Header name @param headerValue Header value @return MockMvcRequestSpecBuilder\n*/"}
{"ID": 289, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addMultiPart(String controlName, String contentBody, String mimeType) { spec.multiPart(controlName, mimeType); return this; } \nResponse:", "ground_truth": "Specify a string to send to the server using multi-part form data with a specific mime-type.\n\n@param controlName Defines the control name of the body part. In HTML this is the attribute name of the input tag.\n@param contentBody The string to send\n@param mimeType    The mime-type\n@return The request specification", "predict": " Add multi-part request with control name, content body and mime type. @param controlName Control name @param contentBody Content body @param mimeType Mime type @return MockMvcRequestSpecBuilder\n*/"}
{"ID": 290, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcRequestSpecBuilder addResultHandlers(ResultHandler resultHandler, ResultHandler... additionalResultHandlers) { spec.resultHandlers(resultHandler, additionalResultHandlers); return this; } \nResponse:", "ground_truth": "Add a result handler\n\n@param resultHandler The result handler\n@return MockMvcRequestSpecBuilder", "predict": " Add result handlers to the MockMvcRequestSpecBuilder instance. Useful for attaching your own processors to the MockRestRequest. @param resultHandler The result handler @param additionalResultHandlers Additional result handlers to add @return MockMvcRequestSpecBuilder instance\n*/"}
{"ID": 291, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> HttpClientConfig setParam(String parameterName, T parameterValue) { notNull(parameterName, \"Parameter name\"); final Map<String, Object> newParams = new HashMap<String, Object>(httpClientParams); newParams.put(parameterName, parameterValue); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "Set a http client parameter.\n\n@param parameterName  The name of the parameter\n@param parameterValue The value of the parameter (may be null)\n@param <T>            The parameter type\n@return An updated HttpClientConfig", "predict": " Sets a parameter value. @param parameterName the parameter name @param parameterValue the parameter value @return this HttpClientConfig\n*/"}
{"ID": 292, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig addParams(Map<String, ?> httpClientParams) { notNull(httpClientParams, \"httpClientParams\"); final Map<String, Object> newParams = new HashMap<String, Object>(this.httpClientParams); newParams.putAll(httpClientParams); return new HttpClientConfig(httpClientFactory, newParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "Add the given parameters to an already configured number of parameters.\n\n@param httpClientParams The parameters.\n@return An updated HttpClientConfig", "predict": " Allows injecting additional HTTP client parameters. Useful for dependency injection frameworks. @param httpClientParams Additional HTTP client parameters. @return New HTTP client configuration with injected additional HTTP client parameters."}
{"ID": 293, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpClientFactory(HttpClientFactory httpClientFactory) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, NO_HTTP_CLIENT, true); } \nResponse:", "ground_truth": "Set the http client factory that Rest Assured should use when making request. For each request REST Assured will invoke the factory to get the a the HttpClient instance.\n\n@param httpClientFactory The http client factory to use.\n@return An updated HttpClientConfig", "predict": " Provide a custom HttpClientFactory to be used for creating HttpClients. This is particularly useful for providing a mock HttpClientFactory for testing purposes. @param httpClientFactory The HttpClientFactory to use. @return The updated ClientConfig object.\n*/"}
{"ID": 294, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpClientConfig httpMultipartMode(HttpMultipartMode httpMultipartMode) { return new HttpClientConfig(httpClientFactory, httpClientParams, httpMultipartMode, shouldReuseHttpClientInstance, httpClient, true); } \nResponse:", "ground_truth": "Specify the HTTP Multipart mode when sending multi-part data.\n\n@param httpMultipartMode The multi-part mode to set.\n@return An updated HttpClientConfig", "predict": " Configures the HTTP multipart mode. @param httpMultipartMode The HTTP multipart mode. @return The updated HttpClientConfig.\n*/"}
{"ID": 295, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T get(String path) { final JSONAssertion jsonAssertion = createJsonAssertion(path, params); final Object json = jsonParser.parseWith(createConfigurableJsonSlurper()); return (T) jsonAssertion.getResult(json, null); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a boolean.\n\n@param path The Object path.\n@return The object matching the Object path. This may be any primitive type, a List or a Map.  A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Retrieve a JSON object from the given path. @param path The path to the JSON object. @return The JSON object."}
{"ID": 296, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getInt(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Integer) { return (Integer) value; } else if (value instanceof Short) { return ((Short) value).intValue(); } else if (value instanceof Long) { return ((Long) value).intValue(); } else { return ObjectConverter.convertObjectTo(value, Integer.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as an int.\n\n@param path The Object path.\n@return The int matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the int value at the given path. Groovy truth is used to coerce the doubles and booleans. Therefore 1, 'true', and 0 are coerced to the correct int value. NaN and Infinity are not coerced. @param path The dot notation path to the value you want @return The int value at the path"}
{"ID": 297, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte getByte(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Byte) { return (Byte) value; } else if (value instanceof Long) { return ((Long) value).byteValue(); } else if (value instanceof Integer) { return ((Integer) value).byteValue(); } else { return ObjectConverter.convertObjectTo(value, Byte.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a byte.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the value at the given path as a byte. Groovy truth is used to coerce the type of the object to byte. If the object is not a Byte, Long, Integer or coercible to one of those types, then a NumberFormatException is thrown. If Groovy truth determines that the object is not a Number at all, an IllegalArgumentException is thrown. If the path is not valid, an IllegalArgumentException is thrown. @param path The path to the value to interrogate @return The value at the given path as a byte\n*/"}
{"ID": 298, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public short getShort(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Short) { return (Short) value; } else if (value instanceof Long) { return ((Long) value).shortValue(); } else if (value instanceof Integer) { return ((Integer) value).shortValue(); } else { return ObjectConverter.convertObjectTo(value, Short.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a short.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the value at the provided path as a Short. Groovy truth is used to coerce the object to a Short. If the object is not a Short, Groovy casts it as a Short. Therefore, this method will fail if Groovy cannot infer its type. Groovy does not implicitly convert Long or Integer to Short. Therefore, you may wish to call Short.valueOf(long) or Short.valueOf(int) if your intent is to narrow the type of the object and gain improved type safety. @param path The path to the value to retrieve. @return The value at the path as a Short. Groovy truth is used to coerce the object to a Short. If the object is not a Short, Groovy casts it as a Short. Therefore, this method will fail if Groovy cannot infer its type. Groovy does not implicitly convert Long or Integer to Short. Therefore, you may wish to call Short.valueOf(long) or Short.valueOf(int) if your intent is to narrow the type of the"}
{"ID": 299, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public float getFloat(String path) { final Object value = get(path); //Groovy will always return a Double for floating point values. if (value instanceof Double) { return ((Double) value).floatValue(); } else { return ObjectConverter.convertObjectTo(value, Float.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a float.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Gets the float value at the specified path. This method assumes that there is a float value at the specified path. If the path does not exist or does not contain a float value, a MissingPropertyException is thrown. @param path the path to the property @return the float value at the specified path\n*/"}
{"ID": 300, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public double getDouble(String path) { final Object value = get(path); if (value instanceof Double) { return (Double) value; } return ObjectConverter.convertObjectTo(value, Double.class); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a double.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the double value at the given path. @param path The path to the double value. @return The double value at the given path."}
{"ID": 301, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long getLong(String path) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get(path); if (value instanceof Long) { return (Long) value; } else if (value instanceof Short) { return ((Short) value).longValue(); } else if (value instanceof Integer) { return ((Integer) value).longValue(); } else { return ObjectConverter.convertObjectTo(value, Long.class); } } \nResponse:", "ground_truth": "Get the result of an Object path expression as a long.\n\n@param path The Object path.\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get the long value at the given path. Groovy truth is used to coerce the doubles into longs. If the value doesn't exist or is not coercible, a MissingPropertyException is thrown. @param path The property path. @return The long value at the property path.\n*/"}
{"ID": 302, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> List<T> getList(String path, Class<T> genericType) { if (genericType == null) { throw new IllegalArgumentException(\"Generic type cannot be null\"); } final List<T> original = get(path); final List<T> newList = new LinkedList<T>(); if (original != null) { for (T t : original) { T e; if (t instanceof Map && !genericType.isAssignableFrom(Map.class)) { // TODO Avoid double parsing String str = objectToString(t); //noinspection unchecked e = (T) jsonStringToObject(str, genericType); } else { e = ObjectConverter.convertObjectTo(t, genericType); } newList.add(e); } } return Collections.unmodifiableList(newList); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a list.\n\n@param path        The Object path.\n@param genericType The generic list type\n@param <T>         The type\n@return The object matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Convert the entire list of objects to a list of objects of the specified generic type. @param path Path to the list. @param genericType Generic type of the list items. @param <T> Generic type of the list items. @return List of objects of the specified generic type."}
{"ID": 303, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <K, V> Map<K, V> getMap(String path) { return get(path); } \nResponse:", "ground_truth": "Get the result of an Object path expression as a map.\n\n@param path The Object path.\n@param <K>  The type of the expected key\n@param <V>  The type of the expected value\n@return The map matching the Object path. A {@link java.lang.ClassCastException} will be thrown if the object\ncannot be casted to the expected type.", "predict": " Get a typed map from the JSON payload. Supports both legacy and modern syntax. @param path Path to the value to retrieve. @return The value at the path. Will be a Map or null if not found."}
{"ID": 304, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T getObject(String path, Class<T> objectType) { Object object = getFromPath(path, false); return getObjectAsType(object, objectType); } \nResponse:", "ground_truth": "Get an XML document as a Java Object.\n\n@param objectType The type of the java object.\n@param <T>        The type of the java object\n@return A Java object representation of the XML document", "predict": " Get the object at the given path. The path can be absolute or relative. If the path is relative, it will be resolved against the root object. If the path is absolute, it will not be resolved. @param path The path to the object. @param objectType The type of the object. @return The object at the given path. Will be null if the path does not exist.\n */"}
{"ID": 305, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder setBody(Object object, ObjectMapper mapper) { spec.body(object, mapper); return this; } \nResponse:", "ground_truth": "Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper.\nThis works for the POST, PATCH and PUT methods only. Trying to do this for the other http methods will cause an exception to be thrown.\n\n@param object The object to serialize and send with the request\n@param mapper The object mapper\n@return The request specification", "predict": " Explicitly specify a request body to send. Typically, request bodies are automatically discovered from the incoming request using automatic discovery. However, sometimes clients may wish to send a body with the request, or receive a body in return. In such cases, this method may be used to force send a body regardless of discovery, or to provide a custom body object to operate upon. Note that no content-type header will be set, so clients are responsible for setting a content type header themselves. Also note that no charset will be set, so clients are responsible for setting a charset if necessary themselves. Furthermore, no content-transfer-encoding will be set, so clients are responsible for setting that header themselves. Lastly, no content-MD5 header will be set, so clients are responsible for computing and setting that header themselves. @param object The object to send as the request body. May be a single object or an array of objects. Note that objects may not be null; you must send an empty JSON array if you want to send a null. @param m"}
{"ID": 306, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addCookie(String key, Object value, Object... cookieNameValuePairs) { spec.cookie(key, value, cookieNameValuePairs); return this; } \nResponse:", "ground_truth": "Add a cookie to be sent with the request.\n\n@param key                  The cookie key\n@param value                The cookie value\n@param cookieNameValuePairs Additional cookies values. This will actually create two cookies with the same name but with different values.\n@return The request specification builder", "predict": " Allows adding cookies as a map e.g.: \"name\": \"john\", \"age\": 30. Accepts additional cookie pairs after the first pair e.g.: \"john\": 30, \"age\": 30. Duplicate cookies are ok: \"john\": 30, \"john\": 40. Cookies with null values can be added @param key Cookie name @param value Cookie value @param cookieNameValuePairs Additional pairs for the cookie"}
{"ID": 307, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Object... parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a parameter to be sent with the request.\n\n@param parameterName   The parameter name\n@param parameterValues Zero to many parameter values for this parameter name.\n@return The request specification builder", "predict": " Add parameter to be sent with the request. Note that query params must be specified with a question mark, e.g., \"?foo=bar\". Multiple values for the same param can be specified with an ampersand, e.g., \"?foo=bar&foo=baz\". Although this might seem awkward, it's necessary to have an exact counterpart in the response, as query params are sent raw, and not encoded, whereas form params are sent through url encoding. @param parameterName The name of the parameter @param parameterValues Zero or more values of the parameter\n */"}
{"ID": 308, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RequestSpecBuilder addParam(String parameterName, Collection<?> parameterValues) { spec.param(parameterName, parameterValues); return this; } \nResponse:", "ground_truth": "Add a multi-value parameter to be sent with the request.\n\n@param parameterName   The parameter key\n@param parameterValues The parameter values\n@return The request specification builder", "predict": " Add several multi-valued parameters at once. Useful when building many specs with similar characteristics. @param parameterName the name of the parameter @param parameterValues the values of the parameter @return the builder\n */"}
{"ID": 309, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MockMvcParamConfig formParamsUpdateStrategy(UpdateStrategy updateStrategy) { return new MockMvcParamConfig(queryParamsUpdateStrategy, updateStrategy, requestParameterUpdateStrategy, attributeUpdateStrategy, sessionUpdateStrategy, true); } \nResponse:", "ground_truth": "Set form parameter update strategy to the given value.\n\n@param updateStrategy The update strategy to use for form parameters\n@return A new instance of {@link MockMvcParamConfig}", "predict": " Allows you to specify how to handle form parameters when updating requests. @param updateStrategy The update strategy to use. @return A new instance of MockMvcParamConfig with the provided strategy."}
{"ID": 310, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Filter logResponseToIfMatches(PrintStream stream, Matcher<Integer> matcher) { return new ResponseLoggingFilter(stream, matcher); } \nResponse:", "ground_truth": "Create a new logging filter without using the \"new\" operator.\nWill make the DSL look nicer.\n\n@param stream The print stream to log to\n@param matcher The matcher that must be fulfilled in order for logging to occur\n@return a new instance of the filter", "predict": " Logs the response status code to the specified PrintStream if it matches the given matcher. Useful for debugging purposes. @param stream The PrintStream to write the response status code to. @param matcher The matcher to evaluate against the response status code. @return A Filter that logs the response status code to the specified PrintStream if it matches the given matcher. Useful for debugging purposes."}
{"ID": 311, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cookies cookies(Cookie cookie, Cookie... additionalCookies) { AssertParameter.notNull(cookie, \"Cookie\"); final List<Cookie> cookieList = new LinkedList<Cookie>(); cookieList.add(cookie); Collections.addAll(cookieList, additionalCookies); return new Cookies(cookieList); } \nResponse:", "ground_truth": "An alternative way to create a Cookies object from the constructor.\n\n@param cookie            The cookie to be included\n@param additionalCookies Additional cookies to be included (optional)\n@return A new cookies object containing the specified cookies", "predict": " Create a Cookies instance with the Cookie provided plus any additional Cookies. Useful for ensuring cookies are sent securely. @param cookie Cookie to add to Cookies instance @param additionalCookies Cookies to add to Cookies instance @return Cookies instance containing Cookie plus any additional Cookies\n*/"}
{"ID": 312, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cleanUpForCollectedState(Set<KeyAndSource> keysAndSources) { synchronized (lock) { for (KeyAndSource keyAndSource : keysAndSources) { Multiset<Object> set = backingMap.get(keyAndSource.key); if (set != null) { set.remove(keyAndSource.source); if (set.isEmpty()) { backingMap.remove(keyAndSource.key); } } } } } \nResponse:", "ground_truth": "There may be multiple child injectors blacklisting a certain key so only remove the source\nthat's relevant.", "predict": " Clean up the multimap for garbage collected state. Specifically, removes all entries whose multimap has been garbage collected.\n*/"}
{"ID": 313, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void index() { for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) { bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding); } } \nResponse:", "ground_truth": "Indexes bindings by type.", "predict": " Index explicit bindings. That is, go through all explicit bindings and put them in the multimap. Duplicate bindings are possible due to type variables. That is, suppose we have: <code>List&lt;Thing&gt; things = injector.getInstance(new Key&lt;List&lt;Thing&gt;&gt;() {})</code> Things is a type variable. In this case, Guice creates TWO bindings for Thing. One injected at startup, and one at runtime. Both have the same Key. Therefore, we have to deduplicate. Luckily, we can leverage equality of Keys. Specifically, we equate Keys with Lists. Of course, this begs the question: Why bother injecting Lists? Aren't they just glorified containers? Besides, who knows what other garbage lies inside them? Injected Lists would certainly NOT qualify. Besides, injecting Lists would defeat the purpose of favoring explicit bindings. Sounds like a tradeoff, eh? Sounds like we're perfectly willing to sacrifice explicit bindings in exchange for injecting Lists"}
{"ID": 314, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> getBindingOrThrow(Key<T> key, Errors errors, JitLimitation jitType) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl<T> binding = state.getExplicitBinding(key); if (binding != null) { return binding; } // Look for an on-demand binding. return getJustInTimeBinding(key, errors, jitType); } \nResponse:", "ground_truth": "Gets a binding implementation. First, it check to see if the parent has a binding. If the\nparent has a binding and the binding is scoped, it will use that binding. Otherwise, this\nchecks for an explicit binding. If no explicit binding is found, it looks for a just-in-time\nbinding.", "predict": " Returns the binding if it's already been created, or grabs a JIT binding if it hasn't. This ensures that we only ever create JIT bindings for keys that haven't yet been resolved. This improves performance because we'll never have to worry about resolving a key for which we already have a JIT binding. Note that we require an instance of Errors to be passed in so that we can capture errors raised during creation of a JIT binding. This is slighty misleading since we're not really dealing with errors there, but rather with making sure we don't accidentally create a JIT binding for an incompatible key. We could improve this by introducing a separate Errors object to track errors while walking the binding graph, but that felt like overkill.\n*/"}
{"ID": 315, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> BindingImpl<T> convertConstantStringBinding(Key<T> key, Errors errors) throws ErrorsException { // Find a constant string binding. Key<String> stringKey = key.ofType(STRING_TYPE); BindingImpl<String> stringBinding = state.getExplicitBinding(stringKey); if (stringBinding == null || !stringBinding.isConstant()) { return null; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @SuppressWarnings(\"unchecked\") String stringValue = ((InstanceBinding<String>) stringBinding).getInstance(); Object source = stringBinding.getSource(); // Find a matching type converter. TypeLiteral<T> type = key.getTypeLiteral(); TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source); if (typeConverterBinding == null) { // No converter can handle the given type. return null; } // Try to convert the string. A failed conversion results in an error. try { @SuppressWarnings(\"unchecked\") // This cast is safe because we double check below. T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type); if (converted == null) { throw errors .converterReturnedNull(stringValue, source, type, typeConverterBinding) .toException(); } if (!type.getRawType().isInstance(converted)) { throw errors .conversionTypeError(stringValue, source, type, typeConverterBinding, converted) .toException(); } return new ConvertedConstantBindingImpl<T>( this, key, converted, stringBinding, typeConverterBinding); } catch (ErrorsException e) { throw e; } catch (RuntimeException e) { throw errors .conversionError(stringValue, source, type, typeConverterBinding, e) .toException(); } } \nResponse:", "ground_truth": "Converts a constant string binding to the required type.\n\n@return the binding if it could be resolved, or null if the binding doesn't exist\n@throws com.google.inject.internal.ErrorsException if there was an error resolving the binding", "predict": " Convert a constant string binding to the requested type. @throws ErrorsException if the value of the string binding cannot be converted to the requested type.\n*/"}
{"ID": 316, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean cleanup(BindingImpl<?> binding, Set<Key> encountered) { boolean bindingFailed = false; Set<Dependency<?>> deps = getInternalDependencies(binding); for (Dependency dep : deps) { Key<?> depKey = dep.getKey(); InjectionPoint ip = dep.getInjectionPoint(); if (encountered.add(depKey)) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings.get(depKey); if (depBinding != null) { // if the binding still exists, validate boolean failed = cleanup(depBinding, encountered); // if children fail, we fail if (depBinding instanceof ConstructorBindingImpl) { ConstructorBindingImpl ctorBinding = (ConstructorBindingImpl) depBinding; ip = ctorBinding.getInternalConstructor(); if (!ctorBinding.isInitialized()) { failed = true; } } if (failed) { removeFailedJitBinding(depBinding, ip); bindingFailed = true; } } else if (state.getExplicitBinding(depKey) == null) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true; } } } return bindingFailed; } \nResponse:", "ground_truth": "Iterates through the binding's dependencies to clean up any stray bindings that were leftover\nfrom a failed JIT binding. This is required because the bindings are eagerly & optimistically\nadded to allow circular dependency support, so dependencies may pass where they should have\nfailed.", "predict": " Cleans up all the bindings in the binding map. Removes entries for keys whose bindings have been cleaned up. Also removes orphan injections. @param encountered Keys of injected singletons encountered during cleanup. Singleton owners need not be accounted for here. They will be accounted for later. @return True if any cleanup actually happened, indicating that something is still broken. We'll leave it up to you to figure out what exactly is wrong."}
{"ID": 317, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeFailedJitBinding(Binding<?> binding, InjectionPoint ip) { failedJitBindings.add(binding.getKey()); jitBindings.remove(binding.getKey()); membersInjectorStore.remove(binding.getKey().getTypeLiteral()); provisionListenerStore.remove(binding); if (ip != null) { constructors.remove(ip); } } \nResponse:", "ground_truth": "Cleans up any state that may have been cached when constructing the JIT binding.", "predict": " Records that an attempt to create the binding failed. MembersInjectorImpl won't try to create the binding again until its reinitialized via reset(). This also marks the binding as a partially bound binding so that we preserve its unsatisfied dependencies until they can be resolved."}
{"ID": 318, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") private Set<Dependency<?>> getInternalDependencies(BindingImpl<?> binding) { if (binding instanceof ConstructorBindingImpl) { return ((ConstructorBindingImpl) binding).getInternalDependencies(); } else if (binding instanceof HasDependencies) { return ((HasDependencies) binding).getDependencies(); } else { return ImmutableSet.of(); } } \nResponse:", "ground_truth": "Safely gets the dependencies of possibly not initialized bindings.", "predict": " Returns the set of internal dependencies for the specified binding. These are dependencies that should be respected by observers of the binding. This includes dependencies inherited from the binding's supertypes. Internal dependencies are guaranteed to be notified by the framework regardless of the strength of the binding's observers. External observers are only guaranteed to be notified by the framework if they observe Binding Strength.STRONG. Strong observers are discouraged because they may unexpectedly influence the observable state of the binding. Conversely, weak observers may inadvertently influence observable state. Strong observers may also influence observable state indirectly through influencing the observable state of other bindings. Conversely, weak observers may also influence observable state indirectly through influencing the observable state of other bindings. Stability: Experimental"}
{"ID": 319, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> BindingImpl<T> createUninitializedBinding( Key<T> key, Scoping scoping, Object source, Errors errors, boolean jitBinding) throws ErrorsException { Class<?> rawType = key.getTypeLiteral().getRawType(); ImplementedBy implementedBy = rawType.getAnnotation(ImplementedBy.class); // Don't try to inject arrays or enums annotated with @ImplementedBy. if (rawType.isArray() || (rawType.isEnum() && implementedBy != null)) { throw errors.missingImplementationWithHint(key, this).toException(); } // Handle TypeLiteral<T> by binding the inner type if (rawType == TypeLiteral.class) { @SuppressWarnings(\"unchecked\") // we have to fudge the inner type as Object BindingImpl<T> binding = (BindingImpl<T>) createTypeLiteralBinding((Key<TypeLiteral<Object>>) key, errors); return binding; } // Handle @ImplementedBy if (implementedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createImplementedByBinding(key, scoping, implementedBy, errors); } // Handle @ProvidedBy. ProvidedBy providedBy = rawType.getAnnotation(ProvidedBy.class); if (providedBy != null) { Annotations.checkForMisplacedScopeAnnotations(rawType, source, errors); return createProvidedByBinding(key, scoping, providedBy, errors); } return ConstructorBindingImpl.create( this, key, null, /* use default constructor */ source, scoping, errors, jitBinding && options.jitDisabled, options.atInjectRequired); } \nResponse:", "ground_truth": "Creates a binding for an injectable type with the given scope. Looks for a scope on the type if\nnone is specified.", "predict": " Without guidance from the key, guesses the strategy from the presence of annotations. This guidance is heuristic and makes some assumptions about the annotations present on the injection point. Specifically, it assumes that all annotations with a binding annotation are binding annotations, and that all annotations without a binding annotation are unscoped. Also, it does not support injecting Providers."}
{"ID": 320, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object[] getAll(InternalContext context, SingleParameterInjector<?>[] parameterInjectors) throws InternalProvisionException { if (parameterInjectors == null) { return NO_ARGUMENTS; } int size = parameterInjectors.length; Object[] parameters = new Object[size]; // optimization: use manual for/each to save allocating an iterator here for (int i = 0; i < size; i++) { parameters[i] = parameterInjectors[i].inject(context); } return parameters; } \nResponse:", "ground_truth": "Returns an array of parameter values.", "predict": " Get all of the values injected by the parameters. @param context the context @param parameterInjectors the parameter injectors @return the values\n* @throws InternalProvisionException the internal provision exception\n*/"}
{"ID": 321, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindInjector(InjectorImpl injector) { Key<Injector> key = Key.get(Injector.class); InjectorFactory injectorFactory = new InjectorFactory(injector); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Injector>( injector, key, SourceProvider.UNKNOWN_SOURCE, injectorFactory, Scoping.UNSCOPED, injectorFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Injector is a special case because we allow both parent and child injectors to both have a\nbinding for that key.", "predict": " Bind the Injector to the guice Injector binding so that we can retrieve it later. We bind the binding directly to the state, so that it survives a refresh. We'll bind the real binding to the injector itself when someone asks for the binding."}
{"ID": 322, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void bindLogger(InjectorImpl injector) { Key<Logger> key = Key.get(Logger.class); LoggerFactory loggerFactory = new LoggerFactory(); injector.state.putBinding( key, new ProviderInstanceBindingImpl<Logger>( injector, key, SourceProvider.UNKNOWN_SOURCE, loggerFactory, Scoping.UNSCOPED, loggerFactory, ImmutableSet.<InjectionPoint>of())); } \nResponse:", "ground_truth": "The Logger is a special case because it knows the injection point of the injected member. It's\nthe only binding that does this.", "predict": " Bind Logger.class to the logger created by this injector. We'll use the logger to enhance debugging in case of problems."}
{"ID": 323, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) { Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation( errors, member, ((AnnotatedElement) member).getAnnotations()); if (misplacedBindingAnnotation == null) { return false; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if (member instanceof Method) { try { if (member.getDeclaringClass().getDeclaredField(member.getName()) != null) { return false; } } catch (NoSuchFieldException ignore) { } } errors.misplacedBindingAnnotation(member, misplacedBindingAnnotation); return true; } \nResponse:", "ground_truth": "Returns true if the binding annotation is in the wrong place.", "predict": " Checks that misplaced annotations intended for binding conformances are indeed so. Reports an error if misplaced.\n<p>The motivation for this pass is that Scala accepts binding annotations on everything, including fields, whereas Java only accepts them on constructors and methods. Thus, this pass warns about misplaced annotations that appear to be meant for binding conformances. Unfortunately, there's no way to tell if an annotation is meant for this, short of analyzing Scala source and refusing to accept annotations that wouldn't compile there.</p>\n<p>Interestingly, annotations implicitly added by javac for method overloading (@SafeVarargs) don't show up here because they don't have a direct equivalent in Scala source.</p>\n*/"}
{"ID": 324, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean overrides(Method a, Method b) { // See JLS section 8.4.8.1 int modifiers = b.getModifiers(); if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) { return true; } if (Modifier.isPrivate(modifiers)) { return false; } // b must be package-private return a.getDeclaringClass().getPackage().equals(b.getDeclaringClass().getPackage()); } \nResponse:", "ground_truth": "Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\nclass is a subclass of b's declaring class.", "predict": " Checks if one method overrides another. See JLS section 8.4.8.1. @param a The first method. @param b The second method. @return True if b overrides a. False otherwise."}
{"ID": 325, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(MembersInjector<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual members injector.\n\n@throws IllegalStateException if the delegate is already set", "predict": " Initializes the Rx MembersInjector delegating to another MembersInjector. Subsequent calls to injectMembers will delegate to the new MembersInjector. After calling this method, injectMembers will delegate to the specified MembersInjector. This method must be called exactly once.\n*/"}
{"ID": 326, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") final TypeLiteral<Provider<T>> providerType() { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())); } \nResponse:", "ground_truth": "Gets the type of this type's provider.", "predict": " Returns a TypeLiteral describing the provider type. We need this to appease the type system. Providers aren't generic, but because they extend Binding, they aren't automatically bound to their own type parameters. Instead, we manually pass them around. Fortunately, TypeLiteral understands how to turn a raw Class into a TypeLiteral."}
{"ID": 327, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<TypeLiteral<?>> resolveAll(Type[] types) { TypeLiteral<?>[] result = new TypeLiteral<?>[types.length]; for (int t = 0; t < types.length; t++) { result[t] = resolve(types[t]); } return ImmutableList.copyOf(result); } \nResponse:", "ground_truth": "Returns an immutable list of the resolved types.", "predict": " Resolve all types in the array. @param types The types to resolve. @return The resolved types."}
{"ID": 328, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> TypeLiteral<T> canonicalizeForKey(TypeLiteral<T> typeLiteral) { Type type = typeLiteral.getType(); if (!isFullySpecified(type)) { Errors errors = new Errors().keyNotFullySpecified(typeLiteral); throw new ConfigurationException(errors.getMessages()); } if (typeLiteral.getRawType() == javax.inject.Provider.class) { ParameterizedType parameterizedType = (ParameterizedType) type; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @SuppressWarnings(\"unchecked\") TypeLiteral<T> guiceProviderType = (TypeLiteral<T>) TypeLiteral.get(Types.providerOf(parameterizedType.getActualTypeArguments()[0])); return guiceProviderType; } @SuppressWarnings(\"unchecked\") TypeLiteral<T> wrappedPrimitives = (TypeLiteral<T>) PRIMITIVE_TO_WRAPPER.get(typeLiteral); if (wrappedPrimitives != null) { return wrappedPrimitives; } // If we know this isn't a subclass, return as-is. if (typeLiteral.getClass() == TypeLiteral.class) { return typeLiteral; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @SuppressWarnings(\"unchecked\") TypeLiteral<T> recreated = (TypeLiteral<T>) TypeLiteral.get(typeLiteral.getType()); return recreated; } \nResponse:", "ground_truth": "Returns an type that's appropriate for use in a key.\n\n<p>If the raw type of {@code typeLiteral} is a {@code javax.inject.Provider}, this returns a\n{@code com.google.inject.Provider} with the same type parameters.\n\n<p>If the type is a primitive, the corresponding wrapper type will be returned.\n\n@throws ConfigurationException if {@code type} contains a type variable", "predict": " Canonicalize a type literal. Canonicalize, in particular, converts diamonds (T -> A -> B) to thin triangles (A -> B). Although the original motivation for this method was Guice, callers find it useful in dealing with language inference within DI frameworks that use structural typing. For example, consider the following class hierarchy: @code List<Foo> class FooList extends AbstractList<Foo> {... } class Foo extends Bar<Foo> {... } class Bar<T> extends AbstractList<T> {... } Baz<Foo> baz = new Baz<Foo>() {... } Baz<Bar<Foo>> baz2 = new Baz<Bar<Foo>>() {... } Here we can infer that the upper bound of Baz<Bar<Foo>> is Bar<Foo>, since Baz<Foo> does not introduce any new information about the Bar<Foo> heirarchy. In contrast, if we tried to infer Baz<Bar<Foo>> = Baz"}
{"ID": 329, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static void prepareBuiltInConverters(InjectorImpl injector) { // Configure type converters. convertToPrimitiveType(injector, int.class, Integer.class); convertToPrimitiveType(injector, long.class, Long.class); convertToPrimitiveType(injector, boolean.class, Boolean.class); convertToPrimitiveType(injector, byte.class, Byte.class); convertToPrimitiveType(injector, short.class, Short.class); convertToPrimitiveType(injector, float.class, Float.class); convertToPrimitiveType(injector, double.class, Double.class); convertToClass( injector, Character.class, new TypeConverter() { @Override public Object convert(String value, TypeLiteral<?> toType) { value = value.trim(); if (value.length() != 1) { throw new RuntimeException(\"Length != 1.\"); } return value.charAt(0); } @Override public String toString() { return \"TypeConverter<Character>\"; } }); convertToClasses( injector, Matchers.subclassesOf(Enum.class), new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { return Enum.valueOf((Class) toType.getRawType(), value); } @Override public String toString() { return \"TypeConverter<E extends Enum<E>>\"; } }); internalConvertToTypes( injector, new AbstractMatcher<TypeLiteral<?>>() { @Override public boolean matches(TypeLiteral<?> typeLiteral) { return typeLiteral.getRawType() == Class.class; } @Override public String toString() { return \"Class<?>\"; } }, new TypeConverter() { @Override @SuppressWarnings(\"unchecked\") public Object convert(String value, TypeLiteral<?> toType) { try { return Class.forName(value); } catch (ClassNotFoundException e) { throw new RuntimeException(e.getMessage()); } } @Override public String toString() { return \"TypeConverter<Class<?>>\"; } }); } \nResponse:", "ground_truth": "Installs default converters for primitives, enums, and class literals.", "predict": " Prepares converters for primitives, enums, and classes. Primitive converters convert between numbers and their boxed types. Boxed converters convert between numbers and their unboxed types. Enum converters convert between strings and their constants. Classes converters convert between strings and classes. @param injector Guice injector to grab converters from.\n*/"}
{"ID": 330, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static ClassLoader canonicalize(ClassLoader classLoader) { return classLoader != null ? classLoader : SystemBridgeHolder.SYSTEM_BRIDGE.getParent(); } \nResponse:", "ground_truth": "Attempts to canonicalize null references to the system class loader. May return null if for\nsome reason the system loader is unavailable.", "predict": " Canonicalize the class loader. @param classLoader the class loader to canonicalize. @return the canonicalized class loader.\n*/"}
{"ID": 331, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasSameVersionOfCglib(ClassLoader classLoader) { Class<?> fc = net.sf.cglib.reflect.FastClass.class; try { return classLoader.loadClass(fc.getName()) == fc; } catch (ClassNotFoundException e) { return false; } } \nResponse:", "ground_truth": "Returns true if the types classloader has the same version of cglib that BytecodeGen has. This\nonly returns false in strange OSGI situations, but it prevents us from using FastClass for non\npublic members.", "predict": " Check whether CGLIB is present in the classpath. Unfortunately, CGLIB is not standardized across Java versions, so we have to resort to probing the classpath. @param classLoader The class loader to probe. @return Whether CGLIB is available."}
{"ID": 332, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean isPubliclyCallable(Member member) { if (!Modifier.isPublic(member.getModifiers())) { return false; } Class<?>[] parameterTypes; if (member instanceof Constructor) { parameterTypes = ((Constructor) member).getParameterTypes(); } else { Method method = (Method) member; if (!Modifier.isPublic(method.getReturnType().getModifiers())) { return false; } parameterTypes = method.getParameterTypes(); } for (Class<?> type : parameterTypes) { if (!Modifier.isPublic(type.getModifiers())) { return false; } } return true; } \nResponse:", "ground_truth": "Returns true if the member can be called by a fast class generated in a different classloader.", "predict": " Checks if the given member is publicly callable. @param member Member to check. @return True if publicly callable, false otherwise."}
{"ID": 333, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Key<?> fixAnnotations(Key<?> key) { return key.getAnnotation() == null ? key : Key.get(key.getTypeLiteral(), key.getAnnotation().annotationType()); } \nResponse:", "ground_truth": "Replace annotation instances with annotation types, this is only appropriate for testing if a\nkey is bound and not for injecting.\n\n<p>See Guice bug 125, https://github.com/google/guice/issues/125", "predict": " Fix the annotations on the key to ensure that they meet expectations. Specifically, ensure that there is exactly one Guice injected annotation on the key. @param key The key whose annotations we wish to correct. @return The corrected Key.\n*/"}
{"ID": 334, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Initializable<T> requestInjection( InjectorImpl injector, T instance, Binding<T> binding, Object source, Set<InjectionPoint> injectionPoints) { checkNotNull(source); Preconditions.checkState( !validationStarted, \"Member injection could not be requested after validation is started\"); ProvisionListenerStackCallback<T> provisionCallback = binding == null ? null : injector.provisionListenerStore.get(binding); // short circuit if the object has no injections or listeners. if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners() && provisionCallback == null)) { return Initializables.of(instance); } if (initializablesCache.containsKey(instance)) { @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T> Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance); return cached; } InjectableReference<T> injectableReference = new InjectableReference<T>( injector, instance, binding == null ? null : binding.getKey(), provisionCallback, source, cycleDetectingLockFactory.create(instance.getClass())); initializablesCache.put(instance, injectableReference); pendingInjections.add(injectableReference); return injectableReference; } \nResponse:", "ground_truth": "Registers an instance for member injection when that step is performed.\n\n@param instance an instance that optionally has members to be injected (each annotated\nwith @Inject).\n@param binding the binding that caused this initializable to be created, if it exists.\n@param source the source location that this injection was requested", "predict": " Issues each of the injections on the instance and catches any exceptions thrown by DI framework methods. Reports these caught exceptions to the hosting Instrumentation. Also reports uncaught exceptions to hosting Instrumentation.\n<p>This method is intentionally not static so as to perform DI resolution across the board. Ideally DI frameworks would expose DI resolution facilities at the DI framework level. However, we want to maintain backward compatibility with older frameworks, so DI frameworks need to be able to resolve injections at the DI framework level. Therefore, DI frameworks need to expose DI resolution facilities at the DI framework level. Unfortunately, DI frameworks cannot easily do so because DI frameworks need to evolve independently from injection frameworks. Therefore, frameworks evolved independently from injection frameworks. Injection frameworks evolve independently from DI frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI frameworks evolve independently from injection frameworks. Therefore, DI"}
{"ID": 335, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void validateOustandingInjections(Errors errors) { validationStarted = true; initializablesCache.clear(); for (InjectableReference<?> reference : pendingInjections) { try { reference.validate(errors); } catch (ErrorsException e) { errors.merge(e.getErrors()); } } } \nResponse:", "ground_truth": "Prepares member injectors for all injected instances. This prompts Guice to do static analysis\non the injected instances.", "predict": " Validates outstanding injections against eligible injection points. @throws ErrorsException if there are errors.\n*/"}
{"ID": 336, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T newInstance(Object[] args) throws Throwable { constructor.setAccessible(true); try { return constructor.newInstance(args); } catch (InvocationTargetException e) { throw e.getCause(); } } \nResponse:", "ground_truth": "Returns an instance of T, constructed using this constructor, with the supplied arguments.", "predict": " Invokes the constructor with the given arguments. @param args Arguments to pass to the constructor. @return Newly constructed instance. @throws Throwable Construction failure.\n*/"}
{"ID": 337, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"JavaDoc\", \"deprecation\"}) private ServletRequest withDispatcher( ServletRequest servletRequest, final ManagedServletPipeline servletPipeline) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if (!servletPipeline.hasServletsMapped()) { return servletRequest; } HttpServletRequest request = (HttpServletRequest) servletRequest; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper(request) { @Override public RequestDispatcher getRequestDispatcher(String path) { final RequestDispatcher dispatcher = servletPipeline.getRequestDispatcher(path); return (null != dispatcher) ? dispatcher : super.getRequestDispatcher(path); } }; } \nResponse:", "ground_truth": "Used to create an proxy that dispatches either to the guice-servlet pipeline or the regular\npipeline based on uri-path match. This proxy also provides minimal forwarding support.\n\n<p>We cannot forward from a web.xml Servlet/JSP to a guice-servlet (because the filter pipeline\nis not called again). However, we can wrap requests with our own dispatcher to forward the\n*other* way. web.xml Servlets/JSPs can forward to themselves as per normal.\n\n<p>This is not a problem cuz we intend for people to migrate from web.xml to guice-servlet,\nincrementally, but not the other way around (which, we should actively discourage).", "predict": " Wrap the ServletRequest with a dispatcher if there are mapped servlets. This prevents us from inserting our wrapper unless it's actually going to be used. This is necessary for compatibility for apps that downcast their HttpServletRequests to a concrete implementation. @param servletRequest The ServletRequest to wrap. @param servletPipeline The pipeline to use to locate applicable servlets. @return The ServletRequestWrapper wrapping the original ServletRequest.\n"}
{"ID": 338, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> InternalFactory<? extends T> scope( Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) { if (scoping.isNoScope()) { return creator; } Scope scope = scoping.getScopeInstance(); // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here. If you change the type make sure to update // SingletonScope as well. Provider<T> scoped = scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator)); return new InternalFactoryToProviderAdapter<T>(scoped, source); } \nResponse:", "ground_truth": "Scopes an internal factory.", "predict": " Returns a factory that applies a scope to the object returned by the factory. The scope is applied at the injector level, meaning that repeated calls to this method will return new factories, each with their own lifetime scope. @param <T> The type of the object returned by the factory.\n*/\npublic static <T> InternalFactory<? extends T> scope(Key<T> key, InjectorImpl injector, InternalFactory<? extends T> creator, Object source, Scoping scoping) {\n  if (scoping.isNoScope()) {\n    return creator;\n  }\n  Scope scope = scoping.getScopeInstance();\n  return scope.scope(key, new ProviderToInternalFactoryAdapter<T>(injector, creator));\n}\n}\n"}
{"ID": 339, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Scoping makeInjectable(Scoping scoping, InjectorImpl injector, Errors errors) { Class<? extends Annotation> scopeAnnotation = scoping.getScopeAnnotation(); if (scopeAnnotation == null) { return scoping; } ScopeBinding scope = injector.state.getScopeBinding(scopeAnnotation); if (scope != null) { return forInstance(scope.getScope()); } errors.scopeNotFound(scopeAnnotation); return UNSCOPED; } \nResponse:", "ground_truth": "Replaces annotation scopes with instance scopes using the Injector's annotation-to-instance\nmap. If the scope annotation has no corresponding instance, an error will be added and unscoped\nwill be retuned.", "predict": " Makes sure that scoping annotation is consistent with bindings. Binding might override scoping annotation that was previously set by the user. Consistent bindings stay wins. Inconsistent bindings are ignored. <p> TODO(dpb): Technically, this doesn't quite satisfy people who want their scope annotation inherited. People want the union of all their scopes and exclusions. However, nobody ever complained about it, so \u00af\\_(\u30c4)_/\u00af. \u00af\\_(\u30c4)_/\u00af IE9 team @author jesse.tang - august 2014"}
{"ID": 340, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static String normalizePath(String path) { StringBuilder sb = new StringBuilder(path.length()); int queryStart = path.indexOf('?'); String query = null; if (queryStart != -1) { query = path.substring(queryStart); path = path.substring(0, queryStart); } // Normalize the path. we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters. e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List<String> segments = new ArrayList<>(); for (String segment : SLASH_SPLITTER.split(path)) { // This decodes all non-special characters from the path segment. so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers.urlPathSegmentEscaper().escape(lenientDecode(segment, UTF_8, false)); if (\".\".equals(normalized)) { // skip } else if (\"..\".equals(normalized)) { if (segments.size() > 1) { segments.remove(segments.size() - 1); } } else { segments.add(normalized); } } SLASH_JOINER.appendTo(sb, segments); if (query != null) { sb.append(query); } return sb.toString(); } \nResponse:", "ground_truth": "Normalizes a path by unescaping all safe, percent encoded characters.", "predict": " Normalizes the path removing sequences like \"/./\" and \"#...\" and so on.\n * @param path the path to normalize\n * @return the normalized path\n */"}
{"ID": 341, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Annotation> T generateAnnotation(Class<T> annotationType) { Preconditions.checkState( isAllDefaultMethods(annotationType), \"%s is not all default methods\", annotationType); return (T) cache.getUnchecked(annotationType); } \nResponse:", "ground_truth": "Generates an Annotation for the annotation class. Requires that the annotation is all\noptionals.", "predict": " Generates an annotation mirror for the given annotation class. The mirror will have dummy values for all members. @throws IllegalArgumentException if the annotation is not all default methods\n*/"}
{"ID": 342, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isRetainedAtRuntime(Class<? extends Annotation> annotationType) { Retention retention = annotationType.getAnnotation(Retention.class); return retention != null && retention.value() == RetentionPolicy.RUNTIME; } \nResponse:", "ground_truth": "Returns true if the given annotation is retained at runtime.", "predict": " Answers if the retention policy for the annotated element is RUNTIME. @param annotationType The annotation type to check. @return True if RUNTIME, false otherwise."}
{"ID": 343, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class<? extends Annotation> findScopeAnnotation( Errors errors, Annotation[] annotations) { Class<? extends Annotation> found = null; for (Annotation annotation : annotations) { Class<? extends Annotation> annotationType = annotation.annotationType(); if (isScopeAnnotation(annotationType)) { if (found != null) { errors.duplicateScopeAnnotations(found, annotationType); } else { found = annotationType; } } } return found; } \nResponse:", "ground_truth": "Returns the scoping annotation, or null if there isn't one.", "predict": " Finds the first scope annotation on the given annotations array. Scopes are identified by looking for classes annotated with the Scoped qualifier. Classes are scanned in order they are encountered during the inheritance hierarchy traversal. If a class declares more than one scoped qualifier, the first one encountered wins. Scoped qualifiers are inherited, so scanning occurs at runtime. @param annotations Annotations to inspect @return First scope annotation encountered or null if none found"}
{"ID": 344, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Key<?> getKey( TypeLiteral<?> type, Member member, Annotation[] annotations, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Annotation found = findBindingAnnotation(errors, member, annotations); errors.throwIfNewErrors(numErrorsBefore); return found == null ? Key.get(type) : Key.get(type, found); } \nResponse:", "ground_truth": "Gets a key for the given type, member and annotations.", "predict": " Returns a key for the given type and member. @param type the type of the binding. @param member the member annotated with a binding annotation (must be a field or setter). @param annotations the annotations on the member. @throws ErrorsException if there are errors looking up the key. @since 3.0"}
{"ID": 345, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String nameOf(Key<?> key) { Annotation annotation = key.getAnnotation(); Class<? extends Annotation> annotationType = key.getAnnotationType(); if (annotation != null && !isMarker(annotationType)) { return key.getAnnotation().toString(); } else if (key.getAnnotationType() != null) { return \"@\" + key.getAnnotationType().getName(); } else { return \"\"; } } \nResponse:", "ground_truth": "Returns the name the binding should use. This is based on the annotation. If the annotation has\nan instance and is not a marker annotation, we ask the annotation for its toString. If it was a\nmarker annotation or just an annotation type, we use the annotation's name. Otherwise, the name\nis the empty string.", "predict": " Returns a string representation of the binding key. For example, consider a binding with a key of Key.get(new TypeLiteral<SomeClass>() {}). The string representation of that key is \"Key<SomeClass>\" @param key The binding key to convert to a string. @return A string representation of the binding key."}
{"ID": 346, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void initializeDelegate(Provider<T> delegate) { checkState(this.delegate == null, \"delegate already initialized\"); this.delegate = checkNotNull(delegate, \"delegate\"); } \nResponse:", "ground_truth": "Sets the actual provider.\n\n@throws IllegalStateException if the delegate is already set", "predict": " Associates this authenticator with a delegate. Useful for delegating to another Authenticator, but retaining the same KeyManager. Used primarily by InstrumentedHttpClients. @param delegate Authenticator to delegate to. Must not be null.\n*/"}
{"ID": 347, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addDirectTypeBinding(Binder binder) { binder .bind(bindingSelection.getDirectKey()) .toProvider(new RealDirectTypeProvider<T>(bindingSelection)); } \nResponse:", "ground_truth": "Adds a binding for T. Multiple calls to this are safe, and will be collapsed as duplicate\nbindings.", "predict": " Direct binding to the direct key."}
{"ID": 348, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ConstructorInjector<?> get(InjectionPoint constructorInjector, Errors errors) throws ErrorsException { return cache.get(constructorInjector, errors); } \nResponse:", "ground_truth": "Returns a new complete constructor injector with injection listeners registered.", "predict": " Returns the constructor injector for the given constructor. There must be exactly one constructor annotated with @Inject. The constructor must be accessible to the injector. @throws ConfigurationException if there is no accessible constructor annotated with @Inject. @since 2.0"}
{"ID": 349, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasScope(Class<? extends Interceptor> interceptorClass) { for (Annotation annotation : interceptorClass.getAnnotations()) { if (Annotations.isScopeAnnotation(annotation.annotationType())) { return true; } } return false; } \nResponse:", "ground_truth": "Returns true if the given class has a scope annotation.", "predict": " Checks if the interceptor class has scope annotation. @param interceptorClass Interceptor class. @return True if the interceptor class has scope annotation. False otherwise."}
{"ID": 350, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <K, V> RealMapBinder<K, V> newRealMapBinder( Binder binder, TypeLiteral<K> keyType, Key<V> valueTypeAndAnnotation) { binder = binder.skipSources(RealMapBinder.class); TypeLiteral<V> valueType = valueTypeAndAnnotation.getTypeLiteral(); return newRealMapBinder( binder, keyType, valueType, valueTypeAndAnnotation.ofType(mapOf(keyType, valueType)), RealMultibinder.newRealSetBinder( binder, valueTypeAndAnnotation.ofType(entryOfProviderOf(keyType, valueType)))); } \nResponse:", "ground_truth": "since it's an easy way to group a type and an optional annotation type or instance.", "predict": " Like Multibinder.newSetBinder, but with a different error message."}
{"ID": 351, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<V> getKeyForNewValue(K key) { checkNotNull(key, \"key\"); checkConfiguration(!bindingSelection.isInitialized(), \"MapBinder was already initialized\"); RealMultibinder<Map.Entry<K, Provider<V>>> entrySetBinder = bindingSelection.getEntrySetBinder(); Key<V> valueKey = Key.get( bindingSelection.getValueType(), new RealElement( entrySetBinder.getSetName(), MAPBINDER, bindingSelection.getKeyType().toString())); entrySetBinder.addBinding().toProvider(new ProviderMapEntry<K, V>(key, valueKey)); return valueKey; } \nResponse:", "ground_truth": "Adds a binding to the map for the given key.", "predict": " Returns a key similar to the one requested, but with provisions for injecting a different key entirely, or for injecting a key with a different type altogether.\n*/"}
{"ID": 352, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private T provision(InternalContext context, ConstructionContext<T> constructionContext) throws InternalProvisionException { try { T t; try { Object[] parameters = SingleParameterInjector.getAll(context, parameterInjectors); t = constructionProxy.newInstance(parameters); constructionContext.setProxyDelegates(t); } finally { constructionContext.finishConstruction(); } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext.setCurrentReference(t); MembersInjectorImpl<T> localMembersInjector = membersInjector; localMembersInjector.injectMembers(t, context, false); localMembersInjector.notifyListeners(t); return t; } catch (InvocationTargetException userException) { Throwable cause = userException.getCause() != null ? userException.getCause() : userException; throw InternalProvisionException.errorInjectingConstructor(cause) .addSource(constructionProxy.getInjectionPoint()); } finally { constructionContext.removeCurrentReference(); } } \nResponse:", "ground_truth": "Provisions a new T.", "predict": " Provision an instance. Guards against recursive provisioning. Ensures that injections are always performed from the root injector. Leaves the construction context open for reuse. Leaves the construction proxy open for reuse. Leaves the members injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for reuse. Leaves the current reference open for reuse. Leaves the injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for reuse. Leaves the current reference open for reuse. Leaves the injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for reuse. Leaves the current reference open for reuse. Leaves the injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for reuse. Leaves the current reference open for reuse. Leaves the injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for reuse. Leaves the current reference open for reuse. Leaves the injector open for reuse. Leaves the listeners open for reuse. Leaves the construction context open for"}
{"ID": 353, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object writeReplace() throws ObjectStreamException { Object[] sourcesAsStrings = sources.toArray(); for (int i = 0; i < sourcesAsStrings.length; i++) { sourcesAsStrings[i] = Errors.convert(sourcesAsStrings[i]).toString(); } return new Message(ImmutableList.copyOf(sourcesAsStrings), message, cause); } \nResponse:", "ground_truth": "When serialized, we eagerly convert sources to strings. This hurts our formatting, but it\nguarantees that the receiving end will be able to read the message.", "predict": " Serialization hook for ensuring that we always have an ImmutableList when we deserialize. Without this, we'll sometimes have a MutableList, which confuses equals() and hashCode(). Oh well. Stupid immutable collections API."}
{"ID": 354, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Module forModule(Module module) { // avoid infinite recursion, since installing a module always installs itself if (module instanceof CheckedProviderMethodsModule) { return Modules.EMPTY_MODULE; } return new CheckedProviderMethodsModule(module); } \nResponse:", "ground_truth": "Returns a module which creates bindings for provider methods from the given module.", "predict": " Prevents infinite recursion when installing a CheckedProviderMethodsModule.\n"}
{"ID": 355, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings(\"unchecked\") public Collection<AssistedMethod> getAssistedMethods() { return (Collection<AssistedMethod>) (Collection<?>) assistDataByMethod.values(); } \nResponse:", "ground_truth": "the collection is immutable.", "predict": " Returns all assistedMethods declared in this class. Useful for IDE auto-completion."}
{"ID": 356, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isTypeNotSpecified(TypeLiteral<?> typeLiteral, ConfigurationException ce) { Collection<Message> messages = ce.getErrorMessages(); if (messages.size() == 1) { Message msg = Iterables.getOnlyElement(new Errors().keyNotFullySpecified(typeLiteral).getMessages()); return msg.getMessage().equals(Iterables.getOnlyElement(messages).getMessage()); } else { return false; } } \nResponse:", "ground_truth": "Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully\nspecified.", "predict": " Hack to deal with deficiencies in the inferrer. Specifically, inferrer doesn't understand that literals are inferred *after* everything else is inferred, so we infer types *before* everything else is inferred. This hack moves inferred types *after* everything else was inferred. Fortunately, inferrer seems to understand literals better than everything else, so we're OK. Caveat Emptor.\n */"}
{"ID": 357, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean constructorHasMatchingParams( TypeLiteral<?> type, Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException { List<TypeLiteral<?>> params = type.getParameterTypes(constructor); Annotation[][] paramAnnotations = constructor.getParameterAnnotations(); int p = 0; List<Key<?>> constructorKeys = Lists.newArrayList(); for (TypeLiteral<?> param : params) { Key<?> paramKey = Annotations.getKey(param, constructor, paramAnnotations[p++], errors); constructorKeys.add(paramKey); } // Require that every key exist in the constructor to match up exactly. for (Key<?> key : paramList) { // If it didn't exist in the constructor set, we can't use it. if (!constructorKeys.remove(key)) { return false; } } // If any keys remain and their annotation is Assisted, we can't use it. for (Key<?> key : constructorKeys) { if (key.getAnnotationType() == Assisted.class) { return false; } } // All @Assisted params match up to the method's parameters. return true; } \nResponse:", "ground_truth": "Matching logic for constructors annotated with AssistedInject. This returns true if and only if\nall @Assisted parameters in the constructor exactly match (in any order) all @Assisted\nparameters the method's parameter.", "predict": " Matches up param keys to a constructor annotated with @AssistedInject. Follows the same matching rules as KeyFactory#getKey. @param type TypeLiteral describing the assisted injectable type. @param constructor Constructor to introspect. @param paramList Keys to match up against this assisted injectable's parameters. @param errors Errors resulting from type comparisons. @return True if all assisted inject param keys were satisfied. False otherwise."}
{"ID": 358, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> getDependencies( InjectionPoint ctorPoint, TypeLiteral<?> implementation) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); builder.addAll(ctorPoint.getDependencies()); if (!implementation.getRawType().isInterface()) { for (InjectionPoint ip : InjectionPoint.forInstanceMethodsAndFields(implementation)) { builder.addAll(ip.getDependencies()); } } return builder.build(); } \nResponse:", "ground_truth": "Calculates all dependencies required by the implementation and constructor.", "predict": " Collect all dependencies transitively reachable via the injectable constructor injection point. Dependencies will be collected from the implementation class, inaccessible superclasses, enclosing classes, and enclosing interfaces. Members injection will also be considered. Members injection is transitive, so dependencies will also be considered transitively reachable.\n */"}
{"ID": 359, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Set<Dependency<?>> removeAssistedDeps(Set<Dependency<?>> deps) { ImmutableSet.Builder<Dependency<?>> builder = ImmutableSet.builder(); for (Dependency<?> dep : deps) { Class<?> annotationType = dep.getKey().getAnnotationType(); if (annotationType == null || !annotationType.equals(Assisted.class)) { builder.add(dep); } } return builder.build(); } \nResponse:", "ground_truth": "Return all non-assisted dependencies.", "predict": " Remove any dependencies satisfied by the assisted injector from the accumulating set of unsatisfied dependencies. Leaves the injected constructor untouched."}
{"ID": 360, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isValidForOptimizedAssistedInject( Set<Dependency<?>> dependencies, Class<?> implementation, TypeLiteral<?> factoryType) { Set<Dependency<?>> badDeps = null; // optimization: create lazily for (Dependency<?> dep : dependencies) { if (isInjectorOrAssistedProvider(dep)) { if (badDeps == null) { badDeps = Sets.newHashSet(); } badDeps.add(dep); } } if (badDeps != null && !badDeps.isEmpty()) { logger.log( Level.WARNING, \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!) \" + \"The exact offending deps are: {2}\", new Object[] {factoryType, implementation, badDeps}); return false; } return true; } \nResponse:", "ground_truth": "Returns true if all dependencies are suitable for the optimized version of AssistedInject. The\noptimized version caches the binding & uses a ThreadLocal Provider, so can only be applied if\nthe assisted bindings are immediately provided. This looks for hints that the values may be\nlazily retrieved, by looking for injections of Injector or a Provider for the assisted values.", "predict": " Returns true if assisted inject is faster than normal inject. Cases deemed unlikely are warned about, but not necessarily banned. Things that are banned are: Guice assisted inject + child injectors (which is inherently unsafe). Things that are discouraged but not banned are: Dagger 2 @Assisted annotation on concrete producers, and concrete producers with DI bodies. Dagger 2 producers with assisted DI bodies are discouraged but not banned. Other DI frameworks are not considered here (rather pointless, since assisted inject almost certainly wouldn't hurt anyone using them). Other frameworks might benefit or even warn about assisted inject, but it's upto you to decide. Often assisted inject is just plain inferior to DI everywhere else. Whereas DI solves difficult problems in a declarative way, assisted inject encourages you to solve them at awkward and inefficient runtime cost. Especially assisted inject doesn't even solve the \"problem at runtime cost\"! Rather it introduces it to unsuspecting users! Needless to say, assisted inject is inferior everywhere except in DI frameworks that care about speed and efficiency. Don't use assisted inject unless you have to. Good"}
{"ID": 361, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<?> getBindingFromNewInjector( final Method method, final Object[] args, final AssistData data) { checkState( injector != null, \"Factories.create() factories cannot be used until they're initialized by Guice.\"); final Key<?> returnType = data.returnType; // We ignore any pre-existing binding annotation. final Key<?> returnKey = Key.get(returnType.getTypeLiteral(), RETURN_ANNOTATION); Module assistedModule = new AbstractModule() { @Override @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // raw keys are necessary for the args array and return value protected void configure() { Binder binder = binder().withSource(method); int p = 0; if (!data.optimized) { for (Key<?> paramKey : data.paramTypes) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder.bind((Key) paramKey).toProvider(Providers.of(args[p++])); } } else { for (Key<?> paramKey : data.paramTypes) { // Bind to our ThreadLocalProviders. binder.bind((Key) paramKey).toProvider(data.providers.get(p++)); } } Constructor constructor = data.constructor; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if (constructor != null) { binder .bind(returnKey) .toConstructor(constructor, (TypeLiteral) data.implementationType) .in(Scopes.NO_SCOPE); // make sure we erase any scope on the implementation type } } }; Injector forCreate = injector.createChildInjector(assistedModule); Binding<?> binding = forCreate.getBinding(returnKey); // If we have providers cached in data, cache the binding for future optimizations. if (data.optimized) { data.cachedBinding = binding; } return binding; } \nResponse:", "ground_truth": "Creates a child injector that binds the args, and returns the binding for the method's result.", "predict": " Creates a binding for the method annotated with NewBinder. This binding will only ever be used to satisfy injections of the method's parameters. Specifically, it will be used as a provider for those injections, and will satisfy eager singletons. Additionally, it will satisfy injections of eager singletons, eager collections, eager maps, eager multimaps, eager sets, eager iterables, suppliers, and anything annotated with @AssistedInject. Lastly, it will satisfy injections of injections, injecting the assistData into the ultimate binding so that assisted injections can be satisfied."}
{"ID": 362, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if (methodHandleByMethod.containsKey(method)) { return methodHandleByMethod.get(method).invokeWithArguments(args); } if (method.getDeclaringClass().equals(Object.class)) { if (\"equals\".equals(method.getName())) { return proxy == args[0]; } else if (\"hashCode\".equals(method.getName())) { return System.identityHashCode(proxy); } else { return method.invoke(this, args); } } AssistData data = assistDataByMethod.get(method); checkState(data != null, \"No data for method: %s\", method); Provider<?> provider; if (data.cachedBinding != null) { // Try to get optimized form... provider = data.cachedBinding.getProvider(); } else { provider = getBindingFromNewInjector(method, args, data).getProvider(); } try { int p = 0; for (ThreadLocalProvider tlp : data.providers) { tlp.set(args[p++]); } return provider.get(); } catch (ProvisionException e) { // if this is an exception declared by the factory method, throw it as-is if (e.getErrorMessages().size() == 1) { Message onlyError = getOnlyElement(e.getErrorMessages()); Throwable cause = onlyError.getCause(); if (cause != null && canRethrow(method, cause)) { throw cause; } } throw e; } finally { for (ThreadLocalProvider tlp : data.providers) { tlp.remove(); } } } \nResponse:", "ground_truth": "When a factory method is invoked, we create a child injector that binds all parameters, then\nuse that to get an instance of the return type.", "predict": " Invokes the method on the proxied instance. @param args Arguments to the method. May be ignored. @return The return value of the method. May be ignored. @throws Throwable If anything goes wrong. Wrapped by Proxies.realize(). Only declared exceptions will be propagated. Others will be treated as unchecked Proxies.realize() exceptions.\n*/"}
{"ID": 363, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <T> Errors missingImplementationWithHint(Key<T> key, Injector injector) { StringBuilder sb = new StringBuilder(); sb.append(format(\"No implementation for %s was bound.\", key)); // Keys which have similar strings as the desired key List<String> possibleMatches = new ArrayList<>(); // Check for other keys that may have the same type, // but not the same annotation TypeLiteral<T> type = key.getTypeLiteral(); List<Binding<T>> sameTypes = injector.findBindingsByType(type); if (!sameTypes.isEmpty()) { sb.append(format(\"%n Did you mean?\")); int howMany = Math.min(sameTypes.size(), MAX_MATCHING_TYPES_REPORTED); for (int i = 0; i < howMany; ++i) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb.append(format(\"%n * %s\", sameTypes.get(i).getKey())); } int remaining = sameTypes.size() - MAX_MATCHING_TYPES_REPORTED; if (remaining > 0) { String plural = (remaining == 1) ? \"\" : \"s\"; sb.append(format(\"%n %d more binding%s with other annotations.\", remaining, plural)); } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type.toString(); Map<Key<?>, Binding<?>> bindingMap = injector.getAllBindings(); for (Key<?> bindingKey : bindingMap.keySet()) { String have = bindingKey.getTypeLiteral().toString(); if (have.contains(want) || want.contains(have)) { Formatter fmt = new Formatter(); Messages.formatSource(fmt, bindingMap.get(bindingKey).getSource()); String match = String.format(\"%s bound%s\", convert(bindingKey), fmt.toString()); possibleMatches.add(match); // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if (possibleMatches.size() > MAX_RELATED_TYPES_REPORTED) { // Early exit if we have found more than we need. break; } } } if ((possibleMatches.size() > 0) && (possibleMatches.size() <= MAX_RELATED_TYPES_REPORTED)) { sb.append(format(\"%n Did you mean?\")); for (String possibleMatch : possibleMatches) { sb.append(format(\"%n %s\", possibleMatch)); } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if (sameTypes.isEmpty() && possibleMatches.isEmpty() && key.getAnnotation() == null && COMMON_AMBIGUOUS_TYPES.contains(key.getTypeLiteral().getRawType())) { // We don't recommend using such simple types without annotations. sb.append(format(\"%nThe key seems very generic, did you forget an annotation?\")); } return addMessage(sb.toString()); } \nResponse:", "ground_truth": "Within guice's core, allow for better missing binding messages", "predict": " Missing implementation guidance. Suggestions are prioritized based on how vague the suggestion is. Suggestions are ranked as vague if they are: 1) vague imports, 2) vague unrelated imports, 3) vague imports with unrelated types, 4) vague unrelated types, 5) vague imports with unrelated types, 6) vague imports with ambiguous types, 7) vague unrelated types, 8) vague imports with ambiguous types, 9) vague ambiguous types, 10) vague unrelated types, 11) vague ambiguous types, 12) vague imports with ambiguous types, 13) vague ambiguous types, 14) vague unrelated types, 15) vague ambiguous types, 16) vague imports with ambiguous types, 17) vague ambiguous types, 18) vague unrelated types, 19) vague ambiguous types, 20) vague unrelated types, 21) vague ambiguous types, 22) vague unrelated types, 23) vague ambiguous types, 24) vague unrelated types, 25) vague ambiguous types, 26) vague unrelated types, 27) vague ambiguous types, 28) vague unrelated types, 29) vague ambiguous types, 30) vague unrelated"}
{"ID": 364, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> RealMultibinder<T> newRealSetBinder(Binder binder, Key<T> key) { binder = binder.skipSources(RealMultibinder.class); RealMultibinder<T> result = new RealMultibinder<>(binder, key); binder.install(result); return result; } \nResponse:", "ground_truth": "Implementation of newSetBinder.", "predict": " Without this method, we would need to rewrite the RealMultibinder itself. Instead, we rely on the RealMultibinder being skipped by our Binder. Hopefully we'll improve upon that in the future.\n"}
{"ID": 365, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Key<T> getKeyForNewItem() { checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\"); return Key.get( bindingSelection.getElementTypeLiteral(), new RealElement(bindingSelection.getSetName(), MULTIBINDER, \"\")); } \nResponse:", "ground_truth": "Adds a new entry to the set and returns the key for it.", "predict": " Returns the key that will be used to look up the bindingSelection. This will be a key for the Multibinder itself, unless bindingSelection is a Singleton. In that case, it will be a key for the Singleton itself."}
{"ID": 366, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Filter findNextFilter(HttpServletRequest request) { while (++index < filterDefinitions.length) { Filter filter = filterDefinitions[index].getFilterIfMatching(request); if (filter != null) { return filter; } } return null; } \nResponse:", "ground_truth": "Iterates over the remaining filter definitions. Returns the first applicable filter, or null if\nnone apply.", "predict": " Find the next filter to execute. Searches the entire filter chain starting at the farthest downstream filter. @param request The HTTP request. @return The next filter to execute, or null if there aren't any more filters to execute.\n*/"}
{"ID": 367, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean hasAtInject(Constructor cxtor) { return cxtor.isAnnotationPresent(Inject.class) || cxtor.isAnnotationPresent(javax.inject.Inject.class); } \nResponse:", "ground_truth": "Returns true if the inject annotation is on the constructor.", "predict": " Checks if the constructor has at least one injection annotation. @param cxtor The constructor to check. @return True if the constructor has at least one injection annotation, false otherwise."}
{"ID": 368, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: InjectionPoint getInternalConstructor() { if (factory.constructorInjector != null) { return factory.constructorInjector.getConstructionProxy().getInjectionPoint(); } else { return constructorInjectionPoint; } } \nResponse:", "ground_truth": "Returns an injection point that can be used to clean up the constructor store.", "predict": " Lazily obtain the ConstructionProxyInjector for this constructor injection point. ConstructionProxyInjectors are cached, so this method is cheap. @return ConstructionProxyInjector for this constructor injection point\n*/"}
{"ID": 369, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Set<Dependency<?>> getInternalDependencies() { ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder(); if (factory.constructorInjector == null) { builder.add(constructorInjectionPoint); // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder.addAll( InjectionPoint.forInstanceMethodsAndFields( constructorInjectionPoint.getDeclaringType())); } catch (ConfigurationException ignored) { } } else { builder.add(getConstructor()).addAll(getInjectableMembers()); } return Dependency.forInjectionPoints(builder.build()); } \nResponse:", "ground_truth": "Returns a set of dependencies that can be iterated over to clean up stray JIT bindings.", "predict": " Returns dependencies that will be provisioned by this MembersInjector."}
{"ID": 370, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Module forModule(Object module, ModuleAnnotatedMethodScanner scanner) { return forObject(module, false, scanner); } \nResponse:", "ground_truth": "Returns a module which creates bindings methods in the module that match the scanner.", "predict": " Creates a Module object for the given module. The scanner is used to discover annotated methods. The scanner is not used to discover classes. @param module The module to introspect. @param scanner The scanner to use to discover annotated methods. @return A Module object for the given module.\n**/"}
{"ID": 371, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Annotation getAnnotation(Binder binder, Method method) { if (method.isBridge() || method.isSynthetic()) { return null; } Annotation annotation = null; for (Class<? extends Annotation> annotationClass : scanner.annotationClasses()) { Annotation foundAnnotation = method.getAnnotation(annotationClass); if (foundAnnotation != null) { if (annotation != null) { binder.addError( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\", scanner, method); return null; } annotation = foundAnnotation; } } return annotation; } \nResponse:", "ground_truth": "Returns the annotation that is claimed by the scanner, or null if there is none.", "predict": " Get the annotation claimed by this scanner on the given method. If there are multiple annotations claimed, then we'll report an error. Otherwise, we'll return null. @param binder The binder to report errors against. @param method The method to scan. @return The claimed annotation, or null if there isn't one."}
{"ID": 372, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Integer getLineNumber(Member member) { Preconditions.checkArgument( type == member.getDeclaringClass(), \"Member %s belongs to %s, not %s\", member, member.getDeclaringClass(), type); return lines.get(memberKey(member)); } \nResponse:", "ground_truth": "Get the line number associated with the given member.\n\n@param member a field, constructor, or method belonging to the class used during construction\n@return the wrapped line number, or null if not available\n@throws IllegalArgumentException if the member does not belong to the class used during\nconstruction", "predict": " Returns the line number of the given member. The line number is extracted from the member's source code comments. The comments are scanned for the following format: \"#define MY_LINE 100\" Therefore, the line number returned is MY_LINE. The line numbers are counted from 1. Negative line numbers indicate lines that are not in the original source code. @param member Member whose line number should be returned. @return Line number of the given member. Negative line numbers indicate lines that are not in the original source code."}
{"ID": 373, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void initialize(Errors errors) { injector.lookups = injector; new LookupProcessor(errors).process(injector, lookups); } \nResponse:", "ground_truth": "Initialize the specified lookups, either immediately or when the injector is created.", "predict": " Initializes the injector with a set of bindings so that it can satisfy injections. Repeated calls to this method are benign. Whereas injector.getInstance() will throw an exception if called before initialization has completed, this method will simply return the same instance until initialization completes. Upon completion of initialization, this method delegates to injector.getInstance() to satisfy injections.\n"}
{"ID": 374, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static <T> Callable<T> continueRequest(Callable<T> callable, Map<Key<?>, Object> seedMap) { return wrap(callable, continueRequest(seedMap)); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"continues\" the HTTP request in another\nthread. This acts as a way of transporting request context data from the request processing\nthread to to worker threads.\n\n<p>There are some limitations:\n\n<ul>\n<li>Derived objects (i.e. anything marked @RequestScoped will not be transported.\n<li>State changes to the HttpServletRequest after this method is called will not be seen in the\ncontinued thread.\n<li>Only the HttpServletRequest, ServletContext and request parameter map are available in the\ncontinued thread. The response and session are not available.\n</ul>\n\n<p>The returned callable will throw a {@link ScopingException} when called if the HTTP request\nscope is still active on the current thread.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@param seedMap the initial set of scoped instances for Guice to seed the request scope with. To\nseed a key with null, use {@code null} as the value.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 3.0\n@deprecated You probably want to use {@code transferRequest} instead", "predict": " Continue a request that has been aborted. Useful for ensuring that a request has completed even if interrupted. @param callable The callable to continue. @param seedMap Seeds to use for continuing the request. @return A new callable that wraps the original callable and seeds.\nDeprecated because it doesn't properly seed the continuation seed. Keeping it around for backwards compatibility.\n */"}
{"ID": 375, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Callable<T> transferRequest(Callable<T> callable) { return wrap(callable, transferRequest()); } \nResponse:", "ground_truth": "Wraps the given callable in a contextual callable that \"transfers\" the request to another\nthread. This acts as a way of transporting request context data from the current thread to a\nfuture thread.\n\n<p>As opposed to {@link #continueRequest}, this method propagates all existing scoped objects.\nThe primary use case is in server implementations where you can detach the request processing\nthread while waiting for data, and reattach to a different thread to finish processing at a\nlater time.\n\n<p>Because request-scoped objects are not typically thread-safe, the callable returned by this\nmethod must not be run on a different thread until the current request scope has terminated.\nThe returned callable will block until the current thread has released the request scope.\n\n@param callable code to be executed in another thread, which depends on the request scope.\n@return a callable that will invoke the given callable, making the request context available to\nit.\n@throws OutOfScopeException if this method is called from a non-request thread, or if the\nrequest has completed.\n@since 4.0", "predict": " Transferring the request to the background thread. Useful when you want to do some lengthy operation without blocking your caller thread. @param callable Callable to transfer. @param <T> Return type. @return Callable wrapper.\n*/"}
{"ID": 376, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object validateAndCanonicalizeValue(Key<?> key, Object object) { if (object == null || object == NullObject.INSTANCE) { return NullObject.INSTANCE; } if (!key.getTypeLiteral().getRawType().isInstance(object)) { throw new IllegalArgumentException( \"Value[\" + object + \"] of type[\" + object.getClass().getName() + \"] is not compatible with key[\" + key + \"]\"); } return object; } \nResponse:", "ground_truth": "Validates the key and object, ensuring the value matches the key type, and canonicalizing null\nobjects to the null sentinel.", "predict": " Canonicalize the value object to comply with invariants enforced by GWT emulation mode. Specifically, ensure that null is represented by GWT's NullObject implementation. Also, coerce GWT interfaces to their emulation implementations.\n<p>This method is package-private to encourage callers to treat this as an implementation detail. Specifically, this method assumes that all implementations of Key are tightly coupled with their emulation counterparts. Furthermore, this method assumes that all GWT interfaces are tightly coupled with their emulation counterparts. Ideally, this coupling would be maintained through DI frameworks such as Guice or Tang, but unfortunately neither of those technologies currently offer guarantees around this coupling. Furthermore, maintaining such coupling complicates testing because it complicates mocking libraries significantly. Therefore, maintaining coupling here encourages consistency across DI frameworks and greatly simplifies testing. Furthermore, maintaining coupling encourages consistency across GWT modules thereby simplifying testing considerably. Lastly, maintaining coupling encourages consistency across GWT emulated environments thereby simplifying testing considerably.\n<p>Note that canonicalization here merely serves to comply with GWT's"}
{"ID": 377, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") // the MembersInjector type always agrees with the passed type public <T> MembersInjectorImpl<T> get(TypeLiteral<T> key, Errors errors) throws ErrorsException { return (MembersInjectorImpl<T>) cache.get(key, errors); } \nResponse:", "ground_truth": "Returns a new complete members injector with injection listeners registered.", "predict": " Returns the MembersInjector for the given type. Creates the MembersInjector if necessary. The MembersInjector is created whenever you ask for a MembersInjector, typically from within your constructor. However, it isn't created until the injector is actually used -- so MembersInjectors from constructors and from setters/with methods can be used independently. @return Returns the MembersInjector for the given type"}
{"ID": 378, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T> MembersInjectorImpl<T> createWithListeners(TypeLiteral<T> type, Errors errors) throws ErrorsException { int numErrorsBefore = errors.size(); Set<InjectionPoint> injectionPoints; try { injectionPoints = InjectionPoint.forInstanceMethodsAndFields(type); } catch (ConfigurationException e) { errors.merge(e.getErrorMessages()); injectionPoints = e.getPartialValue(); } ImmutableList<SingleMemberInjector> injectors = getInjectors(injectionPoints, errors); errors.throwIfNewErrors(numErrorsBefore); EncounterImpl<T> encounter = new EncounterImpl<>(errors, injector.lookups); Set<TypeListener> alreadySeenListeners = Sets.newHashSet(); for (TypeListenerBinding binding : typeListenerBindings) { TypeListener typeListener = binding.getListener(); if (!alreadySeenListeners.contains(typeListener) && binding.getTypeMatcher().matches(type)) { alreadySeenListeners.add(typeListener); try { typeListener.hear(type, encounter); } catch (RuntimeException e) { errors.errorNotifyingTypeListener(binding, type, e); } } } encounter.invalidate(); errors.throwIfNewErrors(numErrorsBefore); return new MembersInjectorImpl<T>(injector, type, encounter, injectors); } \nResponse:", "ground_truth": "Creates a new members injector and attaches both injection listeners and method aspects.", "predict": " MembersInjectorImpl is a hack to work around limitations in our hosting model. We cannot easily pass dependencies into Provider<MembersInjector> because the Servlet spec says that the container will happily discard a previously set dependency once the listener has been set. Our solution is to maintain our own dependency set along with the set of injection points contributing to each injection. Providers cannot be modified once they've been created so we maintain our own dependency set as a set of injection points contributing to each injected set. @param type a TypeLiteral describing the injection point\n@param errors Errors encountered during injection. This error supersedes all errors from other injections.\n@return a MembersInjector for the given type\n*/"}
{"ID": 379, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: ImmutableList<SingleMemberInjector> getInjectors( Set<InjectionPoint> injectionPoints, Errors errors) { List<SingleMemberInjector> injectors = Lists.newArrayList(); for (InjectionPoint injectionPoint : injectionPoints) { try { Errors errorsForMember = injectionPoint.isOptional() ? new Errors(injectionPoint) : errors.withSource(injectionPoint); SingleMemberInjector injector = injectionPoint.getMember() instanceof Field ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember) : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember); injectors.add(injector); } catch (ErrorsException ignoredForNow) { // ignored for now } } return ImmutableList.copyOf(injectors); } \nResponse:", "ground_truth": "Returns the injectors for the specified injection points.", "predict": " Calculates and returns a multimap of injection points to injectors to inject at those injection points. Only called by Ranked Binding. @author crazybob@google.com (Bob Lee)"}
{"ID": 380, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Key<T> get(Class<T> type, AnnotationStrategy annotationStrategy) { return new Key<T>(type, annotationStrategy); } \nResponse:", "ground_truth": "Gets a key for an injection type and an annotation strategy.", "predict": " Returns a key for an injectable type. Specifically, if T is a {@link Provider}, the key will be of type {@code Provider<T>}. Otherwise, the key will be of type T."}
{"ID": 381, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Annotation annotation) { checkNotNull(annotation, \"annotation\"); Class<? extends Annotation> annotationType = annotation.annotationType(); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); if (Annotations.isMarker(annotationType)) { return new AnnotationTypeStrategy(annotationType, annotation); } return new AnnotationInstanceStrategy(Annotations.canonicalizeIfNamed(annotation)); } \nResponse:", "ground_truth": "Gets the strategy for an annotation.", "predict": " Returns the strategy that should be used for evaluating the suitability of annotations of the given type. Currently, only BindingAnnotations are supported. @throws IllegalArgumentException if the annotation is neither Binding nor BindingAnnotation.\n*/"}
{"ID": 382, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static AnnotationStrategy strategyFor(Class<? extends Annotation> annotationType) { annotationType = Annotations.canonicalizeIfNamed(annotationType); if (isAllDefaultMethods(annotationType)) { return strategyFor(generateAnnotation(annotationType)); } checkNotNull(annotationType, \"annotation type\"); ensureRetainedAtRuntime(annotationType); ensureIsBindingAnnotation(annotationType); return new AnnotationTypeStrategy(annotationType, null); } \nResponse:", "ground_truth": "Gets the strategy for an annotation type.", "predict": " Returns the strategy for the annotation type. This method may be slow. Particularly because it consults the annotation index. But it avoids doing costly reflective lookups.\n */"}
{"ID": 383, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pruneStacktrace(Throwable throwable) { for (Throwable t = throwable; t != null; t = t.getCause()) { StackTraceElement[] stackTrace = t.getStackTrace(); List<StackTraceElement> pruned = Lists.newArrayList(); for (StackTraceElement element : stackTrace) { String className = element.getClassName(); if (!AOP_INTERNAL_CLASSES.contains(className) && !className.contains(\"$EnhancerByGuice$\")) { pruned.add(element); } } t.setStackTrace(pruned.toArray(new StackTraceElement[pruned.size()])); } } \nResponse:", "ground_truth": "Removes stacktrace elements related to AOP internal mechanics from the throwable's stack trace\nand any causes it may have.", "predict": " Prune unwanted junk from Robolectric stacktraces. Robolectric tends to spew useless junk on stderr, sigh.\n */"}
{"ID": 384, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getBindingSource() { if (source instanceof Class) { return StackTraceElements.forType((Class) source).toString(); } else if (source instanceof Member) { return StackTraceElements.forMember((Member) source).toString(); } else { return source.toString(); } } \nResponse:", "ground_truth": "Returns a string describing where this dependency was bound. If the binding was just-in-time,\nthere is no valid binding source, so this describes the class in question.", "predict": " Returns the binding source. @return Binding source."}
{"ID": 385, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String formatMessages(String heading, Collection<Message> errorMessages) { Formatter fmt = new Formatter().format(heading).format(\":%n%n\"); int index = 1; boolean displayCauses = getOnlyCause(errorMessages) == null; Map<Equivalence.Wrapper<Throwable>, Integer> causes = Maps.newHashMap(); for (Message errorMessage : errorMessages) { int thisIdx = index++; fmt.format(\"%s) %s%n\", thisIdx, errorMessage.getMessage()); List<Object> dependencies = errorMessage.getSources(); for (int i = dependencies.size() - 1; i >= 0; i--) { Object source = dependencies.get(i); formatSource(fmt, source); } Throwable cause = errorMessage.getCause(); if (displayCauses && cause != null) { Equivalence.Wrapper<Throwable> causeEquivalence = ThrowableEquivalence.INSTANCE.wrap(cause); if (!causes.containsKey(causeEquivalence)) { causes.put(causeEquivalence, thisIdx); fmt.format(\"Caused by: %s\", Throwables.getStackTraceAsString(cause)); } else { int causeIdx = causes.get(causeEquivalence); fmt.format( \"Caused by: %s (same stack trace as error #%s)\", cause.getClass().getName(), causeIdx); } } fmt.format(\"%n\"); } if (errorMessages.size() == 1) { fmt.format(\"1 error\"); } else { fmt.format(\"%s errors\", errorMessages.size()); } return fmt.toString(); } \nResponse:", "ground_truth": "Returns the formatted message for an exception with the specified messages.", "predict": " Pretty-prints a collection of errors. @param heading heading to use for the error messages\n@param errorMessages collection of errors to pretty-print\n@return pretty-printed error message\n*/"}
{"ID": 386, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(String messageFormat, Object... arguments) { return create(null, messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message without a cause.\n\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a new localized message. The arguments are substituted into the message format string. @param messageFormat The message format string. @param arguments The arguments to be substituted into the message format string. @return The localized message.\n */"}
{"ID": 387, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create(Throwable cause, String messageFormat, Object... arguments) { return create(cause, ImmutableList.of(), messageFormat, arguments); } \nResponse:", "ground_truth": "Creates a new Message with the given cause.\n\n@param cause The exception that caused the error\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a new causal chain with the given cause and message. @param cause Cause of the chain. @param messageFormat Message format of the message. @param arguments Arguments for the message format. @return Newly created causal chain.\n*/"}
{"ID": 388, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Message create( Throwable cause, List<Object> sources, String messageFormat, Object... arguments) { String message = format(messageFormat, arguments); return new Message(sources, message, cause); } \nResponse:", "ground_truth": "Creates a new Message with the given cause and a binding source stack.\n\n@param cause The exception that caused the error\n@param sources The binding sources for the source stack\n@param messageFormat Format string\n@param arguments format string arguments", "predict": " Creates a new Message with the given arguments. The message will be constructed using the given Throwable cause, sources and message format. The resulting message will be immutable. @param cause The cause of this message. May be null. @param sources The sources of this message. May be empty. May contain null values. @param messageFormat The message format to use. May contain placeholders denoted by a '{' character followed by a positive integer. @param arguments The arguments to substitute into the message format. May contain null values. @return The new message. Never null. May be immutable. May be reused. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May be discarded. May"}
{"ID": 389, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Object convert(Object o) { ElementSource source = null; if (o instanceof ElementSource) { source = (ElementSource) o; o = source.getDeclaringSource(); } return convert(o, source); } \nResponse:", "ground_truth": "Formats an object in a user friendly way.", "predict": " Convert an arbitrary object to a SourceLocation.\n@param o the object to convert\n@return the SourceLocation\n*/"}
{"ID": 390, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean shouldBeSkipped(String className) { return (parent != null && parent.shouldBeSkipped(className)) || classNamesToSkip.contains(className); } \nResponse:", "ground_truth": "Returns true if the className should be skipped.", "predict": " Skips analyzing the given class if it matches any of the configured skip regexes. @param className The fully qualified class name. @return True if the class should be skipped, false otherwise.\n*/"}
{"ID": 391, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getFromClassNames(List<String> moduleClassNames) { Preconditions.checkNotNull(moduleClassNames, \"The list of module class names cannot be null.\"); for (final String moduleClassName : moduleClassNames) { if (!shouldBeSkipped(moduleClassName)) { return new StackTraceElement(moduleClassName, \"configure\", null, -1); } } return UNKNOWN_SOURCE; } \nResponse:", "ground_truth": "Returns the non-skipped module class name.", "predict": " Given a list of fully qualified class names, returns the deepest StackTraceElement that represents a Guice module. The returned StackTraceElement will be qualified by the fully qualified class names of the modules that precede it in the list. If no such StackTraceElement exists, returns UNKNOWN_SOURCE. @param moduleClassNames The fully qualified class names of the modules. @return The deepest StackTraceElement that represents a Guice module."}
{"ID": 392, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager.class.getName() + \" [module class name]\"); System.err.println(\"Then run 'jconsole' to connect.\"); System.exit(1); } Module module = (Module) Class.forName(args[0]).newInstance(); Injector injector = Guice.createInjector(module); manage(args[0], injector); System.out.println(\"Press Ctrl+C to exit...\"); // Sleep forever. Thread.sleep(Long.MAX_VALUE); } \nResponse:", "ground_truth": "Run with no arguments for usage instructions.", "predict": " Main entrance point.\n"}
{"ID": 393, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Dependency<?> pushDependency(Dependency<?> dependency, Object source) { Dependency<?> previous = this.dependency; this.dependency = dependency; doPushState(dependency, source); return previous; } \nResponse:", "ground_truth": "Sets the new current dependency & adds it to the state.", "predict": " Push a dependency onto the current stack. This is intended to be used by Dependency Injection frameworks to implement their DI frameworks. @param dependency The dependency to push onto the stack. @param source The source of the dependency. This is used primarily for Dependency Injection frameworks. @return The dependency that was previously on the top of the stack. This is primarily used for Dependency Injection frameworks."}
{"ID": 394, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushState(com.google.inject.Key<?> key, Object source) { doPushState(key, source); } \nResponse:", "ground_truth": "Adds to the state without setting the dependency.", "predict": " Pushes a new GuiceBerryEnricherState onto the stack.\n<p>Note that this method is intended to be used by GuiceBerryEnricher implementations only. It is not intended for general consumption.\n<p>The source of the pushed state is unspecified.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped automatically when the GuiceBerryEnricher completes.\n<p>The pushed state will be popped"}
{"ID": 395, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static <T> Initializable<T> of(final T instance) { return new Initializable<T>() { @Override public T get() { return instance; } @Override public String toString() { return String.valueOf(instance); } }; } \nResponse:", "ground_truth": "Returns an initializable for an instance that requires no initialization.", "predict": " Provide an Initializable that wraps an existing instance. Useful for mocking frameworks that require mocking of singletons. @param <T> The type of the wrapped instance. @param instance The instance to wrap. @return An Initializable wrapping the provided instance.\n*/"}
{"ID": 396, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T provision( Provider<? extends T> provider, Dependency<?> dependency, ConstructionContext<T> constructionContext) throws InternalProvisionException { T t = provider.get(); if (t == null && !dependency.isNullable()) { InternalProvisionException.onNullInjectedIntoNonNullableDependency(source, dependency); } constructionContext.setProxyDelegates(t); return t; } \nResponse:", "ground_truth": "Provisions a new instance. Subclasses should override this to catch exceptions & rethrow as\nErrorsExceptions.", "predict": " Provision a new instance of the dependency using the provider. @param provider the provider to provision from. @param dependency the dependency to provision. @param constructionContext the construction context. @return the provisioned instance. @throws InternalProvisionException if the dependency is not nullable and the provider returns null.\n*/"}
{"ID": 397, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onEvent(ConnectionEventType type, String remoteAddr, Connection conn) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList != null) { for (ConnectionEventProcessor processor : processorList) { processor.onEvent(remoteAddr, conn); } } } \nResponse:", "ground_truth": "Dispatch events.\n\n@param type\n@param remoteAddr\n@param conn", "predict": " Invoked by the Connection Manager when a Connection Event occurs. The Connection Manager invokes this method when a Connection Event occurs. The Connection Manager invokes this method BEFORE the Connection Manager invokes the ConnectionEventProcessor. Therefore, processors can leverage Connection Events to perform additional filtering, manipulate the Connection, etc. @param type ConnectionEventType.CONNECTION_CLOSED, CONNECTION_ERROR, CONNECTION_REMOTE_CLOSE, CONNECTION_REMOTE_OPEN, CONNECTION_STATE_CHANGE, CONNECTION_TIMEOUT, CONNECTION_IDLE, CONNECTION_LOST, CONNECTION_REQUEST_SENT, CONNECTION_RESPONSE_RECEIVED, CONNECTION_REQUEST_RECEIVED, CONNECTION_RESPONSE_SENT, CONNECTION_REQUEST_FAILED, CONNECTION_RESPONSE_FAILED, CONNECTION_REQUEST_SENT_FAILED"}
{"ID": 398, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addConnectionEventProcessor(ConnectionEventType type, ConnectionEventProcessor processor) { List<ConnectionEventProcessor> processorList = this.processors.get(type); if (processorList == null) { this.processors.putIfAbsent(type, new ArrayList<ConnectionEventProcessor>(1)); processorList = this.processors.get(type); } processorList.add(processor); } \nResponse:", "ground_truth": "Add event processor.\n\n@param type\n@param processor", "predict": " Add a ConnectionEventProcessor to the processors map. The ConnectionEventProcessor will be notified of ConnectionEvents generated by this ConnectionEventManager. @param type ConnectionEventType of ConnectionEventProcessor to add. @param processor ConnectionEventProcessor to add."}
{"ID": 399, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T getFutureTaskResult(RunStateRecordedFutureTask<T> task, Logger logger) { T t = null; if (null != task) { try { t = task.getAfterRun(); } catch (InterruptedException e) { logger.error(\"Future task interrupted!\", e); } catch (ExecutionException e) { logger.error(\"Future task execute failed!\", e); } catch (FutureTaskNotRunYetException e) { logger.error(\"Future task has not run yet!\", e); } catch (FutureTaskNotCompleted e) { logger.error(\"Future task has not completed!\", e); } } return t; } \nResponse:", "ground_truth": "get the result of a future task\n\nNotice: the run method of this task should have been called at first.\n\n@param task\n@param <T>\n@return", "predict": " Get the result of FutureTask. @param task The FutureTask to get the result. @param logger The logger to log the exception. @return The result of FutureTask.\n*/"}
{"ID": 400, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void launderThrowable(Throwable t) { if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof Error) { throw (Error) t; } else { throw new IllegalStateException(\"Not unchecked!\", t); } } \nResponse:", "ground_truth": "launder the throwable\n\n@param t", "predict": " launders the given throwable to unchecked. That means that all checked exceptions are converted to unchecked ones. Furthermore, all suppressed exceptions are laundered too. Furthermore, all suppressed unchecked exceptions are laundered too. Furthermore, all suppressed runtime exceptions are laundered too. Furthermore, all suppressed errors are laundered too. Furthermore, all suppressed exceptions are laundered too. Furthermore, all suppressed unchecked exceptions are laundered too. Furthermore, all suppressed runtime exceptions are laundered too. Furthermore, all suppressed errors are laundered too. Furthermore, all suppressed exceptions are laundered too. Furthermore, all suppressed unchecked exceptions are laundered too. Furthermore, all suppressed runtime exceptions are laundered too. Furthermore, all suppressed errors are laundered too. Furthermore, all suppressed exceptions are laundered too. Furthermore, all suppressed unchecked exceptions are laundered too. Furthermore, all suppressed runtime exceptions are laundered too. Furthermore, all suppressed errors are laundered too. Furthermore, all suppressed exceptions are laundered too. Furthermore, all suppressed unchecked exceptions are laundered too. Furthermore, all suppressed runtime exceptions"}
{"ID": 401, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerProcessor(CommandCode cmdCode, RemotingProcessor<?> processor) { if (this.cmd2processors.containsKey(cmdCode)) { logger .warn( \"Processor for cmd={} is already registered, the processor is {}, and changed to {}\", cmdCode, cmd2processors.get(cmdCode).getClass().getName(), processor.getClass() .getName()); } this.cmd2processors.put(cmdCode, processor); } \nResponse:", "ground_truth": "Register processor to process command that has the command code of cmdCode.\n\n@param cmdCode\n@param processor", "predict": " Register processor for command code. @param cmdCode command code. @param processor processor for command code."}
{"ID": 402, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerDefaultProcessor(RemotingProcessor<?> processor) { if (this.defaultProcessor == null) { this.defaultProcessor = processor; } else { throw new IllegalStateException(\"The defaultProcessor has already been registered: \" + this.defaultProcessor.getClass()); } } \nResponse:", "ground_truth": "Register the default processor to process command with no specific processor registered.\n\n@param processor", "predict": " Register the default processor. This processor will be used if no other processors match the incoming message. @param processor The processor to register.\n*/"}
{"ID": 403, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RemotingProcessor<?> getProcessor(CommandCode cmdCode) { RemotingProcessor<?> processor = this.cmd2processors.get(cmdCode); if (processor != null) { return processor; } return this.defaultProcessor; } \nResponse:", "ground_truth": "Get the specific processor with command code of cmdCode if registered, otherwise the default processor is returned.\n\n@param cmdCode\n@return", "predict": " Get processor for command code. @param cmdCode Command code. @return Processor for command code."}
{"ID": 404, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Url tryGet(String url) { SoftReference<Url> softRef = Url.parsedUrls.get(url); return (null == softRef) ? null : softRef.get(); } \nResponse:", "ground_truth": "try get from cache\n\n@param url\n@return", "predict": " Try to get the Url from SoftReference cache. @param url the url to be parsed. @return the Url object."}
{"ID": 405, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ProtocolCode decodeProtocolCode(ByteBuf in) { if (in.readableBytes() >= protocolCodeLength) { byte[] protocolCodeBytes = new byte[protocolCodeLength]; in.readBytes(protocolCodeBytes); return ProtocolCode.fromBytes(protocolCodeBytes); } return null; } \nResponse:", "ground_truth": "decode the protocol code\n\n@param in input byte buf\n@return an instance of ProtocolCode", "predict": " Decode the protocol code from the buffer. @param in The buffer to decode from. @return The decoded ProtocolCode. May be null if there isn't enough readable bytes.\n*/"}
{"ID": 406, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> getAll() { Map<String, List<Connection>> allConnections = new HashMap<String, List<Connection>>(); Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iterator = this .getConnPools().entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iterator.next(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); if (null != pool) { allConnections.put(entry.getKey(), pool.getAll()); } } return allConnections; } \nResponse:", "ground_truth": "Get all connections of all poolKey.\n\n@return a map with poolKey as key and a list of connections in ConnectionPool as value", "predict": " Get all connections. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those in abandoned connection pools. Including those in recycled connection pools. Including those"}
{"ID": 407, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void scan() { if (null != this.connTasks && !this.connTasks.isEmpty()) { Iterator<String> iter = this.connTasks.keySet().iterator(); while (iter.hasNext()) { String poolKey = iter.next(); ConnectionPool pool = this.getConnectionPool(this.connTasks.get(poolKey)); if (null != pool) { pool.scan(); if (pool.isEmpty()) { if ((System.currentTimeMillis() - pool.getLastAccessTimestamp()) > DEFAULT_EXPIRE_TIME) { iter.remove(); logger.warn(\"Remove expired pool task of poolKey {} which is empty.\", poolKey); } } } } } } \nResponse:", "ground_truth": "in case of cache pollution and connection leak, to do schedule scan\n\n@see com.alipay.remoting.Scannable#scan()", "predict": " Scan expired connection pools. Especially designed for connection pool auto-recycle feature. Pool auto-recycle feature works as follows: suppose you have a connection pool named \"pool1\" with 10 connections, and you want to recycle these 10 connections every 10 minutes. So you add a connection pool named \"pool1\" to connTasks, and you add 10 connections to this pool. Every 10 minutes, a thread will scan this pool and check whether these 10 connections are expired. If yes, they will be removed from pool1 and recycled to pool2. Pool2 is another connection pool, you can add more connections to pool2. So you can achieve connection pool auto-recycle feature. If you want to achieve connection pool auto-recycle feature, you should add following steps: 1. Add a connection pool named pool1 to connTasks. Pool1 will be scanned every 10 minutes. 2. Add 10 connections to pool1. 3. Enjoy! Enjoy auto-recycle feature! Enjoy! Enjoy auto-recycle feature! Enjoy! Enjoy auto"}
{"ID": 408, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Connection getAndCreateIfAbsent(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\n\n@see ConnectionManager#getAndCreateIfAbsent(Url)", "predict": " Get and create connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null!= pool) { return pool.get(); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); return null; }"}
{"ID": 409, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void createConnectionAndHealIfNeed(Url url) throws InterruptedException, RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null != pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); } } \nResponse:", "ground_truth": "If no task cached, create one and initialize the connections.\nIf task cached, check whether the number of connections adequate, if not then heal it.\n\n@param url\n@return\n@throws InterruptedException\n@throws RemotingException", "predict": " create connection pool with initialized connections. ConnectionPool pool = this.getConnectionPoolAndCreateIfAbsent(url.getUniqueKey(), new ConnectionPoolCall(url)); if (null!= pool) { healIfNeed(pool, url); } else { logger.error(\"[NOTIFYME] bug detected! pool here must not be null!\"); }"}
{"ID": 410, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeTask(String poolKey) { RunStateRecordedFutureTask<ConnectionPool> task = this.connTasks.remove(poolKey); if (null != task) { ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(task, logger); if (null != pool) { pool.removeAllAndTryClose(); } } } \nResponse:", "ground_truth": "remove task and remove all connections\n\n@param poolKey", "predict": " Remove the task associated with the pool identified by poolKey.\n*/"}
{"ID": 411, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void healIfNeed(ConnectionPool pool, Url url) throws RemotingException, InterruptedException { String poolKey = url.getUniqueKey(); // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if (pool.isAsyncCreationDone() && pool.size() < url.getConnNum()) { FutureTask<Integer> task = this.healTasks.get(poolKey); if (null == task) { task = new FutureTask<Integer>(new HealConnectionCall(url, pool)); task = this.healTasks.putIfAbsent(poolKey, task); if (null == task) { task = this.healTasks.get(poolKey); task.run(); } } try { int numAfterHeal = task.get(); if (logger.isDebugEnabled()) { logger.debug(\"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\", numAfterHeal, url.getConnNum(), url.isConnWarmup()); } } catch (InterruptedException e) { this.healTasks.remove(poolKey); throw e; } catch (ExecutionException e) { this.healTasks.remove(poolKey); Throwable cause = e.getCause(); if (cause instanceof RemotingException) { throw (RemotingException) cause; } else { FutureTaskUtil.launderThrowable(cause); } } // heal task is one-off, remove from cache directly after run this.healTasks.remove(poolKey); } } \nResponse:", "ground_truth": "execute heal connection tasks if the actual number of connections in pool is less than expected\n\n@param pool\n@param url", "predict": " heal connection gradually, until expected connections are totally established. @param pool @param url @throws RemotingException @throws InterruptedException"}
{"ID": 412, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doCreate(final Url url, final ConnectionPool pool, final String taskName, final int syncCreateNumWhenNotWarmup) throws RemotingException { final int actualNum = pool.size(); final int expectNum = url.getConnNum(); if (actualNum < expectNum) { if (logger.isDebugEnabled()) { logger.debug(\"actual num {}, expect num {}, task name {}\", actualNum, expectNum, taskName); } if (url.isConnWarmup()) { for (int i = actualNum; i < expectNum; ++i) { Connection connection = create(url); pool.add(connection); } } else { if (syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url.getConnNum()) { throw new IllegalArgumentException( \"sync create number when not warmup should be [0,\" + url.getConnNum() + \"]\"); } // create connection in sync way if (syncCreateNumWhenNotWarmup > 0) { for (int i = 0; i < syncCreateNumWhenNotWarmup; ++i) { Connection connection = create(url); pool.add(connection); } if (syncCreateNumWhenNotWarmup == url.getConnNum()) { return; } } // initialize executor in lazy way initializeExecutor(); pool.markAsyncCreationStart();// mark the start of async try { this.asyncCreateConnectionExecutor.execute(new Runnable() { @Override public void run() { try { for (int i = pool.size(); i < url.getConnNum(); ++i) { Connection conn = null; try { conn = create(url); } catch (RemotingException e) { logger .error( \"Exception occurred in async create connection thread for {}, taskName {}\", url.getUniqueKey(), taskName, e); } pool.add(conn); } } finally { pool.markAsyncCreationDone();// mark the end of async } } }); } catch (RejectedExecutionException e) { pool.markAsyncCreationDone();// mark the end of async when reject throw e; } } // end of NOT warm up } // end of if } \nResponse:", "ground_truth": "do create connections\n\n@param url\n@param pool\n@param taskName\n@param syncCreateNumWhenNotWarmup you can specify this param to ensure at least desired number of connections available in sync way\n@throws RemotingException", "predict": " Create connections. Notice that the connections are NOT warmed up here. They are warmed up in warmingThread. So please don't put complicated logic here. Imagine you wanna change the warming logic at runtime, but wanna make sure the change is effective at the warmup stage. @param url @param pool @param taskName @param syncCreateNumWhenNotWarmup @throws RemotingException"}
{"ID": 413, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void closeConnection(String addr) { Url url = this.addressParser.parse(addr); this.connectionManager.remove(url.getUniqueKey()); } \nResponse:", "ground_truth": "Close all connections of a address\n\n@param addr", "predict": " Close connection. @param addr Connect address."}
{"ID": 414, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onClose() { Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator(); while (iter.hasNext()) { Entry<Integer, InvokeFuture> entry = iter.next(); iter.remove(); InvokeFuture future = entry.getValue(); if (future != null) { future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress())); future.cancelTimeout(); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } } \nResponse:", "ground_truth": "Do something when closing.", "predict": " Close myself forcibly. Destruction of myself forcibly is assured absolutely. Destruction of others forcibly is absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely. Destruction of others absolutely assured absolutely"}
{"ID": 415, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (closed.compareAndSet(false, true)) { try { if (this.getChannel() != null) { this.getChannel().close().addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (logger.isInfoEnabled()) { logger .info( \"Close the connection to remote address={}, result={}, cause={}\", RemotingUtil.parseRemoteAddress(Connection.this .getChannel()), future.isSuccess(), future.cause()); } } }); } } catch (Exception e) { logger.warn(\"Exception caught when closing connection {}\", RemotingUtil.parseRemoteAddress(Connection.this.getChannel()), e); } } } \nResponse:", "ground_truth": "Close the connection.", "predict": " Close this connection abnormally. Usually called from outside of RemotingClient.\n */"}
{"ID": 416, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object setAttributeIfAbsent(String key, Object value) { return attributes.putIfAbsent(key, value); } \nResponse:", "ground_truth": "set attribute if key absent.\n\n@param key\n@param value\n@return", "predict": " Associates the specified value with the specified key in this context if the value is absent. More formally, puts the key-value pair into the map if the map contains no mapping for the key or if the existing mapping has a value that is not equal to the new value. Returns the previous value associated with the key, or null if there was no mapping for the key. (A null return can also indicate that the map previously associated null with the key, if the implementation supports null values.) The map will not contain a mapping for the specified key once the call returns. @param key the key whose associated value is to be set @param value the value to be associated with the specified key @return the previous value associated with the key, or null if there was no mapping for the key\n"}
{"ID": 417, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerUserProcessor(UserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor) { throw new RuntimeException(\"User processor should not be null!\"); } if (processor instanceof MultiInterestUserProcessor) { registerUserProcessor((MultiInterestUserProcessor) processor, userProcessors); } else { if (StringUtils.isBlank(processor.interest())) { throw new RuntimeException(\"Processor interest should not be blank!\"); } UserProcessor<?> preProcessor = userProcessors.putIfAbsent(processor.interest(), processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + processor.interest() + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register single-interest user processor.\n\n@param processor  the processor need to be registered\n@param userProcessors   the map of user processors", "predict": " Register a user processor with rpc server. @param processor the user processor to register. @param userProcessors the map of processors to hold processors interested in serving a particular interest.\n */"}
{"ID": 418, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void registerUserProcessor(MultiInterestUserProcessor<?> processor, ConcurrentHashMap<String, UserProcessor<?>> userProcessors) { if (null == processor.multiInterest() || processor.multiInterest().isEmpty()) { throw new RuntimeException(\"Processor interest should not be blank!\"); } for (String interest : processor.multiInterest()) { UserProcessor<?> preProcessor = userProcessors.putIfAbsent(interest, processor); if (preProcessor != null) { String errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\"; throw new RuntimeException(errMsg); } } } \nResponse:", "ground_truth": "Help register multi-interest user processor.\n\n@param processor  the processor with multi-interest need to be registered\n@param userProcessors    the map of user processors", "predict": " Register a multi interest user processor to rpc server. @param processor the user processor to register. @param userProcessors the map of user processors maintained by rpc server."}
{"ID": 419, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void dispatchToUserProcessor(RemotingContext ctx, RpcRequestCommand cmd) { final int id = cmd.getId(); final byte type = cmd.getType(); // processor here must not be null, for it have been checked before UserProcessor processor = ctx.getUserProcessor(cmd.getRequestClass()); if (processor instanceof AsyncUserProcessor) { try { processor.handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), new RpcAsyncContext(ctx, cmd, this), cmd.getRequestObject()); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"AYSNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } else { try { Object responseObject = processor .handleRequest(processor.preHandleRequest(ctx, cmd.getRequestObject()), cmd.getRequestObject()); sendResponseIfNecessary(ctx, type, this.getCommandFactory().createResponse(responseObject, cmd)); } catch (RejectedExecutionException e) { logger .warn(\"RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor\"); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, ResponseStatus.SERVER_THREADPOOL_BUSY)); } catch (Throwable t) { String errMsg = \"SYNC process rpc request failed in RpcRequestProcessor, id=\" + id; logger.error(errMsg, t); sendResponseIfNecessary(ctx, type, this.getCommandFactory() .createExceptionResponse(id, t, errMsg)); } } } \nResponse:", "ground_truth": "dispatch request command to user processor\n@param ctx remoting context\n@param cmd rpc request command", "predict": " Dispatch the request to UserProcessor. NOTICE: UserProcessor may be async, so you should not expect the request object to be fully processed here.\n */"}
{"ID": 420, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean deserializeRequestCommand(RemotingContext ctx, RpcRequestCommand cmd, int level) { boolean result; try { cmd.deserialize(level); result = true; } catch (DeserializationException e) { logger .error( \"DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}\", cmd.getId(), RpcDeserializeLevel.valueOf(level), e); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), ResponseStatus.SERVER_DESERIAL_EXCEPTION, e)); result = false; } catch (Throwable t) { String errMsg = \"Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=\" + cmd.getId() + \", deserializeLevel=\" + level; logger.error(errMsg, t); sendResponseIfNecessary(ctx, cmd.getType(), this.getCommandFactory() .createExceptionResponse(cmd.getId(), t, errMsg)); result = false; } return result; } \nResponse:", "ground_truth": "deserialize request command\n\n@return true if deserialize success; false if exception catched", "predict": " Deserialize the request command. @param ctx The remoting context. @param cmd The request command. @param level The deserialization level. @return Whether deserialization succeeds."}
{"ID": 421, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void preProcessRemotingContext(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { ctx.setArriveTimestamp(cmd.getArriveTime()); ctx.setTimeout(cmd.getTimeout()); ctx.setRpcCommandType(cmd.getType()); ctx.getInvokeContext().putIfAbsent(InvokeContext.BOLT_PROCESS_WAIT_TIME, currentTimestamp - cmd.getArriveTime()); } \nResponse:", "ground_truth": "pre process remoting context, initial some useful infos and pass to biz\n\n@param ctx remoting context\n@param cmd rpc request command\n@param currentTimestamp current timestamp", "predict": " Preprocess the remoting context. @param ctx the remoting context @param cmd the rpc request command @param currentTimestamp the current timestamp\n*/"}
{"ID": 422, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void timeoutLog(final RpcRequestCommand cmd, long currentTimestamp, RemotingContext ctx) { if (logger.isDebugEnabled()) { logger .debug( \"request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}].\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } String remoteAddr = \"UNKNOWN\"; if (null != ctx) { ChannelHandlerContext channelCtx = ctx.getChannelContext(); Channel channel = channelCtx.channel(); if (null != channel) { remoteAddr = RemotingUtil.parseRemoteAddress(channel); } } logger .warn( \"Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}].\", cmd.getId(), remoteAddr, (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } \nResponse:", "ground_truth": "print some log when request timeout and discarded in io thread.", "predict": " Log timeout info. @param cmd the cmd\n * @param currentTimestamp the current timestamp\n * @param ctx the ctx\n */"}
{"ID": 423, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void debugLog(RemotingContext ctx, RpcRequestCommand cmd, long currentTimestamp) { if (logger.isDebugEnabled()) { logger.debug(\"Rpc request received! requestId={}, from {}\", cmd.getId(), RemotingUtil.parseRemoteAddress(ctx.getChannelContext().channel())); logger.debug( \"request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}.\", cmd.getId(), currentTimestamp, cmd.getArriveTime(), (currentTimestamp - cmd.getArriveTime()), cmd.getTimeout()); } } \nResponse:", "ground_truth": "print some debug log when receive request", "predict": " Log debug information. @param ctx the remoting context. @param cmd the rpc request command. @param currentTimestamp the current timestamp."}
{"ID": 424, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void process(RemotingContext ctx, T msg, ExecutorService defaultExecutor) throws Exception { ProcessTask task = new ProcessTask(ctx, msg); if (this.getExecutor() != null) { this.getExecutor().execute(task); } else { defaultExecutor.execute(task); } } \nResponse:", "ground_truth": "Process the remoting command with its own executor or with the defaultExecutor if its own if null.\n\n@param ctx\n@param msg\n@param defaultExecutor\n@throws Exception", "predict": " Process incoming message synchronously. @param ctx RemotingContext instance. @param msg IncomingMessage instance. @param defaultExecutor ExecutorService instance. @throws Exception Exception occurs during processing."}
{"ID": 425, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void invokeWithCallback(final Connection conn, final RemotingCommand request, final InvokeCallback invokeCallback, final int timeoutMillis) { final InvokeFuture future = createInvokeFuture(conn, request, request.getInvokeContext(), invokeCallback); conn.addInvokeFuture(future); final int requestId = request.getId(); try { Timeout timeout = TimerHolder.getTimer().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { InvokeFuture future = conn.removeInvokeFuture(requestId); if (future != null) { future.putResponse(commandFactory.createTimeoutResponse(conn .getRemoteAddress())); future.tryAsyncExecuteInvokeCallbackAbnormally(); } } }, timeoutMillis, TimeUnit.MILLISECONDS); future.addTimeout(timeout); conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture cf) throws Exception { if (!cf.isSuccess()) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse( conn.getRemoteAddress(), cf.cause())); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), cf.cause()); } } }); } catch (Exception e) { InvokeFuture f = conn.removeInvokeFuture(requestId); if (f != null) { f.cancelTimeout(); f.putResponse(commandFactory.createSendFailedResponse(conn.getRemoteAddress(), e)); f.tryAsyncExecuteInvokeCallbackAbnormally(); } logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } \nResponse:", "ground_truth": "Invocation with callback.\n\n@param conn\n@param request\n@param invokeCallback\n@param timeoutMillis\n@throws InterruptedException", "predict": " Send request and notify callback on receiving OK response. Notice that timeoutMillis is relative time rather than absolute millis. And it's suggested to use relative time rather than absolute millis, because it won't harm anyone. Moreover, you'd better understand why you can't use absolute millis. Suppose that you've a method in a class B which depends on a method in class A. A has a relative timeout of 20 milliseconds while B has a relative timeout of 3000 milliseconds. So when invoking method in B, you'd better invoke it with timeoutMillis = 2000 than 3000. If absolute millis were used here, you'd better invoke it with timeoutMillis = 2000 + 3000 = 5000. Relative time would guarantee the timeout you've specified actually. However, absolute millis would guarantee the timeout you specify actually plus some slop. So it's better to use relative time rather than absolute millis.\n* Notice that timeoutMillis is relative time rather than absolute millis. And it's suggested to use relative time rather than absolute millis, because it"}
{"ID": 426, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void oneway(final Connection conn, final RemotingCommand request) { try { conn.getChannel().writeAndFlush(request).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture f) throws Exception { if (!f.isSuccess()) { logger.error(\"Invoke send failed. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), f.cause()); } } }); } catch (Exception e) { if (null == conn) { logger.error(\"Conn is null\"); } else { logger.error(\"Exception caught when sending invocation. The address is {}\", RemotingUtil.parseRemoteAddress(conn.getChannel()), e); } } } \nResponse:", "ground_truth": "Oneway invocation.\n\n@param conn\n@param request\n@throws InterruptedException", "predict": " Send a request and wait for a response. Usually invoked by the proxy. Notice: please DO NOT make a mistake to use this method instead of invokeAsync, because this method won't trigger invocationInterceptor. However, you can still invoke invocationInterceptor by yourself. @param conn the connection to send request on. Notice: please DO NOT make a mistake to use this method instead of invokeAsync, because this method won't trigger invocationInterceptor. However, you can still invoke invocationInterceptor by yourself.\n */"}
{"ID": 427, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte toByte(BitSet bs) { int value = 0; for (int i = 0; i < bs.length(); ++i) { if (bs.get(i)) { value += 1 << i; } } if (bs.length() > 7) { throw new IllegalArgumentException(\"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } return (byte) value; } \nResponse:", "ground_truth": "from bit set to byte\n@param bs\n@return byte represent the bit set", "predict": " Convert BitSet to byte. @param bs bit set @return byte value\n*/"}
{"ID": 428, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BitSet toBitSet(int value) { if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) { throw new IllegalArgumentException( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\"); } BitSet bs = new BitSet(); int index = 0; while (value != 0) { if (value % 2 != 0) { bs.set(index); } ++index; value = (byte) (value >> 1); } return bs; } \nResponse:", "ground_truth": "from byte to bit set\n@param value\n@return bit set represent the byte", "predict": " Convert int value to BitSet. Similar to what java BitSet does. @param value @return"}
{"ID": 429, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addReconnectTask(Url url) { ReconnectTask task = new ReconnectTask(); task.url = url; tasks.add(task); } \nResponse:", "ground_truth": "add reconnect task\n\n@param url", "predict": " Add reconnect task. @param url reconnect url.\n*/"}
{"ID": 430, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop() { if (!this.started) { return; } this.started = false; healConnectionThreads.interrupt(); this.tasks.clear(); this.canceled.clear(); } \nResponse:", "ground_truth": "stop reconnect thread", "predict": " Stops the connection pool. Kills all connection threads and clears all pending tasks. After calling this method, no further connections can be acquired.\n*/"}
{"ID": 431, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected RemotingCommand toRemotingCommand(Object request, Connection conn, InvokeContext invokeContext, int timeoutMillis) throws SerializationException { RpcRequestCommand command = this.getCommandFactory().createRequestCommand(request); if (null != invokeContext) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext.get(InvokeContext.BOLT_CUSTOM_SERIALIZER); if (null != clientCustomSerializer) { try { command.setSerializer((Byte) clientCustomSerializer); } catch (ClassCastException e) { throw new IllegalArgumentException( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer.getClass().getName() + \"].\"); } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext.get(InvokeContext.BOLT_CRC_SWITCH, ProtocolSwitch.CRC_SWITCH_DEFAULT_VALUE); if (null != crcSwitch && crcSwitch) { command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } } else { // enable crc by default, if there is no invoke context. command.setProtocolSwitch(ProtocolSwitch .create(new int[] { ProtocolSwitch.CRC_SWITCH_INDEX })); } command.setTimeout(timeoutMillis); command.setRequestClass(request.getClass().getName()); command.setInvokeContext(invokeContext); command.serialize(); logDebugInfo(command); return command; } \nResponse:", "ground_truth": "Convert application request object to remoting request command.\n\n@param request\n@param conn\n@param timeoutMillis\n@return\n@throws CodecException", "predict": " Serialize the request object into byte array according to the request type and invoke the corresponding method in the channel. The request will be routed to the server whose server type is the same as the destination of the invocation. @param request The request object. @param conn The channel instance which is used to transmit the request. @param invokeContext The invocation context. @param timeoutMillis The timeout millis in RpcClient.sendRequest. @return The response command. @throws SerializationException Serialization failure.\n"}
{"ID": 432, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Map<String, List<Connection>> filter(List<Connection> connections) { List<Connection> serviceOnConnections = new ArrayList<Connection>(); List<Connection> serviceOffConnections = new ArrayList<Connection>(); Map<String, List<Connection>> filteredConnections = new ConcurrentHashMap<String, List<Connection>>(); for (Connection connection : connections) { String serviceStatus = (String) connection.getAttribute(Configs.CONN_SERVICE_STATUS); if (serviceStatus != null) { if (connection.isInvokeFutureMapFinish() && !freshSelectConnections.containsValue(connection)) { serviceOffConnections.add(connection); } } else { serviceOnConnections.add(connection); } } filteredConnections.put(Configs.CONN_SERVICE_STATUS_ON, serviceOnConnections); filteredConnections.put(Configs.CONN_SERVICE_STATUS_OFF, serviceOffConnections); return filteredConnections; } \nResponse:", "ground_truth": "Filter connections to monitor\n\n@param connections", "predict": " Filter connections by service status. @param connections connections to filter. @return filtered connections."}
{"ID": 433, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void monitor(Map<String, RunStateRecordedFutureTask<ConnectionPool>> connPools) { try { if (null != connPools && !connPools.isEmpty()) { Iterator<Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>>> iter = connPools .entrySet().iterator(); while (iter.hasNext()) { Map.Entry<String, RunStateRecordedFutureTask<ConnectionPool>> entry = iter .next(); String poolKey = entry.getKey(); ConnectionPool pool = FutureTaskUtil.getFutureTaskResult(entry.getValue(), logger); List<Connection> connections = pool.getAll(); Map<String, List<Connection>> filteredConnectons = this.filter(connections); List<Connection> serviceOnConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_ON); List<Connection> serviceOffConnections = filteredConnectons .get(Configs.CONN_SERVICE_STATUS_OFF); if (serviceOnConnections.size() > CONNECTION_THRESHOLD) { Connection freshSelectConnect = serviceOnConnections.get(random .nextInt(serviceOnConnections.size())); freshSelectConnect.setAttribute(Configs.CONN_SERVICE_STATUS, Configs.CONN_SERVICE_STATUS_OFF); Connection lastSelectConnect = freshSelectConnections.remove(poolKey); freshSelectConnections.put(poolKey, freshSelectConnect); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } else { if (freshSelectConnections.containsKey(poolKey)) { Connection lastSelectConnect = freshSelectConnections.remove(poolKey); closeFreshSelectConnections(lastSelectConnect, serviceOffConnections); } if (logger.isInfoEnabled()) { logger .info( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\", serviceOnConnections.size(), CONNECTION_THRESHOLD); } } for (Connection offConn : serviceOffConnections) { if (offConn.isFine()) { offConn.close(); } } } } } catch (Exception e) { logger.error(\"ScheduledDisconnectStrategy monitor error\", e); } } \nResponse:", "ground_truth": "Monitor connections and close connections with status is off\n\n@param connPools", "predict": " Monitor the connection pools. @param connPools The connection pools."}
{"ID": 434, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeFreshSelectConnections(Connection lastSelectConnect, List<Connection> serviceOffConnections) throws InterruptedException { if (null != lastSelectConnect) { if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { Thread.sleep(RETRY_DETECT_PERIOD); if (lastSelectConnect.isInvokeFutureMapFinish()) { serviceOffConnections.add(lastSelectConnect); } else { if (logger.isInfoEnabled()) { logger.info(\"Address={} won't close at this schedule turn\", RemotingUtil.parseRemoteAddress(lastSelectConnect.getChannel())); } } } } } \nResponse:", "ground_truth": "close the connection of the fresh select connections\n\n@param lastSelectConnect\n@param serviceOffConnections\n@throws InterruptedException", "predict": " Close fresh connections witch invoke future map finish. @param lastSelectConnect last select connection @param serviceOffConnections connections witch invoke future map finish @throws InterruptedException interrupted exception\n*/"}
{"ID": 435, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean getBool(String key, String defaultValue) { return Boolean.parseBoolean(System.getProperty(key, defaultValue)); } \nResponse:", "ground_truth": "~~~ public helper methods to retrieve system property", "predict": " Get a boolean system property. The default value is returned if the property is not defined. @param key the property key. @param defaultValue the default value. @return the boolean value.\n*/"}
{"ID": 436, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void infoLog(String format, String addr) { if (logger.isInfoEnabled()) { if (StringUtils.isNotEmpty(addr)) { logger.info(format, addr); } else { logger.info(format, \"UNKNOWN-ADDR\"); } } } \nResponse:", "ground_truth": "print info log\n@param format\n@param addr", "predict": " Logging helper."}
{"ID": 437, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isRequestTimeout() { if (this.timeout > 0 && (this.rpcCommandType != RpcCommandType.REQUEST_ONEWAY) && (System.currentTimeMillis() - this.arriveTimestamp) > this.timeout) { return true; } return false; } \nResponse:", "ground_truth": "whether this request already timeout\n\n@return", "predict": " Check whether the request timeout. @return true if timeout, false otherwise."}
{"ID": 438, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public UserProcessor<?> getUserProcessor(String className) { return StringUtils.isBlank(className) ? null : this.userProcessors.get(className); } \nResponse:", "ground_truth": "Get user processor for class name.\n\n@param className\n@return", "predict": " Get the user processor by class name. @param className the class name of the user processor. @return the user processor or null if not found."}
{"ID": 439, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Connection randomGet(List<Connection> conns) { if (null == conns || conns.isEmpty()) { return null; } int size = conns.size(); int tries = 0; Connection result = null; while ((result == null || !result.isFine()) && tries++ < MAX_TIMES) { result = conns.get(this.random.nextInt(size)); } if (result != null && !result.isFine()) { result = null; } return result; } \nResponse:", "ground_truth": "get one connection randomly\n\n@param conns\n@return", "predict": " Picks a random connection from the pool. @param conns The pool of connections. @return The randomly picked connection. Null if none are available."}
{"ID": 440, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T get(String key, T defaultIfNotFound) { return this.context.get(key) != null ? (T) this.context.get(key) : defaultIfNotFound; } \nResponse:", "ground_truth": "get and use default if not found\n\n@param key\n@param defaultIfNotFound\n@param <T>\n@return", "predict": " Get a value from the context. @param key The key to lookup. @param defaultIfNotFound The default value to return if the key is not found. @return The value for the key. Will return the default value if the key is not found.\n*/"}
{"ID": 441, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getProperty(String key) { if (properties == null) { return null; } return properties.getProperty(key); } \nResponse:", "ground_truth": "Get property value according to property key\n\n@param key\n@return property value", "predict": " Get the value of a property. @param key The name of the property sought. @return The value of the property sought. Returns null if the property is not found."}
{"ID": 442, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object resolveResponseObject(ResponseCommand responseCommand, String addr) throws RemotingException { preProcess(responseCommand, addr); if (responseCommand.getResponseStatus() == ResponseStatus.SUCCESS) { return toResponseObject(responseCommand); } else { String msg = String.format(\"Rpc invocation exception: %s, the address is %s, id=%s\", responseCommand.getResponseStatus(), addr, responseCommand.getId()); logger.warn(msg); if (responseCommand.getCause() != null) { throw new InvokeException(msg, responseCommand.getCause()); } else { throw new InvokeException(msg + \", please check the server log for more.\"); } } } \nResponse:", "ground_truth": "Analyze the response command and generate the response object.\n\n@param responseCommand response command\n@param addr response address\n@return response object", "predict": " Resolve the response object. @param responseCommand the response command @param addr the address @return the object\n@throws RemotingException the remoting exception\n*/"}
{"ID": 443, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Object toResponseObject(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand response = (RpcResponseCommand) responseCommand; response.deserialize(); return response.getResponseObject(); } \nResponse:", "ground_truth": "Convert remoting response command to application response object.", "predict": " Convert the response command to the response object. @param responseCommand the response command. @return the response object. @throws CodecException Failed to deserialize the response object."}
{"ID": 444, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Throwable toThrowable(ResponseCommand responseCommand) throws CodecException { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; resp.deserialize(); Object ex = resp.getResponseObject(); if (ex != null && ex instanceof Throwable) { return (Throwable) ex; } return null; } \nResponse:", "ground_truth": "Convert remoting response command to throwable if it is a throwable, otherwise return null.", "predict": " Convert the given response command to a Throwable. The Throwable is deserialized from the response object. If the Throwable is null, null is returned. @param responseCommand The response command to convert. @return The Throwable contained in the response, or null if none. @throws CodecException If deserialization fails."}
{"ID": 445, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String detailErrMsg(String clientErrMsg, ResponseCommand responseCommand) { RpcResponseCommand resp = (RpcResponseCommand) responseCommand; if (StringUtils.isNotBlank(resp.getErrorMsg())) { return String.format(\"%s, ServerErrorMsg:%s\", clientErrMsg, resp.getErrorMsg()); } else { return String.format(\"%s, ServerErrorMsg:null\", clientErrMsg); } } \nResponse:", "ground_truth": "Detail your error msg with the error msg returned from response command", "predict": " Detail err msg. @param clientErrMsg the client err msg @param responseCommand the response command\n * @return the string\n */"}
{"ID": 446, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private RpcServerException createServerException(Throwable t, String errMsg) { String formattedErrMsg = String.format( \"[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s\", t.getClass().getName(), t.getMessage(), errMsg); RpcServerException e = new RpcServerException(formattedErrMsg); e.setStackTrace(t.getStackTrace()); return e; } \nResponse:", "ground_truth": "create server exception using error msg and fill the stack trace using the stack trace of throwable.\n\n@param t the origin throwable to fill the stack trace of rpc server exception\n@param errMsg additional error msg, <code>null</code> is allowed\n@return an instance of RpcServerException", "predict": " Create a ServerException from a Throwable and an error message. @param t The Throwable. @param errMsg The error message. @return The ServerException."}
{"ID": 447, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void printConnectionTraceLog(Logger logger, String traceId, InvokeContext invokeContext) { String sourceIp = invokeContext.get(InvokeContext.CLIENT_LOCAL_IP); Integer sourcePort = invokeContext.get(InvokeContext.CLIENT_LOCAL_PORT); String targetIp = invokeContext.get(InvokeContext.CLIENT_REMOTE_IP); Integer targetPort = invokeContext.get(InvokeContext.CLIENT_REMOTE_PORT); StringBuilder logMsg = new StringBuilder(); logMsg.append(traceId).append(\",\"); logMsg.append(sourceIp).append(\",\"); logMsg.append(sourcePort).append(\",\"); logMsg.append(targetIp).append(\",\"); logMsg.append(targetPort); if (logger.isInfoEnabled()) { logger.info(logMsg.toString()); } } \nResponse:", "ground_truth": "print trace log\n@param traceId\n@param invokeContext", "predict": " Print connection trace log. @param logger the logger @param traceId the trace id @param invokeContext the invoke context"}
{"ID": 448, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static EventLoopGroup newEventLoopGroup(int nThreads, ThreadFactory threadFactory) { return epollEnabled ? new EpollEventLoopGroup(nThreads, threadFactory) : new NioEventLoopGroup(nThreads, threadFactory); } \nResponse:", "ground_truth": "Create the right event loop according to current platform and system property, fallback to NIO when epoll not enabled.\n\n@param nThreads\n@param threadFactory\n@return an EventLoopGroup suitable for the current platform", "predict": " Creates an EventLoopGroup with Native Epoll implementation.\n */"}
{"ID": 449, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress remote = channel.remoteAddress(); return doParse(remote != null ? remote.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the remote address of the channel.\n\n@param channel\n@return", "predict": " Parse remote address. @param channel Channel instance. @return Remote address."}
{"ID": 450, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalAddress(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final SocketAddress local = channel.localAddress(); return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY); } \nResponse:", "ground_truth": "Parse the local address of the channel.\n\n@param channel\n@return", "predict": " Parse local address. @param channel the channel @return the string\n*/"}
{"ID": 451, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote host ip of the channel.\n\n@param channel\n@return", "predict": " Parse the remote IP address. @param channel Channel instance. @return Remote IP address."}
{"ID": 452, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseRemoteHostName(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getAddress().getHostName(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the remote hostname of the channel.\n\nNote: take care to use this method, for a reverse name lookup takes uncertain time in {@link InetAddress#getHostName}.\n\n@param channel\n@return", "predict": " Parse the remote host name. @param channel the channel. @return the remote host name."}
{"ID": 453, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseLocalIP(final Channel channel) { if (null == channel) { return StringUtils.EMPTY; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getAddress().getHostAddress(); } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the local host ip of the channel.\n\n@param channel\n@return", "predict": " Parse local IP address. @param channel Channel. @return IP address."}
{"ID": 454, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseRemotePort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress remote = (InetSocketAddress) channel.remoteAddress(); if (remote != null) { return remote.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the remote host port of the channel.\n\n@param channel\n@return int", "predict": " Parse the remote port from the channel. @param channel Channel instance. @return Remote port."}
{"ID": 455, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int parseLocalPort(final Channel channel) { if (null == channel) { return -1; } final InetSocketAddress local = (InetSocketAddress) channel.localAddress(); if (local != null) { return local.getPort(); } return -1; } \nResponse:", "ground_truth": "Parse the local host port of the channel.\n\n@param channel\n@return int", "predict": " Parse the local port from the Channel. @param channel Channel to inspect. @return Port number or -1 if unavailable."}
{"ID": 456, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String parseSocketAddressToHostIp(SocketAddress socketAddress) { final InetSocketAddress addrs = (InetSocketAddress) socketAddress; if (addrs != null) { InetAddress addr = addrs.getAddress(); if (null != addr) { return addr.getHostAddress(); } } return StringUtils.EMPTY; } \nResponse:", "ground_truth": "Parse the host ip of socket address.\n\ne.g. /127.0.0.1:1234 -> 127.0.0.1\n\n@param socketAddress\n@return String", "predict": " Parse SocketAddress to HostIp. @param socketAddress SocketAddress @return HostIp"}
{"ID": 457, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Connection connection) { markAccess(); if (null == connection) { return; } boolean res = this.conns.addIfAbsent(connection); if (res) { connection.increaseRef(); } } \nResponse:", "ground_truth": "add a connection\n\n@param connection", "predict": " Add connection to pool. Increase ref count. @param connection connection to add.\n*/"}
{"ID": 458, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeAndTryClose(Connection connection) { if (null == connection) { return; } boolean res = this.conns.remove(connection); if (res) { connection.decreaseRef(); } if (connection.noRef()) { connection.close(); } } \nResponse:", "ground_truth": "removeAndTryClose a connection\n\n@param connection", "predict": " Remove connection from pool and decrease ref count. If connection no longer referenced, close it. @param connection connection to remove from pool\n*/"}
{"ID": 459, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Connection get() { markAccess(); if (null != this.conns) { List<Connection> snapshot = new ArrayList<Connection>(this.conns); if (snapshot.size() > 0) { return this.strategy.select(snapshot); } else { return null; } } else { return null; } } \nResponse:", "ground_truth": "get a connection\n\n@return", "predict": " Get connection from pool. Strategy may choose to return null if pool is empty. Strategy may choose to return stale connection. Strategy may choose to evict stale connection. Strategy may choose to evict idle connection. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict idle connection aggressively. Strategy may choose to evict stale connection aggressively. Strategy may choose to evict"}
{"ID": 460, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(String className, CustomSerializer serializer) { CustomSerializer prevSerializer = classCustomSerializer.putIfAbsent(className, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for class: \" + className + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for class name.\n\n@param className\n@param serializer\n@return", "predict": " Register a custom serializer for a class. Useful for registering Kryo serializers that cannot be expressed in the DSL. @param className Fully qualified class name of the class to register. @param serializer Custom serializer to register.\n*/"}
{"ID": 461, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(String className) { if (!classCustomSerializer.isEmpty()) { return classCustomSerializer.get(className); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for class name.\n\n@param className\n@return", "predict": " Get Custom Serializer. @param className Custom Serializer class name. @return Custom Serializer."}
{"ID": 462, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerCustomSerializer(CommandCode code, CustomSerializer serializer) { CustomSerializer prevSerializer = commandCustomSerializer.putIfAbsent(code, serializer); if (prevSerializer != null) { throw new RuntimeException(\"CustomSerializer has been registered for command code: \" + code + \", the custom serializer is: \" + prevSerializer.getClass().getName()); } } \nResponse:", "ground_truth": "Register custom serializer for command code.\n\n@param code\n@param serializer\n@return", "predict": " Register a custom serializer for a command code. @param code The command code to associate with the serializer. @param serializer The custom serializer to associate with the command code.\n */"}
{"ID": 463, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CustomSerializer getCustomSerializer(CommandCode code) { if (!commandCustomSerializer.isEmpty()) { return commandCustomSerializer.get(code); } return null; } \nResponse:", "ground_truth": "Get the custom serializer for command code.\n\n@param code\n@return", "predict": " Get Custom Serializer for Command Code. @param code Command Code. @return Custom Serializer for Command Code."}
{"ID": 464, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager.conn_monitor_initial_delay(); /** period of schedule task, unit: ms*/ long period = ConfigManager.conn_monitor_period(); this.executor = new ScheduledThreadPoolExecutor(1, new NamedThreadFactory( \"ConnectionMonitorThread\", true), new ThreadPoolExecutor.AbortPolicy()); MonitorTask monitorTask = new MonitorTask(); this.executor.scheduleAtFixedRate(monitorTask, initialDelay, period, TimeUnit.MILLISECONDS); } \nResponse:", "ground_truth": "Start schedule task", "predict": " Start monitoring thread.\n*/"}
{"ID": 465, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isConnected(String remoteAddr) { Url url = this.rpcRemoting.addressParser.parse(remoteAddr); return this.isConnected(url); } \nResponse:", "ground_truth": "check whether a client address connected\n\n@param remoteAddr\n@return", "predict": " Judge whether the connection between the local and remote peers is alive. @param remoteAddr The remote address. @return Whether the connection between the local and remote peers is alive."}
{"ID": 466, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void initWriteBufferWaterMark() { int lowWaterMark = this.netty_buffer_low_watermark(); int highWaterMark = this.netty_buffer_high_watermark(); if (lowWaterMark > highWaterMark) { throw new IllegalArgumentException( String .format( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\", highWaterMark, lowWaterMark)); } else { logger.warn( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\", lowWaterMark, highWaterMark); } this.bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark( lowWaterMark, highWaterMark)); } \nResponse:", "ground_truth": "init netty write buffer water mark", "predict": " Init write buffer water mark. NOTICE: high water mark should not be smaller than low water mark.\n*/"}
{"ID": 467, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static FramedataImpl1 get(Opcode opcode) { if (opcode== null) { throw new IllegalArgumentException(\"Supplied opcode cannot be null\"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException(\"Supplied opcode is invalid\"); } } \nResponse:", "ground_truth": "Get a frame with a specific opcode\n\n@param opcode the opcode representing the frame\n@return the frame with a specific opcode", "predict": " Creates a new FramedataImpl1 with the supplied frame opcode. Will throw an IllegalArgumentException if opcode is null. Also supplying an unsupported opcode will throw an IllegalArgumentException. @param opcode The opcode of the frame you want to create @return Newly crafted framedata\n*/"}
{"ID": 468, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean batch( WebSocketImpl ws, ByteChannel sockchannel ) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if( buffer == null ) { if( sockchannel instanceof WrappedByteChannel ) { c = (WrappedByteChannel) sockchannel; if( c.isNeedWrite() ) { c.writeMore(); } } } else { do {// FIXME writing as much as possible is unfair!! /*int written = */sockchannel.write( buffer ); if( buffer.remaining() > 0 ) { return false; } else { ws.outQueue.poll(); // Buffer finished. Remove it. buffer = ws.outQueue.peek(); } } while ( buffer != null ); } if( ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER ) {// ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); } \nResponse:", "ground_truth": "Returns whether the whole outQueue has been flushed\n@param ws The WebSocketImpl associated with the channels\n@param sockchannel The channel to write to\n@throws IOException May be thrown by {@link WrappedByteChannel#writeMore()}\n@return returns Whether there is more data to write", "predict": " Writes to all waiting clients. Blocks until everything has been written. @param ws The websocketImpl which is used to identify the clients. @param sockchannel The channel to write to. @return False if there are no more packets in the queue. Meaning you have to exit your application listening to this socket. True means you have more packets in your queue so you can continue listening."}
{"ID": 469, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setCode(int code) { this.code = code; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = \"\"; } updatePayload(); } \nResponse:", "ground_truth": "Set the close code for this close frame\n@param code the close code", "predict": " Set the closing status code. After this the closing reason will be discarded. Please note that we recommend to use the <a href=\"http://en.wikipedia.org/wiki/Unix_Epoch\">UNIX Epoch</a> for the closingTimestamp to guarantee that the timestamp is always ascending. @param code Status code as described in RFC 6455 \u00a7 7.4.1 @see <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4.1\">RFC 6455 \u00a7 7.4.1 Status Codes</a>"}
{"ID": 470, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position( payload.position() + 2 ); reason = Charsetfunctions.stringUtf8( payload ); } catch ( IllegalArgumentException e ) { throw new InvalidDataException( CloseFrame.NO_UTF8 ); } finally { payload.position( mark ); } } \nResponse:", "ground_truth": "Validate the payload to valid utf8\n@param mark the current mark\n@param payload the current payload\n@throws InvalidDataException the current payload is not a valid utf8", "predict": " Decodes and verifies UTF-8. @throws InvalidDataException Thrown when UTF-8 is invalid."}
{"ID": 471, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); } \nResponse:", "ground_truth": "Update the payload to represent the close code and the reason", "predict": " Updates the payload of this ICMP Packet in accordance to the ICMP Code and Reason! Attention! Reason-ICMP-Messages may _NOT_ be longer than 64 bytes! Furthermore, neither the ICMP Type nor the ICMP Code can be set using this method! They are send as separate packets!"}
{"ID": 472, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private HandshakeState containsRequestedProtocol(String requestedProtocol) { for( IProtocol knownProtocol : knownProtocols ) { if( knownProtocol.acceptProvidedProtocol( requestedProtocol ) ) { protocol = knownProtocol; log.trace(\"acceptHandshake - Matching protocol found: {}\", protocol); return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; } \nResponse:", "ground_truth": "Check if the requested protocol is part of this draft\n@param requestedProtocol the requested protocol\n@return MATCHED if it is matched, otherwise NOT_MATCHED", "predict": " Determine if the requested protocol is supported by any of the protocols known to this handshaker. If so, then set the protocol to that protocol. Otherwise, return HandshakeState.NOT_MATCHED. @param requestedProtocol The requested protocol. @return HandshakeState.MATCHED if a matching protocol was found, HandshakeState.NOT_MATCHED otherwise."}
{"ID": 473, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if( length > Integer.MAX_VALUE ) { log.trace(\"Limit exedeed: Payloadsize is to big...\"); throw new LimitExceededException(\"Payloadsize is to big...\"); } if( length > maxFrameSize) { log.trace( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize, length); throw new LimitExceededException( \"Payload limit reached.\", maxFrameSize ); } if( length < 0 ) { log.trace(\"Limit underflow: Payloadsize is to little...\"); throw new LimitExceededException(\"Payloadsize is to little...\"); } } \nResponse:", "ground_truth": "Check if the frame size exceeds the allowed limit\n@param length the current payload length\n@throws LimitExceededException if the payload length is to big", "predict": " translates the length limit violation to a LimitExceededException. Additionally logs violations. @param length violation length @throws LimitExceededException thrown if violation exceeds limit\n*/"}
{"ID": 474, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if( maxpacketsize < realpacketsize ) { log.trace( \"Incomplete frame: maxpacketsize < realpacketsize\" ); throw new IncompleteException( realpacketsize ); } } \nResponse:", "ground_truth": "Check if the max packet size is smaller than the real packet size\n@param maxpacketsize the max packet size\n@param realpacketsize the real packet size\n@throws IncompleteException if the maxpacketsize is smaller than the realpackagesize", "predict": " Analyzes the incomming frame and throws an IncompleteException if the packet is incomplete. Also increases the packetcounter. @param maxpacketsize The maximum packet size announced by the remote peer. @param realpacketsize The real packet size of the frame. @throws IncompleteException If the packet is incomplete."}
{"ID": 475, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String generateFinalKey( String in ) { String seckey = in.trim(); String acc = seckey + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance( \"SHA1\" ); } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException( e ); } return Base64.encodeBytes( sh1.digest( acc.getBytes() ) ); } \nResponse:", "ground_truth": "Generate a final key from a input string\n@param in the input string\n@return a final key", "predict": " Generate the final encryption key. @param in The cleartext password. @return The final encryption key.\n*/"}
{"ID": 476, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if( curop != Opcode.CONTINUOUS ) { processFrameIsNotFin(frame); } else if( frame.isFin() ) { processFrameIsFin(webSocketImpl, frame); } else if( currentContinuousFrame == null ) { log.error( \"Protocol error: Continuous frame sequence was not started.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } //Check if the whole payload is valid utf8, when the opcode indicates a text if( curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8( frame.getPayloadData() ) ) { log.error( \"Protocol error: Payload is not UTF8\" ); throw new InvalidDataException( CloseFrame.NO_UTF8 ); } //Checking if the current continuous frame contains a correct payload with the other frames combined if( curop == Opcode.CONTINUOUS && currentContinuousFrame != null ) { addToBufferList(frame.getPayloadData()); } } \nResponse:", "ground_truth": "Process the frame if it is a continuous frame or the fin bit is not set\n@param webSocketImpl the websocket implementation to use\n@param frame the current frame\n@param curop the current Opcode\n@throws InvalidDataException if there is a protocol error", "predict": " Processes incoming fragmented frames. When fragmented frames are received, they are put in the fragmentedFrames queue. The fragmentation is continued as long as the queue is not empty. When the queue is empty, the fragmentation stops. When the application accepts to resend fragmented frames, they are re-fragmented and put in the fragmentedFrames queue again.\n * @param webSocketImpl The WebSocketImpl instance which received the fragmented frames.\n * @param frame The fragmented frames which should be processed.\n * @throws InvalidDataException The processed fragmented frames contain invalid UTF-8 sequences.\n */"}
{"ID": 477, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, frame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a binary frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Process the given fragmented frame received from the client. @param webSocketImpl The WebSocketImpl instance this frame arrived on. Guaranteed to be non-null. @param frame The fragmented frame. Guaranteed to be non-null. @throws InvalidDataException The frame contains invalid data. Or the frame is unknown. Or the frame violates the protocol. @throws CloseFrameException The frame is a close frame. Or the frame violates the protocol. @throws IOException An I/O error occurred while sending the frame. Or the frame is unknown."}
{"ID": 478, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { log.error( \"Runtime exception during onWebsocketMessage\", e ); webSocketImpl.getWebSocketListener().onWebsocketError( webSocketImpl, e ); } \nResponse:", "ground_truth": "Log the runtime exception to the specific WebSocketImpl\n@param webSocketImpl the implementation of the websocket\n@param e the runtime exception", "predict": " Logs the given RuntimeException. Meant to be used in situations in which the wrong exception is gonna be thrown anyways. Thus the logging should suffice. If people complain about this approach they can try to improve it :-) @param webSocketImpl The websocketImpl which connection had a problem. Might be null. @param e The exception which was thrown during communication. Might be null."}
{"ID": 479, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( frame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } \nResponse:", "ground_truth": "Process the frame if it is a text frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Process the received frame and fire the corresponding events. @param webSocketImpl The WebSocketImpl @param frame The Framedata @throws InvalidDataException The Framedata could not be understood.\n*/"}
{"ID": 480, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if( currentContinuousFrame == null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Continuous frame sequence was not started.\" ); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if( currentContinuousFrame.getOpcode() == Opcode.TEXT ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, Charsetfunctions.stringUtf8( currentContinuousFrame.getPayloadData() ) ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } else if( currentContinuousFrame.getOpcode() == Opcode.BINARY ) { ((FramedataImpl1) currentContinuousFrame).setPayload( getPayloadFromByteBufferList() ); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage( webSocketImpl, currentContinuousFrame.getPayloadData() ); } catch ( RuntimeException e ) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); } \nResponse:", "ground_truth": "Process the frame if it is the last frame\n@param webSocketImpl the websocket impl\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": " Process special frames. @param webSocketImpl The WebSocketImpl @param frame The Framedata @throws InvalidDataException The Framedata could not be understood by this websocket\n */"}
{"ID": 481, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if( currentContinuousFrame != null ) { log.trace( \"Protocol error: Previous continuous frame sequence not completed.\" ); throw new InvalidDataException( CloseFrame.PROTOCOL_ERROR, \"Previous continuous frame sequence not completed.\" ); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); } \nResponse:", "ground_truth": "Process the frame if it is not the last frame\n@param frame the frame\n@throws InvalidDataException if there is a protocol error", "predict": " processes a continious frame which was received in FRAME_IS_NOT_FINISHED state. According to the spec this should not happen but some browsers continue to send FRAME_IS_NOT_FINISHED after a continuous frame was sent. Unfortunately MSIE sends a FRAME_IS_FINISHED after a continuous frame was sent -> workaround for IE @throws InvalidDataException"}
{"ID": 482, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = \"\"; if( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if( webSocketImpl.getReadyState() == ReadyState.CLOSING ) { // complete the close handshake by disconnecting webSocketImpl.closeConnection( code, reason, true ); } else { // echo close handshake if( getCloseHandshakeType() == CloseHandshakeType.TWOWAY ) webSocketImpl.close( code, reason, true ); else webSocketImpl.flushAndClose( code, reason, false ); } } \nResponse:", "ground_truth": "Process the frame if it is a closing frame\n@param webSocketImpl the websocket impl\n@param frame the frame", "predict": " Processes a closing handshake initiated by this websocket. @param webSocketImpl The websocket which initiated the closing handshake. @param frame The closing frame."}
{"ID": 483, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if( totalSize > maxFrameSize ) { clearBufferList(); log.trace(\"Payload limit reached. Allowed: {} Current: {}\", maxFrameSize, totalSize); throw new LimitExceededException(maxFrameSize); } } \nResponse:", "ground_truth": "Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size\n@throws LimitExceededException if the current size is bigger than the allowed size", "predict": " Checks the buffer list size and throws LimitExceededException if exceeded. Clears the list if exceeded. @throws LimitExceededException When the buffer list exceeds the limit.\n*/"}
{"ID": 484, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate( (int) totalSize ); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put( buffer ); } } resultingByteBuffer.flip(); return resultingByteBuffer; } \nResponse:", "ground_truth": "Method to generate a full bytebuffer out of all the fragmented frame payload\n@return a bytebuffer containing all the data\n@throws LimitExceededException will be thrown when the totalSize is bigger then Integer.MAX_VALUE due to not being able to allocate more", "predict": " Consolidates all the buffers in the list into one big buffer. This is done to avoid numerous small allocations. @return Consolidated buffer containing all buffers in the list. @throws LimitExceededException Thrown if the consolidated buffer exceeds the maximum size allowed.\n*/"}
{"ID": 485, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; } \nResponse:", "ground_truth": "Get the current size of the resulting bytebuffer in the bytebuffer list\n@return the size as long (to not get an integer overflow)", "predict": " Calculate how much memory occupied by the ByteBuffer list. Including duplicated ByteBuffer. @return occupied memory size\n*/"}
{"ID": 486, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if (!\"GET\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid request method received: %s Status line: %s\", firstLineTokens[0],line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor( firstLineTokens[ 1 ] ); return clienthandshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as server\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " HTTP/1.1 101 Switching Protocols"}
{"ID": 487, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if (!\"101\".equals(firstLineTokens[1])) { throw new InvalidHandshakeException( String.format(\"Invalid status code received: %s Status line: %s\", firstLineTokens[1], line)); } if (!\"HTTP/1.1\".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException( String.format(\"Invalid status line received: %s Status line: %s\", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus( Short.parseShort( firstLineTokens[ 1 ] ) ); serverhandshake.setHttpStatusMessage( firstLineTokens[ 2 ] ); return handshake; } \nResponse:", "ground_truth": "Checking the handshake for the role as client\n@return a handshake\n@param firstLineTokens the token of the first line split as as an string array\n@param line the whole line", "predict": " translates the 101 Switching Protocols https://tools.ietf.org/html/rfc7230#section-101 Switching Protocols status line into a 101 Switching Protocols response handshake. @param firstLineTokens the first line tokens @param line the line @return 101 Switching Protocols response handshake\n* @throws InvalidHandshakeException"}
{"ID": 488, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void decode( ByteBuffer socketBuffer ) { assert ( socketBuffer.hasRemaining() ); log.trace( \"process({}): ({})\", socketBuffer.remaining(), ( socketBuffer.remaining() > 1000 ? \"too big to display\" : new String( socketBuffer.array(), socketBuffer.position(), socketBuffer.remaining() ) )); if( readyState != ReadyState.NOT_YET_CONNECTED ) { if( readyState == ReadyState.OPEN ) { decodeFrames( socketBuffer ); } } else { if( decodeHandshake( socketBuffer ) && (!isClosing() && !isClosed())) { assert ( tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer.hasRemaining() ); // the buffers will never have remaining bytes at the same time if( socketBuffer.hasRemaining() ) { decodeFrames( socketBuffer ); } else if( tmpHandshakeBytes.hasRemaining() ) { decodeFrames( tmpHandshakeBytes ); } } } } \nResponse:", "ground_truth": "Method to decode the provided ByteBuffer\n\n@param socketBuffer the ByteBuffer to decode", "predict": " Decodes incoming data from the socket buffer. Will either decode frames or handshake depending on the ready state of this WebSocket. Will not decode anything if the socket is closed. Will decode handshake frames if handshake is not yet complete. Will decode frames if handshake is complete but there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete but there are no leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete and there are leftover bytes in the socket buffer. Will decode leftover bytes if handshake is complete"}
{"ID": 489, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToWrongHandshake( InvalidDataException exception ) { write( generateHttpResponseDueToError( 404 ) ); flushAndClose( exception.getCloseCode(), exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if the received handshake was not correct\n\n@param exception the InvalidDataException causing this problem", "predict": " Properly closes the connection. Necessary since browsers seem to choke on receiving 502 Bad Gateway and then proceeds to retry the request ignoring the 502 Bad Gateway with a valid request. Closing the connection reliably prevents this behavior.\n */"}
{"ID": 490, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void closeConnectionDueToInternalServerError( RuntimeException exception ) { write( generateHttpResponseDueToError( 500 ) ); flushAndClose( CloseFrame.NEVER_CONNECTED, exception.getMessage(), false ); } \nResponse:", "ground_truth": "Close the connection if there was a server error by a RuntimeException\n\n@param exception the RuntimeException causing this problem", "predict": " Properly handle fatal errors happened during the upgrade process. Especially malicious peers can send malicious HTTP responses which may result in serious risks. Therefore ban these peers forever. Furthermore, if these banned peers continually flood and overwhelm the server, the server might be unable to handle and deal with them forever. Therefore let's disconnect these banned peers as well.\n"}
{"ID": 491, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ByteBuffer generateHttpResponseDueToError( int errorCode ) { String errorCodeDescription; switch(errorCode) { case 404: errorCodeDescription = \"404 WebSocket Upgrade Failure\"; break; case 500: default: errorCodeDescription = \"500 Internal Server Error\"; } return ByteBuffer.wrap( Charsetfunctions.asciiBytes( \"HTTP/1.1 \" + errorCodeDescription + \"\\r\\nContent-Type: text/html\\nServer: TooTallNate Java-WebSocket\\r\\nContent-Length: \" + ( 48 + errorCodeDescription.length() ) + \"\\r\\n\\r\\n<html><head></head><body><h1>\" + errorCodeDescription + \"</h1></body></html>\" ) ); } \nResponse:", "ground_truth": "Generate a simple response for the corresponding endpoint to indicate some error\n\n@param errorCode the http error code\n@return the complete response as ByteBuffer", "predict": " Generates a HTTP 101 Switching Protocols response with the given error code. The handshake will be aborted afterwards.\n@param errorCode Error code to respond with. Can be 404 (404 Not Found), 500 (500 Internal Server Error) or 503 (503 Service Unavailable).\n@return Newly allocated ByteBuffer containing the HTTP 101 Switching Protocols response. The caller is responsible for releasing this ByteBuffer.\n*/"}
{"ID": 492, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void send( String text ) { if( text == null ) throw new IllegalArgumentException( \"Cannot send 'null' data to a WebSocketImpl.\" ); send( draft.createFrames( text, role == Role.CLIENT ) ); } \nResponse:", "ground_truth": "Send Text data to the other end.\n\n@throws WebsocketNotConnectedException websocket is not yet connected", "predict": " Send Text data to the remote end point. @param text The textual data to transmit. Although illegal, this method is provided for pragmatic reasons. For example, if the websocket connection is lost, the application may wish to transmit partial data packets rather than waiting for the entire packet to be transmitted. @throws IllegalArgumentException The data could not be transmitted because the data was null.\n*/"}
{"ID": 493, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException(\"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\"); } try { closeBlocking(); if( writeThread != null ) { this.writeThread.interrupt(); this.writeThread = null; } if( connectReadThread != null ) { this.connectReadThread.interrupt(); this.connectReadThread = null; } this.draft.reset(); if( this.socket != null ) { this.socket.close(); this.socket = null; } } catch ( Exception e ) { onError( e ); engine.closeConnection( CloseFrame.ABNORMAL_CLOSE, e.getMessage() ); return; } connectLatch = new CountDownLatch( 1 ); closeLatch = new CountDownLatch( 1 ); this.engine = new WebSocketImpl( this, this.draft ); } \nResponse:", "ground_truth": "Reset everything relevant to allow a reconnect\n@since 1.3.8", "predict": " Immediately closes the Websocket connection."}
{"ID": 494, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void connect() { if( connectReadThread != null ) throw new IllegalStateException( \"WebSocketClient objects are not reuseable\" ); connectReadThread = new Thread( this ); connectReadThread.setName( \"WebSocketConnectReadThread-\" + connectReadThread.getId() ); connectReadThread.start(); } \nResponse:", "ground_truth": "Initiates the websocket connection. This method does not block.", "predict": " Initiates a WebSocket connection. This method blocks until the connection succeeds or fails.\n */"}
{"ID": 495, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getPort() { int port = uri.getPort(); if( port == -1 ) { String scheme = uri.getScheme(); if( \"wss\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_WSS_PORT; } else if( \"ws\".equals( scheme ) ) { return WebSocketImpl.DEFAULT_PORT; } else { throw new IllegalArgumentException( \"unknown scheme: \" + scheme ); } } return port; } \nResponse:", "ground_truth": "Extract the specified port\n@return the specified port or the default port for the specific scheme", "predict": " Gets the port of the URI or -1 if no port is specified."}
{"ID": 496, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if( part1 == null || part1.length() == 0 ) path = \"/\"; else path = part1; if( part2 != null ) path += '?' + part2; int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? \":\" + port : \"\" ); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor( path ); handshake.put( \"Host\", host ); if( headers != null ) { for( Map.Entry<String,String> kv : headers.entrySet() ) { handshake.put( kv.getKey(), kv.getValue() ); } } engine.startHandshake( handshake ); } \nResponse:", "ground_truth": "Create and send the handshake to the other endpoint\n@throws InvalidHandshakeException  a invalid handshake was created", "predict": " Send the opening handshake request to the server. After sending the handshake request, it pumps until HELLO answer arrives. It seems that there is no other way to assure the websocket connection is established!? Maybe there is a mistake in the spec!? Consult RFC 6455 \u00a77.2 Introduction and Terminology"}
{"ID": 497, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setConnectionLostTimeout( int connectionLostTimeout ) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); return; } if (this.websocketRunning) { log.trace(\"Connection lost timer restarted\"); //Reset all the pings try { ArrayList<WebSocket> connections = new ArrayList<WebSocket>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { log.error(\"Exception during connection lost restart\", e); } restartConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Setter for the interval checking for lost connections\nA value lower or equal 0 results in the check to be deactivated\n\n@param connectionLostTimeout the interval in seconds\n@since 1.3.4", "predict": " Set the connectionLostTimeout. @param connectionLostTimeout The connectionLostTimeout to set.\n*/"}
{"ID": 498, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; log.trace(\"Connection lost timer stopped\"); cancelConnectionLostTimer(); } } } \nResponse:", "ground_truth": "Stop the connection lost timer\n@since 1.3.4", "predict": " Stop connection lost timer."}
{"ID": 499, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { log.trace(\"Connection lost timer deactivated\"); return; } log.trace(\"Connection lost timer started\"); this.websocketRunning = true; restartConnectionLostTimer(); } } \nResponse:", "ground_truth": "Start the connection lost timer\n@since 1.3.4", "predict": " Activate connection lost timer."}
{"ID": 500, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(\"connectionLostChecker\")); Runnable connectionLostChecker = new Runnable() { /** * Keep the connections in a separate list to not cause deadlocks */ private ArrayList<WebSocket> connections = new ArrayList<WebSocket>( ); @Override public void run() { connections.clear(); try { connections.addAll( getConnections() ); long minimumPongTime = (long) (System.nanoTime() - ( connectionLostTimeout * 1.5 )); for( WebSocket conn : connections ) { executeConnectionLostDetection(conn, minimumPongTime); } } catch ( Exception e ) { //Ignore this exception } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService.scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); } \nResponse:", "ground_truth": "This methods allows the reset of the connection lost timer in case of a changed parameter\n@since 1.3.4", "predict": " Restarts the connectionLostTimer. Necessary if the websocket connection drops unexpectedly."}
{"ID": 501, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if( webSocketImpl.getLastPong() < minimumPongTime ) { log.trace(\"Closing connection due to no pong received: {}\", webSocketImpl); webSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ); } else { if( webSocketImpl.isOpen() ) { webSocketImpl.sendPing(); } else { log.trace(\"Trying to ping a non open connection: {}\", webSocketImpl); } } } \nResponse:", "ground_truth": "Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping\n@param webSocket the websocket instance\n@param minimumPongTime the lowest/oldest allowable last pong time (in nanoTime) before we consider the connection to be lost", "predict": " Executes the connection lost detection logic. Will close the connection if the minimum pong time has elapsed. @param webSocket The websocket to perform the detection on. @param minimumPongTime The minimum pong time to trigger the connection loss detection."}
{"ID": 502, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void cancelConnectionLostTimer() { if( connectionLostCheckerService != null ) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } } \nResponse:", "ground_truth": "Cancel any running timer for the connection lost detection\n@since 1.3.4", "predict": " Cancels the Connection Lost Timer if it is running."}
{"ID": 503, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer( WebSocket conn, Draft draft, ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server(); } \nResponse:", "ground_truth": "This default implementation does not do anything. Go ahead and overwrite it.\n\n@see org.java_websocket.WebSocketListener#onWebsocketHandshakeReceivedAsServer(WebSocket, Draft, ClientHandshake)", "predict": " Implement this method to create your own handshake for the server. @return The handshake you want to send to the client. Returning null will make the framework use the default handshake."}
{"ID": 504, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void onWebsocketPing( WebSocket conn, Framedata f ) { conn.sendFrame( new PongFrame( (PingFrame)f ) ); } \nResponse:", "ground_truth": "This default implementation will send a pong in response to the received ping.\nThe pong frame will have the same payload as the ping frame.\n\n@see org.java_websocket.WebSocketListener#onWebsocketPing(WebSocket, Framedata)", "predict": " Implement this to handle ping frames. You have to return FRAME_OPENED to inform the sender that you indeed received the frame. You must send a correct pong in any case. @see SimpleChannelHandler"}
{"ID": 505, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop( int timeout ) throws InterruptedException { if( !isclosed.compareAndSet( false, true ) ) { // this also makes sure that no further connections will be added to this.connections return; } List<WebSocket> socketsToClose; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList<WebSocket>( connections ); } for( WebSocket ws : socketsToClose ) { ws.close( CloseFrame.GOING_AWAY ); } wsf.close(); synchronized ( this ) { if( selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join( timeout ); } } } \nResponse:", "ground_truth": "Closes all connected clients sockets, then closes the underlying\nServerSocketChannel, effectively killing the server socket selectorthread,\nfreeing the port the server was bound to and stops all internal workerthreads.\n\nIf this method is called before the server is started it will never start.\n\n@param timeout\nSpecifies how many milliseconds the overall close handshaking may take altogether before the connections are closed without proper close handshaking.<br>\n\n@throws InterruptedException Interrupt", "predict": " Stop the AutobahnServer brutally killing all spawned selectors and threads. Useful for cleaning up stuff in beforeShutdown(). PRECONDITION: has to be called BEFORE the threads / sockets are stopped."}
{"ID": 506, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getPort() { int port = getAddress().getPort(); if( port == 0 && server != null ) { port = server.socket().getLocalPort(); } return port; } \nResponse:", "ground_truth": "Gets the port number that this server listens on.\n\n@return The port number.", "predict": " Returns the port that this server socket is bound to. If the server socket was bound prior to being shut down, the port number will be available. Otherwise, this method returns 0. @return The port that this server socket is bound to. If the server socket was bound prior to being shut down, the port number will be available. Otherwise, this method returns 0."}
{"ID": 507, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while ( !iqueue.isEmpty() ) { conn = iqueue.remove( 0 ); WrappedByteChannel c = ( (WrappedByteChannel) conn.getChannel() ); ByteBuffer buf = takeBuffer(); try { if( SocketChannelIOHelper.readMore( buf, conn, c ) ) iqueue.add( conn ); if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } } } \nResponse:", "ground_truth": "Do an additional read\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " Called exclusively by run() to initiate reads and process buffered data. Broken out into a separate function to facilitate testing."}
{"ID": 508, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if( !onConnect( key ) ) { key.cancel(); return; } SocketChannel channel = server.accept(); if(channel==null){ return; } channel.configureBlocking( false ); Socket socket = channel.socket(); socket.setTcpNoDelay( isTcpNoDelay() ); socket.setKeepAlive( true ); WebSocketImpl w = wsf.createWebSocket( this, drafts ); w.setSelectionKey(channel.register( selector, SelectionKey.OP_READ, w )); try { w.setChannel( wsf.wrapChannel( channel, w.getSelectionKey() )); i.remove(); allocateBuffers( w ); } catch (IOException ex) { if( w.getSelectionKey() != null ) w.getSelectionKey().cancel(); handleIOException( w.getSelectionKey(), null, ex ); } } \nResponse:", "ground_truth": "Execute a accept operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@throws InterruptedException  thrown by taking a buffer\n@throws IOException if an error happened during accept", "predict": " Accept a TCP connection from a remote host. You need to call this to establish a new outgoing connection. You do not call this to simply wait for an incoming connection. This will block until a new connection arrives: If you want to have a non-blocking connect, just call #accept() and then call #connected(). @see #connected()\n"}
{"ID": 509, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if(conn.getChannel() == null){ key.cancel(); handleIOException( key, conn, new IOException() ); return false; } try { if( SocketChannelIOHelper.read( buf, conn, conn.getChannel() ) ) { if( buf.hasRemaining() ) { conn.inQueue.put( buf ); queue( conn ); i.remove(); if( conn.getChannel() instanceof WrappedByteChannel && ( (WrappedByteChannel) conn.getChannel() ).isNeedRead() ) { iqueue.add( conn ); } } else { pushBuffer(buf); } } else { pushBuffer( buf ); } } catch ( IOException e ) { pushBuffer( buf ); throw e; } return true; } \nResponse:", "ground_truth": "Execute a read operation\n@param key the selectionkey to read off\n@param i the iterator for the selection keys\n@return true, if the read was successful, or false if there was an error\n@throws InterruptedException thrown by taking a buffer\n@throws IOException if an error happened during read", "predict": " Actually processes reads and writes and lets the thread pools to it."}
{"ID": 510, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doWrite(SelectionKey key) throws IOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); if( SocketChannelIOHelper.batch( conn, conn.getChannel() ) ) { if( key.isValid() ) { key.interestOps(SelectionKey.OP_READ); } } } \nResponse:", "ground_truth": "Execute a write operation\n@param key the selectionkey to write on\n@throws IOException if an error happened during batch", "predict": " Actually processes write requests for a SelectionKey. You probably don't want to call this directly. Instead use processWriteBuffer() below. This method is meant for subclasses to implement their own write mechanism. @throws IOException may be thrown by the OS"}
{"ID": 511, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doSetupSelectorAndServerThread() { selectorthread.setName( \"WebSocketSelector-\" + selectorthread.getId() ); try { server = ServerSocketChannel.open(); server.configureBlocking( false ); ServerSocket socket = server.socket(); socket.setReceiveBufferSize( WebSocketImpl.RCVBUF ); socket.setReuseAddress( isReuseAddr() ); socket.bind( address ); selector = Selector.open(); server.register( selector, server.validOps() ); startConnectionLostTimer(); for( WebSocketWorker ex : decoders ){ ex.start(); } onStart(); } catch ( IOException ex ) { handleFatal( null, ex ); return false; } return true; } \nResponse:", "ground_truth": "Setup the selector thread as well as basic server settings\n@return true, if everything was successful, false if some error happened", "predict": " Starts the connectionLostTimer iff it isn't already running. The latter is implied by the latter being able to be called multiple times. Besides starting it isn't crucial that it actually runs."}
{"ID": 512, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean doEnsureSingleThread() { synchronized ( this ) { if( selectorthread != null ) throw new IllegalStateException( getClass().getName() + \" can only be started once.\" ); selectorthread = Thread.currentThread(); if( isclosed.get() ) { return false; } } return true; } \nResponse:", "ground_truth": "The websocket server can only be started once\n@return true, if the server can be started, false if already a thread is running", "predict": " Ensures that only one thread is selecting for events at any given time. Necessary evil due to poor design of Reactor.waitForMultipleEvents vs pollForMultipleEvents NIAS-399"}
{"ID": 513, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doServerShutdown() { stopConnectionLostTimer(); if( decoders != null ) { for( WebSocketWorker w : decoders ) { w.interrupt(); } } if( selector != null ) { try { selector.close(); } catch ( IOException e ) { log.error( \"IOException during selector.close\", e ); onError( null, e ); } } if( server != null ) { try { server.close(); } catch ( IOException e ) { log.error( \"IOException during server.close\", e ); onError( null, e ); } } } \nResponse:", "ground_truth": "Clean up everything after a shutdown", "predict": " Initiates forceful termination of the server."}
{"ID": 514, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Socket getSocket( WebSocket conn ) { WebSocketImpl impl = (WebSocketImpl) conn; return ( (SocketChannel) impl.getSelectionKey().channel() ).socket(); } \nResponse:", "ground_truth": "Getter to return the socket used by this specific connection\n@param conn The specific connection\n@return The socket used by this connection", "predict": " Allows the efficient use of channel arrays @param conn The WebSocket connection @return socket associated with selectionKey\n*/"}
{"ID": 515, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); } \nResponse:", "ground_truth": "Send a byte array to a specific collection of websocket connections\n@param data the data to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Broadcasts a message to all connected clients. @param data The message to broadcast. @param clients The clients to broadcast to."}
{"ID": 516, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); } \nResponse:", "ground_truth": "Send a text to a specific collection of websocket connections\n@param text the text to send to the endpoints\n@param clients a collection of endpoints to whom the text has to be send", "predict": " Broadcasts a message to all clients subscribed to the broadcast topic. @param text The message to broadcast. @param clients The clients to broadcast to."}
{"ID": 517, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void doBroadcast(Object data, Collection<WebSocket> clients) { String sData = null; if (data instanceof String) { sData = (String)data; } ByteBuffer bData = null; if (data instanceof ByteBuffer) { bData = (ByteBuffer)data; } if (sData == null && bData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<Draft, List<Framedata>>(); for( WebSocket client : clients ) { if( client != null ) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, sData, bData); try { client.sendFrame( draftFrames.get( draft ) ); } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } } \nResponse:", "ground_truth": "Private method to cache all the frames to improve memory footprint and conversion time\n@param data the data to broadcast\n@param clients the clients to send the message to", "predict": " Send the data Broadcast! All clients connected to this rooms data will receive the data! You can broadcast using this method BEFORE you joined the room or you can broadcast using this AFTER you joined the room too! You cannot broadcast using this BEFORE you joined the room! @param data Data you want to send! You can send string or byte data! You can also send ByteBuffers! Remember: You cannot broadcast any fancy data i.e. serializable objects! You CAN broadcast huge (>4kb) data! Please use care! You cannot broadcast stuff like images or files! Files bigger than 4kb ARE NOT SUPPORTED! You CAN send BYTE data! You cannot send mixed data (String and BYTE)! You CANNOT send stuff like IMAGES or FILES! Images are NOT SUPPORTED! Files are NOT SUPPORTED! Please use care! You cannot broadcast stuff like huge (>4kb) data! Please use care! You cannot broadcast stuff like huge (>4kb) data! Please use care! You cannot broadcast stuff like huge (>4kb) data! Please"}
{"ID": 518, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String sData, ByteBuffer bData) { if( !draftFrames.containsKey( draft ) ) { List<Framedata> frames = null; if (sData != null) { frames = draft.createFrames( sData, false ); } if (bData != null) { frames = draft.createFrames( bData, false ); } if (frames != null) { draftFrames.put(draft, frames); } } } \nResponse:", "ground_truth": "Fills the draftFrames with new data for the broadcast\n@param draft The draft to use\n@param draftFrames The list of frames per draft to fill\n@param sData the string data, can be null\n@param bData the bytebuffer data, can be null", "predict": " Will be called from FramedataImpl.writeFramedata(), if data must be fragmented, so we must wrap the data into frames here. Furthermore we must decide which draft we shall use for framing here! @param draft The draft we shall use for framing fragmented DATA frames @param draftFrames The map of drafts to lists of framedata belonging to them. So far only the latest draft is maintained @param sData The string to be fragmented into DATA frames. Might be null. In that case draft.base64() is false. @param bData The ByteBuf to be fragmented into DATA frames. Might be null. In that case draft.base64() is false."}
{"ID": 519, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int transferByteBuffer( ByteBuffer source, ByteBuffer dest ) { if( source == null || dest == null ) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if( fremain > toremain ) { int limit = Math.min( fremain, toremain ); source.limit( limit ); dest.put( source ); return limit; } else { dest.put( source ); return fremain; } } \nResponse:", "ground_truth": "Transfer from one ByteBuffer to another ByteBuffer\n\n@param source the ByteBuffer to copy from\n@param dest   the ByteBuffer to copy to\n@return the number of transferred bytes", "predict": " Transferring bytes from one ByteBuffer to another. @param source Source ByteBuffer. @param dest Target ByteBuffer. @return Number of transferred bytes."}
{"ID": 520, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JPAApi start() { jpaConfig .persistenceUnits() .forEach( persistenceUnit -> emfs.put( persistenceUnit.name, Persistence.createEntityManagerFactory(persistenceUnit.unitName))); return this; } \nResponse:", "ground_truth": "Initialise JPA entity manager factories.", "predict": " Starts the JPA subsystem. After this method is called, you can obtain EntityManagerFactory instances using emfs.get(persistenceUnitName). You can also obtain EntityManagerFactory instances using emf.get(persistenceUnitName). However, EntityManager instances obtained from EntityManagerFactory instances obtained through emfs.get(persistenceUnitName) are not transactional. Therefore, you should only use EntityManager instances obtained through emfs.get(persistenceUnitName) if you are sure that you do not intend to use EntityManager instances obtained through emf.get(persistenceUnitName) in a transactional manner. @return fluent interface\n*/"}
{"ID": 521, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em(String name) { EntityManagerFactory emf = emfs.get(name); if (emf == null) { return null; } return emf.createEntityManager(); } \nResponse:", "ground_truth": "Get a newly created EntityManager for the specified persistence unit name.\n\n@param name The persistence unit name", "predict": " Obtains EntityManager by name. @param name Name of EntityManagerFactory. @return EntityManager."}
{"ID": 522, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void withTransaction(Consumer<EntityManager> block) { withTransaction( em -> { block.accept(em); return null; }); } \nResponse:", "ground_truth": "Run a block of code with a newly created EntityManager for the default Persistence Unit.\n\n@param block Block of code to execute", "predict": " Wrap the supplied block in a transaction and execute it. Useful for ensuring that database operations are rolled back properly. @param block Consumer to execute within a transaction. @see EntityTransaction#begin()\n */"}
{"ID": 523, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Seq<Object> convertArgsToScalaBuffer(final Object... args) { return scala.collection.JavaConverters.asScalaBufferConverter(wrapArgsToListIfNeeded(args)) .asScala() .toList(); } \nResponse:", "ground_truth": "Converts the varargs to a scala buffer, takes care of wrapping varargs into a intermediate list\nif necessary\n\n@param args the message arguments\n@return scala type for message processing", "predict": " Convert args to Scala SeqBuffer. @param args args to convert. @return Scala SeqBuffer."}
{"ID": 524, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs private static <T> List<T> wrapArgsToListIfNeeded(final T... args) { List<T> out; if (args != null && args.length == 1 && args[0] instanceof List) { out = (List<T>) args[0]; } else { out = Arrays.asList(args); } return out; } \nResponse:", "ground_truth": "Wraps arguments passed into a list if necessary.\n\n<p>Returns the first value as is if it is the only argument and a subtype of `java.util.List`\nOtherwise, it calls Arrays.asList on args\n\n@param args arguments as a List", "predict": " Wraps the arguments to a list if needed. @param args The arguments to wrap. Can be null. @return The wrapped arguments. Never null. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty. Can be unmodifiable. Can be immutable. Can be empty"}
{"ID": 525, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, String key, Object... args) { Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(key, scalaArgs, lang); } \nResponse:", "ground_truth": "Translates a message.\n\n<p>Uses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get a localized message. The key may contain placeholders denoted by a percent sign (%) followed by number. Placeholders may appear anywhere within the \"%s\" pattern in the format string. Each placeholder is replaced by successive elements of the argument list. @param lang The preferred language to use for localization of the message. @param key The message key to lookup. @param args Arguments referenced by placeholders in the format string.\n@since 2.13\n*/"}
{"ID": 526, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String get(play.api.i18n.Lang lang, List<String> keys, Object... args) { Buffer<String> keyArgs = scala.collection.JavaConverters.asScalaBufferConverter(keys).asScala(); Seq<Object> scalaArgs = convertArgsToScalaBuffer(args); return messages.apply(keyArgs.toSeq(), scalaArgs, lang); } \nResponse:", "ground_truth": "Translates the first defined message.\n\n<p>Uses `java.text.MessageFormat` internally to format the message.\n\n@param lang the message lang\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get a localized message. The first argument is the language, and the rest are printf-style arguments for substituting in the message. The language is looked up from Play's default resolver, using the language code as an argument.\nThe language may be a 2 letter language code (ISO-639-1), or a 3 letter language code (ISO-639-2).\nThe language may also be a 2 letter language code augmented with an underscore (_) followed by 3 letters, such as fr_FR_. This form assumes the language is using the revised 2 letter language codes defined by ISO-639-2. However, 3 letter language codes are also supported for backward compatibility. @param lang The language to use for selecting the message. @param keys The printf-style arguments for substituting in the message. @param args The printf-style arguments for substituting in the message. @return The localized message.\n*/"}
{"ID": 527, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Boolean isDefinedAt(play.api.i18n.Lang lang, String key) { return messages.isDefinedAt(key, lang); } \nResponse:", "ground_truth": "Check if a message key is defined.\n\n@param lang the message lang\n@param key the message key\n@return a Boolean", "predict": " Checks if a message is available for the given langauge. The lookup is case insensitive. @param lang The language to check for. @param key The message key to check. @return Whether the message is available or not.\n*/"}
{"ID": 528, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Collection<Lang> candidates) { Seq<Lang> cs = Scala.asScala(candidates); play.api.i18n.Messages msgs = messages.preferred((Seq) cs); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given candidates.\n\n<p>Will select a language from the candidates, based on the languages available, and fallback\nto the default language if none of the candidates are available.\n\n@param candidates the candidate languages\n@return the most appropriate Messages instance given the candidate languages", "predict": " Selects the preferred Lang(s) from the candidates. The Lang(s) are ranked according to how much they support the messages in question, and the Lang(s) with the highest ranking are selected. @param candidates The candidate Lang(s) to choose from. @return The preferred Lang(s).\n*/"}
{"ID": 529, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Messages preferred(Http.RequestHeader request) { play.api.i18n.Messages msgs = messages.preferred(request); return new MessagesImpl(new Lang(msgs.lang()), this); } \nResponse:", "ground_truth": "Get a messages context appropriate for the given request.\n\n<p>Will select a language from the request, based on the languages available, and fallback to\nthe default language if none of the candidates are available.\n\n@param request the incoming request\n@return the preferred messages context for the request", "predict": " The preferred language for the messages. @param request The HTTP request. @return The preferred language for the messages.\n*/"}
{"ID": 530, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Result setLang(Result result, Lang lang) { return messages.setLang(result.asScala(), lang).asJava(); } \nResponse:", "ground_truth": "Given a Result and a Lang, return a new Result with the lang cookie set to the given Lang.\n\n@param result the result where the lang will be set.\n@param lang the lang to set on the result\n@return a new result with the lang.", "predict": " Set Lang information to the result. @param result The result to set Lang information. @param lang Lang information to set. @return The result with Lang information set."}
{"ID": 531, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(GuiceableModule... modules) { return newBuilder(delegate.bindings(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Add bindings from guiceable modules.\n\n@param modules the set of modules to bind\n@return a copy of this builder configured with those modules", "predict": " Binds several modules sequentially. Equivalent to Guice.bindSequentially(this, modules). @param modules modules to bind sequentially\n@return Self, fluent API\n*/"}
{"ID": 532, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Module... modules) { return bindings(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Add bindings from Play modules.\n\n@param modules the set of Guice modules whose bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " Bind everything from these modules. @param modules The modules to bind. @return A new Self instance.\n*/"}
{"ID": 533, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self bindings(play.api.inject.Binding<?>... bindings) { return bindings(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Add Play bindings.\n\n@param bindings the set of play bindings to apply\n@return a copy of this builder configured with the provided bindings", "predict": " Bind these objects to the DI container. This is equivalent to invoking <code>bind()</code> on each of them individually. @param bindings The objects to bind. @return A new Self instance with the additional bindings.\n*/"}
{"ID": 534, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(GuiceableModule... modules) { return newBuilder(delegate.overrides(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override bindings using guiceable modules.\n\n@param modules the set of Guice modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " Override modules in this builder. @param modules Modules to override. @return New builder with overridden modules.\n*/"}
{"ID": 535, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Module... modules) { return overrides(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override bindings using Play modules.\n\n@param modules the set of Play modules whose bindings override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " Override modules with the specified Play modules. Useful for injecting Play dependencies into Scala actors. Equivalent to `play.api.inject.Module$.MODULE$.overrideWith(modules)`. @param modules The Play modules to use. @return A new Scala injector with the specified modules overriding the Play injector.\n*/"}
{"ID": 536, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self overrides(play.api.inject.Binding<?>... bindings) { return overrides(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override bindings using Play bindings.\n\n@param bindings a set of Play bindings that override some previously configured ones\n@return a copy of this builder re-configured with the provided bindings", "predict": " Bind these Play bindings to Guice. @param bindings The Play bindings to bind. @return A Self reference for fluency.\n*/"}
{"ID": 537, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final Self disable(Class<?>... moduleClasses) { return newBuilder(delegate.disable(Scala.toSeq(moduleClasses))); } \nResponse:", "ground_truth": "Disable modules by class.\n\n@param moduleClasses the module classes whose bindings should be disabled\n@return a copy of this builder configured to ignore the provided module classes", "predict": " Disable modules. Similar to Guice's --disable flag. Disables one or more modules. @param moduleClasses Classes of modules to disable. @return Fluent API for fluent chaining. Never null."}
{"ID": 538, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage<Result> call(Context ctx) { return call( ctx.args != null && !ctx.args.isEmpty() ? ctx.request().addAttr(CTX_ARGS, ctx.args) : ctx.request()); } \nResponse:", "ground_truth": "Executes this action with the given HTTP context and returns the result.\n\n@param ctx the http context in which to execute this action\n@return a promise to the action's result\n@deprecated Since 2.7.0. Use {@link #call(Request)} instead. Please see <a\nhref=\"https://www.playframework.com/documentation/latest/JavaHttpContextMigration27\">the\nmigration guide</a> for more details.", "predict": " Deprecated. Use async(Request) instead.\n */"}
{"ID": 539, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<Result> call( Request req) { // TODO: Make this method abstract after removing call(Context) return Context.safeCurrent() .map( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx.withRequest(req.removeAttr(CTX_ARGS)); Context.setCurrent(newCtx); return call(newCtx); }) .orElseGet( () -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context(req.removeAttr(CTX_ARGS), contextComponents); ctx.args = req.attrs().getOptional(CTX_ARGS).orElse(new HashMap<>()); return call(ctx); }); } \nResponse:", "ground_truth": "Executes this action with the given HTTP request and returns the result.\n\n@param req the http request with which to execute this action\n@return a promise to the action's result", "predict": " Invoke the action with the current request context. The current context is preserved on the thread local. The context will be automatically restored after the action completes. @param req The current request context. @return The result of the action.\n*/\npublic CompletionStage<Result> call(Request req) {\n\treturn CompletableFuture.supplyAsync( () -> {\n\t\tContext ctx = Context.current();\n\t\tContext.setCurrent(req.removeAttr(CTX_ARGS));\n\t\treturn call(req.removeAttr(CTX_ARGS));\n\t}, executorService);\n}\n\n/**\n * Invoke the action with the current request context. The current context is preserved on the thread local. The context will be automatically restored after the action completes.\n * @param req The current request context.\n * @return The result of the action.\n */"}
{"ID": 540, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<File> getExistingFile(String relativePath) { return OptionConverters.toJava(env.getExistingFile(relativePath)); } \nResponse:", "ground_truth": "Retrieves a file relative to the application root path. This method returns an Optional, using\nempty if the file was not found.\n\n@param relativePath relative path of the file to fetch\n@return an existing file", "predict": " Get the value of a single environment variable. Returns an absent value if the environment variable is not defined. @param relativePath Relative path within the sandbox to the environment variable. @return Environment variable value or absent if the environment variable is not defined."}
{"ID": 541, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> Binding<T> in(final Class<A> scope) { return underlying.in(scope).asJava(); } \nResponse:", "ground_truth": "Configure the scope for this binding.", "predict": " Instruct Retrofit to convert the body of the request to the given type. @param scope The class whose annotations should be searched for annotations applicable to the incoming request body. Ideally, this would be your service interface. @param <A> The Retrofit-generated class containing the annotation. @return The updated Builder instance so that additional calls can be chained.\n"}
{"ID": 542, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B> Tuple<A, B> Tuple(A a, B b) { return new Tuple<A, B>(a, b); } \nResponse:", "ground_truth": "Constructs a tuple of A,B\n\n@param a The a value\n@param b The b value\n@param <A> a's type\n@param <B> b's type\n@return The tuple", "predict": " Static factory method for creating a new Tuple. Useful for situations where you want to statically bind two values together. @param a The first value. @param b The second value. @return A new Tuple containing the two values."}
{"ID": 543, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A, B, C, D, E> Tuple5<A, B, C, D, E> Tuple5(A a, B b, C c, D d, E e) { return new Tuple5<A, B, C, D, E>(a, b, c, d, e); } \nResponse:", "ground_truth": "Constructs a tuple of A,B,C,D,E\n\n@param a The a value\n@param b The b value\n@param c The c value\n@param d The d value\n@param e The e value\n@param <A> a's type\n@param <B> b's type\n@param <C> c's type\n@param <D> d's type\n@param <E> e's type\n@return The tuple", "predict": " Static factory method for creating Tuples of arity 5. @param a The first value. @param b The second value. @param c The third value. @param d The fourth value. @param e The fifth value. @return A Tuple of arity 5."}
{"ID": 544, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static Executor toExecutor(ExecutionContext ec) { ExecutionContext prepared = ec.prepare(); if (prepared instanceof Executor) { return (Executor) prepared; } else { return prepared::execute; } } \nResponse:", "ground_truth": "Converts the execution context to an executor, preparing it first.\n\n@param ec the execution context.\n@return the Java Executor.", "predict": " Wrap the execution context in an executor if necessary.\n<p>Note that this method is only ever called from GroovyShellTestSupport.groovyTestCase(). GroovyShellTestSupport.groovyTestCase() is marked synthetic, so synthetic groovyTestCase() methods won't trigger this. That means that the GroovyShellTestSupport class is effectively final. However, GroovyShellTestSupportTest is inherited from GroovyShellTestSupport, so it needs to have this method. Unfortunately GroovyShellTestSupportTest inherits from GroovyShellTestSupport through GroovyShellTestSupportTestCase, so GroovyShellTestSupportTestCase also needs to have this method. Luckily, GroovyShellTestSupportTestCase doesn't inherit through GroovyShellTestSupportTestCase, so GroovyShellTestSupportTestCase doesn't need to inherit through GroovyShellTestSupportTestCase either. So GroovyShellTestSupportTestCase doesn't need to inherit through GroovyShellTestSupportTestCase either. That means that GroovyShellTestSupport"}
{"ID": 545, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String name, String unitName) { return new DefaultJPAConfig(new JPAConfig.PersistenceUnit(name, unitName)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given name and unit name.\n\n@param name the name for the entity manager factory\n@param unitName the persistence unit name as used in `persistence.xml`\n@return a default JPA configuration", "predict": " Create a JPAConfig with the given persistence unit name. @param name The persistence unit name. @param unitName The persistence unit name. @return The JPAConfig.\n*/"}
{"ID": 546, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig of(String n1, String u1, String n2, String u2) { return new DefaultJPAConfig( new JPAConfig.PersistenceUnit(n1, u1), new JPAConfig.PersistenceUnit(n2, u2)); } \nResponse:", "ground_truth": "Create a default JPA configuration with the given names and unit names.\n\n@param n1 Name of the first entity manager factory\n@param u1 Name of the first unit\n@param n2 Name of the second entity manager factory\n@param u2 Name of the second unit\n@return a default JPA configuration with the provided persistence units.", "predict": " Static factory method to create a JPAConfig with two persistence units. @param n1 Name of the first persistence unit. @param u1 Unit of the first persistence unit. @param n2 Name of the second persistence unit. @param u2 Unit of the second persistence unit. @return JPAConfig with two persistence units."}
{"ID": 547, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JPAConfig from(Map<String, String> map) { ImmutableSet.Builder<JPAConfig.PersistenceUnit> persistenceUnits = new ImmutableSet.Builder<JPAConfig.PersistenceUnit>(); for (Map.Entry<String, String> entry : map.entrySet()) { persistenceUnits.add(new JPAConfig.PersistenceUnit(entry.getKey(), entry.getValue())); } return new DefaultJPAConfig(persistenceUnits.build()); } \nResponse:", "ground_truth": "Create a default JPA configuration from a map of names to unit names.\n\n@param map Map of entity manager factory names to unit names\n@return a JPAConfig configured with the provided mapping", "predict": " Create a JPAConfig from a map of persistence unit names and values. @param map Map of persistence unit names and values. @return JPAConfig.\n*/"}
{"ID": 548, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<String, ByteString, NotUsed> string(String callbackName) { return Flow.of(String.class) .map( str -> { return ByteString.fromString(\"'\" + StringEscapeUtils.escapeEcmaScript(str) + \"'\"); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a Flow of escaped ByteString from a series of String elements. Calls out to Comet.flow\ninternally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Turns a string into a ByteString. Escapes \\\\ and \\\". Also escapes single quotes. Useful for escaping JSON. @param callbackName Name of the callback to use when transforming the string. Helpful for IDE auto-complete. @return Flow that turns a string into a ByteString. Useful for escaping JSON."}
{"ID": 549, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Flow<JsonNode, ByteString, NotUsed> json(String callbackName) { return Flow.of(JsonNode.class) .map( json -> { return ByteString.fromString(Json.stringify(json)); }) .via(flow(callbackName)); } \nResponse:", "ground_truth": "Produces a flow of ByteString using `Json.stringify` from a Flow of JsonNode. Calls out to\nComet.flow internally.\n\n@param callbackName the javascript callback method.\n@return a flow of ByteString elements.", "predict": " Turns a json string into a ByteString. Useful for interfacing with http services. @param callbackName Name of the callback to invoke. @return Flow that converts a json string into a ByteString. Useful for interfacing with http services."}
{"ID": 550, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T extends ConstraintValidator<?, ?>> MappedConstraintValidatorFactory addConstraintValidator(Class<T> key, T constraintValidator) { validators.put(key, () -> constraintValidator); return this; } \nResponse:", "ground_truth": "Adds validator as a singleton.\n\n@param key the constraint validator type\n@param constraintValidator the constraint validator instance\n@param <T> the type of constraint validator implementation\n@return {@link MappedConstraintValidatorFactory} with the given constraint validator added.", "predict": " Adds a constraint validator to the factory. @param key The constraint validator key. @param constraintValidator The constraint validator. @param <T> The constraint validator type. @return The factory.\n*/"}
{"ID": 551, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private <T extends ConstraintValidator<?, ?>> T newInstance(Class<T> key) { try { return key.getDeclaredConstructor().newInstance(); } catch (InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex) { throw new RuntimeException(ex); } } \nResponse:", "ground_truth": "need to do so.", "predict": " Dynamically instantiates a ConstraintValidator class. @param key The ConstraintValidator class. @return The ConstraintValidator instance.\n*/"}
{"ID": 552, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method getMatchingAccessibleMethod( final Class<?> cls, final String methodName, final Class<?>... parameterTypes) { try { final Method method = cls.getMethod(methodName, parameterTypes); MemberUtils.setAccessibleWorkaround(method); return method; } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null; final Method[] methods = cls.getMethods(); for (final Method method : methods) { // compare name and parameters if (method.getName().equals(methodName) && MemberUtils.isMatchingMethod(method, parameterTypes)) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod(method); if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareMethodFit(accessibleMethod, bestMatch, parameterTypes) < 0)) { bestMatch = accessibleMethod; } } } if (bestMatch != null) { MemberUtils.setAccessibleWorkaround(bestMatch); } if (bestMatch != null && bestMatch.isVarArgs() && bestMatch.getParameterTypes().length > 0 && parameterTypes.length > 0) { final Class<?>[] methodParameterTypes = bestMatch.getParameterTypes(); final Class<?> methodParameterComponentType = methodParameterTypes[methodParameterTypes.length - 1].getComponentType(); final String methodParameterComponentTypeName = ClassUtils.primitiveToWrapper(methodParameterComponentType).getName(); final String parameterTypeName = parameterTypes[parameterTypes.length - 1].getName(); final String parameterTypeSuperClassName = parameterTypes[parameterTypes.length - 1].getSuperclass().getName(); if (!methodParameterComponentTypeName.equals(parameterTypeName) && !methodParameterComponentTypeName.equals(parameterTypeSuperClassName)) { return null; } } return bestMatch; } \nResponse:", "ground_truth": "Finds an accessible method that matches the given name and has compatible parameters.\nCompatible parameters mean that every method parameter is assignable from the given parameters.\nIn other words, it finds a method with the given name that will take the parameters given.\n\n<p>This method can match primitive parameter by passing in wrapper classes. For example, a\n{@code Boolean} will match a primitive {@code boolean} parameter.\n\n@param cls find method in this class\n@param methodName find method with this name\n@param parameterTypes find method with most compatible parameters\n@return The accessible method", "predict": " Returns a method which is semantically equal to the given method, but whose declaring class is accessible. If no such method exists, returns null. @param cls the class which declares the method @param methodName the declared name of the method @param parameterTypes the parameter types of the method @return the accessible method, or <code>null</code> if none\n*/"}
{"ID": 553, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onClientError( RequestHeader request, int statusCode, String message) { if (statusCode == 400) { return onBadRequest(request, message); } else if (statusCode == 403) { return onForbidden(request, message); } else if (statusCode == 404) { return onNotFound(request, message); } else if (statusCode >= 400 && statusCode < 500) { return onOtherClientError(request, statusCode, message); } else { throw new IllegalArgumentException( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message); } } \nResponse:", "ground_truth": "Invoked when a client error occurs, that is, an error in the 4xx series.\n\n<p>The base implementation calls onBadRequest, onForbidden, onNotFound, or onOtherClientError\ndepending on the HTTP status code.\n\n@param request The request that caused the client error.\n@param statusCode The error status code. Must be greater or equal to 400, and less than 500.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " Invoked when a 400 Bad Request status code is received from the client. The default implementation logs the error and returns a 400 Bad Request response. Subclasses may override this method to customize behavior. @param request The request object providing context, such as the request URI, refined by the matcher @param statusCode The 400 Bad Request status code @param message The 400 Bad Request message @return A CompletionStage that completes with a 400 Bad Request result\n*/"}
{"ID": 554, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.badRequest( views.html.defaultpages.badRequest.render( request.method(), request.uri(), message, request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a bad request.\n\n<p>Returns Results.badRequest (400) with the included template from {@code\nviews.html.defaultpages.badRequest} as the content.\n\n@param request The request that was bad.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling. 405 - Method Not Allowed Handling."}
{"ID": 555, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onForbidden(RequestHeader request, String message) { return CompletableFuture.completedFuture( Results.forbidden(views.html.defaultpages.unauthorized.render(request.asScala()))); } \nResponse:", "ground_truth": "Invoked when a client makes a request that was forbidden.\n\n<p>Returns Results.forbidden (401) with the included template from {@code\nviews.html.defaultpages.unauthorized} as the content.\n\n@param request The forbidden request.\n@param message The error message.\n@return a CompletionStage containing the Result.", "predict": " Render 403 Forbidden page. @param request RequestHeader @param message Message to be displayed in 403 Forbidden page. @return CompletionStage<Result> 403 Forbidden page."}
{"ID": 556, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onNotFound(RequestHeader request, String message) { if (environment.isProd()) { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.notFound.render( request.method(), request.uri(), request.asScala()))); } else { return CompletableFuture.completedFuture( Results.notFound( views.html.defaultpages.devNotFound.render( request.method(), request.uri(), Some.apply(routes.get()), request.asScala()))); } } \nResponse:", "ground_truth": "Invoked when a handler or resource is not found.\n\n<p>If the environment's mode is production, then returns Results.notFound (404) with the\nincluded template from `views.html.defaultpages.notFound` as the content.\n\n<p>Otherwise, Results.notFound (404) is rendered with {@code\nviews.html.defaultpages.devNotFound} template.\n\n@param request The request that no handler was found to handle.\n@param message A message, which is not used by the default implementation.\n@return a CompletionStage containing the Result.", "predict": " Render 404 page. @param request incoming HTTP request\n@return 404 page rendered as a CompletionStage\n*/"}
{"ID": 557, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) { try { UsefulException usefulException = throwableToUsefulException(exception); logServerError(request, usefulException); switch (environment.mode()) { case PROD: return onProdServerError(request, usefulException); default: return onDevServerError(request, usefulException); } } catch (Exception e) { logger.error(\"Error while handling error\", e); return CompletableFuture.completedFuture(Results.internalServerError()); } } \nResponse:", "ground_truth": "Invoked when a server error occurs.\n\n<p>By default, the implementation of this method delegates to [[onProdServerError()]] when in\nprod mode, and [[onDevServerError()]] in dev mode. It is recommended, if you want Play's debug\ninfo on the error page in dev mode, that you override [[onProdServerError()]] instead of this\nmethod.\n\n@param request The request that triggered the server error.\n@param exception The server error.\n@return a CompletionStage containing the Result.", "predict": " 405 Method Not Allowed"}
{"ID": 558, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void logServerError(RequestHeader request, UsefulException usefulException) { logger.error( String.format( \"\\n\\n! @%s - Internal server error, for (%s) [%s] ->\\n\", usefulException.id, request.method(), request.uri()), usefulException); } \nResponse:", "ground_truth": "Responsible for logging server errors.\n\n<p>The base implementation uses a SLF4J Logger. If a special annotation is desired for internal\nserver errors, you may want to use SLF4J directly with the Marker API to distinguish server\nerrors from application errors.\n\n<p>This can also be overridden to add additional logging information, eg. the id of the\nauthenticated user.\n\n@param request The request that triggered the server error.\n@param usefulException The server error.", "predict": " Logs server error details. UsefulException is logged as well.\n * @param request Request Header.\n * @param usefulException UsefulException.\n */"}
{"ID": 559, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final UsefulException throwableToUsefulException(final Throwable throwable) { return HttpErrorHandlerExceptions.throwableToUsefulException( sourceMapper.sourceMapper(), environment.isProd(), throwable); } \nResponse:", "ground_truth": "Convert the given exception to an exception that Play can report more information about.\n\n<p>This will generate an id for the exception, and in dev mode, will load the source code for\nthe code that threw the exception, making it possible to report on the location that the\nexception was thrown from.", "predict": " Convert a Throwable into a UsefulException. UsefulException is a subclass of Exception, so this method will happily wrap any Throwable into a UsefulException. UsefulException is Serializable so that it can survive being sent over the wire. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable so that it survives across bounces. UsefulException is immutable"}
{"ID": 560, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onDevServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.devError.render(playEditor, exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in dev mode when a server error occurs. Note that this method is where the URL set by\nplay.editor is used.\n\n<p>The base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.devError}.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " Display an error page in development mode. @param request incoming HTTP request\n@param exception Exception raised during dev server request\n@return CompletionStage<Result>\n*/"}
{"ID": 561, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CompletionStage<Result> onProdServerError( RequestHeader request, UsefulException exception) { return CompletableFuture.completedFuture( Results.internalServerError( views.html.defaultpages.error.render(exception, request.asScala()))); } \nResponse:", "ground_truth": "Invoked in prod mode when a server error occurs.\n\n<p>The base implementation returns {@code Results.internalServerError} with the content of\n{@code views.html.defaultpages.error} template.\n\n<p>Override this rather than [[onServerError()]] if you don't want to change Play's debug\noutput when logging errors in dev mode.\n\n@param request The request that triggered the error.\n@param exception The exception.\n@return a CompletionStage containing the Result.", "predict": " What happens when prod server experiences an error while serving requests. Default behaviour is to return internalServerError result. Override this method to change behaviour. @param request incoming request @param exception raised exception\n * @return CompletionStage<Result>\n */"}
{"ID": 562, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException { assert (files.length == baseDirs.length); FileRepository[] repositories = new FileRepository[files.length]; List<JarFile> jarFiles = new ArrayList<>(); for (int i = 0; i < files.length; i++) { File file = files[i]; String baseDir = baseDirs[i]; if (file.isDirectory()) { repositories[i] = new FilesystemRepository(file); } else { // Assume it's a jar file JarFile jarFile = new JarFile(file); jarFiles.add(jarFile); repositories[i] = new JarRepository(jarFile, Option.apply(baseDir)); } } return new DocumentationHandler( new AggregateFileRepository(repositories), () -> { for (JarFile jarFile : jarFiles) { jarFile.close(); } }); } \nResponse:", "ground_truth": "Create a BuildDocHandler that serves documentation from the given files, which could either be\ndirectories or jar files. The baseDir array must be the same length as the files array, and the\ncorresponding entry in there for jar files is used as a base directory to use resources from in\nthe jar.\n\n@param files The directories or jar files to serve documentation from.\n@param baseDirs The base directories for the jar files. Entries may be null.\n@return a BuildDocHandler.", "predict": " Creates a BuildDocHandler from a set of files and base directories. The files are searched in the order they are given, and the directories are searched recursively. @param files Files to search for documentation. @param baseDirs Directories to search recursively for documentation. @return DocumentationHandler for the given files and directories.\n@throws IOException Problems opening the files or directories.\n*/\npublic static BuildDocHandler fromResources(File[] files, String[] baseDirs) throws IOException {\n\tassert (files.length == baseDirs.length);\n\tFileRepository[] repositories = new FileRepository[files.length];\n\tfor (int i = 0; i < files.length; i++) {\n\t\tFile file = files[i];\n\t\tif (file.isDirectory()) {\n\t\t\trepositories[i] = new FilesystemRepository(file);\n\t\t} else { // Assume it's a jar file JarFile jarFile = new JarFile("}
{"ID": 563, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectory(File directory) { FileRepository repo = new FilesystemRepository(directory); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given directory by wrapping a\nFilesystemRepository.\n\n@param directory The directory to serve the documentation from.", "predict": " Creates a BuildDocHandler that serves documentation from the given directory. @param directory The directory to serve documentation from. @return A BuildDocHandler that serves documentation from the given directory.\n*/"}
{"ID": 564, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar(File directory, JarFile jarFile, String base) { return fromDirectoryAndJar(directory, jarFile, base, false); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Creates a BuildDocHandler from a directory and JarFile. The directory will be searched for Javadoc-generated HTML files, while the JarFile will be searched for Javadoc-generated text files. The Javadoc-generated files will be merged together into a single HTML file. The merged HTML file will be served at the following URL: base + \"/<path>\" where <path> is the relative path of the directory from the root of the JarFile. For example, if the JarFile is at \"/tmp/foo.jar\" and the directory is at \"/tmp/bar\", then the resulting HTML file will be at \"/tmp/bar/index.html\". @param directory The directory containing Javadoc-generated HTML files. @param jarFile The JarFile containing Javadoc-generated text files. @param base The base URL for serving the HTML files. @return A BuildDocHandler that serves the merged HTML files.\n"}
{"ID": 565, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromDirectoryAndJar( File directory, JarFile jarFile, String base, boolean fallbackToJar) { FileRepository fileRepo = new FilesystemRepository(directory); FileRepository jarRepo = new JarRepository(jarFile, Option.apply(base)); FileRepository manualRepo; if (fallbackToJar) { manualRepo = new AggregateFileRepository(new FileRepository[] {fileRepo, jarRepo}); } else { manualRepo = fileRepo; } return new DocumentationHandler(manualRepo, jarRepo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves the manual from a given directory by wrapping a\nFilesystemRepository, and the API docs from a given JAR file by wrapping a JarRepository.\n\n@param directory The directory to serve the documentation from.\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.\n@param fallbackToJar Whether the doc handler should fall back to the jar repo for docs.", "predict": " Creates a BuildDocHandler from a directory and JarFile. The directory will be searched first, and if not found, the JarFile will be searched. The JarFile will be searched last, and if not found, the directory will be searched. If neither directory nor JarFile contain documentation, then the fallbackToJar parameter will determine whether to search the JarFile or not. If fallbackToJar is false, then no JarFile will be searched. If fallbackToJar is true, then the JarFile will be searched regardless of whether the directory or JarFile contain documentation. @param directory The directory containing documentation. @param jarFile The JarFile containing documentation. @param base The base path to prepend to any relative paths in the documentation. @param fallbackToJar Whether to fallback to JarFile if neither directory nor JarFile contain documentation. @return A BuildDocHandler.\n"}
{"ID": 566, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BuildDocHandler fromJar(JarFile jarFile, String base) { FileRepository repo = new JarRepository(jarFile, Option.apply(base)); return new DocumentationHandler(repo); } \nResponse:", "ground_truth": "Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a\nJarRepository.\n\n@param jarFile The JAR file to server the documentation from.\n@param base The directory within the JAR file to serve the documentation from, or null if the\ndocumentation should be served from the root of the JAR.", "predict": " Creates a BuildDocHandler from a JarFile. The base directory is taken from the manifest of the jar file. @param jarFile jar file to read documentation from @param base base directory to use for relative paths in the documentation @return BuildDocHandler\n*/"}
{"ID": 567, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CompletionStage<ByteString> consumeData(Materializer mat) { return dataStream().runFold(ByteString.empty(), ByteString::concat, mat); } \nResponse:", "ground_truth": "Consumes the data.\n\n<p>This method should be used carefully, since if the source represents an ephemeral stream,\nthen the entity may not be usable after this method is invoked.\n\n@param mat the application's materializer.\n@return a CompletionStage holding the data", "predict": " Consume all remaining data from the stream. Returns a CompletionStage that completes when all data has been consumed.\n */ ImprovedByteStringConsumer::ConsumeAllData::ConsumeAllData(ImprovedByteStringConsumer* consumer) {\n  this->consumer = consumer;\n}\n\nvoid ImprovedByteStringConsumer::ConsumeAllData::accept(ByteStringConsumer* consumer) const {\n  consumer->accept(ByteString(consumer->data(), consumer->size()));\n  consumer->dataComplete();\n}\n\nvoid ImprovedByteStringConsumer::ConsumeAllData::run() const {\n  consumer->accept(this);\n}\n\n} // namespace reactivesocket\n"}
{"ID": 568, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromContent(Content content, String charset) { String body; if (content instanceof Xml) { // See https://github.com/playframework/playframework/issues/2770 body = content.body().trim(); } else { body = content.body(); } return new Strict( ByteString.fromString(body, charset), Optional.of(content.contentType() + \"; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given content.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " Creates a new strict HttpEntity from the given content. The content is trimmed before being used. @param content The content to wrap. @param charset The charset to use. @return The strict HttpEntity wrapping the content.\n*/"}
{"ID": 569, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity fromString(String content, String charset) { return new Strict( ByteString.fromString(content, charset), Optional.of(\"text/plain; charset=\" + charset)); } \nResponse:", "ground_truth": "Create an entity from the given String.\n\n@param content The content.\n@param charset The charset.\n@return the HTTP entity.", "predict": " Static factory method to create a strict HttpEntity from a string. @param content The content to be used. @param charset The charset to be used. @return The strict HttpEntity."}
{"ID": 570, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static final HttpEntity chunked(Source<ByteString, ?> data, Optional<String> contentType) { return new Chunked(data.map(HttpChunk.Chunk::new), contentType); } \nResponse:", "ground_truth": "Convert the given source of ByteStrings to a chunked entity.\n\n@param data The source.\n@param contentType The optional content type.\n@return The ByteStrings.", "predict": " Produces a framed, streamed HttpEntity with chunked Transfer-Encoding. @param data The source of the data. @param contentType The content type of the request. May be absent. @return The framed, streamed HttpEntity.\n*/"}
{"ID": 571, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content) { return status(status, content, JsonEncoding.UTF8); } \nResponse:", "ground_truth": "Generates a simple result with json content and UTF8 encoding.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content as a play-json object\n@return the result", "predict": " Generate a 204 No Content status. Useful for returning 204 status codes when 204 responses are acceptable. @param status The status code to return. @param content The content to send with the 204 status. @return 204 No Content status."}
{"ID": 572, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, JsonNode content, JsonEncoding encoding) { if (content == null) { throw new NullPointerException(\"Null content\"); } return status(status).sendJson(content, encoding); } \nResponse:", "ground_truth": "Generates a simple result with json content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a play-json object\n@param encoding the encoding into which the json should be encoded\n@return the result", "predict": " Send a JSON status 204 with optional content. @param status The status code. @param content The content. @param encoding The encoding. @return The result.\n*/"}
{"ID": 573, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, byte[] content) { if (content == null) { throw new NullPointerException(\"Null content\"); } return new Result( status, new HttpEntity.Strict(ByteString.fromArray(content), Optional.empty())); } \nResponse:", "ground_truth": "Generates a simple result with byte-array content.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the result's body content, as a byte array\n@return the result", "predict": " Creates a result with status code and content. @param status The status code. @param content The content. @return The result.\n*/"}
{"ID": 574, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, InputStream content, long contentLength) { return status(status).sendInputStream(content, contentLength); } \nResponse:", "ground_truth": "Generates a chunked result.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the input stream containing data to chunk over\n@param contentLength the length of the provided content in bytes.\n@return the result", "predict": " Send the given input stream as POST with Transfer-Encoding chunked. Useful when uploading something like a file. @param status The status code of the HTTP response @param content The input stream to send as POST, wrapped in a BufferedInputStream, @param contentLength The length of the content stream, if known beforehand @return The streamed result\n */"}
{"ID": 575, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result status(int status, File content) { return status(status, content, StaticFileMimeTypes.fileMimeTypes()); } \nResponse:", "ground_truth": "Generates a result with file contents.\n\n@param status the HTTP status for this result e.g. 200 (OK), 404 (NOT_FOUND)\n@param content the file to send\n@return the result", "predict": " Static file serving endpoint. Serving files from the local filesystem. This method serves files directly out of the local filesystem so that users can send files even when they don't have access to the web application itself. This is accomplished by looking up the file from the local filesystem. Serve other kinds of files by serving them directly out of your web application. @param status The status code to respond with. @param content The content to respond with. @return The result.\n*/"}
{"ID": 576, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private User findById(Long id) { if (id > 3) return null; User user = new User(); user.id = id; user.name = \"User \" + String.valueOf(id); return user; } \nResponse:", "ground_truth": "designed to be lightweight operation", "predict": " FindById."}
{"ID": 577, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Lang preferred(Collection<Lang> candidates) { return new Lang( langs.preferred((scala.collection.immutable.Seq) Scala.asScala(candidates).toSeq())); } \nResponse:", "ground_truth": "Select a preferred language, given the list of candidates.\n\n<p>Will select the preferred language, based on what languages are available, or return the\ndefault language if none of the candidates are available.\n\n@param candidates The candidate languages\n@return The preferred language", "predict": " Picks a preferred langauge amongst the candidates. Candidates are prioritized in the following order:\n1. Accept-Language header\n2. Accept-Charset header\n3. Locales advertised in the system properties\n4. Locales advertised in the ServletContext init parameters\n5. Locales advertised in the ServletRequest init parameters\n6. Locales advertised in the ServletContext attributes\n7. Locales advertised in the ServletRequest attributes\n8. Locales advertised in the ServletRequest parameters\n9. Locales advertised in the ServletRequest cookies\n10. Locales advertised in the ServletRequest headers\n11. Locales advertised in the ServletRequest request cookies\n12. Locales advertised in the ServletRequest request headers\n13. Locales advertised in the ServletRequest request cookies\n14. Locales advertised in the ServletRequest request headers\n15. Locales advertised in the ServletRequest request cookies\n16. Locales advertised in the ServletRequest request headers\n17. Locales advertised"}
{"ID": 578, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call unique() { return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment()); } \nResponse:", "ground_truth": "Append a unique identifier to the URL.\n\n@return a copy if this call with a unique identifier to this url", "predict": " Make a copy of this Call with a unique URL. The fragment is preserved.\n@return A copy of this Call with a unique URL.\n*/"}
{"ID": 579, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Call withFragment(String fragment) { return new play.api.mvc.Call(method(), url(), fragment); } \nResponse:", "ground_truth": "Returns a new Call with the given fragment.\n\n@param fragment the URL fragment\n@return a copy of this call that contains the fragment", "predict": " With a fragment query string. Similar to `GET /foo?bar=baz#hello`.\n@param fragment The fragment query string.\n@return A new Call with the fragment query string set.\n*/"}
{"ID": 580, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String absoluteURL(Http.Request request) { return absoluteURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an absolute URL.\n\n@param request used to identify the host and protocol that should base this absolute URL\n@return the absolute URL string", "predict": " Returns the absolute URL for the current request. Useful for generating URLs using templating systems like Mustache. @param request The HTTP request object. @return The absolute URL for the current request."}
{"ID": 581, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String webSocketURL(Http.Request request) { return webSocketURL(request.secure(), request.host()); } \nResponse:", "ground_truth": "Transform this call to an WebSocket URL.\n\n@param request used as the base for forming the WS url\n@return the websocket url string", "predict": " Return the WebSocket URL for the given request. The default implementation simply delegates to the Router's WebsocketSupport.urlFor method. However, subclasses may override this method to provide custom logic for determining the WebSocket URL. For example, this could be used to customize the WebSocket URL for a specific host. @param request The HTTP request. @return The WebSocket URL.\n*/"}
{"ID": 582, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: AbstractFunction1<Connection, BoxedUnit> connectionFunction(final ConnectionRunnable block) { return new AbstractFunction1<Connection, BoxedUnit>() { public BoxedUnit apply(Connection connection) { try { block.run(connection); return BoxedUnit.UNIT; } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection runnable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionRunnable.\n\n@param block a Java functional interface instance to wrap\n@return a scala function that wraps the given block", "predict": " Wrap a ConnectionRunnable in a Function1 that will execute it on a connection. Useful for wrapping a ConnectionRunnable in a try-with-resources statement. @param block The ConnectionRunnable to execute. @return A Function1 that wraps the ConnectionRunnable.\n*/"}
{"ID": 583, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: <A> AbstractFunction1<Connection, A> connectionFunction(final ConnectionCallable<A> block) { return new AbstractFunction1<Connection, A>() { public A apply(Connection connection) { try { return block.call(connection); } catch (java.sql.SQLException e) { throw new RuntimeException(\"Connection callable failed\", e); } } }; } \nResponse:", "ground_truth": "Create a Scala function wrapper for ConnectionCallable.\n\n@param block a Java functional interface instance to wrap\n@param <A> the provided block's return type\n@return a scala function wrapping the given block", "predict": " Wrap a Callable in a Function1 that will provide a Connection to it. Useful for ensuring that a Connection is closed properly. @param block The Callable to wrap. @return The Function1 wrapping the Callable. Never null."}
{"ID": 584, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Server forRouter(Mode mode, int port, Function<BuiltInComponents, Router> block) { return new Builder().mode(mode).http(port).build(block); } \nResponse:", "ground_truth": "Create a server for the router returned by the given block.\n\n@param block The block which creates a router.\n@param mode The mode the server will run on.\n@param port The port the server will run on.\n@return The running server.", "predict": " Creates a Server instance for Router. @param mode The Router mode. @param port The HTTP port. @param block The Router block. @return The Server instance."}
{"ID": 585, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode toJson(final Object data) { try { return mapper().valueToTree(data); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts an object to JsonNode.\n\n@param data Value to convert in Json.\n@return the JSON node.", "predict": " Convert the given POJO to a JSON document. @param data POJO to convert. @return JSON document.\n*/"}
{"ID": 586, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <A> A fromJson(JsonNode json, Class<A> clazz) { try { return mapper().treeToValue(json, clazz); } catch (Exception e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Converts a JsonNode to a Java value\n\n@param <A> the type of the return value.\n@param json Json value to convert.\n@param clazz Expected Java value type.\n@return the return value.", "predict": " Convert json to pojo. @param json json node. @param clazz pojo class. @return pojo.\n*/"}
{"ID": 587, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(String src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a String representing a json, and return it as a JsonNode.\n\n@param src the JSON string.\n@return the JSON node.", "predict": " Parses the given JSON string into a tree structure. @param src The JSON string to parse. @return The resulting tree structure."}
{"ID": 588, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonNode parse(java.io.InputStream src) { try { return mapper().readTree(src); } catch (Throwable t) { throw new RuntimeException(t); } } \nResponse:", "ground_truth": "Parses a InputStream representing a json, and return it as a JsonNode.\n\n@param src the JSON input stream.\n@return the JSON node.", "predict": " Reads a JSON document from the given InputStream. @param src The InputStream to read from. @return The root of the resulting tree.\n*/"}
{"ID": 589, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relative(String startPath, String targetPath) { // If the start and target path's are the same then link to the current directory if (startPath.equals(targetPath)) { return CURRENT_DIR; } String[] start = toSegments(canonical(startPath)); String[] target = toSegments(canonical(targetPath)); // If start path has no trailing separator (a \"file\" path), then drop file segment if (!startPath.endsWith(SEPARATOR)) start = Arrays.copyOfRange(start, 0, start.length - 1); // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = \"\"; if (!targetPath.endsWith(SEPARATOR)) { targetFile = target[target.length - 1]; target = Arrays.copyOfRange(target, 0, target.length - 1); } // Work out how much of the filepath is shared by start and path. String[] common = commonPrefix(start, target); String[] parents = toParentDirs(start.length - common.length); int relativeStartIdx = common.length; String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length); String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length); System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length); // If this is not a sibling reference append a trailing / to path String trailingSep = \"\"; if (relativePath.length > 0) trailingSep = SEPARATOR; return Arrays.stream(relativePath).collect(Collectors.joining(SEPARATOR)) + trailingSep + targetFile; } \nResponse:", "ground_truth": "Create a path to targetPath that's relative to the given startPath.", "predict": " Calculate the relative path between two paths. The relative path is calculated by chopping off the common prefix, then joining together the remaining segments. If the first path is a parent of the second path, then the relative path is simply the second path minus the common prefix. If the first path is not a parent of the second path, then the relative path is the longest common ancestor path between the two paths, minus the common prefix, plus the second path minus the common ancestor path. If the first path is identical to the second path, then the relative path is \".\". If the first path is a parent of the second path, but not identical, then the relative path is \"..\". If the first path is not a parent of the second path, but not identical, then the relative path is the longest common ancestor path between the two paths, minus the common prefix, plus the second path minus the common ancestor path. If the first path is identical to the second path, but neither is a parent, then the relative path is \"./\". If the first path"}
{"ID": 590, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String canonical(String url) { String[] urlPath = toSegments(url); Stack<String> canonical = new Stack<>(); for (String comp : urlPath) { if (comp.isEmpty() || comp.equals(CURRENT_DIR)) continue; if (!comp.equals(PARENT_DIR) || (!canonical.empty() && canonical.peek().equals(PARENT_DIR))) canonical.push(comp); else canonical.pop(); } String prefixSep = url.startsWith(SEPARATOR) ? SEPARATOR : \"\"; String trailingSep = url.endsWith(SEPARATOR) ? SEPARATOR : \"\"; return prefixSep + canonical.stream().collect(Collectors.joining(SEPARATOR)) + trailingSep; } \nResponse:", "ground_truth": "Create a canonical path that does not contain parent directories, current directories, or\nsuperfluous directory separators.", "predict": " Canonicalize the given url. The resulting url will be separated by '/' instead of '\\' @param url The url to canonicalize @return The canonicalized url\n*/"}
{"ID": 591, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Tuple<String, List<Object>>> displayableConstraint( Set<ConstraintDescriptor<?>> constraints) { return constraints .parallelStream() .filter(c -> c.getAnnotation().annotationType().isAnnotationPresent(Display.class)) .map(c -> displayableConstraint(c)) .collect(Collectors.toList()); } \nResponse:", "ground_truth": "Converts a set of constraints to human-readable values. Does not guarantee the order of the\nreturned constraints.\n\n<p>This method calls {@code displayableConstraint} under the hood.\n\n@param constraints the set of constraint descriptors.\n@return a list of pairs of tuples assembled from displayableConstraint.", "predict": " Filter constraints to only those which have a Display annotation. @param constraints The constraints to filter. @return A list of tuples containing the constraint class and displayable constraints."}
{"ID": 592, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Tuple<String, List<Object>> displayableConstraint( ConstraintDescriptor<?> constraint) { final Display displayAnnotation = constraint.getAnnotation().annotationType().getAnnotation(Display.class); return Tuple( displayAnnotation.name(), Collections.unmodifiableList( Stream.of(displayAnnotation.attributes()) .map(attr -> constraint.getAttributes().get(attr)) .collect(Collectors.toList()))); } \nResponse:", "ground_truth": "Converts a constraint to a human-readable value.\n\n@param constraint the constraint descriptor.\n@return A tuple containing the constraint's display name and the constraint attributes.", "predict": " Extracts a human readable displayable name and attributes from a constraint. Useful for debugging purposes. @param constraint constraint to extract displayable information from @return tuple containing displayable information about the constraint\n*/"}
{"ID": 593, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <A> CompletionStage<A> timeout( final CompletionStage<A> stage, final long amount, final TimeUnit unit) { requireNonNull(stage, \"Null stage\"); requireNonNull(unit, \"Null unit\"); FiniteDuration duration = FiniteDuration.apply(amount, unit); return toJava(delegate.timeout(duration, Scala.asScalaWithFuture(() -> stage))); } \nResponse:", "ground_truth": "Creates a CompletionStage that returns either the input stage, or a futures.\n\n<p>Note that timeout is not the same as cancellation. Even in case of futures, the given\ncompletion stage will still complete, even though that completed value is not returned.\n\n@param stage the input completion stage that may time out.\n@param amount The amount (expressed with the corresponding unit).\n@param unit The time Unit.\n@param <A> the completion's result type.\n@return either the completed future, or a completion stage that failed with futures.", "predict": " Timeout the given stage after the given amount of time has elapsed. @param stage The stage to timeout. @param amount The amount of time to wait. @param unit The unit of time to wait. @return The timed out stage.\n*/"}
{"ID": 594, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAssignable( Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) { if (arrayGetLength(classArray) != arrayGetLength(toClassArray)) { return false; } if (classArray == null) { classArray = EMPTY_CLASS_ARRAY; } if (toClassArray == null) { toClassArray = EMPTY_CLASS_ARRAY; } for (int i = 0; i < classArray.length; i++) { if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) { return false; } } return true; } \nResponse:", "ground_truth": "Checks if an array of Classes can be assigned to another array of Classes.\n\n<p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each Class pair in\nthe input arrays. It can be used to check if a set of arguments (the first parameter) are\nsuitably compatible with a set of method parameter types (the second parameter).\n\n<p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this method takes into\naccount widenings of primitive classes and {@code null}s.\n\n<p>Primitive widenings allow an int to be assigned to a {@code long}, {@code float} or {@code\ndouble}. This method returns the correct result for these cases.\n\n<p>{@code Null} may be assigned to any reference type. This method will return {@code true} if\n{@code null} is passed in and the toClass is non-primitive.\n\n<p>Specifically, this method tests whether the type represented by the specified {@code Class}\nparameter can be converted to the type represented by this {@code Class} object via an identity\nconversion widening primitive or widening reference conversion. See <em><a\nhref=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>, sections\n5.1.1, 5.1.2 and 5.1.4 for details.\n\n@param classArray the array of Classes to check, may be {@code null}\n@param toClassArray the array of Classes to try to assign into, may be {@code null}\n@param autoboxing whether to use implicit autoboxing/unboxing between primitives and wrappers\n@return {@code true} if assignment possible", "predict": " Determine whether or not a class can be assigned to another class. This is primarily useful for determining assignability in the context of generics. @param classArray the array of Classes to check @param toClassArray the array of Classes to try to assign into @param autoboxing indicates whether or not autoboxing should be considered when determining assignability @return true if the classes can be assigned, false otherwise\n*/"}
{"ID": 595, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Date parseCRONExpression(String cron) { try { return new CronExpression(cron).getNextValidTimeAfter(new Date()); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Parses a CRON expression.\n\n@param cron the CRON String\n@return the next <code>Date</code> that satisfies the expression", "predict": " Parses a CRON expression and returns the next time in milliseconds after 1970-01-01T00:00:00Z that CRON will be valid. @param cron expression @return time in milliseconds after 1970-01-01T00:00:00Z that CRON will be valid\n*/"}
{"ID": 596, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long cronInterval(String cron, Date date) { try { return new CronExpression(cron).getNextInterval(date); } catch (Exception e) { throw new IllegalArgumentException(\"Invalid CRON pattern : \" + cron, e); } } \nResponse:", "ground_truth": "Compute the number of milliseconds between the next valid date and the one after.\n\n@param cron the CRON String\n@param date the date to start search\n@return the number of milliseconds between the next valid date and the one after, with an\ninvalid interval between", "predict": " Calculates the next interval for the given CRON pattern and date. The calculation is performed using the Quartz cron scheduling algorithm. @param cron Cron pattern to calculate the next interval for. @param date Date to calculate the next interval for. @return Next interval for the given CRON pattern and date.\n */"}
{"ID": 597, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AhcWSClient create( AhcWSClientConfig config, AhcHttpCache cache, Materializer materializer) { final StandaloneAhcWSClient client = StandaloneAhcWSClient.create(config, cache, materializer); return new AhcWSClient(client, materializer); } \nResponse:", "ground_truth": "Creates WS client manually from configuration, internally creating a new instance of\nAsyncHttpClient and managing its own thread pool.\n\n<p>This client is not managed as part of Play's lifecycle, and <b>must</b> be closed by calling\nws.close(), otherwise you will run into memory leaks.\n\n@param config a config object, usually from AhcWSClientConfigFactory\n@param cache if not null, provides HTTP caching.\n@param materializer an Akka materializer\n@return a new instance of AhcWSClient.", "predict": " StandaloneAhcWSClient is thread safe, so we can safely reuse it across requests. However, we can't reuse the AhcHttpCache because it's tied to a specific AhcWSClient instance. Therefore, we create a StandaloneAhcWSClient for each AhcWSClient instance.\n */"}
{"ID": 598, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder builder(ApplicationLoader.Context context) { return initialBuilder .in(context.environment()) .loadConfig(context.initialConfig()) .overrides(overrides(context)); } \nResponse:", "ground_truth": "Construct a builder to use for loading the given context.\n\n@param context the context the returned builder will load\n@return the builder", "predict": " Allows injecting dependencies into the bootstrap process. Useful for dependency injection frameworks. @param context The application context. @return The builder."}
{"ID": 599, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Result TODO(Request request) { return status(NOT_IMPLEMENTED, views.html.defaultpages.todo.render(request.asScala())); } \nResponse:", "ground_truth": "Generates a 501 NOT_IMPLEMENTED simple result.", "predict": " Render a simple thank you page. @param request The HTTP request. @return 200 OK with thank you page."}
{"ID": 600, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void session(String key, String value) { session().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the current session.\n\n@param key the key to set into the session\n@param value the value to set for <code>key</code>\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " Deprecated alias for put(key, value). Kept around for backward compatibility. @param key The key to store the value under. @param value The value to store. @deprecated Use put(key, value) instead. Kept around for backward compatibility."}
{"ID": 601, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static void flash(String key, String value) { flash().put(key, value); } \nResponse:", "ground_truth": "Puts a new value into the flash scope.\n\n@param key the key to put into the flash scope\n@param value the value corresponding to <code>key</code>\n@deprecated Deprecated as of 2.7.0. Use {@link Result} instead.", "predict": " Flash a flash cookie. Flash cookies have a maxAge of 0, forcing them to be discarded at the end of the browser session. Flash cookies are not HTTPOnly. @param key The flash cookie key. @param value The flash cookie value. @deprecated Use flash().put(key, value) instead.\n*/"}
{"ID": 602, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final A instance) { return underlying.qualifiedWith(instance).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given instance of an annotation.\n\n<p>This can be used to specify bindings with annotations that have particular values.", "predict": " Qualify this binding key with a qualifier annotation. @param instance The qualifier annotation. @param <A> The qualifier annotation type. @return A new binding key qualified with the qualifier annotation. Never null."}
{"ID": 603, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends Annotation> BindingKey<T> qualifiedWith(final Class<A> annotation) { return underlying.qualifiedWith(annotation).asJava(); } \nResponse:", "ground_truth": "Qualify this binding key with the given annotation.\n\n<p>For example, you may have both a cached implementation, and a direct implementation of a\nservice. To differentiate between them, you may define a Cached annotation:\n\n<pre>{@code\nbindClass(Foo.class).qualifiedWith(Cached.class).to(FooCached.class),\nbindClass(Foo.class).to(FooImpl.class)\n\n...\n\nclass MyController {\n{@literal @}Inject\nMyController({@literal @}Cached Foo foo) {\n...\n}\n...\n}\n}</pre>\n\nIn the above example, the controller will get the cached {@code Foo} service.", "predict": " Qualifies the binding key with an annotation. @param annotation The annotation to qualify the binding key with. @return A binding key qualified with the given annotation. Never null.\n*/"}
{"ID": 604, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Class<? extends T> implementation) { return underlying.to(implementation).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given implementation class.\n\n<p>This class will be instantiated and injected by the injection framework.", "predict": " Instruct the fluent builders to manufacture instances of the generic type T using the supplied Class<? extends T> as the instantiation strategy. Construction will occur using reflection. @param implementation The Class<? extends T> to use in lieu of generating generic types. @return Fluent Builder referencing this binding. Useful for method chaining.\n*/"}
{"ID": 605, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final Provider<? extends T> provider) { return underlying.to(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider instance.\n\n<p>This provider instance will be invoked to obtain the implementation for the key.", "predict": " Instruct subsequent injections to interpret their bound value as coming from this particular provider. Useful for injecting Providers that you don't trust to originate from your library. @param provider Provider to enforce. @return Fluent API for chaining. Never returns {@code null}.\n*/"}
{"ID": 606, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends T> Binding<T> to(final Supplier<A> instance) { return underlying.to(new FromJavaSupplier<>(instance)).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given instance.", "predict": " Fluent API shortcut for bridging to suppliers. @param <A> generic type of suppliers' return value. @param instance Supplier to be bridged. @return Binding of suppliers' return value."}
{"ID": 607, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Binding<T> to(final BindingKey<? extends T> key) { return underlying.to(key.asScala()).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to another binding key.", "predict": " Associates the current Binding with a different BindingKey. This is a shortcut for casting.\n@param key The new BindingKey.\n@return The Binding associated with the new BindingKey.\n*/"}
{"ID": 608, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <P extends Provider<? extends T>> Binding<T> toProvider(final Class<P> provider) { return underlying.toProvider(provider).asJava(); } \nResponse:", "ground_truth": "Bind this binding key to the given provider class.\n\n<p>The dependency injection framework will instantiate and inject this provider, and then\ninvoke its `get` method whenever an instance of the class is needed.", "predict": " Convert this type to a Provider type. @param provider The provider type. @return A fluent API binding reflecting this type.\n*/"}
{"ID": 609, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<Lang> availables(Application app) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); List<play.api.i18n.Lang> availableLangs = Scala.asJava(langs.availables()); return availableLangs.stream().map(Lang::new).collect(toList()); } \nResponse:", "ground_truth": "Retrieve Lang availables from the application configuration.\n\n@param app the current application.\n@return the list of available Lang.", "predict": " List all available languages. Useful for debugging purpose.\n@param app The Play application.\n@return List of available languages.\n*/"}
{"ID": 610, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Lang preferred(Application app, List<Lang> availableLangs) { play.api.i18n.Langs langs = app.injector().instanceOf(play.api.i18n.Langs.class); Stream<Lang> stream = availableLangs.stream(); List<play.api.i18n.Lang> langSeq = stream.map(l -> new play.api.i18n.Lang(l.toLocale())).collect(toList()); return new Lang(langs.preferred(Scala.toSeq(langSeq))); } \nResponse:", "ground_truth": "Guess the preferred lang in the langs set passed as argument. The first Lang that matches an\navailable Lang wins, otherwise returns the first Lang available in this application.\n\n@param app the currept application\n@param availableLangs the set of langs from which to guess the preferred\n@return the preferred lang.", "predict": " Select the preferred langauge for the application.\nThe preferred langauge is the first langauge in the list of available languages.\nThe list of available languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is determined by looking up the languages in the Play installation directory.\nThe list of languages is"}
{"ID": 611, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader fromMap( Map<String, List<Evolution>> evolutions) { return new SimpleEvolutionsReader(evolutions); } \nResponse:", "ground_truth": "Create an evolutions reader based on a simple map of database names to evolutions.\n\n@param evolutions The map of database names to evolutions.\n@return the evolutions reader.", "predict": " Create an EvolutionsReader from a map of evolution names to evolution lists.\nThe evolution list is a list of evolution steps. Each evolution step is a map of evolution key to evolution value. Evolution keys are:\n- \"table\": evolution step table name\n- \"columns\": evolution step columns\n- \"values\": evolution step values\n- \"foreignKey\": evolution step foreign key constraint name\n- \"foreignKeyColumns\": evolution step foreign key constraint columns\n- \"foreignKeyUpdateRule\": evolution step foreign key constraint update rule\n- \"foreignKeyDeleteRule\": evolution step foreign key constraint delete rule\n- \"index\": evolution step index name\n- \"unique\": evolution step unique constraint name\n- \"uniqueColumns\": evolution step unique constraint columns\n- \"uniqueUpdateRule\": evolution step unique constraint update rule\n- \"uniqueDeleteRule\": evolution step unique constraint delete rule\n- \"foreignKeyInitiallyDeferred\": evolution step foreign key constraint initially deferred\n- \"foreignKeyInitiallyImmediate\": evolution step foreign key constraint initially immediate\n-"}
{"ID": 612, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static play.api.db.evolutions.EvolutionsReader forDefault(Evolution... evolutions) { Map<String, List<Evolution>> map = new HashMap<String, List<Evolution>>(); map.put(\"default\", Arrays.asList(evolutions)); return fromMap(map); } \nResponse:", "ground_truth": "Create an evolutions reader for the default database from a list of evolutions.\n\n@param evolutions The list of evolutions.\n@return the evolutions reader.", "predict": " Create an EvolutionsReader for the default evolution strategy. @param evolutions evolution steps\nreturned by the evolution framework\n*/"}
{"ID": 613, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cleanupEvolutions(Database database, boolean autocommit, String schema) { DatabaseEvolutions evolutions = new DatabaseEvolutions(database.asScala(), schema); evolutions.evolve(evolutions.resetScripts(), autocommit); } \nResponse:", "ground_truth": "Cleanup evolutions for the given database.\n\n<p>This will run the down scripts for all the applied evolutions.\n\n@param database The database to apply the evolutions to.\n@param autocommit Whether autocommit should be used.\n@param schema The schema where all the play evolution tables are saved in", "predict": " Drops outdated evolution scripts from the database. Drops evolution scripts older than 30 days. Drops evolution scripts older than 90 days if autocommit is disabled. Drops evolution scripts older than 365 days if autocommit is enabled. Drops evolution scripts older than 540 days if autocommit is disabled and schema is not equal to \"public\". Drops evolution scripts older than 900 days if autocommit is enabled and schema is not equal to \"public\". Drops evolution scripts older than 1890 days if autocommit is disabled and schema is equal to \"public\". Drops evolution scripts older than 3600 days if autocommit is enabled and schema is equal to \"public\". Drops evolution scripts older than 3660 days if autocommit is disabled and schema is equal to \"public\". Drops evolution scripts older than 3720 days if autocommit is enabled and schema is equal to \"public\". Drops evolution scripts older than 3780 days if autocommit is disabled and schema is equal to \"public\". Drops evolution scripts older than 3840 days if aut"}
{"ID": 614, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withConfigLoader(Function<Environment, Config> load) { return newBuilder( delegate.loadConfig( func( (play.api.Environment env) -> new play.api.Configuration(load.apply(new Environment(env)))))); } \nResponse:", "ground_truth": "Set the initial configuration loader. Overrides the default or any previously configured\nvalues.\n\n@param load the configuration loader\n@return the configured application builder", "predict": " Supply a custom config loader. @param load The custom loader. @return The builder.\n*/"}
{"ID": 615, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder withModuleLoader( BiFunction<Environment, Config, List<GuiceableModule>> loader) { return newBuilder( delegate.load( func( (play.api.Environment env, play.api.Configuration conf) -> Scala.toSeq(loader.apply(new Environment(env), conf.underlying()))))); } \nResponse:", "ground_truth": "Set the module loader. Overrides the default or any previously configured values.\n\n@param loader the configuration\n@return the configured application builder", "predict": " Allows injecting a custom Guice ModuleLoader. @param loader The Guice ModuleLoader to use. @return The Builder, for further configuration.\n*/"}
{"ID": 616, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(GuiceableModule... modules) { return newBuilder(delegate.load(Scala.varargs(modules))); } \nResponse:", "ground_truth": "Override the module loader with the given guiceable modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Loads several modules sequentially. Useful for injecting dependencies into your GuiceBerry configuration. @param modules The modules to load sequentially. @return A new builder that loads the modules sequentially.\n */ Lifetime of this builder is tied to the lifetime of your application."}
{"ID": 617, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(com.google.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Guice modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Load modules from a variety of sources. @param modules Modules to load. @return Fluent Builder.\n*/"}
{"ID": 618, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Module... modules) { return load(Guiceable.modules(modules)); } \nResponse:", "ground_truth": "Override the module loader with the given Play modules.\n\n@param modules the set of overriding modules\n@return an application builder that incorporates the overrides", "predict": " Load Guice modules from Play modules. @param modules Play modules to load. @return Fluent DSL.\n*/"}
{"ID": 619, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public GuiceApplicationBuilder load(play.api.inject.Binding<?>... bindings) { return load(Guiceable.bindings(bindings)); } \nResponse:", "ground_truth": "Override the module loader with the given Play bindings.\n\n@param bindings the set of binding override\n@return an application builder that incorporates the overrides", "predict": " Load Guice bindings from Play bindings. @param bindings bindings to load\n * @return this builder\n*/"}
{"ID": 620, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected GuiceApplicationBuilder newBuilder( play.api.inject.guice.GuiceApplicationBuilder builder) { return new GuiceApplicationBuilder(builder); } \nResponse:", "ground_truth": "Implementation of Self creation for GuiceBuilder.\n\n@return the application builder", "predict": " Override this method to change how GuiceApplicationBuilder is created.\nThe default implementation simply delegates to the Play GuiceApplicationBuilder.\n@param builder Play GuiceApplicationBuilder\n@return GuiceApplicationBuilder\n*/"}
{"ID": 621, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } StringBuilder buf = new StringBuilder(); encode(buf, cookie); return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Cookie header value.\n\n@param cookie specified the cookie\n@return a Rfc6265 style Cookie header value", "predict": " Encodes the cookie into a Cookie header format. The resulting string can be used as the value of the Cookie header. @param cookie Cookie to encode. @return the encoded cookie header string.\n**/\npublic String encode(Cookie cookie) {\n\tif (cookie == null) throw new NullPointerException(\"cookie\");\n\tStringBuilder buf = new StringBuilder();\n\tencode(buf, cookie);\n\treturn stripTrailingSeparator(buf);\n}\n/**\n * Encodes the cookie into a Cookie header format. The resulting string can be used as the value of the Cookie header. @param cookie Cookie to encode. @return the encoded cookie header string.\n**/\npublic String encode(Cookie cookie, char separator) {\n\tif (cookie == null) throw new NullPointerException(\"cookie\");\n\tStringBuilder buf = new StringBuilder();\n\tencode(buf, cookie, separator);\n\treturn stripTrailingSeparator(buf);\n}\n"}
{"ID": 622, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EntityManager em() { Deque<EntityManager> ems = this.emStack(true); if (ems.isEmpty()) { Http.Context.safeCurrent() .map( ctx -> { throw new RuntimeException( \"No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional\"); }) .orElseGet( () -> { throw new RuntimeException( \"No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread.\"); }); } return ems.peekFirst(); } \nResponse:", "ground_truth": "Get the default EntityManager for this thread.\n\n@throws RuntimeException if no EntityManager is bound to the current Http.Context or the\ncurrent Thread.\n@return the EntityManager", "predict": " Obtain the EntityManager bound to this thread. This is useful for obtaining JPA entities. @return The EntityManager bound to this thread.\n*/"}
{"ID": 623, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Deque<EntityManager> emStack(boolean threadLocalFallback) { return Http.Context.safeCurrent() .map( context -> { Object emsObject = context.args.get(CURRENT_ENTITY_MANAGER); if (emsObject != null) { return (Deque<EntityManager>) emsObject; } else { Deque<EntityManager> ems = new ArrayDeque<>(); context.args.put(CURRENT_ENTITY_MANAGER, ems); return ems; } }) .orElseGet( () -> { // Not a web request if (threadLocalFallback) { return this.get(); } else { throw new RuntimeException( \"No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead.\"); } }); } \nResponse:", "ground_truth": "Get the EntityManager stack.\n\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.\n@return the queue of entity managers.", "predict": " Get the stack of EntityManagers. Useful for suspending transactions and rolling them back. Useful for suspending transactions and rolling them back. @param threadLocalFallback If true, resorts to the ThreadLocal approach if there is no Http.Context present. Useful for testing purposes. @return Stack of EntityManagers. Empty stack if none are present."}
{"ID": 624, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void pushOrPopEm(EntityManager em, boolean threadLocalFallback) { Deque<EntityManager> ems = this.emStack(threadLocalFallback); if (em != null) { ems.push(em); } else { if (ems.isEmpty()) { throw new IllegalStateException(\"Tried to remove the EntityManager, but none was set.\"); } ems.pop(); } } \nResponse:", "ground_truth": "Pushes or pops the EntityManager stack depending on the value of the em argument. If em is\nnull, then the current EntityManager is popped. If em is non-null, then em is pushed onto the\nstack and becomes the current EntityManager.\n\n@param em the entity manager to push, if null then will pop one off the stack.\n@param threadLocalFallback if true, fall back to a ThreadLocal queue of entity managers if no\nHTTP.Context object is found.", "predict": " Pushes or pops an EntityManager onto the stack. If none is set, and the stack is empty, then IllegalStateException is thrown. If the EntityManager is popped, it is released. If the EntityManager is pushed, it is acquired. If threadLocalFallback is true, then the EntityManager is acquired from the ThreadLocal. Otherwise, the EntityManager is acquired from the ThreadLocal iff the stack is empty. @param em The EntityManager to push or pop onto the stack. May be null. @param threadLocalFallback Whether to fallback to acquiring the EntityManager from the ThreadLocal. If false, then the EntityManager is acquired from the ThreadLocal only iff the stack is empty. If true, then the EntityManager is acquired from the ThreadLocal regardless of whether or not the stack is empty."}
{"ID": 625, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Function<In, F.Either<FlowIn, Out>> splitter, Flow<FlowIn, Out, ?> flow) { return bypassWith( Flow.<In>create().map(splitter::apply), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), flow); } \nResponse:", "ground_truth": "Bypass the given flow using the given splitter function.\n\n<p>If the splitter function returns Left, they will go through the flow. If it returns Right,\nthey will bypass the flow.\n\n<p>Uses onlyFirstCanFinishMerge(2) by default.\n\n@param <In> the In type parameter for Flow\n@param <FlowIn> the FlowIn type parameter for the left branch in Either.\n@param <Out> the Out type parameter for Flow\n@param flow the original flow\n@param splitter the splitter function to use\n@return the flow with a bypass.", "predict": " Turns a pure function into a pure function by piping through a fan-in intermediate Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own order but doesn't preserve the order of the input Flow. The fan-in intermediate Flow preserves its own"}
{"ID": 626, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, FlowIn, Out> Flow<In, Out, ?> bypassWith( Flow<In, F.Either<FlowIn, Out>, ?> splitter, Graph<UniformFanInShape<Out, Out>, ?> mergeStrategy, Flow<FlowIn, Out, ?> flow) { return splitter.via( Flow.fromGraph( GraphDSL.<FlowShape<F.Either<FlowIn, Out>, Out>>create( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>> broadcast = builder.add(Broadcast.create(2, true)); UniformFanInShape<Out, Out> merge = builder.add(mergeStrategy); Flow<F.Either<FlowIn, Out>, FlowIn, ?> collectIn = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.left.isPresent()) { return x.left.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, Out, ?> collectOut = Flow.<F.Either<FlowIn, Out>>create() .collect( Scala.partialFunction( x -> { if (x.right.isPresent()) { return x.right.get(); } else { throw Scala.noMatch(); } })); Flow<F.Either<FlowIn, Out>, F.Either<FlowIn, Out>, ?> blockCancel = play.api.libs.streams.AkkaStreams .<F.Either<FlowIn, Out>>ignoreAfterCancellation() .asJava(); // Normal flow builder .from(broadcast.out(0)) .via(builder.add(collectIn)) .via(builder.add(flow)) .toInlet(merge.in(0)); // Bypass flow, need to ignore downstream finish builder .from(broadcast.out(1)) .via(builder.add(blockCancel)) .via(builder.add(collectOut)) .toInlet(merge.in(1)); return new FlowShape<>(broadcast.in(), merge.out()); }))); } \nResponse:", "ground_truth": "Using the given splitter flow, allow messages to bypass a flow.\n\n<p>If the splitter flow produces Left, they will be fed into the flow. If it produces Right,\nthey will bypass the flow.\n\n@param <In> the In type parameter for Flow\n@param <FlowIn> the FlowIn type parameter for the left branch in Either.\n@param <Out> the Out type parameter for Flow.\n@param flow the original flow.\n@param splitter the splitter function.\n@param mergeStrategy the merge strategy (onlyFirstCanFinishMerge, ignoreAfterFinish,\nignoreAfterCancellation)\n@return the flow with a bypass.", "predict": " Bypasses the given flow with the given shape using the given merge strategy. The merge strategy must be a fan-in shape. The shape must be a fan-out shape. The shape must be connected to the merge strategy. The shape must be connected to the flow. The shape must be connected to the bypasser. The shape must be connected to the collector. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to the merger. The shape must be connected to"}
{"ID": 627, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> Flow<In, Out, ?> actorRef( Function<ActorRef, Props> props, int bufferSize, OverflowStrategy overflowStrategy, ActorRefFactory factory, Materializer mat) { return play.api.libs.streams.ActorFlow.<In, Out>actorRef( new AbstractFunction1<ActorRef, Props>() { @Override public Props apply(ActorRef v1) { return props.apply(v1); } }, bufferSize, overflowStrategy, factory, mat) .asJava(); } \nResponse:", "ground_truth": "Create a flow that is handled by an actor.\n\n<p>Messages can be sent downstream by sending them to the actor passed into the props function.\nThis actor meets the contract of the actor returned by {@link\nakka.stream.javadsl.Source#actorRef}.\n\n<p>The props function should return the props for an actor to handle the flow. This actor will\nbe created using the passed in {@link akka.actor.ActorRefFactory}. Each message received will\nbe sent to the actor - there is no back pressure, if the actor is unable to process the\nmessages, they will queue up in the actors mailbox. The upstream can be cancelled by the actor\nterminating itself.\n\n@param <In> the In type parameter for a Flow\n@param <Out> the Out type parameter for a Flow\n@param props A function that creates the props for actor to handle the flow.\n@param bufferSize The maximum number of elements to buffer.\n@param overflowStrategy The strategy for how to handle a buffer overflow.\n@param factory The Actor Factory used to create the actor to handle the flow - for example, an\nActorSystem.\n@param mat The materializer to materialize the flow.\n@return the flow itself.", "predict": " Create an ActorFlow backed by an Akka actor. The actor receives a Props object describing the actor type and any dependencies. The actor is instantiated using the supplied ActorRefFactory. The actor receives a Flow.overflowStrategy describing how overruns are handled. The actor receives a Materializer to facilitate testing. The actor receives a bufferSize describing how much data to buffer before blocking producers. The actor receives a mat ActorRef describing the ActorSystem actor to use. The actor receives a mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef describing the OverflowStrategy actor to use. The actor receives the mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef describing the ActorRefFactory actor to use. The actor receives the mat ActorRef"}
{"ID": 628, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private List<Object> convertErrorArguments(Object[] arguments) { if (arguments == null) { return Collections.emptyList(); } List<Object> converted = Arrays.stream(arguments) .filter( arg -> !(arg instanceof org.springframework.context.support.DefaultMessageSourceResolvable)) .collect(Collectors.toList()); return Collections.unmodifiableList(converted); } \nResponse:", "ground_truth": "Convert the error arguments.\n\n@param arguments The arguments to convert.\n@return The converted arguments.", "predict": " Convert error arguments to Spring friendly ones. @param arguments arguments to convert. @return converted arguments.\n*/"}
{"ID": 629, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Form<T> fill(T value) { if (value == null) { throw new RuntimeException(\"Cannot fill a form with a null value\"); } return new Form<>( rootName, backedType, new HashMap<>(), new HashMap<>(), new ArrayList<>(), Optional.ofNullable(value), groups, messagesApi, formatters, validatorFactory, config, lang, directFieldAccess); } \nResponse:", "ground_truth": "Populates this form with an existing value, used for edit forms.\n\n@param value existing value of type <code>T</code> used to fill this form\n@return a copy of this form filled with the new data", "predict": " Fills the form with a value. The value must be assignable to the backing type. @param value The value to fill the form with. May be null. @return The filled form. Never null."}
{"ID": 630, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<ValidationError> globalErrors() { return Collections.unmodifiableList( errors.stream().filter(error -> error.key().isEmpty()).collect(Collectors.toList())); } \nResponse:", "ground_truth": "Retrieve all global errors - errors without a key.\n\n@return All global errors.", "predict": " Returns all global errors. Global errors are errors that are not tied to any specific field. They are displayed at the top of the form regardless of any errors on individual fields. Global errors are displayed in the order they were added. @return List of ValidationErrors\n*/"}
{"ID": 631, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonNode errorsAsJson(Lang lang) { Map<String, List<String>> allMessages = new HashMap<>(); errors.forEach( error -> { if (error != null) { final List<String> messages = new ArrayList<>(); if (messagesApi != null && lang != null) { final List<String> reversedMessages = new ArrayList<>(error.messages()); Collections.reverse(reversedMessages); messages.add( messagesApi.get( lang, reversedMessages, translateMsgArg(error.arguments(), messagesApi, lang))); } else { messages.add(error.message()); } allMessages.put(error.key(), messages); } }); return play.libs.Json.toJson(allMessages); } \nResponse:", "ground_truth": "Returns the form errors serialized as Json using the given Lang.\n\n@param lang the language to use.\n@return the JSON node containing the errors.", "predict": " Retrieve all errors as a json structure. Useful for AngularJS. @param lang The language to use to translate error messages. @return The errors as a json structure.\n*/\npublic JsonNode errorsAsJson(Lang lang) {\n\treturn play.libs.Json.toJson(errorsAsJsonMap(lang));\n}\n\n/** Retrieve all errors as a json structure. Useful for AngularJS. @param lang The language to use to translate error messages. @return The errors as a json structure.\n*/"}
{"ID": 632, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Optional<Object> value(String key) { return super.value().map(v -> v.getData().get(asNormalKey(key))); } \nResponse:", "ground_truth": "Gets the concrete value\n\n@param key the string key.\n@return the value", "predict": " Get the value of a key in the multimap. The key must exist. @param key The key whose value to retrieve. @return The value of the key. Will be absent if the key does not exist."}
{"ID": 633, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DynamicForm fill(Map<String, Object> value) { Form<Dynamic> form = super.fill(new Dynamic(value)); return new DynamicForm( form.rawData(), form.files(), form.errors(), form.value(), messagesApi, formatters, validatorFactory, config, lang().orElse(null)); } \nResponse:", "ground_truth": "Fills the form with existing data.\n\n@param value the map of values to fill in the form.\n@return the modified form.", "predict": " Fills the DynamicForm with the provided Map. @param value The Map to use to fill the DynamicForm. @return The DynamicForm filled with the provided Map."}
{"ID": 634, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T parse(String text, Class<T> clazz) { return conversion.convert(text, clazz); } \nResponse:", "ground_truth": "Parses this string as instance of the given class.\n\n@param text the text to parse\n@param clazz class representing the required type\n@param <T> the type to parse out of the text\n@return the parsed value", "predict": " Convert the given text to the given type. @param text The text to convert. @param clazz The type to convert to. @return The converted text.\n*/"}
{"ID": 635, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T parse(Field field, String text) { return (T) conversion.convert(text, new TypeDescriptor(field)); } \nResponse:", "ground_truth": "Parses this string as instance of a specific field\n\n@param field the related field (custom formatters are extracted from this field annotation)\n@param text the text to parse\n@param <T> the type to parse out of the text\n@return the parsed value", "predict": " Convert the given text to the given field type. @param field The field to convert to. @param text The text to convert. @return The converted text.\n*/"}
{"ID": 636, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(T t) { if (t == null) { return \"\"; } if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value.\n\n@param t the value to print\n@param <T> the type to print\n@return the formatted string", "predict": " Prints the given object to a string using the configured converter. @param t The object to print. @return The string representation of the given object."}
{"ID": 637, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(Field field, T t) { return print(new TypeDescriptor(field), t); } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific field.\n\n@param field the related field - custom formatters are extracted from this field annotation\n@param t the value to print\n@param <T> the type to print\n@return the formatted string", "predict": " Prints the value of the field of the given object. @param field The field whose value is printed. @param t The object whose field is printed. @return The printed value.\n*/"}
{"ID": 638, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> String print(TypeDescriptor desc, T t) { if (t == null) { return \"\"; } if (desc != null && conversion.canConvert(desc, TypeDescriptor.valueOf(String.class))) { return (String) conversion.convert(t, desc, TypeDescriptor.valueOf(String.class)); } else if (conversion.canConvert(t.getClass(), String.class)) { return conversion.convert(t, String.class); } else { return t.toString(); } } \nResponse:", "ground_truth": "Computes the display string for any value, for a specific type.\n\n@param desc the field descriptor - custom formatters are extracted from this descriptor.\n@param t the value to print\n@param <T> the type to print\n@return the formatted string", "predict": " Prints the given object to a string using the configured converter. @param desc The type descriptor of the desired return type. @param t The object to print. @return The string representation of the given object.\n*/"}
{"ID": 639, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Formatters registerOptional() { conversion.addConverter( new GenericConverter() { public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { if (sourceType.getObjectType().equals(String.class)) { // From String to Optional Object element = conversion.convert(source, sourceType, targetType.elementTypeDescriptor(source)); return Optional.ofNullable(element); } else if (targetType.getObjectType().equals(String.class)) { // From Optional to String if (source == null) return \"\"; Optional<?> opt = (Optional) source; return opt.map( o -> conversion.convert( source, sourceType.getElementTypeDescriptor(), targetType)) .orElse(\"\"); } return null; } public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<ConvertiblePair> result = new HashSet<>(); result.add(new ConvertiblePair(Optional.class, String.class)); result.add(new ConvertiblePair(String.class, Optional.class)); return result; } }); return this; } \nResponse:", "ground_truth": "Converter for String -> Optional and Optional -> String", "predict": " Register converter for Optional types."}
{"ID": 640, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> Formatters register(final Class<T> clazz, final SimpleFormatter<T> formatter) { conversion.addFormatterForFieldType( clazz, new org.springframework.format.Formatter<T>() { public T parse(String text, Locale locale) throws java.text.ParseException { return formatter.parse(text, locale); } public String print(T t, Locale locale) { return formatter.print(t, locale); } public String toString() { return formatter.toString(); } }); return this; } \nResponse:", "ground_truth": "Registers a simple formatter.\n\n@param clazz class handled by this formatter\n@param <T> the type that this formatter will parse and print\n@param formatter the formatter to register\n@return the modified Formatters object.", "predict": " Register a formatter for a specific field type. @param clazz The field type to register the formatter for. @param formatter The formatter to register. @return This Formatters instance.\n*/"}
{"ID": 641, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <A extends Annotation, T> Formatters register( final Class<T> clazz, final AnnotationFormatter<A, T> formatter) { final Class<? extends Annotation> annotationType = (Class<? extends Annotation>) GenericTypeResolver.resolveTypeArguments( formatter.getClass(), AnnotationFormatter.class)[0]; conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(clazz, String.class)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (sourceType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) sourceType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.print(a, (T) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return \"@\" + annotationType.getName() + \" \" + clazz.getName() + \" -> \" + String.class.getName() + \": \" + formatter; } }); conversion.addConverter( new ConditionalGenericConverter() { public Set<GenericConverter.ConvertiblePair> getConvertibleTypes() { Set<GenericConverter.ConvertiblePair> types = new HashSet<>(); types.add(new GenericConverter.ConvertiblePair(String.class, clazz)); return types; } public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) { return (targetType.getAnnotation(annotationType) != null); } public Object convert( Object source, TypeDescriptor sourceType, TypeDescriptor targetType) { final A a = (A) targetType.getAnnotation(annotationType); Locale locale = LocaleContextHolder.getLocale(); try { return formatter.parse(a, (String) source, locale); } catch (Exception ex) { throw new ConversionFailedException(sourceType, targetType, source, ex); } } public String toString() { return String.class.getName() + \" -> @\" + annotationType.getName() + \" \" + clazz.getName() + \": \" + formatter; } }); return this; } \nResponse:", "ground_truth": "Registers an annotation-based formatter.\n\n@param clazz class handled by this formatter\n@param formatter the formatter to register\n@param <A> the annotation type\n@param <T> the type that will be parsed or printed\n@return the modified Formatters object.", "predict": " Register a converter for a specific annotation. @param clazz the annotation class to register the converter for. @param formatter the converter to register. @param <A> the annotation type. @param <T> the annotation's type. @return this, fluent API.\n*/"}
{"ID": 642, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encode(Cookie cookie) { if (cookie == null) { throw new NullPointerException(\"cookie\"); } final String name = cookie.name(); final String value = cookie.value() != null ? cookie.value() : \"\"; validateCookie(name, value); StringBuilder buf = new StringBuilder(); if (cookie.wrap()) { addQuoted(buf, name, value); } else { add(buf, name, value); } if (cookie.maxAge() != Integer.MIN_VALUE) { add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge()); Date expires = cookie.maxAge() <= 0 ? new Date(0) // Set expires to the Unix epoch : new Date(cookie.maxAge() * 1000L + System.currentTimeMillis()); add(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires)); } if (cookie.sameSite() != null) { add(buf, CookieHeaderNames.SAMESITE, cookie.sameSite()); } if (cookie.path() != null) { add(buf, CookieHeaderNames.PATH, cookie.path()); } if (cookie.domain() != null) { add(buf, CookieHeaderNames.DOMAIN, cookie.domain()); } if (cookie.isSecure()) { add(buf, CookieHeaderNames.SECURE); } if (cookie.isHttpOnly()) { add(buf, CookieHeaderNames.HTTPONLY); } return stripTrailingSeparator(buf); } \nResponse:", "ground_truth": "Encodes the specified cookie into a Set-Cookie header value.\n\n@param cookie the cookie\n@return a single Set-Cookie header value", "predict": " Formats a Cookie for sending to the server.\n <p>Note that some cookie specifications omit the \"=\" character on the name, which is contrary to the HTTP specification. That is allowed, but not encouraged.\n @param cookie The cookie to format. @return The Cookie formatted for sending to the server.\n */"}
{"ID": 643, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static NodeList selectNodes(String path, Object node) { return selectNodes(path, node, null); } \nResponse:", "ground_truth": "Select all nodes that are selected by this XPath expression. If multiple nodes match, multiple\nnodes will be returned. Nodes will be returned in document-order,\n\n@param path the xpath expression\n@param node the starting node\n@return result of evaluating the xpath expression against node", "predict": " Selects nodes from the given XPath expression and XPath namespace context. @param path XPath expression @param node XPath namespace context @return NodeList of matching nodes\n**/"}
{"ID": 644, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(java.util.List<T> list) { return scala.collection.JavaConverters.asScalaBufferConverter(list).asScala().toList(); } \nResponse:", "ground_truth": "Converts a Java List to Scala Seq.\n\n@param list    the java list.\n@return the converted Seq.\n@param <T> the element type.", "predict": " Scala converter method for converting a java list to Scala Seq.\n * @param list The list to convert.\n * @return Scala Seq wrapping the list.\n */"}
{"ID": 645, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> scala.collection.immutable.Seq<T> toSeq(T[] array) { return toSeq(java.util.Arrays.asList(array)); } \nResponse:", "ground_truth": "Converts a Java Array to Scala Seq.\n\n@param array    the java array.\n@return the converted Seq.\n@param <T> the element type.", "predict": " Scala Seq wrapping an array. @param array The array to wrap. @return The Scala Seq wrapping the array."}
{"ID": 646, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SafeVarargs public static <T> scala.collection.immutable.Seq<T> varargs(T... array) { return toSeq(array); } \nResponse:", "ground_truth": "Converts a Java varargs to Scala varargs.\n\n@param array    the java array.\n@return the Scala varargs\n@param <T> the element type.", "predict": " Scala varargs analog.\n* @param array The array of items.\n* @param <T> The type of items.\n* @return The Scala Seq.\n*/"}
{"ID": 647, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <In, Out> MappedWebSocketAcceptor<In, Out> json(Class<In> in) { return new MappedWebSocketAcceptor<>( Scala.partialFunction( message -> { try { if (message instanceof Message.Binary) { return F.Either.Left( play.libs.Json.mapper() .readValue( ((Message.Binary) message).data().iterator().asInputStream(), in)); } else if (message instanceof Message.Text) { return F.Either.Left( play.libs.Json.mapper().readValue(((Message.Text) message).data(), in)); } } catch (Exception e) { return F.Either.Right(new Message.Close(CloseCodes.Unacceptable(), e.getMessage())); } throw Scala.noMatch(); }), outMessage -> { try { return new Message.Text(play.libs.Json.mapper().writeValueAsString(outMessage)); } catch (Exception e) { throw new RuntimeException(e); } }); } \nResponse:", "ground_truth": "Acceptor for JSON WebSockets.\n\n@param in The class of the incoming messages, used to decode them from the JSON.\n@param <In> The websocket's input type (what it receives from clients)\n@param <Out> The websocket's output type (what it writes to clients)\n@return The WebSocket acceptor.", "predict": " Create a JSON WebSocketAcceptor. The first parameter is the class of the incoming message. The second parameter is the function that transforms the incoming message to the outgoing message. The third parameter is the function that transforms the outgoing message to the response. The fourth parameter is the function that transforms the incoming exception to the outgoing exception. The fifth parameter is the function that transforms the outgoing exception to the response. @param in The incoming message class. @param out The outgoing message class. @param <In> The incoming message class. @param <Out> The outgoing message class. @return The JSON WebSocketAcceptor."}
{"ID": 648, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static <In, Out> WebSocket acceptOrResult( PartialFunction<Message, F.Either<In, Message>> inMapper, Function<Http.RequestHeader, CompletionStage<F.Either<Result, Flow<In, Out, ?>>>> f, Function<Out, Message> outMapper) { return new WebSocket() { @Override public CompletionStage<F.Either<Result, Flow<Message, Message, ?>>> apply( Http.RequestHeader request) { return f.apply(request) .thenApply( resultOrFlow -> { if (resultOrFlow.left.isPresent()) { return F.Either.Left(resultOrFlow.left.get()); } else { Flow<Message, Message, ?> flow = AkkaStreams.bypassWith( Flow.<Message>create().collect(inMapper), play.api.libs.streams.AkkaStreams.onlyFirstCanFinishMerge(2), resultOrFlow.right.get().map(outMapper::apply)); return F.Either.Right(flow); } }); } }; } \nResponse:", "ground_truth": "Helper to create handlers for WebSockets.\n\n@param inMapper Function to map input messages. If it produces left, the message will be passed\nto the WebSocket flow, if it produces right, the message will be sent back out to the\nclient - this can be used to send errors directly to the client.\n@param f The function to handle the WebSocket.\n@param outMapper Function to map output messages.\n@return The WebSocket handler.", "predict": " Alternative way to express the above DSL. Useful for testing purposes.\n */"}
{"ID": 649, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static boolean setAccessibleWorkaround(final AccessibleObject o) { if (o == null || o.isAccessible()) { return false; } final Member m = (Member) o; if (!o.isAccessible() && Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) { try { o.setAccessible(true); return true; } catch (final SecurityException e) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false; } \nResponse:", "ground_truth": "XXX Default access superclass workaround.\n\n<p>When a {@code public} class has a default access superclass with {@code public} members,\nthese members are accessible. Calling them from compiled code works fine. Unfortunately, on\nsome JVMs, using reflection to invoke these members seems to (wrongly) prevent access even when\nthe modifier is {@code public}. Calling {@code setAccessible(true)} solves the problem but will\nonly work from sufficiently privileged code. Better workarounds would be gratefully accepted.\n\n@param o the AccessibleObject to set as accessible\n@return a boolean indicating whether the accessibility of the object was set to true.", "predict": " Workaround for Introspector issues. Under certain circumstances, setting accessible via reflection breaks accessibility. Therefore, we resort to hacks involving reflection. Fortunately, hacks like these are incredibly fragile and brittle, so we're willing to accept hacks like these in favor of having solid reflection facilities. Fortunately, hacks like these tend to disappear in fairly dramatic ways. Luckily, hacks are incredibly brittle, so we're reasonably confident hacks will remain relatively stable in the face of evolution in the JVM. Although hacks are brittle, they're incredibly robust, so evolution in the JVM won't adversely affect our ability to use reflection effectively. Although hacks are brittle, they're also extremely robust, so evolution in the JVM won't adversely affect our ability to use reflection effectively. Although hacks are brittle, they're also extremely robust, so evolution in the JVM won't adversely affect our ability to use reflection effectively. Although hacks are brittle, they're also extremely robust, so evolution in the JVM won't adversely affect our ability to use reflection effectively. Although hacks are brittle, they're also extremely"}
{"ID": 650, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getPrimitivePromotionCost( final Class<?> srcClass, final Class<?> destClass) { float cost = 0.0f; Class<?> cls = srcClass; if (!cls.isPrimitive()) { // slight unwrapping penalty cost += 0.1f; cls = ClassUtils.wrapperToPrimitive(cls); } for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) { if (cls == ORDERED_PRIMITIVE_TYPES[i]) { cost += 0.1f; if (i < ORDERED_PRIMITIVE_TYPES.length - 1) { cls = ORDERED_PRIMITIVE_TYPES[i + 1]; } } } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required to promote a primitive number to another type.\n\n@param srcClass the (primitive) source class\n@param destClass the (primitive) destination class\n@return The cost of promoting the primitive", "predict": " Estimates the cost of promoting a primitive type to another. Promotion involves widening the type, which incurs a slight performance penalty. Therefore, promoting is preferable to widening unless widened type is another primitive. Therefore, this estimator favors promoting primitives. Promoting char -> int requires widening char to int, which incurs a slight penalty, while promoting int -> char remains viable. Therefore, promoting achieves a higher score than widening char -> int. Promoting short -> int remains viable despite widening char -> int, as promoting short -> char remains viable. Therefore, promoting achieves a higher score than widening char -> int. Promoting short -> char remains viable despite widening short -> int, as promoting char -> short remains viable. Therefore, promoting achieves a higher score than widening short -> int. Promoting short -> char remains viable despite widening short -> int, as promoting char -> short remains viable. Therefore, promoting achieves a higher score than widening short -> int. Promoting char -> short remains viable despite widening char -> short, as promoting char -> short remains viable. Therefore, promoting achieves a"}
{"ID": 651, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getTotalTransformationCost( final Class<?>[] srcArgs, final Executable executable) { final Class<?>[] destArgs = executable.getParameterTypes(); final boolean isVarArgs = executable.isVarArgs(); // \"source\" and \"destination\" are the actual and declared args respectively. float totalCost = 0.0f; final long normalArgsLen = isVarArgs ? destArgs.length - 1 : destArgs.length; if (srcArgs.length < normalArgsLen) { return Float.MAX_VALUE; } for (int i = 0; i < normalArgsLen; i++) { totalCost += getObjectTransformationCost(srcArgs[i], destArgs[i]); } if (isVarArgs) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs.length < destArgs.length; final boolean explicitArrayForVarags = srcArgs.length == destArgs.length && srcArgs[srcArgs.length - 1].isArray(); final float varArgsCost = 0.001f; final Class<?> destClass = destArgs[destArgs.length - 1].getComponentType(); if (noVarArgsPassed) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost(destClass, Object.class) + varArgsCost; } else if (explicitArrayForVarags) { final Class<?> sourceClass = srcArgs[srcArgs.length - 1].getComponentType(); totalCost += getObjectTransformationCost(sourceClass, destClass) + varArgsCost; } else { // This is typical varargs case. for (int i = destArgs.length - 1; i < srcArgs.length; i++) { final Class<?> srcClass = srcArgs[i]; totalCost += getObjectTransformationCost(srcClass, destClass) + varArgsCost; } } } return totalCost; } \nResponse:", "ground_truth": "Returns the sum of the object transformation cost for each class in the source argument list.\n\n@param srcArgs The source arguments\n@param executable The executable to calculate transformation costs for\n@return The total transformation cost", "predict": " Calculates the total transformation cost of transforming all the arguments. The following are the individual contributions to the cost: Wildcards are free: If both classes are wildcards, totalCost is 0. Less than ideal: If one class is a wildcard, but the other is not, totalCost increases slightly. More than ideal: If neither class is a wildcard, but both classes are interfaces, totalCost increases slightly. Everywhere else: totalCost increases significantly. Strange cases: If one or both of the classes are primitives, we'll assume that someone knows what they're doing. :) Particularly odd: If both classes are primitives, totalCost increases tremendously."}
{"ID": 652, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) { if (destClass.isPrimitive()) { return getPrimitivePromotionCost(srcClass, destClass); } float cost = 0.0f; while (srcClass != null && !destClass.equals(srcClass)) { if (destClass.isInterface() && ClassUtils.isAssignable(srcClass, destClass)) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f; break; } cost++; srcClass = srcClass.getSuperclass(); } /* * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if (srcClass == null) { cost += 1.5f; } return cost; } \nResponse:", "ground_truth": "Gets the number of steps required needed to turn the source class into the destination class.\nThis represents the number of steps in the object hierarchy graph.\n\n@param srcClass The source class\n@param destClass The destination class\n@return The cost of transforming an object", "predict": " Calculates the Levenshtein distance between two Strings. @param src The first String, must not be null. @param dest The second String, must not be null. @return The Levenshtein distance between the Strings.\n*/"}
{"ID": 653, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(String key, Object... args) { return messagesApi.get(lang, key, args); } \nResponse:", "ground_truth": "Get the message at the given key.\n\n<p>Uses `java.text.MessageFormat` internally to format the message.\n\n@param key the message key\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get localized message. @param key localization key. @param args localization arguments. @return localized message."}
{"ID": 654, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String at(List<String> keys, Object... args) { return messagesApi.get(lang, keys, args); } \nResponse:", "ground_truth": "Get the message at the first defined key.\n\n<p>Uses `java.text.MessageFormat` internally to format the message.\n\n@param keys the messages keys\n@param args the message arguments\n@return the formatted message or a default rendering if the key wasn't defined", "predict": " Get localized message. @param keys keys to search for localized message. @param args arguments to replace in localized message. @return localized message."}
{"ID": 655, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Database createFrom( String driver, String url, Map<String, ? extends Object> config) { return createFrom(\"default\", driver, url, config); } \nResponse:", "ground_truth": "Create a pooled database named \"default\" with the given configuration.\n\n@param driver the database driver class\n@param url the database url\n@param config a map of extra database configuration\n@return a configured database", "predict": " Creates a new database connection pool using the default driver and url. The configuration map is ignored. @param driver The database driver class name. @param url The database url. @param config The configuration map. Ignored. @return The database connection pool."}
{"ID": 656, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ParallelSorter create(Object[] arrays) { Generator gen = new Generator(); gen.setArrays(arrays); return gen.create(); } \nResponse:", "ground_truth": "Create a new ParallelSorter object for a set of arrays. You may\nsort the arrays multiple times via the same ParallelSorter object.\n@param arrays An array of arrays to sort. The arrays may be a mix\nof primitive and non-primitive types, but should all be the same\nlength.\n@param loader ClassLoader for generated class, uses \"current\" if null", "predict": " Creates a ParallelSorter tailored to sort the given arrays. The arrays are assumed to be sorted already. The arrays are not copied, so they must not be modified after passing them to this method. The arrays are also assumed to be relatively small, so copying them is cheap compared to sorting. Therefore, the sorting is carried out in-place. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting algorithm is tailored to that fact. Therefore, the arrays are sorted in place, and the sorting"}
{"ID": 657, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void quickSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.quickSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using the quicksort algorithm.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": " QuickSort algorithm. QuickSort improves stability of quicksort algorithm by sorting small subarrays independently. It divides the array into two halves at every iteration and sort them recursively. Then it merges these two halves together. This improves stability of quicksort algorithm drastically. It is called quick sort because it partitions the array into two halves repeatedly. It divides the array into two halves at every iteration and sort them recursively. Then it merges these two halves together. This improves stability of quicksort algorithm drastically. It is called quick sort because it partitions the array into two halves repeatedly. It divides the array into two halves at every iteration and sort them recursively. Then it merges these two halves together. This improves stability of quicksort algorithm drastically. It is called quick sort because it partitions the array into two halves repeatedly. It divides the array into two halves at every iteration and sort them recursively. Then it merges these two halves together. This improves stability of quicksort algorithm drastically. It is called quick sort because"}
{"ID": 658, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void mergeSort(int index, int lo, int hi, Comparator cmp) { chooseComparer(index, cmp); super.mergeSort(lo, hi - 1); } \nResponse:", "ground_truth": "Sort the arrays using an in-place merge sort.\n@param index array (column) to sort by\n@param lo starting array index (row), inclusive\n@param hi ending array index (row), exclusive\n@param cmp Comparator to use if the specified column is non-primitive", "predict": " Traditional Merge Sort. Chooses a comparer based on the comparator of the specified index.\n@param lo Begin of the merge sort.\n@param hi End of the merge sort.\n*/"}
{"ID": 659, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object invoke(Object obj, Object[] args) throws Throwable { try { init(); FastClassInfo fci = fastClassInfo; return fci.f1.invoke(fci.i1, obj, args); } catch (InvocationTargetException e) { throw e.getTargetException(); } catch (IllegalArgumentException e) { if (fastClassInfo.i1 < 0) throw new IllegalArgumentException(\"Protected method: \" + sig1); throw e; } } \nResponse:", "ground_truth": "Invoke the original method, on a different object of the same type.\n@param obj the compatible object; recursion will result if you use the object passed as the first\nargument to the MethodInterceptor (usually not what you want)\n@param args the arguments passed to the intercepted method; you may substitute a different\nargument array as long as the types are compatible\n@see MethodInterceptor#intercept\n@throws Throwable the bare exceptions thrown by the called method are passed through\nwithout wrapping in an <code>InvocationTargetException</code>", "predict": " Invokes a method on an object. Expects the arguments to be boxed primitives. @param obj receiver of invocation @param args arguments to pass to method @return result of invocation\n@throws Throwable if invocation raises exception\n*/"}
{"ID": 660, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void cast_numeric(Type from, Type to) { if (from != to) { if (from == Type.DOUBLE_TYPE) { if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.D2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.D2L); } else { mv.visitInsn(Constants.D2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.FLOAT_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.F2D); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.F2L); } else { mv.visitInsn(Constants.F2I); cast_numeric(Type.INT_TYPE, to); } } else if (from == Type.LONG_TYPE) { if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.L2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.L2F); } else { mv.visitInsn(Constants.L2I); cast_numeric(Type.INT_TYPE, to); } } else { if (to == Type.BYTE_TYPE) { mv.visitInsn(Constants.I2B); } else if (to == Type.CHAR_TYPE) { mv.visitInsn(Constants.I2C); } else if (to == Type.DOUBLE_TYPE) { mv.visitInsn(Constants.I2D); } else if (to == Type.FLOAT_TYPE) { mv.visitInsn(Constants.I2F); } else if (to == Type.LONG_TYPE) { mv.visitInsn(Constants.I2L); } else if (to == Type.SHORT_TYPE) { mv.visitInsn(Constants.I2S); } } } } \nResponse:", "ground_truth": "Casts from one primitive numeric type to another", "predict": " Generate a cast instruction. Expect the casted type to be compatible with the argument type. @see Constants\n*/"}
{"ID": 661, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void load_arg(int index) { load_local(state.argumentTypes[index], state.localOffset + skipArgs(index)); } \nResponse:", "ground_truth": "Pushes the specified argument of the current method onto the stack.\n@param index the zero-based index into the argument list", "predict": " Load argument into local variable slot."}
{"ID": 662, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void emit_field(int opcode, Type ctype, String name, Type ftype) { mv.visitFieldInsn(opcode, ctype.getInternalName(), name, ftype.getDescriptor()); } \nResponse:", "ground_truth": "package-protected for EmitUtils, try to fix", "predict": " Emit a field instruction. @param opcode the opcode of the instruction @param ctype the class containing the field @param name the name of the field @param ftype the field type\n*/"}
{"ID": 663, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void zero_or_null(Type type) { if (TypeUtils.isPrimitive(type)) { switch (type.getSort()) { case Type.DOUBLE: push(0d); break; case Type.LONG: push(0L); break; case Type.FLOAT: push(0f); break; case Type.VOID: aconst_null(); default: push(0); } } else { aconst_null(); } } \nResponse:", "ground_truth": "Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.", "predict": " Generates code to push a zero or null constant onto the operand stack. The zero constant pushed depends on the primitive type of the operand type. For example, a double pushes 0d, a float pushes 0f, and a void pushes null.\n"}
{"ID": 664, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void unbox_or_zero(Type type) { if (TypeUtils.isPrimitive(type)) { if (type != Type.VOID_TYPE) { Label nonNull = make_label(); Label end = make_label(); dup(); ifnonnull(nonNull); pop(); zero_or_null(type); goTo(end); mark(nonNull); unbox(type); mark(end); } } else { checkcast(type); } } \nResponse:", "ground_truth": "Unboxes the object on the top of the stack. If the object is null, the\nunboxed primitive value becomes zero.", "predict": " Generate bytecode that tests if the topmost value on the stack is null or zero, pops it off and jumps to either label depending on whether it evaluates to zero. Useful for unboxing primitives."}
{"ID": 665, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) { Type componentType = TypeUtils.getComponentType(type); Local array = e.make_local(); Local loopvar = e.make_local(Type.INT_TYPE); Label loopbody = e.make_label(); Label checkloop = e.make_label(); e.store_local(array); e.push(0); e.store_local(loopvar); e.goTo(checkloop); e.mark(loopbody); e.load_local(array); e.load_local(loopvar); e.array_load(componentType); callback.processElement(componentType); e.iinc(loopvar, 1); e.mark(checkloop); e.load_local(loopvar); e.load_local(array); e.arraylength(); e.if_icmp(e.LT, loopbody); } \nResponse:", "ground_truth": "Process an array on the stack. Assumes the top item on the stack\nis an array of the specified type. For each element in the array,\nputs the element on the stack and triggers the callback.\n@param type the type of the array (type.isArray() must be true)\n@param callback the callback triggered for each element", "predict": " Processes an array by making a local copy of it, loading each element and passing it to the callback. The callback will typically write out some code involving the local copy and the current element. After each element is processed, the array is decremented by 1. Upon completion, the array is popped from the stack. @param e The code emitter to emit code with. @param type The type of the array. @param callback The callback to invoke with each element of the array."}
{"ID": 666, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) { e.dup2(); Label nonNull = e.make_label(); Label oneNullHelper = e.make_label(); Label end = e.make_label(); e.ifnonnull(nonNull); e.ifnonnull(oneNullHelper); e.pop2(); e.goTo(bothNull); e.mark(nonNull); e.ifnull(oneNullHelper); e.goTo(end); e.mark(oneNullHelper); e.pop2(); e.goTo(oneNull); e.mark(end); } \nResponse:", "ground_truth": "If both objects on the top of the stack are non-null, does nothing.\nIf one is null, or both are null, both are popped off and execution\nbranches to the respective label.\n@param oneNull label to branch to if only one of the objects is null\n@param bothNull label to branch to if both of the objects are null", "predict": " Generate code for comparing two objects for nullness. Unlike most comparisons, we can't steal code from Object.equals here because we're not calling through to it. Instead, we generate explicit test for nullness.\nUnlike most comparisons, we don't steal our comparisons for non-nullness testing here. Instead, we emit test-for-null followed by a conditional jump. This allows us to share the test-for-null machinery.\n*/\nprivate static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n    e.dup2();\n    Label nonNull = e.make_label();\n    Label oneNullHelper = e.make_label();\n    Label end = e.make_label();\n    e.ifnonnull(nonNull);\n    e.pop2();\n    e.goTo(bothNull);\n    e.mark(nonNull);\n    e.dup();\n    e.ifnonnull(oneNullHelper);\n"}
{"ID": 667, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map/*<Signature, Signature>*/resolveAll() { Map resolved = new HashMap(); for (Iterator entryIter = declToBridge.entrySet().iterator(); entryIter.hasNext(); ) { Map.Entry entry = (Map.Entry) entryIter.next(); Class owner = (Class) entry.getKey(); Set bridges = (Set) entry.getValue(); try { InputStream is = classLoader.getResourceAsStream(owner.getName().replace('.', '/') + \".class\"); if (is == null) { return resolved; } try { new ClassReader(is) .accept(new BridgedFinder(bridges, resolved), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG); } finally { is.close(); } } catch (IOException ignored) {} } return resolved; } \nResponse:", "ground_truth": "Finds all bridge methods that are being called with invokespecial &\nreturns them.", "predict": " Resolves all bridges. Bridges are resolved by reading the class files of referenced classes. Bridges are resolved recursively. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion. Bridges are resolved in parallel threads. Bridges are resolved in parallel threads. Bridges are resolved in breadth-first fashion"}
{"ID": 668, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void getMethods(Class superclass, Class[] interfaces, List methods) { getMethods(superclass, interfaces, methods, null, null); } \nResponse:", "ground_truth": "Finds all of the methods that will be extended by an\nEnhancer-generated class using the specified superclass and\ninterfaces. This can be useful in building a list of Callback\nobjects. The methods are added to the end of the given list.  Due\nto the subclassing nature of the classes generated by Enhancer,\nthe methods are guaranteed to be non-static, non-final, and\nnon-private. Each method signature will only occur once, even if\nit occurs in multiple classes.\n@param superclass the class that will be extended, or null\n@param interfaces the list of interfaces that will be implemented, or null\n@param methods the list into which to copy the applicable methods", "predict": " Discover all the methods in the specified interfaces and superclasses. This method does not go through the proxy interfaces, so discovery will not be confused by proxying. This means discovery may discover unwanted methods due to inheritance. Therefore, discovery should generally be restricted to the interfaces you expect, or you may run into problems. @param superclass Superclass to introspect. Classes discovered through introspection will extend this class. @param interfaces Interfaces to introspect. Classes discovered through introspection will implement these interfaces. @param methods List to add discovered methods to."}
{"ID": 669, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void filterConstructors(Class sc, List constructors) { CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true)); if (constructors.size() == 0) throw new IllegalArgumentException(\"No visible constructors in \" + sc); } \nResponse:", "ground_truth": "Filter the list of constructors from the superclass. The\nconstructors which remain will be included in the generated\nclass. The default implementation is to filter out all private\nconstructors, but subclasses may extend Enhancer to override this\nbehavior.\n@param sc the superclass\n@param constructors the list of all declared constructors from the superclass\n@throws IllegalArgumentException if there are no non-private constructors", "predict": " Filter out unwanted constructors from consideration. This is necessary because constructors are inherited, so we don't want to consider inherited constructors. Furthermore, we want to consider only non-bridge constructors. Bridges are constructors inherited from the superclass, but that's ok because they're never actually called. Bridges are marked invisible so that they'll be filtered out later. @param sc the superclass @param constructors the constructors to consider\n*/"}
{"ID": 670, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setSuperclass(Class superclass) { if (superclass != null && superclass.equals(Object.class)) { superclass = null; } this.superclass = superclass; } \nResponse:", "ground_truth": "Set the class which the generated class will extend. The class\nmust not be declared as final, and must have a non-private\nno-argument constructor.\n@param superclass class to extend, or null to extend Object", "predict": " Sets the superclass of this class. If the superclass is Object.class, this class becomes final. Otherwise, it becomes non-final. @param superclass The superclass of this class."}
{"ID": 671, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void getField(String[] names) throws Exception { final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null); e.load_this(); e.load_arg(0); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label end) { Type type = (Type)fields.get(key); e.getfield((String)key); e.box(type); e.return_value(); } public void processDefault() { e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\"); } }); e.end_method(); } \nResponse:", "ground_truth": "to avoid JVM hashcode implementation incompatibilities", "predict": " Generate the field _providerGet() method. Accessible via a provider instance's 'get' method. The default implementation throws an exception as the field doesn't exist. Subclasses may redefine this method to provide a more efficient implementation."}
{"ID": 672, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Method method) { add(ReflectUtils.getSignature(method), ReflectUtils.getExceptionTypes(method)); } \nResponse:", "ground_truth": "Add a method signature to the interface. The method modifiers are ignored,\nsince interface methods are by definition abstract and public.\n@param method the method to add to the interface", "predict": " Adds all methods of the given clazz to this class. @param clazz The class to introspect.\n*/"}
{"ID": 673, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int cardinality() { int w = value; int c = 0; while (w != 0) { c += T[w & 255]; w >>= 8; } return c; } \nResponse:", "ground_truth": "If bit 31 is set then this method results in an infinite loop.\n\n@return the number of bits set to <code>true</code> in this TinyBitSet.", "predict": " Calculates cardinality of the BloomFilter. Useful for measuring the worst-case false positive probability. @return cardinality of the BloomFilter.\n*/"}
{"ID": 674, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setNamingPolicy(NamingPolicy namingPolicy) { if (namingPolicy == null) namingPolicy = DefaultNamingPolicy.INSTANCE; this.namingPolicy = namingPolicy; } \nResponse:", "ground_truth": "Override the default naming policy.\n@see DefaultNamingPolicy\n@param namingPolicy the custom policy, or null to use the default", "predict": " Sets the naming policy to be used for naming beans and bean properties. @param namingPolicy the naming policy to be used for naming beans and bean properties. May be null, in which case a default naming policy will be used.\n*/"}
{"ID": 675, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods) { Map map = new HashMap(); for (int i = 0; i < methods.length; i++) { Method method = methods[i]; map.put(method.getName() + Type.getMethodDescriptor(method), method); } Method[] result = new Method[namesAndDescriptors.length / 2]; for (int i = 0; i < result.length; i++) { result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]); if (result[i] == null) { // TODO: error? } } return result; } \nResponse:", "ground_truth": "used by MethodInterceptorGenerated generated code", "predict": " Finds all methods with the given name and descriptor in the given methods. Returns an array of length 0 if no methods are found. @param namesAndDescriptors alternating names and descriptors of the methods to find\n * @param methods all methods in the class hierarchy of the receiver\n * @return all methods with the given name and descriptor in the given methods\n */"}
{"ID": 676, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Path resolve(final Path base, String child) { if (StringUtil.startsWithChar(child, File.separatorChar)) { child = child.substring(1); } return base.resolve(child); } \nResponse:", "ground_truth": "Resolves subpath in safer way. For some reason, if child starts with\na separator it gets resolved as a full path, ignoring the base.\nThis method acts different.", "predict": " Resolve child path relatively to base path. @param base Base path. @param child Child path. @return Child path relatively to base path."}
{"ID": 677, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readString(final Path path) throws IOException { try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { StringWriter writer = new StringWriter(); // flush & close not needed for StringWriter-instance StreamUtil.copy(reader, writer); return writer.toString(); } } \nResponse:", "ground_truth": "Reads path content.", "predict": " Reads the content of the given path as UTF-8 encoded string. @param path Path to read. @return Content of the given path as UTF-8 encoded string. @throws IOException Thrown if reading failed."}
{"ID": 678, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest host(final String host) { this.host = host; if (headers.contains(HEADER_HOST)) { headerOverwrite(HEADER_HOST, host); } return this; } \nResponse:", "ground_truth": "Sets request host name.", "predict": " Set the host header. @param host The host header value. @return The request specification.\n*/"}
{"ID": 679, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest create(final String method, final String destination) { return new HttpRequest() .method(method.toUpperCase()) .set(destination); } \nResponse:", "ground_truth": "Generic request builder, usually used when method is a variable.\nOtherwise, use one of the other static request builder methods.", "predict": " Create a new HTTP request. @param method The HTTP method. @param destination The destination. @return The HTTP request."}
{"ID": 680, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest connect(final String destination) { return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination); } \nResponse:", "ground_truth": "Builds a CONNECT request.", "predict": " Connect to the given destination. @param destination The destination to connect to. @return The connect request."}
{"ID": 681, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest get(final String destination) { return new HttpRequest() .method(HttpMethod.GET) .set(destination); } \nResponse:", "ground_truth": "Builds a GET request.", "predict": " Creates a GET request to the given destination. @param destination The destination to GET. @return The GET request."}
{"ID": 682, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest post(final String destination) { return new HttpRequest() .method(HttpMethod.POST) .set(destination); } \nResponse:", "ground_truth": "Builds a POST request.", "predict": " Creates a GET request to the given destination. @param destination The destination to GET. @return The GET request."}
{"ID": 683, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest put(final String destination) { return new HttpRequest() .method(HttpMethod.PUT) .set(destination); } \nResponse:", "ground_truth": "Builds a PUT request.", "predict": " PUT http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html \u00a79.9 PUT"}
{"ID": 684, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest patch(final String destination) { return new HttpRequest() .method(HttpMethod.PATCH) .set(destination); } \nResponse:", "ground_truth": "Builds a PATCH request.", "predict": " Alternative HTTP PATCH method. @param destination The destination. @return The HTTP request."}
{"ID": 685, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest delete(final String destination) { return new HttpRequest() .method(HttpMethod.DELETE) .set(destination); } \nResponse:", "ground_truth": "Builds a DELETE request.", "predict": " Creates a DELETE request. @param destination The destination. @return The HTTP request."}
{"ID": 686, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest head(final String destination) { return new HttpRequest() .method(HttpMethod.HEAD) .set(destination); } \nResponse:", "ground_truth": "Builds a HEAD request.", "predict": " Send a HEAD request to the given destination. @param destination The destination to HEAD. @return The HttpRequest. Useful chained calls."}
{"ID": 687, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest trace(final String destination) { return new HttpRequest() .method(HttpMethod.TRACE) .set(destination); } \nResponse:", "ground_truth": "Builds a TRACE request.", "predict": " 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307 Temporary Redirect. 307"}
{"ID": 688, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpRequest options(final String destination) { return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination); } \nResponse:", "ground_truth": "Builds an OPTIONS request.", "predict": " OPTIONS verb. Similar to HEAD. Similar to DELETE. Similar to TRACE. Similar to CONNECT. Similar to TRACK. Similar to PROPFIND. Similar to MKCOL. Similar to REPORT. Similar to PUT. Similar to MOVE. Similar to COPY. Similar to LOCK. Similar to UNLOCK. Similar to ACL. Similar to REPORT. Similar to PROPPATCH. Similar to SEARCH. Similar to MKACTIVITY. Similar to CHECKOUT. Similar toUNCHECKOUT. Similar to MERGE. Similar to UPDATE. Similar to DELETE-ACL. Similar to MKWORKSPACE. Similar to BMOVE. Similar to BDELETE. Similar to BGENERATE. Similar to SEARCH-AC. Similar to UPDATERECEIVE. Similar to UPDATEMODIFIED. Similar to UPDATE. Similar to DELETE-CONTENT. Similar to MKWORKSPACE. Similar to BMOVE. Similar to BUPDATE. Similar to BDELETE"}
{"ID": 689, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest path(String path) { // this must be the only place that sets the path if (!path.startsWith(StringPool.SLASH)) { path = StringPool.SLASH + path; } int ndx = path.indexOf('?'); if (ndx != -1) { String queryString = path.substring(ndx + 1); path = path.substring(0, ndx); query = HttpUtil.parseQuery(queryString, true); } else { query = HttpMultiMap.newCaseInsensitiveMap(); } this.path = path; return this; } \nResponse:", "ground_truth": "Sets request path. Query string is allowed.\nAdds a slash if path doesn't start with one.\nQuery will be stripped out from the path.\nPrevious query is discarded.\n@see #query()", "predict": " Sets the path part of the URI. The path must start with a slash character (/). The path may contain a question mark ('?') character followed by a query string. The query string must be in the form of a series of name=value pairs separated by ampersand (&) characters. Multiple question marks or multiple equals signs in the query string are treated as if they were one occurrence of the character. @param path The path part of the URI. @return The updated UriComponentsBuilder instance. Never null."}
{"ID": 690, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest cookies(final Cookie... cookies) { if (cookies.length == 0) { return this; } StringBuilder cookieString = new StringBuilder(); boolean first = true; for (Cookie cookie : cookies) { Integer maxAge = cookie.getMaxAge(); if (maxAge != null && maxAge.intValue() == 0) { continue; } if (!first) { cookieString.append(\"; \"); } first = false; cookieString.append(cookie.getName()); cookieString.append('='); cookieString.append(cookie.getValue()); } headerOverwrite(\"cookie\", cookieString.toString()); return this; } \nResponse:", "ground_truth": "Sets cookies to the request.", "predict": " Set cookies to be sent with the request. Cookies are sent as a Cookie HTTP header. @param cookies Cookies to send with the request. @return The request specification"}
{"ID": 691, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final String name1, final Object value1, final Object... parameters) { query(name1, value1 == null ? null : value1.toString()); for (int i = 0; i < parameters.length; i += 2) { String name = parameters[i].toString(); String value = parameters[i + 1].toString(); query.add(name, value); } return this; } \nResponse:", "ground_truth": "Adds many query parameters at once. Although it accepts objects,\neach value will be converted to string.", "predict": " Adds a query parameter to the request. The parameter will be added to the query string, and will be encoded in accordance to RFC 3986. @param name1 The name of the parameter. @param value1 The value of the parameter. @param parameters Additional parameters. Each even numbered argument is considered a parameter name, and each odd numbered argument is considered a parameter value. Odd numbered arguments are considered only if they are non-null and non-empty. @return The HttpRequest object itself.\n*/"}
{"ID": 692, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest query(final Map<String, String> queryMap) { for (Map.Entry<String, String> entry : queryMap.entrySet()) { query.add(entry.getKey(), entry.getValue()); } return this; } \nResponse:", "ground_truth": "Adds all parameters from the provided map.", "predict": " Adds query parameters to the request. @param queryMap The query parameters to add. @return The updated builder.\n*/"}
{"ID": 693, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest queryString(final String queryString, final boolean decode) { this.query = HttpUtil.parseQuery(queryString, decode); return this; } \nResponse:", "ground_truth": "Sets query from provided query string. Previous query values\nare discarded.", "predict": " Set the QUERY_STRING value. @param queryString QUERY_STRING value. @param decode decode QUERY_STRING value. @return this.\n*/"}
{"ID": 694, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String queryString() { if (query == null) { return StringPool.EMPTY; } return HttpUtil.buildQuery(query, queryEncoding); } \nResponse:", "ground_truth": "Generates query string. All values are URL encoded.", "predict": " Returns the query string. @return query query string.\n*/"}
{"ID": 695, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String hostUrl() { StringBand url = new StringBand(8); if (protocol != null) { url.append(protocol); url.append(\"://\"); } if (host != null) { url.append(host); } if (port != Defaults.DEFAULT_PORT) { url.append(':'); url.append(port); } return url.toString(); } \nResponse:", "ground_truth": "Returns just host url, without path and query.", "predict": " Returns the host url. @return the host url\n*/"}
{"ID": 696, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest basicAuthentication(final String username, final String password) { if (username != null && password != null) { String data = username.concat(StringPool.COLON).concat(password); String base64 = Base64.encodeToString(data); headerOverwrite(HEADER_AUTHORIZATION, \"Basic \" + base64); } return this; } \nResponse:", "ground_truth": "Enables basic authentication by adding required header.", "predict": " Basic authentication. @param username Username. @param password Password. @return HttpRequestBuilder."}
{"ID": 697, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpRequest setHostHeader() { String hostPort = this.host; if (port != Defaults.DEFAULT_PORT) { hostPort += StringPool.COLON + port; } headerOverwrite(HEADER_HOST, hostPort); return this; } \nResponse:", "ground_truth": "Sets 'Host' header from current host and port.", "predict": " Set Host header. Useful when behind reverse proxy like Nginx. Without this Nginx will reject the request. Similar to apache mod_rewrite's RewriteHostHeader directive. @return HttpRequest"}
{"ID": 698, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected Buffer buffer(final boolean fullRequest) { // INITIALIZATION // host port if (header(HEADER_HOST) == null) { setHostHeader(); } // form Buffer formBuffer = formBuffer(); // query string String queryString = queryString(); // user-agent if (header(\"User-Agent\") == null) { header(\"User-Agent\", Defaults.userAgent); } // POST method requires Content-Type to be set if (method.equals(\"POST\") && (contentLength() == null)) { contentLength(0); } // BUILD OUT Buffer request = new Buffer(); request.append(method) .append(SPACE) .append(path); if (query != null && !query.isEmpty()) { request.append('?'); request.append(queryString); } request.append(SPACE) .append(httpVersion) .append(CRLF); populateHeaderAndBody(request, formBuffer, fullRequest); return request; } \nResponse:", "ground_truth": "Prepares the request buffer.", "predict": " Prepares the HTTP request. @param fullRequest whether to populate the full request or not. @return HTTP request."}
{"ID": 699, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) { return responseHandler.apply(send()); } \nResponse:", "ground_truth": "Syntax sugar.", "predict": " Send the request and await the response synchronously. @param responseHandler The response handler to handle the response. @param <R> The return type. @return The return value of the response handler."}
{"ID": 700, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static Handler removeRange(final Handler firstHandler, final Label start, final Label end) { if (firstHandler == null) { return null; } else { firstHandler.nextHandler = removeRange(firstHandler.nextHandler, start, end); } int handlerStart = firstHandler.startPc.bytecodeOffset; int handlerEnd = firstHandler.endPc.bytecodeOffset; int rangeStart = start.bytecodeOffset; int rangeEnd = end == null ? Integer.MAX_VALUE : end.bytecodeOffset; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if (rangeStart >= handlerEnd || rangeEnd <= handlerStart) { return firstHandler; } if (rangeStart <= handlerStart) { if (rangeEnd >= handlerEnd) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler.nextHandler; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler(firstHandler, end, firstHandler.endPc); } } else if (rangeEnd >= handlerEnd) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler(firstHandler, firstHandler.startPc, start); } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = // [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler.nextHandler = new Handler(firstHandler, end, firstHandler.endPc); return new Handler(firstHandler, firstHandler.startPc, start); } } \nResponse:", "ground_truth": "Removes the range between start and end from the Handler list that begins with the given\nelement.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@param start the start of the range to be removed.\n@param end the end of the range to be removed. Maybe {@literal null}.\n@return the exception handler list with the start-end range removed.", "predict": " Remove handlers in [start,end] interval from the handler list. May return early if no handlers are removed. May return early if [start,end] doesn't intersect with any existing ranges. May return early if [start,end] intersects with [handlerStart,handlerEnd[ but is not included in [handlerStart,handlerEnd[. May return early if [start,end] intersects with [rangeStart,rangeEnd[ but is not included in [rangeStart,rangeEnd[. May return early if [rangeStart,rangeEnd[ intersects with [handlerStart,handlerEnd[ but is not included in [handlerStart,handlerEnd[. May return early if [rangeStart,rangeEnd[ intersects with [start,end] but is not included in [start,end]. May return early if [rangeStart,rangeEnd[ intersects with [start,end] but is not included in [start,end]. May return early if [rangeStart,rangeEnd[ intersects with [handlerStart,handlerEnd"}
{"ID": 701, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static int getExceptionTableLength(final Handler firstHandler) { int length = 0; Handler handler = firstHandler; while (handler != null) { length++; handler = handler.nextHandler; } return length; } \nResponse:", "ground_truth": "Returns the number of elements of the Handler list that begins with the given element.\n\n@param firstHandler the beginning of a Handler list. May be {@literal null}.\n@return the number of elements of the Handler list that begins with 'handler'.", "predict": " Calculate the length of the exception table. @param firstHandler the first exception handler. @return the length of the exception table.\n*/"}
{"ID": 702, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionInterceptors() { final Collection<? extends ActionInterceptor> interceptorValues = interceptorsManager.getAllInterceptors(); interceptors = new ArrayList<>(); interceptors.addAll(interceptorValues); interceptors.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all interceptors.", "predict": " Collect action interceptors."}
{"ID": 703, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionFilters() { final Collection<? extends ActionFilter> filterValues = filtersManager.getAllFilters(); filters = new ArrayList<>(); filters.addAll(filterValues); filters.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all filters.", "predict": " Collect action filters."}
{"ID": 704, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionResults() { final Collection<ActionResult> resultsValues = resultsManager.getAllActionResults(); results = new ArrayList<>(); results.addAll(resultsValues); results.sort(Comparator.comparing(a -> a.getClass().getSimpleName())); } \nResponse:", "ground_truth": "Collects all action results.", "predict": " Collects all action results."}
{"ID": 705, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectActionRuntimes() { actions = actionsManager.getAllActionRuntimes(); actions.sort(Comparator.comparing(ActionRuntime::getActionPath)); } \nResponse:", "ground_truth": "Collects all action runtime configurations.", "predict": " Collects all action runtimes."}
{"ID": 706, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected void setSimpleProperty(final BeanProperty bp, final Object value) { Setter setter = bp.getSetter(isDeclared); // try: setter if (setter != null) { invokeSetter(setter, bp, value); return; } // try: put(\"property\", value) if (bp.isMap()) { ((Map) bp.bean).put(bp.name, value); return; } if (isSilent) { return; } throw new BeanException(\"Simple property not found: \" + bp.name, bp); } \nResponse:", "ground_truth": "Sets a value of simple property.", "predict": " Set a simple property. @param bp The bean property to set. @param value The value to set."}
{"ID": 707, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public <T> T getProperty(final Object bean, final String name) { BeanProperty beanProperty = new BeanProperty(this, bean, name); if (!isSilent) { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } else { try { resolveNestedProperties(beanProperty); return (T) getIndexProperty(beanProperty); } catch (Exception ignore) { return null; } } } \nResponse:", "ground_truth": "Returns value of bean's property.", "predict": " Get the property value. @param bean the bean instance. @param name the property name. @return the property value."}
{"ID": 708, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public String extractThisReference(final String propertyName) { int ndx = StringUtil.indexOfChars(propertyName, INDEX_CHARS); if (ndx == -1) { return propertyName; } return propertyName.substring(0, ndx); } \nResponse:", "ground_truth": "Extract the first name of this reference.", "predict": " Extracts the THIS reference from the given property name. @param propertyName the property name to analyze. Shall not be <code>null</code>. @return the extracted THIS reference, or <code>null</code> if none. Shall not be empty neither. Shall not contain any forbidden characters. Shall not exceed the maximum length for a formal THIS reference. Shall respect the conventions explained in the Javadoc of {@link #THIS_REFERENCE}. Shall not be longer than {@link #MAXIMUM_LENGTH}. Shall not be longer than the given maximum length. Shall not collide with other potential THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other formal THIS references. Shall not collide with any other"}
{"ID": 709, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public PrintWriter getWriter() { if (writer == null) { writer = new FastCharArrayWriter(); printWriter = new PrintWriter(writer); } return printWriter; } \nResponse:", "ground_truth": "Returns buffered writer. Buffer will be created if not already used.", "predict": " Get the writer associated with this FastStringBuffer. This writer will be inherited by FastStringBufferWriter.\n@return Writer associated with this FastStringBuffer.\n*/"}
{"ID": 710, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setObjectReference(final String name, final Object object) { if (objectRefs == null) { objectRefs = new HashMap<>(); } objectRefs.put(name, object); } \nResponse:", "ground_truth": "Saves object reference.", "predict": " Associate a named object with this component. Useful for dependency injection frameworks. @param name Name of the object to associate with this component. @param object Associated object."}
{"ID": 711, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getObjectReference(final String name) { if (objectRefs == null) { return null; } return objectRefs.get(name); } \nResponse:", "ground_truth": "Returns object reference.", "predict": " Get the object reference for the given name. @param name The name of the object reference. @return The object reference or null if not found."}
{"ID": 712, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object lookupObject(final String ref) { Object value = getObjectReference(ref); if (value == null) { throw new DbSqlBuilderException(\"Invalid object reference: \" + ref); } return value; } \nResponse:", "ground_truth": "Lookups for object reference and throws an exception if reference doesn't exist.", "predict": " Looks up an object reference. @param ref Object reference. May be either a fully qualified name or a dot-separated path. @return Corresponding object. May be null if the reference is invalid."}
{"ID": 713, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor getTableDescriptor(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.desc; } \nResponse:", "ground_truth": "Returns entity descriptor for provided table reference.", "predict": " Returns the DbEntityDescriptor for the given tableRef. Returns null if none found. @param tableRef The fully qualified name of the table. @return The DbEntityDescriptor for the given tableRef. Returns null if none found."}
{"ID": 714, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityDescriptor findTableDescriptorByColumnRef(final String columnRef) { for (Map.Entry<String, TableRefData> entry : tableRefs.entrySet()) { DbEntityDescriptor ded = entry.getValue().desc; if (ded.findByPropertyName(columnRef) != null) { return ded; } } return null; } \nResponse:", "ground_truth": "Finds entity descriptor of a table that contains provided column reference.", "predict": " Finds the table descriptor by the column ref. @param columnRef the column ref\n * @return the table descriptor\n */"}
{"ID": 715, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getTableAlias(final String tableRef) { if (tableRefs == null) { return null; } TableRefData t = tableRefs.get(tableRef); return t == null ? null : t.alias; } \nResponse:", "ground_truth": "Returns table alias for provided table reference.", "predict": " Get the alias for a table ref. Aliases are optional. They are primarily used in expanding queries. @param tableRef table ref to look up @return alias or null if no alias is registered for this table ref\n*/"}
{"ID": 716, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerTableReference(final String tableReference, final DbEntityDescriptor ded, final String tableAlias) { if (tableRefs == null) { tableRefs = new HashMap<>(); } TableRefData t = new TableRefData(ded, tableAlias); if (tableRefs.put(tableReference, t) != null) { throw new DbSqlBuilderException(\"Duplicated table reference: \" + tableReference); } } \nResponse:", "ground_truth": "Registers table reference for provided entity.", "predict": " Register table reference. @param tableReference table reference. @param ded descriptor of referenced table. @param tableAlias alias of referenced table."}
{"ID": 717, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor lookupTableRef(final String tableRef) { DbEntityDescriptor ded = getTableDescriptor(tableRef); if (ded == null) { throw new DbSqlBuilderException(\"Table reference not used in this query: \" + tableRef); } return ded; } \nResponse:", "ground_truth": "Lookups for table reference and throws an exception if table reference not found.", "predict": " Looks up the table descriptor referenced by the given tableRef. Throws an exception if the tableRef is not used in this query. @param tableRef the tableRef to lookup @return the referenced table descriptor\n*/"}
{"ID": 718, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerHint(final String hint) { if (hints == null) { hints = new ArrayList<>(hintCount); } hints.add(hint); } \nResponse:", "ground_truth": "Registers a hint.", "predict": " Register a hint for the upcoming geometry. Useful for avoiding anomalous situations like rings crossing themselves or polygons touching themselves. This is accomplished by chopping the offending ring/polygon piece out of the geometry.\n<p>Note that this is destructive to the geometry. It does not clone it.</p>\n<p>This is a no-op if hints are disabled.</p>\n<p>This is a destructive operation.</p>\n<p>This is a no-op if hints are disabled.</p>\n<p>This is a destructive operation.</p>\n<p>This is a no-op if hints are disabled.</p>\n<p>This is a destructive operation.</p>\n<p>This is a no-op if hints are disabled.</p>\n<p>This is a destructive operation.</p>\n<p>This is a no-op if hints are disabled.</p>\n<p>This is a destructive operation.</p>\n<p>This is a no-"}
{"ID": 719, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public final boolean serialize(final JsonContext jsonContext, final T value) { if (jsonContext.pushValue(value)) { // prevent circular dependencies return false; } serializeValue(jsonContext, value); jsonContext.popValue(); return true; } \nResponse:", "ground_truth": "Detects circular dependencies and pushes value as current\ntype context.", "predict": " Serialize the given value. @param jsonContext the json context @param value the value to serialize @return true if the value was serialized, false otherwise\n*/"}
{"ID": 720, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectAttributes(final HttpServletRequest servletRequest, final Targets targets) { final Enumeration<String> attributeNames = servletRequest.getAttributeNames(); while (attributeNames.hasMoreElements()) { final String attrName = attributeNames.nextElement(); targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(attrName); if (name != null) { final Object attrValue = servletRequest.getAttribute(attrName); target.writeValue(name, attrValue, true); } }); } } \nResponse:", "ground_truth": "Injects request attributes.", "predict": " Inject attributes from the servlet request into Targets.\n@param servletRequest The servlet request.\n@param targets Targets to inject into.\n*/"}
{"ID": 721, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectParameters(final HttpServletRequest servletRequest, final Targets targets) { final boolean encode = encodeGetParams && servletRequest.getMethod().equals(\"GET\"); final Enumeration<String> paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = ServletUtil.prepareParameters( paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues != null) { if (encode) { for (int j = 0; j < paramValues.length; j++) { final String p = paramValues[j]; if (p != null) { final String encoding = madvocEncoding.getEncoding(); paramValues[j] = StringUtil.convertCharset(p, StringPool.ISO_8859_1, encoding); } } } final Object value = (paramValues.length != 1 ? paramValues : paramValues[0]); target.writeValue(name, value, true); } } }); } } \nResponse:", "ground_truth": "Inject request parameters.", "predict": " Inject parameters from servlet request into Madvoc targets. @param servletRequest servlet request @param targets Madvoc targets */"}
{"ID": 722, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectUploadedFiles(final HttpServletRequest servletRequest, final Targets targets) { if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } final MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } final Enumeration<String> paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { final String paramName = paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } targets.forEachTargetAndIn(this, (target, in) -> { final String name = in.matchedName(paramName); if (name != null) { final FileUpload[] paramValues = multipartRequest.getFiles(paramName); if (ignoreInvalidUploadFiles) { for (int j = 0; j < paramValues.length; j++) { final FileUpload paramValue = paramValues[j]; if ((!paramValue.isValid()) || (!paramValue.isUploaded())) { paramValues[j] = null; } } } final Object value = (paramValues.length == 1 ? paramValues[0] : paramValues); target.writeValue(name, value, true); } }); } } \nResponse:", "ground_truth": "Inject uploaded files from multipart request parameters.", "predict": " Inject uploaded files into Targets. @param servletRequest servlet request. @param targets Targets to inject."}
{"ID": 723, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertPropertyNameToColumnName(final String propertyName) { StringBuilder tableName = new StringBuilder(propertyName.length() * 2); if (splitCamelCase) { String convertedTableName = Format.fromCamelCase(propertyName, separatorChar); tableName.append(convertedTableName); } else { tableName.append(propertyName); } if (!changeCase) { return tableName.toString(); } return uppercase ? toUppercase(tableName).toString() : toLowercase(tableName).toString(); } \nResponse:", "ground_truth": "Converts property name to column name.", "predict": " Convert property name to column name. @param propertyName the property name @return the column name"}
{"ID": 724, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String convertColumnNameToPropertyName(final String columnName) { StringBuilder propertyName = new StringBuilder(columnName.length()); int len = columnName.length(); if (splitCamelCase) { boolean toUpper = false; for (int i = 0; i < len; i++) { char c = columnName.charAt(i); if (c == separatorChar) { toUpper = true; continue; } if (toUpper) { propertyName.append(Character.toUpperCase(c)); toUpper = false; } else { propertyName.append(Character.toLowerCase(c)); } } return propertyName.toString(); } return columnName; } \nResponse:", "ground_truth": "Converts column name to property name.", "predict": " Convert column name to property name. @param columnName the column name @return the string\n*/"}
{"ID": 725, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String applyToColumnName(final String columnName) { String propertyName = convertColumnNameToPropertyName(columnName); return convertPropertyNameToColumnName(propertyName); } \nResponse:", "ground_truth": "Applies column naming strategy to given column name hint.\nReturns full column name.", "predict": " Convert the column name to property name. @param columnName the column name @return the string\n */"}
{"ID": 726, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void storeValue(final PreparedStatement st, final int index, final Object value, final int dbSqlType) throws SQLException { T t = TypeConverterManager.get().convertType(value, sqlType); set(st, index, t, dbSqlType); } \nResponse:", "ground_truth": "Stores value in database. Value is casted to sql type.", "predict": " Store the value in PreparedStatement. @param st PreparedStatement to store the value. @param index Index of the value. @param value Value to store. @param dbSqlType JDBC type of the value. @throws SQLException If fails."}
{"ID": 727, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected <E> E prepareGetValue(final T t, final Class<E> destinationType) { if (t == null) { return null; } if (destinationType == null) { return (E) t; } return TypeConverterManager.get().convertType(t, destinationType); } \nResponse:", "ground_truth": "Once when value is read from result set, prepare it to match destination type.\n@param t get value\n@param destinationType destination type", "predict": " Convert the T object into a E object. @param t The T object. @param destinationType The destination type. @return The E object."}
{"ID": 728, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Set<T> getAll() { final Set<T> set = new HashSet<>(wrappers.size()); set.addAll(wrappers.values()); return set; } \nResponse:", "ground_truth": "Returns all action wrappers. Returns a copy in new set.", "predict": " Returns all wrappers. Useful for testing.\n@return all wrappers\n*/"}
{"ID": 729, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T resolve(final Class<? extends T> wrapperClass) { String wrapperClassName = wrapperClass.getName(); T wrapper = lookup(wrapperClassName); if (wrapper == null) { wrapper = createWrapper(wrapperClass); initializeWrapper(wrapper); wrappers.put(wrapperClassName, wrapper); } return wrapper; } \nResponse:", "ground_truth": "Resolves single wrapper. Creates new wrapper instance if not already registered.\nDoes not expand the wrappers.", "predict": " Looks up a previously created wrapper for the given class. If no wrapper exists, creates a new one. @param wrapperClass the wrapper class to resolve @return the resolved wrapper\n*/"}
{"ID": 730, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <R extends T> R createWrapper(final Class<R> wrapperClass) { try { return ClassUtil.newInstance(wrapperClass); } catch (Exception ex) { throw new MadvocException(\"Invalid Madvoc wrapper: \" + wrapperClass, ex); } } \nResponse:", "ground_truth": "Creates new wrapper.", "predict": " Creates Madvoc wrapper. @param wrapperClass Madvoc wrapper class. @return Madvoc wrapper instance."}
{"ID": 731, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String separatorsToSystem(final String path) { if (path == null) { return null; } if (SYSTEM_SEPARATOR == WINDOWS_SEPARATOR) { return separatorsToWindows(path); } else { return separatorsToUnix(path); } } \nResponse:", "ground_truth": "Converts all separators to the system separator.\n\n@param path  the path to be changed, null ignored\n@return the updated path", "predict": " Convert separators to system. @param path Path to convert. @return Converted path."}
{"ID": 732, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String doGetPath(final String filename, final int separatorAdd) { if (filename == null) { return null; } int prefix = getPrefixLength(filename); if (prefix < 0) { return null; } int index = indexOfLastSeparator(filename); int endIndex = index + separatorAdd; if (prefix >= filename.length() || index < 0 || prefix >= endIndex) { return StringPool.EMPTY; } return filename.substring(prefix, endIndex); } \nResponse:", "ground_truth": "Does the work of getting the path.\n\n@param filename  the filename\n@param separatorAdd  0 to omit the end separator, 1 to return it\n@return the path", "predict": " Returns the path from a full filename, which excludes the prefix. Whitespace is trimmed from the end of the path. @param filename the filename to query, may be null @param separatorAdd how many characters to add to the separator @return the path, or \"\""}
{"ID": 733, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] split(final String filename) { String prefix = getPrefix(filename); if (prefix == null) { prefix = StringPool.EMPTY; } int lastSeparatorIndex = indexOfLastSeparator(filename); int lastExtensionIndex = indexOfExtension(filename); String path; String baseName; String extension; if (lastSeparatorIndex == -1) { path = StringPool.EMPTY; if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } else { path = filename.substring(prefix.length(), lastSeparatorIndex + 1); if (lastExtensionIndex == -1) { baseName = filename.substring(prefix.length() + path.length()); extension = StringPool.EMPTY; } else { baseName = filename.substring(prefix.length() + path.length(), lastExtensionIndex); extension = filename.substring(lastExtensionIndex + 1); } } return new String[] {prefix, path, baseName, extension}; } \nResponse:", "ground_truth": "Splits filename into a array of four Strings containing prefix, path, basename and extension.\nPath will contain ending separator.", "predict": " Splits the given filename into prefix, path and extension parts. @param filename The filename to split. Shall not be <code>null</code>. @return The splitted parts. Shall not be <code>null</code>. Shall contain four elements. Shall not contain any <code>null</code> elements. Shall not contain empty elements. Shall not contain duplicate elements. Shall not contain elements starting with dot. Shall not contain elements ending with dot. Shall not contain dot appearing anywhere except at the beginning of the filename. Shall not contain dot appearing anywhere except at the end of the filename. Shall not contain dot appearing anywhere except at the beginning of the extension. Shall not contain dot appearing anywhere except at the end of the extension. Shall not contain dot appearing anywhere except at the beginning of the path. Shall not contain dot appearing anywhere except at the end of the path. Shall not contain dot appearing anywhere except at the beginning of the base name. Shall not contain dot appearing anywhere except at the end of the base name. Shall not contain dot appearing anywhere except at"}
{"ID": 734, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String relativePath(final String targetPath, final String basePath) { return new File(basePath).toPath().relativize(new File(targetPath).toPath()).toString(); } \nResponse:", "ground_truth": "Calculates relative path of target path on base path.", "predict": " Calculates the relative path of the targetPath relatively to the basePath. @param targetPath The target path. @param basePath The base path. @return The relative path."}
{"ID": 735, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp registerComponent(final Class<?> madvocComponent) { Objects.requireNonNull(madvocComponent); madvocComponents.add(ClassConsumer.of(madvocComponent)); return this; } \nResponse:", "ground_truth": "Registers additional Madvoc components after the registration of default components.", "predict": " Register Madvoc component. Madvoc components are Madvoc Interceptors, Madvoc Filters, Madvoc interceptors and Madvoc filters. Madvoc components are Madvoc Interceptors and Madvoc Filters. They are registered automatically by Madvoc container. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. They are registered by Madvoc container automatically. Therefore, you don't need to register them manually. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. Therefore, you don't need to register them manually. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. Therefore, you don't need to register them manually. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. Therefore, you don't need to register them manually. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. Therefore, you don't need to register them manually. Madvoc Interceptors and Madvoc Filters are Madvoc extensions. Therefore, you don't need to register them manually. Madvoc Interceptors and Mad"}
{"ID": 736, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <A extends ActionConfig> WebApp withActionConfig(final Class<A> actionConfigType, final Consumer<A> actionConfigConsumer) { withRegisteredComponent(ActionConfigManager.class, acm -> acm.with(actionConfigType, actionConfigConsumer)); return this; } \nResponse:", "ground_truth": "Configures the action configurations.", "predict": " Allows injecting arbitrary ActionConfig implementations into the DI container. Useful for mocking purposes. @param actionConfigType The type of ActionConfig to inject. @param actionConfigConsumer The consumer that will be invoked with the injected ActionConfig. @param <A> The type of ActionConfig to inject. @return The web application builder.\n*/"}
{"ID": 737, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WebApp start() { log = LoggerFactory.getLogger(WebApp.class); log.debug(\"Initializing Madvoc WebApp\"); //// params & props for (final Map<String, Object> params : paramsList) { madvocContainer.defineParams(params); } for (final Props props : propsList) { madvocContainer.defineParams(props); } propsList = null; //// components registerMadvocComponents(); madvocComponents.forEach( madvocComponent -> madvocContainer.registerComponent(madvocComponent.type(), madvocComponent.consumer())); madvocComponents = null; madvocComponentInstances.forEach(madvocContainer::registerComponentInstance); madvocComponentInstances = null; configureDefaults(); //// listeners madvocContainer.fireEvent(Init.class); //// component configuration componentConfigs.accept(madvocContainer); componentConfigs = null; initialized(); madvocContainer.fireEvent(Start.class); if (!madvocRouterConsumers.isEmpty()) { final MadvocRouter madvocRouter = MadvocRouter.create(); madvocContainer.registerComponentInstance(madvocRouter); madvocRouterConsumers.accept(madvocRouter); } madvocRouterConsumers = null; started(); madvocContainer.fireEvent(Ready.class); ready(); return this; } \nResponse:", "ground_truth": "Initializes and starts web application.", "predict": " Starts Madvoc web application. Madvoc components are initialized and Madvoc router consumer is registered. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router consumer is Madvoc Router consumer. Madvoc router consumer is optional. Madvoc router"}
{"ID": 738, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void configureDefaults() { final ActionConfigManager actionConfigManager = madvocContainer.lookupComponent(ActionConfigManager.class); actionConfigManager.registerAnnotation(Action.class); actionConfigManager.registerAnnotation(RestAction.class); } \nResponse:", "ground_truth": "Configure defaults.", "predict": " Configures Madvoc defaults. Usually you don't need to override this method. Instead, override other Madvoc features you wish to customize. @see madvoc.MadvocConfigurerMadvocConfigurer\n*/"}
{"ID": 739, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerMadvocComponents() { if (madvocContainer == null) { throw new MadvocException(\"Madvoc WebApp not initialized.\"); } log.debug(\"Registering Madvoc WebApp components\"); madvocContainer.registerComponent(MadvocEncoding.class); madvocContainer.registerComponentInstance(new ServletContextProvider(servletContext)); madvocContainer.registerComponent(ActionConfigManager.class); madvocContainer.registerComponent(ActionMethodParamNameResolver.class); madvocContainer.registerComponent(ActionMethodParser.class); madvocContainer.registerComponent(ActionPathRewriter.class); madvocContainer.registerComponent(ActionsManager.class); madvocContainer.registerComponent(ContextInjectorComponent.class); madvocContainer.registerComponent(InterceptorsManager.class); madvocContainer.registerComponent(FiltersManager.class); madvocContainer.registerComponent(MadvocController.class); madvocContainer.registerComponent(RootPackages.class); madvocContainer.registerComponent(ResultsManager.class); madvocContainer.registerComponent(ResultMapper.class); madvocContainer.registerComponent(ScopeResolver.class); madvocContainer.registerComponent(ScopeDataInspector.class); madvocContainer.registerComponent(AsyncActionExecutor.class); madvocContainer.registerComponent(FileUploader.class); } \nResponse:", "ground_truth": "Registers default Madvoc components.", "predict": " Register Madvoc components. Typically MadvocWebApp components are registered during Madvoc initialization. However, you can also register Madvoc components manually. Madvoc components are MadvocWebApp components plus MadvocController. MadvocController is MadvocWebApp component too, but it is not registered automatically. Therefore, MadvocController must be registered manually. MadvocController is needed for MadvocControllerAdvice to work properly. MadvocControllerAdvice is Madvoc component too, but it is not registered automatically. Therefore, MadvocControllerAdvice must be registered manually too. MadvocControllerAdvice is needed for MadvocControllerAdvice to work properly. MadvocControllerAdvice is Madvoc component too, but it is not registered automatically. Therefore, MadvocControllerAdvice must be registered manually too. MadvocControllerAdvice is needed for MadvocControllerAdvice to work properly. MadvocControllerAdvice is Madvoc component too, but it is not registered automatically. Therefore, MadvocControllerAdvice must be registered manually too. MadvocController"}
{"ID": 740, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeJars(final String... excludedJars) { for (final String excludedJar : excludedJars) { rulesJars.exclude(excludedJar); } return this; } \nResponse:", "ground_truth": "Specify excluded jars.", "predict": " Exclude jars from consideration. @param excludedJars jars to exclude. @return this scanner.\n*/"}
{"ID": 741, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeJars(final String... includedJars) { for (final String includedJar : includedJars) { rulesJars.include(includedJar); } return this; } \nResponse:", "ground_truth": "Specify included jars.", "predict": " Adds jars to scan for rules. @param includedJars jars to scan for rules. @return this scanner.\n*/"}
{"ID": 742, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner includeEntries(final String... includedEntries) { for (final String includedEntry : includedEntries) { rulesEntries.include(includedEntry); } return this; } \nResponse:", "ground_truth": "Sets included set of names that will be considered during configuration.\n@see InExRules", "predict": " Allows to include additional entries to scan. @param includedEntries Additional entries to scan. @return This scanner. Never null."}
{"ID": 743, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner excludeEntries(final String... excludedEntries) { for (final String excludedEntry : excludedEntries) { rulesEntries.exclude(excludedEntry); } return this; } \nResponse:", "ground_truth": "Sets excluded names that narrows included set of packages.\n@see InExRules", "predict": " Exclude entries from consideration. @param excludedEntries The entries to exclude. @return The scanner.\n*/"}
{"ID": 744, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanJarFile(final File file) { final ZipFile zipFile; try { zipFile = new ZipFile(file); } catch (IOException ioex) { if (!ignoreException) { throw new FindFileException(\"Invalid zip: \" + file.getName(), ioex); } return; } final Enumeration entries = zipFile.entries(); while (entries.hasMoreElements()) { final ZipEntry zipEntry = (ZipEntry) entries.nextElement(); final String zipEntryName = zipEntry.getName(); try { if (StringUtil.endsWithIgnoreCase(zipEntryName, CLASS_FILE_EXT)) { final String entryName = prepareEntryName(zipEntryName, true); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } else if (includeResources) { final String entryName = prepareEntryName(zipEntryName, false); final ClassPathEntry classPathEntry = new ClassPathEntry(entryName, zipFile, zipEntry); try { scanEntry(classPathEntry); } finally { classPathEntry.closeInputStream(); } } } catch (RuntimeException rex) { if (!ignoreException) { ZipUtil.close(zipFile); throw rex; } } } ZipUtil.close(zipFile); } \nResponse:", "ground_truth": "Scans classes inside single JAR archive. Archive is scanned as a zip file.\n@see #onEntry(ClassPathEntry)", "predict": " Scan the jar file. @param file jar file\n*/"}
{"ID": 745, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void scanClassPath(final File root) { String rootPath = root.getAbsolutePath(); if (!rootPath.endsWith(File.separator)) { rootPath += File.separatorChar; } final FindFile ff = FindFile.create().includeDirs(false).recursive(true).searchPath(rootPath); File file; while ((file = ff.nextFile()) != null) { final String filePath = file.getAbsolutePath(); try { if (StringUtil.endsWithIgnoreCase(filePath, CLASS_FILE_EXT)) { scanClassFile(filePath, rootPath, file, true); } else if (includeResources) { scanClassFile(filePath, rootPath, file, false); } } catch (RuntimeException rex) { if (!ignoreException) { throw rex; } } } } \nResponse:", "ground_truth": "Scans single classpath directory.\n@see #onEntry(ClassPathEntry)", "predict": " Scan the classpath for classes. @param root The root directory of the classpath. Shall not be <code>null</code>.\n"}
{"ID": 746, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] bytecodeSignatureOfType(final Class type) { final String name = 'L' + type.getName().replace('.', '/') + ';'; return name.getBytes(); } \nResponse:", "ground_truth": "Returns type signature bytes used for searching in class file.", "predict": " Generate the bytecode signature of a given type. @param type The type. @return The signature.\n*/"}
{"ID": 747, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ClassScanner scan(final String... paths) { for (final String path : paths) { filesToScan.add(new File(path)); } return this; } \nResponse:", "ground_truth": "Scans provided paths.", "predict": " Scans the given paths for Java classes. @param paths The paths to scan. @return The scanner itself. Useful for chaining."}
{"ID": 748, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() { if (detectEntriesMode) { rulesEntries.detectMode(); } filesToScan.forEach(file -> { final String path = file.getAbsolutePath(); if (StringUtil.endsWithIgnoreCase(path, JAR_FILE_EXT)) { if (!acceptJar(file)) { return; } scanJarFile(file); } else if (file.isDirectory()) { scanClassPath(file); } }); } \nResponse:", "ground_truth": "Starts with the scanner.", "predict": " Starts scanning."}
{"ID": 749, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected JtxTransaction createNewTransaction(final JtxTransactionMode tm, final Object scope, final boolean active) { return new DbJtxTransaction(this, tm, scope, active); } \nResponse:", "ground_truth": "Builds new transaction instance.", "predict": " Again, we cannot rely on Spring TransactionManagerImpl to provide us with a real transaction object. Instead, we have to create one manually. Unfortunately, Spring TransactionManagerImpl does not provide a way to create a real transaction object without activating it. Therefore, we have to do it ourselves. Luckily, we can rely on the fact that we have a dedicated transaction manager. Therefore, we can leverage the knowledge of Spring TransactionManagerImpl to achieve the same goal. Unfortunately, Spring TransactionManagerImpl does not provide a way to create a real transaction object without activating it. Therefore, we have to do it ourselves. Luckily, we can leverage the knowledge of Spring TransactionManagerImpl to achieve the same goal. Unfortunately, Spring TransactionManagerImpl does not provide a way to create a real transaction object without activating it. Therefore, we have to do it ourselves. Luckily, we can leverage the knowledge of Spring TransactionManagerImpl to achieve the same goal. Hopefully, Spring TransactionManagerImpl will provide us with a real transaction object soon. However, Spring TransactionManagerImpl does not provide a way to"}
{"ID": 750, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <S extends MadvocScope> S defaultOrScopeType(final Class<S> scopeClass) { if (scopeClass == null) { return (S) getOrInitScope(RequestScope.class); } return (S) getOrInitScope(scopeClass); } \nResponse:", "ground_truth": "Lookups the scope instance of given scope annotation.\nIf instance does not exist, it will be created, cached and returned.", "predict": " Initialize Madvoc scope with default scope type. Usually Madvoc developers don't need to call this method. Instead, Madvoc developers usually use MadvocConfiguration.madvocConfigurations() method to obtain MadvocConfiguration instances. However, if Madvoc developers want to use MadvocConfiguration.madvocConfigurations() method, they can't obtain MadvocConfiguration instances because MadvocConfiguration instances are singletons. Therefore, Madvoc developers need to use MadvocConfiguration.madvocConfigurations() method to obtain MadvocConfiguration instances. However, if Madvoc developers want to obtain MadvocConfiguration instances, they can't obtain MadvocConfiguration instances because MadvocConfiguration instances are singletons. Therefore, Madvoc developers need to use MadvocConfiguration.madvocConfigurations() method to obtain MadvocConfiguration instances. However, if Madvoc developers want to obtain MadvocConfiguration instances, they can't obtain MadvocConfiguration instances because MadvocConfiguration instances are singletons. Therefore, Madvoc developers need to use MadvocConfiguration.madvocConfigurations() method"}
{"ID": 751, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MadvocScope getOrInitScope(final Class<? extends MadvocScope> madvocScopeType) { for (final MadvocScope s : allScopes) { if (s.getClass().equals(madvocScopeType)) { return s; } } // new scope detected final MadvocScope newScope; try { newScope = madpc.createBean(madvocScopeType); } catch (Exception ex) { throw new MadvocException(\"Unable to create scope: \" + madvocScopeType, ex); } allScopes.add(newScope); return newScope; } \nResponse:", "ground_truth": "Performs search for the scope class and returns it's instance.", "predict": " Creates MadvocScope from scratch. Useful for Madvoc extensions. @param madvocScopeType MadvocScope type. @return Newly created MadvocScope. Never null."}
{"ID": 752, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forScope(final Class<? extends MadvocScope> scopeType, final Consumer<MadvocScope> madvocScopeConsumer) { final MadvocScope scope = getOrInitScope(scopeType); madvocScopeConsumer.accept(scope); } \nResponse:", "ground_truth": "Finds a given scope and consumes it.", "predict": " Register MadvocScope consumer. MadvocScope consumer is executed BEFORE MadvocScopeFilter. Therefore, MadvocScopeFilter is executed BEFORE MadvocScopeFilterConsumer. Therefore, MadvocScopeFilterConsumer is executed BEFORE MadvocScopeMadvocConfiguratorMadvocScopeMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvocConfiguratorMadvoc"}
{"ID": 753, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] decode(final char[] arr) { int length = arr.length; if (length == 0) { return new byte[0]; } int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length > 76 ? (arr[76] == '\\r' ? cnt / 78 : 0) << 1 : 0; int len = ((cnt - sepCnt) * 6 >> 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) { int i = INV[arr[sndx++]] << 18 | INV[arr[sndx++]] << 12 | INV[arr[sndx++]] << 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i >> 16); dest[d++] = (byte) (i >> 8); dest[d++] = (byte) i; if (sepCnt > 0 && ++cc == 19) { sndx += 2; cc = 0; } } if (d < len) { int i = 0; for (int j = 0; sndx <= endx - pad; j++) { i |= INV[arr[sndx++]] << (18 - j * 6); } for (int r = 16; d < len; r -= 8) { dest[d++] = (byte) (i >> r); } } return dest; } \nResponse:", "ground_truth": "Decodes a BASE64 encoded char array.", "predict": " Decodes a BASE64 encoded char array. All illegal characters will be ignored and can handle both arrays with and without line separators. @param arr The source array. @return The decoded array of bytes. Or <code>null</code> if the legal characters (including '=') isn't divideable by 4."}
{"ID": 754, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static String prepareCsrfToken(final HttpSession session, final int timeToLive) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if (tokenSet == null) { tokenSet = new HashSet<>(); session.setAttribute(CSRF_TOKEN_SET, tokenSet); } String value; boolean unique; do { value = RandomString.get().randomAlphaNumeric(32); assureSize(tokenSet); unique = tokenSet.add(new Token(value, timeToLive)); } while (!unique); return value; } \nResponse:", "ground_truth": "Generates new CSRF token and puts it in the session. Returns generated token value.", "predict": " Generate a CSRF token for the current session. The token will be valid for the given TTL. @param session The HTTP session. @param timeToLive The TTL for the token. @return The generated CSRF token.\n*/"}
{"ID": 755, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static void assureSize(final Set<Token> tokenSet) { if (tokenSet.size() < maxTokensPerSession) { return; } long validUntilMin = Long.MAX_VALUE; Token tokenToRemove = null; Iterator<Token> iterator = tokenSet.iterator(); while (iterator.hasNext()) { Token token = iterator.next(); if (token.isExpired()) { iterator.remove(); continue; } if (token.validUntil < validUntilMin) { validUntilMin = token.validUntil; tokenToRemove = token; } } if ((tokenToRemove != null) && (tokenSet.size() >= maxTokensPerSession)) { tokenSet.remove(tokenToRemove); } } \nResponse:", "ground_truth": "Removes expired tokens if token set is full.\n@see #setMaxTokensPerSession(int)", "predict": " assureSize assures that the set has enough capacity to accommodate at least one more token. If necessary, it removes expired tokens from the set.\n*/"}
{"ID": 756, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static boolean checkCsrfToken(final HttpSession session, final String tokenValue) { Set<Token> tokenSet = (Set<Token>) session.getAttribute(CSRF_TOKEN_SET); if ((tokenSet == null) && (tokenValue == null)) { return true; } if ((tokenSet == null) || (tokenValue == null)) { return false; } boolean found = false; Iterator<Token> it = tokenSet.iterator(); while (it.hasNext()) { Token t = it.next(); if (t.isExpired()) { it.remove(); continue; } if (t.getValue().equals(tokenValue)) { it.remove(); found = true; } } return found; } \nResponse:", "ground_truth": "Checks token value.\nC", "predict": " Check if the CSRF token is valid. @param session Session to check. @param tokenValue Token value to check. @return True if the token is valid, false otherwise."}
{"ID": 757, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static BeanCopy from(final Object source) { BeanCopy beanCopy = new BeanCopy(source); beanCopy.isSourceMap = source instanceof Map; return beanCopy; } \nResponse:", "ground_truth": "Defines source, detects a map.", "predict": " Copy from source. @param source source @return BeanCopy"}
{"ID": 758, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void copy() { beanUtil = new BeanUtilBean() .declared(declared) .forced(forced) .silent(true); visit(); } \nResponse:", "ground_truth": "Performs the copying.", "predict": " Copy the bean. Useful for copying referenced beans."}
{"ID": 759, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected boolean visitProperty(String name, final Object value) { if (isTargetMap) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } beanUtil.setProperty(destination, name, value); return true; } \nResponse:", "ground_truth": "Copies single property to the destination.\nExceptions are ignored, so copying continues if\ndestination does not have some of the sources properties.", "predict": " Visit a property of the bean. @param name Name of the property. @param value Value of the property. @return True if visiting should continue, false otherwise. Returning false skips visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false leads to ignoring deeper nested beans. Returning true leads to visiting deeper nested beans. Returning false"}
{"ID": 760, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final TemplateData templateData) { super.init(templateData); if (entity != null) { ded = lookupType(entity); } else { Object object = templateData.getObjectReference(entityName); if (object != null) { ded = lookupType(resolveClass(object)); } else { ded = lookupName(entityName); } } String tableReference = this.tableReference; if (tableReference == null) { tableReference = tableAlias; } if (tableReference == null) { tableReference = entityName; } if (tableReference == null) { tableReference = ded.getEntityName(); } templateData.registerTableReference(tableReference, ded, tableAlias); } \nResponse:", "ground_truth": "Resolves and registers table references.", "predict": " Initializes the embedded class. @param templateData TemplateData instance."}
{"ID": 761, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <S extends Scope> S resolveScope(final Class<S> scopeType) { S scope = (S) scopes.get(scopeType); if (scope == null) { try { scope = newInternalInstance(scopeType, (PetiteContainer) this); } catch (Exception ex) { throw new PetiteException(\"Invalid Petite scope: \" + scopeType.getName(), ex); } registerScope(scopeType, scope); scopes.put(scopeType, scope); } return scope; } \nResponse:", "ground_truth": "Resolves and registers scope from a scope type.", "predict": " Resolves Petite scope by its type. Scope is created if it doesn't exist yet. @param scopeType Petite scope type @param <S> Petite scope type @return Petite scope\n*/"}
{"ID": 762, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> BeanDefinition<T> registerPetiteBean( final Class<T> type, String name, Class<? extends Scope> scopeType, WiringMode wiringMode, final boolean define, final Consumer<T> consumer ) { if (name == null) { name = resolveBeanName(type); } if (wiringMode == null) { wiringMode = annotationResolver.resolveBeanWiringMode(type); } if (wiringMode == WiringMode.DEFAULT) { wiringMode = petiteConfig.getDefaultWiringMode(); } if (scopeType == null) { scopeType = annotationResolver.resolveBeanScopeType(type); } if (scopeType == null) { scopeType = SingletonScope.class; } // remove existing bean BeanDefinition existing = removeBean(name); if (existing != null) { if (petiteConfig.getDetectDuplicatedBeanNames()) { throw new PetiteException( \"Duplicated bean name detected while registering class '\" + type.getName() + \"'. Petite bean class '\" + existing.type.getName() + \"' is already registered with the name: \" + name); } } // check if type is valid if (type.isInterface()) { throw new PetiteException(\"PetiteBean can not be an interface: \" + type.getName()); } // registration if (log.isDebugEnabled()) { log.info(\"Petite bean: [\" + name + \"] --> \" + type.getName() + \" @ \" + scopeType.getSimpleName() + \":\" + wiringMode.toString()); } // register Scope scope = resolveScope(scopeType); BeanDefinition<T> beanDefinition = createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); registerBean(name, beanDefinition); // providers ProviderDefinition[] providerDefinitions = petiteResolvers.resolveProviderDefinitions(type, name); if (providerDefinitions != null) { for (ProviderDefinition providerDefinition : providerDefinitions) { providers.put(providerDefinition.name, providerDefinition); } } // define if (define) { beanDefinition.ctor = petiteResolvers.resolveCtorInjectionPoint(beanDefinition.type()); beanDefinition.properties = PropertyInjectionPoint.EMPTY; beanDefinition.methods = MethodInjectionPoint.EMPTY; beanDefinition.initMethods = InitMethodPoint.EMPTY; beanDefinition.destroyMethods = DestroyMethodPoint.EMPTY; } // return return beanDefinition; } \nResponse:", "ground_truth": "Registers or defines a bean.\n\n@param type bean type, must be specified\n@param name bean name, if <code>null</code> it will be resolved from the class (name or annotation)\n@param scopeType bean scope, if <code>null</code> it will be resolved from the class (annotation or default one)\n@param wiringMode wiring mode, if <code>null</code> it will be resolved from the class (annotation or default one)\n@param define when set to <code>true</code> bean will be defined - all injection points will be set to none", "predict": " Registers Petite bean with given name. @param type petite bean type @param name bean name @param scopeType petite scope type @param wiringMode wiring mode @param define defines bean @param consumer consumer of bean\n@return bean definition\n*/"}
{"ID": 763, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerBean(final String name, final BeanDefinition beanDefinition) { beans.put(name, beanDefinition); if (!petiteConfig.isUseAltBeanNames()) { return; } Class type = beanDefinition.type(); if (annotationResolver.beanHasAnnotationName(type)) { return; } Class[] interfaces = ClassUtil.resolveAllInterfaces(type); for (Class anInterface : interfaces) { String altName = annotationResolver.resolveBeanName(anInterface, petiteConfig.getUseFullTypeNames()); if (name.equals(altName)) { continue; } if (beans.containsKey(altName)) { continue; } if (beansAlt.containsKey(altName)) { BeanDefinition existing = beansAlt.get(altName); if (existing != null) { beansAlt.put(altName, null); // store null as value to mark that alt name is duplicate } } else { beansAlt.put(altName, beanDefinition); } } } \nResponse:", "ground_truth": "Registers bean definition by putting it in the beans map. If bean does\nnot have petite name explicitly defined, alternative bean names\nwill be registered.", "predict": " Register bean. Bean name is automatically generated if Petite annotation is not used. @param name Name of bean. @param beanDefinition Bean definition."}
{"ID": 764, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeBean(final Class type) { // collect bean names Set<String> beanNames = new HashSet<>(); for (BeanDefinition def : beans.values()) { if (def.type.equals(type)) { beanNames.add(def.name); } } // remove collected bean names for (String beanName : beanNames) { removeBean(beanName); } } \nResponse:", "ground_truth": "Removes all petite beans of provided type. Bean name is not resolved from a type!\nInstead, all beans are iterated and only beans with equal types are removed.\n@see #removeBean(String)", "predict": " Remove all beans of given type. @param type The bean type to remove."}
{"ID": 765, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] resolveBeanNamesForType(final Class type) { String[] beanNames = beanCollections.get(type); if (beanNames != null) { return beanNames; } ArrayList<String> list = new ArrayList<>(); for (Map.Entry<String, BeanDefinition> entry : beans.entrySet()) { BeanDefinition beanDefinition = entry.getValue(); if (ClassUtil.isTypeOf(beanDefinition.type, type)) { String beanName = entry.getKey(); list.add(beanName); } } if (list.isEmpty()) { beanNames = StringPool.EMPTY_ARRAY; } else { beanNames = list.toArray(new String[0]); } beanCollections.put(type, beanNames); return beanNames; } \nResponse:", "ground_truth": "Resolves bean names for give type.", "predict": " Resolves bean names for the given type. @param type the type @return the resolved bean names\n*/"}
{"ID": 766, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteCtorInjectionPoint(final String beanName, final Class[] paramTypes, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Constructor constructor = null; if (paramTypes == null) { CtorDescriptor[] ctors = cd.getAllCtorDescriptors(); if (ctors != null && ctors.length > 0) { if (ctors.length > 1) { throw new PetiteException(ctors.length + \" suitable constructor found as injection point for: \" + beanDefinition.type.getName()); } constructor = ctors[0].getConstructor(); } } else { CtorDescriptor ctorDescriptor = cd.getCtorDescriptor(paramTypes, true); if (ctorDescriptor != null) { constructor = ctorDescriptor.getConstructor(); } } if (constructor == null) { throw new PetiteException(\"Constructor not found: \" + beanDefinition.type.getName()); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(constructor, references); beanDefinition.ctor = new CtorInjectionPoint(constructor, ref); } \nResponse:", "ground_truth": "Registers constructor injection point.\n\n@param beanName bean name\n@param paramTypes constructor parameter types, may be <code>null</code>\n@param references references for arguments", "predict": " Registers Petite injection point for constructor injection. Petite will inject constructor arguments into bean constructor using reflection. @param beanName Petite bean name. @param paramTypes constructor parameter types. @param references References to inject. References can be Spring bean names, Spring bean names or Strings denoting Spring bean names. References can also be Spring bean instances themselves. References can be petite beans too. @see PetiteBeans PetiteBeans utility class."}
{"ID": 767, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetitePropertyInjectionPoint(final String beanName, final String property, final String reference) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } BeanReferences ref = referencesResolver.resolveReferenceFromValue(propertyDescriptor, reference); PropertyInjectionPoint pip = new PropertyInjectionPoint(propertyDescriptor, ref); beanDefinition.addPropertyInjectionPoint(pip); } \nResponse:", "ground_truth": "Registers property injection point.\n\n@param beanName bean name\n@param property property name\n@param reference explicit injection reference, may be <code>null</code>", "predict": " Registers injection point for Petite bean property injection. Petite will inject requested bean property value into bean instance. @param beanName Petite bean name. @param property Property name. @param reference Reference to inject."}
{"ID": 768, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteSetInjectionPoint(final String beanName, final String property) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); PropertyDescriptor propertyDescriptor = cd.getPropertyDescriptor(property, true); if (propertyDescriptor == null) { throw new PetiteException(\"Property not found: \" + beanDefinition.type.getName() + '#' + property); } SetInjectionPoint sip = new SetInjectionPoint(propertyDescriptor); beanDefinition.addSetInjectionPoint(sip); } \nResponse:", "ground_truth": "Registers set injection point.\n\n@param beanName bean name\n@param property set property name", "predict": " Petite injection point for Set injection. Petite will automatically convert injected Set into unmodifiable Set. @param beanName Spring bean name of the Petite bean. @param property Spring bean property name of the Petite bean. Typically you don't have to specify this parameter - Petite will autodetect it. However, if you'd like to specify a particular bean property, you can use this parameter. Spring bean property name conventions are usually followed in Spring XML files: beanName#propertyName. For example, if you'd like to autodetect Petite bean name'myPetiteBean' and Spring bean property 'foo', you'd use'myPetiteBean#foo'. Alternatively, you can specify 'foo' as Spring bean property name."}
{"ID": 769, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteMethodInjectionPoint(final String beanName, final String methodName, final Class[] arguments, final String[] references) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); Method method = null; if (arguments == null) { MethodDescriptor[] methods = cd.getAllMethodDescriptors(methodName); if (methods != null && methods.length > 0) { if (methods.length > 1) { throw new PetiteException(methods.length + \" suitable methods found as injection points for: \" + beanDefinition.type.getName() + '#' + methodName); } method = methods[0].getMethod(); } } else { MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md != null) { method = md.getMethod(); } } if (method == null) { throw new PetiteException(\"Method not found: \" + beanDefinition.type.getName() + '#' + methodName); } BeanReferences[] ref = referencesResolver.resolveReferenceFromValues(method, references); MethodInjectionPoint mip = new MethodInjectionPoint(method, ref); beanDefinition.addMethodInjectionPoint(mip); } \nResponse:", "ground_truth": "Registers method injection point.\n\n@param beanName bean name\n@param methodName method name\n@param arguments method arguments, may be <code>null</code>\n@param references injection references", "predict": " Registers Petite method injection point. Petite IoC container will inject dependencies to the method parameters. @param beanName Petite bean name. @param methodName Method name. @param arguments Method arguments. @param references References."}
{"ID": 770, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteInitMethods(final String beanName, final InitMethodInvocationStrategy invocationStrategy, String... initMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (initMethodNames == null) { initMethodNames = StringPool.EMPTY_ARRAY; } int total = initMethodNames.length; InitMethodPoint[] initMethodPoints = new InitMethodPoint[total]; int i; for (i = 0; i < initMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(initMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Init method not found: \" + beanDefinition.type.getName() + '#' + initMethodNames[i]); } initMethodPoints[i] = new InitMethodPoint(md.getMethod(), i, invocationStrategy); } beanDefinition.addInitMethodPoints(initMethodPoints); } \nResponse:", "ground_truth": "Registers init method.\n\n@param beanName bean name\n@param invocationStrategy moment of invocation\n@param initMethodNames init method names", "predict": " Registers petite init methods for given bean name. Useful for declarative approach. @param beanName Petite bean name. @param invocationStrategy Init method invocation strategy. @param initMethodNames Init method names."}
{"ID": 771, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteDestroyMethods(final String beanName, String... destroyMethodNames) { BeanDefinition beanDefinition = lookupExistingBeanDefinition(beanName); ClassDescriptor cd = ClassIntrospector.get().lookup(beanDefinition.type); if (destroyMethodNames == null) { destroyMethodNames = StringPool.EMPTY_ARRAY; } int total = destroyMethodNames.length; DestroyMethodPoint[] destroyMethodPoints = new DestroyMethodPoint[total]; int i; for (i = 0; i < destroyMethodNames.length; i++) { MethodDescriptor md = cd.getMethodDescriptor(destroyMethodNames[i], ClassUtil.EMPTY_CLASS_ARRAY, true); if (md == null) { throw new PetiteException(\"Destroy method not found: \" + beanDefinition.type.getName() + '#' + destroyMethodNames[i]); } destroyMethodPoints[i] = new DestroyMethodPoint(md.getMethod()); } beanDefinition.addDestroyMethodPoints(destroyMethodPoints); } \nResponse:", "ground_truth": "Registers destroy method.\n\n@param beanName bean name\n@param destroyMethodNames destroy method names", "predict": " Registers destroy methods for Petite beans. Destroy methods are called when Petite IoC container destroys bean instances. Destroy methods are called in reversed order of registration. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are called in reversed order of destruction. Destroy methods are"}
{"ID": 772, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteProvider(final String providerName, final String beanName, final String methodName, final Class[] arguments) { BeanDefinition beanDefinition = lookupBeanDefinition(beanName); if (beanDefinition == null) { throw new PetiteException(\"Bean not found: \" + beanName); } Class beanType = beanDefinition.type; ClassDescriptor cd = ClassIntrospector.get().lookup(beanType); MethodDescriptor md = cd.getMethodDescriptor(methodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + methodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, beanName, md.getMethod()); providers.put(providerName, providerDefinition); } \nResponse:", "ground_truth": "Registers instance method provider.\n\n@param providerName provider name\n@param beanName bean name\n@param methodName instance method name\n@param arguments method argument types", "predict": " Registers Petite provider bean. Petite will inject dependencies to the method of this provider. @param providerName Petite bean name of the provider. @param beanName Name of the Petite bean. @param methodName Name of the provider method. @param arguments Provider method arguments."}
{"ID": 773, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPetiteProvider(final String providerName, final Class type, final String staticMethodName, final Class[] arguments) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor md = cd.getMethodDescriptor(staticMethodName, arguments, true); if (md == null) { throw new PetiteException(\"Provider method not found: \" + staticMethodName); } ProviderDefinition providerDefinition = new ProviderDefinition(providerName, md.getMethod()); providers.put(providerName, providerDefinition); } \nResponse:", "ground_truth": "Registers static method provider.\n\n@param providerName provider name\n@param type class type\n@param staticMethodName static method name\n@param arguments method argument types", "predict": " Registers Petite provider. Petite will use this provider to create instances of beans. @param providerName Petite provider name. @param type Provider type. @param staticMethodName Provider static method name. @param arguments Provider static method arguments."}
{"ID": 774, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachBeanType(final Class type, final Consumer<String> beanNameConsumer) { forEachBean(bd -> { if (ClassUtil.isTypeOf(bd.type, type)) { beanNameConsumer.accept(bd.name); } }); } \nResponse:", "ground_truth": "Iterates all beans that are of given type.", "predict": " For each bean type, consumer bean name. @param type Consumer bean name. @since 0.7.0 @see com.github.eemmiirr.redis2json.annotation.RedisBean @see com.github.eemmiirr.redis2json.command.CommandKeyScan @see com.github.eemmiirr.redis2json.command.CommandScan\n"}
{"ID": 775, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void defineParameters(final Map<?, ?> properties) { for (Map.Entry<?, ?> entry : properties.entrySet()) { defineParameter(entry.getKey().toString(), entry.getValue()); } } \nResponse:", "ground_truth": "Defines many parameters at once.", "predict": " Define the parameters for this processor. @param properties The properties to define.\n*/"}
{"ID": 776, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object intercept(final ActionRequest actionRequest) throws Exception { printBefore(actionRequest); long startTime = System.currentTimeMillis(); Object result = null; try { result = actionRequest.invoke(); } catch (Exception ex) { result = \"<exception>\"; throw ex; } catch (Throwable th) { result = \"<throwable>\"; throw new Exception(th); } finally { long executionTime = System.currentTimeMillis() - startTime; printAfter(actionRequest, executionTime, result); } return result; } \nResponse:", "ground_truth": "Measure action invocation time.", "predict": " Interceptor for monitoring purpose. @param actionRequest intercepted action request @return intercepted action result\n*/"}
{"ID": 777, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int resolveJavaVersion(final int version) { final int javaVersionNumber = SystemUtil.info().getJavaVersionNumber(); final int platformVersion = javaVersionNumber - 8 + 52; return version > platformVersion ? version : platformVersion; } \nResponse:", "ground_truth": "Resolves Java version from current version.", "predict": " Resolve the java version number. @param version the version number to resolve. @return the resolved version number."}
{"ID": 778, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void pushInt(final MethodVisitor mv, final int value) { if (value <= 5) { mv.visitInsn(ICONST_0 + value); } else if (value <= Byte.MAX_VALUE) { mv.visitIntInsn(BIPUSH, value); } else { mv.visitIntInsn(SIPUSH, value); } } \nResponse:", "ground_truth": "Pushes int value in an optimal way.", "predict": " Push a constant integer value onto the operand stack. This is a special purpose method which differs from the other commonly used methods in pushing constants onto the operand stack. Rather than a single value, a series of values may be pushed onto the operand stack. The benefit of pushing several values rather than one value is that the compiler can perform several optimization passes while compiling the method. The downside is that the compiler cannot verify that the values were pushed onto the operand stack in the exact same order that they were pushed onto the operand stack. Therefore, care must be taken to ensure that the values are pushed onto the operand stack in exactly the order that they were pushed onto the operand stack. Generally speaking, the compiler will automatically push several values onto the operand stack in the correct order, but there are exceptions. For example, if a method pushes several values onto the operand stack, and then performs a conditional branch on one of those values, the compiler cannot necessarily determine which branch will be taken. Therefore, the safest approach is to push several values onto"}
{"ID": 779, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkArgumentIndex(final MethodInfo methodInfo, final int argIndex) { if ((argIndex < 1) || (argIndex > methodInfo.getArgumentsCount())) { throw new ProxettaException(\"Invalid argument index: \" + argIndex); } } \nResponse:", "ground_truth": "Validates argument index.", "predict": " Check if argument index is valid. @param methodInfo intercepted method information @param argIndex argument index to check"}
{"ID": 780, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String adviceFieldName(final String name, final int index) { return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index; } \nResponse:", "ground_truth": "Builds advice field name.", "predict": " Advice field name. @param name Field name. @param index Advice index. @return Advice field name."}
{"ID": 781, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String adviceMethodName(final String name, final int index) { return ProxettaNames.methodPrefix + name + ProxettaNames.methodDivider + index; } \nResponse:", "ground_truth": "Builds advice method name.", "predict": " Advice method name. @param name Original method name. @param index Advice index. @return Advice method name."}
{"ID": 782, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadSpecialMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { mv.visitVarInsn(ALOAD, 0); for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKESPECIAL call.", "predict": " Load special method arguments. Basically, pushes all arguments plus the implicit 'this' argument. @param mv Method visitor. @param methodInfo Information about the current method.\n*/"}
{"ID": 783, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadStaticMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 0; i < methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKESTATIC call.", "predict": " Loads all arguments of the given method info. Basically, loads all arguments of the instrumented method minus the THIS argument. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESPECIAL instruction loads exactly the arguments of the instrumented method. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESPECIAL instruction loads exactly the arguments of the instrumented method. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESPECIAL instruction loads exactly the arguments of the instrumented method. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESPECIAL instruction loads exactly the arguments of the instrumented method. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESPECIAL instruction loads exactly the arguments of the instrumented method. Furthermore, loads the instrumented method's ACCESS FLAGS. Therefore, the INVOKESP"}
{"ID": 784, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadVirtualMethodArguments(final MethodVisitor mv, final MethodInfo methodInfo) { for (int i = 1; i <= methodInfo.getArgumentsCount(); i++) { loadMethodArgument(mv, methodInfo, i); } } \nResponse:", "ground_truth": "Loads all method arguments before INVOKEVIRTUAL call.", "predict": " Loads all arguments of the intercepted method. Expects the following IL: POP N POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POP POPOP POP POP POP POP POP POPOP"}
{"ID": 785, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ILOAD, offset); break; case 'J': mv.visitVarInsn(LLOAD, offset); break; case 'F': mv.visitVarInsn(FLOAD, offset); break; case 'D': mv.visitVarInsn(DLOAD, offset); break; default: mv.visitVarInsn(ALOAD, offset); } } \nResponse:", "ground_truth": "Loads one argument. Index is 1-based. No conversion occurs.", "predict": " Loads the argument at the given index from the local variable array. Depending on the type of the argument pushes it onto the operand stack. Primitive types are widened to their boxed counterpart. Strings are widened to their char* counterpart. Widening primitive types are generally cheaper than boxing, so most of the widening conversions are folded statically at compile time. Widening reference types are rarer to encounter, so they are boxed regardless of their boxing cost. Boxing primitives and widening reference types are relatively expensive compared to their boxing counterparts. Widening primitives incur no boxing cost, but boxing cost may be incurred statically at compile time. Widening reference types incur both boxing cost and dynamic casting cost. Widening primitive types incur no boxing cost, but boxing cost may be incurred statically at compile time. Widening reference types incur both boxing cost and dynamic casting cost. Widening primitive types incur no boxing cost, but boxing cost may be incurred statically at compile time. Widening reference types incur both boxing cost and dynamic casting cost. Widening primitive types incur no boxing cost,"}
{"ID": 786, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeMethodArgument(final MethodVisitor mv, final MethodInfo methodInfo, final int index) { int offset = methodInfo.getArgumentOffset(index); int type = methodInfo.getArgument(index).getOpcode(); switch (type) { case 'V': break; case 'B': case 'C': case 'S': case 'I': case 'Z': mv.visitVarInsn(ISTORE, offset); break; case 'J': mv.visitVarInsn(LSTORE, offset); break; case 'F': mv.visitVarInsn(FSTORE, offset); break; case 'D': mv.visitVarInsn(DSTORE, offset); break; default: mv.visitVarInsn(ASTORE, offset); } } \nResponse:", "ground_truth": "Stores one argument. Index is 1-based. No conversion occurs.", "predict": " Stores the argument at the given index in the local variable frame of the method visitor. The fourth bytecode argument denotes the slot index. Therefore, the bytecode arguments are shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore, the fourth bytecode argument denotes the slot index shifted by 3 bits. Therefore"}
{"ID": 787, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareReturnValue(final MethodVisitor mv, final MethodInfo methodInfo, int varOffset) { varOffset += methodInfo.getAllArgumentsSize(); switch (methodInfo.getReturnType().getOpcode()) { case 'V': mv.visitInsn(ACONST_NULL); break; case 'B': AsmUtil.valueOfByte(mv); break; case 'C': AsmUtil.valueOfCharacter(mv); break; case 'S': AsmUtil.valueOfShort(mv); break; case 'I': AsmUtil.valueOfInteger(mv); break; case 'Z': AsmUtil.valueOfBoolean(mv); break; case 'J': AsmUtil.valueOfLong(mv); break; case 'F': AsmUtil.valueOfFloat(mv); break; case 'D': AsmUtil.valueOfDouble(mv); break; } } \nResponse:", "ground_truth": "Prepares return value.", "predict": " Prepares the return value of the intercepted method. Basically, it pushes the return value onto the operand stack. However, if the return type is void, nothing happens. Instead, a NOP instruction is pushed onto the stack. Furthermore, if the return type is primitive, but boxed, the boxing primitive value is pushed onto the stack instead. Therefore, boxing primitives are treated separately. Finally, if the return type is primitive, but neither boxed nor void, the primitive value is pushed onto the stack. However, if the return type is neither primitive nor boxed, but is an array, the array length is pushed onto the stack instead. Lastly, if the return type is neither primitive nor boxed nor void, nor an array, nothing happens. Therefore, boxing primitives are treated separately. Moreover, arrays are treated separately because their length needs to be pushed onto the stack. However, arrays of primitives are treated like primitives. Therefore, boxing primitives are treated separately. Lastly, if the return type is neither primitive nor boxed nor void, nor an array,"}
{"ID": 788, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String createMethodSignaturesKey(final int access, final String methodName, final String description, final String className) { return new StringBand(7) .append(access) .append(COLON) .append(description) .append(StringPool.UNDERSCORE) .append(className) .append(StringPool.HASH) .append(methodName) .toString(); } \nResponse:", "ground_truth": "Creates unique key for method signatures map.", "predict": " Creates the signatures key. @param access the access modifiers. @param methodName the method name. @param description the method description. @param className the declaring class name. @return the signatures key."}
{"ID": 789, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void newArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitIntInsn(NEWARRAY, T_INT); return; } if (componentType == long.class) { mv.visitIntInsn(NEWARRAY, T_LONG); return; } if (componentType == float.class) { mv.visitIntInsn(NEWARRAY, T_FLOAT); return; } if (componentType == double.class) { mv.visitIntInsn(NEWARRAY, T_DOUBLE); return; } if (componentType == byte.class) { mv.visitIntInsn(NEWARRAY, T_BYTE); return; } if (componentType == short.class) { mv.visitIntInsn(NEWARRAY, T_SHORT); return; } if (componentType == boolean.class) { mv.visitIntInsn(NEWARRAY, T_BOOLEAN); return; } if (componentType == char.class) { mv.visitIntInsn(NEWARRAY, T_CHAR); return; } mv.visitTypeInsn(ANEWARRAY, AsmUtil.typeToSignature(componentType)); } \nResponse:", "ground_truth": "Creates new array.", "predict": " Generate anewarray instruction for primitive types or reference types.\n"}
{"ID": 790, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeIntoArray(final MethodVisitor mv, final Class componentType) { if (componentType == int.class) { mv.visitInsn(IASTORE); return; } if (componentType == long.class) { mv.visitInsn(LASTORE); return; } if (componentType == float.class) { mv.visitInsn(FASTORE); return; } if (componentType == double.class) { mv.visitInsn(DASTORE); return; } if (componentType == byte.class) { mv.visitInsn(BASTORE); return; } if (componentType == short.class) { mv.visitInsn(SASTORE); return; } if (componentType == boolean.class) { mv.visitInsn(BASTORE); return; } if (componentType == char.class) { mv.visitInsn(CASTORE); return; } mv.visitInsn(AASTORE); } \nResponse:", "ground_truth": "Stores element on stack into an array.", "predict": " Stores an int, long, float, double, byte, short, boolean or char value from the stack into the given array. Leaves the array on the stack. @param mv the method visitor @param componentType the component type of the array (must be one of int, long, float, double, byte, short, boolean or char)"}
{"ID": 791, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String extractEncoding(final String contentType, String defaultEncoding) { String encoding = extractEncoding(contentType); if (encoding == null) { if (defaultEncoding == null) { defaultEncoding = JoddCore.encoding; } encoding = defaultEncoding; } return encoding; } \nResponse:", "ground_truth": "Extracts encoding from a given content type.\n\n@param contentType     content type.\n@param defaultEncoding Default encoding to be used if extract returns {@code null}.\nIf defaultEncoding is {@code null}, {@link JoddCore#encoding} will be used.\n@return Encoding from the content type.\n@see #extractEncoding(String)", "predict": " Extracts encoding from content type header. Returns default encoding if not found. @param contentType content type header value @param defaultEncoding default encoding to return if not found\n */"}
{"ID": 792, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isEmptyFlags(Flags flags) { if (flags == null) return true; Flags.Flag[] systemFlags = flags.getSystemFlags(); if (systemFlags != null && systemFlags.length > 0) { return false; } String[] userFlags = flags.getUserFlags(); if (userFlags != null && userFlags.length > 0) { return false; } return true; } \nResponse:", "ground_truth": "Check whether flags is a empty flags\n@param flags a flags of message to check\n@return whether the flags is empty", "predict": " Checks if flags are empty. Empty flags consist of only the system flags. Empty user flags consist of only the user flags. @param flags Flags to check. @return True if flags are empty. False otherwise."}
{"ID": 793, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveAuthBearerToken(final HttpServletRequest request) { String header = request.getHeader(HEADER_AUTHORIZATION); if (header == null) { return null; } int ndx = header.indexOf(\"Bearer \"); if (ndx == -1) { return null; } return header.substring(ndx + 7).trim(); } \nResponse:", "ground_truth": "Returns Bearer token.", "predict": " Extract bearer token from authorization header. @param request incoming request\n@return bearer token or null if not found\n*/"}
{"ID": 794, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void requireAuthentication(final HttpServletResponse resp, final String realm) throws IOException { resp.setHeader(WWW_AUTHENTICATE, \"Basic realm=\\\"\" + realm + '\\\"'); resp.sendError(HttpServletResponse.SC_UNAUTHORIZED); } \nResponse:", "ground_truth": "Sends correct headers to require basic authentication for the given realm.", "predict": " Requires BASIC authentication. @param resp the response to require BASIC authentication @param realm the realm to authenticate against @throws IOException if an I/O error occurs\n*/"}
{"ID": 795, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareDownload(final HttpServletResponse response, final File file, final String mimeType) { if (!file.exists()) { throw new IllegalArgumentException(\"File not found: \" + file); } if (file.length() > Integer.MAX_VALUE) { throw new IllegalArgumentException(\"File too big: \" + file); } prepareResponse(response, file.getAbsolutePath(), mimeType, (int) file.length()); } \nResponse:", "ground_truth": "Prepares response for file download with provided mime type.", "predict": " Prepare the download. @param response The HTTP response. @param file The file to download. @param mimeType The MIME type of the file.\n*/"}
{"ID": 796, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void prepareResponse(final HttpServletResponse response, final String fileName, String mimeType, final int fileSize) { if ((mimeType == null) && (fileName != null)) { String extension = FileNameUtil.getExtension(fileName); mimeType = MimeTypes.getMimeType(extension); } if (mimeType != null) { response.setContentType(mimeType); } if (fileSize >= 0) { response.setContentLength(fileSize); } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if (fileName != null) { String name = FileNameUtil.getName(fileName); String encodedFileName = URLCoder.encode(name); response.setHeader(CONTENT_DISPOSITION, \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName); } } \nResponse:", "ground_truth": "Prepares response for various provided data.\n\n@param response http response\n@param fileName file name, if full path then file name will be stripped, if null, will be ignored.\n@param mimeType mime type with optional charset, may be <code>null</code>\n@param fileSize if less then 0 it will be ignored", "predict": " Prepare the response for downloading the file. @param response the HTTP servlet response. @param fileName the file name. @param mimeType the mime type. @param fileSize the file size."}
{"ID": 797, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Cookie[] getAllCookies(final HttpServletRequest request, final String cookieName) { Cookie[] cookies = request.getCookies(); if (cookies == null) { return null; } ArrayList<Cookie> list = new ArrayList<>(cookies.length); for (Cookie cookie : cookies) { if (cookie.getName().equals(cookieName)) { list.add(cookie); } } if (list.isEmpty()) { return null; } return list.toArray(new Cookie[0]); } \nResponse:", "ground_truth": "Returns all cookies from client that matches provided name.\n@see #getCookie(javax.servlet.http.HttpServletRequest, String)", "predict": " Get all cookies with the given name. @param request The request to inspect. @param cookieName The name of the cookie to look for. @return The cookies with the given name, or null if none were found."}
{"ID": 798, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readRequestBodyFromReader(final HttpServletRequest request) throws IOException { BufferedReader buff = request.getReader(); StringWriter out = new StringWriter(); StreamUtil.copy(buff, out); return out.toString(); } \nResponse:", "ground_truth": "Reads HTTP request body using the request reader. Once body is read,\nit cannot be read again!", "predict": " Reads the entire contents of the request body into a String. Useful for examining large POST requests. @param request The request whose body should be read. @return The entire contents of the request body. @throws IOException If an error occurs reading the body.\n*/"}
{"ID": 799, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException { String charEncoding = request.getCharacterEncoding(); if (charEncoding == null) { charEncoding = JoddCore.encoding; } CharArrayWriter charArrayWriter = new CharArrayWriter(); BufferedReader bufferedReader = null; try { InputStream inputStream = request.getInputStream(); if (inputStream != null) { bufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding)); StreamUtil.copy(bufferedReader, charArrayWriter); } else { return StringPool.EMPTY; } } finally { StreamUtil.close(bufferedReader); } return charArrayWriter.toString(); } \nResponse:", "ground_truth": "Reads HTTP request body using the request stream. Once body is read,\nit cannot be read again!", "predict": " Reads request body from servlet request stream. Useful for reading large amounts of data.\n@param request servlet request\n@return request body\n*/"}
{"ID": 800, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeContextPath(final PageContext pageContext, final String contextPathVariableName) { String ctxPath = getContextPath(pageContext); HttpServletRequest request = (HttpServletRequest) pageContext.getRequest(); request.setAttribute(contextPathVariableName, ctxPath); ServletContext servletContext = pageContext.getServletContext(); servletContext.setAttribute(contextPathVariableName, ctxPath); } \nResponse:", "ground_truth": "Stores context path in server context and request scope.", "predict": " Stores the context path in the page context under the given name. Useful for JSP EL. @param pageContext PageContext to store the context path in. @param contextPathVariableName Name under which to store the context path."}
{"ID": 801, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeContextPath(final ServletContext servletContext, final String contextPathVariableName) { String ctxPath = getContextPath(servletContext); servletContext.setAttribute(contextPathVariableName, ctxPath); } \nResponse:", "ground_truth": "Stores context path in page context and request scope.", "predict": " Stores the context path in the servlet context under the given name. Useful for Spring Boot applications, where the context path is not readily available. @param servletContext Servlet context to store the context path in. @param contextPathVariableName Name of the servlet context attribute to store the context path under. Typically \"contextPath\"."}
{"ID": 802, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isGetParameter(final HttpServletRequest request, String name) { name = URLCoder.encodeQueryParam(name) + '='; String query = request.getQueryString(); String[] nameValuePairs = StringUtil.splitc(query, '&'); for (String nameValuePair : nameValuePairs) { if (nameValuePair.startsWith(name)) { return true; } } return false; } \nResponse:", "ground_truth": "Checks if some parameter is in GET parameters.", "predict": " Check if the given parameter is in the query string. @param request The HTTP request. @param name The parameter name. @return True if the parameter is in the query string. False otherwise."}
{"ID": 803, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] prepareParameters( final String[] paramValues, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { if (treatEmptyParamsAsNull || ignoreEmptyRequestParams) { int emptyCount = 0; int total = paramValues.length; for (int i = 0; i < paramValues.length; i++) { String paramValue = paramValues[i]; if (paramValue == null) { emptyCount++; continue; } if (paramValue.length() == 0) { emptyCount++; if (treatEmptyParamsAsNull) { paramValue = null; } } paramValues[i] = paramValue; } if ((ignoreEmptyRequestParams) && (emptyCount == total)) { return null; } } return paramValues; } \nResponse:", "ground_truth": "Prepares parameters for further processing.\n@param paramValues\tstring array of param values\n@param treatEmptyParamsAsNull\tempty parameters should be treated as <code>null</code>\n@param ignoreEmptyRequestParams\tif all parameters are empty, return <code>null</code>", "predict": " Prepares the parameter values to be sent to the server. Empty parameters are substituted by null. Treating empty request parameters as null is indicated by setting the treatEmptyParamsAsNull parameter to true. Ignoring empty request parameters is indicated by setting the ignoreEmptyRequestParams parameter to true. @param paramValues The parameter values to prepare. @param treatEmptyParamsAsNull Treat empty parameters as null. @param ignoreEmptyRequestParams Ignore empty request parameters. @return The prepared parameter values. May be null if the treatEmptyParamsAsNull and ignoreEmptyRequestParams parameters indicate so."}
{"ID": 804, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copyParamsToAttributes( final HttpServletRequest servletRequest, final boolean treatEmptyParamsAsNull, final boolean ignoreEmptyRequestParams) { Enumeration paramNames = servletRequest.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } String[] paramValues = servletRequest.getParameterValues(paramName); paramValues = prepareParameters(paramValues, treatEmptyParamsAsNull, ignoreEmptyRequestParams); if (paramValues == null) { continue; } servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } // multipart if (!(servletRequest instanceof MultipartRequestWrapper)) { return; } MultipartRequestWrapper multipartRequest = (MultipartRequestWrapper) servletRequest; if (!multipartRequest.isMultipart()) { return; } paramNames = multipartRequest.getFileParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); if (servletRequest.getAttribute(paramName) != null) { continue; } FileUpload[] paramValues = multipartRequest.getFiles(paramName); servletRequest.setAttribute(paramName, paramValues.length == 1 ? paramValues[0] : paramValues); } } \nResponse:", "ground_truth": "Copies all request parameters to attributes.", "predict": " Copy request parameters to attributes. @param servletRequest the servlet request\n * @param treatEmptyParamsAsNull Treat empty request params as null.\n * @param ignoreEmptyRequestParams Ignore empty request params.\n */"}
{"ID": 805, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void invokeBody(final JspFragment body) throws JspException { if (body == null) { return; } try { body.invoke(null); } catch (IOException ioex) { throw new JspException(\"Tag body failed\", ioex); } } \nResponse:", "ground_truth": "Invokes tag body.", "predict": " Invokes the given tag fragment. The fragment will be invoked under the same context as the surrounding tags. @param body Tag fragment to invoke.\n * @throws JspException if invoked via a fragment.\n*/"}
{"ID": 806, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] renderBody(final JspFragment body) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter(); invokeBody(body, writer); return writer.toCharArray(); } \nResponse:", "ground_truth": "Renders tag body to char array.", "predict": " Render the body of the given JspFragment. @param body the fragment @return the rendered body\n* @throws JspException in case of difficulties\n*/"}
{"ID": 807, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String renderBodyToString(final JspFragment body) throws JspException { char[] result = renderBody(body); return new String(result); } \nResponse:", "ground_truth": "Renders tag body to string.\n@see #renderBody(javax.servlet.jsp.tagext.JspFragment)", "predict": " Render the body of a JspFragment to a String. @param body The JspFragment whose body to render. @return The rendered body as a String. @throws JspException If an error occurs rendering the body.\n*/"}
{"ID": 808, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void invokeInitMethods(final InitMethodInvocationStrategy invocationStrategy) { for (final InitMethodPoint initMethod : beanDefinition.initMethodPoints()) { if (invocationStrategy != initMethod.invocationStrategy) { continue; } try { initMethod.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid init method: \" + initMethod, ex); } } } \nResponse:", "ground_truth": "Invokes init methods.", "predict": " Invokes init methods according to invocation strategy. @param invocationStrategy Init method invocation strategy.\n*/"}
{"ID": 809, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void callDestroyMethods() { for (final DestroyMethodPoint destroyMethodPoint : beanDefinition.destroyMethodPoints()) { try { destroyMethodPoint.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid destroy method: \" + destroyMethodPoint.method, ex); } } } \nResponse:", "ground_truth": "Calls destroy methods on given BeanData. Destroy methods are called\nwithout any order.", "predict": " Calls destroy methods. Destroy methods are invoked in reversed order. Destroy methods are invoked in reversed order."}
{"ID": 810, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object newBeanInstance() { if (beanDefinition.ctor == CtorInjectionPoint.EMPTY) { throw new PetiteException(\"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition.type.getName()); } int paramNo = beanDefinition.ctor.references.length; Object[] args = new Object[paramNo]; // wiring if (beanDefinition.wiringMode != WiringMode.NONE) { for (int i = 0; i < paramNo; i++) { args[i] = pc.getBean(beanDefinition.ctor.references[i]); if (args[i] == null) { if ((beanDefinition.wiringMode == WiringMode.STRICT)) { throw new PetiteException( \"Wiring constructor failed. References '\" + beanDefinition.ctor.references[i] + \"' not found for constructor: \" + beanDefinition.ctor.constructor); } } } } // create instance final Object bean; try { bean = beanDefinition.ctor.constructor.newInstance(args); } catch (Exception ex) { throw new PetiteException(\"Failed to create new bean instance '\" + beanDefinition.type.getName() + \"' using constructor: \" + beanDefinition.ctor.constructor, ex); } return bean; } \nResponse:", "ground_truth": "Creates a new instance.", "predict": " Creates new Petite bean instance. @return Petite bean instance."}
{"ID": 811, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectParams(final ParamManager paramManager, final boolean implicitParamInjection) { if (beanDefinition.name == null) { return; } if (implicitParamInjection) { // implicit final int len = beanDefinition.name.length() + 1; for (final String param : beanDefinition.params) { final Object value = paramManager.get(param); final String destination = param.substring(len); try { BeanUtil.declared.setProperty(bean, destination, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition.name, ex); } } } // explicit for (final ValueInjectionPoint pip : beanDefinition.values) { final String value = paramManager.parseKeyTemplate(pip.valueTemplate); try { BeanUtil.declared.setProperty(bean, pip.property, value); } catch (Exception ex) { throw new PetiteException(\"Unable to set value for: '\" + pip.valueTemplate + \"' to bean: \" + beanDefinition.name, ex); } } } \nResponse:", "ground_truth": "Injects all parameters.", "predict": " Injects Petite params to bean. @param paramManager Parameter manager. @param implicitParamInjection Automatic param injection is enabled."}
{"ID": 812, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"UnusedDeclaration\"}) public String rewrite(final HttpServletRequest servletRequest, final String actionPath, final String httpMethod) { return actionPath; } \nResponse:", "ground_truth": "Rewrites action path.", "predict": " Rewrite the action path. @param servletRequest the servlet request @param actionPath the action path @param httpMethod the HTTP method @return the rewritten action path\n*/"}
{"ID": 813, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addHeader(final String name, final String value) { List<String> valuesList = super.getAll(name); if (valuesList.isEmpty()) { super.add(name, value); return; } super.remove(name); valuesList.add(value); super.addAll(name, valuesList); } \nResponse:", "ground_truth": "Adds new header value. If existing value exist, it will be removed\nso the store the new key value.", "predict": " Adds header to existing values or creates new header with given value. @param name header name @param value header value"}
{"ID": 814, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void put(final String profile, final Map<String, PropsEntry> map, final String key, final String value, final boolean append) { String realValue = value; if (append || appendDuplicateProps) { PropsEntry pv = map.get(key); if (pv != null) { realValue = pv.value + APPEND_SEPARATOR + realValue; } } PropsEntry propsEntry = new PropsEntry(key, realValue, profile, this); // update position pointers if (first == null) { first = propsEntry; } else { last.next = propsEntry; } last = propsEntry; // add to the map map.put(key, propsEntry); } \nResponse:", "ground_truth": "Puts key-value pair into the map, with respect of appending duplicate properties", "predict": " Put a new PropsEntry into the PropsEntry Map. Also update the pointers. @param profile The profile name. @param map The map to put the PropsEntry into. @param key The key to store. @param value The value to store. @param appendDuplicateProps If true, duplicate props are appended with APPEND_SEPARATOR. Otherwise, they overwrite the old one.\n*/"}
{"ID": 815, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void putBaseProperty(final String key, final String value, final boolean append) { put(null, baseProperties, key, value, append); } \nResponse:", "ground_truth": "Adds base property.", "predict": " Putting base property. @param key the key @param value the value @param append the append flag\n*/"}
{"ID": 816, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void putProfileProperty(final String key, final String value, final String profile, final boolean append) { Map<String, PropsEntry> map = profileProperties.computeIfAbsent(profile, k -> new HashMap<>()); put(profile, map, key, value, append); } \nResponse:", "ground_truth": "Adds profile property.", "predict": " Put profile property. @param key the key @param value the value @param profile the profile @param append the append flag\n*/"}
{"ID": 817, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropsEntry getProfileProperty(final String profile, final String key) { final Map<String, PropsEntry> profileMap = profileProperties.get(profile); if (profileMap == null) { return null; } return profileMap.get(key); } \nResponse:", "ground_truth": "Returns profile property.", "predict": " Get the profile property. @param profile the profile name @param key the key of the property @return the property or null if not found\n*/"}
{"ID": 818, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveMacros(String value, final String... profiles) { // create string template parser that will be used internally StringTemplateParser stringTemplateParser = new StringTemplateParser(); stringTemplateParser.setResolveEscapes(false); if (!ignoreMissingMacros) { stringTemplateParser.setReplaceMissingKey(false); } else { stringTemplateParser.setReplaceMissingKey(true); stringTemplateParser.setMissingKeyReplacement(StringPool.EMPTY); } final Function<String, String> macroResolver = macroName -> { String[] lookupProfiles = profiles; int leftIndex = macroName.indexOf('<'); if (leftIndex != -1) { int rightIndex = macroName.indexOf('>'); String profiles1 = macroName.substring(leftIndex + 1, rightIndex); macroName = macroName.substring(0, leftIndex).concat(macroName.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(profiles1, ','); StringUtil.trimAll(lookupProfiles); } return lookupValue(macroName, lookupProfiles); }; // start parsing int loopCount = 0; while (loopCount++ < MAX_INNER_MACROS) { final String newValue = stringTemplateParser.parse(value, macroResolver); if (newValue.equals(value)) { break; } if (skipEmptyProps) { if (newValue.length() == 0) { return null; } } value = newValue; } return value; } \nResponse:", "ground_truth": "Resolves all macros in this props set. Called on property lookup.", "predict": " Resolves macros in the given string using the given profiles. @param value The string to resolve macros in. @param profiles Profiles to use for resolving macros. @return The resolved string."}
{"ID": 819, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) { if (target == null) { target = new HashMap(); } // make sure prefix ends with a dot if (prefix != null) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } } if (profiles != null) { for (String profile : profiles) { while (true) { final Map<String, PropsEntry> map = this.profileProperties.get(profile); if (map != null) { extractMap(target, map, profiles, wildcardPatterns, prefix); } final int ndx = profile.lastIndexOf('.'); if (ndx == -1) { break; } profile = profile.substring(0, ndx); } } } extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix); return target; } \nResponse:", "ground_truth": "Extracts props to target map. This is all-in-one method, that does many things at once.", "predict": " Extracts properties from the profiles and wildcardPatterns. Wildcard Patterns are processed recursively. Wildcard Patterns are processed in alphabetical order. Profiles are processed in alphabetical order. @param target Map to put the properties into. @param profiles Profiles to extract properties from. @param wildcardPatterns Wildcard Patterns to extract properties from. @param prefix Prefix to prepend to property names. @return Map with properties."}
{"ID": 820, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int streamtoword(byte[] data, int[] offp) { int i; int word = 0; int off = offp[0]; for (i = 0; i < 4; i++) { word = (word << 8) | (data[off] & 0xff); off = (off + 1) % data.length; } offp[0] = off; return word; } \nResponse:", "ground_truth": "Cycically extract a word of key material.\n\n@param data the string to extract the data from\n@param offp a \"pointer\" (as a one-entry array) to the\ncurrent offset into data\n@return the next word of material from data", "predict": " Convert an unsigned byte to a word, where the byte and the word are treated as unsigned values. That is, the byte is masked with 0xFF and the masked byte is placed into the lowest 8 bits of the word and the rest of the masked byte is placed into the high 8 bits of the word. @param data the byte array to convert @param offp an array of length 1 where the offset into the byte array is returned upon completion of this routine. Specifically, the offset into the byte array is returned at index 0 and the length of the byte array is returned at index 1. @return the word generated from the byte array\n*/"}
{"ID": 821, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String hashpw(String password, String salt) { BCrypt B; String real_salt; byte[] passwordb, saltb, hashed; char minor = (char) 0; int rounds, off; StringBuffer rs = new StringBuffer(); if (salt.charAt(0) != '$' || salt.charAt(1) != '2') { throw new IllegalArgumentException(\"Invalid salt version\"); } if (salt.charAt(2) == '$') { off = 3; } else { minor = salt.charAt(2); if (minor != 'a' || salt.charAt(3) != '$') { throw new IllegalArgumentException(\"Invalid salt revision\"); } off = 4; } // Extract number of rounds if (salt.charAt(off + 2) > '$') { throw new IllegalArgumentException(\"Missing salt rounds\"); } rounds = Integer.parseInt(salt.substring(off, off + 2)); real_salt = salt.substring(off + 3, off + 25); try { passwordb = (password + (minor >= 'a' ? \"\\000\" : \"\")).getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { throw new AssertionError(\"UTF-8 is not supported\"); } saltb = decode_base64(real_salt, BCRYPT_SALT_LEN); B = new BCrypt(); hashed = B.crypt_raw(passwordb, saltb, rounds, (int[]) bf_crypt_ciphertext.clone()); rs.append(\"$2\"); if (minor >= 'a') { rs.append(minor); } rs.append('$'); if (rounds < 10) { rs.append('0'); } if (rounds > 30) { throw new IllegalArgumentException( \"rounds exceeds maximum (30)\"); } rs.append(rounds) .append('$') .append(encode_base64(saltb, saltb.length)) .append(encode_base64(hashed, bf_crypt_ciphertext.length * 4 - 1)); return rs.toString(); } \nResponse:", "ground_truth": "Hash a password using the OpenBSD bcrypt scheme.\n\n@param password the password to hash\n@param salt the salt to hash with (perhaps generated\nusing BCrypt.gensalt)\n@return the hashed password", "predict": " Generate a salt for BCrypt passwords. @param password the password to generate a salt for @param minor the minor version of the salt to generate (a, c, or y) @return a salt for the given password\n*/"}
{"ID": 822, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean checkpw(String plaintext, String hashed) { byte[] hashed_bytes; byte[] try_bytes; try { String try_pw = hashpw(plaintext, hashed); hashed_bytes = hashed.getBytes(\"UTF-8\"); try_bytes = try_pw.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException uee) { return false; } if (hashed_bytes.length != try_bytes.length) { return false; } byte ret = 0; for (int i = 0; i < try_bytes.length; i++) { ret |= hashed_bytes[i] ^ try_bytes[i]; } return ret == 0; } \nResponse:", "ground_truth": "Check that a plaintext password matches a previously hashed\none.\n\n@param plaintext the plaintext password to verify\n@param hashed the previously-hashed password\n@return true if the passwords match, false otherwise", "predict": " Check a plaintext password against a previously salted and hashed one. Generally you should salt yourself before hashing, but this is included for historical reasons. @param plaintext The plaintext password to verify. @param hashed The previously-hashed password. @return Whether the plaintext password matches the hashed one."}
{"ID": 823, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int copyAll(final OutputStream out) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; } return count; } \nResponse:", "ground_truth": "Copies bytes from this stream to some output until boundary is\nreached. Returns number of copied bytes. It will throw an exception\nfor any irregular behaviour.", "predict": " Copies everything until the boundary is reached. Leaves the boundary untouched. Upon reaching the boundary, stops copying. Upon reaching EOF, also stops copying. @param out Stream to copy to. May be null, in which case nothing happens. @return Number of bytes copied. Negative if EOF was reached prematurely.\n*/"}
{"ID": 824, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int copyMax(final OutputStream out, final int maxBytes) throws IOException { int count = 0; while (true) { byte b = readByte(); if (isBoundary(b)) { break; } out.write(b); count++; if (count == maxBytes) { return count; } } return count; } \nResponse:", "ground_truth": "Copies max or less number of bytes to output stream. Useful for determining\nif uploaded file is larger then expected.", "predict": " Copies at most maxBytes bytes from the buffer to the output stream. Leaves the buffer intact. Leaves the stream unaffected if maxBytes exceeds the size of the buffer. @param out The output stream to write to. @param maxBytes The maximum number of bytes to copy. @return The number of bytes actually copied. @throws IOException If there is an error writing to the output stream."}
{"ID": 825, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime parse(final Class<?> actionClass, final Method actionMethod, ActionDefinition actionDefinition) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues(actionMethod); final ActionConfig actionConfig = resolveActionConfig(annotationValues); // interceptors ActionInterceptor[] actionInterceptors = parseActionInterceptors(actionClass, actionMethod, actionConfig); // filters ActionFilter[] actionFilters = parseActionFilters(actionClass, actionMethod, actionConfig); // build action definition when not provided if (actionDefinition == null) { actionDefinition = parseActionDefinition(actionClass, actionMethod); } detectAndRegisterAlias(annotationValues, actionDefinition); final boolean async = parseMethodAsyncFlag(actionMethod); final boolean auth = parseMethodAuthFlag(actionMethod); final Class<? extends ActionResult> actionResult = parseActionResult(actionMethod); final Class<? extends ActionResult> defaultActionResult = actionConfig.getActionResult(); return createActionRuntime( null, actionClass, actionMethod, actionResult, defaultActionResult, actionFilters, actionInterceptors, actionDefinition, async, auth); } \nResponse:", "ground_truth": "Parses java action method annotation and returns its action runtime.\n\n@param actionClass action class\n@param actionMethod action method\n@param actionDefinition optional action def, usually <code>null</code> so to be parsed", "predict": " Parses the action method and extracts the following: Interceptors, Filters, Async, Auth, Result, DefaultResult, Aliases, Aliases. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved to their respective ActionDefinition. Aliases are resolved"}
{"ID": 826, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) { final Class<? extends Annotation> annotationType; if (annotationValues == null) { annotationType = Action.class; } else { annotationType = annotationValues.annotationType(); } return actionConfigManager.lookup(annotationType); } \nResponse:", "ground_truth": "Resolves action config.", "predict": " Resolves the ActionConfig for the given annotation values. @param annotationValues the annotation values, may be {@code null} @return the resolved ActionConfig, or {@code null} if none found\n*/"}
{"ID": 827, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void detectAndRegisterAlias(final ActionAnnotationValues annotationValues, final ActionDefinition actionDefinition) { final String alias = parseMethodAlias(annotationValues); if (alias != null) { String aliasPath = StringUtil.cutToIndexOf(actionDefinition.actionPath(), StringPool.HASH); actionsManager.registerPathAlias(alias, aliasPath); } } \nResponse:", "ground_truth": "Detects if alias is defined in annotation and registers it if so.", "predict": " Detects and registers alias for action path. @param annotationValues the annotation values @param actionDefinition the action definition\n*/"}
{"ID": 828, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class<? extends ActionInterceptor>[] readActionInterceptors(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionInterceptor>[] result = null; InterceptedBy interceptedBy = actionClassOrMethod.getAnnotation(InterceptedBy.class); if (interceptedBy != null) { result = interceptedBy.value(); if (result.length == 0) { result = null; } } return result; } \nResponse:", "ground_truth": "Reads class or method annotation for action interceptors.", "predict": " Read interceptors from interceptor classes or interceptor methods. Interceptors are read from interceptor classes first, then from interceptor methods. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order: Interceptors from interceptor classes, Interceptors from interceptor methods, Interceptors from interceptor definitions. Interceptors are read in the following order"}
{"ID": 829, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class<? extends ActionFilter>[] readActionFilters(final AnnotatedElement actionClassOrMethod) { Class<? extends ActionFilter>[] result = null; FilteredBy filteredBy = actionClassOrMethod.getAnnotation(FilteredBy.class); if (filteredBy != null) { result = filteredBy.value(); if (result.length == 0) { result = null; } } return result; } \nResponse:", "ground_truth": "Reads class or method annotation for action filters.", "predict": " Reads the action filters from the annotated element. @param actionClassOrMethod The annotated element. @return The action filters. Shall not be <code>null</code>. Shall contain at least one non-empty array element. Shall not be empty. Shall not be <code>null</code>. Shall not be empty. Shall not be <code>null</code>. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not be empty. Shall not"}
{"ID": 830, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] readPackageActionPath(final Class actionClass) { Package actionPackage = actionClass.getPackage(); final String actionPackageName = actionPackage.getName(); // 1 - read annotations first String packageActionPathFromAnnotation; mainloop: while (true) { MadvocAction madvocActionAnnotation = actionPackage.getAnnotation(MadvocAction.class); packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation.value().trim() : null; if (StringUtil.isEmpty(packageActionPathFromAnnotation)) { packageActionPathFromAnnotation = null; } if (packageActionPathFromAnnotation == null) { // next package String newPackage = actionPackage.getName(); actionPackage = null; while (actionPackage == null) { final int ndx = newPackage.lastIndexOf('.'); if (ndx == -1) { // end of hierarchy, nothing found break mainloop; } newPackage = newPackage.substring(0, ndx); actionPackage = Packages.of(actionClass.getClassLoader(), newPackage); } } else { // annotation found, register root rootPackages.addRootPackage(actionPackage.getName(), packageActionPathFromAnnotation); break; } } // 2 - read root package String packagePath = rootPackages.findPackagePathForActionPackage(actionPackageName); if (packagePath == null) { return ArraysUtil.array(null, null); } return ArraysUtil.array( StringUtil.stripChar(packagePath, '/'), StringUtil.surround(packagePath, StringPool.SLASH) ); } \nResponse:", "ground_truth": "Reads action path for package.\nIf annotation is not set on package-level, class package will be used for\npackage action path part.", "predict": " Read Madvoc annotations and Madvoc root packages. @param actionClass Madvoc action class. @return Madvoc package action path."}
{"ID": 831, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] readMethodActionPath(final String methodName, final ActionAnnotationValues annotationValues, final ActionConfig actionConfig) { // read annotation String methodActionPath = annotationValues != null ? annotationValues.value() : null; if (methodActionPath == null) { methodActionPath = methodName; } else { if (methodActionPath.equals(Action.NONE)) { return ArraysUtil.array(null, null); } } // check for defaults for (String path : actionConfig.getActionMethodNames()) { if (methodActionPath.equals(path)) { methodActionPath = null; break; } } return ArraysUtil.array(methodName, methodActionPath); } \nResponse:", "ground_truth": "Reads action path from the action method.", "predict": " Reads the method action path from the annotation or config. @param methodName the method name @param annotationValues the annotation values @param actionConfig the action config @return the action path\n*/"}
{"ID": 832, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseMethodAlias(final ActionAnnotationValues annotationValues) { String alias = null; if (annotationValues != null) { alias = annotationValues.alias(); } return alias; } \nResponse:", "ground_truth": "Reads method's alias value.", "predict": " Parses the alias to be used for the annotated controller method. The default implementation looks for a value on the annotation itself or uses the decapitalized version of the method name. @param annotationValues the values found on the annotation\n * @return the alias to be used for the annotated controller method\n */"}
{"ID": 833, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime createActionRuntime( final ActionHandler actionHandler, final Class actionClass, final Method actionClassMethod, final Class<? extends ActionResult> actionResult, final Class<? extends ActionResult> defaultActionResult, final ActionFilter[] filters, final ActionInterceptor[] interceptors, final ActionDefinition actionDefinition, final boolean async, final boolean auth) { if (actionHandler != null) { return new ActionRuntime( actionHandler, actionClass, actionClassMethod, filters, interceptors, actionDefinition, NoneActionResult.class, NoneActionResult.class, async, auth, null, null); } final ScopeData scopeData = scopeDataInspector.inspectClassScopes(actionClass); // find ins and outs final Class[] paramTypes = actionClassMethod.getParameterTypes(); final MethodParam[] params = new MethodParam[paramTypes.length]; final Annotation[][] paramAnns = actionClassMethod.getParameterAnnotations(); String[] methodParamNames = null; // for all elements: action and method arguments... for (int ndx = 0; ndx < paramTypes.length; ndx++) { Class paramType = paramTypes[ndx]; // lazy init to postpone bytecode usage, when method has no arguments if (methodParamNames == null) { methodParamNames = actionMethodParamNameResolver.resolveParamNames(actionClassMethod); } final String paramName = methodParamNames[ndx]; final Annotation[] parameterAnnotations = paramAnns[ndx]; final ScopeData paramsScopeData = scopeDataInspector.inspectMethodParameterScopes(paramName, paramType, parameterAnnotations); MapperFunction mapperFunction = null; for (final Annotation annotation : parameterAnnotations) { if (annotation instanceof Mapper) { mapperFunction = MapperFunctionInstances.get().lookup(((Mapper) annotation).value()); break; } } params[ndx] = new MethodParam( paramTypes[ndx], paramName, scopeDataInspector.detectAnnotationType(parameterAnnotations), paramsScopeData, mapperFunction ); } return new ActionRuntime( null, actionClass, actionClassMethod, filters, interceptors, actionDefinition, actionResult, defaultActionResult, async, auth, scopeData, params); } \nResponse:", "ground_truth": "Creates new instance of action runtime configuration.\nInitialize caches.", "predict": " Creates an action runtime. @param actionHandler The action handler. @param actionClass The action class. @param actionClassMethod The action class method. @param actionResult The action result. @param defaultActionResult The default action result. @param filters The filters. @param interceptors The interceptors. @param actionDefinition The action definition. @param async The async flag. @param auth The auth flag. @return The action runtime."}
{"ID": 834, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void preResponseCommit() { long lastModified = lastModifiedData.getLastModified(); long ifModifiedSince = request.getDateHeader(\"If-Modified-Since\"); if (lastModified > -1 && !response.containsHeader(\"Last-Modified\")) { if (ifModifiedSince < (lastModified / 1000 * 1000)) { response.setDateHeader(\"Last-Modified\", lastModified); } else { response.reset(); response.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } \nResponse:", "ground_truth": "todo move to BufferResponseWrapper ?", "predict": " Prevents browsers from caching the 304 response. Without this, conditional GET requests could be answered with 304 Not Modified, defeating the purpose of conditional GETs. Furthermore, some browsers will treat a 304 response as a 303 response, even when 303 responses contain the 'Last-Modified' header. Consequently, 304 responses without a Last-Modified header are not cacheable. @see <a href=\"http://www.ietf.org/rfc/rfc2616.txt\">conditional GET</a>\n*/"}
{"ID": 835, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T applyAdvice(final Class<T> targetClass) { Class adviceClass = cache.get(targetClass); if (adviceClass == null) { // advice not yet created adviceClass = PROXY_PROXETTA.proxy().setTarget(targetClass).define(); cache.put(targetClass, adviceClass); } // create new advice instance and injects target instance to it try { Object advice = ClassUtil.newInstance(adviceClass); Field field = adviceClass.getField(\"$___target$0\"); field.set(advice, targetClass); return (T) advice; } catch (Exception ex) { throw new ProxettaException(ex); } } \nResponse:", "ground_truth": "Applies advice on given target class and returns proxy instance.", "predict": " Advises given class using proxetta. Useful for injecting advice into existing classes. @param targetClass Target class to advice. @return Advised class."}
{"ID": 836, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void injectTargetIntoProxy(final Object proxy, final Object target) { Class proxyClass = proxy.getClass(); try { Field field = proxyClass.getField(\"$___target$0\"); field.set(proxy, target); } catch (Exception ex) { throw new ProxettaException(ex); } } \nResponse:", "ground_truth": "Injects target into proxy.", "predict": " Inject target into proxy. Useful for injecting into proxies created by Enhancer. Useful for injecting into proxies created by PowerMock. Useful for injecting into proxies created by Mockito. Useful for injecting into proxies created by EasyMock. Useful for injecting into proxies created by JMockit. Useful for injecting into proxies created by Mockito2. Useful for injecting into proxies created by PowerMockMockito. Useful for injecting into proxies created by EasyMockMockito. Useful for injecting into proxies created by JMockitMockito. Useful for injecting into proxies created by Mockito2Mockito. Useful for injecting into proxies created by PowerMockMockito2. Useful for injecting into proxies created by EasyMockMockito2Mockito. Useful for injecting into proxies created by JMockitMockito2Mockito. Useful for injecting into proxies created by Mockito2Mockito2PowerMockMockito. Useful for injecting into proxies created by EasyMockMockito2Mockito2"}
{"ID": 837, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (fv != null) { return fv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of the field.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation of the field. @param descriptor the class descriptor of the annotation class. @param visible true if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation. <i>The annotation values must be visited before calling other methods on this annotation visitor</i>.\n*/"}
{"ID": 838, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveRealName(final String jsonName) { if (jsonNames == null) { return jsonName; } int jsonIndex = ArraysUtil.indexOf(jsonNames, jsonName); if (jsonIndex == -1) { return jsonName; } return realNames[jsonIndex]; } \nResponse:", "ground_truth": "Resolves real name from JSON name.", "predict": " Resolve real name. @param jsonName the json name @return the string\n*/"}
{"ID": 839, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveJsonName(final String realName) { if (realNames == null) { return realName; } int realIndex = ArraysUtil.indexOf(realNames, realName); if (realIndex == -1) { return realName; } return jsonNames[realIndex]; } \nResponse:", "ground_truth": "Resolves JSON name from real name.", "predict": " Resolve json name. @param realName the real name @return the string\n*/"}
{"ID": 840, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public TypeData lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { if (serializationSubclassAware) { typeData = findSubclassTypeData(type); } if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } } return typeData; } \nResponse:", "ground_truth": "Returns all includes for given type. Returns an empty array\nwhen no includes are defined.", "predict": " Looks up the TypeData for a given Class. Will lazily acquire TypeData instances for Classes referenced in the inheritance hierarchy. @param type The Class whose TypeData is sought. @return The TypeData for the Class. Never null. May be stale.\n*/"}
{"ID": 841, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeData _lookupTypeData(final Class type) { TypeData typeData = typeDataMap.get(type); if (typeData == null) { typeData = scanClassForAnnotations(type); typeDataMap.put(type, typeData); } return typeData; } \nResponse:", "ground_truth": "Lookups type data and creates one if missing.", "predict": " Looks up the TypeData for a given Class. Will lazily scan annotations on the class to identify its annotations. @param type the Class to look up @return the TypeData for the Class\n*/"}
{"ID": 842, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeData findSubclassTypeData(final Class type) { final Class<? extends Annotation> defaultAnnotation = jsonAnnotation; if (type.getAnnotation(defaultAnnotation) != null) { // current type has annotation, don't find anything, let type data be created return null; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); // lookup superclasses Class[] superClasses = cd.getAllSuperclasses(); for (Class superClass : superClasses) { if (superClass.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(superClass); } } Class[] interfaces = cd.getAllInterfaces(); for (Class interfaze : interfaces) { if (interfaze.getAnnotation(defaultAnnotation) != null) { // annotated subclass founded! return _lookupTypeData(interfaze); } } return null; } \nResponse:", "ground_truth": "Finds type data of first annotated superclass or interface.", "predict": " Looking for annotated subclass of current type. @param type current type\n * @return founded subclass or null\n */"}
{"ID": 843, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveJsonName(final Class type, final String name) { TypeData typeData = lookupTypeData(type); return typeData.resolveJsonName(name); } \nResponse:", "ground_truth": "Returns different name of a property if set by annotation.", "predict": " Resolve a json name to a Jackson compatible name. For example, a class annotated with JsonSnakeCase will have snake_case converted to snakeCase. Also, underscores will be converted to hyphens. Lastly, camelCase will be converted to snake_case. @param type The type to resolve the name for. @param name The name to resolve. @return The resolved name."}
{"ID": 844, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveRealName(final Class type, final String jsonName) { TypeData typeData = lookupTypeData(type); return typeData.resolveRealName(jsonName); } \nResponse:", "ground_truth": "Returns real property name for given JSON property.", "predict": " Resolve real name for a type. @param type The type. @param jsonName The json name. @return The real name."}
{"ID": 845, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public byte[] getFileContent() throws IOException { if (data != null) { return data; } if (tempFile != null) { return FileUtil.readBytes(tempFile); } return null; } \nResponse:", "ground_truth": "Returns the content of file upload item.", "predict": " Returns the content of the file. May be null if the file does not exist. May throw IOException if there is an error reading the file.\n*/"}
{"ID": 846, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void copyBootstrapMethods(final ClassReader classReader, final char[] charBuffer) { // Find attributOffset of the 'bootstrap_methods' array. byte[] inputBytes = classReader.b; int currentAttributeOffset = classReader.getFirstAttributeOffset(); for (int i = classReader.readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { String attributeName = classReader.readUTF8(currentAttributeOffset, charBuffer); if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { bootstrapMethodCount = classReader.readUnsignedShort(currentAttributeOffset + 6); break; } currentAttributeOffset += 6 + classReader.readInt(currentAttributeOffset + 2); } if (bootstrapMethodCount > 0) { // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array. int bootstrapMethodsOffset = currentAttributeOffset + 8; int bootstrapMethodsLength = classReader.readInt(currentAttributeOffset + 2) - 2; bootstrapMethods = new ByteVector(bootstrapMethodsLength); bootstrapMethods.putByteArray(inputBytes, bootstrapMethodsOffset, bootstrapMethodsLength); // Add each bootstrap method in the symbol table entries. int currentOffset = bootstrapMethodsOffset; for (int i = 0; i < bootstrapMethodCount; i++) { int offset = currentOffset - bootstrapMethodsOffset; int bootstrapMethodRef = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int numBootstrapArguments = classReader.readUnsignedShort(currentOffset); currentOffset += 2; int hashCode = classReader.readConst(bootstrapMethodRef, charBuffer).hashCode(); while (numBootstrapArguments-- > 0) { int bootstrapArgument = classReader.readUnsignedShort(currentOffset); currentOffset += 2; hashCode ^= classReader.readConst(bootstrapArgument, charBuffer).hashCode(); } add(new Entry(i, Symbol.BOOTSTRAP_METHOD_TAG, offset, hashCode & 0x7FFFFFFF)); } } } \nResponse:", "ground_truth": "Read the BootstrapMethods 'bootstrap_methods' array binary content and add them as entries of\nthe SymbolTable.\n\n@param classReader the ClassReader whose bootstrap methods must be copied to initialize the\nSymbolTable.\n@param charBuffer a buffer used to read strings in the constant pool.", "predict": " Copies the constant pool entries from the given class reader to this class writer."}
{"ID": 847, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int setMajorVersionAndClassName(final int majorVersion, final String className) { this.majorVersion = majorVersion; this.className = className; return addConstantClass(className).index; } \nResponse:", "ground_truth": "Sets the major version and the name of the class to which this symbol table belongs. Also adds\nthe class name to the constant pool.\n\n@param majorVersion a major ClassFile version number.\n@param className an internal class name.\n@return the constant pool index of a new or already existing Symbol with the given class name.", "predict": " Sets the major version and class name. @param majorVersion the major version. @param className the class name. @return the index of the constant pool entry containing the major version number.\n"}
{"ID": 848, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putConstantPool(final ByteVector output) { output.putShort(constantPoolCount).putByteArray(constantPool.data, 0, constantPool.length); } \nResponse:", "ground_truth": "Puts this symbol table's constant_pool array in the given ByteVector, preceded by the\nconstant_pool_count value.\n\n@param output where the JVMS ClassFile's constant_pool array must be put.", "predict": " Puts the constant pool to the given output. @param output where the constant pool must be put.\n*/"}
{"ID": 849, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putBootstrapMethods(final ByteVector output) { if (bootstrapMethods != null) { output .putShort(addConstantUtf8(Constants.BOOTSTRAP_METHODS)) .putInt(bootstrapMethods.length + 2) .putShort(bootstrapMethodCount) .putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length); } } \nResponse:", "ground_truth": "Puts this symbol table's BootstrapMethods attribute in the given ByteVector. This includes the\n6 attribute header bytes and the num_bootstrap_methods value.\n\n@param output where the JVMS BootstrapMethods attribute must be put.", "predict": " Puts the bootstrap methods of this class in the given byte vector."}
{"ID": 850, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantFieldref(final String owner, final String name, final String descriptor) { return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor); } \nResponse:", "ground_truth": "Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a field name.\n@param descriptor a field descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_FIELDREF constant pool entry to the given one. @param owner the internal name of the field's owner class. @param name the field's name. @param descriptor the field's descriptor.\n@return a new or already existing Symbol.CONSTANT_FIELDREF constant pool entry."}
{"ID": 851, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodref( final String owner, final String name, final String descriptor, final boolean isInterface) { int tag = isInterface ? Symbol.CONSTANT_INTERFACE_METHODREF_TAG : Symbol.CONSTANT_METHODREF_TAG; return addConstantMemberReference(tag, owner, name, descriptor); } \nResponse:", "ground_truth": "Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this\nsymbol table. Does nothing if the constant pool already contains a similar item.\n\n@param owner the internal name of a class.\n@param name a method name.\n@param descriptor a method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_Methodref constant pool entry to the given class."}
{"ID": 852, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Entry addConstantMemberReference( final int tag, final String owner, final String name, final String descriptor) { int hashCode = hash(tag, owner, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122( tag, addConstantClass(owner).index, addConstantNameAndType(name, descriptor)); return put(new Entry(constantPoolCount++, tag, owner, name, descriptor, 0, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to\nthe constant pool of this symbol table. Does nothing if the constant pool already contains a\nsimilar item.\n\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_Member_info structure to the constant pool. Does nothing if the constant pool already contains a similar item. <i>This method is intended for {@literal post-parse} use only.</i> @param tag one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}, see {@link Opcodes} @param owner internal name of the field or method owner class @param name name of the field or method @param descriptor descriptor of the field or method, or"}
{"ID": 853, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantMemberReference( final int index, final int tag, final String owner, final String name, final String descriptor) { add(new Entry(index, tag, owner, name, descriptor, 0, hash(tag, owner, name, descriptor))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Fieldref_info, CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info\nto the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_FIELDREF_TAG}, {@link Symbol#CONSTANT_METHODREF_TAG}\nor {@link Symbol#CONSTANT_INTERFACE_METHODREF_TAG}.\n@param owner the internal name of a class.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a CONSTANT_MemberRef constant pool entry to the table."}
{"ID": 854, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantIntegerOrFloat(final int tag, final int value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } constantPool.putByte(tag).putInt(value); return put(new Entry(constantPoolCount++, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.\n@return a constant pool constant with the given tag and primitive values.", "predict": " Add a CONSTANT_INTEGER_TAG or CONSTANT_FLOAT_TAG symbol to the constant pool. The tag is identified by its type, ie. CONSTANT_INTEGER_TAG or CONSTANT_FLOAT_TAG. The value is added to the constant pool using the following format: CONSTANT_VALUE_TAG Typ VALUE where Typ is the type of the value and VALUE is its value. The Typ guarantees that the value is representable in the specified type. The value is stored in big endian format. @param tag the tag of the constant, ie. CONSTANT_INTEGER_TAG or CONSTANT_FLOAT_TAG. @param value the value of the constant. @return the Symbol that represents the constant pool entry.\n*/"}
{"ID": 855, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantIntegerOrFloat(final int index, final int tag, final int value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_INTEGER_TAG} or {@link Symbol#CONSTANT_FLOAT_TAG}.\n@param value an int or float.", "predict": " Adds a constant pool entry of type CONSTANT_INTEGER_TAG or CONSTANT_FLOAT_TAG. @param index the index of the new constant pool entry. @param tag the kind of the constant pool entry. @param value the value of the constant pool entry.\n*/"}
{"ID": 856, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantLongOrDouble(final int tag, final long value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == value) { return entry; } entry = entry.next; } int index = constantPoolCount; constantPool.putByte(tag).putLong(value); constantPoolCount += 2; return put(new Entry(index, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table.\nDoes nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.\n@return a constant pool constant with the given tag and primitive values.", "predict": " Add a CONSTANT_Long_info or CONSTANT_Double_info to the constantPool. The tag must be CONSTANT_Long or CONSTANT_Double. The hashCode is updated. @param tag the tag of the entry @param value the long or double value of the entry @return the Symbol for this entry\n*/"}
{"ID": 857, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantLongOrDouble(final int index, final int tag, final long value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol\ntable.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_LONG_TAG} or {@link Symbol#CONSTANT_DOUBLE_TAG}.\n@param value a long or double.", "predict": " Adds a CONSTANT_Long_info or CONSTANT_Double_info entry. @param index the constant pool index (must be greater than 0). @param tag the kind of the constant pool entry @param value the long or double value.\n*/"}
{"ID": 858, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addConstantNameAndType(final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; int hashCode = hash(tag, name, descriptor); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry.index; } entry = entry.next; } constantPool.put122(tag, addConstantUtf8(name), addConstantUtf8(descriptor)); return put(new Entry(constantPoolCount++, tag, name, descriptor, hashCode)).index; } \nResponse:", "ground_truth": "Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_NAME_AND_TYPE constant to the constant pool, retrieving an existing CONSTANT_NAME_AND_TYPE entry if it already exists. The CONSTANT_NAME_AND_TYPE_TAG is described in section 4.4.7 of <cite>The Java&trade; Virtual Machine Specification</cite>. @param name a fully qualified class name in internal form (@see <a href=\"../../../../technotes/guides/jvmti/jvmpi.html#methSignature\">JVM TI Specification</a>). @param descriptor a field or method descriptor. @return the index of a new or already existing CONSTANT_NAME_AND_TYPE entry.\n"}
{"ID": 859, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantNameAndType(final int index, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_NAME_AND_TYPE_TAG; add(new Entry(index, tag, name, descriptor, hash(tag, name, descriptor))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a CONSTANT_NAME_AND_TYPE entry to the constant pool. @param name a name. May be <tt>null</tt>. @param descriptor a descriptor. May be <tt>null</tt>.\n*/"}
{"ID": 860, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addConstantUtf8(final String value) { int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.CONSTANT_UTF8_TAG && entry.hashCode == hashCode && entry.value.equals(value)) { return entry.index; } entry = entry.next; } constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value); return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index; } \nResponse:", "ground_truth": "Adds a CONSTANT_Utf8_info to the constant pool of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param value a string.\n@return a new or already existing Symbol with the given value.", "predict": " Add a CONSTANT_Utf8_info structure to the constant pool. The value of the CONSTANT_Utf8_info must be a string of 1, 2, 3, 4, or 5 bytes. @param value the string to add to the constant pool @return the index of the added entry\n*/"}
{"ID": 861, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantUtf8(final int index, final String value) { add(new Entry(index, Symbol.CONSTANT_UTF8_TAG, value, hash(Symbol.CONSTANT_UTF8_TAG, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_String_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param value a string.", "predict": " Adds a CONSTANT_Utf8_info structure to the constant pool. @param index at which the CONSTANT_Utf8_info structure must be inserted. @param value the string to be inserted as CONSTANT_Utf8_info.\n*/"}
{"ID": 862, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantMethodHandle( final int referenceKind, final String owner, final String name, final String descriptor, final boolean isInterface) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; // Note that we don't need to include isInterface in the hash computation, because it is // redundant with owner (we can't have the same owner with different isInterface values). int hashCode = hash(tag, owner, name, descriptor, referenceKind); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == referenceKind && entry.owner.equals(owner) && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } if (referenceKind <= Opcodes.H_PUTSTATIC) { constantPool.put112(tag, referenceKind, addConstantFieldref(owner, name, descriptor).index); } else { constantPool.put112( tag, referenceKind, addConstantMethodref(owner, name, descriptor, isInterface).index); } return put( new Entry(constantPoolCount++, tag, owner, name, descriptor, referenceKind, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table. Does nothing if\nthe constant pool already contains a similar item.\n\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.\n@param isInterface whether owner is an interface or not.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_MethodHandle CP entry to the constant pool of this class. Does nothing if the constant pool already contains a similar item. @param referenceKind how CONSTANT_MethodHandle should be referenced, one of the _REF_ constants (@see cpTags). @param owner the internal name of a class. @param name the method's name. @param descriptor the method's descriptor. @param isInterface true if this is an interface method. @return a new or already existing Symbol.CONSTANT_MethodHandle reference.\n"}
{"ID": 863, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantMethodHandle( final int index, final int referenceKind, final String owner, final String name, final String descriptor) { final int tag = Symbol.CONSTANT_METHOD_HANDLE_TAG; int hashCode = hash(tag, owner, name, descriptor, referenceKind); add(new Entry(index, tag, owner, name, descriptor, referenceKind, hashCode)); } \nResponse:", "ground_truth": "Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param referenceKind one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link\nOpcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link\nOpcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link\nOpcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of a class of interface.\n@param name a field or method name.\n@param descriptor a field or method descriptor.", "predict": " Adds a CONSTANT_METHOD_HANDLE entry.\n@param index the constant pool index (must be greater than 0).\n@param referenceKind the kind of reference to the constant pool entry. It can be {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}.\n@param owner the internal name of the method's owner class (see {@link Type#getInternalName()}). @param name the method's name. @param descriptor the method's descriptor (see {@link"}
{"ID": 864, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); } \nResponse:", "ground_truth": "Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table. Also adds the related\nbootstrap method to the BootstrapMethods of this symbol table. Does nothing if the constant\npool already contains a similar item.\n\n@param name a method name.\n@param descriptor a field descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_Dynamic constant to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i> @param name name of the referenced class @param descriptor descriptor of the referenced class @param bootstrapMethodHandle the bootstrap method handle @param bootstrapMethodArguments the bootstrap method arguments\n@see #createDynamicConstant\n"}
{"ID": 865, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addConstantInvokeDynamic( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { Symbol bootstrapMethod = addBootstrapMethod(bootstrapMethodHandle, bootstrapMethodArguments); return addConstantDynamicOrInvokeDynamicReference( Symbol.CONSTANT_INVOKE_DYNAMIC_TAG, name, descriptor, bootstrapMethod.index); } \nResponse:", "ground_truth": "Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table. Also adds the\nrelated bootstrap method to the BootstrapMethods of this symbol table. Does nothing if the\nconstant pool already contains a similar item.\n\n@param name a method name.\n@param descriptor a method descriptor.\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_InvokeDynamic constant pool entry to the constant pool of the class being build. Does nothing if the constant pool already contains a similar item. <i>This method is intended for {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i> @param name name of the invoked method. @param descriptor descriptor of the invoke dynamic method. @param bootstrapMethodHandle the bootstrap method handle. @param bootstrapMethodArguments the bootstrap method arguments."}
{"ID": 866, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantDynamicOrInvokeDynamicReference( final int tag, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.data == bootstrapMethodIndex && entry.name.equals(name) && entry.value.equals(descriptor)) { return entry; } entry = entry.next; } constantPool.put122(tag, bootstrapMethodIndex, addConstantNameAndType(name, descriptor)); return put( new Entry( constantPoolCount++, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol\ntable. Does nothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG) or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_Dynamic or CONSTANT_InvokeDynamic constant to the constant pool. @param tag one of {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL}, {@link Opcodes#H_INVOKESTATIC}, {@link Opcodes#H_INVOKESPECIAL}, {@link Opcodes#H_NEWINVOKESPECIAL} or {@link Opcodes#H_INVOKEINTERFACE}. @param name the internal name of the field or method. @param descriptor the descriptor of the field or method. @param bootstrapMethodIndex the bootstrap method index.\n"}
{"ID": 867, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantDynamicOrInvokeDynamicReference( final int tag, final int index, final String name, final String descriptor, final int bootstrapMethodIndex) { int hashCode = hash(tag, name, descriptor, bootstrapMethodIndex); add(new Entry(index, tag, null, name, descriptor, bootstrapMethodIndex, hashCode)); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this\nsymbol table.\n\n@param tag one of {@link Symbol#CONSTANT_DYNAMIC_TAG} or {@link\nSymbol#CONSTANT_INVOKE_DYNAMIC_TAG}.\n@param index the constant pool index of the new Symbol.\n@param name a method name.\n@param descriptor a field descriptor for CONSTANT_DYNAMIC_TAG or a method descriptor for\nCONSTANT_INVOKE_DYNAMIC_TAG.\n@param bootstrapMethodIndex the index of a bootstrap method in the BootstrapMethods attribute.", "predict": " Adds a constant dynamic or invoke dynamic reference to the constant pool. @param tag the kind of the entry. This can be ICONST_METH, DCONST_METH, or INVOKE_DYNAMIC. @param index the index of the constant pool entry @param name a string containing the name of the referenced method. May be <tt>null</tt>. @param descriptor a string containing the descriptor of the referenced method. May be <tt>null</tt>. @param bootstrapMethodIndex the bootstrap method index of the referenced method. May be a negative number.\n*/"}
{"ID": 868, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Symbol addConstantUtf8Reference(final int tag, final String value) { int hashCode = hash(tag, value); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) { return entry; } entry = entry.next; } constantPool.put12(tag, addConstantUtf8(value)); return put(new Entry(constantPoolCount++, tag, value, hashCode)); } \nResponse:", "ground_truth": "Adds a CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table. Does\nnothing if the constant pool already contains a similar item.\n\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a CONSTANT_Utf8_info structure to the constant pool. The value must be already interned. @param tag the kind of the constant pool item. @param value the value of the constant pool item. @return a new or already existing Symbol entry.\n*/"}
{"ID": 869, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addConstantUtf8Reference(final int index, final int tag, final String value) { add(new Entry(index, tag, value, hash(tag, value))); } \nResponse:", "ground_truth": "Adds a new CONSTANT_Class_info, CONSTANT_String_info, CONSTANT_MethodType_info,\nCONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table.\n\n@param index the constant pool index of the new Symbol.\n@param tag one of {@link Symbol#CONSTANT_CLASS_TAG}, {@link Symbol#CONSTANT_STRING_TAG}, {@link\nSymbol#CONSTANT_METHOD_TYPE_TAG}, {@link Symbol#CONSTANT_MODULE_TAG} or {@link\nSymbol#CONSTANT_PACKAGE_TAG}.\n@param value an internal class name, an arbitrary string, a method descriptor, a module or a\npackage name, depending on tag.", "predict": " Adds a CONSTANT_Utf8 CP entry to the constant pool. @param index at which the entry must be inserted. This index must respect the constraints: 0 <= index <= 255 @param tag the kind of the entry. Must be CONSTANT_UTF8. @param value the string value of the entry. Can be an empty string.\n"}
{"ID": 870, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: Symbol addBootstrapMethod( final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { ByteVector bootstrapMethodsAttribute = bootstrapMethods; if (bootstrapMethodsAttribute == null) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector(); } // The bootstrap method arguments can be Constant_Dynamic values, which reference other // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified // while adding the given bootstrap method to it, in the rest of this method. for (Object bootstrapMethodArgument : bootstrapMethodArguments) { addConstant(bootstrapMethodArgument); } // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to // compare it with existing ones, and will be reverted below if there is already a similar // bootstrap method. int bootstrapMethodOffset = bootstrapMethodsAttribute.length; bootstrapMethodsAttribute.putShort( addConstantMethodHandle( bootstrapMethodHandle.getTag(), bootstrapMethodHandle.getOwner(), bootstrapMethodHandle.getName(), bootstrapMethodHandle.getDesc(), bootstrapMethodHandle.isInterface()) .index); int numBootstrapArguments = bootstrapMethodArguments.length; bootstrapMethodsAttribute.putShort(numBootstrapArguments); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { bootstrapMethodsAttribute.putShort(addConstant(bootstrapMethodArgument).index); } // Compute the length and the hash code of the bootstrap method. int bootstrapMethodlength = bootstrapMethodsAttribute.length - bootstrapMethodOffset; int hashCode = bootstrapMethodHandle.hashCode(); for (Object bootstrapMethodArgument : bootstrapMethodArguments) { hashCode ^= bootstrapMethodArgument.hashCode(); } hashCode &= 0x7FFFFFFF; // Add the bootstrap method to the symbol table or revert the above changes. return addBootstrapMethod(bootstrapMethodOffset, bootstrapMethodlength, hashCode); } \nResponse:", "ground_truth": "Adds a bootstrap method to the BootstrapMethods attribute of this symbol table. Does nothing if\nthe BootstrapMethods already contains a similar bootstrap method.\n\n@param bootstrapMethodHandle a bootstrap method handle.\n@param bootstrapMethodArguments the bootstrap method arguments.\n@return a new or already existing Symbol with the given value.", "predict": " Adds a bootstrap method to the BootstrapMethods attribute. Does nothing if the bootstrap methods attribute has already been initialized. @param bootstrapMethodHandle the bootstrap method handle. @param bootstrapMethodArguments the bootstrap method arguments. These arguments can be Constant_Dynamic values, which reference other bootstrap methods.\n"}
{"ID": 871, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int addMergedType(final int typeTableIndex1, final int typeTableIndex2) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | (((long) typeTableIndex2) << 32); int hashCode = hash(Symbol.MERGED_TYPE_TAG, typeTableIndex1 + typeTableIndex2); Entry entry = get(hashCode); while (entry != null) { if (entry.tag == Symbol.MERGED_TYPE_TAG && entry.hashCode == hashCode && entry.data == data) { return entry.info; } entry = entry.next; } String type1 = typeTable[typeTableIndex1].value; String type2 = typeTable[typeTableIndex2].value; int commonSuperTypeIndex = addType(classWriter.getCommonSuperClass(type1, type2)); put(new Entry(typeCount, Symbol.MERGED_TYPE_TAG, data, hashCode)).info = commonSuperTypeIndex; return commonSuperTypeIndex; } \nResponse:", "ground_truth": "Adds a merged type in the type table of this symbol table. Does nothing if the type table\nalready contains a similar type.\n\n@param typeTableIndex1 a {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@param typeTableIndex2 another {@link Symbol#TYPE_TAG} type, specified by its index in the type\ntable.\n@return the index of a new or already existing {@link Symbol#TYPE_TAG} type Symbol,\ncorresponding to the common super class of the given types.", "predict": " Adds a merged type to this symbol table. This symbol table must not contain conflicting types. @param typeTableIndex1 a type table index. Maybe zero. @param typeTableIndex2 another type table index. Maybe zero. The result of merging these tables must be saved into the table at index zero. @return the symbol table index of the entry corresponding to the merged type. Maybe zero. Conflict resolution depends on the {@link SymbolTable} constructor."}
{"ID": 872, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int hash(final String name) { int h = 0; for (int i = name.length() - 1; i >= 0; i--) { char c = name.charAt(i); if (!caseSensitive) { if (c >= 'A' && c <= 'Z') { c += 32; } } h = 31 * h + c; } if (h > 0) { return h; } if (h == Integer.MIN_VALUE) { return Integer.MAX_VALUE; } return -h; } \nResponse:", "ground_truth": "Calculates hash value of the input string.", "predict": " Generates hash code for a given name ignoring case considerations. The hash code is guaranteed to be equal to the hash code generated by the method without considering case considerations. @param name the name to hash. @return the hash code for the given name ignoring case considerations."}
{"ID": 873, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpMultiMap<V> clear() { for (int i = 0; i < entries.length; i++) { entries[i] = null; } head.before = head.after = head; return this; } \nResponse:", "ground_truth": "Clears the map.", "predict": " Clears multimap. After clearing multimap entries remain in the same order they were added to the multimap. Therefore multimap entries can't be retrieved by their keys. Therefore multimap entries can't be removed by key. Therefore multimap entries can't be removed by value. Therefore multimap entries can't be replaced by other multimap entries. Therefore multimap entries can't be replaced by values. Therefore multimap entries can't be replaced by keys. Therefore multimap entries can't be replaced by anything. Therefore multimap entries remain in the same order they were added to the multimap. Therefore multimap entries can't be retrieved by their keys. Therefore multimap entries can't be retrieved by their values. Therefore multimap entries can't be retrieved by anything. Therefore multimap entries remain in the same order they were added to the multimap. Therefore multimap entries can't be retrieved by their keys. Therefore multimap entries can't be retrieved by their values. Therefore multimap entries remain in the same order they were added to the multimap. Therefore multim"}
{"ID": 874, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<V> getAll(final String name) { LinkedList<V> values = new LinkedList<>(); int h = hash(name); int i = index(h); MapEntry<V> e = entries[i]; while (e != null) { if (e.hash == h && eq(name, e.key)) { values.addFirst(e.getValue()); } e = e.next; } return values; } \nResponse:", "ground_truth": "Returns all values associated with the name.", "predict": " Returns all values mapped to the specified key. Note that this method does not return the default value associated with the key. @param name The name whose values are sought. @return A list of values associated with the specified key, or an empty list if no values are found.\n*/"}
{"ID": 875, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Iterator<Map.Entry<String, V>> iterator() { final MapEntry[] e = {head.after}; return new Iterator<Map.Entry<String, V>>() { @Override public boolean hasNext() { return e[0] != head; } @Override @SuppressWarnings(\"unchecked\") public Map.Entry<String, V> next() { if (!hasNext()) { throw new NoSuchElementException(\"No next() entry in the iteration\"); } MapEntry<V> next = e[0]; e[0] = e[0].after; return next; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } \nResponse:", "ground_truth": "Returns iterator of all entries.", "predict": " Returns an iterator over the entries in this LRUCache. The iterator supports element deletion. @return an iterator over the entries in this LRUCache.\n*/"}
{"ID": 876, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Map.Entry<String, V>> entries() { List<Map.Entry<String, V>> all = new LinkedList<>(); MapEntry<V> e = head.after; while (e != head) { all.add(e); e = e.after; } return all; } \nResponse:", "ground_truth": "Returns all the entries of this map. Case sensitivity does not influence\nthe returned list, it always contains all of the values.", "predict": " Returns all the entries in the skiplist in arbitrary order. Note that this is a destructive operation on the skiplist. That is, the skiplist will be emptied. @return the entries in arbitrary order\n*/"}
{"ID": 877, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void grow(final int minCapacity) { final int oldCapacity = buffer.length; int newCapacity = oldCapacity << 1; if (newCapacity - minCapacity < 0) { // special case, min capacity is larger then a grow newCapacity = minCapacity + 512; } buffer = Arrays.copyOf(buffer, newCapacity); } \nResponse:", "ground_truth": "Grows the buffer.", "predict": " Growing the buffer. Growing exponentially is quite slow so we cheat here. We double the buffer size every 512 allocations. So we allocate 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554688, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 556874260896, 110374182400, 224589324896, 4503599627370496, 9007199254740992, 18014398509481984, 36028797018963968, 72057594037927936, 1441151880"}
{"ID": 878, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public FastCharBuffer append(final CharSequence csq, final int start, final int end) { for (int i = start; i < end; i++) { append(csq.charAt(i)); } return this; } \nResponse:", "ground_truth": "Appends character sequence to buffer.", "predict": " Appends a subsequence of the CharSequence argument to this FastCharBuffer. @param csq the CharSequence to append. @param start the starting index of the CharSequence. @param end the end index of the CharSequence. @return this FastCharBuffer.\n*/"}
{"ID": 879, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = methodVisitor.visitAnnotation(desc, visible); // [A4] return new AnnotationVisitorAdapter(destAnn); } \nResponse:", "ground_truth": "Copies target method annotations.", "predict": " Visit a normal annotation of the method. @param desc the class descriptor of the annotation class. @param visible indicate if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation.\n*/"}
{"ID": 880, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visitEnd() { createFirstChainDelegate_Continue(tmd); for (int p = 0; p < tmd.proxyData.length; p++) { tmd.selectCurrentProxy(p); createProxyMethod(tmd); } } \nResponse:", "ground_truth": "Finally, builds proxy methods if applied to current method.", "predict": " Visit the end of the class. Generate the proxy delegation chains."}
{"ID": 881, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createFirstChainDelegate_Start() { // check invalid access flags int access = msign.getAccessFlags(); if (!wd.allowFinalMethods) { if ((access & AsmUtil.ACC_FINAL) != 0) { // detect final throw new ProxettaException( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\"); } } // create proxy methods tmd = new TargetMethodData(msign, aspectList); access &= ~ACC_NATIVE; access &= ~ACC_ABSTRACT; methodVisitor = wd.dest.visitMethod( access, tmd.msign.getMethodName(), tmd.msign.getDescription(), tmd.msign.getAsmMethodSignature(), null); } \nResponse:", "ground_truth": "Starts creation of first chain delegate.", "predict": " Create first chain delegate. Here we postpone visiting of first advice method until we have more information about advice method. This is important because advice method may be native method and we cannot create proxy for native methods. Moreover, advice method may be abstract method and we cannot create proxy for abstract methods. Therefore we postpone visiting of advice method till we have more information about advice method. Moreover, advice method may be native method and we cannot create proxy for native methods. Moreover, advice method may be abstract method and we cannot create proxy for abstract methods. Therefore we postpone visiting of advice method till we have more information about advice method. Moreover, advice method may be native method and we cannot create proxy for native methods. Moreover, advice method may be abstract method and we cannot create proxy for abstract methods. Therefore we postpone visiting of advice method till we have more information about advice method. Moreover, advice method may be native method and we cannot create proxy for native methods. Moreover, advice method may be abstract method and we cannot create proxy for abstract methods. Therefore we postpone visiting of advice method till"}
{"ID": 882, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createFirstChainDelegate_Continue(final TargetMethodData tmd) { methodVisitor.visitCode(); if (tmd.msign.isStatic) { loadStaticMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESTATIC, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } else { loadSpecialMethodArguments(methodVisitor, tmd.msign); methodVisitor.visitMethodInsn( INVOKESPECIAL, wd.thisReference, tmd.firstMethodName(), tmd.msign.getDescription(), false); } visitReturn(methodVisitor, tmd.msign, false); methodVisitor.visitMaxs(0, 0); methodVisitor.visitEnd(); } \nResponse:", "ground_truth": "Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method.\nThis method mirrors the target method.", "predict": " Generate the prologue for the first chain delegate. Continue specialization. @param tmd Tail specialization information.\n*/"}
{"ID": 883, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Path parse(final String path) { return path == null ? new Path() : new Path(StringUtil.splitc(path, '.')); } \nResponse:", "ground_truth": "Parses input dot-separated string that represents a path.", "predict": " Parse a dotted path into its constituent segments. @param path dotted path @return Path\n*/"}
{"ID": 884, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Path push(final CharSequence field) { _push(field); if (altPath != null) { altPath.push(field); } return this; } \nResponse:", "ground_truth": "Push element to the path.", "predict": " Push field onto stack. @param field Field to push onto stack. @return Fluent API allowing chained invocation.\n*/"}
{"ID": 885, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void configureServletContext(final ServletContext servletContext) { servletContext.addListener(jodd.servlet.RequestContextListener.class); if (decoraEnabled) { final FilterRegistration filter = servletContext.addFilter(\"decora\", jodd.decora.DecoraServletFilter.class); filter.addMappingForUrlPatterns(null, true, contextPath); } final FilterRegistration filter = servletContext.addFilter(\"madvoc\", jodd.madvoc.MadvocServletFilter.class); filter.addMappingForUrlPatterns(madvocDispatcherTypes, true, contextPath); } \nResponse:", "ground_truth": "Configures servlet context.", "predict": " Configures servlet context. Madvoc filter must be registered before MadvocMadvocConfigurator is called. Moreover, servlet context listeners are registered here. Moreover, MadvocMadvocConfigurator registers MadvocServletConfigurator listeners. Therefore, MadvocMadvocConfigurator must be called BEFORE servlet listeners are registered. Moreover, servlet listeners are registered BEFORE MadvocMadvocConfigurator listeners. Therefore, MadvocMadvocConfigurator must be called BEFORE servlet listeners are registered. Moreover, servlet listeners are registered BEFORE MadvocMadvocConfigurator listeners. Therefore, MadvocMadvocConfigurator must be called BEFORE servlet listeners are registered. Moreover, servlet listeners are registered BEFORE MadvocMadvocConfigurator listeners. Therefore, MadvocMadvocConfigurator must be called BEFORE servlet listeners are registered. Moreover, servlet listeners are registered BEFORE MadvocMadvocConfigurator listeners. Therefore, MadvocMadvocConfigurator must be called BEFORE servlet listeners are registered. Moreover"}
{"ID": 886, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object execute() { String methodName = targetMethodName(); Class returnType = returnType(); Object next = pathref.continueWith(this, methodName, returnType); return ProxyTarget.returnValue(next); } \nResponse:", "ground_truth": "Reads method name and appends it. Creates object for next call and\nreturns that value. If next object is unsupported, it will return null;", "predict": " Execute the Continuation passing through the ProxyTarget.\nThe Continuation will be resumed upon returning from this method.\nThe Continuation will be suspended upon throwing an exception.\nThe Continuation will be suspended upon returning normally.\nThe Continuation will be suspended upon returning normally but with a suspended target.\nThe Continuation will be suspended upon returning normally but with a suspended target and a suspended continuation.\nThe Continuation will be suspended upon returning normally but with a suspended target, suspended continuation, and suspended target.\nThe Continuation will be suspended upon returning normally but with a suspended target, suspended continuation, suspended target, and suspended continuation.\nThe Continuation will be suspended upon returning normally but with a suspended target, suspended continuation, suspended target, suspended continuation, and suspended target.\nThe Continuation will be suspended upon returning normally but with a suspended target, suspended continuation, suspended target, suspended continuation, suspended target, and suspended continuation.\nThe Continuation will be suspended upon returning normally but with a suspended target, suspended continuation, suspended target, suspended"}
{"ID": 887, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldDescriptor[] getAllFieldDescriptors() { if (allFields == null) { FieldDescriptor[] allFields = new FieldDescriptor[fieldsMap.size()]; int index = 0; for (FieldDescriptor fieldDescriptor : fieldsMap.values()) { allFields[index] = fieldDescriptor; index++; } Arrays.sort(allFields, Comparator.comparing(fd -> fd.getField().getName())); this.allFields = allFields; } return allFields; } \nResponse:", "ground_truth": "Returns all fields of this collection. Returns empty array\nif no fields exist. Initialized lazy.", "predict": " Returns all descriptors in this file. The returned descriptors include those from super classes. Moreover, descriptors inherited from interfaces are returned too. Note that descriptors inherited from interfaces are only included when the descriptor is defined in the same file as the interface. @return all descriptors in this file.\n*/"}
{"ID": 888, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") @Override protected <T> BeanDefinition<T> createBeanDefinitionForRegistration( final String name, Class<T> type, final Scope scope, final WiringMode wiringMode, final Consumer<T> consumer) { if (proxetta != null) { final Class originalType = type; final ProxettaFactory builder = proxetta.proxy(); builder.setTarget(type); type = builder.define(); return new ProxettaBeanDefinition( name, type, scope, wiringMode, originalType, proxetta.getAspects(new ProxyAspect[0]), consumer); } return super.createBeanDefinitionForRegistration(name, type, scope, wiringMode, consumer); } \nResponse:", "ground_truth": "Applies proxetta on bean class before bean registration.", "predict": " Interceptor aspect wired to intercept all methods of the proxetta proxy. This aspect wires interceptors to the aspects. Interceptors wired to aspects are wired to the target bean. Interceptors wired to target bean are wired to the proxetta proxy. Interceptors wired to proxetta proxy are wired to the aspects."}
{"ID": 889, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbTransactionMode convertToDbMode(final JtxTransactionMode txMode) { final int isolation; switch (txMode.getIsolationLevel()) { case ISOLATION_DEFAULT: isolation = DbTransactionMode.ISOLATION_DEFAULT; break; case ISOLATION_NONE: isolation = DbTransactionMode.ISOLATION_NONE; break; case ISOLATION_READ_COMMITTED: isolation = DbTransactionMode.ISOLATION_READ_COMMITTED; break; case ISOLATION_READ_UNCOMMITTED: isolation = DbTransactionMode.ISOLATION_READ_UNCOMMITTED; break; case ISOLATION_REPEATABLE_READ: isolation = DbTransactionMode.ISOLATION_REPEATABLE_READ; break; case ISOLATION_SERIALIZABLE: isolation = DbTransactionMode.ISOLATION_SERIALIZABLE; break; default: throw new IllegalArgumentException(); } return new DbTransactionMode(isolation, txMode.isReadOnly()); } \nResponse:", "ground_truth": "Converter JTX transaction mode to DB transaction mode.", "predict": " Convert isolation level to isolation mode. @param txMode isolation level @return isolation mode\n*/"}
{"ID": 890, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object readProperty(final Object source, final PropertyDescriptor propertyDescriptor) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { try { return getter.invokeGetter(source); } catch (Exception ex) { throw new JsonException(ex); } } return null; } \nResponse:", "ground_truth": "Reads property using property descriptor.", "predict": " Reads a property from the source object using reflection. @param source Source object. @param propertyDescriptor Property descriptor. @return Property value."}
{"ID": 891, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void putAll(final Map t) { for (Object o : t.entrySet()) { Map.Entry e = (Map.Entry) o; put(e.getKey(), e.getValue()); } } \nResponse:", "ground_truth": "Copies all of the mappings from the specified map to this one.\nThese mappings replace any mappings that this map had for any of the\nkeys currently in the specified Map.\n\n@param t Mappings to be stored in this map.", "predict": " Copies all mappings from the specified map to this map. These mappings replace any mappings that this map had for any of the keys currently in the specified map. @param t the map whose mappings are to be stored in this map */\npublic void putAll(final Map t) {\n\tfor (Object o : t.entrySet()) {\n\t\tMap.Entry e = (Map.Entry) o;\n\t\tput(e.getKey(), e.getValue());\n\t}\n}\n\n/** Copies all mappings from the specified map to this map. These mappings replace any mappings that this map had for any of the keys currently in the specified map. */\npublic void putAll(final Map t) {\n\tfor (Object o : t.entrySet()) {\n\t\tMap.Entry e = (Map.Entry) o;\n\t\tput(e.getKey(), e.getValue());\n\t}\n}\n\n/** Removes all mappings from this map."}
{"ID": 892, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Buffer append(final Buffer buffer) { if (buffer.list.isEmpty()) { // nothing to append return buffer; } list.addAll(buffer.list); last = buffer.last; size += buffer.size; return this; } \nResponse:", "ground_truth": "Appends other buffer to this one.", "predict": " Append the content of another buffer to this one. @param buffer Buffer to append. @return This buffer.\n*/"}
{"ID": 893, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final Writer writer) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] array = fastByteBuffer.toArray(); writer.write(new String(array, StringPool.ISO_8859_1)); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, writer, StringPool.ISO_8859_1); } finally { StreamUtil.close(inputStream); } } } } \nResponse:", "ground_truth": "Writes content to the writer.", "predict": " Writes the contents of the FastByteArrayOutputStream to the Writer. @param writer Writer to write to. @throws IOException Writing problems."}
{"ID": 894, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final OutputStream out) throws IOException { for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; out.write(fastByteBuffer.toArray()); } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); try { StreamUtil.copy(inputStream, out); } finally { StreamUtil.close(inputStream); } } } } \nResponse:", "ground_truth": "Writes content to the output stream.", "predict": " Write the contents of this FastByteBufferList to the OutputStream. @param out OutputStream to write to. @throws IOException On error."}
{"ID": 895, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeTo(final OutputStream out, final HttpProgressListener progressListener) throws IOException { // start final int size = size(); final int callbackSize = progressListener.callbackSize(size); int count = 0; // total count int step = 0; // step is offset in current chunk progressListener.transferred(count); // loop for (Object o : list) { if (o instanceof FastByteBuffer) { FastByteBuffer fastByteBuffer = (FastByteBuffer) o; byte[] bytes = fastByteBuffer.toArray(); int offset = 0; while (offset < bytes.length) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the bytes array if (offset + chunk > bytes.length) { chunk = bytes.length - offset; } // writes the chunk out.write(bytes, offset, chunk); offset += chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } else if (o instanceof Uploadable) { Uploadable uploadable = (Uploadable) o; InputStream inputStream = uploadable.openInputStream(); int remaining = uploadable.getSize(); try { while (remaining > 0) { // calc the remaining sending chunk size int chunk = callbackSize - step; // check if this chunk size fits the remaining size if (chunk > remaining) { chunk = remaining; } // writes remaining chunk StreamUtil.copy(inputStream, out, chunk); remaining -= chunk; step += chunk; count += chunk; // listener if (step >= callbackSize) { progressListener.transferred(count); step -= callbackSize; } } } finally { StreamUtil.close(inputStream); } } } // end if (step != 0) { progressListener.transferred(count); } } \nResponse:", "ground_truth": "Writes content to the output stream, using progress listener to track the sending progress.", "predict": " Writes the Uploadable to the OutputStream. @param out The OutputStream to write to. @param progressListener The ProgressListener to report progress to. Can be null. @throws IOException On I/O errors."}
{"ID": 896, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getString(final String key) { CharSequence cs = (CharSequence) map.get(key); return cs == null ? null : cs.toString(); } \nResponse:", "ground_truth": "Returns the string value with the specified key.", "predict": " Returns the value associated with the given key as a String. Returns null if no value is associated with the key. @param key The key whose associated value is to be returned. @return The value associated with the given key as a String. Returns null if no value is associated with the key."}
{"ID": 897, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Integer getInteger(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Integer) { return (Integer) number; } return number.intValue(); } \nResponse:", "ground_truth": "returns the integer value with the specified key.", "predict": " Get the integer value for the given key. @param key The key whose value is sought. @return The integer value for the given key. May be null."}
{"ID": 898, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Long getLong(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Long) { return (Long) number; } return number.longValue(); } \nResponse:", "ground_truth": "Returns the long value with the specified key.", "predict": " Get a long value from the configuration map. @param key The key to look up. @return The long value, or null if not found."}
{"ID": 899, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Double getDouble(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Double) { return (Double) number; } return number.doubleValue(); } \nResponse:", "ground_truth": "Returns the double value with the specified key.", "predict": " Get double value from hazelcast map. @param key the key @return double value\n*/"}
{"ID": 900, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Float getFloat(final String key) { Number number = (Number) map.get(key); if (number == null) { return null; } if (number instanceof Float) { return (Float) number; } return number.floatValue(); } \nResponse:", "ground_truth": "Returns the float value with the specified key.", "predict": " Get float value from hazelcast map. @param key map key @return float value"}
{"ID": 901, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T> T getValue(final String key) { T val = (T) map.get(key); if (val instanceof Map) { return (T) new JsonObject((Map) val); } if (val instanceof List) { return (T) new JsonArray((List) val); } return val; } \nResponse:", "ground_truth": "Returns the value with the specified key, as an object.", "predict": " Get a value from the JsonObject. @param key The key whose value is to be returned. @return The value for the key.\n*/"}
{"ID": 902, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonObject put(final String key, final String value) { Objects.requireNonNull(key); map.put(key, value); return this; } \nResponse:", "ground_truth": "Puts a string into the JSON object with the specified key.", "predict": " Associates a key with a value. @param key The key. Cannot be null. @param value The value. Cannot be null. @return The fluent interface. Never null."}
{"ID": 903, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useFolder(final String folderName) { closeFolderIfOpened(folder); try { this.folderName = folderName; this.folder = getService().getFolder(folderName); try { folder.open(Folder.READ_WRITE); } catch (final MailException ignore) { folder.open(Folder.READ_ONLY); } } catch (final MessagingException msgexc) { throw new MailException(\"Failed to connect to folder: \" + folderName, msgexc); } } \nResponse:", "ground_truth": "Opens new folder and closes previously opened folder.\n\n@param folderName Folder to open", "predict": " Use a folder. @param folderName Folder name.\n*/"}
{"ID": 904, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: ReceivedEmail[] receiveMessages( final EmailFilter filter, final Flags flagsToSet, final Flags flagsToUnset, final boolean envelope, final Consumer<Message[]> processedMessageConsumer) { useAndOpenFolderIfNotSet(); final Message[] messages; try { if (filter == null) { messages = folder.getMessages(); } else { messages = folder.search(filter.getSearchTerm()); } if (messages.length == 0) { return ReceivedEmail.EMPTY_ARRAY; } if (envelope) { final FetchProfile fetchProfile = new FetchProfile(); fetchProfile.add(FetchProfile.Item.ENVELOPE); fetchProfile.add(FetchProfile.Item.FLAGS); folder.fetch(messages, fetchProfile); } // process messages final ReceivedEmail[] emails = new ReceivedEmail[messages.length]; for (int i = 0; i < messages.length; i++) { final Message msg = messages[i]; // we need to parse message BEFORE flags are set! emails[i] = new ReceivedEmail(msg, envelope, attachmentStorage); if (!EmailUtil.isEmptyFlags(flagsToSet)) { emails[i].flags(flagsToSet); msg.setFlags(flagsToSet, true); } if (!EmailUtil.isEmptyFlags(flagsToUnset)) { emails[i].flags().remove(flagsToUnset); msg.setFlags(flagsToUnset, false); } if (EmailUtil.isEmptyFlags(flagsToSet) && !emails[i].isSeen()) { msg.setFlag(Flags.Flag.SEEN, false); } } if (processedMessageConsumer != null) { processedMessageConsumer.accept(messages); } // if messages were marked to be deleted, we need to expunge the folder if (!EmailUtil.isEmptyFlags(flagsToSet)) { if (flagsToSet.contains(Flags.Flag.DELETED)) { folder.expunge(); } } return emails; } catch (final MessagingException msgexc) { throw new MailException(\"Failed to fetch messages\", msgexc); } } \nResponse:", "ground_truth": "The main email receiving method.", "predict": " Receives messages matching the given filter. Flags are set according to the flagsToSet and flagsToUnset arguments. Flags are unset according to the flagsToUnset argument. Additionally, if envelope is true, envelope information is extracted from the fetched messages. Additionally, if processedMessageConsumer is not null, it is called with the fetched messages. @param filter The filter to apply. May be null. @param flagsToSet Flags to set on the fetched messages. May be null. @param flagsToUnset Flags to unset on the fetched messages. May be null. @param envelope Whether to extract envelope information from the fetched messages. @param processedMessageConsumer The consumer to call with the fetched messages. May be null. @return The fetched messages. Never null. May be empty. May contain duplicates. May contain messages flagged as deleted. May contain messages flagged as seen. May contain messages flagged as answered. May contain messages flagged as draft. May contain messages flagged as spam. May contain messages flagged as viruses"}
{"ID": 905, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void updateEmailFlags(final ReceivedEmail receivedEmail) { useAndOpenFolderIfNotSet(); try { folder.setFlags(new int[] {receivedEmail.messageNumber()}, receivedEmail.flags(),true); } catch (MessagingException mex) { throw new MailException(\"Failed to fetch messages\", mex); } } \nResponse:", "ground_truth": "Updates the email flags on the server.", "predict": " Update the flags for the given email. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent. The flags are applied to the email and the email is resent."}
{"ID": 906, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void closeFolderIfOpened(final Folder folder) { if (folder != null) { try { folder.close(true); } catch (final MessagingException ignore) { } } } \nResponse:", "ground_truth": "Closes folder if opened and expunge deleted messages.", "predict": " Close the given Folder if it's currently open. Never call this method with a null argument. Instead, rely on Gmail to refrain from opening folders unless absolutely necessary.\n"}
{"ID": 907, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: DbQueryNamedParameter lookupNamedParameter(final String name) { DbQueryNamedParameter p = rootNP; while (p != null) { if (p.equalsName(name)) { return p; } p = p.next; } return null; } \nResponse:", "ground_truth": "Lookup for named parameter.", "predict": " Looks up named parameter. @param name Name of parameter to look up. @return Named parameter or null if not found."}
{"ID": 908, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String alias(final String target) { return StringPool.LEFT_CHEV.concat(target).concat(StringPool.RIGHT_CHEV); } \nResponse:", "ground_truth": "Creates alias.", "predict": " Alias for the given target. @param target Target string. @return Alias string."}
{"ID": 909, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean validateAction(final String... profiles) { prepareValidator(); vtor.useProfiles(profiles); vtor.validate(this); vtor.resetProfiles(); List<Violation> violations = vtor.getViolations(); return violations == null; } \nResponse:", "ground_truth": "Validates action. Profiles are reset after the invocation.\n@return <code>true</code> if validation is successful, otherwise returns <code>false</code>", "predict": " Validate the bean against the rules defined by the annotations. @param profiles The profiles to activate. @return True if there are no violations, false otherwise."}
{"ID": 910, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addViolation(final String name, final Object invalidValue) { prepareValidator(); vtor.addViolation(new Violation(name, this, invalidValue)); } \nResponse:", "ground_truth": "Adds action violation.", "predict": " Adds violation with violation message. @param name Violation name. @param invalidValue Violated value."}
{"ID": 911, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RawData as(final String mimeOrExtension) { if (mimeOrExtension.contains(StringPool.SLASH)) { this.mimeType = mimeOrExtension; } else { this.mimeType = MimeTypes.getMimeType(mimeOrExtension); } return this; } \nResponse:", "ground_truth": "Defines mime type by providing real mime type or just extension!", "predict": " Sets the mimetype or extension of the RawData. Useful for determining the mimeType of a binary attachment. @param mimeOrExtension mimetype or extension of the RawData. @return this\n"}
{"ID": 912, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RawData downloadableAs(final String downloadFileName) { this.downloadFileName = downloadFileName; this.mimeType = MimeTypes.getMimeType(FileNameUtil.getExtension(downloadFileName)); return this; } \nResponse:", "ground_truth": "Defines download file name and mime type from the name extension.", "predict": " Provide a downloadable file name for the raw data download. @param downloadFileName the downloadable file name @return the builder\n*/"}
{"ID": 913, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T setTarget(final InputStream target) { assertTargetIsNotDefined(); targetInputStream = target; targetClass = null; targetClassName = null; return _this(); } \nResponse:", "ground_truth": "Defines class input stream as a target.", "predict": " Associate the target of the DSL to an InputStream. Useful when dealing with large streams. @param target The target InputStream. @return The builder. Useful to call again with other InputStream.\n */ assumed publicly accessible."}
{"ID": 914, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T setTarget(final String targetName) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(targetName); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + targetName); } targetClassName = targetName; targetClass = null; } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to get stream class name: \" + targetName, ioex); } return _this(); } \nResponse:", "ground_truth": "Defines class name as a target.\nClass will not be loaded by classloader!", "predict": " Set target class name. Usually you don't need to call this method. Instead you can use {@link #setProxyTargetClass(boolean)} method. However, you can use this method to set target class name before weaving proxy class. @param targetName Target class name. @return Self reference.\n*/"}
{"ID": 915, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T setTarget(final Class target) { assertTargetIsNotDefined(); try { targetInputStream = ClassLoaderUtil.getClassAsStream(target); if (targetInputStream == null) { throw new ProxettaException(\"Target class not found: \" + target.getName()); } targetClass = target; targetClassName = target.getName(); } catch (IOException ioex) { StreamUtil.close(targetInputStream); throw new ProxettaException(\"Unable to stream class: \" + target.getName(), ioex); } return _this(); } \nResponse:", "ground_truth": "Defines class as a target.", "predict": " Specify target class. Cannot be changed during weaving process. @param target Target class. Cannot be null. @return InterceptorBuilder. Never null."}
{"ID": 916, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void process() { if (targetInputStream == null) { throw new ProxettaException(\"Target missing: \" + targetClassName); } // create class reader final ClassReader classReader; try { classReader = new ClassReader(targetInputStream); } catch (IOException ioex) { throw new ProxettaException(\"Error reading class input stream\", ioex); } // reads information final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader(proxetta.getClassLoader()); classReader.accept(targetClassInfoReader, 0); this.destClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES); // create proxy if (log.isDebugEnabled()) { log.debug(\"processing: \" + classReader.getClassName()); } WorkData wd = process(classReader, targetClassInfoReader); // store important data proxyApplied = wd.proxyApplied; proxyClassName = wd.thisReference.replace('/', '.'); } \nResponse:", "ground_truth": "Reads the target and creates destination class.", "predict": " Process class file."}
{"ID": 917, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] create() { process(); byte[] result = toByteArray(); dumpClassInDebugFolder(result); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } return null; } if (log.isDebugEnabled()) { log.debug(\"Proxy created \" + StringUtil.toSafeString(targetClassName)); } return result; } \nResponse:", "ground_truth": "Returns byte array of created class.", "predict": " Create proxy. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by reflection. Usually invoked by"}
{"ID": 918, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class define() { process(); if ((!proxetta.isForced()) && (!isProxyApplied())) { if (log.isDebugEnabled()) { log.debug(\"Proxy not applied: \" + StringUtil.toSafeString(targetClassName)); } if (targetClass != null) { return targetClass; } if (targetClassName != null) { try { return ClassLoaderUtil.loadClass(targetClassName); } catch (ClassNotFoundException cnfex) { throw new ProxettaException(cnfex); } } } if (log.isDebugEnabled()) { log.debug(\"Proxy created: \" + StringUtil.toSafeString(targetClassName)); } try { ClassLoader classLoader = proxetta.getClassLoader(); if (classLoader == null) { classLoader = ClassLoaderUtil.getDefaultClassLoader(); if ((classLoader == null) && (targetClass != null)) { classLoader = targetClass.getClassLoader(); } } final byte[] bytes = toByteArray(); dumpClassInDebugFolder(bytes); return DefineClass.of(getProxyClassName(), bytes, classLoader); } catch (Exception ex) { throw new ProxettaException(\"Class definition failed\", ex); } } \nResponse:", "ground_truth": "Defines class.", "predict": " Define proxy class. Usually you don't need to redefine proxy class. However, redefining proxy class is required for redefining interceptors. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class is dangerous. Therefore, redefining proxy class"}
{"ID": 919, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object newInstance() { Class type = define(); try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new ProxettaException(\"Invalid Proxetta class\", ex); } } \nResponse:", "ground_truth": "Creates new instance of created class.\nAssumes default no-arg constructor.", "predict": " Create new proxetta instance. @return new proxetta instance."}
{"ID": 920, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void dumpClassInDebugFolder(final byte[] bytes) { File debugFolder = proxetta.getDebugFolder(); if (debugFolder == null) { return; } if (!debugFolder.exists() || !debugFolder.isDirectory()) { log.warn(\"Invalid debug folder: \" + debugFolder); } String fileName = proxyClassName; if (fileName == null) { fileName = \"proxetta-\" + System.currentTimeMillis(); } fileName += \".class\"; File file = new File(debugFolder, fileName); try { FileUtil.writeBytes(file, bytes); } catch (IOException ioex) { log.warn(\"Error writing class as \" + file, ioex); } } \nResponse:", "ground_truth": "Writes created class content to output folder for debugging purposes.", "predict": " Dump class bytes into debug folder. Useful for debugging purposes. @param bytes class bytes\n*/"}
{"ID": 921, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T from(final String personalName, final String from) { return from(new EmailAddress(personalName, from)); } \nResponse:", "ground_truth": "Sets the FROM address by providing personal name and address.\n\n@param personalName personal name.\n@param from         email address.\n@return this\n@see #from(EmailAddress)", "predict": " Create a new mailing address with the specified personal name and email address. Personal name may be omitted if email address is supplied. @param personalName Personal name of sender. May be omitted if email address is supplied. @param from Email address of sender. May be omitted if personal name is supplied. @return New mailing address. Never null."}
{"ID": 922, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T to(final EmailAddress to) { this.to = ArraysUtil.append(this.to, to); return _this(); } \nResponse:", "ground_truth": "Appends TO address.\n\n@param to {@link EmailAddress} to add.\n@return this", "predict": " Adds recipients to the TO recipients of the email. @param to The email address of the recipient. @return Fluent API: Allows chaining of methods.\n*/"}
{"ID": 923, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T to(final String personalName, final String to) { return to(new EmailAddress(personalName, to)); } \nResponse:", "ground_truth": "Appends TO address by personal name and email address.\n\n@param personalName personal name.\n@param to           email address.\n@return this\n@see #to(EmailAddress)", "predict": " Specify a personal name and email address to send replies to. Useful for automated replies. @param personalName Personal name of the reply-to email address. @param to Email address of the reply-to email address. @return Fluent API allowing chained assertions on the created fluent email.\n"}
{"ID": 924, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T replyTo(final EmailAddress... replyTo) { this.replyTo = ArraysUtil.join(this.replyTo, valueOrEmptyArray(replyTo)); return _this(); } \nResponse:", "ground_truth": "Appends REPLY-TO addresses.\n\n@param replyTo vararg of {@link EmailAddress}es to set.\n@return this", "predict": " Set Reply To recipients. Similar to BCC recipients except these addresses will receive copies of all emails sent through SendGrid. Separate multiple Reply To addresses with a comma. @param replyTo Comma separated list of email addresses. @return this\n*/"}
{"ID": 925, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T cc(final EmailAddress... ccs) { this.cc = ArraysUtil.join(this.cc, valueOrEmptyArray(ccs)); return _this(); } \nResponse:", "ground_truth": "Appends CC addresses.\n\n@param ccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " Comma separated list of email addresses. @param ccs Comma separated list of email addresses. @return Fluent API"}
{"ID": 926, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T textMessage(final String text, final String encoding) { return message(new EmailMessage(text, MimeTypes.MIME_TEXT_PLAIN, encoding)); } \nResponse:", "ground_truth": "Adds plain message text.\n\n@param text     The text to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Send plain text message. @param text Plain text message. @param encoding Plain text encoding. @return Fluent API."}
{"ID": 927, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T htmlMessage(final String html, final String encoding) { return message(new EmailMessage(html, MimeTypes.MIME_TEXT_HTML, encoding)); } \nResponse:", "ground_truth": "Adds HTML message.\n\n@param html     The HTML to add as a {@link String}.\n@param encoding The encoding as a {@link String}.\n@return this\n@see #message(EmailMessage)", "predict": " Alternative constructor that takes html and encoding. @param html The html content. @param encoding The encoding of the html. @return The EmailMessage.\n*/"}
{"ID": 928, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T header(final String name, final String value) { headers.put(name, value); return _this(); } \nResponse:", "ground_truth": "Sets header value.\n\n@param name  The name of the header.\n@param value The value of the header.\n@return this", "predict": " Set header value. @param name header name @param value header value @return Fluent API\n*/"}
{"ID": 929, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String get(final String name, final String defaultValue) { Objects.requireNonNull(name); String value = null; try { if (System.getSecurityManager() == null) { value = System.getProperty(name); } else { value = AccessController.doPrivileged((PrivilegedAction<String>) () -> System.getProperty(name)); } } catch (Exception ignore) { } if (value == null) { return defaultValue; } return value; } \nResponse:", "ground_truth": "Returns system property. If key is not available, returns the default value.", "predict": " Get a system property. The security manager restricts access to system properties. @param name the system property name. @param defaultValue the default value. @return the system property value or the default value if the property is not defined.\n*/"}
{"ID": 930, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean getBoolean(final String name, final boolean defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); switch (value) { case \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true; case \"false\": case \"no\" : case \"0\" : case \"off\" : return false; default: return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as boolean.", "predict": " Gets a boolean value from the configuration. The default value is returned if the configuration doesn't contain the key or the value is not a valid boolean. @param name The name of the configuration value. @param defaultValue The default value. @return The configuration value or the default value.\n*/"}
{"ID": 931, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getInt(final String name, final int defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Integer.parseInt(value); } catch (NumberFormatException nfex) { return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as an int.", "predict": " Get the named integer value from the configuration. The value may be prefixed by a \"-\" to indicate a negative value. If the value is not present, the defaultValue is returned. @param name The name of the property to look up. @param defaultValue The value to return if the named property is not present. @return The integer value of the named property, or the defaultValue if the property is not present.\n**/"}
{"ID": 932, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getLong(final String name, final long defaultValue) { String value = get(name); if (value == null) { return defaultValue; } value = value.trim().toLowerCase(); try { return Long.parseLong(value); } catch (NumberFormatException nfex) { return defaultValue; } } \nResponse:", "ground_truth": "Returns system property as a long.", "predict": " Get a long value from the configuration. The value may be prefixed by a description of the units it is in, e.g. \"10GB\". If no units are found, assume a simple integer value. @param name The name of the value to get. @param defaultValue The default value to return if no value is found. @return The long value.\n*/"}
{"ID": 933, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: MethodParameter[] getResolvedParameters() { if (paramExtractor == null) { return MethodParameter.EMPTY_ARRAY; } if (!paramExtractor.debugInfoPresent) { throw new ParamoException(\"Parameter names not available for method: \" + declaringClass.getName() + '#' + methodName); } return paramExtractor.getMethodParameters(); } \nResponse:", "ground_truth": "Returns method parameters once when method is parsed.\nIf method has no parameters, an empty array is returned.", "predict": " Returns the resolved parameters of the intercepted method. @return the resolved parameters of the intercepted method\n*/"}
{"ID": 934, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int serializeKeyValue(final JsonContext jsonContext, final Path currentPath, final Object key, final Object value, int count) { if ((value == null) && jsonContext.isExcludeNulls()) { return count; } if (key != null) { currentPath.push(key.toString()); } else { currentPath.push(StringPool.NULL); } // check if we should include the field boolean include = true; if (value != null) { // + all collections are not serialized by default include = jsonContext.matchIgnoredPropertyTypes(value.getClass(), false, include); // + path queries: excludes/includes include = jsonContext.matchPathToQueries(include); } // done if (!include) { currentPath.pop(); return count; } if (key == null) { jsonContext.pushName(null, count > 0); } else { jsonContext.pushName(key.toString(), count > 0); } jsonContext.serialize(value); if (jsonContext.isNamePopped()) { count++; } currentPath.pop(); return count; } \nResponse:", "ground_truth": "Serializes key and a value.", "predict": " Serializes a key-value pair. @param jsonContext the json context. @param currentPath the current path. @param key the key. @param value the value. @param count the count. @return the int."}
{"ID": 935, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String lookupAlias(final String alias) { String value = actionsManager.lookupPathAlias(alias); if (value == null) { ActionRuntime cfg = actionsManager.lookup(alias); if (cfg != null) { value = cfg.getActionPath(); } } return value; } \nResponse:", "ground_truth": "Lookups value as an alias and, if not found, as a default alias.", "predict": " Looks up alias in the path alias table. If found, returns the aliased path. Otherwise, returns the original alias. @param alias Alias to lookup @return Aliased path or original alias\n*/"}
{"ID": 936, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveAlias(final String value) { final StringBuilder result = new StringBuilder(value.length()); int i = 0; int len = value.length(); while (i < len) { int ndx = value.indexOf('<', i); if (ndx == -1) { // alias markers not found if (i == 0) { // try whole string as an alias String alias = lookupAlias(value); return (alias != null ? alias : value); } else { result.append(value.substring(i)); } break; } // alias marked found result.append(value.substring(i, ndx)); ndx++; int ndx2 = value.indexOf('>', ndx); String aliasName = (ndx2 == -1 ? value.substring(ndx) : value.substring(ndx, ndx2)); // process alias String alias = lookupAlias(aliasName); if (alias != null) { result.append(alias); } else { // alias not found if (log.isWarnEnabled()) { log.warn(\"Alias not found: \" + aliasName); } } i = ndx2 + 1; } // fix prefix '//' - may happened when aliases are used i = 0; len = result.length(); while (i < len) { if (result.charAt(i) != '/') { break; } i++; } if (i > 1) { return result.substring(i - 1, len); } return result.toString(); } \nResponse:", "ground_truth": "Returns resolved alias result value or passed on, if alias doesn't exist.", "predict": " Resolve alias. @param value The value to resolve. @return The resolved value.\n*/"}
{"ID": 937, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResultPath resolveResultPath(String path, String value) { boolean absolutePath = false; if (value != null) { // [*] resolve alias in value value = resolveAlias(value); // [*] absolute paths if (StringUtil.startsWithChar(value, '/')) { absolutePath = true; int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path = value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { path = value; value = null; } } else { // [*] resolve # in value and path int i = 0; while (i < value.length()) { if (value.charAt(i) != '#') { break; } int dotNdx = MadvocUtil.lastIndexOfSlashDot(path); if (dotNdx != -1) { // dot found path = path.substring(0, dotNdx); } i++; } if (i > 0) { // remove # from value value = value.substring(i); // [*] update path and value if (StringUtil.startsWithChar(value, '.')) { value = value.substring(1); } else { int dotNdx = value.indexOf(\"..\"); if (dotNdx != -1) { path += '.' + value.substring(0, dotNdx); value = value.substring(dotNdx + 2); } else { if (value.length() > 0) { if (StringUtil.endsWithChar(path, '/')) { path += value; } else { path += '.' + value; } } value = null; } } } } } if (!absolutePath) { if (resultPathPrefix != null) { path = resultPathPrefix + path; } } return new ResultPath(path, value); } \nResponse:", "ground_truth": "Resolves result path.", "predict": " Resolve result path. @param path Parameter path. @param value Parameter value. @return ResultPath instance."}
{"ID": 938, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveResultPathString(final String path, final String value) { final ResultPath resultPath = resolveResultPath(path, value); final String result = resultPath.pathValue(); return resolveAlias(result); } \nResponse:", "ground_truth": "Resolves result path as a string, when parts are not important\nand when only full string matters. Additional alias resolving\non full path is done.", "predict": " Resolve the result path string. @param path the path @param value the value @return the string\n*/"}
{"ID": 939, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int lastIndexOfSlashDot(final String str) { int slashNdx = str.lastIndexOf('/'); int dotNdx = StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); if (dotNdx == -1) { if (slashNdx == -1) { return -1; } slashNdx++; if (slashNdx < str.length() - 1) { dotNdx = slashNdx; } else { dotNdx = -1; } } return dotNdx; } \nResponse:", "ground_truth": "Locates last dot after the last slash or just slash.", "predict": " Returns the index of the last slash or dot in the given string. Returns -1 if neither slash nor dot is contained in the string. @param str Input string. Shall not be <code>null</code>. @return Returns the index of the last slash or dot in the given string. Returns -1 if neither slash nor dot is contained in the string. Shall not be <code>null</code>."}
{"ID": 940, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int lastIndexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); slashNdx++; return StringUtil.lastIndexOf(str, '.', str.length(), slashNdx); } \nResponse:", "ground_truth": "Locates last index of dot after the optional last slash.", "predict": " Returns the index of the last dot after the slash. Strips leading slashes. Stripping is needed to determine the dot index in case of UNC paths. Stripping also prevents hitting the drive letter limit imposed by Windows. Stripping is done before checking for dots because UNC paths are likely to contain periods whereas drive letters are unlikely to contain periods. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done before determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often used as path separators. Stripping is done after determining the dot index because dots are often"}
{"ID": 941, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOfDotAfterSlash(final String str) { int slashNdx = str.lastIndexOf('/'); if (slashNdx == -1) { slashNdx = 0; } return str.indexOf('.', slashNdx); } \nResponse:", "ground_truth": "Locates first dot after the last slash.", "predict": " Returns the index of the first dot after the last slash. Strips leading slashes. Stripping is skipped if the dot is preceded by a slash. Stripping is skipped if the dot is preceded by a slash and preceded by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stripping is skipped if the dot is followed by a slash. Stripping is skipped if the dot is followed by a slash and followed by a slash too. Stripping is skipped if the dot is followed by a slash and preceded by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stripping is skipped if the dot is preceded by a slash and followed by a slash too. Stri"}
{"ID": 942, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripLastCamelWord(String name) { int ndx = name.length() - 1; while (ndx >= 0) { if (CharUtil.isUppercaseAlpha(name.charAt(ndx))) { break; } ndx--; } if (ndx >= 0) { name = name.substring(0, ndx); } return name; } \nResponse:", "ground_truth": "Removes last CamelWord", "predict": " Strips the last CamelCase word from the string. Useful for SnakeYaml snake case. @param name the string to strip\n * @return the stripped string\n */"}
{"ID": 943, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveSchemaName(final Class<?> type, final String defaultSchemaName) { String schemaName = null; final DbTable dbTable = type.getAnnotation(DbTable.class); if (dbTable != null) { schemaName = dbTable.schema().trim(); } if ((schemaName == null) || (schemaName.length() == 0)) { schemaName = defaultSchemaName; } return schemaName; } \nResponse:", "ground_truth": "Resolves schema name from a type. Uses default schema name if not specified.", "predict": " Resolve schema name. @param type the type @param defaultSchemaName the default schema name @return the string\n*/"}
{"ID": 944, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbEntityColumnDescriptor resolveColumnDescriptors( final DbEntityDescriptor dbEntityDescriptor, final PropertyDescriptor property, final boolean isAnnotated, final ColumnNamingStrategy columnNamingStrategy) { String columnName = null; boolean isId = false; Class<? extends SqlType> sqlTypeClass = null; // read ID annotation DbId dbId = null; if (property.getFieldDescriptor() != null) { dbId = property.getFieldDescriptor().getField().getAnnotation(DbId.class); } if (dbId == null && property.getReadMethodDescriptor() != null) { dbId = property.getReadMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId == null && property.getWriteMethodDescriptor() != null) { dbId = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbId.class); } if (dbId != null) { columnName = dbId.value().trim(); sqlTypeClass = dbId.sqlType(); isId = true; } else { DbColumn dbColumn = null; if (property.getFieldDescriptor() != null) { dbColumn = property.getFieldDescriptor().getField().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getReadMethodDescriptor() != null) { dbColumn = property.getReadMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn == null && property.getWriteMethodDescriptor() != null) { dbColumn = property.getWriteMethodDescriptor().getMethod().getAnnotation(DbColumn.class); } if (dbColumn != null) { columnName = dbColumn.value().trim(); sqlTypeClass = dbColumn.sqlType(); } else { if (isAnnotated) { return null; } } } if (StringUtil.isEmpty(columnName)) { // default annotation value columnName = columnNamingStrategy.convertPropertyNameToColumnName(property.getName()); } else { if (!columnNamingStrategy.isStrictAnnotationNames()) { columnName = columnNamingStrategy.applyToColumnName(columnName); } } if (sqlTypeClass == SqlType.class) { sqlTypeClass = null; } return new DbEntityColumnDescriptor( dbEntityDescriptor, quoteIfRequired(columnName, columnNamingStrategy.isAlwaysQuoteNames(), columnNamingStrategy.getQuoteChar()), property.getName(), property.getType(), isId, sqlTypeClass); } \nResponse:", "ground_truth": "Resolves column descriptor from property. If property is annotated value will be read\nfrom annotation. If property is not annotated, then property will be ignored\nif entity is annotated. Otherwise, column name is generated from the property name.", "predict": " Resolve column descriptors. @param dbEntityDescriptor the db entity descriptor @param property the property @param isAnnotated the is annotated @param columnNamingStrategy the column naming strategy @return the db entity column descriptor"}
{"ID": 945, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(final long[] key, final long[] tweak) { final int newNw = key.length; // only create new arrays if the value of N{w} changes (different key size) if (nw != newNw) { nw = newNw; switch (nw) { case WORDS_4: pi = PI4; rpi = RPI4; r = R4; break; case WORDS_8: pi = PI8; rpi = RPI8; r = R8; break; case WORDS_16: pi = PI16; rpi = RPI16; r = R16; break; default: throw new RuntimeException(\"Invalid threefish key\"); } this.k = new long[nw + 1]; // instantiation of these fields here for performance reasons vd = new long[nw]; // v is the intermediate value v{d} at round d ed = new long[nw]; // ed is the value of e{d} at round d fd = new long[nw]; // fd is the value of f{d} at round d ksd = new long[nw]; // ksd is the value of k{s} at round d } System.arraycopy(key, 0, this.k, 0, key.length); long knw = EXTENDED_KEY_SCHEDULE_CONST; for (int i = 0; i < nw; i++) { knw ^= this.k[i]; } this.k[nw] = knw; // set tweak values t[0] = tweak[0]; t[1] = tweak[1]; t[2] = t[0] ^ t[1]; } \nResponse:", "ground_truth": "Initialize the cipher using the key and the tweak value.\n\n@param key the Threefish key to use\n@param tweak the tweak values to use", "predict": " Initialize the cipher in the specified mode with the given key and tweak values. The tweak values are ignored unless the tweak mode is enabled. The key schedule is reinitialized. The tweak values are ignored unless the tweak mode is enabled. The key schedule is reinitialized. @param key The symmetric key to use. @param tweak The tweak value to use. Ignored unless the tweak mode is enabled."}
{"ID": 946, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void mix(final int j, final int d) { y[0] = x[0] + x[1]; final long rotl = r[d % DEPTH_OF_D_IN_R][j]; // java left rotation for a long y[1] = (x[1] << rotl) | (x[1] >>> (Long.SIZE - rotl)); y[1] ^= y[0]; } \nResponse:", "ground_truth": "Implementation of the MIX function.\n\n@param j the index in the rotation constants\n@param d the round", "predict": " Mixes the values in the sponge. The sponge is reinitialized if necessary. The sponge must be reinitialized after calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling this method. The sponge must NOT be reinitialized before calling"}
{"ID": 947, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void demix(final int j, final int d) { y[1] ^= y[0]; final long rotr = r[d % DEPTH_OF_D_IN_R][j]; // NOTE performance: darn, creation on stack! // right shift x[1] = (y[1] << (Long.SIZE - rotr)) | (y[1] >>> rotr); x[0] = y[0] - x[1]; } \nResponse:", "ground_truth": "Implementation of the un-MIX function.", "predict": " Mixes the contribution of a single branch. Mixing is destructive, so the original contributions are recovered afterwards.\nThe idea is to mix the contribution of each branch independently, distributing the workload equally among all branches.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that preceded it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that followed it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that preceded it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that followed it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that preceded it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that followed it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that preceded it.\nThe contribution of a single branch is recovered by combining it with the contribution of all branches that"}
{"ID": 948, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void keySchedule(final int s) { for (int i = 0; i < nw; i++) { // just put in the main key first ksd[i] = k[(s + i) % (nw + 1)]; // don't add anything for i = 0,...,Nw - 4 if (i == nw - 3) { // second to last ksd[i] += t[s % TWEAK_VALUES]; } else if (i == nw - 2) { // first to last ksd[i] += t[(s + 1) % TWEAK_VALUES]; } else if (i == nw - 1) { // last ksd[i] += s; } } } \nResponse:", "ground_truth": "Creates the subkeys.\n\n@param s the value of the round devided by 4", "predict": " Apply Keccak-f permutation to tweakable1600-bit state.\n*/"}
{"ID": 949, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(final String keyMessage, final long tweak1, final long tweak2) { long[] tweak = new long[] {tweak1, tweak2}; byte[] key = new byte[blockSize / Byte.SIZE]; byte[] keyData = StringUtil.getBytes(keyMessage); System.arraycopy(keyData, 0, key, 0, key.length < keyData.length ? key.length : keyData.length); init(bytesToLongs(key), tweak); } \nResponse:", "ground_truth": "Initializes cipher in a simple way.", "predict": " Initialize AES CTR mode with the given key and tweak. @param keyMessage The key message. @param tweak1 The tweak1. @param tweak2 The tweak2."}
{"ID": 950, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public byte[] encryptBlock(final byte[] content, final int offset) { long[] contentBlock = bytesToLongs(content, offset, blockSizeInBytes); long[] encryptedBlock = new long[blockSize / Long.SIZE]; blockEncrypt(contentBlock, encryptedBlock); return longsToBytes(encryptedBlock); } \nResponse:", "ground_truth": "Encrypts a block.", "predict": " Encrypts the content block. @param content The content to encrypt. @param offset The offset in the content where the block starts. @return The encrypted content block."}
{"ID": 951, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static long[] bytesToLongs(final byte[] ba, final int offset, final int size) { long[] result = new long[size >> 3]; int i8 = offset; for (int i = 0; i < result.length; i++) { result[i] = Bits.getLong(ba, i8); i8 += 8; } return result; } \nResponse:", "ground_truth": "Converts segment of byte array into long array.", "predict": " Convert a byte array to a long[] using big-endian ordering. Leaves the input untouched if shorter than 8 bytes. Leaves the high-order bits untouched. @param ba The byte array to convert. @param offset The offset into the byte array. @param size The number of bytes to convert. @return The long[] representation of the bytes. Will be padded with zeros if shorter than 8 bytes. Will preserve the high-order bits untouched."}
{"ID": 952, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String removeAnyBounding(final char s, final char e, final String str) { if (str == null || str.length() < 2) { return str; } if (str.startsWith(String.valueOf(s)) && str.endsWith(String.valueOf(e))) { return str.substring(1, str.length() - 1); } return str; } \nResponse:", "ground_truth": "If the string starts and ends with start and end char, remove them,\notherwise return the string as it was passed in.", "predict": " Remove any surrounding brackets from a string. Useful for removing brackets from a string that might have been accidentally included. @param s the opening bracket character @param e the closing bracket character @param str the string to remove surrounding brackets from @return the string without surrounding brackets\n*/"}
{"ID": 953, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String path() { if (methref != null) { final String methodName = methref.ref(); return target.getName() + '#' + methodName; } return path; } \nResponse:", "ground_truth": "Returns path value.", "predict": " Returns the path of the referenced method.\n@return the path of the referenced method\n*/"}
{"ID": 954, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File zlib(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't zlib folder\"); } FileInputStream fis = new FileInputStream(file); Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION); String zlibFileName = file.getAbsolutePath() + ZLIB_EXT; DeflaterOutputStream dos = new DeflaterOutputStream(new FileOutputStream(zlibFileName), deflater); try { StreamUtil.copy(fis, dos); } finally { StreamUtil.close(dos); StreamUtil.close(fis); } return new File(zlibFileName); } \nResponse:", "ground_truth": "Compresses a file into zlib archive.", "predict": " Zip a file. @param file The file to zip. @return The zipped file. @throws IOException If something went wrong.\n*/"}
{"ID": 955, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File gzip(final File file) throws IOException { if (file.isDirectory()) { throw new IOException(\"Can't gzip folder\"); } FileInputStream fis = new FileInputStream(file); String gzipName = file.getAbsolutePath() + GZIP_EXT; GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(gzipName)); try { StreamUtil.copy(fis, gzos); } finally { StreamUtil.close(gzos); StreamUtil.close(fis); } return new File(gzipName); } \nResponse:", "ground_truth": "Compresses a file into gzip archive.", "predict": " Gzip a file. @param file The file to gzip. @return The gzipped file. @throws IOException If there was an IO error compressing the file.\n*/"}
{"ID": 956, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File ungzip(final File file) throws IOException { String outFileName = FileNameUtil.removeExtension(file.getAbsolutePath()); File out = new File(outFileName); out.createNewFile(); FileOutputStream fos = new FileOutputStream(out); GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(file)); try { StreamUtil.copy(gzis, fos); } finally { StreamUtil.close(fos); StreamUtil.close(gzis); } return out; } \nResponse:", "ground_truth": "Decompress gzip archive.", "predict": " Ungzip the contents of the given file. @param file The file to ungzip. @return The ungzipped file. @throws IOException Something went wrong."}
{"ID": 957, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static List<String> listZip(final File zipFile) throws IOException { List<String> entries = new ArrayList<>(); ZipFile zip = new ZipFile(zipFile); Enumeration zipEntries = zip.entries(); while (zipEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipEntries.nextElement(); String entryName = entry.getName(); entries.add(entryName); } return Collections.unmodifiableList(entries); } \nResponse:", "ground_truth": "Lists zip content.", "predict": " Unpacks a ZIP archive into a flat directory structure. @param zipFile ZIP archive to unpack @return List of files contained within the ZIP archive\n@throws IOException if an I/O error has occurred during unpacking\n*/"}
{"ID": 958, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void unzip(final String zipFile, final String destDir, final String... patterns) throws IOException { unzip(new File(zipFile), new File(destDir), patterns); } \nResponse:", "ground_truth": "Extracts zip file content to the target directory.\n@see #unzip(java.io.File, java.io.File, String...)", "predict": " Extract zip archive to destDir. Patterns are used to filter files to be extracted. Patterns are relative to the root of the zip archive. Patterns are separated by comma. @param zipFile zip archive file. @param destDir destination directory. @param patterns patterns to filter files to be extracted. Patterns are relative to the root of the zip archive. Patterns are separated by comma. @throws IOException if failed to extract."}
{"ID": 959, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addToZip(final ZipOutputStream zos, final File file, String path, final String comment, final boolean recursive) throws IOException { if (!file.exists()) { throw new FileNotFoundException(file.toString()); } if (path == null) { path = file.getName(); } while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } boolean isDir = file.isDirectory(); if (isDir) { // add folder record if (!StringUtil.endsWithChar(path, '/')) { path += '/'; } } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(file.lastModified()); if (comment != null) { zipEntry.setComment(comment); } if (isDir) { zipEntry.setSize(0); zipEntry.setCrc(0); } zos.putNextEntry(zipEntry); if (!isDir) { InputStream is = new FileInputStream(file); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } } zos.closeEntry(); // continue adding if (recursive && file.isDirectory()) { boolean noRelativePath = StringUtil.isEmpty(path); final File[] children = file.listFiles(); if (children != null && children.length != 0) { for (File child : children) { String childRelativePath = (noRelativePath ? StringPool.EMPTY : path) + child.getName(); addToZip(zos, child, childRelativePath, comment, recursive); } } } } \nResponse:", "ground_truth": "Adds single entry to ZIP output stream.\n\n@param zos zip output stream\n@param file file or folder to add\n@param path relative path of file entry; if <code>null</code> files name will be used instead\n@param comment optional comment\n@param recursive when set to <code>true</code> content of added folders will be added, too", "predict": " Adds a file to ZIP archive. @param zos ZIP output stream. @param file ZIP file. @param path ZIP file path. @param comment ZIP file comment. @param recursive Recursive flag. @throws IOException ZIP output error."}
{"ID": 960, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addToZip(final ZipOutputStream zos, final byte[] content, String path, final String comment) throws IOException { while (path.length() != 0 && path.charAt(0) == '/') { path = path.substring(1); } if (StringUtil.endsWithChar(path, '/')) { path = path.substring(0, path.length() - 1); } ZipEntry zipEntry = new ZipEntry(path); zipEntry.setTime(System.currentTimeMillis()); if (comment != null) { zipEntry.setComment(comment); } zos.putNextEntry(zipEntry); InputStream is = new ByteArrayInputStream(content); try { StreamUtil.copy(is, zos); } finally { StreamUtil.close(is); } zos.closeEntry(); } \nResponse:", "ground_truth": "Adds byte content into the zip as a file.", "predict": " Adds content to the ZIP stream. @param zos ZIP output stream. @param content Content to add. @param path Path to add to ZIP. @param comment Comment to add to ZIP. @throws IOException ZIP stream error."}
{"ID": 961, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldDescriptor getFieldDescriptor(final String name, final boolean declared) { final FieldDescriptor fieldDescriptor = getFields().getFieldDescriptor(name); if (fieldDescriptor != null) { if (!fieldDescriptor.matchDeclared(declared)) { return null; } } return fieldDescriptor; } \nResponse:", "ground_truth": "Returns field descriptor.", "predict": " Find field descriptor by name. @param name Field name. @param declared Whether declared or not. @return Field descriptor or null if not found."}
{"ID": 962, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyDescriptor getPropertyDescriptor(final String name, final boolean declared) { PropertyDescriptor propertyDescriptor = getProperties().getPropertyDescriptor(name); if ((propertyDescriptor != null) && propertyDescriptor.matchDeclared(declared)) { return propertyDescriptor; } return null; } \nResponse:", "ground_truth": "Returns property descriptor. Declared flag is matched on both read and write\nmethods.", "predict": " Find a property descriptor by name. If declaredOnly is true, only properties declared in the class hierarchy will be searched. Otherwise, all properties will be searched. @param name Name of the property to find. @param declared Only declared properties will be searched. @return Property descriptor for the named property or null if not found."}
{"ID": 963, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void setRequestBundleName(final ServletRequest request, final String bundleName) { if (log.isDebugEnabled()) { log.debug(\"Bundle name for this request: \" + bundleName); } request.setAttribute(REQUEST_BUNDLE_NAME_ATTR, bundleName); } \nResponse:", "ground_truth": "Sets bundle name for provided servlet request.", "predict": " Sets the bundle name for the current request. Useful for unit testing. @param request ServletRequest @param bundleName Bundle name to set."}
{"ID": 964, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void setSessionLocale(final HttpSession session, final String localeCode) { if (log.isDebugEnabled()) { log.debug(\"Locale stored to session: \" + localeCode); } Locale locale = Locale.forLanguageTag(localeCode); session.setAttribute(SESSION_LOCALE_ATTR, locale); } \nResponse:", "ground_truth": "Saves Locale to HTTP session.", "predict": " Stores locale to session. @param session Session. @param localeCode Locale code."}
{"ID": 965, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Locale getSessionLocale(final HttpSession session) { Locale locale = (Locale) session.getAttribute(SESSION_LOCALE_ATTR); return locale == null ? MESSAGE_RESOLVER.getFallbackLocale() : locale; } \nResponse:", "ground_truth": "Returns current locale from session.\ns", "predict": " Retrieve locale from session. Fallback to system default locale if not found. @param session HttpSession to retrieve locale from. @return Locale from session or fallback locale. Never null."}
{"ID": 966, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] filterParametersForBeanName(String beanName, final boolean resolveReferenceParams) { beanName = beanName + '.'; List<String> list = new ArrayList<>(); for (Map.Entry<String, Object> entry : params.entrySet()) { String key = entry.getKey(); if (!key.startsWith(beanName)) { continue; } list.add(key); if (!resolveReferenceParams) { continue; } // resolve all references String value = PropertiesUtil.resolveProperty(params, key); entry.setValue(value); } if (list.isEmpty()) { return StringPool.EMPTY_ARRAY; } else { return list.toArray(new String[0]); } } \nResponse:", "ground_truth": "Returns an array of param keys that belongs to provided bean.\nOptionally resolves the value of returned parameters.", "predict": " Filters out unwanted parameters from the given bean name. @param beanName the bean name to filter out unwanted parameters from. @param resolveReferenceParams whether to resolve reference parameters. @return the filtered bean name."}
{"ID": 967, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropsEntries profile(final String... profiles) { if (profiles == null) { return this; } for (String profile : profiles) { addProfiles(profile); } return this; } \nResponse:", "ground_truth": "Enables profiles to iterate.", "predict": " Activate profiles. @param profiles Profiles to activate. @return Fluent DSL."}
{"ID": 968, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getLongLittleEndian(final byte[] buf, final int offset) { return ((long) buf[offset + 7] << 56) // no mask needed | ((buf[offset + 6] & 0xffL) << 48) | ((buf[offset + 5] & 0xffL) << 40) | ((buf[offset + 4] & 0xffL) << 32) | ((buf[offset + 3] & 0xffL) << 24) | ((buf[offset + 2] & 0xffL) << 16) | ((buf[offset + 1] & 0xffL) << 8) | ((buf[offset] & 0xffL)); // no shift needed } \nResponse:", "ground_truth": "Gets a long from a byte buffer in little endian byte order.", "predict": " Read 64-bit little endian long.\n@param buf source buffer @param offset offset into buffer @return 64-bit little endian long\n*/"}
{"ID": 969, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] readStream(final InputStream inputStream, final boolean close) throws IOException { if (inputStream == null) { throw new IOException(\"Class not found\"); } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE]; int bytesRead; while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) { outputStream.write(data, 0, bytesRead); } outputStream.flush(); return outputStream.toByteArray(); } finally { if (close) { inputStream.close(); } } } \nResponse:", "ground_truth": "Reads the given input stream and returns its content as a byte array.\n\n@param inputStream an input stream.\n@param close true to close the input stream after reading.\n@return the content of the given input stream.\n@throws IOException if a problem occurs during reading.", "predict": " Reads the contents of the InputStream into a byte array. Optionally closes the stream when done. @param inputStream The InputStream to read. @param close Whether to close the stream when done. @return The contents of the InputStream as a byte array. @throws IOException If there is an error reading from the InputStream.\n*/"}
{"ID": 970, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Label readLabel(final int bytecodeOffset, final Label[] labels) { if (labels[bytecodeOffset] == null) { labels[bytecodeOffset] = new Label(); } return labels[bytecodeOffset]; } \nResponse:", "ground_truth": "Returns the label corresponding to the given bytecode offset. The default implementation of\nthis method creates a label for the given offset if it has not been already created.\n\n@param bytecodeOffset a bytecode offset in a method.\n@param labels the already created labels, indexed by their offset. If a label already exists\nfor bytecodeOffset this method must not create a new one. Otherwise it must store the new\nlabel in this array.\n@return a non null Label, which must be equal to labels[bytecodeOffset].", "predict": " Reads the label at the given BCI. Lazily creates the labels for BCIs which are still unknown. @param bytecodeOffset the BCI to read the label for.\n@return the label at the given BCI. Never returns null.\n*/"}
{"ID": 971, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getTypeAnnotationBytecodeOffset( final int[] typeAnnotationOffsets, final int typeAnnotationIndex) { if (typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets.length || readByte(typeAnnotationOffsets[typeAnnotationIndex]) < TypeReference.INSTANCEOF) { return -1; } return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1); } \nResponse:", "ground_truth": "Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or\n-1 if there is no such type_annotation of if it does not have a bytecode offset.\n\n@param typeAnnotationOffsets the offset of each 'type_annotation' entry in a\nRuntime[In]VisibleTypeAnnotations attribute, or null.\n@param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.\n@return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1\nif there is no such type_annotation of if it does not have a bytecode offset.", "predict": " Returns the offset of the type annotation at the given index in the given array of type annotation offsets. @param typeAnnotationOffsets the offsets of annotations in the class file. This array must not be modified. @param typeAnnotationIndex the index of the type annotation in the array. This index must not be greater than the number of annotations in the array. @return the offset of the type annotation at the given index.\n"}
{"ID": 972, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int readElementValues( final AnnotationVisitor annotationVisitor, final int annotationOffset, final boolean named, final char[] charBuffer) { int currentOffset = annotationOffset; // Read the num_element_value_pairs field (or num_values field for an array_value). int numElementValuePairs = readUnsignedShort(currentOffset); currentOffset += 2; if (named) { // Parse the element_value_pairs array. while (numElementValuePairs-- > 0) { String elementName = readUTF8(currentOffset, charBuffer); currentOffset = readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer); } } else { // Parse the array_value array. while (numElementValuePairs-- > 0) { currentOffset = readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer); } } if (annotationVisitor != null) { annotationVisitor.visitEnd(); } return currentOffset; } \nResponse:", "ground_truth": "Reads the element values of a JVMS 'annotation' structure and makes the given visitor visit\nthem. This method can also be used to read the values of the JVMS 'array_value' field of an\nannotation's 'element_value'.\n\n@param annotationVisitor the visitor that must visit the values.\n@param annotationOffset the start offset of an 'annotation' structure (excluding its type_index\nfield) or of an 'array_value' structure.\n@param named if the annotation values are named or not. This should be true to parse the values\nof a JVMS 'annotation' structure, and false to parse the JVMS 'array_value' of an\nannotation's element_value.\n@param charBuffer the buffer used to read strings in the constant pool.\n@return the end offset of the JVMS 'annotation' or 'array_value' structure.", "predict": " Reads a generic info, and returns the updated currentOffset."}
{"ID": 973, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int readVerificationTypeInfo( final int verificationTypeInfoOffset, final Object[] frame, final int index, final char[] charBuffer, final Label[] labels) { int currentOffset = verificationTypeInfoOffset; int tag = b[currentOffset++] & 0xFF; switch (tag) { case Frame.ITEM_TOP: frame[index] = Opcodes.TOP; break; case Frame.ITEM_INTEGER: frame[index] = Opcodes.INTEGER; break; case Frame.ITEM_FLOAT: frame[index] = Opcodes.FLOAT; break; case Frame.ITEM_DOUBLE: frame[index] = Opcodes.DOUBLE; break; case Frame.ITEM_LONG: frame[index] = Opcodes.LONG; break; case Frame.ITEM_NULL: frame[index] = Opcodes.NULL; break; case Frame.ITEM_UNINITIALIZED_THIS: frame[index] = Opcodes.UNINITIALIZED_THIS; break; case Frame.ITEM_OBJECT: frame[index] = readClass(currentOffset, charBuffer); currentOffset += 2; break; case Frame.ITEM_UNINITIALIZED: frame[index] = createLabel(readUnsignedShort(currentOffset), labels); currentOffset += 2; break; default: throw new IllegalArgumentException(); } return currentOffset; } \nResponse:", "ground_truth": "Reads a JVMS 'verification_type_info' structure and stores it at the given index in the given\narray.\n\n@param verificationTypeInfoOffset the start offset of the 'verification_type_info' structure to\nread.\n@param frame the array where the parsed type must be stored.\n@param index the index in 'frame' where the parsed type must be stored.\n@param charBuffer the buffer used to read strings in the constant pool.\n@param labels the labels of the method currently being parsed, indexed by their offset. If the\nparsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is\nstored in this array if it does not already exist.\n@return the end offset of the JVMS 'verification_type_info' structure.", "predict": " Reads a verification_type_info JVMS structure from the given offset. Can deal with variable-length structures for simplicity. Most of the time, the structure has already been read during the visit of the method's code, so this method simply reads the two sizes, the index and the tag of the structure. @param verificationTypeInfoOffset the start offset of the structure in the bytecode. @param frame the array in which the parsed structure must be stored. @param index the index of the value to be read. @param charBuffer the char buffer used to read strings (ignored here). @param labels the labels of the method's code, or <tt>null</tt> if the labels are already created. @return the offset of the first byte following the parsed structure."}
{"ID": 974, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int[] readBootstrapMethodsAttribute(final int maxStringLength) { char[] charBuffer = new char[maxStringLength]; int currentAttributeOffset = getFirstAttributeOffset(); int[] currentBootstrapMethodOffsets = null; for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) { // Read the attribute_info's attribute_name and attribute_length fields. String attributeName = readUTF8(currentAttributeOffset, charBuffer); int attributeLength = readInt(currentAttributeOffset + 2); currentAttributeOffset += 6; if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) { // Read the num_bootstrap_methods field and create an array of this size. currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)]; // Compute and store the offset of each 'bootstrap_methods' array field entry. int currentBootstrapMethodOffset = currentAttributeOffset + 2; for (int j = 0; j < currentBootstrapMethodOffsets.length; ++j) { currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset; // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each), // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2). currentBootstrapMethodOffset += 4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2; } return currentBootstrapMethodOffsets; } currentAttributeOffset += attributeLength; } return null; } \nResponse:", "ground_truth": "Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.\n\n@param maxStringLength a conservative estimate of the maximum length of the strings contained\nin the constant pool of the class.\n@return the offsets of the bootstrap methods or null.", "predict": " Reads the BootstrapMethods attribute and puts the contents in a List of BootstrapMethodInfo objects. @param maxStringLength The greatest length of any string in the class, assuming <tt>constant_value_index</tt> is valid. @return The BootstrapMethods attribute (<i>not yet opened</i>).\n*/"}
{"ID": 975, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected CtorDescriptor[] inspectConstructors() { Class type = classDescriptor.getType(); Constructor[] ctors = type.getDeclaredConstructors(); CtorDescriptor[] allCtors = new CtorDescriptor[ctors.length]; for (int i = 0; i < ctors.length; i++) { Constructor ctor = ctors[i]; CtorDescriptor ctorDescriptor = createCtorDescriptor(ctor); allCtors[i] = ctorDescriptor; if (ctorDescriptor.isDefault()) { defaultCtor = ctorDescriptor; } } return allCtors; } \nResponse:", "ground_truth": "Inspects all declared constructors of a target type.", "predict": " Inspect constructors and determine which are default constructors. Also build the CtorDescriptor objects for each constructor.\n@return Newly allocated array of CtorDescriptor objects.\n*/"}
{"ID": 976, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CtorDescriptor getCtorDescriptor(final Class... args) { ctors: for (CtorDescriptor ctorDescriptor : allCtors) { Class[] arg = ctorDescriptor.getParameters(); if (arg.length != args.length) { continue; } for (int j = 0; j < arg.length; j++) { if (arg[j] != args[j]) { continue ctors; } } return ctorDescriptor; } return null; } \nResponse:", "ground_truth": "Finds constructor description that matches given argument types.", "predict": " Find a ctorDescriptor that matches the given args. @param args the constructor args @return the ctorDescriptor or null if none found"}
{"ID": 977, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Map<String, TransientBeanData> getRequestMap(final HttpServletRequest servletRequest) { return (Map<String, TransientBeanData>) servletRequest.getAttribute(ATTR_NAME); } \nResponse:", "ground_truth": "Returns instance map from http request.", "predict": " Get the transient bean data map from the HTTP servlet request. @param servletRequest the servlet request, not null @return the transient bean data map, not null\n*/"}
{"ID": 978, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Map<String, TransientBeanData> createRequestMap(final HttpServletRequest servletRequest) { Map<String, TransientBeanData> map = new HashMap<>(); servletRequest.setAttribute(ATTR_NAME, map); return map; } \nResponse:", "ground_truth": "Creates instance map and stores it in the request.", "predict": " Create a transient bean data map. @param servletRequest Current HTTP request. @return Map of transient bean data.\n*/"}
{"ID": 979, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected long[] convertArrayToArray(final Object value) { final Class valueComponentType = value.getClass().getComponentType(); final long[] result; if (valueComponentType.isPrimitive()) { result = convertPrimitiveArrayToArray(value, valueComponentType); } else { // convert object array to target array final Object[] array = (Object[]) value; result = new long[array.length]; for (int i = 0; i < array.length; i++) { result[i] = convertType(array[i]); } } return result; } \nResponse:", "ground_truth": "Converts array value to array.", "predict": " Convert primitive array to primitive array. @param value the value @return the long[]\n*/"}
{"ID": 980, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final FilterConfig filterConfig) throws ServletException { // final String decoraManagerClass = filterConfig.getInitParameter(PARAM_DECORA_MANAGER); if (decoraManagerClass != null) { try { final Class decoraManagerType = ClassLoaderUtil.loadClass(decoraManagerClass); decoraManager = (DecoraManager) ClassUtil.newInstance(decoraManagerType); } catch (Exception ex) { log.error(\"Unable to load Decora manager class: \" + decoraManagerClass, ex); throw new ServletException(ex); } } else { decoraManager = createDecoraManager(); } // final String decoraParserClass = filterConfig.getInitParameter(PARAM_DECORA_PARSER); if (decoraParserClass != null) { try { final Class decoraParserType = ClassLoaderUtil.loadClass(decoraParserClass); decoraParser = (DecoraParser) ClassUtil.newInstance(decoraParserType); } catch (Exception ex) { log.error(\"Unable to load Decora parser class: \" + decoraParserClass, ex); throw new ServletException(ex); } } else { decoraParser = createDecoraParser(); } // final String decoraCache = filterConfig.getInitParameter(PARAM_DECORA_CACHE); if (decoraCache != null) { cached = Converter.get().toBoolean(decoraCache, false); } } \nResponse:", "ground_truth": "Initializes Decora filter. Loads manager and parser from init parameters.", "predict": " Initialize DecoraManager and DecoraParser. @param filterConfig Filter configuration. @throws ServletException If an error occurs during initialization."}
{"ID": 981, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile onFile(final Consumer<File> fileConsumer) { if (consumers == null) { consumers = Consumers.of(fileConsumer); } else { consumers.add(fileConsumer); } return this; } \nResponse:", "ground_truth": "Registers file consumer", "predict": " Consume the file found by this matcher. @param fileConsumer Consumer to consume the file found by this matcher. @return Fluent API allowing to add several consumers to the consumers found by this matcher. Never returns {@code null}.\n*/"}
{"ID": 982, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile searchPath(final URI searchPath) { File file; try { file = new File(searchPath); } catch (Exception ex) { throw new FindFileException(\"URI error: \" + searchPath, ex); } addPath(file); return this; } \nResponse:", "ground_truth": "Specifies the search path. Throws an exception if URI is invalid.", "predict": " Adds a path to the search path. @param searchPath The path to add. @return The finder.\n*/"}
{"ID": 983, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile searchPath(final URL searchPath) { File file = FileUtil.toContainerFile(searchPath); if (file == null) { throw new FindFileException(\"URL error: \" + searchPath); } addPath(file); return this; } \nResponse:", "ground_truth": "Specifies the search path. Throws an exception if URL is invalid.", "predict": " Adds a search path to the classpath. @param searchPath the search path @return this FindFile\n*/"}
{"ID": 984, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile include(final String... patterns) { for (String pattern : patterns) { rules.include(pattern); } return this; } \nResponse:", "ground_truth": "Defines include patterns.", "predict": " Includes additional include patterns. Patterns can be absolute paths or relative paths against the directory containing the Groovy script. @param patterns Patterns to include @return Fluent DSL\n*/"}
{"ID": 985, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FindFile exclude(final String... patterns) { for (String pattern : patterns) { rules.exclude(pattern); } return this; } \nResponse:", "ground_truth": "Defines exclude patterns.", "predict": " Exclude patterns. @param patterns Patterns to exclude. @return Fluent API."}
{"ID": 986, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addPath(final File path) { if (!path.exists()) { return; } if (pathList == null) { pathList = new LinkedList<>(); } pathList.add(path); } \nResponse:", "ground_truth": "Adds existing search path to the file list.\nNon existing files are ignored.\nIf path is a folder, it will be scanned for all files.", "predict": " Add a path to the search path. @param path The path to add.\n*/"}
{"ID": 987, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<File> findAll() { List<File> allFiles = new ArrayList<>(); File file; while ((file = nextFile()) != null) { allFiles.add(file); } return allFiles; } \nResponse:", "ground_truth": "Finds all files and returns list of founded files.", "predict": " Find all files in the directory. @return All files in the directory."}
{"ID": 988, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void init() { rules.detectMode(); todoFiles = new LinkedList<>(); todoFolders = new LinkedList<>(); if (pathList == null) { pathList = new LinkedList<>(); return; } if (pathListOriginal == null) { pathListOriginal = (LinkedList<File>) pathList.clone(); } String[] files = new String[pathList.size()]; int index = 0; Iterator<File> iterator = pathList.iterator(); while (iterator.hasNext()) { File file = iterator.next(); if (file.isFile()) { files[index++] = file.getAbsolutePath(); iterator.remove(); } } if (index != 0) { FilesIterator filesIterator = new FilesIterator(files); todoFiles.add(filesIterator); } } \nResponse:", "ground_truth": "Initializes file walking.\nSeparates input files and folders.", "predict": " Init Folders and Todo Files lists."}
{"ID": 989, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Iterator<File> iterator() { return new Iterator<File>() { private File nextFile; @Override public boolean hasNext() { nextFile = nextFile(); return nextFile != null; } @Override public File next() { if (nextFile == null) { throw new NoSuchElementException(); } return nextFile; } @Override public void remove() { throw new UnsupportedOperationException(); } }; } \nResponse:", "ground_truth": "Returns file walking iterator.", "predict": " Returns an iterator over the files in this directory. The iterator does not support removal. @return an iterator over the files in this directory\n*/"}
{"ID": 990, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WiringMode resolveBeanWiringMode(final Class type) { PetiteBean petiteBean = ((Class<?>) type).getAnnotation(PetiteBean.class); return petiteBean != null ? petiteBean.wiring() : WiringMode.DEFAULT; } \nResponse:", "ground_truth": "Resolves bean's auto-wire flag from the annotation. Returns default auto-wire if annotation doesn't exist.", "predict": " Resolves wiring mode for given bean class. @param type Target bean class. @return Wiring mode. Never returns null. Default mode is DEFAULT."}
{"ID": 991, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveBeanName(final Class type, final boolean useLongTypeName) { PetiteBean petiteBean = ((Class<?>)type).getAnnotation(PetiteBean.class); String name = null; if (petiteBean != null) { name = petiteBean.value().trim(); } if ((name == null) || (name.length() == 0)) { if (useLongTypeName) { name = type.getName(); } else { name = StringUtil.uncapitalize(type.getSimpleName()); } } return name; } \nResponse:", "ground_truth": "Resolves bean's name from bean annotation or type name. May be used for resolving bean name\nof base type during registration of bean subclass.", "predict": " Resolves bean name from Petite annotations. @param type @param useLongTypeName @return"}
{"ID": 992, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PrintWriter getWriter() { if (outWriter == null) { if (outStream != null) { throw new IllegalStateException(\"Can't call getWriter() after getOutputStream()\"); } bufferedWriter = new FastCharArrayWriter(); outWriter = new PrintWriter(bufferedWriter) { @Override public void close() { // do not close the print writer after rendering // since it will remove reference to bufferedWriter } }; } return outWriter; } \nResponse:", "ground_truth": "Returns a writer.", "predict": " Get the writer to write output to. This method should be called before rendering starts. Developers should not call this method again after rendering finishes. Developers should call flush() after rendering finishes. Developers should not call close() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after rendering finishes. Developers should not call getOutputStream() after rendering finishes. Developers should not call getWriter() after"}
{"ID": 993, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ServletOutputStream getOutputStream() { if (outStream == null) { if (outWriter != null) { throw new IllegalStateException(\"Can't call getOutputStream() after getWriter()\"); } bufferOutputStream = new FastByteArrayServletOutputStream(); outStream = bufferOutputStream; } return outStream; } \nResponse:", "ground_truth": "Returns a servlet output stream.", "predict": " Get the output stream to write binary data to. This method is called by the framework to obtain an output stream to write binary data to. The ServletOutputStream obtained by calling this method is buffered, so frequent calls to write() will incur overhead. Instead, use getWriter() to write text data. Calling getOutputStream() after getWriter() has been called will result in an IllegalStateException. @return The ServletOutputStream to write binary data to. Never null.\n*/"}
{"ID": 994, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getClassName() { switch (sort) { case VOID: return \"void\"; case BOOLEAN: return \"boolean\"; case CHAR: return \"char\"; case BYTE: return \"byte\"; case SHORT: return \"short\"; case INT: return \"int\"; case FLOAT: return \"float\"; case LONG: return \"long\"; case DOUBLE: return \"double\"; case ARRAY: StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName()); for (int i = getDimensions(); i > 0; --i) { stringBuilder.append(\"[]\"); } return stringBuilder.toString(); case OBJECT: case INTERNAL: return valueBuffer.substring(valueBegin, valueEnd).replace('/', '.'); default: throw new AssertionError(); } } \nResponse:", "ground_truth": "Returns the binary name of the class corresponding to this type. This method must not be used\non method types.\n\n@return the binary name of the class corresponding to this type.", "predict": " Returns the internal name of the class corresponding to this internal name. This method unstuff internal names. For example, it returns \"java/lang/String\" instead of \"java.lang.String\". @return the internal name of the class corresponding to this internal name."}
{"ID": 995, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getConstructorDescriptor(final Constructor<?> constructor) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = constructor.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } return stringBuilder.append(\")V\").toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given constructor.\n\n@param constructor a {@link Constructor} object.\n@return the descriptor of the given constructor.", "predict": " Returns the descriptor of the given constructor. @param constructor the constructor for which to get the descriptor. @return the descriptor of the given constructor."}
{"ID": 996, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); for (Type argumentType : argumentTypes) { argumentType.appendDescriptor(stringBuilder); } stringBuilder.append(')'); returnType.appendDescriptor(stringBuilder); return stringBuilder.toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given argument and return types.\n\n@param returnType the return type of the method.\n@param argumentTypes the argument types of the method.\n@return the descriptor corresponding to the given argument and return types.", "predict": " Generate the method descriptor for the given return type and argument types. @param returnType the return type. Can be {@literal null}. @param argumentTypes the argument types. Can be {@literal null} or empty. @return the method descriptor. Shall not be {@literal null}.\n*/"}
{"ID": 997, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getMethodDescriptor(final Method method) { StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append('('); Class<?>[] parameters = method.getParameterTypes(); for (Class<?> parameter : parameters) { appendDescriptor(parameter, stringBuilder); } stringBuilder.append(')'); appendDescriptor(method.getReturnType(), stringBuilder); return stringBuilder.toString(); } \nResponse:", "ground_truth": "Returns the descriptor corresponding to the given method.\n\n@param method a {@link Method} object.\n@return the descriptor of the given method.", "predict": " Returns the descriptor corresponding to the given Java method. @param method a method. @return the descriptor corresponding to the given Java method."}
{"ID": 998, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void appendDescriptor(final StringBuilder stringBuilder) { if (sort == OBJECT) { stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1); } else if (sort == INTERNAL) { stringBuilder.append('L').append(valueBuffer, valueBegin, valueEnd).append(';'); } else { stringBuilder.append(valueBuffer, valueBegin, valueEnd); } } \nResponse:", "ground_truth": "Appends the descriptor corresponding to this type to the given string buffer.\n\n@param stringBuilder the string builder to which the descriptor must be appended.", "predict": " Append a descriptor, identified by its index. This index does not identify any actual class name. Instead, descriptors are interned and therefore reused, avoiding duplication. Duplicated descriptors are therefore printed once only."}
{"ID": 999, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int getSize() { switch (sort) { case VOID: return 0; case BOOLEAN: case CHAR: case BYTE: case SHORT: case INT: case FLOAT: case ARRAY: case OBJECT: case INTERNAL: return 1; case LONG: case DOUBLE: return 2; default: throw new AssertionError(); } } \nResponse:", "ground_truth": "Returns the size of values of this type. This method must not be used for method types.\n\n@return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for\n{@code void} and 1 otherwise.", "predict": " Returns the size of the operand stack in this frame. The operand stack is measured from its bottom. Negative sizes indicate that this is a bottom frame."}
{"ID": 1000, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int getArgumentsAndReturnSizes(final String methodDescriptor) { int argumentsSize = 1; // Skip the first character, which is always a '('. int currentOffset = 1; int currentChar = methodDescriptor.charAt(currentOffset); // Parse the argument types and compute their size, one at a each loop iteration. while (currentChar != ')') { if (currentChar == 'J' || currentChar == 'D') { currentOffset++; argumentsSize += 2; } else { while (methodDescriptor.charAt(currentOffset) == '[') { currentOffset++; } if (methodDescriptor.charAt(currentOffset++) == 'L') { // Skip the argument descriptor content. currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1; } argumentsSize += 1; } currentChar = methodDescriptor.charAt(currentOffset); } currentChar = methodDescriptor.charAt(currentOffset + 1); if (currentChar == 'V') { return argumentsSize << 2; } else { int returnSize = (currentChar == 'J' || currentChar == 'D') ? 2 : 1; return argumentsSize << 2 | returnSize; } } \nResponse:", "ground_truth": "Computes the size of the arguments and of the return value of a method.\n\n@param methodDescriptor a method descriptor.\n@return the size of the arguments of the method (plus one for the implicit this argument),\nargumentsSize, and the size of its return value, returnSize, packed into a single int i =\n{@code (argumentsSize &lt;&lt; 2) | returnSize} (argumentsSize is therefore equal to {@code\ni &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}).", "predict": " Computes the size of the arguments and the return value of a method described by its method descriptor. @param methodDescriptor a method descriptor. @return the size of the arguments and the return value of the method described by the given method descriptor."}
{"ID": 1001, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setRollbackOnly(final Throwable th) { if (!isNoTransaction()) { if ((status != STATUS_MARKED_ROLLBACK) && (status != STATUS_ACTIVE)) { throw new JtxException(\"TNo active TX that can be marked as rollback only\"); } } rollbackCause = th; status = STATUS_MARKED_ROLLBACK; } \nResponse:", "ground_truth": "Modify the transaction associated with the target object such that the only possible outcome\nof the transaction is to roll back the transaction.", "predict": " Marks TX as rollback only. TX will be rolled back automatically upon commit/rollback. Useful for marking TX that failed to enlist resources in distributed TX coordinator. @param th causal reason why TX was marked as rollback only\n*/"}
{"ID": 1002, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void commitOrRollback(boolean doCommit) { if (log.isDebugEnabled()) { if (doCommit) { log.debug(\"Commit JTX\"); } else { log.debug(\"Rollback JTX\"); } } boolean forcedRollback = false; if (!isNoTransaction()) { if (isRollbackOnly()) { if (doCommit) { doCommit = false; forcedRollback = true; } } else if (!isActive()) { if (isCompleted()) { throw new JtxException(\"TX is already completed, commit or rollback should be called once per TX\"); } throw new JtxException(\"No active TX to \" + (doCommit ? \"commit\" : \"rollback\")); } } if (doCommit) { commitAllResources(); } else { rollbackAllResources(forcedRollback); } } \nResponse:", "ground_truth": "Performs either commit or rollback on all transaction resources.", "predict": " Commits or rolls back depending on the outcome of the TX. Rolls back if TX rolled back, commits if TX committed. Rolls back regardless of outcome if rollbackOnly was set. Rolls back regardless of outcome if TX rolled back and suspended. Rolls back regardless of outcome if TX rolled back and suspended and suspendedTX was set. Rolls back regardless of outcome if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and suspended and suspendedTX was set and suspendedTX was suspended. Throws exception if TX rolled back and"}
{"ID": 1003, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void rollbackAllResources(final boolean wasForced) { status = STATUS_ROLLING_BACK; Exception lastException = null; Iterator<JtxResource> it = resources.iterator(); while (it.hasNext()) { JtxResource resource = it.next(); try { resource.rollbackTransaction(); } catch (Exception ex) { lastException = ex; } finally { it.remove(); } } txManager.removeTransaction(this); status = STATUS_ROLLEDBACK; if (lastException != null) { status = STATUS_UNKNOWN; throw new JtxException(\"Rollback failed: one or more TX resources couldn't rollback a TX\", lastException); } if (wasForced) { throw new JtxException(\"TX rolled back because it has been marked as rollback-only\", rollbackCause); } } \nResponse:", "ground_truth": "Rollbacks all attached resources. Resource will be closed. and detached from this transaction.\nIf exception occurs, it will be rethrown at the end.", "predict": " Rolls back all enlisted resources. Resources enlisted by this TX will be rolled back too. This TX will be rolled back too. Forced rollback overrides enlistment rollback. Enlisted resources will be rolled back too. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced rollback overrides enlistment rollback. Forced roll"}
{"ID": 1004, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E requestResource(final Class<E> resourceType) { if (isCompleted()) { throw new JtxException(\"TX is already completed, resource are not available after commit or rollback\"); } if (isRollbackOnly()) { throw new JtxException(\"TX is marked as rollback only, resource are not available\", rollbackCause); } if (!isNoTransaction() && !isActive()) { throw new JtxException(\"Resources are not available since TX is not active\"); } checkTimeout(); E resource = lookupResource(resourceType); if (resource == null) { int maxResources = txManager.getMaxResourcesPerTransaction(); if ((maxResources != -1) && (resources.size() >= maxResources)) { throw new JtxException(\"TX already has attached max. number of resources\"); } JtxResourceManager<E> resourceManager = txManager.lookupResourceManager(resourceType); resource = resourceManager.beginTransaction(mode, isActive()); resources.add(new JtxResource<>(this, resourceManager, resource)); } return resource; } \nResponse:", "ground_truth": "Requests a resource. If resource is not found, it will be created and new transaction will be started on it.", "predict": " Request a resource of the given type. The resource will be enlisted into TX. @param <E> The type of the resource to request. @return The enlisted resource. Never null. May be completed or rolled back.\n*/"}
{"ID": 1005, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void popName() { if (isPushed) { if (pushedComma) { writeComma(); } String name = pushedName; pushedName = null; isPushed = false; writeName(name); } } \nResponse:", "ground_truth": "Writes stored name to JSON string. Cleans storage.", "predict": " pops a name from the stack without affecting the push status."}
{"ID": 1006, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeString(final String value) { popName(); write(StringPool.QUOTE); int len = value.length(); for (int i = 0; i < len; i++) { char c = value.charAt(i); switch (c) { case '\"': write(\"\\\\\\\"\"); break; case '\\\\': write(\"\\\\\\\\\"); break; case '/': if (strictStringEncoding) { write(\"\\\\/\"); } else { write(c); } break; case '\\b': write(\"\\\\b\"); break; case '\\f': write(\"\\\\f\"); break; case '\\n': write(\"\\\\n\"); break; case '\\r': write(\"\\\\r\"); break; case '\\t': write(\"\\\\t\"); break; default: if (Character.isISOControl(c)) { unicode(c); } else { write(c); } } } write(StringPool.QUOTE); } \nResponse:", "ground_truth": "Write a quoted and escaped value to the output.", "predict": " Writes a quoted string. The quoting is not really significant, but we quote just in case the string contains a quote character within. Quotes are escaped by doubling, i.e. \"\\\". However, \"\\n\" is not escaped because \"\\n\" is a valid newline in JavaScript strings. Therefore \"\\n\" is written as \"\\\\n\". Whitespace characters are quoted too, so \"\\r\\n\" would be written as \"\\\\r\\\\n\". However, \"\\r\" is not quoted because \"\\r\" is a valid line terminator in JavaScript strings. Therefore \"\\r\" is written as \"\\n\". Finally \"\\t\" is quoted because \"\\t\" is a valid tab character in JavaScript strings. Therefore \"\\t\" is written as \"\\\\t\". @param value The string to write.\n"}
{"ID": 1007, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void unicode(final char c) { write(\"\\\\u\"); int n = c; for (int i = 0; i < 4; ++i) { int digit = (n & 0xf000) >> 12; char hex = CharUtil.int2hex(digit); write(hex); n <<= 4; } } \nResponse:", "ground_truth": "Writes unicode representation of a character.", "predict": " Write unicode escape sequence. @param c unicode character\n*/"}
{"ID": 1008, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void write(final CharSequence charSequence) { popName(); try { out.append(charSequence); } catch (IOException ioex) { throw new JsonException(ioex); } } \nResponse:", "ground_truth": "Appends char sequence to the buffer. Used for numbers, nulls, booleans, etc.", "predict": " Writes a CharSequence to the writer. The characters of the CharSequence are converted to bytes according to the encoding of the output stream. The 8859-1 character set is used if the output is a stream and no character encoding is specified. @param charSequence the CharSequence to write to the output. May be null.\n*/"}
{"ID": 1009, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LagartoDomBuilderConfig setParsingErrorLogLevelName(String logLevel) { logLevel = logLevel.trim().toUpperCase(); parsingErrorLogLevel = Logger.Level.valueOf(logLevel); return this; } \nResponse:", "ground_truth": "Sets parsing error log level as a name.", "predict": " Sets the parsing error log level name. The default value is WARN. @param logLevel The log level name. It can be any of DEBUG, INFO, WARN, ERROR, OFF. Case insensitive. @return Self reference."}
{"ID": 1010, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startRegion(final int start, final int tagLen, final int deepLevel) { this.regionStart = start + tagLen; this.regionLength = 0; this.regionTagStart = start; this.deepLevel = deepLevel; } \nResponse:", "ground_truth": "Starts defining region by setting the start index and reset region length to zero.", "predict": " Start of region. @param start Start position of the region. @param tagLen Length of the region tag. @param deepLevel Deep level of nesting."}
{"ID": 1011, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isContaining(final String include) { if (value == null) { return false; } if (splits == null) { splits = StringUtil.splitc(value, ' '); } for (String s: splits) { if (s.equals(include)) { return true; } } return false; } \nResponse:", "ground_truth": "Returns true if attribute is containing some value.", "predict": " Checks if the value contains the include string. The check is case insensitive. @param include The include string to check for. @return True if the value contains the include string. False otherwise."}
{"ID": 1012, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerPseudoFunction(final Class<? extends PseudoFunction> pseudoFunctionType) { PseudoFunction pseudoFunction; try { pseudoFunction = ClassUtil.newInstance(pseudoFunctionType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_FUNCTION_MAP.put(pseudoFunction.getPseudoFunctionName(), pseudoFunction); } \nResponse:", "ground_truth": "Registers pseudo function.", "predict": " Register a pseudo function. Pseudo functions are used to extend the functionality of the css parser. Pseudo functions are identified by their name. @param pseudoFunctionType PseudoFunction class. Pseudo functions are identified by their name.\n*/"}
{"ID": 1013, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static PseudoFunction<?> lookupPseudoFunction(final String pseudoFunctionName) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP.get(pseudoFunctionName); if (pseudoFunction == null) { throw new CSSellyException(\"Unsupported pseudo function: \" + pseudoFunctionName); } return pseudoFunction; } \nResponse:", "ground_truth": "Lookups pseudo function for given pseudo function name.", "predict": " Lookup pseudo function by name. @param pseudoFunctionName pseudo function name @return pseudo function\n"}
{"ID": 1014, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visit(final int version, int access, final String name, final String signature, final String superName, final String[] interfaces) { wd.init(name, superName, this.suffix, this.reqProxyClassName); // change access of destination access &= ~AsmUtil.ACC_ABSTRACT; // write destination class final int v = ProxettaAsmUtil.resolveJavaVersion(version); wd.dest.visit(v, access, wd.thisReference, signature, wd.superName, null); wd.proxyAspects = new ProxyAspectData[aspects.length]; for (int i = 0; i < aspects.length; i++) { wd.proxyAspects[i] = new ProxyAspectData(wd, aspects[i], i); } } \nResponse:", "ground_truth": "Creates destination subclass header from current target class. Destination name is created from targets by\nadding a suffix and, optionally, a number. Destination extends the target.", "predict": " Visit advice method. Advice method is called before advice code. Advice method receives advice class name, advice method name, advice method signature, advice class super class name, advice class interfaces, advice method modifiers, advice method exceptions, advice method arguments, advice method annotations, advice method code, advice method local variables, advice method stack size, advice method max stack size, advice method max locals, advice method max operands, advice method max branches, advice method max returns, advice method max traps, advice method max exceptions, advice method max monitors, advice method max wide, advice method max multiline, advice method max locals, advice method max args, advice method max overhead, advice method overhead ratio, advice method args, advice method catches, advice method throws, advice method catches, advice method throws, advice method lines, advice method branches, advice method returns, advice method traps, advice method exceptions, advice method monitors, advice method wide, advice method multiline, advice method args, advice method overhead ratio, advice method catches, advice method throws, advice method catches,"}
{"ID": 1015, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor destAnn = wd.dest.visitAnnotation(desc, visible); // [A3] return new AnnotationVisitorAdapter(destAnn); } \nResponse:", "ground_truth": "Copies all destination type annotations to the target.", "predict": " Visit a normal annotation. @param desc the class descriptor of the annotation class. @param visible indicate if the annotation is visible at runtime. @return an AnnotationWriter that will write the annotation to the given AnnotationVisitor."}
{"ID": 1016, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void makeStaticInitBlock() { if (wd.adviceClinits != null) { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_STATIC, CLINIT, DESC_VOID, null, null); mv.visitCode(); for (String name : wd.adviceClinits) { mv.visitMethodInsn( INVOKESTATIC, wd.thisReference, name, DESC_VOID, false); } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } } \nResponse:", "ground_truth": "Creates static initialization block that simply calls all\nadvice static init methods in correct order.", "predict": " Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks. Advice to weave clinit blocks"}
{"ID": 1017, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void makeProxyConstructor() { MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PRIVATE | AsmUtil.ACC_FINAL, ProxettaNames.initMethodName, DESC_VOID, null, null); mv.visitCode(); if (wd.adviceInits != null) { for (String name : wd.adviceInits) { mv.visitVarInsn(ALOAD, 0); mv.visitMethodInsn (INVOKESPECIAL, wd.thisReference, name, DESC_VOID, false); } } mv.visitInsn(RETURN); mv.visitMaxs(0, 0); mv.visitEnd(); } \nResponse:", "ground_truth": "Creates init method that simply calls all advice constructor methods in correct order.\nThis created init method is called from each destination's constructor.", "predict": " Making proxy constructor. Making constructor accepting advices initiliazers. Advices initiliazers are stored in advicesInits field. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice initiliazers are advices with advice bodies. Advice init"}
{"ID": 1018, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void processSuperMethods() { for (ClassReader cr : targetClassInfo.superClassReaders) { cr.accept(new EmptyClassVisitor() { String declaredClassName; @Override public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) { declaredClassName = name; } @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { if (name.equals(INIT) || name.equals(CLINIT)) { return null; } MethodSignatureVisitor msign = targetClassInfo.lookupMethodSignatureVisitor(access, name, desc, declaredClassName); if (msign == null) { return null; } return applyProxy(msign); } }, 0); } } \nResponse:", "ground_truth": "Checks for all public super methods that are not overridden.", "predict": " Process super methods."}
{"ID": 1019, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int findLast(int low, int high) { int ndx = -1; while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(mid); if (delta > 0) { high = mid - 1; } else { if (delta == 0) { ndx = mid; } low = mid + 1; } } if (ndx == -1) { return -(low + 1); } return ndx; } \nResponse:", "ground_truth": "Finds very last index of given element in inclusive index range. Returns negative\nvalue if element is not found.", "predict": " Binary search for the given key. The array must be sorted ascending. The lower bound is inclusive, while the upper bound is exclusive. Returns the index of the given key, or -(insertion point) - 1, where insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or the length of the array, if all elements in the array are less than the specified key. The array must be sorted ascending. Returns -1 if the given key is not found.\n"}
{"ID": 1020, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String on(final String string) { if (!enabled) { return string; } final StringBuilder sb = new StringBuilder(); if (prefix != null) { sb.append(prefix).append(\"m\"); } sb.append(string); if (suffix != null) { sb.append(suffix).append(\"m\"); } return sb.toString(); } \nResponse:", "ground_truth": "Returns chalked string.", "predict": " Converts the given string into a CamelCase string by adding camel casing to each word separated by a space. Words are delimited by letters or digits. Words starting with numbers are treated literally (\"one\", \"two\", \"three\"...) and lowered (\"one\", \"two\",...). Camel casing is applied to all letters except for underscores (_). Camel casing is applied to words delimited by spaces. The first character of each word is capitalized. Words are delimited by letters or digits. Words starting with numbers are treated literally (\"one\", \"two\", \"three\"...) and lowered (\"one\", \"two\",...). Camel casing is applied to all letters except for underscores (_). Camel casing is applied to words delimited by spaces. The first character of each word is capitalized. Words are delimited by letters or digits. Words starting with numbers are treated literally (\"one\", \"two\", \"three\"...) and lowered (\"one\", \"two\",...). Camel casing is applied to all letters except for underscores (_). @param string The string"}
{"ID": 1021, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private byte[] replaceAsmInstructions(final byte[] classFile, final boolean hasFrames) { final Attribute[] attributes = getAttributePrototypes(); firstField = null; lastField = null; firstMethod = null; lastMethod = null; lastRuntimeVisibleAnnotation = null; lastRuntimeInvisibleAnnotation = null; lastRuntimeVisibleTypeAnnotation = null; lastRuntimeInvisibleTypeAnnotation = null; moduleWriter = null; nestHostClassIndex = 0; numberOfNestMemberClasses = 0; nestMemberClasses = null; firstAttribute = null; compute = hasFrames ? MethodWriter.COMPUTE_INSERTED_FRAMES : MethodWriter.COMPUTE_NOTHING; new ClassReader(classFile, 0, /* checkClassVersion = */ false) .accept( this, attributes, (hasFrames ? ClassReader.EXPAND_FRAMES : 0) | ClassReader.EXPAND_ASM_INSNS); return toByteArray(); } \nResponse:", "ground_truth": "Returns the equivalent of the given class file, with the ASM specific instructions replaced\nwith standard ones. This is done with a ClassReader -&gt; ClassWriter round trip.\n\n@param classFile a class file containing ASM specific instructions, generated by this\nClassWriter.\n@param hasFrames whether there is at least one stack map frames in 'classFile'.\n@return an equivalent of 'classFile', with the ASM specific instructions replaced with standard\nones.", "predict": " Replaces ASM specific instructions of the visited class. @param classFile the class to transform. @param hasFrames indication of whether frames are used or not.\n*/"}
{"ID": 1022, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Attribute[] getAttributePrototypes() { Attribute.Set attributePrototypes = new Attribute.Set(); attributePrototypes.addAttributes(firstAttribute); FieldWriter fieldWriter = firstField; while (fieldWriter != null) { fieldWriter.collectAttributePrototypes(attributePrototypes); fieldWriter = (FieldWriter) fieldWriter.fv; } MethodWriter methodWriter = firstMethod; while (methodWriter != null) { methodWriter.collectAttributePrototypes(attributePrototypes); methodWriter = (MethodWriter) methodWriter.mv; } return attributePrototypes.toArray(); } \nResponse:", "ground_truth": "Returns the prototypes of the attributes used by this class, its fields and its methods.\n\n@return the prototypes of the attributes used by this class, its fields and its methods.", "predict": " Collect and sort prototypes of all attributes. They are needed for efficient access of attributes in Switch instructions. Since producing all prototypes is costly, this method produces prototypes only for those attributes that are accessed frequently. In practice, this means skipping primitives, strings and symbols. Other symbols are needed to access class members, so they are produced nevertheless. Since primitives and strings are skipped, efficiency gain is especially noticeable for classes with few attributes (~10)."}
{"ID": 1023, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerDefaults() { register(Integer.class, IntegerSqlType.class); register(int.class, IntegerSqlType.class); register(MutableInteger.class, IntegerSqlType.class); register(Float.class, FloatSqlType.class); register(float.class, FloatSqlType.class); register(MutableFloat.class, FloatSqlType.class); register(Double.class, DoubleSqlType.class); register(double.class, DoubleSqlType.class); register(MutableDouble.class, DoubleSqlType.class); register(Byte.class, ByteSqlType.class); register(byte.class, ByteSqlType.class); register(MutableByte.class, ByteSqlType.class); register(Boolean.class, BooleanSqlType.class); register(boolean.class, BooleanSqlType.class); register(MutableBoolean.class, BooleanSqlType.class); register(Long.class, LongSqlType.class); register(long.class, LongSqlType.class); register(MutableLong.class, LongSqlType.class); register(Short.class, ShortSqlType.class); register(short.class, ShortSqlType.class); register(MutableShort.class, ShortSqlType.class); register(Character.class, CharacterSqlType.class); register(char.class, CharacterSqlType.class); register(BigDecimal.class, BigDecimalSqlType.class); register(BigInteger.class, BigIntegerSqlType.class); register(String.class, StringSqlType.class); register(LocalDateTime.class, LocalDateTimeSqlType.class); register(LocalDate.class, LocalDateSqlType.class); register(LocalTime.class, LocalTimeSqlType.class); register(Date.class, SqlDateSqlType.class); register(Timestamp.class, TimestampSqlType.class); register(Time.class, TimeSqlType.class); register(java.util.Date.class, DateSqlType.class); register(JulianDate.class, JulianDateSqlType.class); register(byte[].class, ByteArraySqlType.class); register(URL.class, URLSqlType.class); register(Blob.class, BlobSqlType.class); register(Clob.class, ClobSqlType.class); register(Array.class, SqlArraySqlType.class); register(Ref.class, SqlRefSqlType.class); } \nResponse:", "ground_truth": "Registers default set of SQL types.", "predict": " Register the standard SQL types."}
{"ID": 1024, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void register(final Class type, final Class<? extends SqlType> sqlTypeClass) { types.put(type, lookupSqlType(sqlTypeClass)); } \nResponse:", "ground_truth": "Registers sql type for provided type.", "predict": " Register a type converter for a particular type. Useful for ensuring that the type converter is only ever dealing with a certain type. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt with gracefully. Useful for ensuring that incompatible legacy code is dealt"}
{"ID": 1025, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SqlType lookup(final Class clazz) { SqlType sqlType; for (Class x = clazz; x != null; x = x.getSuperclass()) { sqlType = types.get(clazz); if (sqlType != null) { return sqlType; } Class[] interfaces = x.getInterfaces(); for (Class i : interfaces) { sqlType = types.get(i); if (sqlType != null) { return sqlType; } } } return null; } \nResponse:", "ground_truth": "Retrieves SQL type for provided type. All subclasses and interfaces are examined\nfor matching sql type.", "predict": " Looks up the SQL type for a given Java class. @param clazz Java class whose SQL type is sought. @return SQL type for the given Java class, or null if none found."}
{"ID": 1026, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SqlType lookupSqlType(final Class<? extends SqlType> sqlTypeClass) { SqlType sqlType = sqlTypes.get(sqlTypeClass); if (sqlType == null) { try { sqlType = ClassUtil.newInstance(sqlTypeClass); } catch (Exception ex) { throw new DbSqlException(\"SQL type not found: \" + sqlTypeClass.getSimpleName(), ex); } sqlTypes.put(sqlTypeClass, sqlType); } return sqlType; } \nResponse:", "ground_truth": "Returns sql type instance. Instances are stored for better performances.", "predict": " Looks up a sql type by its class. @param sqlTypeClass the sql type class to look up @return the sql type\n*/"}
{"ID": 1027, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo socks4Proxy(final String proxyAddress, final int proxyPort, final String proxyUser) { return new ProxyInfo(ProxyType.SOCKS4, proxyAddress, proxyPort, proxyUser, null); } \nResponse:", "ground_truth": "Creates SOCKS4 proxy.", "predict": " Establish a SOCKS4 proxy connection. @param proxyAddress Address of the proxy server. @param proxyPort Port of the proxy server. @param proxyUser Username for authenticating at the proxy server. @return ProxyInfo for a SOCKS4 proxy connection.\n**/"}
{"ID": 1028, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo socks5Proxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.SOCKS5, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResponse:", "ground_truth": "Creates SOCKS5 proxy.", "predict": " Creates a ProxyInfo instance for SOCKS5 proxy. @param proxyAddress Address of the proxy. @param proxyPort Port of the proxy. @param proxyUser Username for authentication. @param proxyPassword Password for authentication. @return ProxyInfo instance for SOCKS5 proxy."}
{"ID": 1029, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProxyInfo httpProxy(final String proxyAddress, final int proxyPort, final String proxyUser, final String proxyPassword) { return new ProxyInfo(ProxyType.HTTP, proxyAddress, proxyPort, proxyUser, proxyPassword); } \nResponse:", "ground_truth": "Creates HTTP proxy.", "predict": " Establish an HTTP proxy tunnel securely using HTTPS. Supply the proxy address, port, username and password. Supply HTTPS as the tunnel endpoint. @param proxyAddress The proxy address. @param proxyPort The proxy port. @param proxyUser The proxy username. @param proxyPassword The proxy password. @return ProxyInfo The tunneling information. Never null."}
{"ID": 1030, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int totalThreadTransactions() { ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { return 0; } return txList.size(); } \nResponse:", "ground_truth": "Returns total number of transactions associated with current thread.", "predict": " Total Transactions currently active in the thread. Including suspended ones. Including suspended ones that are suspended due to nesting. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions. Including suspended ones that are suspended due to nesting due to other suspended transactions"}
{"ID": 1031, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int totalThreadTransactionsWithStatus(final JtxStatus status) { ArrayList<JtxTransaction> txlist = txStack.get(); if (txlist == null) { return 0; } int count = 0; for (JtxTransaction tx : txlist) { if (tx.getStatus() == status) { count++; } } return count; } \nResponse:", "ground_truth": "Returns total number of transactions of the specified status associated with current thread.", "predict": " Count total number of transactions with given status. Useful for monitoring purposes. @param status transaction status @return number of transactions with given status\n*/"}
{"ID": 1032, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void associateTransaction(final JtxTransaction tx) { totalTransactions++; ArrayList<JtxTransaction> txList = txStack.get(); if (txList == null) { txList = new ArrayList<>(); txStack.set(txList); } txList.add(tx); // add last } \nResponse:", "ground_truth": "Associate transaction to current thread.", "predict": " Associate the given TX with the current TX. Useful for propagating TX enlistment decisions. @param tx Transaction to enlist. Shall be enlisted BEFORE acquiring locks. Shall NOT be enlisted AFTER acquiring locks. Shall NOT be enlisted AFTER releasing locks. Shall NOT be enlisted BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER acquiring locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER acquiring locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER acquiring locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER acquiring locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE releasing locks. Shall enlist AFTER releasing locks. Shall enlist BEFORE acquiring locks. Shall enlist AFTER releasing"}
{"ID": 1033, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void continueTx(final JtxTransaction sourceTx, final JtxTransactionMode destMode) { if (!validateExistingTransaction) { return; } JtxTransactionMode sourceMode = sourceTx.getTransactionMode(); JtxIsolationLevel destIsolationLevel = destMode.getIsolationLevel(); if (destIsolationLevel != ISOLATION_DEFAULT) { JtxIsolationLevel currentIsolationLevel = sourceMode.getIsolationLevel(); if (currentIsolationLevel != destIsolationLevel) { throw new JtxException(\"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel); } } if ((!destMode.isReadOnly()) && (sourceMode.isReadOnly())) { throw new JtxException(\"Participating TX is not marked as read-only, but existing TX is\"); } } \nResponse:", "ground_truth": "Check if propagation of a transaction is possible, due to source and destination transaction modes.\n@see #setValidateExistingTransaction(boolean)", "predict": " Validate compatibility of participating TX isolation level and existing TX isolation level. Raise exception if incompatible. @param sourceTx participating TX @param destMode TX mode to be joined\n*/"}
{"ID": 1034, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <E> JtxResourceManager<E> lookupResourceManager(final Class<E> resourceType) { //noinspection unchecked JtxResourceManager<E> resourceManager = this.resourceManagers.get(resourceType); if (resourceManager == null) { throw new JtxException(\"No registered resource manager for resource type: \" + resourceType.getSimpleName()); } return resourceManager; } \nResponse:", "ground_truth": "Lookups resource manager for provided type. Throws an exception if provider doesn't exists.", "predict": " Looks up resource manager for given resource type. Throws exception if none found. @param resourceType resource type to lookup @return resource manager for given resource type\n*/"}
{"ID": 1035, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected C createProxyObject(Class<C> target) { target = ProxettaUtil.resolveTargetClass(target); Class proxyClass = cache.get(target); if (proxyClass == null) { proxyClass = proxetta.defineProxy(target); cache.put(target, proxyClass); } C proxy; try { proxy = (C) ClassUtil.newInstance(proxyClass); } catch (Exception ex) { throw new PathrefException(ex); } return proxy; } \nResponse:", "ground_truth": "Creates proxy object.", "predict": " Create a proxy object for the given target class. The proxy class is cached. @param target Target class. @return Proxy object."}
{"ID": 1036, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void append(final String methodName) { if (path.length() != 0) { path += StringPool.DOT; } if (methodName.startsWith(StringPool.LEFT_SQ_BRACKET)) { path = StringUtil.substring(path, 0, -1); } path += methodName; } \nResponse:", "ground_truth": "Appends method name to existing path.", "predict": " Appends the given method name to the current path. @param methodName The method name to append. Shall not be <code>null</code>. Shall not be empty. Shall not start with a dot. Shall not contain dots. Shall not contain slashes. Shall not contain backslashes. Shall not contain question marks. Shall not contain plus signs. Shall not contain parentheses. Shall not contain braces. Shall not contain angle brackets. Shall not contain ampersands. Shall not contain carets. Shall not contain dollar signs. Shall not contain dollar braces. Shall not contain dollar brackets. Shall not contain dollar curly braces. Shall not contain dollar sharp brackets. Shall not contain dollar question marks. Shall not contain dollar exclamation marks. Shall not contain dollar at (@). Shall not contain dollar colon. Shall not contain dollar semicolon. Shall not contain dollar pipe. Shall not contain dollar vertical bar. Shall not contain dollar vertical bar stacked. Shall not contain dollar pipe stacked. Shall not contain dollar question mark stacked. Shall not contain dollar exclamation mark stacked. Shall"}
{"ID": 1037, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String alignLeftAndPad(final String text, final int size) { int textLength = text.length(); if (textLength > size) { return text.substring(0, size); } final StringBuilder sb = new StringBuilder(size); sb.append(text); while (textLength++ < size) { sb.append(' '); } return sb.toString(); } \nResponse:", "ground_truth": "Puts the text to the left and pads with spaces until the size is reached.", "predict": " Pad a string to a fixed length ensuring it is left aligned. Pad with spaces rather than zero character. @param text The string to pad. @param size The length to pad to. @return The padded string."}
{"ID": 1038, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toPrettyString(final Object value) { if (value == null) { return StringPool.NULL; } final Class<?> type = value.getClass(); if (type.isArray()) { final Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { final StringBuilder sb = new StringBuilder(); sb.append('['); if (componentType == int.class) { sb.append(ArraysUtil.toString((int[]) value)); } else if (componentType == long.class) { sb.append(ArraysUtil.toString((long[]) value)); } else if (componentType == double.class) { sb.append(ArraysUtil.toString((double[]) value)); } else if (componentType == float.class) { sb.append(ArraysUtil.toString((float[]) value)); } else if (componentType == boolean.class) { sb.append(ArraysUtil.toString((boolean[]) value)); } else if (componentType == short.class) { sb.append(ArraysUtil.toString((short[]) value)); } else if (componentType == byte.class) { sb.append(ArraysUtil.toString((byte[]) value)); } else { throw new IllegalArgumentException(); } sb.append(']'); return sb.toString(); } else { final StringBuilder sb = new StringBuilder(); sb.append('['); final Object[] array = (Object[]) value; for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(array[i])); } sb.append(']'); return sb.toString(); } } else if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final StringBuilder sb = new StringBuilder(); sb.append('{'); int i = 0; for (final Object o : iterable) { if (i > 0) { sb.append(','); } sb.append(toPrettyString(o)); i++; } sb.append('}'); return sb.toString(); } return value.toString(); } \nResponse:", "ground_truth": "Converts object into pretty string. All arrays are iterated.", "predict": " Pretty print the given value. Primitive arrays are printed as '[...]'. Complex arrays are printed as '[...]'. Collections are printed as '[...]'. Maps are printed as '{...}'. Beans are printed as '{...}'. Others are printed as '[...]'. @param value The value to pretty print. @return The pretty printed value."}
{"ID": 1039, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toCamelCase(final String input, final boolean firstCharUppercase, final char separator) { final int length = input.length(); final StringBuilder sb = new StringBuilder(length); boolean upperCase = firstCharUppercase; for (int i = 0; i < length; i++) { final char ch = input.charAt(i); if (ch == separator) { upperCase = true; } else if (upperCase) { sb.append(Character.toUpperCase(ch)); upperCase = false; } else { sb.append(ch); } } return sb.toString(); } \nResponse:", "ground_truth": "Converts separated string value to CamelCase.", "predict": " CamelCase a string. Similar to snake case but also capitalizes the first letter. Useful for generating human readable strings. @param input The string to camelCase. @param firstCharUppercase Whether or not the first character should be uppercased. @param separator The separator character. @return Camel cased string."}
{"ID": 1040, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String formatParagraph(final String src, final int len, final boolean breakOnWhitespace) { StringBuilder str = new StringBuilder(); int total = src.length(); int from = 0; while (from < total) { int to = from + len; if (to >= total) { to = total; } else if (breakOnWhitespace) { int ndx = StringUtil.lastIndexOfWhitespace(src, to - 1, from); if (ndx != -1) { to = ndx + 1; } } int cutFrom = StringUtil.indexOfNonWhitespace(src, from, to); if (cutFrom != -1) { int cutTo = StringUtil.lastIndexOfNonWhitespace(src, to - 1, from) + 1; str.append(src, cutFrom, cutTo); } str.append('\\n'); from = to; } return str.toString(); } \nResponse:", "ground_truth": "Formats provided string as paragraph.", "predict": " Reformats paragraph text to fit within the given width. Breaks lines anywhere there is whitespace, unless breakOnWhitespace is false. Whitespace is defined as SPACE, TAB, CR, LF. Lines are terminated by CR LF pair.\n@param src paragraph text\n@param len width in characters\n@param breakOnWhitespace break lines anywhere there is whitespace, unless false\n@return reformatted paragraph text\n*/"}
{"ID": 1041, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String convertTabsToSpaces(final String line, final int tabWidth) { int tab_index, tab_size; int last_tab_index = 0; int added_chars = 0; if (tabWidth == 0) { return StringUtil.remove(line, '\\t'); } StringBuilder result = new StringBuilder(); while ((tab_index = line.indexOf('\\t', last_tab_index)) != -1) { tab_size = tabWidth - ((tab_index + added_chars) % tabWidth); if (tab_size == 0) { tab_size = tabWidth; } added_chars += tab_size - 1; result.append(line, last_tab_index, tab_index); result.append(StringUtil.repeat(' ', tab_size)); last_tab_index = tab_index+1; } if (last_tab_index == 0) { return line; } result.append(line.substring(last_tab_index)); return result.toString(); } \nResponse:", "ground_truth": "Converts all tabs on a line to spaces according to the provided tab width.\nThis is not a simple tab to spaces replacement, since the resulting\nindentation remains the same.", "predict": " Replace tabs with spaces in the given line. Tab width is assumed to be 8.\n@param line The line to convert. @param tabWidth The assumed tab width. @return The line with tabs converted to spaces.\n*/"}
{"ID": 1042, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String escapeJava(final String string) { int strLen = string.length(); StringBuilder sb = new StringBuilder(strLen); for (int i = 0; i < strLen; i++) { char c = string.charAt(i); switch (c) { case '\\b' : sb.append(\"\\\\b\"); break; case '\\t' : sb.append(\"\\\\t\"); break; case '\\n' : sb.append(\"\\\\n\"); break; case '\\f' : sb.append(\"\\\\f\"); break; case '\\r' : sb.append(\"\\\\r\"); break; case '\\\"' : sb.append(\"\\\\\\\"\"); break; case '\\\\' : sb.append(\"\\\\\\\\\"); break; default: if ((c < 32) || (c > 127)) { String hex = Integer.toHexString(c); sb.append(\"\\\\u\"); for (int k = hex.length(); k < 4; k++) { sb.append('0'); } sb.append(hex); } else { sb.append(c); } } } return sb.toString(); } \nResponse:", "ground_truth": "Escapes a string using java rules.", "predict": " Escape special characters in a string so that it can be embedded in JavaScript code. @param string The string to escape. @return The escaped string.\n*/"}
{"ID": 1043, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String unescapeJava(final String str) { char[] chars = str.toCharArray(); StringBuilder sb = new StringBuilder(str.length()); for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (c != '\\\\') { sb.append(c); continue; } i++; c = chars[i]; switch (c) { case 'b': sb.append('\\b'); break; case 't': sb.append('\\t'); break; case 'n': sb.append('\\n'); break; case 'f': sb.append('\\f'); break; case 'r': sb.append('\\r'); break; case '\"': sb.append('\\\"'); break; case '\\\\': sb.append('\\\\'); break; case 'u' : char hex = (char) Integer.parseInt(new String(chars, i + 1, 4), 16); sb.append(hex); i += 4; break; default: throw new IllegalArgumentException(\"Invalid escaping character: \" + c); } } return sb.toString(); } \nResponse:", "ground_truth": "Unescapes a string using java rules.", "predict": " Unescapes the escaped control characters and octal escape sequences plus Unicode escapes. Octal escape sequences are not supported. @param str The string to unescape. @return The unescaped string.\n*/"}
{"ID": 1044, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public <T> T getBean(final Class<T> type) { String name = resolveBeanName(type); return (T) getBean(name); } \nResponse:", "ground_truth": "Returns Petite bean instance. Bean name will be resolved from provided type.", "predict": " Retrieve a Spring managed bean by its type. @param type Spring bean type. @param <T> Spring bean type. @return Spring bean instance.\n*/"}
{"ID": 1045, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T getBean(final String name) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition(name); if (def == null) { // try provider ProviderDefinition providerDefinition = providers.get(name); if (providerDefinition != null) { return (T) invokeProvider(providerDefinition); } return null; } // Find the bean in its scope Object bean = def.scopeLookup(); if (bean == null) { // Create new bean in the scope initBeanDefinition(def); final BeanData beanData = new BeanData(this, def); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(beanData); bean = beanData.bean(); } return (T) bean; } \nResponse:", "ground_truth": "Returns Petite bean instance.\nPetite container will find the bean in corresponding scope and all its dependencies,\neither by constructor or property injection. When using constructor injection, cyclic dependencies\ncan not be prevented, but at least they are detected.\n\n@see PetiteContainer#createBean(Class)", "predict": " Get a bean from the registry. @param name Name of the bean to lookup. @return Bean instance or null if not found."}
{"ID": 1046, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initBeanDefinition(final BeanDefinition def) { // init methods if (def.initMethods == null) { def.initMethods = petiteResolvers.resolveInitMethodPoint(def.type); } // destroy methods if (def.destroyMethods == null) { def.destroyMethods = petiteResolvers.resolveDestroyMethodPoint(def.type); } // properties if (def.properties == null) { def.properties = petiteResolvers.resolvePropertyInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // methods if (def.methods == null) { def.methods = petiteResolvers.resolveMethodInjectionPoint(def.type); } // ctors if (def.ctor == null) { def.ctor = petiteResolvers.resolveCtorInjectionPoint(def.type); } // values if (def.values == null) { def.values = paramManager.resolveParamInjectionPoints(def.type); } // sets if (def.sets == null) { def.sets = petiteResolvers.resolveSetInjectionPoint(def.type, def.wiringMode == WiringMode.AUTOWIRE); } // params if (def.params == null) { def.params = paramManager.filterParametersForBeanName(def.name, petiteConfig.getResolveReferenceParameters()); } } \nResponse:", "ground_truth": "Resolves and initializes bean definition. May be called multiple times.", "predict": " Init bean definition. @param def Petite bean definition to initialize."}
{"ID": 1047, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeProvider(final ProviderDefinition provider) { if (provider.method != null) { final Object bean; if (provider.beanName != null) { // instance factory method bean = getBean(provider.beanName); } else { // static factory method bean = null; } try { return provider.method.invoke(bean); } catch (Exception ex) { throw new PetiteException(\"Invalid provider method: \" + provider.method.getName(), ex); } } throw new PetiteException(\"Invalid provider\"); } \nResponse:", "ground_truth": "Invokes provider to get a bean.", "predict": " Invokes Petite provider method. @param provider Petite provider definition. @return Provider method return value.\n"}
{"ID": 1048, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addBean(final String name, final Object bean, WiringMode wiringMode) { wiringMode = petiteConfig.resolveWiringMode(wiringMode); registerPetiteBean(bean.getClass(), name, SingletonScope.class, wiringMode, false, null); BeanDefinition def = lookupExistingBeanDefinition(name); registerBeanAndWireAndInjectParamsAndInvokeInitMethods(new BeanData(this, def, bean)); } \nResponse:", "ground_truth": "Adds object instance to the container as singleton bean.", "predict": " Petite registries can be wired manually using this method. Petite will wire beans according to the wiring mode. @param name Name of Petite bean. @param bean Bean instance. @param wiringMode Wiring mode.\n*/"}
{"ID": 1049, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setBeanProperty(final String name, final Object value) { Object bean = null; int ndx = name.length(); while (true) { ndx = name.lastIndexOf('.', ndx); if (ndx == -1) { break; } String beanName = name.substring(0, ndx); bean = getBean(beanName); if (bean != null) { break; } ndx--; } if (bean == null) { throw new PetiteException(\"Invalid bean property: \" + name); } try { BeanUtil.declared.setProperty(bean, name.substring(ndx + 1), value); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } } \nResponse:", "ground_truth": "Sets petite bean property.", "predict": " Sets bean property value. @param name Name of the bean property. @param value Value of the bean property."}
{"ID": 1050, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getBeanProperty(final String name) { int ndx = name.indexOf('.'); if (ndx == -1) { throw new PetiteException(\"Only bean name is specified, missing property name: \" + name); } String beanName = name.substring(0, ndx); Object bean = getBean(beanName); if (bean == null) { throw new PetiteException(\"Bean doesn't exist: \" + name); } try { return BeanUtil.declared.getProperty(bean, name.substring(ndx + 1)); } catch (Exception ex) { throw new PetiteException(\"Invalid bean property: \" + name, ex); } } \nResponse:", "ground_truth": "Returns petite bean property value.", "predict": " Get bean property value. @param name Name of the bean property. @return Value of the property."}
{"ID": 1051, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void shutdown() { scopes.forEachValue(Scope::shutdown); externalsCache.clear(); beans.clear(); beansAlt.clear(); scopes.clear(); providers.clear(); beanCollections.clear(); } \nResponse:", "ground_truth": "Shutdowns container. After container is down, it can't be used anymore.", "predict": " Shutdowns all caches and clears all caches. After shutdown, no beans or scopes can be added anymore."}
{"ID": 1052, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MethodParameter[] resolveParameters(final AccessibleObject methodOrCtor) { Class[] paramTypes; Class declaringClass; String name; if (methodOrCtor instanceof Method) { Method method = (Method) methodOrCtor; paramTypes = method.getParameterTypes(); name = method.getName(); declaringClass = method.getDeclaringClass(); } else { Constructor constructor = (Constructor) methodOrCtor; paramTypes = constructor.getParameterTypes(); declaringClass = constructor.getDeclaringClass(); name = CTOR_METHOD; } if (paramTypes.length == 0) { return MethodParameter.EMPTY_ARRAY; } InputStream stream; try { stream = ClassLoaderUtil.getClassAsStream(declaringClass); } catch (IOException ioex) { throw new ParamoException(\"Failed to read class bytes: \" + declaringClass.getName(), ioex); } if (stream == null) { throw new ParamoException(\"Class not found: \" + declaringClass); } try { ClassReader reader = new ClassReader(stream); MethodFinder visitor = new MethodFinder(declaringClass, name, paramTypes); reader.accept(visitor, 0); return visitor.getResolvedParameters(); } catch (IOException ioex) { throw new ParamoException(ioex); } finally { StreamUtil.close(stream); } } \nResponse:", "ground_truth": "Resolves method parameters from a method or constructor.\nReturns an empty array when target does not contain any parameter.\nNo caching is involved in this process, i.e. class bytecode\nis examined every time this method is called.", "predict": " Resolves the parameters of the given accessible object. @param methodOrCtor The accessible object. @return The resolved parameters. Shall not be <code>null</code>. Shall not be empty. Shall contain at least one element. Shall not be an array. Shall not be an instance of {@link CtConstructor CtConstructor} or {@link CtMethod CtMethod}. Shall not be an instance of {@link CtConstructor CtConstructor} or {@link CtMethod CtMethod} with constructor parameters. Shall not be an instance of {@link CtConstructor CtConstructor} or {@link CtMethod CtMethod} with method parameters. Shall not be an instance of {@link CtConstructor CtConstructor} or {@link CtMethod CtMethod} with no parameters. Shall not be an instance of {@link CtConstructor CtConstructor} or {@link CtMethod CtMethod} with more than one parameters. Shall not be an instance of {@link CtConstructor CtConstructor} or {@"}
{"ID": 1053, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int doAfterBody() throws JspException { BodyContent body = getBodyContent(); JspWriter out = body.getEnclosingWriter(); String bodytext = populateForm(body.getString(), name -> value(name, pageContext)); try { out.print(bodytext); } catch (IOException ioex) { throw new JspException(ioex); } return SKIP_BODY; } \nResponse:", "ground_truth": "Performs smart form population.", "predict": " Populate the form with the body content.\n * @return SKIP_BODY\n * @throws JspException if a JSP exception has occurred\n */"}
{"ID": 1054, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getValue(final String... profiles) { if (hasMacro) { return propsData.resolveMacros(value, profiles); } return value; } \nResponse:", "ground_truth": "Returns the property value, with replaced macros.", "predict": " Getter for property value. @param profiles profiles to resolve macros in value against. @return resolved value."}
{"ID": 1055, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void end() { if (parentNode != rootNode) { Node thisNode = parentNode; while (thisNode != rootNode) { if (domBuilder.config.isImpliedEndTags()) { if (implRules.implicitlyCloseTagOnEOF(thisNode.getNodeName())) { thisNode = thisNode.getParentNode(); continue; } } error(\"Unclosed tag closed: <\" + thisNode.getNodeName() + \">\"); thisNode = thisNode.getParentNode(); } } // remove whitespaces if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } // foster if (domBuilder.config.isUseFosterRules()) { HtmlFosterRules fosterRules = new HtmlFosterRules(); fosterRules.fixFosterElements(rootNode); } // elapsed rootNode.end(); if (log.isDebugEnabled()) { log.debug(\"LagartoDom tree created in \" + rootNode.getElapsedTime() + \" ms\"); } } \nResponse:", "ground_truth": "Finishes the tree building. Closes unclosed tags.", "predict": " Finalize the DOM tree."}
{"ID": 1056, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Element createElementNode(final Tag tag) { boolean hasVoidTags = htmlVoidRules != null; boolean isVoid = false; boolean selfClosed = false; if (hasVoidTags) { isVoid = htmlVoidRules.isVoidTag(tag.getName()); // HTML and XHTML if (isVoid) { // it's void tag, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } } else { // XML, no voids, lookup the flag selfClosed = domBuilder.config.isSelfCloseVoidTags(); } return new Element(rootNode, tag, isVoid, selfClosed); } \nResponse:", "ground_truth": "Creates new element with correct configuration.", "predict": " Creates a new Element object. Override this method if you wish to produce your own Element implementations. @param tag The tag to create the element for. @return The newly created Element.\n*/"}
{"ID": 1057, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void tag(final Tag tag) { if (!enabled) { return; } TagType tagType = tag.getType(); Element node; switch (tagType) { case START: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); if (domBuilder.config.isImpliedEndTags()) { while (true) { String parentNodeName = parentNode.getNodeName(); if (!implRules.implicitlyCloseParentTagOnNewTag(parentNodeName, node.getNodeName())) { break; } parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + node.getNodeName() + \"> \"); } } } parentNode.addChild(node); if (!node.isVoidElement()) { parentNode = node; } break; case END: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, true); } String tagName = tag.getName().toString(); Node matchingParent = findMatchingParentOpenTag(tagName); if (matchingParent == parentNode) { // regular situation parentNode = parentNode.getParentNode(); break; } if (matchingParent == null) { // matching open tag not found, remove it error(\"Orphan closed tag ignored: </\" + tagName + \"> \" + tag.getTagPosition()); break; } // try to close it implicitly if (domBuilder.config.isImpliedEndTags()) { boolean fixed = false; while (implRules.implicitlyCloseParentTagOnTagEnd(parentNode.getNodeName(), tagName)) { parentNode = parentNode.getParentNode(); if (log.isDebugEnabled()) { log.debug(\"Implicitly closed tag <\" + tagName + \">\"); } if (parentNode == matchingParent) { parentNode = matchingParent.parentNode; fixed = true; break; } } if (fixed) { break; } } // matching tag found, but it is not a regular situation // therefore close all unclosed tags in between fixUnclosedTagsUpToMatchingParent(tag, matchingParent); break; case SELF_CLOSING: if (domBuilder.config.isIgnoreWhitespacesBetweenTags()) { removeLastChildNodeIfEmptyText(parentNode, false); } node = createElementNode(tag); parentNode.addChild(node); break; } } \nResponse:", "ground_truth": "Visits tags.", "predict": " Tag the sax event accordingly to the tag type. @param tag The tag to tag.\n*/"}
{"ID": 1058, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void removeLastChildNodeIfEmptyText(final Node parentNode, final boolean closedTag) { if (parentNode == null) { return; } Node lastChild = parentNode.getLastChild(); if (lastChild == null) { return; } if (lastChild.getNodeType() != Node.NodeType.TEXT) { return; } if (closedTag) { if (parentNode.getChildNodesCount() == 1) { return; } } Text text = (Text) lastChild; if (text.isBlank()) { lastChild.detachFromParent(); } } \nResponse:", "ground_truth": "Removes last child node if contains just empty text.", "predict": " Removes last child node if it is empty text. @param parentNode Parent node. @param closedTag True if parent tag is closed tag."}
{"ID": 1059, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getQueryString() { if (sqlTemplate == null) { return toString(); } if (parameterValues == null) { return sqlTemplate; } final StringBuilder sb = new StringBuilder(); int qMarkCount = 0; final StringTokenizer tok = new StringTokenizer(sqlTemplate + ' ', \"?\"); while (tok.hasMoreTokens()) { final String oneChunk = tok.nextToken(); sb.append(oneChunk); try { Object value = null; if (parameterValues.size() > 1 + qMarkCount) { value = parameterValues.get(1 + qMarkCount); qMarkCount++; } else { if (!tok.hasMoreTokens()) { value = \"\"; } } if (value == null) { value = \"?\"; } sb.append(value); } catch (Throwable th) { sb.append(\"--- Building query failed: \").append(th.toString()); } } return sb.toString().trim(); } \nResponse:", "ground_truth": "Returns the query string.", "predict": " Get the query string. @return query string\n*/"}
{"ID": 1060, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String getActionClassName(final Object action) { Class clazz = action.getClass(); clazz = ProxettaUtil.resolveTargetClass(clazz); return clazz.getName(); } \nResponse:", "ground_truth": "Returns correct action class name. Detects Proxetta classes.", "predict": " Obtain the action class name. @param action The action. @return The action class name."}
{"ID": 1061, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int calculateTo(final int from, final int count, final int size) { int to = size; if (count != -1) { to = from + count; if (to > size) { to = size; } } return to; } \nResponse:", "ground_truth": "Calculates 'TO'.", "predict": " Calculate the to index for the slice operation. @param from the from index. @param count the count. @param size the size of the list. @return the to index.\n*/"}
{"ID": 1062, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void iterateCollection(final Collection collection, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); Iterator iter = collection.iterator(); int i = 0; int to = calculateTo(from, count, collection.size()); while (i < to) { Object item = iter.next(); if (i >= from) { if (status != null) { iteratorStatus.next(!iter.hasNext()); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } i++; } } \nResponse:", "ground_truth": "Iterates collection.", "predict": " Iterates through the collection, skipping ahead to the correct spot in the collection. The collection itself is also iterated through. @param collection Collection to iterate through. @param from Starting index. @param count Maximum number of items to iterate through. @param pageContext Associated PageContext. @throws JspException On errors.\n*/"}
{"ID": 1063, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void iterateArray(final Object[] array, final int from, final int count, final PageContext pageContext) throws JspException { JspFragment body = getJspBody(); int len = array.length; int to = calculateTo(from, count, len); int last = to - 1; for (int i = from; i < to; i++) { Object item = array[i]; if (status != null) { iteratorStatus.next(i == last); } TagUtil.setScopeAttribute(var, item, scope, pageContext); TagUtil.invokeBody(body); } } \nResponse:", "ground_truth": "Iterates arrays.", "predict": " Iterates through the array, setting the scope attribute to the current item. @param array the array to iterate through @param from the index to start iterating from @param count the number of items to iterate through @param pageContext the pageContext to set the scope attribute on @throws JspException if a JSP exception occurs\n*/"}
{"ID": 1064, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replace(final String s, final String sub, final String with) { if (sub.isEmpty()) { return s; } int c = 0; int i = s.indexOf(sub, c); if (i == -1) { return s; } int length = s.length(); StringBuilder sb = new StringBuilder(length + with.length()); do { sb.append(s, c, i); sb.append(with); c = i + sub.length(); } while ((i = s.indexOf(sub, c)) != -1); if (c < length) { sb.append(s, c, length); } return sb.toString(); } \nResponse:", "ground_truth": "Replaces all occurrences of a certain pattern in a string with a\nreplacement string. This is the fastest replace function known to author.\n\n@param s      string to be inspected\n@param sub    string pattern to be replaced\n@param with   string that should go where the pattern was", "predict": " Replaces all occurrences of sub in s with with. @param s The string to search. @param sub The substring to replace. @param with The replacement. @return The resulting string."}
{"ID": 1065, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceChar(final String s, final char sub, final char with) { int startIndex = s.indexOf(sub); if (startIndex == -1) { return s; } char[] str = s.toCharArray(); for (int i = startIndex; i < str.length; i++) { if (str[i] == sub) { str[i] = with; } } return new String(str); } \nResponse:", "ground_truth": "Replaces all occurrences of a character in a string.\n\n@param s      input string\n@param sub    character to replace\n@param with   character to replace with", "predict": " Replaces all occurrences of one character with another character. @param s The string to modify. @param sub The character to replace. @param with The replacement character. @return The resulting string."}
{"ID": 1066, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceChars(final String s, final char[] sub, final char[] with) { char[] str = s.toCharArray(); for (int i = 0; i < str.length; i++) { char c = str[i]; for (int j = 0; j < sub.length; j++) { if (c == sub[j]) { str[i] = with[j]; break; } } } return new String(str); } \nResponse:", "ground_truth": "Replaces all occurrences of a characters in a string.\n\n@param s      input string\n@param sub    characters to replace\n@param with   characters to replace with", "predict": " Replaces all occurrences of characters in the given char[] with the given char[] in the given string. @param s the string to modify @param sub the characters to replace @param with the replacement characters\n@return the resulting string\n*/"}
{"ID": 1067, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceFirst(final String s, final String sub, final String with) { int i = s.indexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); } \nResponse:", "ground_truth": "Replaces the very first occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": " Replaces the first occurrence of sub in s with with. Returns the string consisting of the leading characters in s and the characters in with inserted at the beginning of s. @param s the string to search through. @param sub the substring to search for. @param with the substring to replace it with. @return the string with the first occurrence of sub replaced by with."}
{"ID": 1068, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceFirst(final String s, final char sub, final char with) { int index = s.indexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); } \nResponse:", "ground_truth": "Replaces the very first occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": " Replaces the first occurrence of sub with with in s. @param s The string to search through. @param sub The substring to search for. @param with The substring to replace it with. @return The string with the first occurrence of sub replaced with with.\n*/"}
{"ID": 1069, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceLast(final String s, final String sub, final String with) { int i = s.lastIndexOf(sub); if (i == -1) { return s; } return s.substring(0, i) + with + s.substring(i + sub.length()); } \nResponse:", "ground_truth": "Replaces the very last occurrence of a substring with supplied string.\n\n@param s      source string\n@param sub    substring to replace\n@param with   substring to replace with", "predict": " Replaces the last substring of the given string that matches the regular expression with the replacement string. @param s The string to examine. @param sub The substring to replace. @param with The replacement string. @return The resulting string."}
{"ID": 1070, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String replaceLast(final String s, final char sub, final char with) { int index = s.lastIndexOf(sub); if (index == -1) { return s; } char[] str = s.toCharArray(); str[index] = with; return new String(str); } \nResponse:", "ground_truth": "Replaces the very last occurrence of a character in a string.\n\n@param s      string\n@param sub    char to replace\n@param with   char to replace with", "predict": " Replaces the last occurrence of sub with with in s. @param s The string to search through. @param sub The substring to search for. @param with The substring to replace it with. @return The resulting string with the last occurrence of sub replaced with with.\n*/"}
{"ID": 1071, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String remove(final String s, final String sub) { int c = 0; int sublen = sub.length(); if (sublen == 0) { return s; } int i = s.indexOf(sub, c); if (i == -1) { return s; } StringBuilder sb = new StringBuilder(s.length()); do { sb.append(s, c, i); c = i + sublen; } while ((i = s.indexOf(sub, c)) != -1); if (c < s.length()) { sb.append(s, c, s.length()); } return sb.toString(); } \nResponse:", "ground_truth": "Removes all substring occurrences from the string.\n\n@param s      source string\n@param sub    substring to remove", "predict": " Removes substrings from a string. Similar to perl's ortr. @param s The string to remove substrings from. @param sub The substring to remove. @return The resulting string.\n*/"}
{"ID": 1072, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String remove(final String string, final char ch) { int stringLen = string.length(); char[] result = new char[stringLen]; int offset = 0; for (int i = 0; i < stringLen; i++) { char c = string.charAt(i); if (c == ch) { continue; } result[offset] = c; offset++; } if (offset == stringLen) { return string; // no changes } return new String(result, 0, offset); } \nResponse:", "ground_truth": "Removes a single character from string.\n\n@param string    source string\n@param ch  character to remove", "predict": " Removes all occurrences of the char argument from the string. @param string the original string @param ch the char to remove @return the resulting substring\n*/"}
{"ID": 1073, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAllEmpty(final String... strings) { for (String string : strings) { if (!isEmpty(string)) { return false; } } return true; } \nResponse:", "ground_truth": "Determines if string array contains empty strings.\n@see #isEmpty(CharSequence)", "predict": " Checks if all strings are empty. @param strings The strings to check. @return True if all strings are empty, false otherwise."}
{"ID": 1074, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isAllBlank(final String... strings) { for (String string : strings) { if (!isBlank(string)) { return false; } } return true; } \nResponse:", "ground_truth": "Determines if string array contains just blank strings.", "predict": " Checks if all strings are blank. @param strings Strings to check. @return True if all strings are blank. False otherwise."}
{"ID": 1075, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] toStringArray(final Object value) { if (value == null) { return new String[0]; } Class<?> type = value.getClass(); if (!type.isArray()) { return new String[] {value.toString()}; } Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { if (componentType == int.class) { return ArraysUtil.toStringArray((int[]) value); } else if (componentType == long.class) { return ArraysUtil.toStringArray((long[]) value); } else if (componentType == double.class) { return ArraysUtil.toStringArray((double[]) value); } else if (componentType == float.class) { return ArraysUtil.toStringArray((float[]) value); } else if (componentType == boolean.class) { return ArraysUtil.toStringArray((boolean[]) value); } else if (componentType == short.class) { return ArraysUtil.toStringArray((short[]) value); } else if (componentType == byte.class) { return ArraysUtil.toStringArray((byte[]) value); } else { throw new IllegalArgumentException(); } } else { return ArraysUtil.toStringArray((Object[]) value); } } \nResponse:", "ground_truth": "Converts an array object to array of strings, where every element\nof input array is converted to a string. If input is not an array,\nthe result will still be an array with one element.", "predict": " Convert an arbitrary Object to a String[] using reflection. Primitives will be wrapped as their boxed types. Arrays will also be recognised and recursed into. Lastly, Strings will be recognised as well. Primitive Strings will be returned as-is. Non-primitives will be returned as Strings. Primitive Arrays will be returned as-is. Non-primitives will be returned as Strings. Non-primitive Arrays will be returned as Strings. Lastly, Strings will be returned as-is. @param value The Object to convert to a String[] @return The String[] representation of the Object"}
{"ID": 1076, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String changeFirstCharacterCase(final boolean capitalize, final String string) { int strLen = string.length(); if (strLen == 0) { return string; } char ch = string.charAt(0); char modifiedCh; if (capitalize) { modifiedCh = Character.toUpperCase(ch); } else { modifiedCh = Character.toLowerCase(ch); } if (modifiedCh == ch) { // no change, return unchanged string return string; } char[] chars = string.toCharArray(); chars[0] = modifiedCh; return new String(chars); } \nResponse:", "ground_truth": "Internal method for changing the first character case.", "predict": " Capitalize the first character of the given string. @param capitalize TRUE if the first character should be capitalized, FALSE otherwise. @param string The string to capitalize. @return The capitalized string."}
{"ID": 1077, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String title(final String string) { char[] chars = string.toCharArray(); boolean wasWhitespace = true; for (int i = 0; i < chars.length; i++) { char c = chars[i]; if (CharUtil.isWhitespace(c)) { wasWhitespace = true; } else { if (wasWhitespace) { chars[i] = Character.toUpperCase(c); } else { chars[i] = Character.toLowerCase(c); } wasWhitespace = false; } } return new String(chars); } \nResponse:", "ground_truth": "Makes a title-cased string from given input.", "predict": " Capitalizes the first letter of the string. Useful for generating pretty table captions. @param string The string to capitalize. @return Capitalized string."}
{"ID": 1078, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String compressChars(final String s, final char c) { int len = s.length(); StringBuilder sb = new StringBuilder(len); boolean wasChar = false; for (int i = 0; i < len; i++) { char c1 = s.charAt(i); if (c1 == c) { if (wasChar) { continue; } wasChar = true; } else { wasChar = false; } sb.append(c1); } if (sb.length() == len) { return s; } return sb.toString(); } \nResponse:", "ground_truth": "Compress multiple occurrences of given char into one appearance.", "predict": " Removes all occurrences of char c from s. Returns s if c does not appear in s. @param s the string to modify @param c the char to remove\n * @return the resulting string\n */"}
{"ID": 1079, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean startsWithIgnoreCase(final String src, final String subS, final int startIndex) { String sub = subS.toLowerCase(); int sublen = sub.length(); if (startIndex + sublen > src.length()) { return false; } int j = 0; int i = startIndex; while (j < sublen) { char source = Character.toLowerCase(src.charAt(i)); if (sub.charAt(j) != source) { return false; } j++; i++; } return true; } \nResponse:", "ground_truth": "Tests if this string starts with the specified prefix with ignored case\nand with the specified prefix beginning a specified index.\n\n@param src        source string to test\n@param subS       starting substring\n@param startIndex index from where to test\n\n@return <code>true</code> if the character sequence represented by the argument is\na prefix of the character sequence represented by this string;\n<code>false</code> otherwise.", "predict": " Checks if a string starts with ignoring case considerations of characters in the prefix supplied. This method will consider the case of letters regardless of the case of letters in the source string. @param src The source string. @param subS The prefix to consider. @param startIndex The starting index of the comparison ignoring case considerations. @return True if the source starts with ignoring case considerations of characters in the prefix. False otherwise."}
{"ID": 1080, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean endsWithChar(final String s, final char c) { if (s.length() == 0) { return false; } return s.charAt(s.length() - 1) == c; } \nResponse:", "ground_truth": "Returns if string ends with provided character.", "predict": " Returns true if the string ends with the character. @param s the string to test. @param c the character to test for. @return true if the string ends with the character."}
{"ID": 1081, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int countIgnoreCase(final String source, final String sub) { int count = 0; int j = 0; int sublen = sub.length(); if (sublen == 0) { return 0; } while (true) { int i = indexOfIgnoreCase(source, sub, j); if (i == -1) { break; } count++; j = i + sublen; } return count; } \nResponse:", "ground_truth": "Count substring occurrences in a source string, ignoring case.\n\n@param source\tsource string\n@param sub\t\tsubstring to count\n@return\t\t\tnumber of substring occurrences", "predict": " Count how often the substring appears in the larger string ignoring case considerations. This method is more efficient than count if you don't need the actual count. The count returned is the number of times that the substring appears in the larger string ignoring case considerations. This method is faster than countIgnoreCase if the expected string count is small compared to the source string length. The count returned is an estimate because some strings may be exponentially larger than others. @param source the larger string @param sub the smaller string @return the estimated frequency of occurrence of the smaller string in the larger string ignoring case considerations.\n */"}
{"ID": 1082, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean equalsIgnoreCase(final String[] as, final String[] as1) { if (as.length != as1.length) { return false; } for (int i = 0; i < as.length; i++) { if (!as[i].equalsIgnoreCase(as1[i])) { return false; } } return true; } \nResponse:", "ground_truth": "Compares two string arrays.\n\n@param as     first string array\n@param as1    second string array\n\n@return true if all array elements matches", "predict": " Compare two arrays ignoring case considerations. @param as The first array. @param as1 The second array. @return True if both arrays are equal ignoring case considerations. False otherwise."}
{"ID": 1083, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOfWhitespace(final String string, final int startindex, final int endindex) { for (int i = startindex; i < endindex; i++) { if (CharUtil.isWhitespace(string.charAt(i))) { return i; } } return -1; } \nResponse:", "ground_truth": "Returns first index of a whitespace character, starting from specified index offset.", "predict": " Finds the index of the first whitespace character in the string within the given range. @param string the string to search through @param startindex the starting index to search @param endindex the ending index to search @return the index of the first whitespace character found, or -1 if none found\n*/"}
{"ID": 1084, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripLeadingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(0) == c) { return string.substring(1); } } return string; } \nResponse:", "ground_truth": "Strips leading char if string starts with one.", "predict": " Strips leading char from string. @param string input string @param c leading char to strip @return stripped string\n*/"}
{"ID": 1085, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripTrailingChar(final String string, final char c) { if (string.length() > 0) { if (string.charAt(string.length() - 1) == c) { return string.substring(0, string.length() - 1); } } return string; } \nResponse:", "ground_truth": "Strips trailing char if string ends with one.", "predict": " Strips trailing char from string. @param string input string @param c trailing char to strip @return stripped string\n*/"}
{"ID": 1086, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripChar(final String string, final char c) { if (string.length() == 0) { return string; } if (string.length() == 1) { if (string.charAt(0) == c) { return StringPool.EMPTY; } return string; } int left = 0; int right = string.length(); if (string.charAt(left) == c) { left++; } if (string.charAt(right - 1) == c) { right--; } return string.substring(left, right); } \nResponse:", "ground_truth": "Strips leading and trailing char from given string.", "predict": " Strips the specified character from the front and back of the string. @param string The string to strip. @param c The character to strip. @return The stripped string."}
{"ID": 1087, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripToChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(ndx); } \nResponse:", "ground_truth": "Strips everything up to the first appearance of given char.\nCharacter IS included in the returned string.", "predict": " Strips the specified character from the front of the string. Returns the original string if the character is not found. @param string The string to strip characters from. @param c The character to strip. @return The stripped string."}
{"ID": 1088, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String stripFromChar(final String string, final char c) { int ndx = string.indexOf(c); if (ndx == -1) { return string; } return string.substring(0, ndx); } \nResponse:", "ground_truth": "Strips everything from the first appearance of given char.\nCharacter IS NOT included in the returned string.", "predict": " Strips the specified character from the front of the string. Returns the original string if the character is not found. @param string The string to strip characters from. @param c The character to strip. @return The stripped string."}
{"ID": 1089, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cropAll(final String... strings) { for (int i = 0; i < strings.length; i++) { String string = strings[i]; if (string != null) { string = crop(strings[i]); } strings[i] = string; } } \nResponse:", "ground_truth": "Crops all elements of string array.", "predict": " Crops all strings. @param strings The strings to crop. Shall not be <code>null</code>. Shall contain at least one non-null element. Shall not be empty. Shall not contain any trailing whitespaces. Shall not contain any leading whitespaces. Shall not contain any trailing newlines. Shall not contain any leading newlines. Shall not contain any trailing carriage returns. Shall not contain any leading carriage returns. Shall not contain any trailing form feeds. Shall not contain any leading form feeds. Shall not contain any trailing tabs. Shall not contain any leading tabs. Shall not contain any trailing spaces. Shall not contain any leading spaces. Shall not contain any trailing dots. Shall not contain any leading dots. Shall not contain any trailing hyphens. Shall not contain any leading hyphens. Shall not contain any trailing apostrophes. Shall not contain any leading apostrophes. Shall not contain any trailing quotation marks. Shall not contain any leading quotation marks. Shall not contain any trailing apostrophe quotations marks. Shall not contain any leading apostrophe quotations marks. Shall not"}
{"ID": 1090, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String trimLeft(final String src) { int len = src.length(); int st = 0; while ((st < len) && (CharUtil.isWhitespace(src.charAt(st)))) { st++; } return st > 0 ? src.substring(st) : src; } \nResponse:", "ground_truth": "Trim whitespaces from the left.", "predict": " Trim leading whitespace characters from the source string. @param src The source string. @return The trimmed string."}
{"ID": 1091, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String trimRight(final String src) { int len = src.length(); int count = len; while ((len > 0) && (CharUtil.isWhitespace(src.charAt(len - 1)))) { len--; } return (len < count) ? src.substring(0, len) : src; } \nResponse:", "ground_truth": "Trim whitespaces from the right.", "predict": " Trim trailing whitespace characters from the end of the string. @param src The string to trim trailing whitespace characters from. @return The trimmed string."}
{"ID": 1092, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int[] indexOfRegion(final String string, final String leftBoundary, final String rightBoundary, final int offset) { int ndx = offset; int[] res = new int[4]; ndx = string.indexOf(leftBoundary, ndx); if (ndx == -1) { return null; } res[0] = ndx; ndx += leftBoundary.length(); res[1] = ndx; ndx = string.indexOf(rightBoundary, ndx); if (ndx == -1) { return null; } res[2] = ndx; res[3] = ndx + rightBoundary.length(); return res; } \nResponse:", "ground_truth": "Returns indexes of the first region without escaping character.\n@see #indexOfRegion(String, String, String, char, int)", "predict": " Finds the boundaries of a region in a string. The boundaries are inclusive. @param string The string to search. @param leftBoundary The left boundary of the region. @param rightBoundary The right boundary of the region. @param offset The offset to start searching from. @return The boundaries of the region, or null if none found."}
{"ID": 1093, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String join(final Collection collection, final char separator) { if (collection == null) { return null; } if (collection.size() == 0) { return StringPool.EMPTY; } final StringBuilder sb = new StringBuilder(collection.size() * 16); final Iterator it = collection.iterator(); for (int i = 0; i < collection.size(); i++) { if (i > 0) { sb.append(separator); } sb.append(it.next()); } return sb.toString(); } \nResponse:", "ground_truth": "Joins an collection of objects into one string with separator.", "predict": " Joins the elements of the provided collection into a single String containing the provided list of elements. The list of elements will be separated by the provided separator character. @param collection The collection whose elements will be joined together. @param separator The character to be used to separate the elements of the provided collection. @return The joined string."}
{"ID": 1094, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String join(final Object[] array, final String separator) { if (array == null) { return null; } if (array.length == 0) { return StringPool.EMPTY; } if (array.length == 1) { return String.valueOf(array[0]); } final StringBuilder sb = new StringBuilder(array.length * 16); for (int i = 0; i < array.length; i++) { if (i > 0) { sb.append(separator); } sb.append(array[i]); } return sb.toString(); } \nResponse:", "ground_truth": "Joins an array of objects into one string with separator.", "predict": " Joins the elements of the provided array into a single String containing the provided list of elements. The returned string will be a multiline string containing the list of elements separated by the provided separator. @param array The array of elements to join together. @param separator The separator to use between each element. @return The joined string."}
{"ID": 1095, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String convertCharset(final String source, final String srcCharsetName, final String newCharsetName) { if (srcCharsetName.equals(newCharsetName)) { return source; } return StringUtil.newString(StringUtil.getBytes(source, srcCharsetName), newCharsetName); } \nResponse:", "ground_truth": "Converts string charset. If charset names are the same, the same string is returned.", "predict": " Convert charset. @param source source string. @param srcCharsetName src charset name. @param newCharsetName new charset name. @return converted string."}
{"ID": 1096, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isCharAtEqual(final String string, final int index, final char charToCompare) { if ((index < 0) || (index >= string.length())) { return false; } return string.charAt(index) == charToCompare; } \nResponse:", "ground_truth": "Safely compares provided char with char on given location.", "predict": " Checks if the character at the specified index is equal to the character to compare. @param string The string to check. @param index The index of the character to compare. @return True if the character at the specified index is equal to the character to compare. False otherwise."}
{"ID": 1097, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String surround(String string, final String prefix, final String suffix) { if (!string.startsWith(prefix)) { string = prefix + string; } if (!string.endsWith(suffix)) { string += suffix; } return string; } \nResponse:", "ground_truth": "Surrounds the string with provided prefix and suffix if such missing from string.", "predict": " Surrounds a string with prefix and suffix. If the string doesn't start with prefix, prefix is prepended. If the string doesn't ends with suffix, suffix is appended. @param string the string to surround. @param prefix the prefix to surround the string with. @param suffix the suffix to surround the string with. @return the surrounded string."}
{"ID": 1098, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String prefix(String string, final String prefix) { if (!string.startsWith(prefix)) { string = prefix + string; } return string; } \nResponse:", "ground_truth": "Inserts prefix if doesn't exist.", "predict": " Prefix a string if it doesn't already start with the prefix. Useful for enforcing naming conventions. @param string The string to prefix. @param prefix The prefix to enforce. @return The prefixed string."}
{"ID": 1099, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String suffix(String string, final String suffix) { if (!string.endsWith(suffix)) { string += suffix; } return string; } \nResponse:", "ground_truth": "Appends suffix if doesn't exist.", "predict": " Ensures that the string ends with suffix. If not, it adds suffix to the end of the string. @param string The string to be suffixed. @param suffix Suffix to be added. @return The suffixed string."}
{"ID": 1100, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutToIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(0, i); } return string; } \nResponse:", "ground_truth": "Cuts the string from beginning to the first index of provided substring.", "predict": " Cut substring from string. @param string Original string. @param substring Substring to cut. @return Result string."}
{"ID": 1101, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutFromIndexOf(String string, final String substring) { int i = string.indexOf(substring); if (i != -1) { string = string.substring(i); } return string; } \nResponse:", "ground_truth": "Cuts the string from the first index of provided substring to the end.", "predict": " Cut substring from indexOf. @param string Original string. @param substring Substring to cut. @return Result string."}
{"ID": 1102, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutPrefix(String string, final String prefix) { if (string.startsWith(prefix)) { string = string.substring(prefix.length()); } return string; } \nResponse:", "ground_truth": "Cuts prefix if exists.", "predict": " Cut off the prefix from the string. @param string The string to cut off the prefix. @param prefix The prefix to cut off. @return The cutted string."}
{"ID": 1103, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutSuffix(String string, final String suffix) { if (string.endsWith(suffix)) { string = string.substring(0, string.length() - suffix.length()); } return string; } \nResponse:", "ground_truth": "Cuts sufix if exists.", "predict": " Cut suffix from string. @param string Original string. @param suffix Suffix to cut. @return Result string."}
{"ID": 1104, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String cutSurrounding(final String string, final String prefix, final String suffix) { int start = 0; int end = string.length(); if (string.startsWith(prefix)) { start = prefix.length(); } if (string.endsWith(suffix)) { end -= suffix.length(); } if (end <= start) { return StringPool.EMPTY; } return string.substring(start, end); } \nResponse:", "ground_truth": "Removes surrounding prefix and suffixes.", "predict": " Cut surrounding string. @param string the string @param prefix the prefix @param suffix the suffix @return surrounding string"}
{"ID": 1105, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String insert(final String src, final String insert, int offset) { if (offset < 0) { offset = 0; } if (offset > src.length()) { offset = src.length(); } StringBuilder sb = new StringBuilder(src); sb.insert(offset, insert); return sb.toString(); } \nResponse:", "ground_truth": "Inserts a string on provided offset.", "predict": " Inserts substr at offset. Negative offsets are counted from the end of the string. @param src source string @param insert substr to insert @param offset offset to insert substr at @return new string\n*/"}
{"ID": 1106, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String repeat(final String source, int count) { StringBand result = new StringBand(count); while (count > 0) { result.append(source); count--; } return result.toString(); } \nResponse:", "ground_truth": "Creates a new string that contains the provided string a number of times.", "predict": " Repeats the source string count times. Leaves trailing blanks. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched. Leaves leading blanks untouched. Leaves trailing blanks untouched"}
{"ID": 1107, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String reverse(final String s) { StringBuilder result = new StringBuilder(s.length()); for (int i = s.length() -1; i >= 0; i--) { result.append(s.charAt(i)); } return result.toString(); } \nResponse:", "ground_truth": "Reverse a string.", "predict": " Reverse the order of characters in a string. @param s The string to reverse. @return The reversed string."}
{"ID": 1108, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String maxCommonPrefix(final String one, final String two) { final int minLength = Math.min(one.length(), two.length()); final StringBuilder sb = new StringBuilder(minLength); for (int pos = 0; pos < minLength; pos++) { final char currentChar = one.charAt(pos); if (currentChar != two.charAt(pos)) { break; } sb.append(currentChar); } return sb.toString(); } \nResponse:", "ground_truth": "Returns max common prefix of two strings.", "predict": " Find the longest common prefix between two strings. @param one first string @param two second string @return longest common prefix between two strings\n*/"}
{"ID": 1109, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String findCommonPrefix(final String... strings) { StringBuilder prefix = new StringBuilder(); int index = 0; char c = 0; loop: while (true) { for (int i = 0; i < strings.length; i++) { String s = strings[i]; if (index == s.length()) { break loop; } if (i == 0) { c = s.charAt(index); } else { if (s.charAt(index) != c) { break loop; } } } index++; prefix.append(c); } return prefix.length() == 0 ? StringPool.EMPTY : prefix.toString(); } \nResponse:", "ground_truth": "Finds common prefix for several strings. Returns an empty string if\narguments do not have a common prefix.", "predict": " Find common prefix. @param strings the strings @return the string\n*/"}
{"ID": 1110, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String shorten(String s, int length, final String suffix) { length -= suffix.length(); if (s.length() > length) { for (int j = length; j >= 0; j--) { if (CharUtil.isWhitespace(s.charAt(j))) { length = j; break; } } String temp = s.substring(0, length); s = temp.concat(suffix); } return s; } \nResponse:", "ground_truth": "Shorten string to given length.", "predict": " Shortens a string to a maximum length plus a suffix. Useful for enforcing a maximum length on strings. Useful for ensuring that strings are not too long when displaying them in a GUI. @param s The string to shorten. @param length The maximum length of the string. @param suffix The suffix to append to the shortened string. @return The shortened string."}
{"ID": 1111, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toUpperCase(final String s, Locale locale) { if (s == null) { return null; } StringBuilder sb = null; for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); if (c > 127) { // found non-ascii char, fallback to the slow unicode detection if (locale == null) { locale = Locale.getDefault(); } return s.toUpperCase(locale); } if ((c >= 'a') && (c <= 'z')) { if (sb == null) { sb = new StringBuilder(s); } sb.setCharAt(i, (char)(c - 32)); } } if (sb == null) { return s; } return sb.toString(); } \nResponse:", "ground_truth": "Converts all of the characters in the string to upper case, based on the\nlocale.\n\n@param  s the string to convert\n@param  locale apply this locale's rules\n@return the string, converted to upper case, or <code>null</code> if the\nstring is <code>null</code>", "predict": " Capitalizes the first letter of each word in the given string. Words are delimited by white space. Characters that are not letters, digits or underscores are treated as a single word. Capitalization uses the conventions outlined in section 3.13 of the Java Language Specification. Although this method is capable of handling accented letters, it is recommended you ask the translators of your applications to translate the accented characters into their ASCII or Unicode counterparts. Note that this will not work properly for certain characters, such as ligatures and emoji. Additionally, note that translating ligatures may result in incorrect capitalization of words. For more information on Unicode acronyms, see section 3.13 of the Java Language Specification. @param s the string to capitalize. @param locale the locale to use for capitalization, or null for the default locale. @return the capitalized string.\n"}
{"ID": 1112, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String removeQuotes(final String string) { if ( (startsWithChar(string, '\\'') && endsWithChar(string, '\\'')) || (startsWithChar(string, '\"') && endsWithChar(string, '\"')) || (startsWithChar(string, '`') && endsWithChar(string, '`')) ) { return substring(string, 1, -1); } return string; } \nResponse:", "ground_truth": "Removes starting and ending single or double quotes.", "predict": " Removes surrounding quotes from a string. @param string the string to remove quotes from @return the string without surrounding quotes\n*/"}
{"ID": 1113, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toHexString(final byte[] bytes) { char[] chars = new char[bytes.length * 2]; int i = 0; for (byte b : bytes) { chars[i++] = CharUtil.int2hex((b & 0xF0) >> 4); chars[i++] = CharUtil.int2hex(b & 0x0F); } return new String(chars); } \nResponse:", "ground_truth": "Converts bytes to hex string.", "predict": " Convert byte array to hex string. @param bytes byte array @return hex string\n*/"}
{"ID": 1114, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] getBytes(final String string) { try { return string.getBytes(JoddCore.encoding); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } } \nResponse:", "ground_truth": "Returns String bytes using Jodds default encoding.", "predict": " Converts string to byte array using UTF-8 encoding. Throws runtime exception on encoding error.\n */"}
{"ID": 1115, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char detectQuoteChar(final String str) { if (str.length() < 2) { return 0; } final char c = str.charAt(0); if (c != str.charAt(str.length() - 1)) { return 0; } if (c == '\\'' || c == '\"' || c == '`') { return c; } return 0; } \nResponse:", "ground_truth": "Detects quote character or return 0.", "predict": " Detect quote char. @param str the str @return quote char or 0 if quote char not found"}
{"ID": 1116, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit(final String name, final Object value) { if (av != null) { av.visit(name, value); } } \nResponse:", "ground_truth": "Visits a primitive value of the annotation.\n\n@param name the value name.\n@param value the actual value, whose type must be {@link Byte}, {@link Boolean}, {@link\nCharacter}, {@link Short}, {@link Integer} , {@link Long}, {@link Float}, {@link Double},\n{@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\nvalue can also be an array of byte, boolean, short, char, int, long, float or double values\n(this is equivalent to using {@link #visitArray} and visiting each array element in turn,\nbut is more convenient).", "predict": " Visits a named value of the annotation. @param name the value name. @param value the actual value, or <tt>null</tt> if none was specified."}
{"ID": 1117, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitEnum(final String name, final String descriptor, final String value) { if (av != null) { av.visitEnum(name, descriptor, value); } } \nResponse:", "ground_truth": "Visits an enumeration value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the enumeration class.\n@param value the actual enumeration value.", "predict": " Visits an enumeration value of the annotation. @param name the value name. @param descriptor the class descriptor of the enumeration value. @param value the actual enumeration value."}
{"ID": 1118, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String name, final String descriptor) { if (av != null) { return av.visitAnnotation(name, descriptor); } return null; } \nResponse:", "ground_truth": "Visits a nested annotation value of the annotation.\n\n@param name the value name.\n@param descriptor the class descriptor of the nested annotation class.\n@return a visitor to visit the actual nested annotation value, or {@literal null} if this\nvisitor is not interested in visiting this nested annotation. <i>The nested annotation\nvalue must be fully visited before calling other methods on this annotation visitor</i>.", "predict": " Visits an annotation of the field. @param name the class name. @param descriptor the class descriptor. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation. <i>The type and path arguments of this method are ignored and can be null.</i>"}
{"ID": 1119, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> registerType(final Class<E> type) { DbEntityDescriptor<E> ded = createDbEntityDescriptor(type); DbEntityDescriptor<E> existing = descriptorsMap.put(type, ded); if (log.isDebugEnabled()) { log.debug(\"Register \" + type.getName() + \" as \" + ded.getTableName()); } if (existing != null) { if (ded.getType() == type) { return ded; } throw new DbOomException(\"Type already registered: \" + existing.getType()); } existing = entityNamesMap.put(ded.getEntityName(), ded); if (existing != null) { throw new DbOomException(\"Name '\" + ded.getEntityName() + \"' already mapped to an entity: \" + existing.getType()); } return ded; } \nResponse:", "ground_truth": "Registers just type and entity names. Enough for most usages.", "predict": " Register new entity descriptor. @param <E> Entity type. @param type Entity type. @return Newly registered descriptor. Never null."}
{"ID": 1120, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> registerEntity(final Class<E> type, final boolean force) { if (force) { removeEntity(type); } return registerEntity(type); } \nResponse:", "ground_truth": "Registers entity. Existing entity will be removed if exist, so no exception will be thrown.", "predict": " Register an entity. If force is true, remove any previously registered entity of the same type. Otherwise, do nothing if the entity is already registered. @param <E> Entity type. @param type Entity type. @param force Force removal of previously registered entity of the same type. @return Newly registered entity descriptor.\n*/"}
{"ID": 1121, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> DbEntityDescriptor<E> removeEntity(final Class<E> type) { DbEntityDescriptor<E> ded = descriptorsMap.remove(type); if (ded == null) { ded = createDbEntityDescriptor(type); } entityNamesMap.remove(ded.getEntityName()); tableNamesMap.remove(ded.getTableName()); return ded; } \nResponse:", "ground_truth": "Removes entity and returns removed descriptor.", "predict": " Remove an entity from the database. @param type Entity class. @return Removed descriptor.\n*/"}
{"ID": 1122, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E createEntityInstance(final Class<E> type) { try { return ClassUtil.newInstance(type); } catch (Exception ex) { throw new DbOomException(ex); } } \nResponse:", "ground_truth": "Creates new entity instances.", "predict": " Create new entity instance. @param <E> Entity type. @param type Entity type. @return New entity instance. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never THROW_EXCEPTION. Never NULL. Never"}
{"ID": 1123, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public WrapperProxettaFactory setTargetInterface(final Class targetInterface) { if (!targetInterface.isInterface()) { throw new ProxettaException(\"Not an interface: \" + targetInterface.getName()); } this.targetInterface = targetInterface; return this; } \nResponse:", "ground_truth": "Defines the interface of the resulting class.", "predict": " Set the target interface. Default is to use the proxetta class as target interface. @param targetInterface The target interface. @return The factory. Never null."}
{"ID": 1124, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectTargetIntoWrapper(final Object target, final Object wrapper) { ProxettaUtil.injectTargetIntoWrapper(target, wrapper, targetFieldName); } \nResponse:", "ground_truth": "Injects target into wrapper.", "predict": " Inject target into wrapper. @param target Target. @param wrapper Wrapper."}
{"ID": 1125, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected PropertyDescriptor[] lookupAnnotatedProperties(final Class type) { PropertyDescriptor[] properties = annotatedProperties.get(type); if (properties != null) { return properties; } ClassDescriptor cd = ClassIntrospector.get().lookup(type); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); List<PropertyDescriptor> list = new ArrayList<>(); for (PropertyDescriptor propertyDescriptor : allProperties) { Annotation ann = null; if (propertyDescriptor.getFieldDescriptor() != null) { ann = propertyDescriptor.getFieldDescriptor().getField().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getWriteMethodDescriptor() != null) { ann = propertyDescriptor.getWriteMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann == null && propertyDescriptor.getReadMethodDescriptor() != null) { ann = propertyDescriptor.getReadMethodDescriptor().getMethod().getAnnotation(annotations); } if (ann != null) { list.add(propertyDescriptor); } } if (list.isEmpty()) { properties = EMPTY; } else { properties = list.toArray(new PropertyDescriptor[0]); } annotatedProperties.put(type, properties); return properties; } \nResponse:", "ground_truth": "Lookups for annotated properties. Caches all annotated properties on the first\naction class scan.", "predict": " Introspect our bean type looking for annotated properties. @param type The bean type to introspect. @return An array of PropertyDescriptors describing the editable properties of this bean. May return an empty array if no properties are found.\n*/"}
{"ID": 1126, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbServer detectDatabaseAndConfigureDbOom( final ConnectionProvider cp, final DbOomConfig dbOomConfig) { cp.init(); final Connection connection = cp.getConnection(); final DbServer dbServer = detectDatabase(connection); cp.closeConnection(connection); dbServer.accept(dbOomConfig); return dbServer; } \nResponse:", "ground_truth": "Detects database and configure DbOom engine.", "predict": " Detect database and configure DbOom. @param cp Connection provider. Shall not be <code>null</code>. @param dbOomConfig DbOom configuration. Shall not be <code>null</code>. @return Newly created DbServer. Shall not be <code>null</code>. Shall implement {@link ConnectionProvider} interface. Shall declare {@link DbOomManager} annotation. Shall declare {@link DbOomConnectionProvider} annotation. Shall declare {@link DbOomTransactionScope} annotation. Shall declare {@link DbOomTransactionConfigurer} annotation. Shall declare {@link DbOomTransactionConfigurerFactory} annotation. Shall declare {@link DbOomTransactionConfigurer} annotation. Shall declare {@link DbOomTransactionConfigurerFactory} annotation. Shall declare {@link DbOomTransactionConfigurerFactory} annotation. Shall declare {@link DbOomTransactionConfigurerFactory} annotation. Shall declare {@link D"}
{"ID": 1127, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void close() throws IOException { if (closed) { return; } if (gzipstream != null) { flushToGZip(); gzipstream.close(); gzipstream = null; } else { if (bufferCount > 0) { output.write(buffer, 0, bufferCount); bufferCount = 0; } } output.close(); closed = true; } \nResponse:", "ground_truth": "Closes this output stream, causing any buffered data to be flushed and any\nfurther output data to throw an IOException.", "predict": " Flush remaining buffered data to the output stream and close it.\n@throws IOException if an I/O error occurs\n*/"}
{"ID": 1128, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void write(final int b) throws IOException { if (closed) { throw new IOException(\"Cannot write to a closed output stream\"); } if (bufferCount >= buffer.length) { flushToGZip(); } buffer[bufferCount++] = (byte) b; } \nResponse:", "ground_truth": "Writes the specified byte to our output stream.", "predict": " Writes the specified byte to this output stream. The general contract for write is that one byte is written to the output stream. The byte to be written is the eight low-order bits of the argument b. The 24 high-order bits of b are ignored. The bit offset within the byte is determined by the value of the bitOffset argument. The bit offset is set to zero by this method. The 24 high-order bits of the integer b are ignored. @param b the byte to be written. @exception IOException if an I/O error occurs. In particular, an IOException may be thrown if the output stream has been closed.\n*/"}
{"ID": 1129, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; if (isRequestedSessionIdFromURL(httpRequest)) { HttpSession session = httpRequest.getSession(false); if (session != null) { session.invalidate(); // clear session if session id in URL } } // wrap response to remove URL encoding HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper(httpResponse) { @Override public String encodeRedirectUrl(final String url) { return url; } @Override public String encodeRedirectURL(final String url) { return url; } @Override public String encodeUrl(final String url) { return url; } @Override public String encodeURL(final String url) { return url; } }; chain.doFilter(request, wrappedResponse); } \nResponse:", "ground_truth": "Filters requests to remove URL-based session identifiers.", "predict": " Interceptor for clearing session ID from URL. @param request intercepted HTTP request @param response intercepted HTTP response @param chain Filter chain @throws IOException propagated from filter chain @throws ServletException propagated from filter chain\n*/"}
{"ID": 1130, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getEncodedName() { if (name == null) { return null; } try { return MimeUtility.encodeText(name); } catch (final UnsupportedEncodingException ueex) { throw new MailException(ueex); } } \nResponse:", "ground_truth": "Returns encoded attachment name.\n\n@return encoded attachment name. Value may be {@code null}.", "predict": " Returns the encoded name of this header. @return the encoded name of this header\n*/"}
{"ID": 1131, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] toByteArray() { final FastByteArrayOutputStream out; if (size != -1) { out = new FastByteArrayOutputStream(size); } else { out = new FastByteArrayOutputStream(); } writeToStream(out); return out.toByteArray(); } \nResponse:", "ground_truth": "Returns byte content of the attachment.\n\n@return byte array with content of the attachment.", "predict": " Serialize this object to a byte array. @return the byte array containing the dumped content.\n*/"}
{"ID": 1132, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeToFile(final File destination) { InputStream input = null; final OutputStream output; try { input = getDataSource().getInputStream(); output = new FileOutputStream(destination); StreamUtil.copy(input, output); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } } \nResponse:", "ground_truth": "Saves attachment to a file.\n\n@param destination The destination file to be written.", "predict": " Write the mail content to the given file. @param destination The destination file. Shall not be <code>null</code>.\n"}
{"ID": 1133, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeToStream(final OutputStream out) { InputStream input = null; try { input = getDataSource().getInputStream(); StreamUtil.copy(input, out); } catch (final IOException ioex) { throw new MailException(ioex); } finally { StreamUtil.close(input); } } \nResponse:", "ground_truth": "Saves attachment to the output stream.\n\n@param out OutputStream where attachment should be copied to.", "predict": " Write the mail data to the given output stream. @param out The output stream to write to.\n*/"}
{"ID": 1134, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String appendArgument(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx) + type + desc.substring(ndx); } \nResponse:", "ground_truth": "Appends argument to the existing description.", "predict": " Append argument type to signature. @param desc Signature descriptor. @param type Argument type. @return Modified signature."}
{"ID": 1135, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String prependArgument(final String desc, final String type) { int ndx = desc.indexOf('('); ndx++; return desc.substring(0, ndx) + type + desc.substring(ndx); } \nResponse:", "ground_truth": "Prepends argument to the existing description.", "predict": " Prepend the argument type to the method descriptor. @param desc The method descriptor. @param type The argument type. @return The prepared descriptor.\n*/"}
{"ID": 1136, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String changeReturnType(final String desc, final String type) { int ndx = desc.indexOf(')'); return desc.substring(0, ndx + 1) + type; } \nResponse:", "ground_truth": "Changes return type.", "predict": " Change the return type of a method signature. @param desc The original descriptor. @param type The new return type. @return The modified descriptor.\n*/"}
{"ID": 1137, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void text(final CharSequence text) { if (!strip) { super.text(text); return; } int textLength = text.length(); char[] dest = new char[textLength]; int ndx = 0; boolean regularChar = true; for (int i = 0; i < textLength; i++) { char c = text.charAt(i); if (CharUtil.isWhitespace(c)) { if (regularChar) { regularChar = false; c = ' '; } else { continue; } } else { regularChar = true; } dest[ndx] = c; ndx++; } if (regularChar || (ndx != 1)) { super.text(CharBuffer.wrap(dest, 0, ndx)); strippedCharsCount += textLength - ndx; } else { strippedCharsCount += textLength; } } \nResponse:", "ground_truth": "Cleans unnecessary whitespaces.", "predict": " Stripped text. Stripped text is not passed to super implementation. Whitespaces are replaced with ordinary space character. Whitespaces at the beginning or at the end of text are also stripped. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Whitespaces at the beginning or at the end of text are also stripped. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whitespaces are replaced with ordinary space character. Stripped text is passed to super implementation. Whites"}
{"ID": 1138, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) { converters.put(type, typeConverter); } \nResponse:", "ground_truth": "Registers a converter for specified type.\nUser must register converter for all super-classes as well.\n\n@param type\t\tclass that converter is for\n@param typeConverter\tconverter for provided class", "predict": " Register a converter for a given type. @param type The type to register. @param typeConverter The converter to register.\n*/"}
{"ID": 1139, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> TypeConverter<T> lookup(final Class<T> type) { return converters.get(type); } \nResponse:", "ground_truth": "Retrieves converter for provided type. Only registered types are matched,\ntherefore subclasses must be also registered.\n\n@return founded converter or <code>null</code>", "predict": " Looks up a converter for the given type. @param type The type to lookup. @return The converter for the given type. Never null. May be a converter for other types. May be a converter for the given type itself."}
{"ID": 1140, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Node> select(final String query) { Collection<List<CssSelector>> selectorsCollection = CSSelly.parse(query); return select(selectorsCollection); } \nResponse:", "ground_truth": "Selects nodes using CSS3 selector query.", "predict": " Selects nodes matching the CSS query. @param query CSS query @return matching nodes\n*/"}
{"ID": 1141, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Node> select(final Collection<List<CssSelector>> selectorsCollection) { List<Node> results = new ArrayList<>(); for (List<CssSelector> selectors : selectorsCollection) { processSelectors(results, selectors); } return results; } \nResponse:", "ground_truth": "Selected nodes using pre-parsed CSS selectors. Take in consideration\ncollection type for results grouping order.", "predict": " Selects nodes from the document matching the given CSS selectors. @param selectorsCollection CSS selectors to match against the document. @return List of nodes matching the CSS selectors. Never null."}
{"ID": 1142, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void processSelectors(final List<Node> results, final List<CssSelector> selectors) { List<Node> selectedNodes = select(rootNode, selectors); for (Node selectedNode : selectedNodes) { if (!results.contains(selectedNode)) { results.add(selectedNode); } } } \nResponse:", "ground_truth": "Process selectors and keep adding results.", "predict": " Processes the selectors against the DOM tree rooted at the given node. @param results The list of nodes to which the selectors will be added. @param selectors The selectors to be processed."}
{"ID": 1143, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node selectFirst(final String query) { List<Node> selectedNodes = select(query); if (selectedNodes.isEmpty()) { return null; } return selectedNodes.get(0); } \nResponse:", "ground_truth": "Selects nodes using CSS3 selector query and returns the very first one.", "predict": " Selects the first node matching the supplied XPath query. Returns null if no matching nodes are found. @param query XPath query @return Node or null\n*/"}
{"ID": 1144, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void walkDescendantsIteratively(final LinkedList<Node> nodes, final CssSelector cssSelector, final List<Node> result) { while (!nodes.isEmpty()) { Node node = nodes.removeFirst(); selectAndAdd(node, cssSelector, result); // append children in walking order to be processed right after this node int childCount = node.getChildNodesCount(); for (int i = childCount - 1; i >= 0; i--) { nodes.addFirst(node.getChild(i)); } } } \nResponse:", "ground_truth": "Walks over the child notes, maintaining the tree order and not using recursion.", "predict": " Walks descendants iteratively. @param nodes the nodes to walk through @param cssSelector the selector to apply @param result the result list to add nodes to\n*/"}
{"ID": 1145, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void walk(final Node rootNode, final CssSelector cssSelector, final List<Node> result) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector.getPrevCssSelector(); Combinator combinator = previousCssSelector != null ? previousCssSelector.getCombinator() : Combinator.DESCENDANT; switch (combinator) { case DESCENDANT: LinkedList<Node> nodes = new LinkedList<>(); int childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { nodes.add(rootNode.getChild(i)); // recursive // selectAndAdd(node, cssSelector, result); // walk(node, cssSelector, result); } walkDescendantsIteratively(nodes, cssSelector, result); break; case CHILD: childCount = rootNode.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node node = rootNode.getChild(i); selectAndAdd(node, cssSelector, result); } break; case ADJACENT_SIBLING: Node node = rootNode.getNextSiblingElement(); if (node != null) { selectAndAdd(node, cssSelector, result); } break; case GENERAL_SIBLING: node = rootNode; while (true) { node = node.getNextSiblingElement(); if (node == null) { break; } selectAndAdd(node, cssSelector, result); } break; } } \nResponse:", "ground_truth": "Finds nodes in the tree that matches single selector.", "predict": " Walks through DOM tree using CSS selector recursively. @param rootNode root node of the DOM tree. @param cssSelector CSS selector to apply. @param result walking result."}
{"ID": 1146, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void selectAndAdd(final Node node, final CssSelector cssSelector, final List<Node> result) { // ignore all nodes that are not elements if (node.getNodeType() != Node.NodeType.ELEMENT) { return; } boolean matched = cssSelector.accept(node); if (matched) { // check for duplicates if (result.contains(node)) { return; } // no duplicate found, add it to the results result.add(node); } } \nResponse:", "ground_truth": "Selects single node for single selector and appends it to the results.", "predict": " Selects the given node and adds it to the result if it fulfills the selectors criterias. @param node The node to be tested. @param cssSelector The selector to be tested. @param result The list of nodes to be filled."}
{"ID": 1147, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean filter(final List<Node> currentResults, final Node node, final CssSelector cssSelector, final int index) { return cssSelector.accept(currentResults, node, index); } \nResponse:", "ground_truth": "Filter nodes.", "predict": " Filters the currentResults based on the cssSelector. @param currentResults The current results to filter. @param node The current node to evaluate. @param cssSelector The selector to evaluate. @param index The index of the current node in the currentResults. @return True if the currentResults should be included in the final results. False otherwise."}
{"ID": 1148, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static char [] zzUnpackCMap(final String packed) { char [] map = new char[0x110000]; int i = 0; /* index in packed string */ int j = 0; /* index in unpacked array */ while (i < 128) { int count = packed.charAt(i++); char value = packed.charAt(i++); do map[j++] = value; while (--count > 0); } return map; } \nResponse:", "ground_truth": "Unpacks the compressed character translation table.\n\n@param packed   the packed character translation table\n@return         the unpacked character translation table", "predict": " Packed char: 00000yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}
{"ID": 1149, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean zzRefill() { if (zzBuffer == null) { zzBuffer = zzChars; zzEndRead += zzChars.length; return false; } return true; } \nResponse:", "ground_truth": "Refills the input buffer.\n\n@return      <code>false</code>, iff there was new input.", "predict": " Attempts to read more data. Returns true if the buffer is now full."}
{"ID": 1150, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <T> PageData<T> page(String sql, final Map params, final int page, final int pageSize, final String sortColumnName, final boolean ascending, final Class[] target) { if (sortColumnName != null) { sql = buildOrderSql(sql, sortColumnName, ascending); } int from = (page - 1) * pageSize; String pageSql = buildPageSql(sql, from, pageSize); DbSqlBuilder dbsql = sql(pageSql); DbOomQuery query = query(dbsql); query.setMaxRows(pageSize); query.setFetchSize(pageSize); query.setMap(params); List<T> list = query.list(pageSize, target); query.close(); String countSql = buildCountSql(sql); dbsql = sql(countSql); query = query(dbsql); query.setMap(params); long count = query.executeCount(); query.close(); return new PageData<>(page, (int) count, pageSize, list); } \nResponse:", "ground_truth": "Pages given page.\n\n@param sql sql query that lists <b>all</b> items\n@param params map of SQL parameters\n@param page current page to show\n@param pageSize number of items to show\n@param sortColumnName name of sorting column, <code>null</code> for no sorting\n@param ascending <code>true</code> for ascending order\n@param target db entities for mapping (sa usual in DbOom)", "predict": " Execute SQL query and return page data. @param sql SQL query @param params Parameters map @param page Page number (1..) @param pageSize Page size (1..) @param sortColumnName Sort column name (@see SortType) @param ascending Ascending or descending sort (@see SortType) @param target Target types (optional) @return Page data\n<pre class=\"brush:java\"> PageData&lt;Customer&gt; customers = Db.query(\"select * from customer order by id asc\", Customer.class); </pre>"}
{"ID": 1151, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeSelect(String sql) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"select\"); if (ndx != -1) { sql = sql.substring(ndx + 6); // select.length() } return sql; } \nResponse:", "ground_truth": "Removes the first 'select' from the sql query.", "predict": " Strips the select keyword and any trailing comma from the SQL statement. Stripping the trailing comma has been known to cause problems in some cases thus this method will always strip any trailing comma. Additionally, Oracle doesn't treat a trailing comma as a statement terminator, thus dropping trailing comments when commenting out a statement ending with a trailing comma is preferable behavior than simply commenting out the trailing comma thereby retaining any trailing comment. Keeping the trailing comma also makes validation easier when executing against Oracle databases. Finally, some dialects such as Oracle actually treat whitespace differently when stripping a trailing comma thereby requiring that we treat all whitespace as insignificant unless we absolutely know it to be significant. Therefore, we strip any insignificant whitespace as well. Whitespace stripping versus stripping comments has been an Oracle-specific behavior that is unfortunately fragile. Hopefully, this will be fixed in a forthcoming release. Lastly, strip comments since they aren't actually part of the statement. @param sql The SQL statement to groom. @return The groomed SQL statement."}
{"ID": 1152, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeToFrom(String sql) { int from = 0; int fromCount = 1; int selectCount = 0; int lastNdx = 0; while (true) { int ndx = StringUtil.indexOfIgnoreCase(sql, \"from\", from); if (ndx == -1) { break; } // count selects in left part String left = sql.substring(lastNdx, ndx); selectCount += StringUtil.countIgnoreCase(left, \"select\"); if (fromCount >= selectCount) { sql = sql.substring(ndx); break; } // find next 'from' lastNdx = ndx; from = ndx + 4; fromCount++; } return sql; } \nResponse:", "ground_truth": "Removes the first part of the sql up to the relevant 'from'.\nTries to detect sub-queries in the 'select' part.", "predict": " Strips the leading and trailing \"'\" and \"'\" from the given SQL string. Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Does nothing if the string is empty. Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Does nothing if the string lacks \"'\"s. Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves \"'\" in place of \"\\'\" and \"'\" in place of \"\\'\"\\\". Leaves"}
{"ID": 1153, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String removeLastOrderBy(String sql) { int ndx = StringUtil.lastIndexOfIgnoreCase(sql, \"order by\"); if (ndx != -1) { int ndx2 = sql.lastIndexOf(sql, ')'); if (ndx > ndx2) { sql = sql.substring(0, ndx); } } return sql; } \nResponse:", "ground_truth": "Removes everything from last \"order by\".", "predict": " Remove ORDER BY clause from end of statement. Leaves parentheses intact. Leaves trailing LIMIT/OFFSET intact. @param sql Statement to analyze. @return Statement with ORDER BY removed."}
{"ID": 1154, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(final String html) { int ndx = html.indexOf('&'); if (ndx == -1) { return html; } StringBuilder result = new StringBuilder(html.length()); int lastIndex = 0; int len = html.length(); mainloop: while (ndx != -1) { result.append(html.substring(lastIndex, ndx)); lastIndex = ndx; while (html.charAt(lastIndex) != ';') { lastIndex++; if (lastIndex == len) { lastIndex = ndx; break mainloop; } } if (html.charAt(ndx + 1) == '#') { // decimal/hex char c = html.charAt(ndx + 2); int radix; if ((c == 'x') || (c == 'X')) { radix = 16; ndx += 3; } else { radix = 10; ndx += 2; } String number = html.substring(ndx, lastIndex); int i = Integer.parseInt(number, radix); result.append((char) i); lastIndex++; } else { // token String encodeToken = html.substring(ndx + 1, lastIndex); char[] replacement = ENTITY_MAP.get(encodeToken); if (replacement == null) { result.append('&'); lastIndex = ndx + 1; } else { result.append(replacement); lastIndex++; } } ndx = html.indexOf('&', lastIndex); } result.append(html.substring(lastIndex)); return result.toString(); } \nResponse:", "ground_truth": "Decodes HTML text. Assumes that all character references are properly closed with semi-colon.", "predict": " Decodes HTML entities in the given string. @param html the HTML string to decode. @return the decoded HTML string.\n*/"}
{"ID": 1155, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String detectName(final char[] input, int ndx) { final Ptr ptr = new Ptr(); int firstIndex = 0; int lastIndex = ENTITY_NAMES.length - 1; int len = input.length; char[] lastName = null; final BinarySearchBase binarySearch = new BinarySearchBase() { @Override protected int compare(final int index) { char[] name = ENTITY_NAMES[index]; if (ptr.offset >= name.length) { return -1; } return name[ptr.offset] - ptr.c; } }; while (true) { ptr.c = input[ndx]; if (!CharUtil.isAlphaOrDigit(ptr.c)) { return lastName != null ? new String(lastName) : null; } firstIndex = binarySearch.findFirst(firstIndex, lastIndex); if (firstIndex < 0) { return lastName != null ? new String(lastName) : null; } char[] element = ENTITY_NAMES[firstIndex]; if (element.length == ptr.offset + 1) { // total match, remember position, continue for finding the longer name lastName = ENTITY_NAMES[firstIndex]; } lastIndex = binarySearch.findLast(firstIndex, lastIndex); if (firstIndex == lastIndex) { // only one element found, check the rest for (int i = ptr.offset; i < element.length; i++) { if (element[i] != input[ndx]) { return lastName != null ? new String(lastName) : null; } ndx++; } return new String(element); } ptr.offset++; ndx++; if (ndx == len) { return lastName != null ? new String(lastName) : null; } } } \nResponse:", "ground_truth": "Detects the longest character reference name on given position in char array.", "predict": " Detect probable entity name. @param input the char array to be scanned, may be null. @param ndx the starting position in the array. @return the probable entity name, or null if none found."}
{"ID": 1156, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String buildOrderSql(String sql, final String column, final boolean ascending) { sql += \" order by \" + column; if (!ascending) { sql += \" desc\"; } return sql; } \nResponse:", "ground_truth": "Appends ORDER BY keyword.", "predict": " Build ORDER BY clause. @param sql ORDER BY clause. @param column ORDER BY column. @param ascending ascending or descending. @return ORDER BY clause."}
{"ID": 1157, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String buildPageSql(String sql, final int from, final int pageSize) { sql = removeSelect(sql); return \"select LIMIT \" + from + ' ' + pageSize + sql; } \nResponse:", "ground_truth": "Builds page sql using LIMIT keyword after the SELECT.", "predict": " Build pagination SQL. @param sql SQL string. @param from start index. @param pageSize page size. @return SQL string."}
{"ID": 1158, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void resolveColumnsAndProperties(final Class type) { PropertyDescriptor[] allProperties = ClassIntrospector.get().lookup(type).getAllPropertyDescriptors(); List<DbEntityColumnDescriptor> decList = new ArrayList<>(allProperties.length); int idcount = 0; HashSet<String> names = new HashSet<>(allProperties.length); for (PropertyDescriptor propertyDescriptor : allProperties) { DbEntityColumnDescriptor dec = DbMetaUtil.resolveColumnDescriptors(this, propertyDescriptor, isAnnotated, columnNamingStrategy); if (dec != null) { if (!names.add(dec.getColumnName())) { throw new DbOomException(\"Duplicate column name: \" + dec.getColumnName()); } decList.add(dec); if (dec.isId) { idcount++; } } } if (decList.isEmpty()) { throw new DbOomException(\"No column mappings in entity: \" + type); } columnDescriptors = decList.toArray(new DbEntityColumnDescriptor[0]); Arrays.sort(columnDescriptors); // extract ids from sorted list if (idcount > 0) { idColumnDescriptors = new DbEntityColumnDescriptor[idcount]; idcount = 0; for (DbEntityColumnDescriptor dec : columnDescriptors) { if (dec.isId) { idColumnDescriptors[idcount++] = dec; } } } } \nResponse:", "ground_truth": "Resolves list of all columns and properties.", "predict": " Extract column descriptors from all persistent fields and detect duplicates. Also detect primary key columns."}
{"ID": 1159, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityColumnDescriptor findByColumnName(final String columnName) { if (columnName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.columnName.equalsIgnoreCase(columnName)) { return columnDescriptor; } } return null; } \nResponse:", "ground_truth": "Finds column descriptor by column name. Case is ignored.", "predict": " Finds a column descriptor by its column name. @param columnName The column name. @return The column descriptor or null if not found."}
{"ID": 1160, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbEntityColumnDescriptor findByPropertyName(final String propertyName) { if (propertyName == null) { return null; } init(); for (DbEntityColumnDescriptor columnDescriptor : columnDescriptors) { if (columnDescriptor.propertyName.equals(propertyName)) { return columnDescriptor; } } return null; } \nResponse:", "ground_truth": "Finds column descriptor by property name.", "predict": " Finds the column descriptor by property name. @param propertyName the property name @return the column descriptor\n*/"}
{"ID": 1161, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPropertyName(final String columnName) { DbEntityColumnDescriptor dec = findByColumnName(columnName); return dec == null ? null : dec.propertyName; } \nResponse:", "ground_truth": "Returns property name for specified column name.", "predict": " Returns the property name for the given column name. May return null if the column name is not recognized. @param columnName The column name. @return The property name."}
{"ID": 1162, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getColumnName(final String propertyName) { DbEntityColumnDescriptor dec = findByPropertyName(propertyName); return dec == null ? null : dec.columnName; } \nResponse:", "ground_truth": "Returns column name for specified property name..", "predict": " Returns the column name for the given property name. May return null if the property is not mapped to a column. @param propertyName The property name. @return The column name."}
{"ID": 1163, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object getIdValue(final E object) { final String propertyName = getIdPropertyName(); return BeanUtil.declared.getProperty(object, propertyName); } \nResponse:", "ground_truth": "Returns ID value for given entity instance.", "predict": " Get the id value for the given object. @param object The object to inspect. @return The id value. Never null. May be an empty string. May be a non-existent property. May be a non-existent object. May be a null reference. May be a primitive wrapper. May be a complex object. May be a collection. May be an array. May be a Map. May be a Number. May be a String. May be a Boolean. May be a Date. May be a Calendar. May be a URL. May be a URI. May be a Locale. May be a Currency. May be a BigDecimal. May be a BigInteger. May be a byte[]. May be a char[]. May be a charSequence. May be a CharSequence. May be a byte[]. May be a char[]. May be a charSequence. May be a CharSequence. May be a byte[]. May be a char[]. May be a charSequence. May be a CharSequ"}
{"ID": 1164, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setIdValue(final E object, final Object value) { final String propertyName = getIdPropertyName(); BeanUtil.declared.setProperty(object, propertyName, value); } \nResponse:", "ground_truth": "Sets ID value for given entity.", "predict": " Set the id value on the target object. Useful for detached entities. @param object The target object. @param value The id value."}
{"ID": 1165, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getKeyValue(final E object) { Object idValue = getIdValue(object); String idValueString = idValue == null ? StringPool.NULL : idValue.toString(); return type.getName().concat(StringPool.COLON).concat(idValueString); } \nResponse:", "ground_truth": "Returns unique key for this entity. Returned key\nis built from entity class and id value.", "predict": " Generate the key value for the object. @param object The object to generate the key value for. @return The key value."}
{"ID": 1166, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public StringBand append(String s) { if (s == null) { s = StringPool.NULL; } if (index >= array.length) { expandCapacity(); } array[index++] = s; length += s.length(); return this; } \nResponse:", "ground_truth": "Appends a string.", "predict": " Appends a string to this band. The string will occupy space in the band. The band capacity is increased if necessary. The band length increases by the length of the string. @param s the string to append. @return this band.\n*/"}
{"ID": 1167, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setIndex(final int newIndex) { if (newIndex < 0) { throw new ArrayIndexOutOfBoundsException(newIndex); } if (newIndex > array.length) { String[] newArray = new String[newIndex]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } if (newIndex > index) { for (int i = index; i < newIndex; i++) { array[i] = StringPool.EMPTY; } } else if (newIndex < index) { for (int i = newIndex; i < index; i++) { array[i] = null; } } index = newIndex; length = calculateLength(); } \nResponse:", "ground_truth": "Specifies the new index.", "predict": " Sets the new length of the array. If the new length is smaller than the old, excess trailing elements are lost. If the new length is larger than the old, excess trailing elements are filled with nulls. @param newLength New length of the array.\n*/"}
{"ID": 1168, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void expandCapacity() { String[] newArray = new String[array.length << 1]; System.arraycopy(array, 0, newArray, 0, index); array = newArray; } \nResponse:", "ground_truth": "Expands internal string array by multiplying its size by 2.", "predict": " Expand capacity of internal storage array. Useful for large datasets (>100kB)\n*/"}
{"ID": 1169, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int calculateLength() { int len = 0; for (int i = 0; i < index; i++) { len += array[i].length(); } return len; } \nResponse:", "ground_truth": "Calculates string length.", "predict": " Calculate the length of the joined string.\n@return the length of the joined string\n*/"}
{"ID": 1170, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createMixingMessage(final BeanDefinition targetBeanDefinition, final BeanDefinition refBeanDefinition) { return \"Scopes mixing detected: \" + refBeanDefinition.name + \"@\" + refBeanDefinition.scope.getClass().getSimpleName() + \" -> \" + targetBeanDefinition.name + \"@\" + targetBeanDefinition.scope.getClass().getSimpleName(); } \nResponse:", "ground_truth": "Creates mixed scope message.", "predict": " Mixing detected between scopes. @param targetBeanDefinition the target bean definition @param refBeanDefinition the reference bean definition @return the string\n*/"}
{"ID": 1171, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object createScopedProxyBean(final PetiteContainer petiteContainer, final BeanDefinition refBeanDefinition) { Class beanType = refBeanDefinition.type; Class proxyClass = proxyClasses.get(beanType); if (proxyClass == null) { // create proxy class only once if (refBeanDefinition instanceof ProxettaBeanDefinition) { // special case, double proxy! ProxettaBeanDefinition pbd = (ProxettaBeanDefinition) refBeanDefinition; ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspects(ArraysUtil.insert(pbd.proxyAspects, aspect, 0)); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(pbd.originalTarget); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } else { ProxyProxetta proxetta = Proxetta.proxyProxetta().withAspect(aspect); proxetta.setClassNameSuffix(\"$ScopedProxy\"); proxetta.setVariableClassName(true); ProxyProxettaFactory builder = proxetta.proxy().setTarget(beanType); proxyClass = builder.define(); proxyClasses.put(beanType, proxyClass); } } Object proxy; try { proxy = ClassUtil.newInstance(proxyClass); Field field = proxyClass.getField(\"$__petiteContainer$0\"); field.set(proxy, petiteContainer); field = proxyClass.getField(\"$__name$0\"); field.set(proxy, refBeanDefinition.name); } catch (Exception ex) { throw new PetiteException(ex); } return proxy; } \nResponse:", "ground_truth": "Creates scoped proxy bean for given bean definition.", "predict": " Creates scoped proxy bean. @param petiteContainer Petite container. @param refBeanDefinition Ref bean definition. @return Scoped proxy bean."}
{"ID": 1172, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void loopBody() throws JspException { JspFragment body = getJspBody(); if (body == null) { return; } LoopIterator loopIterator = new LoopIterator(start, end, step, modulus); if (status != null) { getJspContext().setAttribute(status, loopIterator); } while (loopIterator.next()) { TagUtil.invokeBody(body); } if (status != null) { getJspContext().removeAttribute(status); } } \nResponse:", "ground_truth": "Loops body.", "predict": " Loops over the looping range evaluating the body for each iteration. The body is evaluated outside the loop so that modifications in the body that affect the loop are visible to the surrounding loop. @throws JspException if a JSP exception has occurred\n*/"}
{"ID": 1173, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void init() { File[] filesArray = dir.listFiles(); filesCount = 0; if (filesArray != null) { filesCount = filesArray.length; for (File file : filesArray) { if (!acceptFile(file)) { continue; } map.put(file, new MutableLong(file.lastModified())); } } } \nResponse:", "ground_truth": "Initializes dir watcher by reading all files\nfrom watched folder.", "predict": " Initializes the watcher."}
{"ID": 1174, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean acceptFile(final File file) { if (!file.isFile()) { return false; // ignore non-files } String fileName = file.getName(); if (ignoreDotFiles) { if (fileName.startsWith(StringPool.DOT)) { return false; // ignore hidden files } } if (patterns == null) { return true; } return Wildcard.matchOne(fileName, patterns) != -1; } \nResponse:", "ground_truth": "Accepts if a file is going to be watched.", "predict": " Accepts a file if it matches any of the configured ignores. @param file The file to check. @return True if the file matches any of the ignores."}
{"ID": 1175, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirWatcher useWatchFile(final String name) { watchFile = new File(dir, name); if (!watchFile.isFile() || !watchFile.exists()) { try { FileUtil.touch(watchFile); } catch (IOException ioex) { throw new DirWatcherException(\"Invalid watch file: \" + name, ioex); } } watchFileLastAccessTime = watchFile.lastModified(); return this; } \nResponse:", "ground_truth": "Enables usage of provided watch file.", "predict": " Specify the watch file to use. The watch file must exist and be a regular file. The watch file will be monitored for changes. @param name The name of the watch file. @return The watcher.\n*/"}
{"ID": 1176, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final long pollingInterval) { if (timer == null) { if (!startBlank) { init(); } timer = new Timer(true); timer.schedule(new WatchTask(), 0, pollingInterval); } } \nResponse:", "ground_truth": "Starts the watcher.", "predict": " Starts the polling timer. @param pollingInterval polling interval in milliseconds.\n*/"}
{"ID": 1177, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onChange(final DirWatcherEvent.Type type, final File file) { listeners.accept(new DirWatcherEvent(type, file)); } \nResponse:", "ground_truth": "Triggers listeners on file change.", "predict": " Notify listeners about changes. @param type Type of change. @param file File that was changed."}
{"ID": 1178, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Enumeration<T> enumeration) { if (allEnumerations.contains(enumeration)) { throw new IllegalArgumentException(\"Duplicate enumeration\"); } allEnumerations.add(enumeration); } \nResponse:", "ground_truth": "Adds an enumeration to this composite.", "predict": " Adds an enumeration to the set. Duplicate enumerations are not permitted. @param enumeration The enumeration to add. @throws IllegalArgumentException If the enumeration is already present.\n*/"}
{"ID": 1179, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int computeFieldInfoSize() { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { // ConstantValue attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE); size += 8; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && symbolTable.getMajorVersion() < Opcodes.V1_5) { // Synthetic attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.SYNTHETIC); size += 6; } if (signatureIndex != 0) { // Signature attributes always use 8 bytes. symbolTable.addConstantUtf8(Constants.SIGNATURE); size += 8; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { // Deprecated attributes always use 6 bytes. symbolTable.addConstantUtf8(Constants.DEPRECATED); size += 6; } if (lastRuntimeVisibleAnnotation != null) { size += lastRuntimeVisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_ANNOTATIONS); } if (lastRuntimeInvisibleAnnotation != null) { size += lastRuntimeInvisibleAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_ANNOTATIONS); } if (lastRuntimeVisibleTypeAnnotation != null) { size += lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS); } if (lastRuntimeInvisibleTypeAnnotation != null) { size += lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize( Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS); } if (firstAttribute != null) { size += firstAttribute.computeAttributesSize(symbolTable); } return size; } \nResponse:", "ground_truth": "Returns the size of the field_info JVMS structure generated by this FieldWriter. Also adds the\nnames of the attributes of this field in the constant pool.\n\n@return the size in bytes of the field_info JVMS structure.", "predict": " Computes the size of the attributes of this field. Also add the names of the attributes in the constant pool so that they can be referenced even if this field is stripped. @return the size of the attributes of this field plus the size of the name of each attribute in the constant pool plus one for the attribute_name_index field.\n"}
{"ID": 1180, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putFieldInfo(final ByteVector output) { boolean useSyntheticAttribute = symbolTable.getMajorVersion() < Opcodes.V1_5; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0; output.putShort(accessFlags & ~mask).putShort(nameIndex).putShort(descriptorIndex); // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0; if (constantValueIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { ++attributesCount; } if (signatureIndex != 0) { ++attributesCount; } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { ++attributesCount; } if (lastRuntimeVisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleAnnotation != null) { ++attributesCount; } if (lastRuntimeVisibleTypeAnnotation != null) { ++attributesCount; } if (lastRuntimeInvisibleTypeAnnotation != null) { ++attributesCount; } if (firstAttribute != null) { attributesCount += firstAttribute.getAttributeCount(); } output.putShort(attributesCount); // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if (constantValueIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE)) .putInt(2) .putShort(constantValueIndex); } if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0 && useSyntheticAttribute) { output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0); } if (signatureIndex != 0) { output .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE)) .putInt(2) .putShort(signatureIndex); } if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) { output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0); } if (lastRuntimeVisibleAnnotation != null) { lastRuntimeVisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output); } if (lastRuntimeInvisibleAnnotation != null) { lastRuntimeInvisibleAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output); } if (lastRuntimeVisibleTypeAnnotation != null) { lastRuntimeVisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output); } if (lastRuntimeInvisibleTypeAnnotation != null) { lastRuntimeInvisibleTypeAnnotation.putAnnotations( symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output); } if (firstAttribute != null) { firstAttribute.putAttributes(symbolTable, output); } } \nResponse:", "ground_truth": "Puts the content of the field_info JVMS structure generated by this FieldWriter into the given\nByteVector.\n\n@param output where the field_info structure must be put.", "predict": " Puts the content of the field_info JVMS structure generated by this FieldWriter into the given byte vector."}
{"ID": 1181, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Target ofValue(final Object value, final ScopeData scopeData) { return new Target(value, null, scopeData, null, VALUE_INSTANCE_CREATOR); } \nResponse:", "ground_truth": "Creates a common target over a value, with known scope data.", "predict": " Factory method to create a Target targeting a constant value. @param value the constant value. @param scopeData the scope data. @return the Target targeting the constant value.\n*/"}
{"ID": 1182, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeValue(final InjectionPoint injectionPoint, final Object propertyValue, final boolean silent) { writeValue(injectionPoint.targetName(), propertyValue, silent); } \nResponse:", "ground_truth": "Writes value to this target. Depending on a flag, writing the value can be\ncompletely silent, when no exception is thrown and with top performances.\nOtherwise, an exception is thrown on a failure.", "predict": " Write the value of the injection point. @param injectionPoint the injection point to write @param propertyValue the value to write @param silent ignored\n*/"}
{"ID": 1183, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void decorate(final Writer writer, final char[] pageContent, final char[] decoraContent) throws IOException { DecoraTag[] decoraTags = parseDecorator(decoraContent); parsePage(pageContent, decoraTags); writeDecoratedPage(writer, decoraContent, pageContent, decoraTags); } \nResponse:", "ground_truth": "Decorates page content with decorator template and outputs the result.", "predict": " Decorate the page content with the decorator content. @param writer Writer to write the decorated page content. @param pageContent Content of the page. @param decoraContent Decorator content. @throws IOException Something wrong happened."}
{"ID": 1184, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void parsePage(final char[] pageContent, final DecoraTag[] decoraTags) { LagartoParser lagartoParser = new LagartoParser(pageContent); PageRegionExtractor writer = new PageRegionExtractor(decoraTags); lagartoParser.parse(writer); } \nResponse:", "ground_truth": "Parses target page and extracts Decora regions for replacements.", "predict": " Parse page content. @param pageContent Page content. @param decoraTags Tags extracted from page."}
{"ID": 1185, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void writeDecoratedPage(final Writer out, final char[] decoratorContent, final char[] pageContent, final DecoraTag[] decoraTags) throws IOException { int ndx = 0; for (DecoraTag decoraTag : decoraTags) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag.getStartIndex() - ndx; if (decoratorLen <= 0) { continue; } out.write(decoratorContent, ndx, decoratorLen); ndx = decoraTag.getEndIndex(); // [2] now write region at the place of Decora tag int regionLen = decoraTag.getRegionLength(); if (regionLen == 0) { if (decoraTag.hasDefaultValue()) { out.write(decoratorContent, decoraTag.getDefaultValueStart(), decoraTag.getDefaultValueLength()); } } else { writeRegion(out, pageContent, decoraTag, decoraTags); } } // write remaining content out.write(decoratorContent, ndx, decoratorContent.length - ndx); } \nResponse:", "ground_truth": "Writes decorated content.", "predict": " Write decorator tags and page content. Decorator tags are written before page content. Decorator tags are written in the order they are defined in the Decora tag array. Page content is written after all decorator tags. @param out Writer to write to. @param decoratorContent Decorator content. @param pageContent Page content. @param decoraTags Decora tags. @throws IOException Writing failed."}
{"ID": 1186, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void writeRegion(final Writer out, final char[] pageContent, final DecoraTag decoraTag, final DecoraTag[] decoraTags) throws IOException { int regionStart = decoraTag.getRegionStart(); int regionLen = decoraTag.getRegionLength(); int regionEnd = regionStart + regionLen; for (DecoraTag innerDecoraTag : decoraTags) { if (decoraTag == innerDecoraTag) { continue; } if (decoraTag.isRegionUndefined()) { continue; } if (innerDecoraTag.isInsideOtherTagRegion(decoraTag)) { // write everything from region start to the inner Decora tag out.write(pageContent, regionStart, innerDecoraTag.getRegionTagStart() - regionStart); regionStart = innerDecoraTag.getRegionTagEnd(); } } // write remaining content of the region out.write(pageContent, regionStart, regionEnd - regionStart); } \nResponse:", "ground_truth": "Writes region to output, but extracts all inner regions.", "predict": " Write out everything inside the region. @param out Writer to write to. @param pageContent Page content. @param decoraTag Decora tag. @param decoraTags Other Decora tags. @throws IOException On Writer error."}
{"ID": 1187, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() throws IOException { serverSocket = new ServerSocket(listenPort, socketBacklog); serverSocket.setReuseAddress(true); executorService = Executors.newFixedThreadPool(threadPoolSize); running = true; while (running) { Socket socket = serverSocket.accept(); socket.setKeepAlive(false); executorService.execute(onSocketConnection(socket)); } executorService.shutdown(); } \nResponse:", "ground_truth": "Starts HTTP tunnel. Method ends when the tunnel is stopped.", "predict": " Starts the server listening for incoming connections. Blocks until interrupted. @throws IOException If unable to listen on the socket.\n*/"}
{"ID": 1188, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ProcessResult run(final Process process) throws InterruptedException { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX); final StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX); outputGobbler.start(); errorGobbler.start(); final int result = process.waitFor(); outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessResult(result, baos.toString()); } \nResponse:", "ground_truth": "Executes a process and returns the process output and exit code.", "predict": " Runs the given process and waits for it to finish. The streams are redirected to a ByteArrayOutputStream. The output is printed to STDOUT and STDERR. The process is killed if it takes longer than KILL_TIMEOUT. @param process The process to run. @return The result of the process. @throws InterruptedException If interrupted while waiting for the process to finish.\n*/\npublic static ProcessResult run(final Process process) throws InterruptedException {\n\tfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\tfinal StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), baos, OUTPUT_PREFIX);\n\tfinal StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), baos, ERROR_PREFIX);\n\toutputGobbler.start();\n\terrorGobbler.start();\n\tfinal int result = process.waitFor();\n\toutputGobbler."}
{"ID": 1189, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected IMAPSSLStore getStore(final Session session) { SimpleAuthenticator simpleAuthenticator = (SimpleAuthenticator) authenticator; final URLName url; if (simpleAuthenticator == null) { url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, null, null); } else { final PasswordAuthentication pa = simpleAuthenticator.getPasswordAuthentication(); url = new URLName( PROTOCOL_IMAP, host, port, StringPool.EMPTY, pa.getUserName(), pa.getPassword()); } return new IMAPSSLStore(session, url); } \nResponse:", "ground_truth": "Returns email store.\n\n@param session {@link Session}\n@return {@link com.sun.mail.imap.IMAPSSLStore}", "predict": " Overridden to provide IMAPSSLStore. @param session Store session. @return IMAPSSLStore."}
{"ID": 1190, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ServletOutputStream createOutputStream() throws IOException { GzipResponseStream gzstream = new GzipResponseStream(origResponse); gzstream.setBuffer(threshold); return gzstream; } \nResponse:", "ground_truth": "Creates and returns a ServletOutputStream to write the content associated\nwith this Response.", "predict": " Used to wrap ServletOutputStream avoiding double buffering. Makes no guarantees about synchronization. Ideally only one thread will be writing. @return Underlying ServletOutputStream\n*/"}
{"ID": 1191, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final TemplateData templateData) { super.init(templateData); if (hint != null) { templateData.incrementHintsCount(); } } \nResponse:", "ground_truth": "Counts actual real hints.", "predict": " Initializes the hint. Increases the hints count. @param templateData TemplateData for hint rendering."}
{"ID": 1192, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendAlias(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { final ColumnAliasType columnAliasType = templateData.getColumnAliasType(); if (columnAliasType == null || columnAliasType == ColumnAliasType.TABLE_REFERENCE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnNameForQuery(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(columnName); } else if (columnAliasType == ColumnAliasType.COLUMN_CODE) { final String tableName = ded.getTableName(); final String columnName = dec.getColumnName(); final String code = templateData.registerColumnDataForColumnCode(tableName, columnName); query.append(code); } else if (columnAliasType == ColumnAliasType.TABLE_NAME) { final String tableName = ded.getTableNameForQuery(); final String columnName = dec.getColumnNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(columnName); } } \nResponse:", "ground_truth": "Appends alias.", "predict": " Append alias for the column. @param query SQL query builder. @param ded Associated entity descriptor. @param dec Associated column descriptor. */"}
{"ID": 1193, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendColumnName(final StringBuilder query, final DbEntityDescriptor ded, final DbEntityColumnDescriptor dec) { query.append(resolveTable(tableRef, ded)).append('.').append(dec.getColumnName()); if (templateData.getColumnAliasType() != null) { // create column aliases query.append(AS); switch (templateData.getColumnAliasType()) { case TABLE_NAME: { final String tableName = ded.getTableNameForQuery(); query.append(tableName).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case TABLE_REFERENCE: { final String tableName = ded.getTableName(); templateData.registerColumnDataForTableRef(tableRef, tableName); query.append(tableRef).append(columnAliasSeparator).append(dec.getColumnNameForQuery()); break; } case COLUMN_CODE: { final String tableName = ded.getTableName(); final String code = templateData.registerColumnDataForColumnCode(tableName, dec.getColumnName()); query.append(code); break; } } } } \nResponse:", "ground_truth": "Simply appends column name with optional table reference and alias.", "predict": " Append column name to query. @param query query to append to. @param ded ded. @param dec dec.\n*/"}
{"ID": 1194, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addRule(final D ruleDefinition, final boolean include) { if (rules == null) { rules = new ArrayList<>(); } if (include) { includesCount++; } else { excludesCount++; } Rule<R> newRule = new Rule<>(makeRule(ruleDefinition), include); if (rules.contains(newRule)) { return; } rules.add(newRule); } \nResponse:", "ground_truth": "Adds a rule. Duplicates are not allowed and will be ignored.", "predict": " Adds a rule to the current configuration. Rules are evaluated in the order they are added. Duplicate additions are ignored. @param ruleDefinition The rule definition. @param include Whether or not to include this rule. Defaults to true."}
{"ID": 1195, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean apply(final V value, final boolean blacklist, boolean flag) { if (rules == null) { return flag; } if (blacklist) { flag = processExcludes(value, flag); flag = processIncludes(value, flag); } else { flag = processIncludes(value, flag); flag = processExcludes(value, flag); } return flag; } \nResponse:", "ground_truth": "Applies rules on given flag. Flag is only changed if at least one rule\nmatched. Otherwise, the same value is returned. This way you can\nchain several rules and have the rule engine change the flag\nonly when a rule is matched.", "predict": " Apply blacklist and whitelist filtering rules to the given value. @param value The value to evaluate. @param blacklist True if the value should be evaluated against the blacklist rules, false if evaluating against whitelist rules. @param flag True if the value should be included, false if excluded. @return True if the value should be included, false if excluded."}
{"ID": 1196, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean processIncludes(final V value, boolean include) { if (includesCount > 0) { if (!include) { for (Rule<R> rule : rules) { if (!rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, true)) { include = true; break; } } } } return include; } \nResponse:", "ground_truth": "Process includes rules.", "predict": " Process includes. @param value Value @param include Include flag @return True if accepted\n*/"}
{"ID": 1197, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean processExcludes(final V value, boolean include) { if (excludesCount > 0) { if (include) { for (Rule<R> rule : rules) { if (rule.include) { continue; } if (inExRuleMatcher.accept(value, rule.value, false)) { include = false; break; } } } } return include; } \nResponse:", "ground_truth": "Process excludes rules.", "predict": " Process excludes. @param value Value. @param include Include flag. @return True if passes excludes."}
{"ID": 1198, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPseudoClassName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; } \nResponse:", "ground_truth": "Returns pseudo-class name from simple class name.", "predict": " Pseudo-class name of this component. @return Pseudo-class name of this component."}
{"ID": 1199, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean addAll(final Collection<? extends E> c) { Iterator<? extends E> i = c.iterator(); boolean changed = false; while (i.hasNext()) { boolean ret = add(i.next()); if (!changed) { changed = ret; } } return changed; } \nResponse:", "ground_truth": "Add all of the elements in the given collection to this list.", "predict": " Add all elements of c to this bag.\n@param c Bag whose elements are to be added to this bag.\n@return True if this bag changed as a result of the call.\n*/"}
{"ID": 1200, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int findInsertionPoint(final E o, int low, int high) { while (low <= high) { int mid = (low + high) >>> 1; int delta = compare(get(mid), o); if (delta > 0) { high = mid - 1; } else { low = mid + 1; } } return low; } \nResponse:", "ground_truth": "Conducts a binary search to find the index where Object\nshould be inserted.", "predict": " Binary search for insertion point. The returned insertion point fulfills the invariant low <= insertionPoint <= high. The invariant is preserved iff the input argument o is contained in the set. The worst-case complexity is O(log(high - low)). @param o the object to search for. @param low the lowest index to consider. @param high the highest index to consider. @return the insertion point.\n*/"}
{"ID": 1201, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void bindAnnotationConfig(final Class<? extends Annotation> annotationType, final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig actionConfig = registerNewActionConfiguration(actionConfigClass); actionConfigs.put(annotationType, actionConfig); for (final AnnotationParser annotationParser : annotationParsers) { if (annotationType.equals(annotationParser.getAnnotationType())) { // parser already exists return; } } annotationParsers = ArraysUtil.append(annotationParsers, new AnnotationParser(annotationType, Action.class)); } \nResponse:", "ground_truth": "Binds action annotation and the action config. This can overwrite the default annotation\nconfiguration of an annotation.", "predict": " Binds an annotation to an action config. Useful for injecting action configs into action classes. @param annotationType The annotation type to bind. @param actionConfigClass The action config class to bind."}
{"ID": 1202, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionConfig registerNewActionConfiguration(final Class<? extends ActionConfig> actionConfigClass) { final ActionConfig newActionConfig = createActionConfig(actionConfigClass); actionConfigs.put(actionConfigClass, newActionConfig); return newActionConfig; } \nResponse:", "ground_truth": "Registers action configuration for given type.", "predict": " Register a new ActionConfig. @param actionConfigClass The ActionConfig class to register. @return The newly created ActionConfig.\n*/"}
{"ID": 1203, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionConfig lookup(final Class actionTypeOrAnnotationType) { final ActionConfig actionConfig = actionConfigs.get(actionTypeOrAnnotationType); if (actionConfig == null) { throw new MadvocException(\"ActionConfiguration not registered:\" + actionTypeOrAnnotationType.getName()); } return actionConfig; } \nResponse:", "ground_truth": "Lookup for the action configuration. Typically, the input argument is either the action type or annotation type.", "predict": " Lookup action configuration by action type or annotation type. @param actionTypeOrAnnotationType Action type or annotation type. @return Action configuration or <code>null</code> if not found."}
{"ID": 1204, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T extends ActionConfig> void with(final Class<T> actionConfigType, final Consumer<T> actionConfigConsumer) { final T actionConfig = (T) lookup(actionConfigType); actionConfigConsumer.accept(actionConfig); } \nResponse:", "ground_truth": "Fetch some action config and consumes it.", "predict": " Looks up and applies the action config of the given type. Then applies the consumer to it. Useful for injecting dependencies into action configs. @param actionConfigType The type of action config to look up. @param actionConfigConsumer The consumer to apply to the action config."}
{"ID": 1205, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static void setupSystemMailProperties() { System.setProperty(\"mail.mime.encodefilename\", Boolean.valueOf(Defaults.mailMimeEncodefilename).toString()); System.setProperty(\"mail.mime.decodefilename\", Boolean.valueOf(Defaults.mailMimeDecodefilename).toString()); } \nResponse:", "ground_truth": "Setups the system email properties.", "predict": " Setup mail system properties. Especially useful for debugging mail issues.\n*/"}
{"ID": 1206, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void validateWithin(final ValidationContext vctx, final Object value) { vtor.validate(vctx, value, name); } \nResponse:", "ground_truth": "Validates provided context and value withing this constraint content.", "predict": " Validate that the value falls within the specified inclusive range. @param vctx validation context @param value proposed value to validate against the range inclusive @throws VTorException if the value falls outside the inclusive range\n*/"}
{"ID": 1207, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Element findLastTable(final Node node) { Node tableNode = node; while (tableNode != null) { if (tableNode.getNodeType() == Node.NodeType.ELEMENT) { String tableNodeName = tableNode.getNodeName().toLowerCase(); if (tableNodeName.equals(\"table\")) { break; } } tableNode = tableNode.getParentNode(); } return (Element) tableNode; } \nResponse:", "ground_truth": "Finds the last table in stack of open elements.", "predict": " Finds the last table element in the DOM. Useful for finding the end of a table row. @param node The node to start searching from. @return The last table element found."}
{"ID": 1208, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void fixElements() { for (Element fosterElement : fosterElements) { // find parent table Element lastTable = findLastTable(fosterElement); Node fosterElementParent = fosterElement.getParentNode(); // filter our foster element Node[] fosterChilds = fosterElement.getChildNodes(); for (Node fosterChild : fosterChilds) { if (fosterChild.getNodeType() == Node.NodeType.ELEMENT) { if (isOneOfTableElements((Element) fosterChild)) { // move all child table elements outside // the foster element fosterChild.detachFromParent(); fosterElementParent.insertBefore(fosterChild, fosterElement); } } } // finally, move foster element above the table fosterElement.detachFromParent(); lastTable.getParentNode().insertBefore(fosterElement, lastTable); } } \nResponse:", "ground_truth": "Performs the fix for elements.", "predict": " Fixes foster parenting in tables. Moves foster elements outside tables. Necessary for IE8 standards compliance.\n*/"}
{"ID": 1209, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Map<String, BeanData> registerSessionBeans(final HttpSession httpSession) { SessionBeans sessionBeans = new SessionBeans(); httpSession.setAttribute(SESSION_BEANS_NAME, sessionBeans); return sessionBeans.getBeanMap(); } \nResponse:", "ground_truth": "Registers new session destroy callback if not already registered.", "predict": " Register session beans. @param httpSession HttpSession @return Map<String, BeanData>"}
{"ID": 1210, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Map<String, BeanData> getSessionMap(final HttpSession session) { SessionBeans sessionBeans = (SessionBeans) session.getAttribute(SESSION_BEANS_NAME); if (sessionBeans == null) { return null; } return sessionBeans.getBeanMap(); } \nResponse:", "ground_truth": "Returns instance map from http session.", "predict": " Get session map from session. @param session HttpSession @return Session Map"}
{"ID": 1211, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void init(String name, final String superName, final String suffix, final String reqProxyClassName) { int lastSlash = name.lastIndexOf('/'); this.targetPackage = lastSlash == -1 ? StringPool.EMPTY : name.substring(0, lastSlash).replace('/', '.'); this.targetClassname = name.substring(lastSlash + 1); this.nextSupername = superName; this.superName = name; // create proxy name if (reqProxyClassName != null) { if (reqProxyClassName.startsWith(DOT)) { name = name.substring(0, lastSlash) + '/' + reqProxyClassName.substring(1); } else if (reqProxyClassName.endsWith(DOT)) { name = reqProxyClassName.replace('.', '/') + this.targetClassname; } else { name = reqProxyClassName.replace('.', '/'); } } // add optional suffix if (suffix != null) { name += suffix; } this.thisReference = name; this.superReference = this.superName; } \nResponse:", "ground_truth": "Work data initialization.", "predict": " Initilize the proxy class name. @param name Fully qualified name of the proxy class. @param superName Fully qualified name of the superclass. @param suffix Optional suffix. @param reqProxyClassName Required proxy class name."}
{"ID": 1212, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void addAdviceInitMethod(final String name) { if (adviceInits == null) { adviceInits = new ArrayList<>(); } adviceInits.add(name); } \nResponse:", "ground_truth": "Saves used constructors of advices.", "predict": " Advice init method names. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init methods are invoked before advice classes are initialized. Advice init"}
{"ID": 1213, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void end() { if (newAction) { bundleId = bundlesManager.registerBundle(contextPath, actionPath, bundleId, bundleContentType, sources); } } \nResponse:", "ground_truth": "Called on end of parsing.", "predict": " Ends the bundle lifecycle.\n*/"}
{"ID": 1214, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void add( final String section, final String key, final StringBuilder value, final boolean trim, final Operator operator) { // ignore lines without : or = if (key == null) { return; } String fullKey = key; if (section != null) { if (fullKey.length() != 0) { fullKey = section + '.' + fullKey; } else { fullKey = section; } } String v = value.toString(); if (trim) { if (valueTrimLeft && valueTrimRight) { v = v.trim(); } else if (valueTrimLeft) { v = StringUtil.trimLeft(v); } else { v = StringUtil.trimRight(v); } } if (v.length() == 0 && skipEmptyProps) { return; } extractProfilesAndAdd(fullKey, v, operator); } \nResponse:", "ground_truth": "Adds accumulated value to key and current section.", "predict": " Adds a property to the current configuration. Lines starting with # or! are treated as comments and ignored. Valid options are NAME=VALUE and NAME+=VALUE. NAME+=VALUE is a shortcut for NAME=VALUE+=VALUE. Comments after the NAME are ignored. This makes it easy to declare multiple properties in a single line: -Dname1=value1 -Dname2=value2 -Dname3=value3=value3 -Dname4+=value4 @param section the section to add to - may be null\n * @param key the name of the property\n * @param value the value of the property\n * @param trim trim trailing whitespaces from values\n * @param operator logical connective between values (AND/OR)\n */"}
{"ID": 1215, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void extractProfilesAndAdd(final String key, final String value, final Operator operator) { String fullKey = key; int ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { justAdd(fullKey, value, null, operator); return; } // extract profiles ArrayList<String> keyProfiles = new ArrayList<>(); while (true) { ndx = fullKey.indexOf(PROFILE_LEFT); if (ndx == -1) { break; } final int len = fullKey.length(); int ndx2 = fullKey.indexOf(PROFILE_RIGHT, ndx + 1); if (ndx2 == -1) { ndx2 = len; } // remember profile final String profile = fullKey.substring(ndx + 1, ndx2); keyProfiles.add(profile); // extract profile from key ndx2++; final String right = (ndx2 == len) ? StringPool.EMPTY : fullKey.substring(ndx2); fullKey = fullKey.substring(0, ndx) + right; } if (fullKey.startsWith(StringPool.DOT)) { // check for special case when only profile is defined in section fullKey = fullKey.substring(1); } // add value to extracted profiles justAdd(fullKey, value, keyProfiles, operator); } \nResponse:", "ground_truth": "Extracts profiles from the key name and adds key-value to them.", "predict": " Extract profiles and add. @param key the key\n * @param value the value\n * @param operator the operator\n */"}
{"ID": 1216, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void justAdd(final String key, final String value, final ArrayList<String> keyProfiles, final Operator operator) { if (operator == Operator.COPY) { HashMap<String,Object> target = new HashMap<>(); String[] profiles = null; if (keyProfiles != null) { profiles = keyProfiles.toArray(new String[0]); } String[] sources = StringUtil.splitc(value, ','); for (String source : sources) { source = source.trim(); // try to extract profile for parsing String[] lookupProfiles = profiles; String lookupProfilesString = null; int leftIndex = source.indexOf('<'); if (leftIndex != -1) { int rightIndex = source.indexOf('>'); lookupProfilesString = source.substring(leftIndex + 1, rightIndex); source = source.substring(0, leftIndex).concat(source.substring(rightIndex + 1)); lookupProfiles = StringUtil.splitc(lookupProfilesString, ','); StringUtil.trimAll(lookupProfiles); } String[] wildcards = new String[] {source + \".*\"}; propsData.extract(target, lookupProfiles, wildcards, null); for (Map.Entry<String, Object> entry : target.entrySet()) { String entryKey = entry.getKey(); String suffix = entryKey.substring(source.length()); String newKey = key + suffix; String newValue = \"${\" + entryKey; if (lookupProfilesString != null) { newValue += \"<\" + lookupProfilesString + \">\"; } newValue += \"}\"; if (profiles == null) { propsData.putBaseProperty(newKey, newValue, false); } else { for (final String p : profiles) { propsData.putProfileProperty(newKey, newValue, p, false); } } } } return; } boolean append = operator == Operator.QUICK_APPEND; if (keyProfiles == null) { propsData.putBaseProperty(key, value, append); return; } for (final String p : keyProfiles) { propsData.putProfileProperty(key, value, p, append); } } \nResponse:", "ground_truth": "Core key-value addition.", "predict": " Just add a property, don't touch profiles.\n */"}
{"ID": 1217, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typedesc2ClassName(final String desc) { String className = desc; switch (desc.charAt(0)) { case 'B': case 'C': case 'D': case 'F': case 'I': case 'J': case 'S': case 'Z': case 'V': if (desc.length() != 1) { throw new IllegalArgumentException(INVALID_BASE_TYPE + desc); } break; case 'L': className = className.substring(1, className.length() - 1); break; case '[': // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. className = className.replace('/', '.'); break; default: throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } return className; } \nResponse:", "ground_truth": "Converts bytecode-like description to java class name that can be loaded\nwith a classloader. Uses less-known feature of class loaders for loading\narray classes.\n\n@see #typedescToSignature(String, jodd.mutable.MutableInteger)", "predict": " Translates a type descriptor to a Java class name. For example, \"[I\" becomes \"java.lang.Integer\". Primitive types are represented by their name, not their signature. This method does not recognize type signatures, but does recognize unambiguous type descriptors involving primitive types or references to primitive types or to arrays of primitive types. Thus, this method may be used to determine the runtime type of an argument whose type signature is not known. However, its use is discouraged in most cases, since it does not precisely reflect the type signature of the actual argument passed in. Especially when passing primitive types or their arrays, this method might fail to identify the actual argument type. However, it might identify the correct array type instead of the correct primitive type when the argument type signature is ambiguous (e.g., \"[[I\"). @param desc the type descriptor to interpret @return the corresponding Java class name"}
{"ID": 1218, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typeref2Name(final String desc) { if (desc.charAt(0) != TYPE_REFERENCE) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } String name = desc.substring(1, desc.length() - 1); return name.replace('/', '.'); } \nResponse:", "ground_truth": "Converts type reference to java-name.", "predict": " Translates a type reference in the Java programming language (\"I\") into the corresponding name in this API (\"Ljava/lang/Object;\"). See http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.19. Example: \"I\" translates to \"Ljava/lang/Object;\""}
{"ID": 1219, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typedescToSignature(final String desc, final MutableInteger from) { int fromIndex = from.get(); from.value++; // default usage for most cases switch (desc.charAt(fromIndex)) { case 'B': return \"byte\"; case 'C': return \"char\"; case 'D': return \"double\"; case 'F': return \"float\"; case 'I': return \"int\"; case 'J': return \"long\"; case 'S': return \"short\"; case 'Z': return \"boolean\"; case 'V': return \"void\"; case 'L': int index = desc.indexOf(';', fromIndex); if (index < 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } from.set(index + 1); String str = desc.substring(fromIndex + 1, index); return str.replace('/', '.'); case 'T': return desc.substring(from.value); case '[': StringBuilder brackets = new StringBuilder(); int n = fromIndex; while (desc.charAt(n) == '[') { // count opening brackets brackets.append(\"[]\"); n++; } from.value = n; String type = typedescToSignature(desc, from); // the rest of the string denotes a `<field_type>' return type + brackets; default: if (from.value == 0) { throw new IllegalArgumentException(INVALID_TYPE_DESCRIPTION + desc); } // generics! return desc.substring(from.value); } } \nResponse:", "ground_truth": "Returns java-like signature of a bytecode-like description.\nOnly first description is parsed.\n\nThe field signature represents the value of an argument to a function or\nthe value of a variable. It is a series of bytes generated by the\nfollowing grammar:\n\n<PRE>{@code\n<field_signature> ::= <field_type>\n<field_type>      ::= <base_type>|<object_type>|<array_type>\n<base_type>       ::= B|C|D|F|I|J|S|Z\n<object_type>     ::= L<fullclassname>;\n<array_type>      ::= [<field_type>\n\nThe meaning of the base types is as follows:\nB byte signed byte\nC char character\nD double double precision IEEE float\nF float single precision IEEE float\nI int integer\nJ long long integer\nL<fullclassname>; ... an object of the given class\nS short signed short\nZ boolean true or false\n[<field sig> ... array\n}</PRE>\n\nThis method converts this string into a Java type declaration such as\n<code>String[]</code>.", "predict": " Convert a type descriptor to a signature. The signature is either a fully qualified class name or a fully qualified method name.\nThe signature is stripped of any leading asterisk and prepended with a dollar ($).\nThe signature is stripped of any trailing asterisk and postioned between opening and closing parentheses.\nThe parentheses are stripped of any trailing asterisk and positioned between opening and closing angle brackets.\nThe brackets are stripped of any trailing asterisk and positioned between opening and closing curly braces.\nThe curly braces are stripped of any trailing asterisk and positioned between opening and closing square brackets.\nThe square brackets are stripped of any trailing asterisk and positioned between opening and closing angle brackets.\nThe angle brackets are stripped of any trailing asterisk and positioned between opening and closing square brackets.\nThe square brackets are stripped of any trailing asterisk and positioned between opening and closing curly braces.\nThe curly braces are stripped of any trailing asterisk and positioned between opening and closing parentheses.\nThe parentheses are stripped of any trailing asterisk and positioned between opening and closing angle brackets"}
{"ID": 1220, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String typeToTyperef(final Class type) { if (!type.isArray()) { if (!type.isPrimitive()) { return 'L' + typeToSignature(type) + ';'; } if (type == int.class) { return \"I\"; } if (type == long.class) { return \"J\"; } if (type == boolean.class) { return \"Z\"; } if (type == double.class) { return \"D\"; } if (type == float.class) { return \"F\"; } if (type == short.class) { return \"S\"; } if (type == void.class) { return \"V\"; } if (type == byte.class) { return \"B\"; } if (type == char.class) { return \"C\"; } } return type.getName(); } \nResponse:", "ground_truth": "Converts type to byteccode type ref.", "predict": " Convert primitive types to signatures. @param type Primitive type. @return Signature.\n*/"}
{"ID": 1221, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Consumers<T> addAll(final Consumer<T>... consumers) { Collections.addAll(consumerList, consumers); return this; } \nResponse:", "ground_truth": "Registers additional consumers.", "predict": " Adds consumers to the consumers list. @param consumers Consumers to add. @return Fluent API."}
{"ID": 1222, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Collection<T> createCollection(final int length) { if (collectionType.isInterface()) { if (collectionType == List.class) { if (length > 0) { return new ArrayList<>(length); } else { return new ArrayList<>(); } } if (collectionType == Set.class) { if (length > 0) { return new HashSet<>(length); } else { return new HashSet<>(); } } throw new TypeConversionException(\"Unknown collection: \" + collectionType.getName()); } if (length > 0) { try { Constructor<Collection<T>> ctor = (Constructor<Collection<T>>) collectionType.getConstructor(int.class); return ctor.newInstance(Integer.valueOf(length)); } catch (Exception ex) { // ignore exception } } try { return collectionType.getDeclaredConstructor().newInstance(); } catch (Exception ex) { throw new TypeConversionException(ex); } } \nResponse:", "ground_truth": "Creates new collection of target component type.\nDefault implementation uses reflection to create\nan collection of target type. Override it for better performances.", "predict": " Create a collection of the specified length. @param length The length of the collection. @return The collection.\n*/"}
{"ID": 1223, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertToSingleElementCollection(final Object value) { Collection<T> collection = createCollection(0); //noinspection unchecked collection.add((T) value); return collection; } \nResponse:", "ground_truth": "Creates a collection with single element.", "predict": " Convert the given value to a collection containing a single element. @param value The value to convert. @return The converted value. Never null. May be empty.\n*/"}
{"ID": 1224, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertValueToCollection(Object value) { if (value instanceof Iterable) { Iterable iterable = (Iterable) value; Collection<T> collection = createCollection(0); for (Object element : iterable) { collection.add(convertType(element)); } return collection; } if (value instanceof CharSequence) { value = CsvUtil.toStringArray(value.toString()); } Class type = value.getClass(); if (type.isArray()) { // convert arrays Class componentType = type.getComponentType(); if (componentType.isPrimitive()) { return convertPrimitiveArrayToCollection(value, componentType); } else { Object[] array = (Object[]) value; Collection<T> result = createCollection(array.length); for (Object a : array) { result.add(convertType(a)); } return result; } } // everything else: return convertToSingleElementCollection(value); } \nResponse:", "ground_truth": "Converts non-collection value to collection.", "predict": " Convert the given value to a Collection. The resulting collection will contain either a single element or an array of elements. @param value The value to convert. May be null. @return The converted value. Never null. May be empty. Never null. May be immutable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable. May be unmodifiable"}
{"ID": 1225, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Collection<T> convertCollectionToCollection(final Collection value) { Collection<T> collection = createCollection(value.size()); for (Object v : value) { collection.add(convertType(v)); } return collection; } \nResponse:", "ground_truth": "Converts collection value to target collection.\nEach element is converted to target component type.", "predict": " Convert collection to collection. @param value the value @return the collection\n*/"}
{"ID": 1226, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"AutoBoxing\") protected Collection<T> convertPrimitiveArrayToCollection(final Object value, final Class primitiveComponentType) { Collection<T> result = null; if (primitiveComponentType == int.class) { int[] array = (int[]) value; result = createCollection(array.length); for (int a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == long.class) { long[] array = (long[]) value; result = createCollection(array.length); for (long a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == float.class) { float[] array = (float[]) value; result = createCollection(array.length); for (float a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == double.class) { double[] array = (double[]) value; result = createCollection(array.length); for (double a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == short.class) { short[] array = (short[]) value; result = createCollection(array.length); for (short a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == byte.class) { byte[] array = (byte[]) value; result = createCollection(array.length); for (byte a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == char.class) { char[] array = (char[]) value; result = createCollection(array.length); for (char a : array) { result.add(convertType(a)); } } else if (primitiveComponentType == boolean.class) { boolean[] array = (boolean[]) value; result = createCollection(array.length); for (boolean a : array) { result.add(convertType(a)); } } return result; } \nResponse:", "ground_truth": "Converts primitive array to target collection.", "predict": " Convert primitive array to collection. @param value the value @param primitiveComponentType the primitive component type @return the collection\n*/"}
{"ID": 1227, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void addLineNumber(final int lineNumber) { if (this.lineNumber == 0) { this.lineNumber = (short) lineNumber; } else { if (otherLineNumbers == null) { otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT]; } int otherLineNumberIndex = ++otherLineNumbers[0]; if (otherLineNumberIndex >= otherLineNumbers.length) { int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT]; System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length); otherLineNumbers = newLineNumbers; } otherLineNumbers[otherLineNumberIndex] = lineNumber; } } \nResponse:", "ground_truth": "Adds a source line number corresponding to this label.\n\n@param lineNumber a source line number (which should be strictly positive).", "predict": " Add a line number to this instruction. Line numbers are counted from 1. Therefore, the first line number is 1. Therefore, the last line number is 32767. Therefore, 32766 is the penultimate line number. Therefore, 32765 is the third penultimate line number. And so forth. Therefore, 32760 is the fourth penultimate line number. And so forth. Therefore, 32751 is the fifth penultimate line number. And so forth. Therefore, 32736 is the sixth penultimate line number. And so forth. Therefore, 32701 is the seventh penultimate line number. And so forth. Therefore, 32656 is the eighth penultimate line number. And so forth. Therefore, 32561 is the ninth penultimate line number. And so forth. Therefore, 32466 is the tenth penultimate line number. And so forth. Therefore, 32371 is the eleventh penultimate line number. And so forth. Therefore, 32276 is the twelve penultimate line number. And so forth. Therefore, 32151 is the thirteen penultimate line"}
{"ID": 1228, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) { methodVisitor.visitLabel(this); if (visitLineNumbers && lineNumber != 0) { methodVisitor.visitLineNumber(lineNumber & 0xFFFF, this); if (otherLineNumbers != null) { for (int i = 1; i <= otherLineNumbers[0]; ++i) { methodVisitor.visitLineNumber(otherLineNumbers[i], this); } } } } \nResponse:", "ground_truth": "Makes the given visitor visit this label and its source line numbers, if applicable.\n\n@param methodVisitor a method visitor.\n@param visitLineNumbers whether to visit of the label's source line numbers, if any.", "predict": " Visit the label and its successors. Line numbers of other successors will be visited too. @param methodVisitor the visitor to visit these successors.\n */"}
{"ID": 1229, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void put( final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) { if ((flags & FLAG_RESOLVED) == 0) { if (wideReference) { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length); code.putInt(-1); } else { addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length); code.putShort(-1); } } else { if (wideReference) { code.putInt(bytecodeOffset - sourceInsnBytecodeOffset); } else { code.putShort(bytecodeOffset - sourceInsnBytecodeOffset); } } } \nResponse:", "ground_truth": "Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label\nis known, the relative bytecode offset between the label and the instruction referencing it is\ncomputed and written directly. Otherwise, a null relative offset is written and a new forward\nreference is declared for this label.\n\n@param code the bytecode of the method. This is where the reference is appended.\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference to be appended.\n@param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).", "predict": " Puts the given bytecode at the given offset in the code of this method. @param code a bytevector which contains the bytecodes corresponding to the given method. @param sourceInsnBytecodeOffset the bytecode offset in the source code from which the bytecodes corresponding to the given code come from. Corresponds to the 'offset' item of the 'annotation' operation. @param wideReference true if the value to put has a wide reference. Corresponds to the 'wide' item of the 'annotation' operation.\n*/"}
{"ID": 1230, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addForwardReference( final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) { if (forwardReferences == null) { forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT]; } int lastElementIndex = forwardReferences[0]; if (lastElementIndex + 2 >= forwardReferences.length) { int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT]; System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length); forwardReferences = newValues; } forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset; forwardReferences[++lastElementIndex] = referenceType | referenceHandle; forwardReferences[0] = lastElementIndex; } \nResponse:", "ground_truth": "Adds a forward reference to this label. This method must be called only for a true forward\nreference, i.e. only if this label is not resolved yet. For backward references, the relative\nbytecode offset of the reference can be, and must be, computed and stored directly.\n\n@param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the\nreference stored at referenceHandle.\n@param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link\n#FORWARD_REFERENCE_TYPE_WIDE}.\n@param referenceHandle the offset in the bytecode where the forward reference value must be\nstored.", "predict": " Adds a forward reference to the next instruction following the given one. The forward reference consists of the source instruction offset, the reference type and the reference handle. The forward references table is enlarged as needed. @param sourceInsnBytecodeOffset the bytecode offset of the source instruction. @param referenceType the reference type. @param referenceHandle the reference handle."}
{"ID": 1231, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final boolean resolve(final byte[] code, final int bytecodeOffset) { this.flags |= FLAG_RESOLVED; this.bytecodeOffset = bytecodeOffset; if (forwardReferences == null) { return false; } boolean hasAsmInstructions = false; for (int i = forwardReferences[0]; i > 0; i -= 2) { final int sourceInsnBytecodeOffset = forwardReferences[i - 1]; final int reference = forwardReferences[i]; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK; if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) { if (relativeOffset < Short.MIN_VALUE || relativeOffset > Short.MAX_VALUE) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to // 65535, which is sufficient since the size of a method is limited to 65535 bytes). int opcode = code[sourceInsnBytecodeOffset] & 0xFF; if (opcode < Opcodes.IFNULL) { // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA); } else { // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL. code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA); } hasAsmInstructions = true; } code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } else { code[handle++] = (byte) (relativeOffset >>> 24); code[handle++] = (byte) (relativeOffset >>> 16); code[handle++] = (byte) (relativeOffset >>> 8); code[handle] = (byte) relativeOffset; } } return hasAsmInstructions; } \nResponse:", "ground_truth": "Sets the bytecode offset of this label to the given value and resolves the forward references\nto this label, if any. This method must be called when this label is added to the bytecode of\nthe method, i.e. when its bytecode offset becomes known. This method fills in the blanks that\nwhere left in the bytecode by each forward reference previously added to this label.\n\n@param code the bytecode of the method.\n@param bytecodeOffset the bytecode offset of this label.\n@return {@literal true} if a blank that was left for this label was too small to store the\noffset. In such a case the corresponding jump instruction is replaced with an equivalent\nASM specific instruction using an unsigned two bytes offset. These ASM specific\ninstructions are later replaced with standard bytecode instructions with wider offsets (4\nbytes instead of 2), in ClassReader.", "predict": " Resolves forward references. Those are operand numbers for jumps instructions that cannot be computed until the class is completely parsed (but the class writer and the Code attribute must be parsed anyway). This method should be called for each jump instruction relocation, just before its operand is filled in. @param code the code attribute being mutated @param bytecodeOffset the offset of the jump instruction to be relocated @return whether there was an ASM instruction inserted\n*/"}
{"ID": 1232, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void markSubroutine(final short subroutineId) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = listOfBlocksToProcess.nextListElement; basicBlock.nextListElement = null; // If it is not already marked as belonging to a subroutine, mark it as belonging to // subroutineId and add its successors to the list of blocks to process (unless already done). if (basicBlock.subroutineId == 0) { basicBlock.subroutineId = subroutineId; listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } } } \nResponse:", "ground_truth": "Finds the basic blocks that belong to the subroutine starting with the basic block\ncorresponding to this label, and marks these blocks as belonging to this subroutine. This\nmethod follows the control flow graph to find all the blocks that are reachable from the\ncurrent basic block WITHOUT following any jsr target.\n\n<p>Note: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineId the id of the subroutine starting with the basic block corresponding to\nthis label.", "predict": " Marks this basic block as belonging to the given subroutine. This method is used to tie together two lists of subroutines: the list of subroutines called by a subroutine, and the list of subroutines called by this subroutine. Both lists must be kept in correspondence: there must be a subroutine in the list called by every subroutine in the other list. Note that a subroutine appears in both lists. @param subroutineId the id of the subroutine."}
{"ID": 1233, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void addSubroutineRetSuccessors(final Label subroutineCaller) { // Data flow algorithm: put this basic block in a list blocks to process (which are blocks // belonging to a subroutine starting with this label) and, while there are blocks to process, // remove one from the list, put it in a list of blocks that have been processed, add a return // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks // in the control flow graph to the list of blocks to process (if not already done). Label listOfProcessedBlocks = EMPTY_LIST; Label listOfBlocksToProcess = this; listOfBlocksToProcess.nextListElement = EMPTY_LIST; while (listOfBlocksToProcess != EMPTY_LIST) { // Move a basic block from the list of blocks to process to the list of processed blocks. Label basicBlock = listOfBlocksToProcess; listOfBlocksToProcess = basicBlock.nextListElement; basicBlock.nextListElement = listOfProcessedBlocks; listOfProcessedBlocks = basicBlock; // Add an edge from this block to the successor of the caller basic block, if this block is // the end of a subroutine and if this block and subroutineCaller do not belong to the same // subroutine. if ((basicBlock.flags & FLAG_SUBROUTINE_END) != 0 && basicBlock.subroutineId != subroutineCaller.subroutineId) { basicBlock.outgoingEdges = new Edge( basicBlock.outputStackSize, // By construction, the first outgoing edge of a basic block that ends with a jsr // instruction leads to the jsr continuation block, i.e. where execution continues // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}). subroutineCaller.outgoingEdges.successor, basicBlock.outgoingEdges); } // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does // not push basic blocks which are already in a list. Here this means either in the list of // blocks to process, or in the list of already processed blocks. This second list is // important to make sure we don't reprocess an already processed block. listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess); } // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null, // so that this method can be called again with a different subroutine or subroutine caller. while (listOfProcessedBlocks != EMPTY_LIST) { Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement; listOfProcessedBlocks.nextListElement = null; listOfProcessedBlocks = newListOfProcessedBlocks; } } \nResponse:", "ground_truth": "Finds the basic blocks that end a subroutine starting with the basic block corresponding to\nthis label and, for each one of them, adds an outgoing edge to the basic block following the\ngiven subroutine call. In other words, completes the control flow graph by adding the edges\ncorresponding to the return from this subroutine, when called from the given caller basic\nblock.\n\n<p>Note: a precondition and postcondition of this method is that all labels must have a null\n{@link #nextListElement}.\n\n@param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to\nthis label. This label is supposed to correspond to the start of a subroutine.", "predict": " Adds to the control flow graph successors of basic blocks in the subroutine that starts with the given label. @param subroutineCaller the basic block in a subroutine that starts with the given label. Its successor will be added to the successor list of this label. If this label ends with a jsr, its successor will be the jsr continuation block, i.e. where execution will continue when ret is called."}
{"ID": 1234, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int[] compareDigits(final String str1, int ndx1, final String str2, int ndx2) { // iterate all digits in the first string int zeroCount1 = 0; while (charAt(str1, ndx1) == '0') { zeroCount1++; ndx1++; } int len1 = 0; while (true) { final char char1 = charAt(str1, ndx1); final boolean isDigitChar1 = CharUtil.isDigit(char1); if (!isDigitChar1) { break; } len1++; ndx1++; } // iterate all digits in the second string and compare with the first int zeroCount2 = 0; while (charAt(str2, ndx2) == '0') { zeroCount2++; ndx2++; } int len2 = 0; int ndx1_new = ndx1 - len1; int equalNumbers = 0; while (true) { final char char2 = charAt(str2, ndx2); final boolean isDigitChar2 = CharUtil.isDigit(char2); if (!isDigitChar2) { break; } if (equalNumbers == 0 && (ndx1_new < ndx1)) { equalNumbers = charAt(str1, ndx1_new++) - char2; } len2++; ndx2++; } // compare if (len1 != len2) { // numbers are not equals size return new int[] {len1 - len2}; } if (equalNumbers != 0) { return new int[] {equalNumbers}; } // numbers are equal, but number of zeros is different return new int[] {0, zeroCount1 - zeroCount2, ndx1, ndx2}; } \nResponse:", "ground_truth": "Compare digits at certain position in two strings.\nThe longest run of digits wins. That aside, the greatest\nvalue wins.\n@return if numbers are different, only 1 element is returned.", "predict": " Compare digits of two strings ignoring all leading zeros. @param str1 first string to compare @param ndx1 index of first digit in first string @param str2 second string to compare @param ndx2 index of first digit in second string @return difference in lengths of digits, or 0 if equal\n*/"}
{"ID": 1235, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private char fixAccent(final char c) { for (int i = 0; i < ACCENT_CHARS.length; i+=2) { final char accentChar = ACCENT_CHARS[i]; if (accentChar == c) { return ACCENT_CHARS[i + 1]; } } return c; } \nResponse:", "ground_truth": "Fixes accent char.", "predict": " Fixes accents in a string. @param c character to fix accent for. @return fixed character.\n*/"}
{"ID": 1236, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putByte(final int byteValue) { int currentLength = length; if (currentLength + 1 > data.length) { enlarge(1); } data[currentLength++] = (byte) byteValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a byte into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue a byte.\n@return this byte vector.", "predict": " Adds a byte to the byte vector. The byte vector is automatically enlarged if necessary."}
{"ID": 1237, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put11(final int byteValue1, final int byteValue2) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts two bytes into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@return this byte vector.", "predict": " Puts two bytes from the reader/writer index. The reader/writer index is not incremented. @param byteValue1 the first byte @param byteValue2 the second byte @return this vector"}
{"ID": 1238, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putShort(final int shortValue) { int currentLength = length; if (currentLength + 2 > data.length) { enlarge(2); } byte[] currentData = data; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a short into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param shortValue a short.\n@return this byte vector.", "predict": " Puts a short into the byte vector. The byte vector is automatically enlarged if necessary.\n@param shortValue a short.\n*/"}
{"ID": 1239, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put12(final int byteValue, final int shortValue) { int currentLength = length; if (currentLength + 3 > data.length) { enlarge(3); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue a byte.\n@param shortValue a short.\n@return this byte vector.", "predict": " Puts two bytes into the byte vector as 12 bit integers. Neither argument is bigger than 8388608 (8388608 is the byte size limit of a byte vector). @param byteValue a byte. Shall not be greater than 127. @param shortValue a short. Shall not be greater than 32767. @return this byte vector.\n"}
{"ID": 1240, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put112(final int byteValue1, final int byteValue2, final int shortValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue1; currentData[currentLength++] = (byte) byteValue2; currentData[currentLength++] = (byte) (shortValue >>> 8); currentData[currentLength++] = (byte) shortValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts two bytes and a short into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteValue1 a byte.\n@param byteValue2 another byte.\n@param shortValue a short.\n@return this byte vector.", "predict": " Puts112 puts a 112-bit signed integer value into this byte vector. The 112 most significant bits of the integer are written first in the following order: the 112 higher bits of the first byte, the 7 bits of the second byte, the 112 higher bits of the third byte, the 7 bits of the fourth byte, the 112 higher bits of the fifth byte, the 7 bits of the sixth byte, and the 112 higher bits of the seventh byte. The 7 lower bits of each byte are written in big-endian order. @param byteValue1 the 112 higher bits of the first byte @param byteValue2 the 7 bits of the second byte @param shortValue the 112 higher bits of the third byte @return this byte vector"}
{"ID": 1241, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putInt(final int intValue) { int currentLength = length; if (currentLength + 4 > data.length) { enlarge(4); } byte[] currentData = data; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts an int into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param intValue an int.\n@return this byte vector.", "predict": " Puts an int into the byte vector. The int is converted to bytes using the following process: The int is converted to a byte array. The byte array is then written in the following manner: The byte array is reversed and written to the byte vector in reverse order. That is, the first byte written is the last byte in the byte vector."}
{"ID": 1242, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final ByteVector put122(final int byteValue, final int shortValue1, final int shortValue2) { int currentLength = length; if (currentLength + 5 > data.length) { enlarge(5); } byte[] currentData = data; currentData[currentLength++] = (byte) byteValue; currentData[currentLength++] = (byte) (shortValue1 >>> 8); currentData[currentLength++] = (byte) shortValue1; currentData[currentLength++] = (byte) (shortValue2 >>> 8); currentData[currentLength++] = (byte) shortValue2; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts one byte and two shorts into this byte vector. The byte vector is automatically enlarged\nif necessary.\n\n@param byteValue a byte.\n@param shortValue1 a short.\n@param shortValue2 another short.\n@return this byte vector.", "predict": " Puts two bytes and two shorts into the byte vector. The shorts are stored in big endian format.\n"}
{"ID": 1243, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putLong(final long longValue) { int currentLength = length; if (currentLength + 8 > data.length) { enlarge(8); } byte[] currentData = data; int intValue = (int) (longValue >>> 32); currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; intValue = (int) longValue; currentData[currentLength++] = (byte) (intValue >>> 24); currentData[currentLength++] = (byte) (intValue >>> 16); currentData[currentLength++] = (byte) (intValue >>> 8); currentData[currentLength++] = (byte) intValue; length = currentLength; return this; } \nResponse:", "ground_truth": "Puts a long into this byte vector. The byte vector is automatically enlarged if necessary.\n\n@param longValue a long.\n@return this byte vector.", "predict": " Puts a long into the byte vector. The long is converted to an int by shifting its high-order 24 bits into the lowest 8 bits and then concatenating the rest, if any, to form the 24 lower bits. This is then encoded as described in {@link #putInt}.\n<p>This method is suitable for writing little-endian longs.\n<p>This method does not modify the currentPos vector. @param longValue the long to write @return this byte vector\n*/"}
{"ID": 1244, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ByteVector putByteArray( final byte[] byteArrayValue, final int byteOffset, final int byteLength) { if (length + byteLength > data.length) { enlarge(byteLength); } if (byteArrayValue != null) { System.arraycopy(byteArrayValue, byteOffset, data, length, byteLength); } length += byteLength; return this; } \nResponse:", "ground_truth": "Puts an array of bytes into this byte vector. The byte vector is automatically enlarged if\nnecessary.\n\n@param byteArrayValue an array of bytes. May be {@literal null} to put {@code byteLength} null\nbytes into this byte vector.\n@param byteOffset index of the first byte of byteArrayValue that must be copied.\n@param byteLength number of bytes of byteArrayValue that must be copied.\n@return this byte vector.", "predict": " Puts a byte array into this byte vector. The byte vector is automatically enlarged if necessary. @param byteArrayValue a byte array. @param byteOffset the start offset of the bytes to be put into this byte vector. @param byteLength the number of bytes to be put into this byte vector. */"}
{"ID": 1245, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void enlarge(final int size) { int doubleCapacity = 2 * data.length; int minimalCapacity = length + size; byte[] newData = new byte[doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity]; System.arraycopy(data, 0, newData, 0, length); data = newData; } \nResponse:", "ground_truth": "Enlarges this byte vector so that it can receive 'size' more bytes.\n\n@param size number of additional bytes that this byte vector should be able to receive.", "predict": " enlarge the allocated array to accommodate more elements.\n*/"}
{"ID": 1246, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaHttpSession(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final UserSession<T> userSession = UserSession.get(servletRequest); if (userSession == null) { return null; } final T authToken = userSession.getAuthToken(); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); if (newAuthToken != authToken) { final UserSession<T> newUserSesion = new UserSession<>(newAuthToken, userAuth().tokenValue(newAuthToken)); newUserSesion.start(servletRequest, actionRequest.getHttpServletResponse()); } return newAuthToken; } \nResponse:", "ground_truth": "Tries to authenticate user via HTTP session. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": " Authenticate the user via HTTP session. @param actionRequest The action request. @return The authentication token."}
{"ID": 1247, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaToken(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); // then try the auth token final String token = ServletUtil.resolveAuthBearerToken(servletRequest); if (token == null) { return null; } final T authToken = userAuth().validateToken(token); if (authToken == null) { return null; } // granted final T newAuthToken = userAuth().rotateToken(authToken); actionRequest.getHttpServletResponse().setHeader(\"Authentication\", \"Bearer: \" + userAuth().tokenValue(newAuthToken)); return newAuthToken; } \nResponse:", "ground_truth": "Tries to authenticate user via token. Returns the token if user is authenticated.\nReturned token may be rotated.", "predict": " Authenticate the user via bearer token. @param actionRequest the action request\n@return the authenticated user or null if authentication fails\n*/"}
{"ID": 1248, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T authenticateUserViaBasicAuth(final ActionRequest actionRequest) { final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); final T authToken = userAuth().login(username, password); if (authToken == null) { return null; } return authToken; } \nResponse:", "ground_truth": "Tires to authenticate user via the basic authentication. Returns the token if user is authenticated.", "predict": " Authenticate the user via BASIC Auth. @param actionRequest The request to authenticate. @return The authentication token if authenticated, otherwise null."}
{"ID": 1249, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String findDefaultMessage(final Locale locale, final String key) { String indexedKey = calcIndexKey(key); String msg = getMessage(fallbackBundlename, locale, key, indexedKey); if (msg != null) { return msg; } for (String bname : defaultBundles) { msg = getMessage(bname, locale, key, indexedKey); if (msg != null) { return msg; } } return null; } \nResponse:", "ground_truth": "Finds message in default bundles only, starting from fallback bundlename.", "predict": " Try to find a localized message for the given key. First try to find a localized message in the default bundles. If none is found try to find a localized message in the bundles mentioned in the bundlesToUse property. If none is found try to find a localized message in the bundles mentioned in the fallbackBundlenames property. If none is found return null. @param locale The locale to use. @param key The key to search for. @return The localized message or null if none is found."}
{"ID": 1250, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ResourceBundle getBundle(final String bundleName, final Locale locale, final ClassLoader classLoader) { return ResourceBundle.getBundle(bundleName, locale, classLoader); } \nResponse:", "ground_truth": "Returns specified bundle. Invoked every time if cache is disabled.\nInput arguments are always valid.", "predict": " Get bundle. @param bundleName bundle name @param locale locale @param classLoader class loader @return bundle\n*/"}
{"ID": 1251, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected K get(final K[] array, final int index) { return (K) Array.get(array, index); } \nResponse:", "ground_truth": "Returns array's element at given index.", "predict": " Get the element at the specified index in the array. This is a shortcut for accessing the array directly. @param array the array to get the element from @param index the index of the element to get @return the element at the specified index in the array\n*/"}
{"ID": 1252, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <E, ID> void setEntityId(final DbEntityDescriptor<E> ded, final E entity, final ID newIdValue) { ded.setIdValue(entity, newIdValue); } \nResponse:", "ground_truth": "Sets new ID value for entity.", "predict": " Sets the id value of the entity. @param ded The descriptor of the entity. @param entity The entity. @param newIdValue The new id value."}
{"ID": 1253, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void save(final Object entity) { final DbQuery q = query(dbOom.entities().insert(entity)); q.autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Simply inserts object into the database.", "predict": " Inserts given entity. @param entity Entity to save. Never NULL."}
{"ID": 1254, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void update(final Object entity) { query(dbOom.entities().updateAll(entity)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Updates single entity.", "predict": " Update all entities managed by this DAO. @param entity Entity to update. Shall not be null. Entity will be detached from its session."}
{"ID": 1255, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E updateProperty(final E entity, final String name, final Object newValue) { query(dbOom.entities().updateColumn(entity, name, newValue)).autoClose().executeUpdate(); BeanUtil.declared.setProperty(entity, name, newValue); return entity; } \nResponse:", "ground_truth": "Updates single property in database and in the bean.", "predict": " Update the property of an entity. The entity will be returned, i.e. committed. @param entity an entity to update. Never NULL. @param name the name of the property to update. Never NULL. @param newValue the new value of the property. Never NULL. @return the updated entity. Never NULL."}
{"ID": 1256, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E updateProperty(final E entity, final String name) { Object value = BeanUtil.declared.getProperty(entity, name); query(dbOom.entities().updateColumn(entity, name, value)).autoClose().executeUpdate(); return entity; } \nResponse:", "ground_truth": "Updates property in the database by storing the current property value.", "predict": " Update the property of an entity. The property is identified by its name. The property value is automatically assigned to the column of the first row affected by the UPDATE statement. @param entity an entity @param name the name of the property @param <E> the entity type @return the updated entity\n*/"}
{"ID": 1257, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E, ID> E findById(final Class<E> entityType, final ID id) { return query(dbOom.entities().findById(entityType, id)).autoClose().find(entityType); } \nResponse:", "ground_truth": "Finds single entity by its id.", "predict": " Finder for entity by ID. @param entityType Entity type. @param id Primary key ID. @param <E> Entity type. @param <ID> Primary key type. @return Entity with given ID. Never NULL."}
{"ID": 1258, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> E findOneByProperty(final Class<E> entityType, final String name, final Object value) { return query(dbOom.entities().findByColumn(entityType, name, value)).autoClose().find(entityType); } \nResponse:", "ground_truth": "Finds single entity by matching property.", "predict": " Finder for ONE entity by property. @param entityType type of entity to find @param name property name @param value property value @param <E> Entity type\n * @return founded entity or null\n */"}
{"ID": 1259, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public <E> E findOne(final Object criteria) { return (E) query(dbOom.entities().find(criteria)).autoClose().find(criteria.getClass()); } \nResponse:", "ground_truth": "Finds one entity for given criteria.", "predict": " Find one entity by criteria. @param criteria Criteria (primary key) or object with primary key(s) setted up. @return Primary keyed entity or null if nothing found."}
{"ID": 1260, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void deleteById(final Class entityType, final ID id) { query(dbOom.entities().deleteById(entityType, id)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Deleted single entity by its id.", "predict": " Soft delete by id. Simply ignores non-existing entities. Faster than deleting by primary key. Especially suited for ManyToMany associations. Soft delete by id. Simply ignores non-existing entities. Faster than deleting by primary key. Especially suited for ManyToMany associations. @param entityType type of the entity to delete @param id primary key of the entity to delete"}
{"ID": 1261, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void deleteById(final Object entity) { if (entity != null) { int result = query(dbOom.entities().deleteById(entity)).autoClose().executeUpdate(); if (result != 0) { // now reset the ID value Class type = entity.getClass(); DbEntityDescriptor ded = dbOom.entityManager().lookupType(type); setEntityId(ded, entity, 0); } } } \nResponse:", "ground_truth": "Delete single object by its id. Resets ID value.", "predict": " Delete entity by ID. @param entity Entity to be deleted. Never NULL."}
{"ID": 1262, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long count(final Class entityType) { return query(dbOom.entities().count(entityType)).autoClose().executeCount(); } \nResponse:", "ground_truth": "Counts number of all entities.", "predict": " Count how many entities of given entity type there are in database. @param entityType Entity type. @return Count of entities of given type."}
{"ID": 1263, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void increaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, true)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Increases a property.", "predict": " Increase the value of the named property of the entity with the given ID by delta. Delta may be negative. @param entityType entity type @param id ID of entity @param name name of property @param delta delta\n*/"}
{"ID": 1264, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <ID> void decreaseProperty(final Class entityType, final ID id, final String name, final Number delta) { query(dbOom.entities().increaseColumn(entityType, id, name, delta, false)).autoClose().executeUpdate(); } \nResponse:", "ground_truth": "Decreases a property.", "predict": " Decrease the value of the property of an entity by a delta. The delta is automatically multiplied by minus 1. Therefore, a decreaseProperty(...) invocation will effectively increase the property value by 1. @param entityType type of the entity whose property shall be decreased @param id identifier of the entity whose property shall be decreased @param name name of the property whose value shall be decreased @param delta delta by which the property shall be decreased"}
{"ID": 1265, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> List<E> findRelated(final Class<E> target, final Object source) { return query(dbOom.entities().findForeign(target, source)).autoClose().list(target); } \nResponse:", "ground_truth": "Finds related entity.", "predict": " Finder for related entities. @param target Related entity class. @param source Source entity. @param <E> Related entity type. @return List of related entities. Never NULL. Empty list if nothing found."}
{"ID": 1266, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <E> List<E> listAll(final Class<E> target) { return query(dbOom.entities().from(target)).autoClose().list(target); } \nResponse:", "ground_truth": "List all entities.", "predict": " Select all instances of given entity class. Compared to other query methods, this method will NOT eager fetch relationships. Therefore, it is advisable to specify fetch-mode=\"LAZY\" on related entity definitions when using this method. @param target Entity class to instantiate. @param <E> Entity type. @return List of all instances of given entity class. Never NULL. Empty list if nothing found."}
{"ID": 1267, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void clear() { entries = null; Iterator<String> keys = getAttributeNames(); while (keys.hasNext()) { removeAttribute(keys.next()); } } \nResponse:", "ground_truth": "Removes all attributes from the request as well as clears entries in this map.", "predict": " Clears all entries from the cache."}
{"ID": 1268, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Set<Entry<String, Object>> entrySet() { if (entries == null) { entries = new HashSet<>(); Iterator<String> iterator = getAttributeNames(); while (iterator.hasNext()) { final String key = iterator.next(); final Object value = getAttribute(key); entries.add(new Entry<String, Object>() { @Override public boolean equals(final Object obj) { if (obj == null) { return false; } if (this.getClass() != obj.getClass()) { return false; } Entry entry = (Entry) obj; return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue())); } @Override public int hashCode() { return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode()); } @Override public String getKey() { return key; } @Override public Object getValue() { return value; } @Override public Object setValue(final Object obj) { setAttribute(key, obj); return value; } }); } } return entries; } \nResponse:", "ground_truth": "Returns a Set of attributes from the http request.", "predict": " Provide a Set of Entry objects reflecting all the attributes of this WikiPage. Each Entry object provides a getKey() and getValue() method that return the attribute name and value respectively. The WikiPage itself provides no means of altering the attributes of the WikiPage. However, the WikiPage may be backed by a WikiEngine that provides means of altering the attributes of WikiPages. Therefore, the WikiPage itself does not provide a means of altering the attributes of the WikiPage. Instead, the WikiEngine exposes a means of altering the attributes of WikiPages through the WikiPageEntrySet returned by this method. @return a Set of Entry objects reflecting all the attributes of this WikiPage. Each Entry object provides a getKey() and getValue() method that return the attribute name and value respectively. The WikiPage itself provides no means of altering the attributes of the WikiPage. However, the WikiPage may be backed by a WikiEngine that provides means of altering the attributes of WikiPages. Therefore, the WikiPage itself does not provide a means of altering the attributes of the"}
{"ID": 1269, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object put(final String key, final Object value) { entries = null; Object previous = get(key); setAttribute(key, value); return previous; } \nResponse:", "ground_truth": "Saves an attribute in the request.", "predict": " Associates the specified value with the specified key in this hashtable. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key. @param key the key with which the value is to be associated. @param value the value to be associated with the specified key. @return the previous value of the key in this hashtable, or null if it did not have one.\n"}
{"ID": 1270, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Object remove(final Object key) { entries = null; Object value = get(key); removeAttribute(key.toString()); return value; } \nResponse:", "ground_truth": "Removes the specified request attribute.", "predict": " Remove an attribute from the session. @param key The key of the attribute to remove. @return The value of the removed attribute.\n*/"}
{"ID": 1271, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"ThrowCaughtLocally\"}) public static StackTraceElement[] getCurrentStackTrace() { StackTraceElement[] ste = new Exception().getStackTrace(); if (ste.length > 1) { StackTraceElement[] result = new StackTraceElement[ste.length - 1]; System.arraycopy(ste, 1, result, 0, ste.length - 1); return result; } else { return ste; } } \nResponse:", "ground_truth": "Returns current stack trace in form of array of stack trace elements.\nFirst stack trace element is removed.\nSince an exception is thrown internally, this method is slow.", "predict": " Returns the stack trace of the current thread minus the first frames from Groovy and Kotlin classes. Inspired by discussions on the mailing list and StackOverflow. Similar caveats apply regarding the stability of this solution. Caveat Emptor. Specifically, it is easily possible to introduce new frames into the array, so care should be taken to not blindly trust this value. Fortunately, experimentation showed that the vast majority of frames remained stable throughout development. Caveat Emptor. Again, staying cautious. Fortunately, the frames we're eliminating tend to be libraries and IDE frames, so they're fairly trivial to ignore. Caveat Emptor. Fortunately, we can at least partially mitigate the impact of frames belonging to IDE frameworks by eliminating certain classes whose methods tend to be invoked by IDE APIs. Caveat Emptor. Fortunately, we can mitigate the impact of frames belonging to IDE frameworks by eliminating certain classes whose methods tend to be invoked by IDE APIs. Caveat Emptor. Fortunately, we can mitigate the impact of frames belonging to IDE frameworks by eliminating certain classes whose"}
{"ID": 1272, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StackTraceElement[] getStackTrace(final Throwable t, final String[] allow, final String[] deny) { StackTraceElement[] st = t.getStackTrace(); ArrayList<StackTraceElement> result = new ArrayList<>(st.length); elementLoop: for (StackTraceElement element : st) { String className = element.getClassName(); if (allow != null) { boolean validElemenet = false; for (String filter : allow) { if (className.contains(filter)) { validElemenet = true; break; } } if (!validElemenet) { continue; } } if (deny != null) { for (String filter : deny) { if (className.contains(filter)) { continue elementLoop; } } } result.add(element); } st = new StackTraceElement[result.size()]; return result.toArray(st); } \nResponse:", "ground_truth": "Returns stack trace filtered by class names.", "predict": " Filter stack trace elements. @param t the throwable whose stack trace you want to filter. @param allow optional allow list of classes. @param deny optional deny list of classes. @return filtered stack trace.\n*/"}
{"ID": 1273, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StackTraceElement[][] getStackTraceChain(Throwable t, final String[] allow, final String[] deny) { ArrayList<StackTraceElement[]> result = new ArrayList<>(); while (t != null) { StackTraceElement[] stack = getStackTrace(t, allow, deny); result.add(stack); t = t.getCause(); } StackTraceElement[][] allStacks = new StackTraceElement[result.size()][]; for (int i = 0; i < allStacks.length; i++) { allStacks[i] = result.get(i); } return allStacks; } \nResponse:", "ground_truth": "Returns stack trace chain filtered by class names.", "predict": " Get the stack trace chain for a throwable. The chain is built backwards, so the deepest cause comes first. @param t Throwable whose stack trace you want to obtain. @param allow What classes are allowed in the chain. @param deny What classes are denied in the chain. @return Stack trace chain for t.\n*/"}
{"ID": 1274, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Throwable[] getExceptionChain(Throwable throwable) { ArrayList<Throwable> list = new ArrayList<>(); list.add(throwable); while ((throwable = throwable.getCause()) != null) { list.add(throwable); } Throwable[] result = new Throwable[list.size()]; return list.toArray(result); } \nResponse:", "ground_truth": "Returns exception chain starting from top up to root cause.", "predict": " Get the exception chain for the given throwable. The chain includes the throwable itself. @param throwable The throwable to inspect. @return The exception chain. Never null. May be empty.\n*/"}
{"ID": 1275, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String exceptionStackTraceToString(final Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); t.printStackTrace(pw); StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); } \nResponse:", "ground_truth": "Prints stack trace into a String.", "predict": " Convert an exception stack trace to a string. Useful for debugging. @param t The throwable to convert. @return The stack trace as a string.\n*/"}
{"ID": 1276, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String exceptionChainToString(Throwable t) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw, true); while (t != null) { t.printStackTrace(pw); t = t.getCause(); } StreamUtil.close(pw); StreamUtil.close(sw); return sw.toString(); } \nResponse:", "ground_truth": "Prints full exception stack trace, from top to root cause, into a String.", "predict": " Turns an exception chain into a nicely formatted multi-line string. Useful for debugging. Leaves the root cause untouched. Useful for developers debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for debugging. Leaves out suppressed exceptions. Useful for troubleshooting. Leaves out suppressed exceptions. Useful for"}
{"ID": 1277, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String buildMessage(final String message, Throwable cause) { if (cause != null) { cause = getRootCause(cause); StringBuilder buf = new StringBuilder(); if (message != null) { buf.append(message).append(\"; \"); } buf.append(\"<--- \").append(cause); return buf.toString(); } else { return message; } } \nResponse:", "ground_truth": "Build a message for the given base message and its cause.", "predict": " Build a message for the stack trace. The message includes the original message and the cause of the exception. @param message The original message. @param cause The root cause of the exception. @return The message.\n*/"}
{"ID": 1278, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Throwable unwrapThrowable(final Throwable wrappedThrowable) { Throwable unwrapped = wrappedThrowable; while (true) { if (unwrapped instanceof InvocationTargetException) { unwrapped = ((InvocationTargetException) unwrapped).getTargetException(); } else if (unwrapped instanceof UndeclaredThrowableException) { unwrapped = ((UndeclaredThrowableException) unwrapped).getUndeclaredThrowable(); } else { return unwrapped; } } } \nResponse:", "ground_truth": "Unwraps invocation and undeclared exceptions to real cause.", "predict": " Unwrap a Throwable. Useful for situations where you want to ignore exceptions that arise during certain situations, but want to preserve the original exception in situations where you want to propagate the exception. For example, consider a situation where you want to propagate an exception to the caller, but you want to ignore exceptions that arise during certain situations. Imagine a situation where you have a method that makes a network call, and you want to propagate the exception to the caller, but you want to ignore exceptions that arise during certain situations. Imagine a situation where you have a method that makes a network call, and you want to propagate the exception to the caller, but you want to ignore exceptions that arise during certain situations. Imagine a situation where you have a method that makes a network call, and you want to propagate the exception to the caller, but you want to ignore exceptions that arise during certain situations. Imagine a situation where you have a method that makes a network call, and you want to propagate the exception to the caller, but you want to ignore exceptions that arise during certain situations. Imagine"}
{"ID": 1279, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void registerAsConsumer(final ClassScanner classScanner) { classScanner.registerEntryConsumer(classPathEntry -> { final String entryName = classPathEntry.name(); if (entryName.endsWith(actionClassSuffix)) { try { acceptActionClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc action, ignoring: \" + entryName); } } else if (classPathEntry.isTypeSignatureInUse(MADVOC_COMPONENT_ANNOTATION)) { try { acceptMadvocComponentClass(classPathEntry.loadClass()); } catch (Exception ex) { log.debug(\"Invalid Madvoc component ignoring: {}\" + entryName); } } }); } \nResponse:", "ground_truth": "Parses class name that matches madvoc-related names.", "predict": " Register Madvoc components and actions as consumers of scanning results. Typically Madvoc components are scanned for Madvoc annotations and Madvoc actions are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for Madvoc annotations too. Madvoc annotations are scanned for"}
{"ID": 1280, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void acceptMadvocComponentClass(final Class componentClass) { if (componentClass == null) { return; } if (!checkClass(componentClass)) { return; } madvocComponents.add(() -> madvocContainer.registerComponent(componentClass)); } \nResponse:", "ground_truth": "Registers new Madvoc component.", "predict": " Register Madvoc component class. Madvoc components are Madvoc Interceptors and Controllers. Therefore interceptors and controllers are Madvoc components too. Therefore we can register them here. Madvoc Interceptors are Madvoc components too. Therefore we can register them here. Madvoc Controllers are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too. Therefore we can register them here. Madvoc Filters are Madvoc components too."}
{"ID": 1281, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClassLoader getSystemClassLoader() { if (System.getSecurityManager() == null) { return ClassLoader.getSystemClassLoader(); } else { return AccessController.doPrivileged( (PrivilegedAction<ClassLoader>) ClassLoader::getSystemClassLoader); } } \nResponse:", "ground_truth": "Returns system class loader.", "predict": " Returns the system class loader. On JDK 9+, this may be a security privileged action. @return the system class loader\n*/"}
{"ID": 1282, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { return url.openStream(); } return null; } \nResponse:", "ground_truth": "Opens a resource of the specified name for reading.\n@see #getResourceUrl(String, ClassLoader)", "predict": " Get the InputStream for a named resource. The resource is loaded relative to the calling class. @param resourceName The name of the resource to load. @param callingClass The Class object that called this method. @return The InputStream for the named resource. @throws IOException If there is a problem accessing the named resource.\n*/"}
{"ID": 1283, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getResourceAsStream(final String resourceName, final ClassLoader callingClass, final boolean useCache) throws IOException { URL url = getResourceUrl(resourceName, callingClass); if (url != null) { URLConnection urlConnection = url.openConnection(); urlConnection.setUseCaches(useCache); return urlConnection.getInputStream(); } return null; } \nResponse:", "ground_truth": "Opens a resource of the specified name for reading. Controls caching,\nthat is important when the same jar is reloaded using custom classloader.", "predict": " Get the InputStream for a resource. The resource is searched for in the following locations: 1) Classpath (including the directories of any jars found on the CLASSPATH environment variable) 2) Bundled extensions 3) Bundled resources 4) Resources in the BOOT-INF/classes 5) Resources in the BOOT-INF/lib 6) Resources in WEB-INF/lib 7) Resources in WEB-INF/classes 8) Resources in WEB-INF 7) Resources in WEB-INF 6) Resources in WEB-INF 5) Resources in WEB-INF 4) Resources in WEB-INF 3) Resources in WEB-INF 2) Resources in WEB-INF 1) Resources in WEB-INF 0) Resources in WEB-INF -1) Resources in WEB-INF -2) Resources in WEB-INF -3) Resources in WEB-INF -4) Resources in WEB-INF"}
{"ID": 1284, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getClassAsStream(final Class clazz) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(clazz), clazz.getClassLoader()); } \nResponse:", "ground_truth": "Opens a class of the specified name for reading using class classloader.\n@see #getResourceAsStream(String, ClassLoader)", "predict": " Get the InputStream for the given class. @param clazz The class whose InputStream is sought. @return The InputStream for the given class. @throws IOException If the InputStream cannot be obtained.\n*/"}
{"ID": 1285, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InputStream getClassAsStream(final String className, final ClassLoader classLoader) throws IOException { return getResourceAsStream(ClassUtil.convertClassNameToFileName(className), classLoader); } \nResponse:", "ground_truth": "Opens a class of the specified name for reading using provided class loader.", "predict": " Get the InputStream for the named class. @param className The fully qualified name of the class. @param classLoader The ClassLoader to use. @return The InputStream for the named class. @throws IOException If there is a problem getting the InputStream.\n*/"}
{"ID": 1286, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RouteChunk add(final String newValue) { RouteChunk routeChunk = new RouteChunk(routes, this, newValue); if (children == null) { children = new RouteChunk[] {routeChunk}; } else { children = ArraysUtil.append(children, routeChunk); } return routeChunk; } \nResponse:", "ground_truth": "Adds a new child to the tree.", "predict": " Add a new RouteChunk to this RouteChunk. @param newValue The new RouteChunk to add. @return The RouteChunk that was added.\n*/"}
{"ID": 1287, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RouteChunk findOrCreateChild(final String value) { if (children != null) { for (RouteChunk child : children) { if (child.get().equals(value)) { return child; } } } return add(value); } \nResponse:", "ground_truth": "Finds existing chunk or creates a new one if does not exist.", "predict": " Finds or creates a RouteChunk for the given RouteChunk value. @param value The RouteChunk value to find or create a RouteChunk for. @return The RouteChunk for the given RouteChunk value. Never null. May be this RouteChunk."}
{"ID": 1288, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parseRequest() throws IOException { if (ServletUtil.isMultipartRequest(request)) { parseRequestStream(request.getInputStream(), characterEncoding); } else { Enumeration names = request.getParameterNames(); while (names.hasMoreElements()) { String paramName = (String) names.nextElement(); String[] values = request.getParameterValues(paramName); putParameters(paramName, values); } } } \nResponse:", "ground_truth": "Checks if request if multi-part and parse it. If request is not multi-part it\ncopies all parameters, to make usage the same in both cases.\n\n@see MultipartRequestWrapper", "predict": " Parse the incoming request. @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1289, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Object convertToCollection(final Object value, final Class destinationType, final Class componentType) { return typeConverterManager.convertToCollection(value, destinationType, componentType); } \nResponse:", "ground_truth": "Converter to collection.", "predict": " Convert the value to a Collection. @param value The value to convert. @param destinationType The destination type. @param componentType The component type. @return The converted value.\n*/"}
{"ID": 1290, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeSetter(final Setter setter, final BeanProperty bp, Object value) { try { final MapperFunction setterMapperFunction = setter.getMapperFunction(); if (setterMapperFunction != null) { value = setterMapperFunction.apply(value); } final Class type = setter.getSetterRawType(); if (ClassUtil.isTypeOf(type, Collection.class)) { Class componentType = setter.getSetterRawComponentType(); value = convertToCollection(value, type, componentType); } else { // no collections value = convertType(value, type); } setter.invokeSetter(bp.bean, value); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Setter failed: \" + setter, ex); } return value; } \nResponse:", "ground_truth": "Invokes setter, but first converts type to match the setter type.", "predict": " Invokes the setter method. @param setter the setter method @param bp the bean property @param value the value to set @return the value to set\n*/"}
{"ID": 1291, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void arrayForcedSet(final BeanProperty bp, Object array, final int index, Object value) { Class componentType = array.getClass().getComponentType(); array = ensureArraySize(bp, array, componentType, index); value = convertType(value, componentType); Array.set(array, index, value); } \nResponse:", "ground_truth": "Sets the array element forced. If index is greater then arrays length, array will be expanded to the index.\nIf speed is critical, it is better to allocate an array with proper size before using this method.", "predict": " Straightforward way to forcibly set an indexed property. Deals with both ordinary beans and DynaBeans transparently. Never forces anything into inaccessible properties.\n@param bp The bean property we're manipulating\n@param array The array to manipulate\n@param index The index of the property to manipulate\n@param value The value to forcibly set\n*/"}
{"ID": 1292, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object createBeanProperty(final BeanProperty bp) { Setter setter = bp.getSetter(true); if (setter == null) { return null; } Class type = setter.getSetterRawType(); Object newInstance; try { newInstance = ClassUtil.newInstance(type); } catch (Exception ex) { if (isSilent) { return null; } throw new BeanException(\"Invalid property: \" + bp.name, bp, ex); } newInstance = invokeSetter(setter, bp, newInstance); return newInstance; } \nResponse:", "ground_truth": "Creates new instance for current property name through its setter.\nIt uses default constructor!", "predict": " Create a new instance of the bean property bean. @param bp the bean property bean @return the new instance of the bean property bean\n*/"}
{"ID": 1293, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class extractType(final BeanProperty bp) { Getter getter = bp.getGetter(isDeclared); if (getter != null) { if (bp.index != null) { Class type = getter.getGetterRawComponentType(); return type == null ? Object.class : type; } return getter.getGetterRawType(); } return null; // this should not happens } \nResponse:", "ground_truth": "Extracts type of current property.", "predict": " Extract type from getter. @param bp BeanProperty @return Type of the getter or null if not found."}
{"ID": 1294, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void stop(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { final HttpSession httpSession = servletRequest.getSession(false); if (httpSession != null) { httpSession.removeAttribute(AUTH_SESSION_NAME); } final Cookie cookie = ServletUtil.getCookie(servletRequest, AUTH_COOKIE_NAME); if (cookie == null) { return; } cookie.setMaxAge(0); cookie.setPath(\"/\"); servletResponse.addCookie(cookie); } \nResponse:", "ground_truth": "Stops the user session by removing it from the http session and invalidating the cookie.", "predict": " Signs out the current authenticated user. Signs out the current authenticated user by removing the authentication cookie and setting the remember-me cookie to expire. Also clears the authentication session. Leaves the user logged out in the database. @param servletRequest The servlet request. @param servletResponse The servlet response."}
{"ID": 1295, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse) { final HttpSession httpSession = httpServletRequest.getSession(true); httpSession.setAttribute(AUTH_SESSION_NAME, this); final Cookie cookie = new Cookie(AUTH_COOKIE_NAME, authTokenValue); //cookie.setDomain(SSORealm.SSO_DOMAIN); cookie.setMaxAge(cookieMaxAge); cookie.setPath(\"/\"); httpServletResponse.addCookie(cookie); } \nResponse:", "ground_truth": "Starts new user session.", "predict": " Authenticate the user and obtain a SSO cookie. @param httpServletRequest The HTTP request. @param httpServletResponse The HTTP response."}
{"ID": 1296, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Date toDate(final LocalDate localDate) { return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant()); } \nResponse:", "ground_truth": "Converts local date to Date.", "predict": " Convert LocalDate to Date. @param localDate LocalDate to convert. @return Date."}
{"ID": 1297, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Calendar toCalendar(final LocalDateTime localDateTime) { return GregorianCalendar.from(ZonedDateTime.of(localDateTime, ZoneId.systemDefault())); } \nResponse:", "ground_truth": "Converts local date time to Calendar.", "predict": " Convert LocalDateTime to GregorianCalendar. @param localDateTime LocalDateTime to convert. @return GregorianCalendar."}
{"ID": 1298, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class defineProxy(final Class target) { ProxyProxettaFactory builder = proxetta.proxy(); builder.setTarget(target); return builder.define(); } \nResponse:", "ground_truth": "Generates new class.", "predict": " Define a proxy class for the given target class. @param target Target class. @return Proxy class."}
{"ID": 1299, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Check check) { String name = check.getName(); List<Check> list = map.computeIfAbsent(name, k -> new ArrayList<>()); list.add(check); } \nResponse:", "ground_truth": "Adds validation checks.", "predict": " Add a check to the registry. @param check The check to add.\n*/"}
{"ID": 1300, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ValidationContext resolveFor(final Class<?> target) { ValidationContext vc = new ValidationContext(); vc.addClassChecks(target); return vc; } \nResponse:", "ground_truth": "Resolve validation context for provided target class.\n@see #addClassChecks(Class)", "predict": " Resolve the validation context for a given target class. Useful for injecting a validation context into a DI container. @param target The target class. @return The validation context.\n*/"}
{"ID": 1301, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addClassChecks(final Class target) { final List<Check> list = cache.get(target, () -> { final List<Check> newList = new ArrayList<>(); final ClassDescriptor cd = ClassIntrospector.get().lookup(target); final PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { collectPropertyAnnotationChecks(newList, propertyDescriptor); } return newList; }); addAll(list); } \nResponse:", "ground_truth": "Parses class annotations and adds all checks.\n@see #resolveFor(Class)", "predict": " Collects all relevant annotations for a given class and adds them to the checks. @param target The target class. Shall not be <code>null</code>.\n"}
{"ID": 1302, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void collectPropertyAnnotationChecks(final List<Check> annChecks, final PropertyDescriptor propertyDescriptor) { FieldDescriptor fd = propertyDescriptor.getFieldDescriptor(); if (fd != null) { Annotation[] annotations = fd.getField().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } MethodDescriptor md = propertyDescriptor.getReadMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } md = propertyDescriptor.getWriteMethodDescriptor(); if (md != null) { Annotation[] annotations = md.getMethod().getAnnotations(); collectAnnotationChecks(annChecks, propertyDescriptor.getType(), propertyDescriptor.getName(), annotations); } } \nResponse:", "ground_truth": "Process all annotations of provided properties.", "predict": " Collects annotations from the given property descriptors. @param annChecks The annotation checks to populate. @param propertyDescriptor The property descriptor to introspect."}
{"ID": 1303, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected void collectAnnotationChecks(final List<Check> annChecks, final Class targetType, final String targetName, final Annotation[] annotations) { for (Annotation annotation : annotations) { Constraint c = annotation.annotationType().getAnnotation(Constraint.class); Class<? extends ValidationConstraint> constraintClass; if (c == null) { // if constraint is not available, try lookup String constraintClassName = annotation.annotationType().getName() + \"Constraint\"; try { constraintClass = ClassLoaderUtil.loadClass(constraintClassName, this.getClass().getClassLoader()); } catch (ClassNotFoundException ingore) { continue; } } else { constraintClass = c.value(); } ValidationConstraint vc; try { vc = newConstraint(constraintClass, targetType); } catch (Exception ex) { throw new VtorException(\"Invalid constraint: \" + constraintClass.getClass().getName(), ex); } vc.configure(annotation); Check check = new Check(targetName, vc); copyDefaultCheckProperties(check, annotation); annChecks.add(check); } } \nResponse:", "ground_truth": "Collect annotations for some target.", "predict": " Collect annotation checks. @param annChecks the ann checks @param targetType the target type @param targetName the target name @param annotations the annotations\n*/"}
{"ID": 1304, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void copyDefaultCheckProperties(final Check destCheck, final Annotation annotation) { Integer severity = (Integer) ClassUtil.readAnnotationValue(annotation, ANN_SEVERITY); destCheck.setSeverity(severity.intValue()); String[] profiles = (String[]) ClassUtil.readAnnotationValue(annotation, ANN_PROFILES); destCheck.setProfiles(profiles); String message = (String) ClassUtil.readAnnotationValue(annotation, ANN_MESSAGE); destCheck.setMessage(message); } \nResponse:", "ground_truth": "Copies default properties from annotation to the check.", "predict": " Copies the severity, profiles and message from the default check. @param destCheck The destination check. @param annotation The annotation to copy from."}
{"ID": 1305, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String encodeUriComponent(final String source, final String encoding, final URIPart uriPart) { if (source == null) { return null; } byte[] bytes = encodeBytes(StringUtil.getBytes(source, encoding), uriPart); char[] chars = new char[bytes.length]; for (int i = 0; i < bytes.length; i++) { chars[i] = (char) bytes[i]; } return new String(chars); } \nResponse:", "ground_truth": "Encodes single URI component.", "predict": " Encode a URI component. @param source The source string. @param encoding The encoding. @param uriPart The URI part. @return The encoded string."}
{"ID": 1306, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encode(final String string, final String encoding) { return encodeUriComponent(string, encoding, URIPart.UNRESERVED); } \nResponse:", "ground_truth": "Encodes string using default RFCP rules.", "predict": " Encode a string using the reserved characters in the URI component syntax. @param string The string to encode. @param encoding The encoding to use. @return The encoded string.\n*/"}
{"ID": 1307, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeScheme(final String scheme, final String encoding) { return encodeUriComponent(scheme, encoding, URIPart.SCHEME); } \nResponse:", "ground_truth": "Encodes the given URI scheme with the given encoding.", "predict": " Encode scheme component of URI. @param scheme Scheme to encode. @param encoding Encoding to use. @return Encoded scheme.\n*/"}
{"ID": 1308, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeHost(final String host, final String encoding) { return encodeUriComponent(host, encoding, URIPart.HOST); } \nResponse:", "ground_truth": "Encodes the given URI host with the given encoding.", "predict": " Percent encode the host component of a URI. Expects percent-encoded input. Percent encodes everything except unreserved characters, the characters \"[\", \"]\", and the characters \"?\", \"=\", \"@\", and \"&\". Reserved characters remain percent-encoded. Expects non-null and non-empty input. Percent encodes everything except unreserved characters, the characters \"[\", \"]\", and the characters \"?\", \"=\", \"@\", and \"&\". Reserved characters remain percent-encoded. Percent encodes everything except unreserved characters, the characters \"[\", \"]\", and the characters \"?\", \"=\", \"@\", and \"&\". Reserved characters remain percent-encoded. Percent encodes everything except unreserved characters, the characters \"[\", \"]\", and the characters \"?\", \"=\", \"@\", and \"&\". Reserved characters remain percent-encoded. Percent encodes everything except unreserved characters, the characters \"[\", \"]\", and the characters \"?\", \"=\", \"@\", and \"&\". Reserved characters remain percent-enc"}
{"ID": 1309, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodePort(final String port, final String encoding) { return encodeUriComponent(port, encoding, URIPart.PORT); } \nResponse:", "ground_truth": "Encodes the given URI port with the given encoding.", "predict": " Encode the given port into a URI component using the given encoding scheme. @param port Port to encode. @param encoding Encoding scheme to use. @return Encoded URI port."}
{"ID": 1310, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodePath(final String path, final String encoding) { return encodeUriComponent(path, encoding, URIPart.PATH); } \nResponse:", "ground_truth": "Encodes the given URI path with the given encoding.", "predict": " Encode the provided path using the provided encoding. @param path The path to encode. @param encoding The encoding to use. @return The encoded path."}
{"ID": 1311, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeQuery(final String query, final String encoding) { return encodeUriComponent(query, encoding, URIPart.QUERY); } \nResponse:", "ground_truth": "Encodes the given URI query with the given encoding.", "predict": " Encode a query string component. @param query Query string component to encode. @param encoding Encoding to use. @return Encoded query string component.\n*/"}
{"ID": 1312, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeQueryParam(final String queryParam, final String encoding) { return encodeUriComponent(queryParam, encoding, URIPart.QUERY_PARAM); } \nResponse:", "ground_truth": "Encodes the given URI query parameter with the given encoding.", "predict": " Percent encodes a query parameter. Percent encodes unreserved characters except for plus sign and minus sign. Reserved characters are percent-encoded. Percent encodes spaces as plus signs. Percent encodes plus signs as plus signs. Percent encodes sharp S characters as hyphens. Percent encodes apostrophes as slashes. Percent encodes everything else as itself. @param queryParam The query parameter to encode. @param encoding The percent encoding scheme to use. @return The percent-encoded query parameter."}
{"ID": 1313, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeFragment(final String fragment, final String encoding) { return encodeUriComponent(fragment, encoding, URIPart.FRAGMENT); } \nResponse:", "ground_truth": "Encodes the given URI fragment with the given encoding.", "predict": " Percent-encodes a URI fragment according to RFC 3986. Whereas percent escaping applies to reserved characters, unreserved characters remain untouched. Whereas percent escaping applies to reserved characters, unreserved characters remain untouched. Therefore, percent escaping is preferred over percent escaping. Whereas unreserved characters remain untouched, the percent character itself is percent-encoded. Therefore, percent escaping is preferred over percent escaping. @param fragment The fragment to percent-encode. @param encoding The percent-encoding scheme to employ. @return The percent-encoded fragment."}
{"ID": 1314, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected HashMap<String, PropertyDescriptor> inspectProperties() { boolean scanAccessible = classDescriptor.isScanAccessible(); Class type = classDescriptor.getType(); HashMap<String, PropertyDescriptor> map = new HashMap<>(); Method[] methods = scanAccessible ? ClassUtil.getAccessibleMethods(type) : ClassUtil.getSupportedMethods(type); for (int iteration = 0; iteration < 2; iteration++) { // first find the getters, and then the setters! for (Method method : methods) { if (Modifier.isStatic(method.getModifiers())) { continue; // ignore static methods } boolean add = false; boolean issetter = false; String propertyName; if (iteration == 0) { propertyName = ClassUtil.getBeanPropertyGetterName(method); if (propertyName != null) { add = true; issetter = false; } } else { propertyName = ClassUtil.getBeanPropertySetterName(method); if (propertyName != null) { add = true; issetter = true; } } if (add) { MethodDescriptor methodDescriptor = classDescriptor.getMethodDescriptor(method.getName(), method.getParameterTypes(), true); addProperty(map, propertyName, methodDescriptor, issetter); } } } if (classDescriptor.isIncludeFieldsAsProperties()) { FieldDescriptor[] fieldDescriptors = classDescriptor.getAllFieldDescriptors(); String[] prefix = classDescriptor.getPropertyFieldPrefix(); for (FieldDescriptor fieldDescriptor : fieldDescriptors) { Field field = fieldDescriptor.getField(); if (Modifier.isStatic(field.getModifiers())) { continue; // ignore static fields } String name = field.getName(); if (prefix != null) { for (String p : prefix) { if (!name.startsWith(p)) { continue; } name = name.substring(p.length()); break; } } if (!map.containsKey(name)) { // add missing field as a potential property map.put(name, createPropertyDescriptor(name, fieldDescriptor)); } } } return map; } \nResponse:", "ground_truth": "Inspects all properties of target type.", "predict": " Inspects the bean class and extracts all the readable properties.\n * @return a map of readable properties\n */"}
{"ID": 1315, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyDescriptor[] getAllPropertyDescriptors() { if (allProperties == null) { PropertyDescriptor[] allProperties = new PropertyDescriptor[propertyDescriptors.size()]; int index = 0; for (PropertyDescriptor propertyDescriptor : propertyDescriptors.values()) { allProperties[index] = propertyDescriptor; index++; } Arrays.sort(allProperties, new Comparator<PropertyDescriptor>() { @Override public int compare(final PropertyDescriptor pd1, final PropertyDescriptor pd2) { return pd1.getName().compareTo(pd2.getName()); } }); this.allProperties = allProperties; } return allProperties; } \nResponse:", "ground_truth": "Returns all property descriptors.\nProperties are sorted by name.", "predict": " Returns all PropertyDescriptors in the Introspector, including ones contributed by BeanInfo classes. This method is meant to be used when no explicit Introspector is available. The returned PropertyDescriptors may not be the same as those obtained by calling the getPropertyDescriptors() method, as they reflect changes made to the bean descriptor through the Introspector. Therefore, they should not be depended upon as definitive representations. However, they will accurately reflect the bean's introspection results. @return all PropertyDescriptors in the Introspector, including ones contributed by BeanInfo classes. May return null if no Introspectable beans have been introspected.\n"}
{"ID": 1316, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Cookie[] cookies() { List<String> newCookies = headers(\"set-cookie\"); if (newCookies == null) { return new Cookie[0]; } List<Cookie> cookieList = new ArrayList<>(newCookies.size()); for (String cookieValue : newCookies) { try { Cookie cookie = new Cookie(cookieValue); cookieList.add(cookie); } catch (Exception ex) { // ignore } } return cookieList.toArray(new Cookie[0]); } \nResponse:", "ground_truth": "Returns list of valid cookies sent from server.\nIf no cookie found, returns an empty array. Invalid cookies are ignored.", "predict": " Obtains all cookies sent by the server. Contrary to popular belief, RFC 2965 doesn't specify what to do when multiple Cookie headers are sent for a single request/response pair. To my knowledge, all browsers interpret this as only the first Cookie being used. Additionally, Firefox's Cookie Management Extension interprets all Cookies as being sent. @return Possibly empty Cookie[] containing all cookies sent by the server."}
{"ID": 1317, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse unzip() { String contentEncoding = contentEncoding(); if (contentEncoding != null && contentEncoding().equals(\"gzip\")) { if (body != null) { headerRemove(HEADER_CONTENT_ENCODING); try { ByteArrayInputStream in = new ByteArrayInputStream(body.getBytes(StringPool.ISO_8859_1)); GZIPInputStream gzipInputStream = new GZIPInputStream(in); ByteArrayOutputStream out = new ByteArrayOutputStream(); StreamUtil.copy(gzipInputStream, out); body(out.toString(StringPool.ISO_8859_1)); } catch (IOException ioex) { throw new HttpException(ioex); } } } return this; } \nResponse:", "ground_truth": "Unzips GZip-ed body content, removes the content-encoding header\nand sets the new content-length value.", "predict": " Unzip compressed content. Useful for downloading huge files without consuming massive amounts of memory. @return Fluent API\n*/"}
{"ID": 1318, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse close() { HttpConnection httpConnection = httpRequest.httpConnection; if (httpConnection != null) { httpConnection.close(); httpRequest.httpConnection = null; } return this; } \nResponse:", "ground_truth": "Closes requests connection if it was open.\nShould be called when using keep-alive connections.\nOtherwise, connection will be already closed.", "predict": " Close the connection. Closing the connection will automatically abort the request. Closing a connection that has already been closed has no effect. Closing a connection that has never been opened has no effect. Closing a connection that has been aborted has no effect. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException. Closing a connection that has been aborted will throw an IllegalStateException."}
{"ID": 1319, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final Scope referenceScope) { Class<? extends Scope> refScopeType = referenceScope.getClass(); if (refScopeType == ProtoScope.class) { return true; } if (refScopeType == SingletonScope.class) { return true; } if (refScopeType == ThreadLocalScope.class) { return true; } return false; } \nResponse:", "ground_truth": "Defines allowed referenced scopes that can be injected into the\nthread-local scoped bean.", "predict": " Accepts ProtoScope or SingletonScope or ThreadLocalScope scopes. Always returns true.\n*/\npublic boolean accept(final Scope referenceScope) {\n\treturn true;\n}\n}\n"}
{"ID": 1320, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void printRoutes(final int width) { final ActionsManager actionsManager = webApp.madvocContainer().lookupComponent(ActionsManager.class); final List<ActionRuntime> actions = actionsManager.getAllActionRuntimes(); final Map<String, String> aliases = actionsManager.getAllAliases(); if (actions.isEmpty()) { return; } final Print print = new Print(); print.line(\"Routes\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionMethod = ar.getActionMethod(); print.out(Chalk256.chalk().yellow(), actionMethod == null ? \"*\" : actionMethod, 7); print.space(); final String signature = ClassUtil.getShortClassName( ProxettaUtil.resolveTargetClass(ar.getActionClass()), 2) + '#' + ar.getActionClassMethod().getName(); print.outLeftRightNewLine( Chalk256.chalk().green(), ar.getActionPath(), Chalk256.chalk().blue(), signature, width - 7 - 1 ); }); if (!aliases.isEmpty()) { print.line(\"Aliases\", width); actions.stream() .sorted(Comparator.comparing( actionRuntime -> actionRuntime.getActionPath() + ' ' + actionRuntime.getActionMethod())) .forEach(ar -> { final String actionPath = ar.getActionPath(); for (final Map.Entry<String, String> entry : aliases.entrySet()) { if (entry.getValue().equals(actionPath)) { print.space(8); print.outLeftRightNewLine( Chalk256.chalk().green(), entry.getValue(), Chalk256.chalk().blue(), entry.getKey(), width - 8 ); } } }); } print.line(width); } \nResponse:", "ground_truth": "Prints routes to console.", "predict": " Print routes. @param width Width of the banner."}
{"ID": 1321, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] encrypt(final byte[] content) { FastByteBuffer fbb = new FastByteBuffer(); int length = content.length + 1; int blockCount = length / blockSizeInBytes; int remaining = length; int offset = 0; for (int i = 0; i < blockCount; i++) { if (remaining == blockSizeInBytes) { break; } byte[] encrypted = encryptBlock(content, offset); fbb.append(encrypted); offset += blockSizeInBytes; remaining -= blockSizeInBytes; } if (remaining != 0) { // process remaining bytes byte[] block = new byte[blockSizeInBytes]; System.arraycopy(content, offset, block, 0, remaining - 1); block[remaining - 1] = TERMINATOR; byte[] encrypted = encryptBlock(block, 0); fbb.append(encrypted); } return fbb.toArray(); } \nResponse:", "ground_truth": "Encrypts complete content, block by block.", "predict": " Encrypts the content using AES-128 in CBC mode. @param content The content to encrypt. Shall not be null. Shall be readable. @return The encrypted content. Never null. May be empty."}
{"ID": 1322, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public byte[] decrypt(final byte[] encryptedContent) { FastByteBuffer fbb = new FastByteBuffer(); int length = encryptedContent.length; int blockCount = length / blockSizeInBytes; int offset = 0; for (int i = 0; i < blockCount - 1; i++) { byte[] decrypted = decryptBlock(encryptedContent, offset); fbb.append(decrypted); offset += blockSizeInBytes; } // process last block byte[] decrypted = decryptBlock(encryptedContent, offset); // find terminator int ndx = blockSizeInBytes - 1; while (ndx >= 0) { if (decrypted[ndx] == TERMINATOR) { break; } ndx--; } fbb.append(decrypted, 0, ndx); return fbb.toArray(); } \nResponse:", "ground_truth": "Decrypts the whole content, block by block.", "predict": " Decrypt AES256 CTR ECB encrypted content. Upon return, the encrypted content is truncated to exclude the trailing terminator. @param encryptedContent The encrypted content. @return The decrypted content."}
{"ID": 1323, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object map2bean(final Map map, Class targetType) { Object target = null; // create targets type String className = (String) map.get(classMetadataName); if (className == null) { if (targetType == null) { // nothing to do, no information about target type found target = map; } } else { checkClassName(jsonParser.classnameWhitelist, className); try { targetType = ClassLoaderUtil.loadClass(className); } catch (ClassNotFoundException cnfex) { throw new JsonException(cnfex); } } if (target == null) { target = jsonParser.newObjectInstance(targetType); } ClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass()); boolean targetIsMap = target instanceof Map; for (Object key : map.keySet()) { String keyName = key.toString(); if (classMetadataName != null) { if (keyName.equals(classMetadataName)) { continue; } } PropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared); if (!targetIsMap && pd == null) { // target property does not exist, continue continue; } // value is one of JSON basic types, like Number, Map, List... Object value = map.get(key); Class propertyType = pd == null ? null : pd.getType(); Class componentType = pd == null ? null : pd.resolveComponentType(true); if (value != null) { if (value instanceof List) { if (componentType != null && componentType != String.class) { value = generifyList((List) value, componentType); } } else if (value instanceof Map) { // if the value we want to inject is a Map... if (!ClassUtil.isTypeOf(propertyType, Map.class)) { // ... and if target is NOT a map value = map2bean((Map) value, propertyType); } else { // target is also a Map, but we might need to generify it Class keyType = pd == null ? null : pd.resolveKeyType(true); if (keyType != String.class || componentType != String.class) { // generify value = generifyMap((Map) value, keyType, componentType); } } } } if (targetIsMap) { ((Map)target).put(keyName, value); } else { try { setValue(target, pd, value); } catch (Exception ignore) { ignore.printStackTrace(); } } } return target; } \nResponse:", "ground_truth": "Converts map to target type.", "predict": " Convert Map to bean. @param map Map to convert. @param targetType Target type. @return Converted bean."}
{"ID": 1324, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object generifyList(final List list, final Class componentType) { for (int i = 0; i < list.size(); i++) { Object element = list.get(i); if (element != null) { if (element instanceof Map) { Object bean = map2bean((Map) element, componentType); list.set(i, bean); } else { Object value = convert(element, componentType); list.set(i, value); } } } return list; } \nResponse:", "ground_truth": "Converts type of all list elements to match the component type.", "predict": " Convert a list of Maps to a list of beans. @param list The list to convert. @param componentType The component type of the list. @return The converted list."}
{"ID": 1325, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setValue(final Object target, final PropertyDescriptor pd, Object value) throws InvocationTargetException, IllegalAccessException { Class propertyType; Setter setter = pd.getSetter(true); if (setter != null) { if (value != null) { propertyType = setter.getSetterRawType(); value = jsonParser.convertType(value, propertyType); } setter.invokeSetter(target, value); } } \nResponse:", "ground_truth": "Sets the property value.", "predict": " Setter for the property value. @param target the target object. @param pd the property descriptor. @param value the value to set. @throws InvocationTargetException if the setter throws an exception. @throws IllegalAccessException if the setter is inaccessible.\n*/"}
{"ID": 1326, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <K,V> Map<K, V> generifyMap(final Map<Object, Object> map, final Class<K> keyType, final Class<V> valueType) { if (keyType == String.class) { // only value type is changed, we can make value replacements for (Map.Entry<Object, Object> entry : map.entrySet()) { Object value = entry.getValue(); Object newValue = convert(value, valueType); if (value != newValue) { entry.setValue(newValue); } } return (Map<K, V>) map; } // key is changed too, we need a new map Map<K, V> newMap = new HashMap<>(map.size()); for (Map.Entry<Object, Object> entry : map.entrySet()) { Object key = entry.getKey(); Object newKey = convert(key, keyType); Object value = entry.getValue(); Object newValue = convert(value, valueType); newMap.put((K)newKey, (V)newValue); } return newMap; } \nResponse:", "ground_truth": "Change map elements to match key and value types.", "predict": " Convert map keys and values to generic ones. @param map Map to convert. @param keyType Key type. @param valueType Value type. @return Converted map."}
{"ID": 1327, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int compareTo(final Object o) { DbEntityColumnDescriptor that = (DbEntityColumnDescriptor) o; if (this.isId != that.isId) { return this.isId ? -1 : 1; // IDs should be the first in the array } return this.columnName.compareTo(that.columnName); } \nResponse:", "ground_truth": "Compares two column descriptors. Identity columns should be the first on the list.\nEach group then will be sorted by column name.", "predict": " Natural ordering is based upon column name. Natural ordering is inconsistent with equals, however, so we cannot rely upon either.\n */"}
{"ID": 1328, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpBrowser setDefaultHeader(final String name, final String value) { defaultHeaders.addHeader(name, value); return this; } \nResponse:", "ground_truth": "Adds default header to all requests.", "predict": " Set the default header for every request made by this browser. @param name The header name. @param value The header value. @return Browser Fluent API."}
{"ID": 1329, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public HttpResponse sendRequest(HttpRequest httpRequest) { elapsedTime = System.currentTimeMillis(); // send request httpRequest.followRedirects(false); while (true) { this.httpRequest = httpRequest; HttpResponse previousResponse = this.httpResponse; this.httpResponse = null; addDefaultHeaders(httpRequest); addCookies(httpRequest); // send request if (catchTransportExceptions) { try { this.httpResponse = _sendRequest(httpRequest, previousResponse); } catch (HttpException httpException) { httpResponse = new HttpResponse(); httpResponse.assignHttpRequest(httpRequest); httpResponse.statusCode(503); httpResponse.statusPhrase(\"Service unavailable. \" + ExceptionUtil.message(httpException)); } } else { this.httpResponse =_sendRequest(httpRequest, previousResponse); } readCookies(httpResponse); int statusCode = httpResponse.statusCode(); // 301: moved permanently if (statusCode == 301) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 302: redirect, 303: see other if (statusCode == 302 || statusCode == 303) { String newPath = httpResponse.location(); if (newPath == null) { break; } httpRequest = HttpRequest.get(newPath); continue; } // 307: temporary redirect, 308: permanent redirect if (statusCode == 307 || statusCode == 308) { String newPath = httpResponse.location(); if (newPath == null) { break; } String originalMethod = httpRequest.method(); httpRequest = new HttpRequest() .method(originalMethod) .set(newPath); continue; } break; } elapsedTime = System.currentTimeMillis() - elapsedTime; return this.httpResponse; } \nResponse:", "ground_truth": "Sends new request as a browser. Before sending,\nall browser cookies are added to the request.\nAfter sending, the cookies are read from the response.\nMoreover, status codes 301 and 302 are automatically\nhandled. Returns very last response.", "predict": " Send the HTTP request. @param httpRequest The HTTP request to send. @return The HTTP response."}
{"ID": 1330, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected HttpResponse _sendRequest(final HttpRequest httpRequest, final HttpResponse previouseResponse) { if (!keepAlive) { httpRequest.open(httpConnectionProvider); } else { // keeping alive if (previouseResponse == null) { httpRequest.open(httpConnectionProvider).connectionKeepAlive(true); } else { httpRequest.keepAlive(previouseResponse, true); } } return httpRequest.send(); } \nResponse:", "ground_truth": "Opens connection and sends a response.", "predict": " Sending request to the server. @param httpRequest HttpRequest to send. @param previouseResponse Previous response. @return HttpResponse from server.\n*/"}
{"ID": 1331, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addDefaultHeaders(final HttpRequest httpRequest) { for (Map.Entry<String, String> entry : defaultHeaders.entries()) { String name = entry.getKey(); if (!httpRequest.headers.contains(name)) { httpRequest.headers.add(name, entry.getValue()); } } } \nResponse:", "ground_truth": "Add default headers to the request. If request already has a header set,\ndefault header will be ignored.", "predict": " Adds default headers to the request. These are things like User-Agent, Accept, etc.\n@param httpRequest The request to add the default headers to.\n*/"}
{"ID": 1332, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void readCookies(final HttpResponse httpResponse) { Cookie[] newCookies = httpResponse.cookies(); for (Cookie cookie : newCookies) { cookies.add(cookie.getName(), cookie); } } \nResponse:", "ground_truth": "Reads cookies from response and adds to cookies list.", "predict": " Read cookies from the response. @param httpResponse The HTTP response.\n*/"}
{"ID": 1333, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addCookies(final HttpRequest httpRequest) { // prepare all cookies List<Cookie> cookiesList = new ArrayList<>(); if (!cookies.isEmpty()) { for (Map.Entry<String, Cookie> cookieEntry : cookies) { cookiesList.add(cookieEntry.getValue()); } httpRequest.cookies(cookiesList.toArray(new Cookie[0])); } } \nResponse:", "ground_truth": "Add cookies to the request.", "predict": " Add cookies to httpRequest. @param httpRequest HttpRequest"}
{"ID": 1334, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String sendMail(final Email email) { try { final MimeMessage msg = createMessage(email); getService().sendMessage(msg, msg.getAllRecipients()); return msg.getMessageID(); } catch (final MessagingException msgexc) { throw new MailException(\"Failed to send email: \" + email, msgexc); } } \nResponse:", "ground_truth": "Prepares message and sends it. Returns Message ID of sent email.\n\n@param email {@link Email} to send.\n@return String representing message ID.", "predict": " Send an email using the SMTP server configured in the mail server bean. @param email The email to send. @return The Message-ID header of the sent email.\n*/"}
{"ID": 1335, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setSubject(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { if (emailWithData.subjectEncoding() != null) { msgToSet.setSubject(emailWithData.subject(), emailWithData.subjectEncoding()); } else { msgToSet.setSubject(emailWithData.subject()); } } \nResponse:", "ground_truth": "Sets subject in msgToSet from subject in emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Set Subject of the email. @param emailWithData Email to enrich. @param msgToSet MimeMessage to enrich. @throws MessagingException MessagingException thrown.\n*/"}
{"ID": 1336, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setSentDate(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { Date date = emailWithData.sentDate(); if (date == null) { date = new Date(); } msgToSet.setSentDate(date); } \nResponse:", "ground_truth": "Sets sent date in msgToSet with sent date from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Set the sent date on the email. @param emailWithData the email to set the sent date on. @param msgToSet the mime message to set the sent date on. @throws MessagingException thrown if there is a messaging exception setting the sent date."}
{"ID": 1337, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setHeaders(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final Map<String, String> headers = emailWithData.headers(); if (headers != null) { for (final Map.Entry<String, String> entry : headers.entrySet()) { msgToSet.setHeader(entry.getKey(), entry.getValue()); } } } \nResponse:", "ground_truth": "Sets headers in msgToSet with headers from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Set headers on the outgoing message. @param emailWithData the email with data @param msgToSet the outgoing message to set headers on @throws MessagingException the messaging exception\n*/"}
{"ID": 1338, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setPeople(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { msgToSet.setFrom(emailWithData.from().toInternetAddress()); msgToSet.setReplyTo(EmailAddress.convert(emailWithData.replyTo())); setRecipients(emailWithData, msgToSet); } \nResponse:", "ground_truth": "Sets FROM, REPLY-TO and recipients.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure", "predict": " Set the From, ReplyTo, and recipients of the email. Also set the Subject and Content-Type. @param emailWithData The EmailWithData to extract the necessary information from. @param msgToSet The MimeMessage to set the From, ReplyTo, and recipients in. @throws MessagingException Something went wrong setting the From, ReplyTo, or recipients.\n*/"}
{"ID": 1339, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setRecipients(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { // TO final InternetAddress[] to = EmailAddress.convert(emailWithData.to()); if (to.length > 0) { msgToSet.setRecipients(RecipientType.TO, to); } // CC final InternetAddress[] cc = EmailAddress.convert(emailWithData.cc()); if (cc.length > 0) { msgToSet.setRecipients(RecipientType.CC, cc); } // BCC final InternetAddress[] bcc = EmailAddress.convert(emailWithData.bcc()); if (bcc.length > 0) { msgToSet.setRecipients(RecipientType.BCC, bcc); } } \nResponse:", "ground_truth": "Sets TO, CC and BCC in msgToSet with TO, CC and BCC from emailWithData.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": " Set recipients. @param emailWithData the email with data @param msgToSet the msg to set @throws MessagingException the messaging exception\n*/"}
{"ID": 1340, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addBodyData(final Email emailWithData, final MimeMessage msgToSet) throws MessagingException { final List<EmailMessage> messages = emailWithData.messages(); final int totalMessages = messages.size(); // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List final List<EmailAttachment<? extends DataSource>> attachments = new ArrayList<>(emailWithData.attachments()); if (attachments.isEmpty() && totalMessages == 1) { // special case: no attachments and just one content setContent(messages.get(0), msgToSet); } else { final MimeMultipart multipart = new MimeMultipart(); final MimeMultipart msgMultipart = new MimeMultipart(ALTERNATIVE); multipart.addBodyPart(getBaseBodyPart(msgMultipart)); for (final EmailMessage emailMessage : messages) { msgMultipart.addBodyPart(getBodyPart(emailMessage, attachments)); } addAnyAttachments(attachments, multipart); msgToSet.setContent(multipart); } } \nResponse:", "ground_truth": "Adds message data and attachments.\n\n@param emailWithData {@link Email} with data\n@param msgToSet      {@link MimeMessage} to set data into.\n@throws MessagingException if there is a failure.", "predict": " Actually adds the body data to the email message. @param emailWithData the email with data to add the body data to. @param msgToSet the email message to add the body data to. @throws MessagingException thrown if there is a messaging error.\n*/"}
{"ID": 1341, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setContent(final EmailMessage emailWithData, final Part partToSet) throws MessagingException { partToSet.setContent(emailWithData.getContent(), emailWithData.getMimeType() + CHARSET + emailWithData.getEncoding()); } \nResponse:", "ground_truth": "Sets emailWithData content into msgToSet.\n\n@param emailWithData {@link EmailMessage} with data.\n@param partToSet     {@link Part} to set data into.\n@throws MessagingException if there is a failure.", "predict": " Set the content of the email. @param emailWithData the email with data @param partToSet the part to set @throws MessagingException the messaging exception\n*/"}
{"ID": 1342, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MimeBodyPart createAttachmentBodyPart(final EmailAttachment<? extends DataSource> attachment) throws MessagingException { final MimeBodyPart part = new MimeBodyPart(); final String attachmentName = attachment.getEncodedName(); if (attachmentName != null) { part.setFileName(attachmentName); } part.setDataHandler(new DataHandler(attachment.getDataSource())); if (attachment.getContentId() != null) { part.setContentID(StringPool.LEFT_CHEV + attachment.getContentId() + StringPool.RIGHT_CHEV); } if (attachment.isInline()) { part.setDisposition(INLINE); } return part; } \nResponse:", "ground_truth": "Creates attachment body part. Handles regular and inline attachments.\n\n@param attachment Body part {@link EmailAttachment}.\n@return {@link MimeBodyPart} which represents body part attachment.\n@throws MessagingException if there is a failure.", "predict": " Create attachment body part. @param attachment the attachment @return the mime body part\n * @throws MessagingException the messaging exception\n*/"}
{"ID": 1343, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String getContentType(final String dataHeader) { String token = \"Content-Type:\"; int start = dataHeader.indexOf(token); if (start == -1) { return StringPool.EMPTY; } start += token.length(); return dataHeader.substring(start).trim(); } \nResponse:", "ground_truth": "Strips content type information from requests data header.\n@param dataHeader data header string\n@return content type or an empty string if no content type defined", "predict": " Gets the content type. @param dataHeader the data header @return the content type"}
{"ID": 1344, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void saveResultSet(final ResultSet rs) { if (resultSets == null) { resultSets = new HashSet<>(); } resultSets.add(rs); } \nResponse:", "ground_truth": "Stores result set.", "predict": " Save the given result set. @param rs The result set to save.\n*/"}
{"ID": 1345, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q closeAllResultSets() { final SQLException sex = closeQueryResultSets(); if (sex != null) { throw new DbSqlException(\"Close associated ResultSets error\", sex); } return _this(); } \nResponse:", "ground_truth": "Closes all result sets created by this query. Query remains active.", "predict": " Closing all ResultSets associated with current query. Usually you don't need to call manually this method. However, if you want to close all ResultSets manually, you can do it by calling this method. @return Current object."}
{"ID": 1346, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SQLException closeQuery() { SQLException sqlException = closeQueryResultSets(); if (statement != null) { try { statement.close(); } catch (SQLException sex) { if (sqlException == null) { sqlException = sex; } else { sqlException.setNextException(sex); } } statement = null; } query = null; queryState = CLOSED; return sqlException; } \nResponse:", "ground_truth": "Closes all assigned result sets and then closes the query. Query becomes closed.", "predict": " Close the query. @return The exception, if any."}
{"ID": 1347, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings({\"ClassReferencesSubclass\"}) public void close() { final SQLException sqlException = closeQuery(); connection = null; if (this.session != null) { this.session.detachQuery(this); } if (sqlException != null) { throw new DbSqlException(\"Close query error\", sqlException); } } \nResponse:", "ground_truth": "Closes the query and all created results sets and detaches itself from the session.", "predict": " Close query. @throws DbSqlException error."}
{"ID": 1348, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setFetchSize(final int rows) { checkNotClosed(); this.fetchSize = rows; if (statement != null) { try { statement.setFetchSize(fetchSize); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set fetch size: \" + fetchSize, sex); } } return _this(); } \nResponse:", "ground_truth": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when\nmore rows are needed. The number of rows specified affects only result sets created using this statement.\nIf the value specified is zero, then the hint is ignored. The default value is zero.\n@see Statement#setFetchSize(int)", "predict": " Set fetch size. @param rows New fetch size. @return Current object."}
{"ID": 1349, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setMaxRows(final int maxRows) { checkNotClosed(); this.maxRows = maxRows; if (statement != null) { try { statement.setMaxRows(maxRows); } catch (SQLException sex) { throw new DbSqlException(this, \"Unable to set max rows: \" + maxRows, sex); } } return _this(); } \nResponse:", "ground_truth": "Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number.\nIf the limit is exceeded, the excess rows are silently dropped. Zero means there is no limit.\n@see Statement#setMaxRows(int)", "predict": " Set the maximum number of rows that can be returned by a query. @param maxRows Maximum number of rows. @return Current object."}
{"ID": 1350, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int executeUpdate(final boolean closeQuery) { start = System.currentTimeMillis(); init(); final int result; if (log.isDebugEnabled()) { log.debug(\"Executing update: \" + getQueryString()); } try { if (preparedStatement == null) { if (generatedColumns != null) { if (generatedColumns.length == 0) { result = statement.executeUpdate(query.sql, Statement.RETURN_GENERATED_KEYS); } else { result = statement.executeUpdate(query.sql, generatedColumns); } } else { result = statement.executeUpdate(query.sql); } } else { result = preparedStatement.executeUpdate(); } } catch (SQLException sex) { throw new DbSqlException(this, \"Query execution failed\", sex); } if (closeQuery) { close(); } elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return result; } \nResponse:", "ground_truth": "Executes UPDATE, INSERT or DELETE queries and optionally closes the query.\n@see Statement#executeUpdate(String)", "predict": " Executes SQL UPDATE query. @param closeQuery Close query after execution. @return Affected row count."}
{"ID": 1351, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected long executeCount(final boolean close) { start = System.currentTimeMillis(); init(); ResultSet rs = null; if (log.isDebugEnabled()) { log.debug(\"Executing prepared count: \" + getQueryString()); } try { if (preparedStatement == null) { rs = statement.executeQuery(query.sql); } else { rs = preparedStatement.executeQuery(); } final long firstLong = DbUtil.getFirstLong(rs); elapsed = System.currentTimeMillis() - start; if (log.isDebugEnabled()) { log.debug(\"execution time: \" + elapsed + \"ms\"); } return firstLong; } catch (SQLException sex) { throw new DbSqlException(this, \"Count query failed\", sex); } finally { DbUtil.close(rs); if (close) { close(); } } } \nResponse:", "ground_truth": "Executes count queries and optionally closes query afterwards.", "predict": " Executes prepared count query. @param close indicates weather to close PreparedStatement after execution @return result of count query\n*/"}
{"ID": 1352, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ResultSet getGeneratedColumns() { checkInitialized(); if (generatedColumns == null) { throw new DbSqlException(this, \"No column is specified as auto-generated\"); } final ResultSet rs; try { rs = statement.getGeneratedKeys(); } catch (SQLException sex) { throw new DbSqlException(this, \"No generated keys\", sex); } saveResultSet(rs); totalOpenResultSetCount++; return rs; } \nResponse:", "ground_truth": "Returns generated columns.", "predict": " Statement.getGeneratedKeys() is supported. Returns the auto-generated keys for the last executed INSERT statement. @return ResultSet"}
{"ID": 1353, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getQueryString() { if (debug) { if ((callableStatement != null)) { if (preparedStatement instanceof LoggableCallableStatement) { return ((LoggableCallableStatement) callableStatement).getQueryString(); } } if (preparedStatement != null) { if (preparedStatement instanceof LoggablePreparedStatement) { return ((LoggablePreparedStatement) preparedStatement).getQueryString(); } } } if (query != null) { return query.sql; } return sqlString; } \nResponse:", "ground_truth": "Returns query SQL string. For prepared statements, returned sql string with quick-and-dirty replaced values.", "predict": " Returns the query string. @return The query string."}
{"ID": 1354, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> T proxyOf(final T target, final Class<? extends Aspect> aspectClass) { final Aspect aspect; try { aspect = ClassUtil.newInstance(aspectClass, target); } catch (Exception e) { throw new IllegalArgumentException(\"Can't create new instance of aspect class\", e); } return (T) newProxyInstance(target.getClass().getClassLoader(), aspect, target.getClass().getInterfaces()); } \nResponse:", "ground_truth": "Creates a proxy of given target and the aspect.", "predict": " Proxy of aspect. @param target Target object. @param aspectClass Aspect class. @param <T> Target type. @return Proxy of aspect."}
{"ID": 1355, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Collection<T> collectionOf(final Iterator<? extends T> iterator) { final List<T> list = new ArrayList<>(); while (iterator.hasNext()) { list.add(iterator.next()); } return list; } \nResponse:", "ground_truth": "Returns a collection containing all elements of the iterator.", "predict": " Wrap an iterator into a collection. Useful for mocking iterators. @param iterator The iterator to wrap. @param <T> The type of the iterator. @return The wrapped iterator."}
{"ID": 1356, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Stream<T> streamOf(final Iterator<T> iterator) { return StreamSupport.stream(((Iterable<T>) () -> iterator).spliterator(), false); } \nResponse:", "ground_truth": "Converts iterator to a stream.", "predict": " Stream of elements from iterator. @param iterator iterator to stream from. @param <T> type of elements in iterator. @return stream of elements from iterator."}
{"ID": 1357, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public int compare(final T o1, final T o2) { for (Comparator<T> comparator : comparators) { int result = comparator.compare(o1, o2); if (result != 0) { return result; } } return 0; } \nResponse:", "ground_truth": "Compares two objects starting with first comparator; if they are equals\nproceeds to the next comparator and so on.", "predict": " Compare two objects using the comparators in descending order. @param o1 The first object to compare. @param o2 The second object to compare. @return The result of comparing the two objects. Negative if o1 is less than o2, zero if they are equal, positive if o1 is greater than o2."}
{"ID": 1358, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PetiteConfig setDefaultWiringMode(final WiringMode defaultWiringMode) { if ((defaultWiringMode == null) || (defaultWiringMode == WiringMode.DEFAULT)) { throw new PetiteException(\"Invalid default wiring mode: \" + defaultWiringMode); } this.defaultWiringMode = defaultWiringMode; return this; } \nResponse:", "ground_truth": "Specifies default wiring mode.", "predict": " Sets default wiring mode. Petite engine will use this wiring mode when Petite component is not wired explicitly. Petite engine will use default wiring mode when Petite component is not wired explicitly and Petite component has no default wiring mode. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite beans. Default wiring mode is inherited from Petite"}
{"ID": 1359, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void print(final Level level, final String message, final Throwable throwable) { if (!isEnabled(level)) { return; } StringBuilder msg = new StringBuilder() .append(slf.getElapsedTime()).append(' ').append('[') .append(level).append(']').append(' ') .append(getCallerClass()).append(' ').append('-') .append(' ').append(message); System.out.println(msg.toString()); if (throwable != null) { throwable.printStackTrace(System.out); } } \nResponse:", "ground_truth": "Prints error message if level is enabled.", "predict": " Prints the message and optional throwable at the given level. @param level The log level. @param message The message. @param throwable The optional throwable. Shall be null if no exception occurred. Shall not be null. Shall not be EMPTY. Shall not be LEVEL_OFF. Shall not be null. Shall not be LEVEL_ALL. Shall not be LEVEL_FINEST. Shall not be LEVEL_FINER. Shall not be LEVEL_FINE. Shall not be LEVEL_CONFIG. Shall not be LEVEL_INFO. Shall not be LEVEL_WARNING. Shall not be LEVEL_SEVERE. Shall not be LEVEL_OFF. Shall not be null. Shall not be LEVEL_ALL. Shall not be LEVEL_FINEST. Shall not be LEVEL_FINER. Shall not be LEVEL_FINE. Shall not be LEVEL_CONFIG. Shall not be LEVEL_INFO. Shall not be LEVEL_WARNING. Shall not be LEVEL_SEVERE. Shall not be LEVEL_ALL. Shall not be LEVEL_FINEST. Shall not be LEVEL"}
{"ID": 1360, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String getCallerClass() { Exception exception = new Exception(); StackTraceElement[] stackTrace = exception.getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { String className = stackTraceElement.getClassName(); if (className.equals(SimpleLoggerProvider.class.getName())) { continue; } if (className.equals(SimpleLogger.class.getName())) { continue; } if (className.equals(Logger.class.getName())) { continue; } return shortenClassName(className) + '.' + stackTraceElement.getMethodName() + ':' + stackTraceElement.getLineNumber(); } return \"N/A\"; } \nResponse:", "ground_truth": "Returns called class.", "predict": " Returns the shortened class name of the caller. Useful for troubleshooting. @return shortened class name of the caller\n*/"}
{"ID": 1361, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String shortenClassName(final String className) { int lastDotIndex = className.lastIndexOf('.'); if (lastDotIndex == -1) { return className; } StringBuilder shortClassName = new StringBuilder(className.length()); int start = 0; while(true) { shortClassName.append(className.charAt(start)); int next = className.indexOf('.', start); if (next == lastDotIndex) { break; } start = next + 1; shortClassName.append('.'); } shortClassName.append(className.substring(lastDotIndex)); return shortClassName.toString(); } \nResponse:", "ground_truth": "Returns shorten class name.", "predict": " Shortens a fully qualified class name to a shortened form. The shortened form is obtained by replacing every dot with a dollar sign followed by every subsequent character until a dot is reached again. For example, \"com.foo.bar.MyClass\" becomes \"$foo.bar.MyClass\".\n@param className The fully qualified class name to shorten.\n@return The shortened class name.\n*/"}
{"ID": 1362, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonSerializer excludeTypes(final Class... types) { if (excludedTypes == null) { excludedTypes = types; } else { excludedTypes = ArraysUtil.join(excludedTypes, types); } return this; } \nResponse:", "ground_truth": "Excludes types. Supports interfaces and subclasses as well.", "predict": " Allows excluding certain types from consideration when determining which fields are serialized. Useful for situations where you want to exclude certain types of fields entirely. @param types The types to exclude. @return This serializer.\n*/"}
{"ID": 1363, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void serialize(final Object source, final Appendable target) { JsonContext jsonContext = createJsonContext(target); jsonContext.serialize(source); } \nResponse:", "ground_truth": "Serializes object into provided appendable.", "predict": " Serialize the specified object into the specified appendable. @param source the object to serialize. @param target the appendable to write the serialization result.\n*/"}
{"ID": 1364, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String serialize(final Object source) { FastCharBuffer fastCharBuffer = new FastCharBuffer(); serialize(source, fastCharBuffer); return fastCharBuffer.toString(); } \nResponse:", "ground_truth": "Serializes object into source.", "predict": " Serialize an object to a FastCharBuffer. Useful for debugging purpose. @param source the object to serialize. @return the serialized FastCharBuffer."}
{"ID": 1365, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Serializable> T cloneViaSerialization(final T obj) throws IOException, ClassNotFoundException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream out = null; ObjectInputStream in = null; Object objCopy = null; try { out = new ObjectOutputStream(bos); out.writeObject(obj); out.flush(); byte[] bytes = bos.toByteArray(); in = new ObjectInputStream(new ByteArrayInputStream(bytes)); objCopy = in.readObject(); } finally { StreamUtil.close(out); StreamUtil.close(in); } return (T) objCopy; } \nResponse:", "ground_truth": "Create object copy using serialization mechanism.", "predict": " Deep clone via serialization. @param obj The object to clone. @return The cloned object. @throws IOException If there is an error cloning the object. @throws ClassNotFoundException If there is an error cloning the object.\n*/"}
{"ID": 1366, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeObject(final File dest, final Object object) throws IOException { FileOutputStream fos = null; BufferedOutputStream bos = null; ObjectOutputStream oos = null; try { fos = new FileOutputStream(dest); bos = new BufferedOutputStream(fos); oos = new ObjectOutputStream(bos); oos.writeObject(object); } finally { StreamUtil.close(oos); StreamUtil.close(bos); StreamUtil.close(fos); } } \nResponse:", "ground_truth": "Writes serializable object to a file. Existing file will be overwritten.", "predict": " Write an object to a file. @param dest The destination file. @param object The object to write. @throws IOException Failed to write the object."}
{"ID": 1367, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object readObject(final File source) throws IOException, ClassNotFoundException { Object result = null; FileInputStream fis = null; BufferedInputStream bis = null; ObjectInputStream ois = null; try { fis = new FileInputStream(source); bis = new BufferedInputStream(fis); ois = new ObjectInputStream(bis); result = ois.readObject(); } finally { StreamUtil.close(ois); StreamUtil.close(bis); StreamUtil.close(fis); } return result; } \nResponse:", "ground_truth": "Reads serialized object from the file.", "predict": " Read an object from a file. @param source the file to read from @return the deserialized object\n * @throws IOException if there is an error reading from the file\n * @throws ClassNotFoundException if there is an error deserializing the object\n */"}
{"ID": 1368, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] objectToByteArray(final Object obj) throws IOException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream(); ObjectOutputStream oos = null; try { oos = new ObjectOutputStream(bos); oos.writeObject(obj); } finally { StreamUtil.close(oos); } return bos.toByteArray(); } \nResponse:", "ground_truth": "Serialize an object to byte array.", "predict": " Serialize an object to byte array. @param obj Object to serialize. @return Serialized object. @throws IOException On error.\n*/"}
{"ID": 1369, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Object byteArrayToObject(final byte[] data) throws IOException, ClassNotFoundException { Object retObj = null; ByteArrayInputStream bais = new ByteArrayInputStream(data); ObjectInputStream ois = null; try { ois = new ObjectInputStream(bais); retObj = ois.readObject(); } finally { StreamUtil.close(ois); } return retObj; } \nResponse:", "ground_truth": "De-serialize an object from byte array.", "predict": " Deserialize a byte array into an Object. @param data The byte array to deserialize. @return The deserialized Object. @throws IOException If there is an error deserializing the Object. @throws ClassNotFoundException If there is an error deserializing the Object."}
{"ID": 1370, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[][] resolveMappedTypesTableNames(final Class[] types) { if (cachedMappedNames == null) { String[][] names = new String[types.length][]; for (int i = 0; i < types.length; i++) { Class type = types[i]; if (type != null) { DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded != null) { Class[] mappedTypes = ded.getMappedTypes(); if (mappedTypes != null) { names[i] = createTypesTableNames(mappedTypes); } } } } cachedMappedNames = names; } return cachedMappedNames; } \nResponse:", "ground_truth": "Resolved mapped type names for each type.", "predict": " Resolves the names of the mapped types for the given types. The names are resolved against the database catalog and schema names. The resulting names are cached for reuse. @param types the types to resolve the names for @return the resolved names\n*/"}
{"ID": 1371, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] createTypesTableNames(final Class[] types) { String[] names = new String[types.length]; for (int i = 0; i < types.length; i++) { if (types[i] == null) { names[i] = null; continue; } DbEntityDescriptor ded = dbEntityManager.lookupType(types[i]); if (ded != null) { String tableName = ded.getTableName(); tableName = tableName.toUpperCase(); names[i] = tableName; } } return names; } \nResponse:", "ground_truth": "Creates table names for given types.", "predict": " Creates the names of the types table. The name of the types table is suffixed with \"_TYPES\". Therefore, the name of the types table is always prefixed with the name of the persistence unit. The suffix \"_TYPES\" is appended to the table name. The \"_TYPES\" suffix is removed from the table name when constructing the JPQL query. @param types The types. @return The names of the types table. Shall not be <code>null</code>. Shall not be empty. Shall contain at least one element. Shall not contain duplicates. Shall not contain null. Shall not contain an empty string. Shall not contain spaces. Shall not contain underscores. Shall not contain dots. Shall not contain dollar signs. Shall not contain percent signs. Shall not contain ampersands. Shall not contain asterisks. Shall not contain question marks. Shall not contain curly brackets. Shall not contain back ticks. Shall not contain back ticks. Shall not contain quotation marks. Shall not contain apostrophes. Shall not contain parentheses."}
{"ID": 1372, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) protected Object readColumnValue(final int colNdx, final Class destinationType, final Class<? extends SqlType> sqlTypeClass, final int columnDbSqlType) { if (colNdx != cachedColumnNdx) { try { SqlType sqlType; if (sqlTypeClass != null) { sqlType = SqlTypeManager.get().lookupSqlType(sqlTypeClass); } else { sqlType = SqlTypeManager.get().lookup(destinationType); } if (sqlType != null) { cachedColumnValue = sqlType.readValue(resultSet, colNdx + 1, destinationType, columnDbSqlType); } else { cachedColumnValue = resultSet.getObject(colNdx + 1); cachedColumnValue = TypeConverterManager.get().convertType(cachedColumnValue, destinationType); } } catch (SQLException sex) { throw new DbOomException(dbOomQuery, \"Invalid value for column #\" + (colNdx + 1), sex); } cachedColumnNdx = colNdx; } return cachedColumnValue; } \nResponse:", "ground_truth": "Reads column value from result set. Since this method may be called more then once for\nthe same column, it caches column values.", "predict": " Read column value. Never throws an exception. Always returns a valid value. May return null. @param colNdx Column index (numbered from 1). @param destinationType Destination type. @param sqlTypeClass SQL type class. May be null. @param columnDbSqlType Column database SQL type. May be ignored. @return Column value. Never null. May be null. May be converted to destination type. May be converted to primitive wrapper type. May be converted to BigDecimal. May be converted to BigInteger. May be converted to Number. May be converted to String. May be converted to Calendar. May be converted to Date. May be converted to Timestamp. May be converted to Time. May be converted to URL. May be converted to Blob. May be converted to Clob. May be converted to NClob. May be converted to SQLXML. May be converted to byte[]. May be converted to Byte[]. May be converted to char[]. May be converted to Character[]. May be converted to double."}
{"ID": 1373, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void cacheResultSetEntities(final Object[] result) { if (entitiesCache == null) { entitiesCache = new HashMap<>(); } for (int i = 0; i < result.length; i++) { Object object = result[i]; if (object == null) { continue; } DbEntityDescriptor ded = cachedDbEntityDescriptors[i]; if (ded == null) { // not a type, continue continue; } // calculate key Object key; if (ded.hasIdColumn()) { //noinspection unchecked key = ded.getKeyValue(object); } else { key = object; } Object cachedObject = entitiesCache.get(key); if (cachedObject == null) { // object is not in the cache, add it entitiesCache.put(key, object); } else { // object is in the cache, replace it result[i] = cachedObject; } } } \nResponse:", "ground_truth": "Caches returned entities. Replaces new instances with existing ones.", "predict": " Cache entities retrieved from database. @param result result of database query."}
{"ID": 1374, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProviderDefinition[] resolve(final Class type, final String name) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); MethodDescriptor[] methods = cd.getAllMethodDescriptors(); List<ProviderDefinition> list = new ArrayList<>(); for (MethodDescriptor methodDescriptor : methods) { Method method = methodDescriptor.getMethod(); PetiteProvider petiteProvider = method.getAnnotation(PetiteProvider.class); if (petiteProvider == null) { continue; } String providerName = petiteProvider.value(); if (StringUtil.isBlank(providerName)) { // default provider name providerName = method.getName(); if (providerName.endsWith(\"Provider\")) { providerName = StringUtil.substring(providerName, 0, -8); } } ProviderDefinition providerDefinition; if (Modifier.isStatic(method.getModifiers())) { providerDefinition = new ProviderDefinition(providerName, method); } else { providerDefinition = new ProviderDefinition(providerName, name, method); } list.add(providerDefinition); } ProviderDefinition[] providers; if (list.isEmpty()) { providers = ProviderDefinition.EMPTY; } else { providers = list.toArray(new ProviderDefinition[0]); } return providers; } \nResponse:", "ground_truth": "Resolves all providers in the class", "predict": " Resolves Petite dependencies for given type and name. @param type Petite bean type. @param name Petite bean name. @return Petite dependencies. Never returns null. Empty array if no Petite dependencies found."}
{"ID": 1375, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String applyToTableName(final String tableName) { String entityName = convertTableNameToEntityName(tableName); return convertEntityNameToTableName(entityName); } \nResponse:", "ground_truth": "Applies table naming strategy to given table name hint.\nReturns full table name.", "predict": " Convert table name to table name. @param tableName the table name @return the string\n*/"}
{"ID": 1376, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean isConnectionValid(final ConnectionData connectionData, final long now) { if (!validateConnection) { return true; } if (now < connectionData.lastUsed + validationTimeout) { return true; } Connection conn = connectionData.connection; if (validationQuery == null) { try { return !conn.isClosed(); } catch (SQLException sex) { return false; } } boolean valid = true; Statement st = null; try { st = conn.createStatement(); st.execute(validationQuery); } catch (SQLException sex) { valid = false; } finally { if (st != null) { try { st.close(); } catch (SQLException ignore) { } } } return valid; } \nResponse:", "ground_truth": "Checks if existing connection is valid and available. It may happens\nthat if connection is not used for a while it becomes inactive,\nalthough not technically closed.", "predict": " Validate connection validity. @param connectionData connection data. @param now current time. @return true if connection is valid.\n*/"}
{"ID": 1377, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void renderView(final ActionRequest actionRequest, final String target) throws Exception { HttpServletRequest request = actionRequest.getHttpServletRequest(); HttpServletResponse response = actionRequest.getHttpServletResponse(); RequestDispatcher dispatcher = request.getRequestDispatcher(target); if (dispatcher == null) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + target); // should never happened return; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if (DispatcherUtil.isPageIncluded(request, response)) { dispatcher.include(request, response); } else { dispatcher.forward(request, response); } } \nResponse:", "ground_truth": "Renders the view by dispatching to the target JSP.", "predict": " Render the view. @param actionRequest the action request @param target the target view @throws Exception if something goes wrong\n*/"}
{"ID": 1378, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected String locateTarget(final ActionRequest actionRequest, String path) { String target; if (path.endsWith(StringPool.SLASH)) { path = path + defaultViewPageName; } for (final String ext : defaultViewExtensions) { target = path + ext; if (targetExists(actionRequest, target)) { return target; } } return null; } \nResponse:", "ground_truth": "Locates target using path with various extensions appended.", "predict": " Locate the target view page. @param actionRequest the action request @param path the path @return the target view page"}
{"ID": 1379, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public PrintWriter getWriter() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getWriter(); } return buffer.getWriter(); } \nResponse:", "ground_truth": "Returns buffered writer if buffering is enabled,\notherwise returns the original writer.", "predict": " Get the writer for the servlet response. This method is invoked by the servlet container from within the COMMIT phase of a servlet request. The COMMIT phase finishes after the response header has been sent and before the actual content of the response has been written. This gives you an opportunity to write any last bits of data to the response before committing the response. @return a writer to write the servlet response output. @throws IOException if thrown by the writer methods.\n"}
{"ID": 1380, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public ServletOutputStream getOutputStream() throws IOException { preResponseCommit(); if (buffer == null) { return getResponse().getOutputStream(); } return buffer.getOutputStream(); } \nResponse:", "ground_truth": "Returns buffered output stream if buffering is enabled,\notherwise returns the original stream.", "predict": " Get the output stream to write binary data to. This method is called by Tomcat. Don't confuse it with the ServletOutputStream inherited from ServletResponse. @return The ServletOutputStream to write binary data to. Never null. @throws IOException If an I/O error occurs. Never thrown."}
{"ID": 1381, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeContentToResponse(final char[] content) throws IOException { if (buffer == null) { return; } if (buffer.isUsingStream()) { ServletOutputStream outputStream = getResponse().getOutputStream(); String encoding = getContentTypeEncoding(); if (encoding == null) { outputStream.write(CharUtil.toByteArray(content)); } else { outputStream.write(CharUtil.toByteArray(content, encoding)); } outputStream.flush(); } else { Writer out = getResponse().getWriter(); out.write(content); out.flush(); } } \nResponse:", "ground_truth": "Writes content to original output stream, using either output stream or writer, depending\non how the content was buffered. It is assumed that provided content is a modified\nwrapped content.", "predict": " Writes content to the response. @param content The content to write. @throws IOException Writing failed."}
{"ID": 1382, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void setContentType(final String type) { super.setContentType(type); contentTypeResolver = new ContentTypeHeaderResolver(type); if (bufferContentType(type, contentTypeResolver.getMimeType(), contentTypeResolver.getEncoding())) { enableBuffering(); } else { disableBuffering(); } } \nResponse:", "ground_truth": "Sets the content type and enables or disables buffering.", "predict": " Sets the content type of the response. Useful for setting proper cookies and other HTTP headers. @param type the content type of the HTTP response\n*/"}
{"ID": 1383, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void print(final String string) throws IOException { if (isBufferStreamBased()) { String encoding = getContentTypeEncoding(); byte[] bytes; if (encoding == null) { bytes = string.getBytes(); } else { bytes = string.getBytes(encoding); } buffer.getOutputStream().write(bytes); return; } // make sure at least writer is initialized buffer.getWriter().write(string); } \nResponse:", "ground_truth": "Appends string to the buffer.", "predict": " Prints a string to the output stream. @param string the string to print @throws IOException if an I/O error occurs\n*/"}
{"ID": 1384, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult login() { T authToken; authToken = loginViaBasicAuth(servletRequest); if (authToken == null) { authToken = loginViaRequestParams(servletRequest); } if (authToken == null) { log.warn(\"Login failed.\"); return JsonResult.of(HttpStatus.error401().unauthorized(\"Login failed.\")); } log.info(\"login OK!\"); final UserSession<T> userSession = new UserSession<>(authToken, userAuth.tokenValue(authToken)); userSession.start(servletRequest, servletResponse); // return token return tokenAsJson(authToken); } \nResponse:", "ground_truth": "Authenticate user and start user session.", "predict": " Login the user via basic auth or via request params. @return LoginResult\n*/"}
{"ID": 1385, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult tokenAsJson(final T authToken) { final JsonObject jsonObject = new JsonObject(); jsonObject.put(\"token\", userAuth.tokenValue(authToken)); return JsonResult.of(jsonObject); } \nResponse:", "ground_truth": "Prepares the JSON payload that carries on the token value.", "predict": " Produces a JSON object containing the token details. @param authToken The authentication token. @return A JSON object containing the token details."}
{"ID": 1386, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T loginViaBasicAuth(final HttpServletRequest servletRequest) { final String username = ServletUtil.resolveAuthUsername(servletRequest); if (username == null) { return null; } final String password = ServletUtil.resolveAuthPassword(servletRequest); return userAuth.login(username, password); } \nResponse:", "ground_truth": "Tries to login user with basic authentication.", "predict": " Authenticate a user via BASIC auth. @param servletRequest The servlet request. @return The authenticated user or null if authentication failed."}
{"ID": 1387, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected JsonResult logout() { log.debug(\"logout user\"); UserSession.stop(servletRequest, servletResponse); return JsonResult.of(HttpStatus.ok()); } \nResponse:", "ground_truth": "Logout hook.", "predict": " Logout current user session. @return 204 No Content."}
{"ID": 1388, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File toContainerFile(final URL url) { String protocol = url.getProtocol(); if (protocol.equals(FILE_PROTOCOL)) { return toFile(url); } String path = url.getPath(); return new File(URI.create( path.substring(ZERO, path.lastIndexOf(\"!/\")))); } \nResponse:", "ground_truth": "Returns a file of either a folder or a containing archive.", "predict": " Converts a URL to a File. Unlike the original method, this one doesn't collapse \"../\" sequences in the path. @param url The URL to convert. @return The resulting File.\n*/"}
{"ID": 1389, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File mkdirs(final File dirs) throws IOException { if (dirs.exists()) { checkIsDirectory(dirs); return dirs; } return checkCreateDirectory(dirs); } \nResponse:", "ground_truth": "Creates all directories at once.\n\n@param dirs Directories to make.\n@throws IOException if cannot create directory.", "predict": " Creates a directory recursively. @param dirs The directory to create. @return The directory. @throws IOException If the directory could not be created.\n*/"}
{"ID": 1390, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File mkdir(final File dir) throws IOException { if (dir.exists()) { checkIsDirectory(dir); return dir; } return checkCreateDirectory(dir); } \nResponse:", "ground_truth": "Creates single directory.\n\n@throws IOException if cannot create directory.", "predict": " Creates a directory. @param dir Directory to create. @return Newly created directory. @throws IOException If failed. Reasons include: <ul> <li>Already exists.</li> <li>Parent does not exist and can't be created.</li> <li>Parent does not exist but can be created.</li> <li>Parent exists but can't be created.</li> </ul>"}
{"ID": 1391, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void _copyFile(final File srcFile, final File destFile) throws IOException { if (destFile.exists()) { if (destFile.isDirectory()) { throw new IOException(\"Destination '\" + destFile + \"' is a directory\"); } } // do copy file FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(srcFile); output = new FileOutputStream(destFile, false); StreamUtil.copy(input, output); } finally { StreamUtil.close(output); StreamUtil.close(input); } // done if (srcFile.length() != destFile.length()) { throw new IOException(\"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\"); } destFile.setLastModified(srcFile.lastModified()); } \nResponse:", "ground_truth": "Internal file copy when most of the pre-checking has passed.\n\n@param srcFile  Source {@link File}.\n@param destFile Destination {@link File}.\n@throws IOException if cannot copy", "predict": " Copy a file from srcFile to destFile. If destFile exists, it will be overwritten. Both files must reside in the same directory. @param srcFile The source file. @param destFile The destination file. @throws IOException If anything goes wrong.\n*/"}
{"ID": 1392, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copyDir(final File srcDir, final File destDir) throws IOException { checkDirCopy(srcDir, destDir); _copyDirectory(srcDir, destDir); } \nResponse:", "ground_truth": "Copies directory with specified copy params.\n\n@see #_copyDirectory(File, File)", "predict": " Copies a directory recursively. @param srcDir Source directory. @param destDir Destination directory. @throws IOException If failed."}
{"ID": 1393, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File moveFileToDir(final File srcFile, final File destDir) throws IOException { checkExistsAndDirectory(destDir); return moveFile(srcFile, file(destDir, srcFile.getName())); } \nResponse:", "ground_truth": "Moves a file to a directory.\n\n@param srcFile Source {@link File}.\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": " Move a file to a directory. The destination directory is created if it doesn't exist. @param srcFile The source file. @param destDir The destination directory. @return The moved file. @throws IOException If there is an I/O error.\n*/"}
{"ID": 1394, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void _moveDirectory(final File srcDest, File destDir) throws IOException { if (destDir.exists()) { checkIsDirectory(destDir); destDir = file(destDir, destDir.getName()); destDir.mkdir(); } final boolean rename = srcDest.renameTo(destDir); if (!rename) { _copyDirectory(srcDest, destDir); deleteDir(srcDest); } } \nResponse:", "ground_truth": "Moves a directory.\n\n@param srcDest Source directory\n@param destDir Destination directory.\n@throws IOException if there is an error during move.", "predict": " Move directory recursively. @param srcDest the src dest @param destDir the dest dir @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1395, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void cleanDir(final File destDir) throws IOException { checkExists(destDir); checkIsDirectory(destDir); File[] files = destDir.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of: \" + destDir); } IOException exception = null; for (File file : files) { try { if (file.isDirectory()) { deleteDir(file); } else { file.delete(); } } catch (IOException ioex) { exception = ioex; continue; } } if (exception != null) { throw exception; } } \nResponse:", "ground_truth": "Cleans a directory without deleting it.\n\n@param destDir destination to clean.\n@throws IOException if something went wrong.", "predict": " Clean a directory without deleting it. @param destDir Directory to be cleaned. @throws IOException if the destination directory does not exist or is not a directory, or if cleaning the directory fails."}
{"ID": 1396, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] readUTFChars(final File file) throws IOException { checkExists(file); checkIsFile(file); UnicodeInputStream in = unicodeInputStreamOf(file); try { return StreamUtil.readChars(in, detectEncoding(in)); } finally { StreamUtil.close(in); } } \nResponse:", "ground_truth": "Reads UTF file content as char array.\n\n@param file {@link File} to read.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " Reads UTF-8 encoded characters from the file. Characters are converted into Unicode characters. The file must exist and be a regular file. @param file the file to read from @return the UTF-8 encoded characters from the file\n@throws IOException if the file does not exist or is not a regular file\n*/"}
{"ID": 1397, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] readChars(final File file, final String encoding) throws IOException { checkExists(file); checkIsFile(file); InputStream in = streamOf(file, encoding); try { return StreamUtil.readChars(in, encoding); } finally { StreamUtil.close(in); } } \nResponse:", "ground_truth": "Reads file content as char array.\n\n@param file     {@link File} to read.\n@param encoding Encoding to use.\n@return array of characters.\n@throws IOException if something went wrong.", "predict": " Reads the entire contents of a file into a char array. Uses the default encoding for the operating system. @param file The file whose contents are to be read. @param encoding The encoding to use when reading the file. @return The contents of the file. @throws IOException If there is an I/O error while reading the file.\n*/\npublic static char[] readChars(final File file, final String encoding) throws IOException { return StreamUtil.readChars(streamOf(file, encoding), encoding); }\n/** Reads the entire contents of a file into a char array. Uses the default encoding for the operating system. @param file The file whose contents are to be read. @return The contents of the file. @throws IOException If there is an I/O error while reading the file. */\npublic static char[] readChars(final File file) throws IOException { return StreamUtil.readChars(streamOf(file), Charset.defaultCharset"}
{"ID": 1398, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeChars(final File dest, final char[] data, final String encoding) throws IOException { outChars(dest, data, encoding, false); } \nResponse:", "ground_truth": "Write characters. append = false\n\n@see #outChars(File, char[], String, boolean)", "predict": " Writes characters to a file. Characters are written using the encoding specified by the second argument. @param dest The destination file. @param data The characters to write. @param encoding The encoding to use. @throws IOException If there is an I/O error.\n*/"}
{"ID": 1399, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, false); } \nResponse:", "ground_truth": "Writes String. append = false\n\n@see #outString(File, String, String, boolean)", "predict": " Writes a string to a file. UTF-8 is used unless otherwise specified. @param dest The destination file. @param data The string to write. @param encoding The encoding to use. @throws IOException If there is an I/O error.\n*/"}
{"ID": 1400, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void appendString(final File dest, final String data, final String encoding) throws IOException { outString(dest, data, encoding, true); } \nResponse:", "ground_truth": "Appends String. append = true\n\n@see #outString(File, String, String, boolean)", "predict": " Append a string to a file. UTF-8 is used unless otherwise specified. @param dest The destination file. @param data The string to append. @param encoding The encoding to use. @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1401, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] readBytes(final File file, final int count) throws IOException { checkExists(file); checkIsFile(file); long numToRead = file.length(); if (numToRead >= Integer.MAX_VALUE) { throw new IOException(\"File is larger then max array size\"); } if (count > NEGATIVE_ONE && count < numToRead) { numToRead = count; } byte[] bytes = new byte[(int) numToRead]; RandomAccessFile randomAccessFile = new RandomAccessFile(file, \"r\"); randomAccessFile.readFully(bytes); randomAccessFile.close(); return bytes; } \nResponse:", "ground_truth": "Read file and returns byte array with contents.\n\n@param file  {@link File} to read\n@param count number of bytes to read\n@return byte array from {@link File} contents.\n@throws IOException if not a {@link File} or {@link File} does not exist or file size is\nlarger than {@link Integer#MAX_VALUE}.", "predict": " Reads the whole file into a byte array. @param file The file to read. @param count The number of bytes to read. @return The bytes read. @throws IOException If there is an I/O error.\n*/"}
{"ID": 1402, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void writeBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, false); } \nResponse:", "ground_truth": "Write bytes. append = false\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Write bytes to file. @param dest destination file. @param data data to write. @param off offset in data. @param len length of data to write. @throws IOException if there is a problem writing the data."}
{"ID": 1403, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void appendBytes(final File dest, final byte[] data, final int off, final int len) throws IOException { outBytes(dest, data, off, len, true); } \nResponse:", "ground_truth": "Appends bytes. append = true\n\n@see #outBytes(File, byte[], int, int, boolean)", "predict": " Append bytes to a file. @param dest destination file. @param data data to append. @param off offset in the data. @param len length of the data. @throws IOException if an I/O error occurs."}
{"ID": 1404, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void copy(final File src, final File dest) throws IOException { if (src.isDirectory()) { copyDir(src, dest); return; } if (dest.isDirectory()) { copyFileToDir(src, dest); return; } copyFile(src, dest); } \nResponse:", "ground_truth": "Smart copy. If source is a directory, copy it to destination.\nOtherwise, if destination is directory, copy source file to it.\nOtherwise, try to copy source file to destination file.\n\n@param src  source {@link File}\n@param dest destination {@link File}\n@throws IOException if there is an error copying.\n@see #copyDir(File, File)\n@see #copyFileToDir(File, File)\n@see #copyFile(File, File)", "predict": " Copy src file to dest file. If dest file exists, it will be overwritten. If src file is a directory, it will be copied recursively. If dest file is a directory, it will be created recursively. If src file does not exist, nothing happens. If dest file does not exist, it will be created recursively. @param src source file @param dest destination file @throws IOException if any I/O error occurs during copying\n*/"}
{"ID": 1405, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void delete(final File dest) throws IOException { if (dest.isDirectory()) { deleteDir(dest); return; } deleteFile(dest); } \nResponse:", "ground_truth": "Smart delete of destination file or directory.\n\n@throws IOException if there is an issue deleting the file/directory.\n@see #deleteFile(File)\n@see #deleteDir(File)", "predict": " Delete a file or directory recursively. @param dest the file or directory to delete. @throws IOException if an I/O error occurs.\n */"}
{"ID": 1406, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static File createTempDirectory(final String prefix, final String suffix, final File tempDir) throws IOException { File file = createTempFile(prefix, suffix, tempDir); file.delete(); file.mkdir(); return file; } \nResponse:", "ground_truth": "Creates temporary directory.\n\n@see #createTempFile(String, String, File)", "predict": " Creates a temporary directory. The directory will be created in the system temporary directory if possible, otherwise in the system user temporary directory. The directory will be named using the supplied prefix and suffix. The suffix \".tmp\" will be appended automatically. The directory will be cleaned up automatically upon exiting the virtual machine. @param prefix The prefix to use for naming the temporary directory. @param suffix The suffix to use for naming the temporary directory. @param tempDir The directory to use as a temporary scratch pad. @return The temporary directory. @throws IOException If there is a problem creating the temporary directory."}
{"ID": 1407, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isBinary(final File file) throws IOException { byte[] bytes = readBytes(file, 128); for (byte b : bytes) { if (b < 32 && b != 9 && b != 10 && b != 13) { return true; } } return false; } \nResponse:", "ground_truth": "Checks the start of the file for ASCII control characters\n\n@param file {@link File}\n@return true if the the start of the {@link File} is ASCII control characters.", "predict": " Checks if the file is binary. @param file The file to check. @return True if the file is binary, false otherwise. @throws IOException If there is an I/O error."}
{"ID": 1408, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void checkDirCopy(final File srcDir, final File destDir) throws IOException { checkExists(srcDir); checkIsDirectory(srcDir); if (equals(srcDir, destDir)) { throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\"); } } \nResponse:", "ground_truth": "Checks that srcDir exists, that it is a directory and if srcDir and destDir are not equal.\n\n@param srcDir  Source directory\n@param destDir Destination directory\n@throws IOException if any of the above conditions are not true.", "predict": " Checks that srcDir is a directory and exists. Throws an IOException if either of these conditions is violated. @param srcDir The source directory. @param destDir The destination directory. @throws IOException If srcDir does not exist or is not a directory.\n*/\nprivate static void checkDirCopy(final File srcDir, final File destDir) throws IOException {\n\tcheckExists(srcDir);\n\tcheckIsDirectory(srcDir);\n\tif (equals(srcDir, destDir)) { throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\"); }\n}\n"}
{"ID": 1409, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static void checkFileCopy(final File srcFile, final File destFile) throws IOException { checkExists(srcFile); checkIsFile(srcFile); if (equals(srcFile, destFile)) { throw new IOException(\"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\"); } File destParent = destFile.getParentFile(); if (destParent != null && !destParent.exists()) { checkCreateDirectory(destParent); } } \nResponse:", "ground_truth": "Checks that file copy can occur.\n\n@param srcFile  Source {@link File}\n@param destFile Destination {@link File}\n@throws IOException if srcFile does not exist or is not a file or\nsrcFile and destFile are equal or cannot create ancestor directories.", "predict": " Checks that srcFile and destFile are different files. Copying a file to itself is OK though. Neither srcFile nor destFile may be null. Throws IOException upon error."}
{"ID": 1410, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void printUsage(final String commandName) { final StringBuilder usage = new StringBuilder(commandName); for (final Option option : options) { if (option.shortName != null) { usage.append(\" [-\").append(option.shortName).append(\"]\"); } else if (option.longName != null) { usage.append(\" [--\").append(option.longName).append(\"]\"); } } for (final Param param : params) { usage.append(\" \").append(param.label); } System.out.println(usage); } \nResponse:", "ground_truth": "Prints the usage line.", "predict": " Print usage information for the CLI. @param commandName Name of the command to print usage information for."}
{"ID": 1411, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Method resolveActionMethod(final Class<?> actionClass, final String methodName) { MethodDescriptor methodDescriptor = ClassIntrospector.get().lookup(actionClass).getMethodDescriptor(methodName, false); if (methodDescriptor == null) { throw new MadvocException(\"Public method not found: \" + actionClass.getSimpleName() + \"#\" + methodName); } return methodDescriptor.getMethod(); } \nResponse:", "ground_truth": "Resolves action method for given action class ane method name.", "predict": " Resolves Madvoc action method by introspection. @param actionClass Madvoc action class. @param methodName Madvoc action method name. @return Madvoc action method.\n*/"}
{"ID": 1412, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ActionRuntime registerAction(final Class actionClass, final String actionMethodName, final ActionDefinition actionDefinition) { Method actionMethod = resolveActionMethod(actionClass, actionMethodName); return registerAction(actionClass, actionMethod, actionDefinition); } \nResponse:", "ground_truth": "Registers action with provided action class and method name.\n@see #registerAction(Class, Method, ActionDefinition)", "predict": " Register an action. @param actionClass The action class. @param actionMethodName The action method name. @param actionDefinition The action definition. @return The action runtime.\n*/"}
{"ID": 1413, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerPathAlias(final String alias, final String path) { final String existing = pathAliases.put(alias, path); if (existing != null) { throw new MadvocException(\"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing); } } \nResponse:", "ground_truth": "Registers new path alias.", "predict": " Registers alias for the given path. Alias can be used in Madvoc templates. Aliases are case insensitive. @param alias Alias to register. @param path Path to register."}
{"ID": 1414, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean next() { if (!looping) { return false; } if (last) { return false; } if (count == 0) { value = start; first = true; } else { value += step; first = false; } count++; last = isLastIteration(value + step); return true; } \nResponse:", "ground_truth": "Iterates to next value at the beginning of the loop.", "predict": " Advances the iterator to the next value. Returns false if the iteration has ended.\n */"}
{"ID": 1415, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static CharArraySequence from(final char[] value, final int offset, final int len) { final char[] buffer = new char[value.length]; System.arraycopy(value, offset, buffer, 0, len); return new CharArraySequence(buffer); } \nResponse:", "ground_truth": "Static constructor that creates a char sequence by making a copy of provided char array.", "predict": " Create a CharSequence from a char array. The char array is copied to prevent accidental modification of the original array. @param value char array to copy @param offset offset in the char array @param len length of characters to copy @return CharSequence\n*/"}
{"ID": 1416, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object execute() throws Exception { String methodName = ProxyTarget.targetMethodName(); Class[] argTypes = ProxyTarget.createArgumentsClassArray(); Object[] args = ProxyTarget.createArgumentsArray(); // lookup method on target object class (and not #targetClass!() Class type = _target.getClass(); Method method = type.getMethod(methodName, argTypes); // remember context classloader ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Object result; try { // change class loader Thread.currentThread().setContextClassLoader(type.getClassLoader()); // invoke result = method.invoke(_target, args); } finally { // return context classloader Thread.currentThread().setContextClassLoader(contextClassLoader); } return ProxyTarget.returnValue(result); } \nResponse:", "ground_truth": "Looks up for method in target object and invokes it using reflection.", "predict": " Invokes the target method on the target object. The method name and arguments are taken from the ProxyTarget. The target method is invoked reflectively. The return value is returned to the caller. @return Whatever the target method returns.\n@throws Exception Anything thrown by reflection.\n*/"}
{"ID": 1417, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final boolean matchUpperCase(final char[] uppercaseTarget) { if (ndx + uppercaseTarget.length > total) { return false; } int j = ndx; for (int i = 0; i < uppercaseTarget.length; i++, j++) { final char c = CharUtil.toUpperAscii(input[j]); if (c != uppercaseTarget[i]) { return false; } } return true; } \nResponse:", "ground_truth": "Matches char buffer given in uppercase with content at current location, that will\nbe converted to upper case to make case-insensitive matching.", "predict": " Advances the position in the haystack until it reaches the needle in upper-case letters. Leaves the position unchanged if needle is not found. @param uppercaseTarget the target characters in upper-case letters. @return true if the needle was found in the haystack. False otherwise."}
{"ID": 1418, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected final CharSequence charSequence(final int from, final int to) { if (from == to) { return CharArraySequence.EMPTY; } return CharArraySequence.of(input, from, to - from); } \nResponse:", "ground_truth": "Creates char sub-sequence from the input.", "predict": " Provide a CharSequence view of the specified range.\n@param from inclusive start index.\n@param to exclusive end index.\n@return CharSequence view of the specified range. Shall not be {@code null}. Shall not be empty. Shall not be longer than the whole CharSequence. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be frozen. Shall not be"}
{"ID": 1419, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { URLClassLoader urlClassLoader = (URLClassLoader) classLoader; URL[] allURLS = urlClassLoader.getURLs(); Collections.addAll(urls, allURLS); break; } URL classUrl = classModuleUrl(classLoader, clazz); if (classUrl != null) { urls.add(classUrl); } classUrl = classModuleUrl(classLoader, ClassPathURLs.class); if (classUrl != null) { urls.add(classUrl); } ModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor(); if (moduleDescriptor != null) { moduleDescriptor.requires().forEach(req -> { ModuleLayer.boot() .findModule(req.name()) .ifPresent(mod -> { ClassLoader moduleClassLoader = mod.getClassLoader(); if (moduleClassLoader != null) { URL url = moduleClassLoader.getResource(MANIFEST); if (url != null) { url = fixManifestUrl(url); urls.add(url); } } }); }); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); } \nResponse:", "ground_truth": "Returns urls for the classloader.\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": " Discover all URLs of the given class loader. @param classLoader the class loader @param clazz the class to discover the URLs of @return the URLs of the given class loader\n"}
{"ID": 1420, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Email bcc(final EmailAddress... bccs) { this.bcc = ArraysUtil.join(this.bcc, valueOrEmptyArray(bccs)); return _this(); } \nResponse:", "ground_truth": "Appends one or more BCC addresses.\n\n@param bccs vararg of {@link EmailAddress}es to set.\n@return this", "predict": " BCC receipient addresses. Separate multiple addresses with comma. Supports quoting the BCC header literally (@literal) or escaping it with backslash. Supports both RFC 2822 and unfolded From-header style addresses. Supports both SMTP and BCCP syntaxes. Supports both comma- and semicolon-separated lists. Supports both comma-separated and semicolon-separated lists. Supports both semicolon-separated and unfolded From-header style addresses. Supports both comma-separated and semicolon-separated lists. Supports both semicolon-separated and unfolded From-header style addresses. Supports both comma-separated and semicolon-separated lists. Supports both semicolon-separated and unfolded From-header style addresses. Supports both comma-separated and semicolon-separated lists. Supports both semicolon-separated and unfolded From-header style addresses. Supports both comma-separated and semicolon-separated lists. Supports both semicolon-separated and unfolded From"}
{"ID": 1421, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void register(final Class type, final TypeJsonSerializer typeJsonSerializer) { map.put(type, typeJsonSerializer); cache.clear(); } \nResponse:", "ground_truth": "Registers new serializer.", "predict": " Register a type converter. @param type The type to register. @param typeJsonSerializer The serializer to use for this type."}
{"ID": 1422, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TypeJsonSerializer lookupSerializer(final Class type) { TypeJsonSerializer tjs = map.get(type); if (tjs == null) { if (defaultSerializerMap != null) { tjs = defaultSerializerMap.map.get(type); } } return tjs; } \nResponse:", "ground_truth": "Get type serializer from map. First the current map is used.\nIf element is missing, default map will be used, if exist.", "predict": " Looks up the TypeJsonSerializer for the given type. If no TypeJsonSerializer is found, then the default serializer is looked up. If no default serializer is found, then null is returned.\n@param type The type to lookup.\n@return The TypeJsonSerializer for the given type. May be null.\n*/"}
{"ID": 1423, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parseRequestStream(final InputStream inputStream, final String encoding) throws IOException { setParsed(); MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream); input.readBoundary(); while (true) { FileUploadHeader header = input.readDataHeader(encoding); if (header == null) { break; } if (header.isFile) { String fileName = header.fileName; if (fileName.length() > 0) { if (header.contentType.indexOf(\"application/x-macbinary\") > 0) { input.skipBytes(128); } } FileUpload newFile = fileUploadFactory.create(input); newFile.processStream(); if (fileName.length() == 0) { // file was specified, but no name was provided, therefore it was not uploaded if (newFile.getSize() == 0) { newFile.size = -1; } } putFile(header.formFieldName, newFile); } else { // no file, therefore it is regular form parameter. FastByteArrayOutputStream fbos = new FastByteArrayOutputStream(); input.copyAll(fbos); String value = encoding != null ? new String(fbos.toByteArray(), encoding) : new String(fbos.toByteArray()); putParameter(header.formFieldName, value); } input.skipBytes(1); input.mark(1); // read byte, but may be end of stream int nextByte = input.read(); if (nextByte == -1 || nextByte == '-') { input.reset(); break; } input.reset(); } } \nResponse:", "ground_truth": "Extracts uploaded files and parameters from the request data.", "predict": " Parses the multipart request stream. @param inputStream the input stream to parse. @param encoding the encoding to use when reading the stream. @throws IOException in case of I/O errors.\n*/\nvoid parseRequestStream(final InputStream inputStream, final String encoding) throws IOException {\n\tsetParsed(); MultipartRequestInputStream input = new MultipartRequestInputStream(inputStream); input.readBoundary(); while (true) { FileUploadHeader header = input.readDataHeader(encoding); if (header == null) { break; } if (header.isFile) { String fileName = header.fileName; if (fileName.length() > 0) { if (header.contentType.indexOf(\"application/x-macbinary\") > 0) { input.skipBytes(128); } } FileUpload newFile = fileUploadFactory.create(input); newFile.processStream(); if (fileName.length() == 0) { // file"}
{"ID": 1424, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getParameter(final String paramName) { if (requestParameters == null) { return null; } String[] values = requestParameters.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \nResponse:", "ground_truth": "Returns single value of a parameter. If parameter name is used for\nmore then one parameter, only the first one will be returned.\n\n@return parameter value, or <code>null</code> if not found", "predict": " Get the first value of a request parameter. @param paramName The name of the parameter whose first value is to be retrieved. @return The first value of the named parameter, or null if the parameter does not exist."}
{"ID": 1425, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getParameterValues(final String paramName) { if (requestParameters == null) { return null; } return requestParameters.get(paramName); } \nResponse:", "ground_truth": "Returns all values all of the values the given request parameter has.", "predict": " Get the values of a request parameter. @param paramName The name of the parameter whose values are sought. @return The values of the parameter, or null if the parameter does not exist."}
{"ID": 1426, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FileUpload getFile(final String paramName) { if (requestFiles == null) { return null; } FileUpload[] values = requestFiles.get(paramName); if ((values != null) && (values.length > 0)) { return values[0]; } return null; } \nResponse:", "ground_truth": "Returns uploaded file.\n@param paramName parameter name of the uploaded file\n@return uploaded file or <code>null</code> if parameter name not found", "predict": " Get the uploaded file for the given parameter name. @param paramName The parameter name. @return The uploaded file or null if none."}
{"ID": 1427, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FileUpload[] getFiles(final String paramName) { if (requestFiles == null) { return null; } return requestFiles.get(paramName); } \nResponse:", "ground_truth": "Returns all uploaded files the given request parameter has.", "predict": " Getter for uploaded files. @param paramName Parameter name. @return Array of uploaded files. May be null."}
{"ID": 1428, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void init(final FilterConfig filterConfig) { this.filterConfig = filterConfig; this.encoding = filterConfig.getInitParameter(\"encoding\"); if (this.encoding == null) { this.encoding = JoddCore.encoding; } this.ignore = Converter.get().toBooleanValue(filterConfig.getInitParameter(\"ignore\"), true); } \nResponse:", "ground_truth": "Place this filter into service.\n\n@param filterConfig The filter configuration object", "predict": " Initializes the filter. Called by the servlet container upon doFilter initialization. @param filterConfig The filter configuration object.\n*/"}
{"ID": 1429, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void parse(final DbSqlBuilder sqlBuilder, final String template) { int length = template.length(); int last = 0; while (true) { int mark = template.indexOf('$', last); if (mark == -1) { if (last < length) { sqlBuilder.appendRaw(template.substring(last)); } break; } int escapesCount = countEscapes(template, mark); // check if escaped if (escapesCount > 0) { boolean isEscaped = escapesCount % 2 != 0; int escapesToAdd = escapesCount >> 1; sqlBuilder.appendRaw(template.substring(last, mark - escapesCount + escapesToAdd) + '$'); if (isEscaped) { last = mark + 1; continue; } } else { sqlBuilder.appendRaw(template.substring(last, mark)); } int end; if (template.startsWith(MACRO_TABLE, mark)) { mark += MACRO_TABLE.length(); end = findMacroEnd(template, mark); onTable(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_COLUMN, mark)) { mark += MACRO_COLUMN.length(); end = findMacroEnd(template, mark); onColumn(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_MATCH, mark)) { mark += MACRO_MATCH.length(); end = findMacroEnd(template, mark); onMatch(sqlBuilder, template.substring(mark, end)); } else if (template.startsWith(MACRO_VALUE, mark)) { mark += MACRO_VALUE.length(); end = findMacroEnd(template, mark); onValue(sqlBuilder, template.substring(mark, end)); } else { mark++; // reference found end = mark; // find macro end while (end < length) { if (!isReferenceChar(template, end)) { break; } end++; } onReference(sqlBuilder, template.substring(mark, end)); end--; } end++; last = end; } } \nResponse:", "ground_truth": "Parses template and returns generated sql builder.", "predict": " Parse template replacing macros by sql. @param sqlBuilder builder to append sql to. @param template template to parse."}
{"ID": 1430, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int findMacroEnd(final String template, final int fromIndex) { int endIndex = template.indexOf('}', fromIndex); if (endIndex == -1) { throw new DbSqlBuilderException(\"Template syntax error, some macros are not closed. Error at: '...\" + template.substring(fromIndex)); } return endIndex; } \nResponse:", "ground_truth": "Finds macros end.", "predict": " Finds macro end. @param template Template. @param fromIndex From index. @return Macro end index."}
{"ID": 1431, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected int countEscapes(final String template, int macroIndex) { macroIndex--; int escapeCount = 0; while (macroIndex >= 0) { if (template.charAt(macroIndex) != ESCAPE_CHARACTER) { break; } escapeCount++; macroIndex--; } return escapeCount; } \nResponse:", "ground_truth": "Count escapes to the left.", "predict": " Counts how many escape characters are in the macro replacement string. Escapes are preceded by a macro placeholder. Therefore, the escape character itself counts as one escape character. @param template The template string. @param macroIndex The index of the macro placeholder. @return The number of escape characters."}
{"ID": 1432, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String buildQuery(final HttpMultiMap<?> queryMap, final String encoding) { if (queryMap.isEmpty()) { return StringPool.EMPTY; } int queryMapSize = queryMap.size(); StringBand query = new StringBand(queryMapSize * 4); int count = 0; for (Map.Entry<String, ?> entry : queryMap) { String key = entry.getKey(); key = URLCoder.encodeQueryParam(key, encoding); Object value = entry.getValue(); if (value == null) { if (count != 0) { query.append('&'); } query.append(key); count++; } else { if (count != 0) { query.append('&'); } query.append(key); count++; query.append('='); String valueString = URLCoder.encodeQueryParam(value.toString(), encoding); query.append(valueString); } } return query.toString(); } \nResponse:", "ground_truth": "Builds a query string from given query map.", "predict": " Build query string. @param queryMap query map. @param encoding query encoding. @return query string."}
{"ID": 1433, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static HttpMultiMap<String> parseQuery(final String query, final boolean decode) { final HttpMultiMap<String> queryMap = HttpMultiMap.newCaseInsensitiveMap(); if (StringUtil.isBlank(query)) { return queryMap; } int lastNdx = 0; while (lastNdx < query.length()) { int ndx = query.indexOf('&', lastNdx); if (ndx == -1) { ndx = query.length(); } final String paramAndValue = query.substring(lastNdx, ndx); ndx = paramAndValue.indexOf('='); if (ndx == -1) { queryMap.add(paramAndValue, null); } else { String name = paramAndValue.substring(0, ndx); if (decode) { name = URLDecoder.decodeQuery(name); } String value = paramAndValue.substring(ndx + 1); if (decode) { value = URLDecoder.decodeQuery(value); } queryMap.add(name, value); } lastNdx += paramAndValue.length() + 1; } return queryMap; } \nResponse:", "ground_truth": "Parses query from give query string. Values are optionally decoded.", "predict": " Decodes and parses query string. @param query Query string to decode and parse. @param decode Controls whether decoding is performed. @return Parsed query map."}
{"ID": 1434, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String prepareHeaderParameterName(final String headerName) { // special cases if (headerName.equals(\"etag\")) { return HttpBase.HEADER_ETAG; } if (headerName.equals(\"www-authenticate\")) { return \"WWW-Authenticate\"; } char[] name = headerName.toCharArray(); boolean capitalize = true; for (int i = 0; i < name.length; i++) { char c = name[i]; if (c == '-') { capitalize = true; continue; } if (capitalize) { name[i] = Character.toUpperCase(c); capitalize = false; } else { name[i] = Character.toLowerCase(c); } } return new String(name); } \nResponse:", "ground_truth": "Makes nice header names.", "predict": " Prepares header parameter name. @param headerName Header name. @return Prepared header parameter name."}
{"ID": 1435, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String extractMediaType(final String contentType) { int index = contentType.indexOf(';'); if (index == -1) { return contentType; } return contentType.substring(0, index); } \nResponse:", "ground_truth": "Extracts media-type from value of \"Content Type\" header.", "predict": " Extracts the media type from the content type header. @param contentType the content type header. @return the media type.\n*/"}
{"ID": 1436, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String toHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visit(renderer); return appendable.toString(); } \nResponse:", "ground_truth": "Renders node to appendable.", "predict": " Render the AST to HTML using the supplied Appendable. Useful for debugging purposes. @param node The root node of the AST to render. @param appendable The Appendable to render the AST to. @return The HTML rendering of the AST."}
{"ID": 1437, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String toInnerHtml(final Node node, final Appendable appendable) { NodeVisitor renderer = createRenderer(appendable); node.visitChildren(renderer); return appendable.toString(); } \nResponse:", "ground_truth": "Renders node children to appendable.", "predict": " Render the node to HTML using the supplied appendable. The appendable will be flushed after rendering. @param node The node to render. @param appendable The appendable to render to. @return The rendered HTML."}
{"ID": 1438, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void configureWith(final ServletContext servletContext) { webAppClassName = servletContext.getInitParameter(PARAM_MADVOC_WEBAPP); paramsFiles = Converter.get().toStringArray(servletContext.getInitParameter(PARAM_MADVOC_PARAMS)); madvocConfiguratorClassName = servletContext.getInitParameter(PARAM_MADVOC_CONFIGURATOR); } \nResponse:", "ground_truth": "Configures Madvoc by reading context init parameters.", "predict": " Configures Madvoc with servlet context init parameters. Usually Madvoc is configured via MadvocServletMadvocConfiguratorMadvocConfiguratorMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMadvocMad"}
{"ID": 1439, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void reset() { this.ndx = 0; this.textLen = 0; this.path = new Path(); this.notFirstObject = false; if (useAltPaths) { path.altPath = new Path(); } if (classMetadataName != null) { mapToBean = createMapToBean(classMetadataName); } } \nResponse:", "ground_truth": "Resets JSON parser, so it can be reused.", "predict": " Reinitialize the state of this converter. Useful for testing purposes.\n*/"}
{"ID": 1440, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonParser lazy(final boolean lazy) { this.lazy = lazy; this.mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER; this.listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER; return this; } \nResponse:", "ground_truth": "Defines how JSON parser works. In non-lazy mode, the whole JSON is parsed as it is.\nIn the lazy mode, not everything is parsed, but some things are left lazy.\nThis way we gain performance, especially on partial usage of the whole JSON.\nHowever, be aware that parser holds the input memory until the returned\nobjects are disposed.", "predict": " Configure parser to produce lazy collections. Default lazy collections are eagerly instantiated upon first use. @param lazy true to produce lazy collections, false otherwise. @return fluent API\n*/"}
{"ID": 1441, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class replaceWithMappedTypeForPath(final Class target) { if (mappings == null) { return target; } Class newType; // first try alt paths Path altPath = path.getAltPath(); if (altPath != null) { if (!altPath.equals(path)) { newType = mappings.get(altPath); if (newType != null) { return newType; } } } // now check regular paths newType = mappings.get(path); if (newType != null) { return newType; } return target; } \nResponse:", "ground_truth": "Replaces type with mapped type for current path.", "predict": " Replace the target class with the mapped type for the given path. Useful for ensuring that the target class is not proxied. @param target The target class. @return The mapped type.\n*/"}
{"ID": 1442, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> List<T> parseAsList(final String string, final Class<T> componentType) { return new JsonParser() .map(JsonParser.VALUES, componentType) .parse(string); } \nResponse:", "ground_truth": "Parses input JSON to a list with specified component type.", "predict": " Parse a JSON string into a list of objects of the specified component type. @param string The JSON string to parse. @param componentType The component type of the resulting list. @param <T> The component type of the resulting list. @return The list of objects."}
{"ID": 1443, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <K, V> Map<K, V> parseAsMap( final String string, final Class<K> keyType, final Class<V> valueType) { return new JsonParser() .map(JsonParser.KEYS, keyType) .map(JsonParser.VALUES, valueType) .parse(string); } \nResponse:", "ground_truth": "Parses input JSON to a list with specified key and value types.", "predict": " Parse a JSON string into a map. @param string The JSON string to parse. @param keyType The type of keys in the resulting map. @param valueType The type of values in the resulting map. @return The resulting map.\n*/"}
{"ID": 1444, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Object resolveLazyValue(Object value) { if (value instanceof Supplier) { value = ((Supplier)value).get(); } return value; } \nResponse:", "ground_truth": "Resolves lazy value during the parsing runtime.", "predict": " Resolves lazy values. Supplier values are evaluated lazily. Others are simply returned. @param value The lazy value to resolve. @return The resolved value."}
{"ID": 1445, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void skipObject() { int bracketCount = 1; boolean insideString = false; while (ndx < total) { final char c = input[ndx]; if (insideString) { if (c == '\\\"' && notPrecededByEvenNumberOfBackslashes()) { insideString = false; } } else if (c == '\\\"') { insideString = true; } else if (c == '{') { bracketCount++; } else if (c == '}') { bracketCount--; if (bracketCount == 0) { ndx++; return; } } ndx++; } } \nResponse:", "ground_truth": "Skips over complete object. It is not parsed, just skipped. It will be\nparsed later, but only if required.", "predict": " Skips over an object. Opening curly brace is considered opening a value. Closing curly brace is considered closing a value. Opening bracket is considered opening an array. Closing bracket is considered closing an array. Comma separates values. Whitespaces are ignored. Quote marks quote a value. End of line signifies end of a value. Premature closing bracket signifies syntax error. Premature opening bracket signifies syntax error. Prematurely enclosed comma signifies syntax error. Prematurely enclosed quotes signifies syntax error. Prematurely enclosed closing curly brace signifies syntax error. Prematurely enclosed opening curly brace signifies syntax error. Prematurely enclosed comma signifies syntax error. Prematurely enclosed opening bracket signifies syntax error. Prematurely enclosed quote signifies syntax error. Prematurely enclosed whitespace signifies syntax error. Prematurely enclosed colon signifies syntax error. Prematurely enclosed semicolon signifies syntax error. Prematurely enclosed equals signifies syntax error. Prematurely enclosed pound signifies syntax error. Prematurely enclosed percent signifies syntax error. Prematurely enclosed caret signifies syntax error."}
{"ID": 1446, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseString() { char quote = '\\\"'; if (looseMode) { quote = consumeOneOf('\\\"', '\\''); if (quote == 0) { return parseUnquotedStringContent(); } } else { consume(quote); } return parseStringContent(quote); } \nResponse:", "ground_truth": "Parses a string.", "predict": " Parse a quoted or unquoted string literal. The opening quote has already been consumed. Consumed quote will be stored in consumeQuote. Upon return, consumeQuote will hold the terminating quote character. Outside of loose mode, quotes are preserved in the lexer input stream. Within loose mode, quotes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream. Within loose mode, escapes are discarded. Outside of loose mode, escapes are preserved in the lexer input stream"}
{"ID": 1447, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseStringContent(final char quote) { final int startNdx = ndx; // roll-out until the end of the string or the escape char while (true) { final char c = input[ndx]; if (c == quote) { // no escapes found, just use existing string ndx++; return new String(input, startNdx, ndx - 1 - startNdx); } if (c == '\\\\') { break; } ndx++; } // escapes found, proceed differently textLen = ndx - startNdx; growEmpty(); // for (int i = startNdx, j = 0; j < textLen; i++, j++) { // text[j] = input[i]; // } System.arraycopy(input, startNdx, text, 0, textLen); // escape char, process everything until the end while (true) { char c = input[ndx]; if (c == quote) { // done ndx++; final String str = new String(text, 0, textLen); textLen = 0; return str; } if (c == '\\\\') { // escape char found ndx++; c = input[ndx]; switch (c) { case '\\\"' : c = '\\\"'; break; case '\\\\' : c = '\\\\'; break; case '/' : c = '/'; break; case 'b' : c = '\\b'; break; case 'f' : c = '\\f'; break; case 'n' : c = '\\n'; break; case 'r' : c = '\\r'; break; case 't' : c = '\\t'; break; case 'u' : ndx++; c = parseUnicode(); break; default: if (looseMode) { if (c != '\\'') { c = '\\\\'; ndx--; } } else { syntaxError(\"Invalid escape char: \" + c); } } } text[textLen] = c; textLen++; growAndCopy(); ndx++; } } \nResponse:", "ground_truth": "Parses string content, once when starting quote has been consumed.", "predict": " Parses a quoted string token. Strips escaped quotes and comments. Escapes quotes inside quoted strings ('\"\"'). Comments are stripped. Stripped quotes are escaped with doubling ('\"\"'). Escaping quotes inside comments is not supported. Stripped comments are ignored. Stripped escapes are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped escapes are ignored. Stripped comments are ignored. Stripped"}
{"ID": 1448, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected char parseUnicode() { int i0 = CharUtil.hex2int(input[ndx++]); int i1 = CharUtil.hex2int(input[ndx++]); int i2 = CharUtil.hex2int(input[ndx++]); int i3 = CharUtil.hex2int(input[ndx]); return (char) ((i0 << 12) + (i1 << 8) + (i2 << 4) + i3); } \nResponse:", "ground_truth": "Parses 4 characters and returns unicode character.", "predict": " Parse unicode escape sequence. Expecting 4 hex digits. @return parsed unicode char.\n*/"}
{"ID": 1449, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String parseUnquotedStringContent() { final int startNdx = ndx; while (true) { final char c = input[ndx]; if (c <= ' ' || CharUtil.equalsOne(c, UNQUOTED_DELIMETERS)) { final int currentNdx = ndx; // done skipWhiteSpaces(); return new String(input, startNdx, currentNdx - startNdx); } ndx++; } } \nResponse:", "ground_truth": "Parses un-quoted string content.", "predict": " Skips all contiguous white spaces and extracts a string content. The terminator of the string is NOT considered as white spaces. However, escaped double quotes are considered as white spaces. Therefore, the string content extracted MAY contain escaped double quotes. However, escaped double quotes appearing inside the string content are NOT considered as white spaces. Moreover, a double quote appearing as the last character of the string content is NOT considered as white spaces. However, a double quote appearing as the first character of the string content is considered as white spaces. Therefore, the string content extracted MAY contain double quotes at the beginning and at the end of the string content. However, double quotes appearing as the last character of the string content are NOT considered as white spaces. Moreover, double quotes appearing as the first character of the string content are considered as white spaces. Therefore, the string content extracted MAY contain double quotes at the beginning and at the end of the string content. However, escaped double quotes appearing as the last character of the string content are NOT considered as white spaces. Moreover, escaped double quotes appearing"}
{"ID": 1450, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Number parseNumber() { final int startIndex = ndx; char c = input[ndx]; boolean isDouble = false; boolean isExp = false; if (c == '-') { ndx++; } while (true) { if (isEOF()) { break; } c = input[ndx]; if (c >= '0' && c <= '9') { ndx++; continue; } if (c <= 32) { // white space break; } if (c == ',' || c == '}' || c == ']') { // delimiter break; } if (c == '.') { isDouble = true; } else if (c == 'e' || c == 'E') { isExp = true; } ndx++; } final String value = new String(input, startIndex, ndx - startIndex); if (isDouble) { return Double.valueOf(value); } long longNumber; if (isExp) { longNumber = Double.valueOf(value).longValue(); } else { if (value.length() >= 19) { // if string is 19 chars and longer, it can be over the limit BigInteger bigInteger = new BigInteger(value); if (isGreaterThanLong(bigInteger)) { return bigInteger; } longNumber = bigInteger.longValue(); } else { longNumber = Long.parseLong(value); } } if ((longNumber >= Integer.MIN_VALUE) && (longNumber <= Integer.MAX_VALUE)) { return (int) longNumber; } return longNumber; } \nResponse:", "ground_truth": "Parses JSON numbers.", "predict": " Parse a Number from the input. Whitespace between digits is skipped. Scientific notation is also recognized. Scientific notation is indicated by a 'e' or 'E' appearing somewhere in the mantissa. The mantissa may contain more digits than can fit into a long. In this case, the excess digits are silently discarded. The mantissa may also contain a decimal point ('.') followed by digits appearing after the decimal point. In this case, the decimal point itself is discarded, and the mantissa is interpreted as a rational number. The mantissa may also be empty, in which case NaN is returned. The exponent may be negative, but must not be zero. Negative exponents imply multiplying by a power of ten (-ve exponent). Thus, mantissa * 10^exponent yields mantissa * 2^exponent. Scientific notation is indicated by a 'e' or 'E' appearing somewhere in the mantissa. The mantissa may contain more digits than can fit into a long. In this case, the excess digits are silently discarded. The mant"}
{"ID": 1451, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object parseArrayContent(Class targetType, Class componentType) { // detect special case if (targetType == Object.class) { targetType = List.class; } // continue targetType = replaceWithMappedTypeForPath(targetType); if (componentType == null && targetType != null && targetType.isArray()) { componentType = targetType.getComponentType(); } path.push(VALUES); componentType = replaceWithMappedTypeForPath(componentType); Collection<Object> target = newArrayInstance(targetType); boolean koma = false; mainloop: while (true) { skipWhiteSpaces(); char c = input[ndx]; if (c == ']') { if (koma) { syntaxError(\"Trailing comma\"); } ndx++; path.pop(); return target; } Object value = parseValue(componentType, null, null); target.add(value); skipWhiteSpaces(); c = input[ndx]; switch (c) { case ']': ndx++; break mainloop; case ',': ndx++; koma = true; break; default: syntaxError(\"Invalid char: expected ] or ,\"); } } path.pop(); if (targetType != null) { return convertType(target, targetType); } return target; } \nResponse:", "ground_truth": "Parses arrays, once when open bracket has been consumed.", "predict": " Parse array content. The array brackets are already eaten. Expects to be at '['. Upon eating the '[', it will figure out the component type (@see replaceWithMappedTypeForPath(Class)), and will replace the '['. Upon finding the closing ']', it will return the array. @param targetType the target type @param componentType the component type (may be null) @return the array\n*/"}
{"ID": 1452, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createEmptyCtor() { final MethodVisitor mv = wd.dest.visitMethod(AsmUtil.ACC_PUBLIC, INIT, \"()V\", null, null); mv.visitCode(); mv.visitVarInsn(Opcodes.ALOAD, 0); mv.visitMethodInsn( Opcodes.INVOKESPECIAL, AsmUtil.SIGNATURE_JAVA_LANG_OBJECT, INIT, \"()V\", false); mv.visitInsn(Opcodes.RETURN); mv.visitMaxs(1, 1); mv.visitEnd(); } \nResponse:", "ground_truth": "Created empty default constructor.", "predict": " Creates an empty constructor for the proxy class."}
{"ID": 1453, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createSimpleMethodWrapper(final MethodSignatureVisitor msign) { int access = msign.getAccessFlags(); access &= ~ACC_ABSTRACT; access &= ~ACC_NATIVE; MethodVisitor mv = wd.dest.visitMethod( access, msign.getMethodName(), msign.getDescription(), msign.getAsmMethodSignature(), msign.getExceptions()); mv.visitCode(); mv.visitVarInsn(ALOAD, 0); mv.visitFieldInsn(GETFIELD, wd.thisReference, wd.wrapperRef, wd.wrapperType); loadVirtualMethodArguments(mv, msign); if (wd.wrapInterface) { mv.visitMethodInsn( INVOKEINTERFACE, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), true); } else { mv.visitMethodInsn( INVOKEVIRTUAL, wd.wrapperType.substring(1, wd.wrapperType.length() - 1), msign.getMethodName(), msign.getDescription(), false); } ProxettaAsmUtil.prepareReturnValue(mv, msign, 0); visitReturn(mv, msign, true); mv.visitMaxs(0, 0); mv.visitEnd(); } \nResponse:", "ground_truth": "Creates simple method wrapper without proxy.", "predict": " Create simple method wrapper. Very similar to MethodVisitor.visitMethod except it skips unnecessary stack operations.\n@param msign method signature visitor\n*/"}
{"ID": 1454, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String resolveRawTypeName(String typeName) { if (typeName == null) { return null; } boolean isArray = typeName.startsWith(StringPool.LEFT_SQ_BRACKET); if (isArray) { typeName = typeName.substring(1); } String rawTypeName; if (generics.containsKey(typeName)) { rawTypeName = generics.get(typeName); } else { rawTypeName = declaredTypeGeneric.getOrDefault(typeName, typeName); } if (isArray) { rawTypeName = '[' + rawTypeName; } return rawTypeName; } \nResponse:", "ground_truth": "Resolves raw type name using the generics information from the class\nor method information.", "predict": " Resolves raw type name. @param typeName the type name @return the string\n*/"}
{"ID": 1455, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences resolveReferenceFromValue(final PropertyDescriptor propertyDescriptor, final String refName) { BeanReferences references; if (refName == null || refName.isEmpty()) { references = buildDefaultReference(propertyDescriptor); } else { references = BeanReferences.of(refName); } references = references.removeDuplicateNames(); return references; } \nResponse:", "ground_truth": "Resolves reference from given values. Returns bean reference of given value or defaults\nif given name is blank.", "predict": " Resolve a reference from the value of the property descriptor. @param propertyDescriptor the property descriptor. @param refName the reference name. @return the resolved references. Never null."}
{"ID": 1456, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) { BeanReferences[] references = convertRefToReferences(parameterReferences); if (references == null || references.length == 0) { references = buildDefaultReferences(methodOrCtor); } if (methodOrCtor.getParameterTypes().length != references.length) { throw new PetiteException(\"Different number of method parameters and references for: \" + methodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName()); } removeAllDuplicateNames(references); return references; } \nResponse:", "ground_truth": "Takes given parameters references and returns reference set for given method or constructor.", "predict": " Resolves references from method parameters and values. @param methodOrCtor Petite method or constructor @param parameterReferences References to resolve from values @return References to resolve from method parameters and values\n"}
{"ID": 1457, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences[] readAllReferencesFromAnnotation(final Executable methodOrCtor) { PetiteInject petiteInject = methodOrCtor.getAnnotation(PetiteInject.class); final Parameter[] parameters = methodOrCtor.getParameters(); BeanReferences[] references; final boolean hasAnnotationOnMethodOrCtor; if (petiteInject != null) { references = convertAnnValueToReferences(petiteInject.value()); hasAnnotationOnMethodOrCtor = true; } else { references = new BeanReferences[parameters.length]; hasAnnotationOnMethodOrCtor = false; } int parametersWithAnnotationCount = 0; for (int i = 0; i < parameters.length; i++) { Parameter parameter = parameters[i]; petiteInject = parameter.getAnnotation(PetiteInject.class); if (petiteInject == null) { // no annotation on argument continue; } // there is annotation on argument, override values String annotationValue = readAnnotationValue(petiteInject); if (annotationValue != null) { references[i] = BeanReferences.of(annotationValue); } parametersWithAnnotationCount++; } if (!hasAnnotationOnMethodOrCtor) { if (parametersWithAnnotationCount == 0) { return null; } if (parametersWithAnnotationCount != parameters.length) { throw new PetiteException(\"All arguments must be annotated with PetiteInject\"); } } references = updateReferencesWithDefaultsIfNeeded(methodOrCtor, references); removeAllDuplicateNames(references); return references; } \nResponse:", "ground_truth": "Extracts references from method or constructor annotation.", "predict": " Reads references from PetiteInject annotation on method or constructor. @param methodOrCtor Petite injection method or constructor. @return References array. May be empty array. Never null."}
{"ID": 1458, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] buildDefaultReferences(final Executable methodOrCtor) { final boolean useParamo = petiteConfig.getUseParamo(); final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); MethodParameter[] methodParameters = null; if (useParamo) { methodParameters = Paramo.resolveParameters(methodOrCtor); } final Class[] paramTypes = methodOrCtor.getParameterTypes(); final BeanReferences[] references = new BeanReferences[paramTypes.length]; for (int j = 0; j < paramTypes.length; j++) { String[] ref = new String[lookupReferences.length]; references[j] = BeanReferences.of(ref); for (int i = 0; i < ref.length; i++) { switch (lookupReferences[i]) { case NAME: ref[i] = methodParameters != null ? methodParameters[j].getName() : null; break; case TYPE_SHORT_NAME: ref[i] = StringUtil.uncapitalize(paramTypes[j].getSimpleName()); break; case TYPE_FULL_NAME: ref[i] = paramTypes[j].getName(); break; } } } return references; } \nResponse:", "ground_truth": "Builds default method references.", "predict": " Builds references for all parameters of given method or constructor. References are resolved using lookup strategy. References are also resolved using reflection. References are also resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Petite annotations. References are resolved using Pet"}
{"ID": 1459, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences buildDefaultReference(final PropertyDescriptor propertyDescriptor) { final PetiteReferenceType[] lookupReferences = petiteConfig.getLookupReferences(); final String[] references = new String[lookupReferences.length]; for (int i = 0; i < references.length; i++) { switch (lookupReferences[i]) { case NAME: references[i] = propertyDescriptor.getName(); break; case TYPE_SHORT_NAME: references[i] = StringUtil.uncapitalize(propertyDescriptor.getType().getSimpleName()); break; case TYPE_FULL_NAME: references[i] = propertyDescriptor.getType().getName(); break; } } return BeanReferences.of(references); } \nResponse:", "ground_truth": "Builds default field references.", "predict": " Build default PetiteReference for bean property. @param propertyDescriptor Petite bean property descriptor. @return Default PetiteReference."}
{"ID": 1460, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void removeAllDuplicateNames(final BeanReferences[] allBeanReferences) { for (int i = 0; i < allBeanReferences.length; i++) { BeanReferences references = allBeanReferences[i]; allBeanReferences[i] = references.removeDuplicateNames(); } } \nResponse:", "ground_truth": "Removes duplicate names from bean references.", "predict": " Remove duplicate names from all references. @param allBeanReferences References to analyze. Shall not be <code>null</code>.\n"}
{"ID": 1461, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] convertRefToReferences(final String[] references) { if (references == null) { return null; } BeanReferences[] ref = new BeanReferences[references.length]; for (int i = 0; i < references.length; i++) { ref[i] = BeanReferences.of(references[i]); } return ref; } \nResponse:", "ground_truth": "Converts single string array to an array of bean references.", "predict": " Convert references to references. @param references References to convert. @return References converted.\n*/"}
{"ID": 1462, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private BeanReferences[] convertAnnValueToReferences(String value) { if (value == null) { return null; } value = value.trim(); if (value.length() == 0) { return null; } String[] refNames = Converter.get().toStringArray(value); BeanReferences[] references = new BeanReferences[refNames.length]; for (int i = 0; i < refNames.length; i++) { references[i] = BeanReferences.of(refNames[i].trim()); } return references; } \nResponse:", "ground_truth": "Converts comma-separated string into array of Bean references.", "predict": " Convert a comma separated list of references to an array of references. @param value comma separated list of references @return array of references or null if empty or null\n*/"}
{"ID": 1463, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void runJoy(final Consumer<JoddJoyRuntime> consumer) { final JoddJoy joddJoy = new JoddJoy(); final JoddJoyRuntime joyRuntime = joddJoy.startOnlyBackend(); joddJoy.withDb(joyDb -> setJtxManager(joyRuntime.getJtxManager())); final JtxTransaction tx = startRwTx(); final Print print = new Print(); try { print.line(\"START\", 80); print.newLine(); consumer.accept(joyRuntime); print.newLine(); print.line(\"END\", 80); if (tx != null) { tx.commit(); } } catch (Throwable throwable) { throwable.printStackTrace(); if (tx != null) { tx.rollback(); } } joddJoy.stop(); } \nResponse:", "ground_truth": "Runs JOY in standalone mode, with only backend.", "predict": " Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy Joy"}
{"ID": 1464, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Method findMethod(final Class c, final String methodName) { return findDeclaredMethod(c, methodName, true); } \nResponse:", "ground_truth": "Returns method from an object, matched by name. This may be considered as\na slow operation, since methods are matched one by one.\nReturns only accessible methods.\nOnly first method is matched.\n\n@param c          class to examine\n@param methodName Full name of the method.\n@return null if method not found", "predict": " Finds a declared method in a class hierarchy. @param c The class to introspect. @param methodName The name of the method to find. @return The method or null if none found."}
{"ID": 1465, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> Constructor<T> findConstructor(final Class<T> clazz, final Class<?>... parameterTypes) { final Constructor<?>[] constructors = clazz.getConstructors(); Class<?>[] pts; for (Constructor<?> constructor : constructors) { pts = constructor.getParameterTypes(); if (isAllAssignableFrom(pts, parameterTypes)) { return (Constructor<T>) constructor; } } return null; } \nResponse:", "ground_truth": "Finds constructor with given parameter types. First matched ctor is returned.", "predict": " Finds a constructor that matches the given parameter types. @param clazz The class to introspect. @param parameterTypes The parameter types to look for. @return The constructor, or null if none found.\n*/"}
{"ID": 1466, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class[] resolveAllInterfaces(final Class type) { Set<Class> bag = new LinkedHashSet<>(); _resolveAllInterfaces(type, bag); return bag.toArray(new Class[0]); } \nResponse:", "ground_truth": "Resolves all interfaces of a type. No duplicates are returned.\nDirect interfaces are prior the interfaces of subclasses in\nthe returned array.", "predict": " Resolve all interfaces for the given type. @param type The type to resolve. @return The resolved interfaces. Shall not be <code>null</code>. Shall contain at least one element. Shall not be empty. Shall not contain any <code>null</code> element. Shall not contain duplicates. Shall not contain interfaces that are not resolved. Shall not contain interfaces that are not interfaces. Shall not contain interfaces that are not visible. Shall not contain interfaces that are not visible. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited. Shall not contain interfaces that are not inherited"}
{"ID": 1467, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean compareParameters(final Class[] first, final Class[] second) { if (first.length != second.length) { return false; } for (int i = 0; i < first.length; i++) { if (first[i] != second[i]) { return false; } } return true; } \nResponse:", "ground_truth": "Compares classes, usually method or ctor parameters.", "predict": " Compare two arrays of classes. @param first First array of classes. @param second Second array of classes. @return True if both arrays are equal. False otherwise."}
{"ID": 1468, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void forceAccess(final AccessibleObject accObject) { try { if (System.getSecurityManager() == null) accObject.setAccessible(true); else { AccessController.doPrivileged((PrivilegedAction) () -> { accObject.setAccessible(true); return null; }); } } catch (SecurityException sex) { // ignore } } \nResponse:", "ground_truth": "Suppress access check against a reflection object. SecurityException is silently ignored.\nChecks first if the object is already accessible.", "predict": " Forces accessibility of the given AccessibleObject. Useful for poking holes through vetoable change listeners. Useful for poking holes through inaccessible Swing components. Useful for poking holes through inaccessible Applets. Useful for poking holes through inaccessible AWT components. Useful for poking holes through inaccessible Sun Glass components. Useful for poking holes through inaccessible IBM Glass components. Useful for poking holes through inaccessible Microsoft Office PowerPoint components. Useful for poking holes through inaccessible Microsoft Word components. Useful for poking holes through inaccessible Microsoft Excel components. Useful for poking holes through inaccessible Microsoft PowerPoint 2007 components. Useful for poking holes through inaccessible Microsoft Word 2007 components. Useful for poking holes through inaccessible Microsoft Word 2010 components. Useful for poking holes through inaccessible Microsoft PowerPoint 2010 components. Useful for poking holes through inaccessible Microsoft Word 2013 components. Useful for poking holes through inaccessible Microsoft PowerPoint 2013 components. Useful for poking holes through inaccessible Microsoft Word 2013 components. Useful for poking holes through inaccessible Microsoft PowerPoint 2013 components. Useful for poking holes through inaccessible Microsoft Word 2013 components. Useful for poking holes through inaccessible Microsoft PowerPoint 2013 components. Useful for poking holes through inaccessible Microsoft Word"}
{"ID": 1469, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <T> T newInstance(final Class<T> clazz, final Object... params) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException { if (params.length == 0) { return newInstance(clazz); } final Class<?>[] paramTypes = getClasses(params); final Constructor<?> constructor = findConstructor(clazz, paramTypes); if (constructor == null) { throw new InstantiationException(\"No constructor matched parameter types.\"); } return (T) constructor.newInstance(params); } \nResponse:", "ground_truth": "Creates new instance of given class with given optional arguments.", "predict": " Creates a new instance of the given class using reflection. The constructor with the most parameters will be used. If no constructor matches the given parameters, an InstantiationException will be thrown. @param clazz The class to instantiate. @param params The constructor parameters. @return The new instance. @throws InstantiationException If no constructor matches the given parameters. @throws IllegalAccessException If the constructor is inaccessible. @throws InvocationTargetException If the constructor throws an exception. @throws NoSuchMethodException If the constructor does not exist."}
{"ID": 1470, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class[] getSuperclasses(final Class type) { int i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { i++; } Class[] result = new Class[i]; i = 0; for (Class x = type.getSuperclass(); x != null; x = x.getSuperclass()) { result[i] = x; i++; } return result; } \nResponse:", "ground_truth": "Returns all superclasses.", "predict": " Get all superclasses of a class. @param type The class to introspect. @return The superclasses. Never <code>null</code>. Might be empty."}
{"ID": 1471, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class<?> childClassOf(final Class<?> parentClass, final Object instance) { if (instance == null || instance == Object.class) { return null; } if (parentClass != null) { if (parentClass.isInterface()) { return null; } } Class<?> childClass = instance.getClass(); while (true) { Class<?> parent = childClass.getSuperclass(); if (parent == parentClass) { return childClass; } if (parent == null) { return null; } childClass = parent; } } \nResponse:", "ground_truth": "Returns the class of the immediate subclass of the given parent class for\nthe given object instance; or null if such immediate subclass cannot be\nuniquely identified for the given object instance.", "predict": " Returns the child class of the given parent class. If the given parent class is null, null is returned. If the given parent class is Object.class, null is returned. If the given parent class is an interface, null is returned. Otherwise, the child class of the given parent class is returned. @param parentClass the parent class. @param instance the instance whose child class is sought. @return the child class of the given parent class."}
{"ID": 1472, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JarFile jarFileOf(final Class<?> klass) { URL url = klass.getResource( \"/\" + klass.getName().replace('.', '/') + \".class\"); if (url == null) { return null; } String s = url.getFile(); int beginIndex = s.indexOf(\"file:\") + \"file:\".length(); int endIndex = s.indexOf(\".jar!\"); if (endIndex == -1) { return null; } endIndex += \".jar\".length(); String f = s.substring(beginIndex, endIndex); // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder.decode(f, \"UTF-8\"); File file = new File(f); try { return file.exists() ? new JarFile(file) : null; } catch (IOException e) { throw new IllegalStateException(e); } } \nResponse:", "ground_truth": "Returns the jar file from which the given class is loaded; or null\nif no such jar file can be located.", "predict": " Returns the JarFile containing the given class. The JarFile is located via the classloader of the given class. @param klass The class whose classloader should be used to locate the JarFile. @return The JarFile containing the given class. May be null.\n"}
{"ID": 1473, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void sleep(final long ms) { try { Thread.sleep(ms); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Puts a thread to sleep, without throwing an InterruptedException.\n\n@param ms     the length of time to sleep in milliseconds", "predict": " Sleep for the given amount of milliseconds. @param ms Milliseconds to sleep."}
{"ID": 1474, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void sleep() { try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException iex) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Puts a thread to sleep forever.", "predict": " Sleep forever. Useful for testing purposes."}
{"ID": 1475, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void wait(final Object obj) { synchronized (obj) { try { obj.wait(); } catch (InterruptedException inex) { Thread.currentThread().interrupt(); } } } \nResponse:", "ground_truth": "Waits for a object for synchronization purposes.", "predict": " Wait for the given object to become signaled. The interrupted status of the current thread is preserved. @param obj The object to wait on."}
{"ID": 1476, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ThreadFactory daemonThreadFactory(final String name, final int priority) { return new ThreadFactory() { private AtomicInteger count = new AtomicInteger(); @Override public Thread newThread(final Runnable r) { Thread thread = new Thread(r); thread.setName(name + '-' + count.incrementAndGet()); thread.setDaemon(true); thread.setPriority(priority); return thread; } }; } \nResponse:", "ground_truth": "Creates new daemon thread factory.", "predict": " Thread factory that spawns threads with a priority higher than the priority of the spawning thread. Useful for spawning threads that are daemon threads. @param name Name of spawned thread. @param priority Priority of spawned thread. @return Thread factory."}
{"ID": 1477, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public T get() { if (!initialized) { synchronized (this) { if (!initialized) { final T t = supplier.get(); value = t; initialized = true; supplier = null; return t; } } } return value; } \nResponse:", "ground_truth": "Returns the value. Value will be computed on first call.", "predict": " Get the value. If not initialized, initialize it with supplier.get(). Else, return cached value. @return value\n*/"}
{"ID": 1478, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitParameter(final String name, final int access) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitParameter(name, access); } } \nResponse:", "ground_truth": "Visits a parameter of this method.\n\n@param name parameter name or null if none is provided.\n@param access the parameter's access flags, only {@code ACC_FINAL}, {@code ACC_SYNTHETIC}\nor/and {@code ACC_MANDATED} are allowed (see {@link Opcodes}).", "predict": " Visits a formal parameter of this method. @param name the parameter name. @param access the parameter access flags, only <tt>ACC_FINAL</tt>, <tt>ACC_SYNTHETIC</tt> or/and <tt>ACC_MANDATED</tt> are allowed (see {@link Opcodes}).\n"}
{"ID": 1479, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (mv != null) { return mv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of this method.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation of the field. @param descriptor the class descriptor of the annotation class. @param visible true if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation. <i>The annotation values must be visited before calling other methods on this annotation visitor</i>.\n*/"}
{"ID": 1480, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitTypeAnnotation( final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitTypeAnnotation(typeRef, typePath, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation on a type in the method signature.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\nTypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\nTypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\nTypeReference#THROWS}. See {@link TypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits a TypeAnnotation on a method or class. @param typeRef a reference to the annotated type. See {@link TypeReference}. @param typePath the path to the annotated type argument, wildcard bound, array element type, or static inner type within 'typeRef'. May be <tt>null</tt> if the annotation targets 'typeRef' as a whole. @param descriptor the class descriptor of the annotation class. @param visible <tt>true</tt> if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation."}
{"ID": 1481, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitParameterAnnotation( final int parameter, final String descriptor, final boolean visible) { if (mv != null) { return mv.visitParameterAnnotation(parameter, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of a parameter this method.\n\n@param parameter the parameter index. This index must be strictly smaller than the number of\nparameters in the method descriptor, and strictly smaller than the parameter count\nspecified in {@link #visitAnnotableParameterCount}. Important note: <i>a parameter index i\nis not required to correspond to the i'th parameter descriptor in the method\ndescriptor</i>, in particular in case of synthetic parameters (see\nhttps://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.18).\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits a parameter annotation of the method. @param parameter the parameter index. @param descriptor the class descriptor of the annotation class. @param visible true if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation. <i>The annotation values must be visited before calling other methods on this annotation visitor</i>.\n*/"}
{"ID": 1482, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitFieldInsn( final int opcode, final String owner, final String name, final String descriptor) { if (mv != null) { mv.visitFieldInsn(opcode, owner, name, descriptor); } } \nResponse:", "ground_truth": "Visits a field instruction. A field instruction is an instruction that loads or stores the\nvalue of a field of an object.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nGETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n@param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).", "predict": " Visits a field instruction. A field instruction is an instruction that loads or stores the value of a field of an object. @param opcode the opcode of the type instruction to be visited. This opcode is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD. @param owner the internal name of the field's owner class (see {@link org.objectweb.asm.Type#getInternalName() getInternalName}). @param name the field's name. @param descriptor the field's descriptor (see {@link org.objectweb.asm.Type Type}). @see org.objectweb.asm.FieldVisitor"}
{"ID": 1483, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitMethodInsn( final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) { if (api < Opcodes.ASM5) { if (isInterface != (opcode == Opcodes.INVOKEINTERFACE)) { throw new IllegalArgumentException(\"INVOKESPECIAL/STATIC on interfaces requires ASM5\"); } visitMethodInsn(opcode, owner, name, descriptor); return; } if (mv != null) { mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface); } } \nResponse:", "ground_truth": "Visits a method instruction. A method instruction is an instruction that invokes a method.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either\nINVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n@param owner the internal name of the method's owner class (see {@link\nType#getInternalName()}).\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param isInterface if the method's owner class is an interface.", "predict": " Visits an invokedynamic instruction."}
{"ID": 1484, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitInvokeDynamicInsn( final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { mv.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments); } } \nResponse:", "ground_truth": "Visits an invokedynamic instruction.\n\n@param name the method's name.\n@param descriptor the method's descriptor (see {@link Type}).\n@param bootstrapMethodHandle the bootstrap method.\n@param bootstrapMethodArguments the bootstrap method constant arguments. Each argument must be\nan {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String}, {@link\nType}, {@link Handle} or {@link ConstantDynamic} value. This method is allowed to modify\nthe content of the array so a caller should expect that this array may change.", "predict": " Visits a INVOKEDYNAMIC instruction. @param name the method name. @param descriptor the method descriptor. @param bootstrapMethodHandle the bootstrap method handle. @param bootstrapMethodArguments the bootstrap method arguments."}
{"ID": 1485, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitJumpInsn(final int opcode, final Label label) { if (mv != null) { mv.visitJumpInsn(opcode, label); } } \nResponse:", "ground_truth": "Visits a jump instruction. A jump instruction is an instruction that may jump to another\ninstruction.\n\n@param opcode the opcode of the type instruction to be visited. This opcode is either IFEQ,\nIFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT,\nIF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n@param label the operand of the instruction to be visited. This operand is a label that\ndesignates the instruction to which the jump instruction may jump.", "predict": " Visits a jump instruction. A jump instruction is an instruction that may jump to another instruction.\n<p>Note that many jumps instructions can come from unreachable code. For example, if the last instruction of a method is a jump instruction, the code instruction will be visited at least once. With this implementation, it may be the case that the code instruction has been visited several times.\n"}
{"ID": 1486, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) { if (mv != null) { mv.visitMultiANewArrayInsn(descriptor, numDimensions); } } \nResponse:", "ground_truth": "Visits a MULTIANEWARRAY instruction.\n\n@param descriptor an array type descriptor (see {@link Type}).\n@param numDimensions the number of dimensions of the array to allocate.", "predict": " Visits a MULTIANEWARRAY instruction. @param descriptor an array type descriptor (see {@link Type}). @param numDimensions number of dimensions of the array to allocate.\n*/"}
{"ID": 1487, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitTryCatchBlock( final Label start, final Label end, final Label handler, final String type) { if (mv != null) { mv.visitTryCatchBlock(start, end, handler, type); } } \nResponse:", "ground_truth": "Visits a try catch block.\n\n@param start the beginning of the exception handler's scope (inclusive).\n@param end the end of the exception handler's scope (exclusive).\n@param handler the beginning of the exception handler's code.\n@param type the internal name of the type of exceptions handled by the handler, or {@literal\nnull} to catch any exceptions (for \"finally\" blocks).\n@throws IllegalArgumentException if one of the labels has already been visited by this visitor\n(by the {@link #visitLabel} method).", "predict": " Visits a try catch block. @param start start of the exception handler's scope (inclusive). @param end end of the exception handler's scope (exclusive). @param handler start of the exception handler's code. @param type internal name of the type of exceptions handled by the handler (-1 if none handled).\n*/"}
{"ID": 1488, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitLocalVariableAnnotation( final int typeRef, final TypePath typePath, final Label[] start, final Label[] end, final int[] index, final String descriptor, final boolean visible) { if (api < Opcodes.ASM5) { throw new UnsupportedOperationException(REQUIRES_ASM5); } if (mv != null) { return mv.visitLocalVariableAnnotation( typeRef, typePath, start, end, index, descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation on a local variable type.\n\n@param typeRef a reference to the annotated type. The sort of this type reference must be\n{@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\nTypeReference}.\n@param typePath the path to the annotated type argument, wildcard bound, array element type, or\nstatic inner type within 'typeRef'. May be {@literal null} if the annotation targets\n'typeRef' as a whole.\n@param start the fist instructions corresponding to the continuous ranges that make the scope\nof this local variable (inclusive).\n@param end the last instructions corresponding to the continuous ranges that make the scope of\nthis local variable (exclusive). This array must have the same size as the 'start' array.\n@param index the local variable's index in each range. This array must have the same size as\nthe 'start' array.\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits a local variable annotation. @param typeRef a reference to the annotated type. See {@link TypeReference}. @param typePath the path to the annotated type argument, wildcard bound, array element type, or static inner type within 'typeRef'. May be <tt>null</tt> if the annotation targets 'typeRef' as a whole. @param start the fist instructions corresponding to the continuous ranges that make the scope of this local variable (inclusive). @param end the last instructions corresponding to the continuous ranges that make the scope of this local variable (exclusive). This array must have the same size as the'start' array. @param index the local variable's index. @param descriptor the class descriptor of the annotation class. @param visible <tt>true</tt> if the annotation is visible at runtime.\n"}
{"ID": 1489, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void convertToWriter(final Writer writer, final Properties properties, final Map<String, Properties> profiles) throws IOException { final BufferedWriter bw = getBufferedWriter(writer); writeBaseAndProfileProperties(bw, properties, profiles); writeProfilePropertiesThatAreNotInTheBase(bw, properties, profiles); bw.flush(); } \nResponse:", "ground_truth": "Convert Java Properties to Jodd Props format\n\n@param writer     Writer to write Props formatted file content to\n@param properties Properties to convert to Props format\n@param profiles   Properties per profile to convert and add to the Props format\n@throws IOException On any I/O error when writing to the writer", "predict": " Write the base and profile properties to the writer. @param writer Writer to write to. @param properties Properties to write. @param profiles Profiles to write. @throws IOException Problems writing to the writer."}
{"ID": 1490, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void processStream() throws IOException { FastByteArrayOutputStream out = new FastByteArrayOutputStream(); size = 0; if (maxFileSize == -1) { size += input.copyAll(out); } else { size += input.copyMax(out, maxFileSize + 1); // one more byte to detect larger files if (size > maxFileSize) { fileTooBig = true; valid = false; input.skipToBoundary(); return; } } data = out.toByteArray(); size = data.length; valid = true; } \nResponse:", "ground_truth": "Reads data from input stream into byte array and stores file size.", "predict": " Detects whether the uploaded file exceeds the maximum allowed size, and, if so, halts the upload process. Otherwise, continues normally.\n */"}
{"ID": 1491, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public T next() { if (hasNext == null) { hasNext = Boolean.valueOf(moveToNext()); } if (hasNext == false) { throw new NoSuchElementException(); } if (!entityAwareMode) { hasNext = null; return newElement; } count++; T result = previousElement; previousElement = newElement; hasNext = null; return result; } \nResponse:", "ground_truth": "Returns next mapped object.", "predict": " Move to next element. @return Next element."}
{"ID": 1492, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private boolean moveToNext() { if (last) { // last has been set to true, so no more rows to iterate - close everything if (closeOnEnd) { query.close(); } else { query.closeResultSet(resultSetMapper.getResultSet()); } return false; } while (true) { if (!resultSetMapper.next()) { // no more rows, no more parsing, previousElement is the last one to iterate last = true; return entityAwareMode; } // parse row Object[] objects = resultSetMapper.parseObjects(types); Object row = query.resolveRowResults(objects); newElement = (T) row; if (entityAwareMode) { if (count == 0 && previousElement == null) { previousElement = newElement; continue; } if (previousElement != null && newElement != null) { boolean equals; if (newElement.getClass().isArray()) { equals = Arrays.equals((Object[]) previousElement, (Object[]) newElement); } else { equals = previousElement.equals(newElement); } if (equals) { continue; } } } break; } return true; } \nResponse:", "ground_truth": "Moves to next element.", "predict": " Move to next row. If no more rows, close everything. If entity aware mode, close previous element. Else, close result set. @return True if there is a next row. False otherwise."}
{"ID": 1493, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(T[]... arrays) { Class<T> componentType = (Class<T>) arrays.getClass().getComponentType().getComponentType(); return join(componentType, arrays); } \nResponse:", "ground_truth": "Joins arrays. Component type is resolved from the array argument.", "predict": " Joins arrays into one big array. Useful for flattening nested arrays. @param arrays Arrays to join. @return Joined array.\n*/"}
{"ID": 1494, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] join(Class<T> componentType, T[][] arrays) { if (arrays.length == 1) { return arrays[0]; } int length = 0; for (T[] array : arrays) { length += array.length; } T[] result = (T[]) Array.newInstance(componentType, length); length = 0; for (T[] array : arrays) { System.arraycopy(array, 0, result, length, array.length); length += array.length; } return result; } \nResponse:", "ground_truth": "Joins arrays using provided component type.", "predict": " Joins arrays into one big array. Useful for flattening nested arrays. @param componentType The component type of the resulting array. @param arrays The arrays to join. @return The resulting array."}
{"ID": 1495, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T[] resize(T[] buffer, int newSize) { Class<T> componentType = (Class<T>) buffer.getClass().getComponentType(); T[] temp = (T[]) Array.newInstance(componentType, newSize); System.arraycopy(buffer, 0, temp, 0, buffer.length >= newSize ? newSize : buffer.length); return temp; } \nResponse:", "ground_truth": "Resizes an array.", "predict": " Resize an array. Copies elements from the old array to the new array respecting the semantics of System.arraycopy. If the new array is bigger than the old one, the extra elements are filled with the old array's default value. If the new array is smaller than the old one, the extra elements are left untouched. @param buffer The array to resize. @param newSize The new size of the array. @return The resized array."}
{"ID": 1496, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> T[] append(T[] buffer, T newElement) { T[] t = resize(buffer, buffer.length + 1); t[buffer.length] = newElement; return t; } \nResponse:", "ground_truth": "Appends an element to array.", "predict": " Increases the capacity of an array if necessary to allow for addition of a new element. Increases the capacity of the backing store storage. Therefore, this method is not efficient for growing exponentially sized arrays. However, for arrays whose size is known beforehand, this method is efficient. @param buffer The array to which the new element is to be appended. @param newElement The new element to be appended to the array. @return The array with the new element appended.\n*/"}
{"ID": 1497, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\"}) public static <T> T[] remove(T[] buffer, int offset, int length, Class<T> componentType) { int len2 = buffer.length - length; T[] temp = (T[]) Array.newInstance(componentType, len2); System.arraycopy(buffer, 0, temp, 0, offset); System.arraycopy(buffer, offset + length, temp, offset, len2 - offset); return temp; } \nResponse:", "ground_truth": "Removes sub-array.", "predict": " Remove a range of elements from the given array. The range is defined by [offset, offset+length). @param buffer The array from which to remove elements. @param offset The offset of the first element to remove. @param length The number of elements to remove. @return The resulting array after removal.\n*/"}
{"ID": 1498, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(char[] array, char value) { for (int i = 0; i < array.length; i++) { if (array[i] == value) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds the first occurrence of an element in an array.", "predict": " Searches for the first occurrence of the given char in the char array. Returns -1 if not found. @param array The char array to search in. @param value The char to search for. @return The index of the first occurrence of the char in the char array or -1 if not found."}
{"ID": 1499, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(Object[] array, Object value) { for (int i = 0; i < array.length; i++) { if (array[i].equals(value)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds the first occurrence in an array.", "predict": " Searches for the first occurrence of the given value in the given array. Returns -1 if the value isn't found.\n@param array The array to search through.\n@param value The value to search for.\n@return The index of the first occurrence of the value in the array, or -1 if the value isn't found.\n*/"}
{"ID": 1500, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int indexOf(byte[] array, byte[] sub, int startIndex) { return indexOf(array, sub, startIndex, array.length); } \nResponse:", "ground_truth": "Finds the first occurrence in an array from specified given position.", "predict": " Starting at the beginning, march towards the end looking for the last occurrence of the bytes in sub. Returns -1 if not found. @param array The array to march through looking for sub. @param sub The bytes to seek. @param startIndex The starting index to begin searching at. @return The index of the first occurrence of sub in array or -1 if not found."}
{"ID": 1501, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public LagartoDOMBuilder enableXhtmlMode() { config.ignoreWhitespacesBetweenTags = false; // collect all whitespaces config.setCaseSensitive(true); // XHTML is case sensitive config.setEnableRawTextModes(false); // all tags are parsed in the same way config.enabledVoidTags = true; // list of void tags config.selfCloseVoidTags = true; // self close void tags config.impliedEndTags = false; // no implied tag ends config.setEnableConditionalComments(false); // don't enable IE conditional comments config.setParseXmlTags(false); // enable XML mode in parsing return this; } \nResponse:", "ground_truth": "Enables XHTML mode.", "predict": " Enables XHTML compliance mode. LagartoDOMBuilder recognizes XHTML conditional comments and ignores whitespaces between tags. LagartoDOMBuilder recognizes self-closing tags and ignores whitespaces between them. Tags without ending tag is parsed as unparsed content. Tags with ending tag is parsed normally. Tags with ending conditional comment is parsed as unparsed content. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with conditional comment is parsed normally. Tags without ending conditional comment is parsed as unparsed content. Tags with"}
{"ID": 1502, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Document parse(final char[] content) { LagartoParser lagartoParser = new LagartoParser(content); return doParse(lagartoParser); } \nResponse:", "ground_truth": "Creates DOM tree from provided content.", "predict": " Lagarto parser doesn't support parsing char array directly. So, we need to convert it into LagartoDocument. Luckily, LagartoDocument is thread safe. Therefore, we can safely use it here. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover, we can safely reuse the parser instance. Moreover,"}
{"ID": 1503, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Document doParse(final LagartoParser lagartoParser) { lagartoParser.setConfig(config); LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor(this); lagartoParser.parse(domBuilderTagVisitor); return domBuilderTagVisitor.getDocument(); } \nResponse:", "ground_truth": "Parses the content using provided lagarto parser.", "predict": " Parse LagartoDOM from LagartoParser. @param lagartoParser LagartoParser instance. @return Document LagartoDOM."}
{"ID": 1504, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void endCurrentBasicBlockWithNoSuccessor() { if (compute == COMPUTE_ALL_FRAMES) { Label nextBasicBlock = new Label(); nextBasicBlock.frame = new Frame(nextBasicBlock); nextBasicBlock.resolve(code.data, code.length); lastBasicBlock.nextBasicBlock = nextBasicBlock; lastBasicBlock = nextBasicBlock; currentBasicBlock = null; } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) { currentBasicBlock.outputStackMax = (short) maxRelativeStackSize; currentBasicBlock = null; } } \nResponse:", "ground_truth": "Ends the current basic block. This method must be used in the case where the current basic\nblock does not have any successor.\n\n<p>WARNING: this method must be called after the currently visited instruction has been put in\n{@link #code} (if frames are computed, this method inserts a new Label to start a new basic\nblock after the current instruction).", "predict": " Ends the current basic block, without setting a successor. The current basic block must have no successor. Typically used in conjunction with label.resolve().\n"}
{"ID": 1505, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void collectAttributePrototypes(final Attribute.Set attributePrototypes) { attributePrototypes.addAttributes(firstAttribute); attributePrototypes.addAttributes(firstCodeAttribute); } \nResponse:", "ground_truth": "Collects the attributes of this method into the given set of attribute prototypes.\n\n@param attributePrototypes a set of attribute prototypes.", "predict": " Collect the prototypes of the attributes referenced by the attributes of this method. Also collects the prototypes of the attributes themselves. @param attributePrototypes the prototypes of the attributes collected so far.\n*/"}
{"ID": 1506, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void injectContext(final Object targetObject) { final Class targetType = targetObject.getClass(); final ScopeData scopeData = scopeDataInspector.inspectClassScopesWithCache(targetType); final Targets targets = new Targets(targetObject, scopeData); // inject no context scopeResolver.forEachScope(madvocScope -> madvocScope.inject(targets)); // inject special case scopeResolver.forScope(ParamsScope.class, scope -> scope.inject(targets)); // inject servlet context final ServletContext servletContext = madvocController.getApplicationContext(); if (servletContext != null) { scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); } } \nResponse:", "ground_truth": "Inject context into target.", "predict": " Inject MadvocContext scope. Usually you don't need to call this method directly. Instead you can use MadvocScope.injectMadvocContext(madvocScope, madvocController); MadvocScope.injectServletContext(madvocScope, madvocController); MadvocScope.injectMadvocConfig(madvocScope, madvocController); MadvocScope.injectMadvocController(madvocScope, madvocController); MadvocScope.injectMadvocMadsonic(madvocScope, madsonicMadsonicMadvocMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadsonicMadson"}
{"ID": 1507, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void registerPseudoClass(final Class<? extends PseudoClass> pseudoClassType) { PseudoClass pseudoClass; try { pseudoClass = ClassUtil.newInstance(pseudoClassType); } catch (Exception ex) { throw new CSSellyException(ex); } PSEUDO_CLASS_MAP.put(pseudoClass.getPseudoClassName(), pseudoClass); } \nResponse:", "ground_truth": "Registers pseudo class.", "predict": " Register a PseudoClass implementation. PseudoClasses are used to represent pseudo elements in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo elements in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo elements in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling. PseudoClasses are also used to represent pseudo classes in styling."}
{"ID": 1508, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static PseudoClass lookupPseudoClass(final String pseudoClassName) { PseudoClass pseudoClass = PSEUDO_CLASS_MAP.get(pseudoClassName); if (pseudoClass == null) { throw new CSSellyException(\"Unsupported pseudo class: \" + pseudoClassName); } return pseudoClass; } \nResponse:", "ground_truth": "Lookups pseudo class for given pseudo class name.", "predict": " Lookup pseudo class by name. @param pseudoClassName Pseudo class name. @return Pseudo class.\n*/"}
{"ID": 1509, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void invoke(final ActionRequest actionRequest) { if (executorService == null) { throw new MadvocException(\"No action is marked as async!\"); } final HttpServletRequest servletRequest = actionRequest.getHttpServletRequest(); log.debug(() -> \"Async call to: \" + actionRequest); final AsyncContext asyncContext = servletRequest.startAsync(); executorService.submit(() -> { try { actionRequest.invoke(); } catch (Exception ex) { log.error(\"Invoking async action path failed: \" , ExceptionUtil.unwrapThrowable(ex)); } finally { asyncContext.complete(); } }); } \nResponse:", "ground_truth": "Invokes an action asynchronously by submitting it to the thread pool.", "predict": " Invoke action async. @param actionRequest The action request."}
{"ID": 1510, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String[] getAllBeanPropertyNames(final Class type, final boolean declared) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); ArrayList<String> names = new ArrayList<>(propertyDescriptors.length); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { MethodDescriptor getter = propertyDescriptor.getReadMethodDescriptor(); if (getter != null) { if (getter.matchDeclared(declared)) { names.add(propertyDescriptor.getName()); } } else if (includeFields) { FieldDescriptor field = propertyDescriptor.getFieldDescriptor(); if (field != null) { if (field.matchDeclared(declared)) { names.add(field.getName()); } } } } return names.toArray(new String[0]); } \nResponse:", "ground_truth": "Returns all bean property names.", "predict": " Introspector caches BeanInfo classes so we must be careful not to return a stale BeanInfo.\nTherefore we return a defensive copy of the array.\n*/"}
{"ID": 1511, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit() { String[] properties = resolveProperties(source, declared); for (String name : properties) { if (name == null) { continue; } if (!rules.match(name, blacklist)) { continue; } Object value; String propertyName = name; if (isSourceMap) { propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET; } if (declared) { value = BeanUtil.declared.getProperty(source, propertyName); } else { value = BeanUtil.pojo.getProperty(source, propertyName); } if (value == null && ignoreNullValues) { continue; } if (value instanceof String && StringUtil.isEmpty((String) value)) { continue; } visitProperty(name, value); } } \nResponse:", "ground_truth": "Starts visiting properties.", "predict": " Visit all properties in the bean.\n"}
{"ID": 1512, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final String propertyName, final String rule, final boolean include) { return propertyName.equals(rule); } \nResponse:", "ground_truth": "Compares property name to the rules.", "predict": " Accepts the given property name and rule. Always returns false.\n@param propertyName the property name to check.\n@param rule the rule to check.\n@param include whether to accept or reject the rule.\n@return always false.\n*/"}
{"ID": 1513, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MethodInjectionPoint[] resolve(final Class type) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<MethodInjectionPoint> list = new ArrayList<>(); MethodDescriptor[] allMethods = cd.getAllMethodDescriptors(); for (MethodDescriptor methodDescriptor : allMethods) { Method method = methodDescriptor.getMethod(); if (ClassUtil.isBeanPropertySetter(method)) { // ignore setters continue; } if (method.getParameterTypes().length == 0) { // ignore methods with no argument continue; } BeanReferences[] references = referencesResolver.readAllReferencesFromAnnotation(method); if (references != null) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint(method, references); list.add(methodInjectionPoint); } } final MethodInjectionPoint[] methodInjectionPoints; if (list.isEmpty()) { methodInjectionPoints = MethodInjectionPoint.EMPTY; } else { methodInjectionPoints = list.toArray(new MethodInjectionPoint[0]); } return methodInjectionPoints; } \nResponse:", "ground_truth": "Resolve method injection points in given class.", "predict": " Resolves all injection points for the given type. @param type The type to resolve injection points for. @return The resolved injection points. Shall not be <code>null</code>. Shall not be empty. Shall contain at least one element. Shall not be an empty array. Shall not be an array containing only empty elements. Shall not be an array containing only one element. Shall not be an array containing mixed elements. Shall not be an array containing mixed types. Shall not be an array containing mixed modes. Shall not be an array containing mixed qualifiers. Shall not be an array containing mixed priorities. Shall not be an array containing mixed injection points. Shall not be an array containing mixed priorities. Shall not be an array containing mixed modes. Shall not be an array containing mixed qualifiers. Shall not be an array containing mixed targets. Shall not be an array containing mixed qualifiers. Shall not be an array containing mixed targets. Shall not be an array containing mixed qualifiers. Shall not be an array containing mixed targets. Shall not be an array containing mixed qualifiers. Shall not be"}
{"ID": 1514, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void readFilterConfigParameters(final FilterConfig filterConfig, final Object target, final String... parameters) { for (String parameter : parameters) { String value = filterConfig.getInitParameter(parameter); if (value != null) { BeanUtil.declared.setProperty(target, parameter, value); } } } \nResponse:", "ground_truth": "Reads filter config parameters and set into destination target.", "predict": " Reads the filter configuration parameters and sets them on the target object. @param filterConfig The filter configuration. @param target The target object. @param parameters The parameters to read."}
{"ID": 1515, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void sendBundleFile(final HttpServletResponse resp, final File bundleFile) throws IOException { OutputStream out = resp.getOutputStream(); FileInputStream fileInputStream = new FileInputStream(bundleFile); try { StreamUtil.copy(fileInputStream, out); } finally { StreamUtil.close(fileInputStream); } } \nResponse:", "ground_truth": "Outputs bundle file to the response.", "predict": " Send the bundle file to the client. @param resp The servlet response. @param bundleFile The bundle file. @throws IOException Failed to send the bundle file.\n*/"}
{"ID": 1516, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public File lookupBundleFile(String bundleId) { if ((mirrors != null) && (!mirrors.isEmpty())) { String realBundleId = mirrors.remove(bundleId); if (realBundleId != null) { bundleId = realBundleId; } } return createBundleFile(bundleId); } \nResponse:", "ground_truth": "Lookups for bundle file.", "predict": " Looks up the bundle file for the given bundle ID. The bundle ID may be a symbolic name, in which case it is looked up in the bundles table. If the bundle ID is not symbolic, it is looked up in the bundlesMirror table. If the bundle ID is not found in either table, null is returned. @param bundleId The bundle ID to look up. @return The bundle file for the bundle ID, or null if the bundle ID is not found.\n**/"}
{"ID": 1517, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public File lookupGzipBundleFile(final File file) throws IOException { String path = file.getPath() + ZipUtil.GZIP_EXT; File gzipFile = new File(path); if (!gzipFile.exists()) { if (log.isDebugEnabled()) { log.debug(\"gzip bundle to \" + path); } ZipUtil.gzip(file); } return gzipFile; } \nResponse:", "ground_truth": "Locates gzipped version of bundle file. If gzip file\ndoes not exist, it will be created.", "predict": " Lookup the gzip bundle file. @param file bundle file @return gzip bundle file\n* @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1518, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized String registerBundle(final String contextPath, final String actionPath, final String tempBundleId, final String bundleContentType, final List<String> sources) { if (tempBundleId == null || sources.isEmpty()) { if (strategy == Strategy.ACTION_MANAGED) { // page does not include any resource source file actionBundles.put(actionPath, StringPool.EMPTY); } return null; } // create unique digest from the collected sources String[] sourcesArray = sources.toArray(new String[0]); for (int i = 0, sourcesArrayLength = sourcesArray.length; i < sourcesArrayLength; i++) { sourcesArray[i] = sourcesArray[i].trim().toLowerCase(); } if (sortResources) { Arrays.sort(sourcesArray); } StringBand sb = new StringBand(sourcesArray.length); for (String src : sourcesArray) { sb.append(src); } String sourcesString = sb.toString(); String bundleId = createDigest(sourcesString); bundleId += '.' + bundleContentType; // bundle appears for the first time, create the bundle if (strategy == Strategy.ACTION_MANAGED) { actionBundles.put(actionPath, bundleId); mirrors.put(tempBundleId, bundleId); } try { createBundle(contextPath, actionPath, bundleId, sources); } catch (IOException ioex) { throw new HtmlStaplerException(\"Can't create bundle\", ioex); } return bundleId; } \nResponse:", "ground_truth": "Registers new bundle that consist of provided list of source paths.\nReturns the real bundle id, as provided one is just a temporary bundle id.", "predict": " Register a bundle. @param contextPath the context path of the bundle @param actionPath the action path of the bundle @param tempBundleId the temporary bundle id (for comparison) @param bundleContentType the bundle content type (for comparison) @param sources the bundle sources\n@return the bundle id\n*/"}
{"ID": 1519, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String createDigest(final String source) { final DigestEngine digestEngine = DigestEngine.sha256(); final byte[] bytes = digestEngine.digest(CharUtil.toSimpleByteArray(source)); String digest = Base32.encode(bytes); if (uniqueDigestKey != null) { digest += uniqueDigestKey; } return digest; } \nResponse:", "ground_truth": "Creates digest i.e. bundle id from given string.\nReturned digest must be filename safe, for all platforms.", "predict": " Creates a SHA256 digest of the given source. The digest is encoded in Base32. The digest is prefixed with the uniqueDigestKey if it is not null. The digest is also suffixed with the source. @param source The source to digest. @return The digest."}
{"ID": 1520, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void createBundle(final String contextPath, final String actionPath, final String bundleId, final List<String>sources) throws IOException { final File bundleFile = createBundleFile(bundleId); if (bundleFile.exists()) { return; } StringBand sb = new StringBand(sources.size() * 2); for (String src : sources) { if (sb.length() != 0) { sb.append(StringPool.NEWLINE); } String content; if (isExternalResource(src)) { content = downloadString(src); } else { if (!downloadLocal) { // load local resource from file system String localFile = webRoot; if (src.startsWith(contextPath + '/')) { src = src.substring(contextPath.length()); } if (src.startsWith(StringPool.SLASH)) { // absolute path localFile += src; } else { // relative path localFile += '/' + FileNameUtil.getPathNoEndSeparator(actionPath) + '/' + src; } // trim link parameters, if any int qmndx = localFile.indexOf('?'); if (qmndx != -1) { localFile = localFile.substring(0, qmndx); } try { content = FileUtil.readString(localFile); } catch (IOException ioex) { if (notFoundExceptionEnabled) { throw ioex; } if (log.isWarnEnabled()) { log.warn(ioex.getMessage()); } content = null; } } else { // download local resource String localUrl = localAddressAndPort; if (src.startsWith(StringPool.SLASH)) { localUrl += contextPath + src; } else { localUrl += contextPath + FileNameUtil.getPath(actionPath) + '/' + src; } content = downloadString(localUrl); } if (content != null) { if (isCssResource(src)) { content = fixCssRelativeUrls(content, src); } } } if (content != null) { content = onResourceContent(content); sb.append(content); } } FileUtil.writeString(bundleFile, sb.toString()); if (log.isInfoEnabled()) { log.info(\"Bundle created: \" + bundleId); } } \nResponse:", "ground_truth": "Creates bundle file by loading resource files content. If bundle file already\nexist it will not be recreated!", "predict": " Creates a bundle file. @param contextPath the context path @param actionPath the action path @param bundleId the bundle id @param sources the sources\n * @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1521, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized void reset() { if (strategy == Strategy.ACTION_MANAGED) { actionBundles.clear(); mirrors.clear(); } final FindFile ff = new FindFile(); ff.includeDirs(false); ff.searchPath(new File(bundleFolder, staplerPath)); File f; int count = 0; while ((f = ff.nextFile()) != null) { f.delete(); count++; } if (log.isInfoEnabled()) { log.info(\"reset: \" + count + \" bundle files deleted.\"); } } \nResponse:", "ground_truth": "Clears all settings and removes all created bundle files from file system.", "predict": " Clears all the bundles. Useful during development.\n*/"}
{"ID": 1522, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String fixCssRelativeUrls(final String content, final String src) { final String path = FileNameUtil.getPath(src); final Matcher matcher = CSS_URL_PATTERN.matcher(content); final StringBuilder sb = new StringBuilder(content.length()); int start = 0; while (matcher.find()) { sb.append(content, start, matcher.start()); final String matchedUrl = StringUtil.removeChars(matcher.group(1), \"'\\\"\"); final String url; if (matchedUrl.startsWith(\"https://\") || matchedUrl.startsWith(\"http://\") || matchedUrl.startsWith(\"data:\")) { url = \"url('\" + matchedUrl + \"')\"; } else { url = fixRelativeUrl(matchedUrl, path); } sb.append(url); start = matcher.end(); } sb.append(content.substring(start)); return sb.toString(); } \nResponse:", "ground_truth": "Returns the content with all relative URLs fixed.", "predict": " Fixes relative urls in CSS content. @param content CSS content. @param src CSS source file. @return Fixes relative urls in CSS content.\n"}
{"ID": 1523, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbSqlBuilder updateColumn(final Object entity, final String columnRef) { final Object value = BeanUtil.pojo.getProperty(entity, columnRef); return updateColumn(entity, columnRef, value); } \nResponse:", "ground_truth": "Reads property value and updates the DB.", "predict": " Update column. @param entity the entity @param columnRef the column ref @return the dbsql builder\n*/"}
{"ID": 1524, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static String createTableRefName(final Object entity) { Class type = entity.getClass(); type = (type == Class.class ? (Class) entity : type); return (type.getSimpleName() + '_'); } \nResponse:", "ground_truth": "Creates table reference name from entity type.\nAlways appends an underscore to reference name in order\nto circumvent SQL compatibility issues when entity class name\nequals to a reserved word.", "predict": " Generate the table ref name for the given entity. @param entity The entity. @return The table ref name."}
{"ID": 1525, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public DbSession getDbSession() { log.debug(\"Requesting db TX manager session\"); final DbJtxTransaction jtx = (DbJtxTransaction) jtxTxManager.getTransaction(); if (jtx == null) { throw new DbSqlException( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\"); } return jtx.requestResource(); } \nResponse:", "ground_truth": "Returns session from JTX transaction manager and started transaction.", "predict": " Get DbSession from TX Manager. @return DbSession\n*/"}
{"ID": 1526, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected T[] convertToSingleElementArray(final Object value) { T[] singleElementArray = createArray(1); singleElementArray[0] = convertType(value); return singleElementArray; } \nResponse:", "ground_truth": "Creates an array with single element.", "predict": " Convert the given value to a singleton array. @param value The value to convert. @return The converted value. Never null. May be empty."}
{"ID": 1527, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<String, String> parseSignatureForGenerics(final String signature, final boolean isInterface) { if (signature == null) { return Collections.emptyMap(); } final Map<String, String> genericsMap = new HashMap<>(); SignatureReader sr = new SignatureReader(signature); StringBuilder sb = new StringBuilder(); TraceSignatureVisitor v = new TraceSignatureVisitor(sb, isInterface) { String genericName; @Override public void visitFormalTypeParameter(final String name) { genericName = name; super.visitFormalTypeParameter(name); } @Override public void visitClassType(final String name) { if (genericName != null) { genericsMap.put(genericName, 'L' + name + ';'); genericName = null; } super.visitClassType(name); } }; sr.accept(v); return genericsMap; } \nResponse:", "ground_truth": "Parses signature for generic information and returns a map where key is generic name\nand value is raw type. Returns an empty map if signature does not define any generics.", "predict": " Extract generic types from a signature. @param signature Signature to parse. @param isInterface Whether the signature belongs to an interface or not. @return Generic types."}
{"ID": 1528, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public SetInjectionPoint[] resolve(final Class type, final boolean autowire) { ClassDescriptor cd = ClassIntrospector.get().lookup(type); List<SetInjectionPoint> list = new ArrayList<>(); PropertyDescriptor[] allProperties = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allProperties) { if (propertyDescriptor.isGetterOnly()) { continue; } Class propertyType = propertyDescriptor.getType(); if (!ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } MethodDescriptor writeMethodDescriptor = propertyDescriptor.getWriteMethodDescriptor(); FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); PetiteInject ref = null; if (writeMethodDescriptor != null) { ref = writeMethodDescriptor.getMethod().getAnnotation(PetiteInject.class); } if (ref == null && fieldDescriptor != null) { ref = fieldDescriptor.getField().getAnnotation(PetiteInject.class); } if ((!autowire) && (ref == null)) { continue; } list.add(new SetInjectionPoint(propertyDescriptor)); } SetInjectionPoint[] fields; if (list.isEmpty()) { fields = SetInjectionPoint.EMPTY; } else { fields = list.toArray(new SetInjectionPoint[0]); } return fields; } \nResponse:", "ground_truth": "Resolves all collections for given type.", "predict": " Resolves Petite dependencies for given type. @param type Petite injection target type. @param autowire If autowire is enabled. @return Petite injection points. Empty array if none found."}
{"ID": 1529, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matchIgnoredPropertyTypes(final Class propertyType, final boolean excludeMaps, final boolean include) { if (!include) { return false; } if (propertyType != null) { if (!jsonSerializer.deep) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector.get().lookup(propertyType); if (propertyTypeClassDescriptor.isArray()) { return false; } if (propertyTypeClassDescriptor.isCollection()) { return false; } if (excludeMaps) { if (propertyTypeClassDescriptor.isMap()) { return false; } } } // still not excluded, continue with excluded types and type names // + excluded types if (jsonSerializer.excludedTypes != null) { for (Class excludedType : jsonSerializer.excludedTypes) { if (ClassUtil.isTypeOf(propertyType, excludedType)) { return false; } } } // + exclude type names final String propertyTypeName = propertyType.getName(); if (jsonSerializer.excludedTypeNames != null) { for (String excludedTypeName : jsonSerializer.excludedTypeNames) { if (Wildcard.match(propertyTypeName, excludedTypeName)) { return false; } } } } return true; } \nResponse:", "ground_truth": "Matches property types that are ignored by default.", "predict": " Match ignored property types. @param propertyType the property type @param excludeMaps the exclude maps @param include the include @return true, if successful\n*/"}
{"ID": 1530, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void openConnectionForQuery() { if (connection == null) { connection = connectionProvider.getConnection(); txActive = false; // txAction should already be false try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Failed to open non-TX connection\", sex); } } } \nResponse:", "ground_truth": "Opens connection in auto-commit mode, if already not opened.", "predict": " Open connection for query. Automatically commits previous TX transaction."}
{"ID": 1531, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void openTx() { if (connection == null) { connection = connectionProvider.getConnection(); } txActive = true; try { connection.setAutoCommit(false); if (txMode.getIsolation() != DbTransactionMode.ISOLATION_DEFAULT) { connection.setTransactionIsolation(txMode.getIsolation()); } connection.setReadOnly(txMode.isReadOnly()); } catch (SQLException sex) { throw new DbSqlException(\"Open TX failed\", sex); } } \nResponse:", "ground_truth": "Opens a transaction.", "predict": " Open a transaction. This method is called by the framework to open a transaction. Subclasses may override this method to customize the opening of the transaction.\n */"}
{"ID": 1532, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void closeTx() { txActive = false; try { connection.setAutoCommit(true); } catch (SQLException sex) { throw new DbSqlException(\"Close TX failed\", sex); } } \nResponse:", "ground_truth": "Closes current transaction.", "predict": " Close transaction."}
{"ID": 1533, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commitTransaction() { log.debug(\"Committing transaction\"); assertTxIsActive(); try { connection.commit(); } catch (SQLException sex) { throw new DbSqlException(\"Commit TX failed\", sex); } finally { closeTx(); } } \nResponse:", "ground_truth": "Commit the current transaction, writing any unflushed changes to the database.\nTransaction mode is closed.", "predict": " Commit the current transaction. Rolls back if the connection rolls back. Automatically closes the connection. @since 1.3.2"}
{"ID": 1534, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void rollbackTransaction() { log.debug(\"Rolling-back transaction\"); assertTxIsActive(); try { connection.rollback(); } catch (SQLException sex) { throw new DbSqlException(\"Rollback TX failed\", sex); } finally { closeTx(); } } \nResponse:", "ground_truth": "Roll back the current transaction. Transaction mode is closed.", "predict": " Rolls back the current transaction. This method is automatically called by the framework when a request fails. However, you can call it explicitly to rollback an erroneous transaction.\n"}
{"ID": 1535, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromFile(final File file) throws IOException { Properties prop = new Properties(); loadFromFile(prop, file); return prop; } \nResponse:", "ground_truth": "Create properties from the file.\n\n@param file properties file to load", "predict": " Load properties from a file. @param file the file to load from @return the loaded properties\n * @throws IOException if an error occurs\n */"}
{"ID": 1536, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromString(final String data) throws IOException { Properties p = new Properties(); loadFromString(p, data); return p; } \nResponse:", "ground_truth": "Creates properties from string.", "predict": " Creates a Properties object from a String. The String may be a Properties file, but may also be a traditional comment delimited properties file. @param data the data to be parsed @return the Properties object @throws IOException if there is a problem reading the data\n*/"}
{"ID": 1537, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void loadFromString(final Properties p, final String data) throws IOException { try (ByteArrayInputStream is = new ByteArrayInputStream(data.getBytes(StringPool.ISO_8859_1))) { p.load(is); } } \nResponse:", "ground_truth": "Loads properties from string.", "predict": " Loads properties from a string. @param p Properties to load. @param data String to load. @throws IOException Loading failed."}
{"ID": 1538, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties subset(final Properties p, String prefix, final boolean stripPrefix) { if (StringUtil.isBlank(prefix)) { return p; } if (!prefix.endsWith(StringPool.DOT)) { prefix += '.'; } Properties result = new Properties(); int baseLen = prefix.length(); for (Object o : p.keySet()) { String key = (String) o; if (key.startsWith(prefix)) { result.setProperty(stripPrefix ? key.substring(baseLen) : key, p.getProperty(key)); } } return result; } \nResponse:", "ground_truth": "Creates new Properties object from the original one, by copying\nthose properties that have specified first part of the key name.\nPrefix may be optionally stripped during this process.\n\n@param p         source properties, from which new object will be created\n@param prefix    key names prefix\n\n@return subset properties", "predict": " Strips prefix from keys in Properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful for stripping unwanted prefixes from properties. Useful"}
{"ID": 1539, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Properties createFromClasspath(final String... rootTemplate) { Properties p = new Properties(); return loadFromClasspath(p, rootTemplate); } \nResponse:", "ground_truth": "Creates properties from classpath.", "predict": " Loads properties from the classpath. Useful for bootstrapping. @param rootTemplate The root template to prepend to each relative path encountered in the properties file. @return The loaded properties.\n*/"}
{"ID": 1540, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getProperty(final Map map, final String key, final String defaultValue) { Object val = map.get(key); return (val instanceof String) ? (String) val : defaultValue; } \nResponse:", "ground_truth": "Returns String property from a map.\n@see #getProperty(java.util.Map, String)", "predict": " Get a property from a map. If the property doesn't exist, the default value is returned. @param map The map to get the property from. @param key The key of the property to get. @param defaultValue The default value to return if the property doesn't exist. @return The value of the property."}
{"ID": 1541, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void resolveAllVariables(final Properties prop) { for (Object o : prop.keySet()) { String key = (String) o; String value = resolveProperty(prop, key); prop.setProperty(key, value); } } \nResponse:", "ground_truth": "Resolves all variables.", "predict": " Resolve all variables in the given properties. @param prop The properties to resolve.\n*/"}
{"ID": 1542, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveProperty(final Map map, final String key) { String value = getProperty(map, key); if (value == null) { return null; } value = stp.parse(value, macroName -> getProperty(map, macroName)); return value; } \nResponse:", "ground_truth": "Returns property with resolved variables.", "predict": " Resolve a property from a map. @param map The map to resolve from. @param key The key to resolve. @return The resolved property. Returns null if the property was not found."}
{"ID": 1543, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String resolveScope(final Class type, final String methodName) { if (scopePattern == null) { return null; } String ctx = scopePattern; ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_CLASS, type.getName()); ctx = StringUtil.replace(ctx, JTXCTX_PATTERN_METHOD, methodName); return ctx; } \nResponse:", "ground_truth": "Resolves tx scope from scope pattern.", "predict": " Resolve the scope pattern. @param type the type @param methodName the method name @return the scope"}
{"ID": 1544, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public synchronized JtxTransactionMode getTxMode(final Class type, final String methodName, final Class[] methodArgTypes, final String unique) { String signature = type.getName() + '#' + methodName + '%' + unique; JtxTransactionMode txMode = txmap.get(signature); if (txMode == null) { if (!txmap.containsKey(signature)) { final Method m; try { m = type.getMethod(methodName, methodArgTypes); } catch (NoSuchMethodException nsmex) { throw new ProxettaException(nsmex); } final TransactionAnnotationValues txAnn = readTransactionAnnotation(m); if (txAnn != null) { txMode = new JtxTransactionMode( txAnn.propagation(), txAnn.isolation(), txAnn.readOnly(), txAnn.timeout() ); } else { txMode = defaultTransactionMode; } txmap.put(signature, txMode); } } return txMode; } \nResponse:", "ground_truth": "Reads transaction mode from method annotation. Annotations are cached for better performances.\n@param type target class\n@param methodName target method name over which the transaction should be wrapped\n@param methodArgTypes types of arguments, used to find the method\n@param unique unique method fingerprint that contains return and arguments type information", "predict": " Obtain the transaction mode for the given method. The unique identifier is used to distinguish between different transactional hints. @param type the proxetta class @param methodName the method name @param methodArgTypes the method argument types @param unique the unique identifier @return the transaction mode\n*/"}
{"ID": 1545, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings( {\"unchecked\"}) public void registerAnnotations(final Class<? extends Annotation>[] annotations) { this.annotations = annotations; this.annotationParsers = new AnnotationParser[annotations.length]; for (int i = 0; i < annotations.length; i++) { annotationParsers[i] = TransactionAnnotationValues.parserFor(annotations[i]); } } \nResponse:", "ground_truth": "Registers new TX annotations.", "predict": " Register the annotations that will be scanned for metadata. @param annotations Annotations to register. Typically, implementations will register annotations that are commonly used in Spring Boot applications. However, any annotations can be registered here. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register their own annotations to enrich the information Spring Boot gathers. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register their own annotations to enrich the information Spring Boot gathers. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register their own annotations to enrich the information Spring Boot gathers. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register their own annotations to enrich the information Spring Boot gathers. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register their own annotations to enrich the information Spring Boot gathers. Typically, applications will register annotations that are commonly used in Spring Boot applications, but may want to register"}
{"ID": 1546, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected TransactionAnnotationValues readTransactionAnnotation(final Method method) { for (AnnotationParser annotationParser : annotationParsers) { TransactionAnnotationValues tad = TransactionAnnotationValues.of(annotationParser, method); if (tad != null) { return tad; } } return null; } \nResponse:", "ground_truth": "Finds TX annotation.", "predict": " Read TransactionAnnotationValues from TransactionAnnotationParser. Fallback to other parsers if necessary. @param method The intercepted method. @return TransactionAnnotationValues or null if none found."}
{"ID": 1547, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public boolean accept(final Node node) { // match element name with node name if (!matchElement(node)) { return false; } // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case ATTRIBUTE: if (!((AttributeSelector) selector).accept(node)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(node)) { return false; } break; case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(node)) { return false; } break; } } return true; } \nResponse:", "ground_truth": "Accepts single node.", "predict": " Check if node matches selector. @param node Node to check. @return True if node matches selector. False otherwise."}
{"ID": 1548, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean matchElement(final Node node) { if (node.getNodeType() != Node.NodeType.ELEMENT) { return false; } String element = getElement(); String nodeName = node.getNodeName(); return element.equals(StringPool.STAR) || element.equals(nodeName); } \nResponse:", "ground_truth": "Matches element to css selector. All non-element types are ignored.", "predict": " Match element. @param node Node to match. @return Matching result."}
{"ID": 1549, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean accept(final List<Node> currentResults, final Node node, final int index) { // match attributes int totalSelectors = selectorsCount(); for (int i = 0; i < totalSelectors; i++) { Selector selector = getSelector(i); // just attr name existence switch (selector.getType()) { case PSEUDO_FUNCTION: if (!((PseudoFunctionSelector) selector).accept(currentResults, node, index)) { return false; } break; case PSEUDO_CLASS: if (!((PseudoClassSelector) selector).accept(currentResults, node, index)) { return false; } break; default: } } return true; } \nResponse:", "ground_truth": "Accepts node within current results.", "predict": " Check if selector match current node. @param currentResults current results. @param node current node. @param index current index. @return true if selector match current node."}
{"ID": 1550, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String unescape(final String value) { if (value.indexOf('\\\\') == -1) { return value; } return StringUtil.remove(value, '\\\\'); } \nResponse:", "ground_truth": "Unescapes CSS string by removing all backslash characters from it.", "predict": " Unescape any escapes within the given string. @param value The string to unescape. @return The unescaped string.\n*/"}
{"ID": 1551, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private String[] buildJrePackages(final int javaVersionNumber) { final ArrayList<String> packages = new ArrayList<>(); switch (javaVersionNumber) { case 9: case 8: case 7: case 6: case 5: // in Java1.5, the apache stuff moved packages.add(\"com.sun.org.apache\"); // fall through... case 4: if (javaVersionNumber == 4) { packages.add(\"org.apache.crimson\"); packages.add(\"org.apache.xalan\"); packages.add(\"org.apache.xml\"); packages.add(\"org.apache.xpath\"); } packages.add(\"org.ietf.jgss\"); packages.add(\"org.w3c.dom\"); packages.add(\"org.xml.sax\"); // fall through... case 3: packages.add(\"org.omg\"); packages.add(\"com.sun.corba\"); packages.add(\"com.sun.jndi\"); packages.add(\"com.sun.media\"); packages.add(\"com.sun.naming\"); packages.add(\"com.sun.org.omg\"); packages.add(\"com.sun.rmi\"); packages.add(\"sunw.io\"); packages.add(\"sunw.util\"); // fall through... case 2: packages.add(\"com.sun.java\"); packages.add(\"com.sun.image\"); // fall through... case 1: default: // core stuff packages.add(\"sun\"); packages.add(\"java\"); packages.add(\"javax\"); break; } return packages.toArray(new String[0]); } \nResponse:", "ground_truth": "Builds a set of java core packages.", "predict": " Builds the complete set of packages that comprise the Java installation. @param javaVersionNumber the version of Java to analyze (currently hardwired to 9) @return the complete set of packages comprising the Java installation\n*/"}
{"ID": 1552, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected <T extends Node> T cloneTo(final T dest) { // dest.nodeValue = nodeValue; // already in clone implementations! dest.parentNode = parentNode; if (attributes != null) { dest.attributes = new ArrayList<>(attributes.size()); for (int i = 0, attributesSize = attributes.size(); i < attributesSize; i++) { Attribute attr = attributes.get(i); dest.attributes.add(attr.clone()); } } if (childNodes != null) { dest.childNodes = new ArrayList<>(childNodes.size()); for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node child = childNodes.get(i); Node childClone = child.clone(); childClone.parentNode = dest; // fix parent! dest.childNodes.add(childClone); } } return dest; } \nResponse:", "ground_truth": "Copies all non-final values to the empty cloned object.\nCache-related values are not copied.", "predict": " Clone the node to another node. This method is called by the clone() method of the superclass. The clone() method is overridden to prevent endless loops. @param dest The destination of the clone operation. @return The cloned node.\n"}
{"ID": 1553, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void detachFromParent() { if (parentNode == null) { return; } if (parentNode.childNodes != null) { parentNode.childNodes.remove(siblingIndex); parentNode.reindexChildren(); } parentNode = null; } \nResponse:", "ground_truth": "Removes this node from DOM tree.", "predict": " Detaches this sibling from its parent. This sibling becomes orphaned.\n"}
{"ID": 1554, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addChild(final Node... nodes) { if (nodes.length == 0) { return; // nothing to add } for (Node node : nodes) { node.detachFromParent(); node.parentNode = this; initChildNodes(node); childNodes.add(node); } reindexChildrenOnAdd(nodes.length); } \nResponse:", "ground_truth": "Appends several child nodes at once.\nReindex is done only once, after all children are added.", "predict": " Adds the specified nodes as children of this node. @param nodes The nodes to add as children of this node. May be empty. May contain nodes that are already children of this node. May contain nodes that are siblings of other nodes. May contain nodes that are already siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of other nodes. May contain nodes that are siblings of"}
{"ID": 1555, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertChild(final Node node, final int index) { node.detachFromParent(); node.parentNode = this; try { initChildNodes(node); childNodes.add(index, node); } catch (IndexOutOfBoundsException ignore) { throw new LagartoDOMException(\"Invalid node index: \" + index); } reindexChildren(); } \nResponse:", "ground_truth": "Inserts node at given index.", "predict": " Inserts a child node at the specified index. @param node the child node to insert. @param index the index at which the child node will be inserted."}
{"ID": 1556, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertBefore(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChild, siblingIndex); } \nResponse:", "ground_truth": "Inserts node before provided node.", "predict": " Inserts the specified node before the reference node. @param newChild the node to insert @param refChild the reference node */\npublic final native void insertBefore(Node newChild, Node refChild) /*-{\n\trefChild.parentNode.insertBefore(newChild, refChild);\n}-*/;\n\n/** Inserts the specified node before the reference node. @param newChild the node to insert @param refChild the reference node */"}
{"ID": 1557, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertBefore(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex(); refChild.parentNode.insertChild(newChilds, siblingIndex); } \nResponse:", "ground_truth": "Inserts several child nodes before provided node.", "predict": " Inserts the specified nodes before the specified reference node. @param newChilds the nodes to insert @param refChild the reference node\n*/"}
{"ID": 1558, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertAfter(final Node newChild, final Node refChild) { int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChild); } else { refChild.parentNode.insertChild(newChild, siblingIndex); } } \nResponse:", "ground_truth": "Inserts node after provided node.", "predict": " Inserts a new child after refChild. Equivalent to inserting a new child before refChild and then removing it afterwards. @param newChild the new child @param refChild the reference child"}
{"ID": 1559, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertAfter(final Node[] newChilds, final Node refChild) { if (newChilds.length == 0) { return; } int siblingIndex = refChild.getSiblingIndex() + 1; if (siblingIndex == refChild.parentNode.getChildNodesCount()) { refChild.parentNode.addChild(newChilds); } else { refChild.parentNode.insertChild(newChilds, siblingIndex); } } \nResponse:", "ground_truth": "Inserts several child nodes after referent node.", "predict": " Inserts a bunch of nodes after refChild. The nodes are cloned so that they are not affected by further mutations in the tree. @param newChilds the nodes to insert @param refChild the reference node\n*/"}
{"ID": 1560, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void removeAllChilds() { List<Node> removedNodes = childNodes; childNodes = null; childElementNodes = null; childElementNodesCount = 0; if (removedNodes != null) { for (int i = 0, removedNodesSize = removedNodes.size(); i < removedNodesSize; i++) { Node removedNode = removedNodes.get(i); removedNode.detachFromParent(); } } } \nResponse:", "ground_truth": "Removes all child nodes. Each child node will be detached from this parent.", "predict": " Remove all childs from this node."}
{"ID": 1561, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node findChildNodeWithName(final String name) { if (childNodes == null) { return null; } for (final Node childNode : childNodes) { if (childNode.getNodeName().equals(name)) { return childNode; } } return null; } \nResponse:", "ground_truth": "Finds the first child node with given node name.", "predict": " Finds a child node with the given name. Returns null if no such child node exists. @param name Name of the child node to find. @return Child node with the given name or null if no such child node exists."}
{"ID": 1562, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node[] filterChildNodes(final Predicate<Node> nodePredicate) { if (childNodes == null) { return new Node[0]; } return childNodes.stream() .filter(nodePredicate) .toArray(Node[]::new); } \nResponse:", "ground_truth": "Filters child nodes.", "predict": " Filters out unwanted child nodes. Useful for cleaning up unwanted markup. @param nodePredicate predicate to filter unwanted nodes out of the children. @return filtered child nodes. Never returns null."}
{"ID": 1563, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean check() { if (childNodes == null) { return true; } // children int siblingElementIndex = 0; for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); if (childNode.siblingIndex != i) { return false; } if (childNode.getNodeType() == NodeType.ELEMENT) { if (childNode.siblingElementIndex != siblingElementIndex) { return false; } siblingElementIndex++; } } if (childElementNodesCount != siblingElementIndex) { return false; } // child element nodes if (childElementNodes != null) { if (childElementNodes.length != childElementNodesCount) { return false; } int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { if (childElementNodes[child.siblingElementIndex] != child) { return false; } } } } // sibling names if (siblingNameIndex != -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { if (sibling.siblingNameIndex != index++) { return false; } } } } // process children for (Node childNode : childNodes) { if (!childNode.check()) { return false; } } return true; } \nResponse:", "ground_truth": "Checks the health of child nodes. Useful during complex tree manipulation,\nto check if everything is OK. Not optimized for speed, should be used just\nfor testing purposes.", "predict": " Check if the node is well formed. @return True if the node is well formed. False otherwise."}
{"ID": 1564, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initChildElementNodes() { if (childElementNodes == null) { childElementNodes = new Element[childElementNodesCount]; int childCount = getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = getChild(i); if (child.siblingElementIndex >= 0) { childElementNodes[child.siblingElementIndex] = (Element) child; } } } } \nResponse:", "ground_truth": "Initializes list of child elements.", "predict": " Initializes child element nodes. Child element nodes are initialized only when they are needed. This improves performances dramatically."}
{"ID": 1565, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initSiblingNames() { if (siblingNameIndex == -1) { List<Node> siblings = parentNode.childNodes; int index = 0; for (int i = 0, siblingsSize = siblings.size(); i < siblingsSize; i++) { Node sibling = siblings.get(i); if (sibling.siblingNameIndex == -1 && nodeType == NodeType.ELEMENT && nodeName.equals(sibling.getNodeName())) { sibling.siblingNameIndex = index++; } } } } \nResponse:", "ground_truth": "Initializes siblings elements of the same name.", "predict": " Init sibling names."}
{"ID": 1566, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void initChildNodes(final Node newNode) { if (childNodes == null) { childNodes = new ArrayList<>(); } if (ownerDocument != null) { if (newNode.ownerDocument != ownerDocument) { changeOwnerDocument(newNode, ownerDocument); } } } \nResponse:", "ground_truth": "Initializes child nodes list when needed.\nAlso fix owner document for new node, if needed.", "predict": " Initializes the child nodes of the given node. This method is called by the parser during initialization. It is meant to be overridden by inheriting classes. The default implementation does nothing. @param newNode the node whose children are going to be initialized.\n**/\nprotected void initChildNodes(final Node newNode) {\n}\n\n/**\n * Initializes the map of attributes. This method is called by the parser during initialization. It is meant to be overridden by inheriting classes. The default implementation does nothing.\n * @param newNode the node whose attributes are going to be initialized.\n */"}
{"ID": 1567, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void changeOwnerDocument(final Node node, final Document ownerDocument) { node.ownerDocument = ownerDocument; int childCount = node.getChildNodesCount(); for (int i = 0; i < childCount; i++) { Node child = node.getChild(i); changeOwnerDocument(child, ownerDocument); } } \nResponse:", "ground_truth": "Changes owner document for given node and all its children.", "predict": " Change owner document for node and his children recursively. @param node Node to operate. @param ownerDocument Owner document to set."}
{"ID": 1568, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Node getPreviousSiblingName() { if (nodeName == null) { return null; } initSiblingNames(); int index = siblingNameIndex -1; for (int i = siblingIndex; i >= 0; i--) { Node sibling = parentNode.childNodes.get(i); if ((index == sibling.siblingNameIndex) && nodeName.equals(sibling.getNodeName())) { return sibling; } } return null; } \nResponse:", "ground_truth": "Returns this node's previous sibling element with the same name.", "predict": " Returns the previous sibling with the same name. Returns null if there is no sibling with the same name. This sibling may be before or after this sibling."}
{"ID": 1569, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getTextContent() { StringBuilder sb = new StringBuilder(getChildNodesCount() + 1); appendTextContent(sb); return sb.toString(); } \nResponse:", "ground_truth": "Returns the text content of this node and its descendants.\n@see #appendTextContent(Appendable)", "predict": " Returns textual content of this element. Whitespaces are ignored. @return textual content of this element\n*/"}
{"ID": 1570, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toHtml(this, new StringBuilder()); } \nResponse:", "ground_truth": "Generates HTML.", "predict": " Generates the HTML representation of the Element. @return HTML representation of the Element."}
{"ID": 1571, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getInnerHtml() { LagartoDomBuilderConfig lagartoDomBuilderConfig; if (ownerDocument == null) { lagartoDomBuilderConfig = ((Document) this).getConfig(); } else { lagartoDomBuilderConfig = ownerDocument.getConfig(); } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig.getLagartoHtmlRenderer(); return lagartoHtmlRenderer.toInnerHtml(this, new StringBuilder()); } \nResponse:", "ground_truth": "Generates inner HTML.", "predict": " Retrieve the inner html of this node. This method is used by LagartoDOMBuilderImpl.getInnerHtml(Node node) to render the HTML of a node. The HTML is rendered recursively. The HTML returned by this method is the one that LagartoDOMBuilderImpl.getInnerHtml(Node node) renders."}
{"ID": 1572, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void visitChildren(final NodeVisitor nodeVisitor) { if (childNodes != null) { for (int i = 0, childNodesSize = childNodes.size(); i < childNodesSize; i++) { Node childNode = childNodes.get(i); childNode.visit(nodeVisitor); } } } \nResponse:", "ground_truth": "Visits children nodes.", "predict": " Visit children nodes. @param nodeVisitor the node visitor\n*/"}
{"ID": 1573, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getCssPath() { StringBuilder path = new StringBuilder(); Node node = this; while (node != null) { String nodeName = node.getNodeName(); if (nodeName != null) { StringBuilder sb = new StringBuilder(); sb.append(' ').append(nodeName); String id = node.getAttribute(\"id\"); if (id != null) { sb.append('#').append(id); } path.insert(0, sb); } node = node.getParentNode(); } if (path.charAt(0) == ' ') { return path.substring(1); } return path.toString(); } \nResponse:", "ground_truth": "Returns CSS path to this node from document root.", "predict": " Returns the CSS path of this element. The path is relative to the document root. @return the CSS path of this element\n*/"}
{"ID": 1574, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onDecoraTag(final Tag tag) { String tagName = tag.getName().toString(); if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName.substring(7); decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); return; } // closed tag type decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); decoraTagDefaultValueEnd = tag.getTagPosition(); defineDecoraTag(); } \nResponse:", "ground_truth": "Handle Decora tags.", "predict": " Called when a Decora tag is encountered. Decora tags are ignored.\n@param tag The Decora tag encountered.\n*/\nprotected void onDecoraTag(Tag tag) { }\n/** Checks if there are any nested Decora tags. If there are, they are ignored. @param tag The Decora tag encountered. */\nprotected void checkNestedDecoraTags(Tag tag) { }\n/** Called when a Decora tag is encountered. Decora tags are ignored. */"}
{"ID": 1575, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void onIdAttrStart(final Tag tag) { String id = tag.getId().toString().substring(7); String tagName; String idName; int dashIndex = id.indexOf('-'); if (dashIndex == -1) { tagName = id; idName = null; } else { tagName = id.substring(0, dashIndex); idName = id.substring(dashIndex + 1); } if (tag.getType() == TagType.SELF_CLOSING) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagEnd = tag.getTagPosition() + tag.getTagLength(); defineDecoraTag(); return; } if (tag.getType() == TagType.START) { checkNestedDecoraTags(); decoraTagName = tagName; decoraIdName = idName; decoraTagStart = tag.getTagPosition(); decoraTagDefaultValueStart = tag.getTagPosition() + tag.getTagLength(); closingTagName = tag.getName().toString(); closingTagDeepLevel = tag.getDeepLevel(); } } \nResponse:", "ground_truth": "Handle open and empty ID attribute tags.", "predict": " Analyze the id attribute of the tag. @param tag the tag to analyze\n*/"}
{"ID": 1576, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void defineDecoraTag() { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag(decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd) : new DecoraTag( decoraTagName, decoraIdName, decoraTagStart, decoraTagEnd, decoraTagDefaultValueStart, decoraTagDefaultValueEnd - decoraTagDefaultValueStart); decoraTags.add(decoraTag); decoraTagName = null; decoraIdName = null; closingTagName = null; decoraTagDefaultValueStart = 0; } \nResponse:", "ground_truth": "Defines Decora tag position inside decorator content.\nResets current Decora tag tracking.", "predict": " Define Decora Tag."}
{"ID": 1577, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public JoyProxetta addProxyAspect(final ProxyAspect proxyAspect) { requireNotStarted(proxetta); this.proxyAspects.add(proxyAspect); return this; } \nResponse:", "ground_truth": "Adds a proxy aspect.", "predict": " Add proxy aspects. @param proxyAspect aspects to add. @return joy proxetta."}
{"ID": 1578, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addRootPackage(final String rootPackage, String mapping) { if (packages == null) { packages = new String[0]; } if (mappings == null) { mappings = new String[0]; } // fix mapping if (mapping.length() > 0) { // mapping must start with the slash if (!mapping.startsWith(StringPool.SLASH)) { mapping = StringPool.SLASH + mapping; } // mapping must NOT end with the slash if (mapping.endsWith(StringPool.SLASH)) { mapping = StringUtil.substring(mapping, 0, -1); } } // detect duplicates for (int i = 0; i < packages.length; i++) { if (packages[i].equals(rootPackage)) { if (mappings[i].equals(mapping)) { // both package and the mappings are the same return; } throw new MadvocException(\"Different mappings for the same root package: \" + rootPackage); } } packages = ArraysUtil.append(packages, rootPackage); mappings = ArraysUtil.append(mappings, mapping); } \nResponse:", "ground_truth": "Adds root package and its path mapping. Duplicate root packages\nare ignored, if mapping path is equals, otherwise exception is thrown.", "predict": " Adds root package and mapping. Usually you don't need to call this method directly. Instead you can use MadvocConfigurator. @param rootPackage Root package name. @param mapping Madvoc mapping. Usually '/' or '/*'."}
{"ID": 1579, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addRootPackageOf(final Class actionClass, final String mapping) { addRootPackage(actionClass.getPackage().getName(), mapping); } \nResponse:", "ground_truth": "Sets root package to package of given class.", "predict": " Adds the root package of the given action class to the mapping. Useful for situations where you want to map the package of an action class to a specific controller mapping. @param actionClass The action class whose package will be mapped. @param mapping The mapping to be associated with the action class package."}
{"ID": 1580, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String findRootPackageForActionPath(final String actionPath) { if (mappings == null) { return null; } int ndx = -1; int delta = Integer.MAX_VALUE; for (int i = 0; i < mappings.length; i++) { String mapping = mappings[i]; boolean found = false; if (actionPath.equals(mapping)) { found = true; } else { mapping += StringPool.SLASH; if (actionPath.startsWith(mapping)) { found = true; } } if (found) { int distance = actionPath.length() - mapping.length(); if (distance < delta) { ndx = i; delta = distance; } } } if (ndx == -1) { return null; } return packages[ndx]; } \nResponse:", "ground_truth": "Finds closest root package for the given action path.", "predict": " Finds the root package for the given action path. @param actionPath the action path to find the root package for. @return the root package for the given action path. May be <code>null</code> if no root package was found."}
{"ID": 1581, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveValidationMessage(final HttpServletRequest request, final Violation violation) { ValidationConstraint vc = violation.getConstraint(); String key = vc != null ? vc.getClass().getName() : violation.getName(); String msg = LocalizationUtil.findMessage(request, key); if (msg != null) { return beanTemplateParser.parseWithBean(msg, violation); } return null; } \nResponse:", "ground_truth": "Prepares validation messages.\nKey is either validation constraint class name or violation name.", "predict": " Resolve violation message. @param request the request @param violation violation @return violation message\n*/"}
{"ID": 1582, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BeanReferences removeDuplicateNames() { if (names.length < 2) { return this; } int nullCount = 0; for (int i = 1; i < names.length; i++) { String thisRef = names[i]; if (thisRef == null) { nullCount++; continue; } for (int j = 0; j < i; j++) { if (names[j] == null) { continue; } if (thisRef.equals(names[j])) { names[i] = null; break; } } } if (nullCount == 0) { return this; } String[] newRefs = new String[names.length - nullCount]; int ndx = 0; for (String name : names) { if (name == null) { continue; } newRefs[ndx] = name; ndx++; } return new BeanReferences(newRefs); } \nResponse:", "ground_truth": "Removes later duplicated references in an array.\nReturns new instance of BeanReferences if there was changes,\notherwise returns the same instance.", "predict": " Remove duplicate references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to be unnamed references. Duplicates are assumed to"}
{"ID": 1583, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public JoyProps addPropsFile(final String namePattern) { requireNotStarted(props); this.propsNamePatterns.add(namePattern); return this; } \nResponse:", "ground_truth": "Adds props files or patterns.", "predict": " Adds a JoyProps file to be loaded. JoyProps files are loaded in alphabetical order. @param namePattern JoyProps file name pattern. @return JoyPropsBuilder instance.\n*/"}
{"ID": 1584, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTarget(final Consumer<Target> targetConsumer) { for (final Target target : targets) { targetConsumer.accept(target); } } \nResponse:", "ground_truth": "Iterates all targets.", "predict": " For each target, call the consumer. Useful for dumping targets. @param targetConsumer Consumer to accept each target."}
{"ID": 1585, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTargetAndIn(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.in() == null) { continue; } for (final InjectionPoint in : scopeData.in()) { if (in.scope() != scope) { continue; } biConsumer.accept(target, in); } } } \nResponse:", "ground_truth": "Iterates all targets and for each target iterates all IN injection points of given scope.", "predict": " Iterates over targets and applies biConsumer to each target and injection point. BiConsumer receives Target and InjectionPoint. Targets are iterated in the order they were added to Madvoc container. Therefore, if you need to iterate over targets in some other order, you need to sort them yourself. @param scope Madvoc scope. @param biConsumer BiConsumer accepting Target and InjectionPoint."}
{"ID": 1586, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) { for (final Target target : targets) { final ScopeData scopeData = target.scopeData(); if (scopeData.out() == null) { continue; } for (final InjectionPoint out : scopeData.out()) { if (out.scope() != scope) { continue; } biConsumer.accept(target, out); } } } \nResponse:", "ground_truth": "Iterates all targets and for each target iterates all OUT injection points of given scope.", "predict": " Iterates over targets and collects injection points for the given scope. Useful for Madvoc filters. @param scope Madvoc scope. @param biConsumer BiConsumer accepting Target and InjectionPoint."}
{"ID": 1587, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object[] extractParametersValues() { final Object[] values = new Object[targets.length - 1]; for (int i = 1; i < targets.length; i++) { values[i - 1] = targets[i].value(); } return values; } \nResponse:", "ground_truth": "Collects all parameters from target into an array.", "predict": " Extracts values of parameters from the targets. @return array of values of parameters from the targets."}
{"ID": 1588, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Target[] makeTargets(final Target actionTarget, final MethodParam[] methodParams) { if (methodParams == null) { // action does not have method parameters, so there is just one target return new Target[]{actionTarget}; } // action has method arguments, so there is more then one target final Target[] target = new Target[methodParams.length + 1]; target[0] = actionTarget; final Object action = actionTarget.value(); for (int i = 0; i < methodParams.length; i++) { final MethodParam methodParam = methodParams[i]; final Class paramType = methodParam.type(); final Target paramTarget; if (methodParam.annotationType() == null) { // parameter is NOT annotated, create new value for the target // the class itself will be a base class, and should be scanned final ScopeData newScopeData = methodParam.scopeData().inspector().inspectClassScopesWithCache(paramType); paramTarget = Target.ofValue(createActionMethodArgument(paramType, action), newScopeData); } else if (methodParam.annotationType() == Out.class) { // parameter is annotated with *only* OUT annotation // create the output value now AND to save the type paramTarget = Target.ofMethodParam(methodParam, createActionMethodArgument(paramType, action)); } else { // parameter is annotated with any IN annotation // create target with NO value, as the value will be created later paramTarget = Target.ofMethodParam(methodParam, type -> createActionMethodArgument(type, action)); } target[i + 1] = paramTarget; } return target; } \nResponse:", "ground_truth": "Joins action and parameters into one single array of Targets.", "predict": " Makes Targets for the action and method parameters. Targets are created for the action and for each method parameter. Targets are created for each OUT parameter of the action, and for each IN parameter of the action. Targets are created for each OUT parameter of the method, and for each IN parameter of the method. @param actionTarget Target for the action. @param methodParams Targets for the action and method parameters. @return Targets for the action and method parameters."}
{"ID": 1589, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings({\"unchecked\", \"NullArgumentToVariableArgMethod\"}) protected Object createActionMethodArgument(final Class type, final Object action) { try { if (type.getEnclosingClass() == null || Modifier.isStatic(type.getModifiers())) { // regular or static class return ClassUtil.newInstance(type); } else { // member class Constructor ctor = type.getDeclaredConstructor(type.getDeclaringClass()); ctor.setAccessible(true); return ctor.newInstance(action); } } catch (Exception ex) { throw new MadvocException(ex); } } \nResponse:", "ground_truth": "Creates action method arguments.", "predict": " Creates Madvoc action method argument. @param type Argument type. @param action Madvoc action. @return Argument value.\n"}
{"ID": 1590, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void sessionCreated(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.putIfAbsent(session.getId(), session); for (HttpSessionListener listener : listeners) { listener.sessionCreated(httpSessionEvent); } } \nResponse:", "ground_truth": "Stores session in map and broadcasts event to registered listeners.", "predict": " Fires SessionCreated event to registered listeners. @param httpSessionEvent the event to be fired."}
{"ID": 1591, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void sessionDestroyed(final HttpSessionEvent httpSessionEvent) { HttpSession session = httpSessionEvent.getSession(); sessionMap.remove(session.getId()); for (HttpSessionListener listener : listeners) { listener.sessionDestroyed(httpSessionEvent); } } \nResponse:", "ground_truth": "Removes session from a map and broadcasts event to registered listeners.", "predict": " Destroyed Session Listener. Destroyed sessions are removed from the session map. Also invokes the sessionDestroyed method on each registered HttpSessionListener. @param httpSessionEvent The HttpSessionEvent raised when a session is destroyed.\n*/"}
{"ID": 1592, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonArray add(Object value) { Objects.requireNonNull(value); value = JsonObject.resolveValue(value); list.add(value); return this; } \nResponse:", "ground_truth": "Adds an object to the JSON array.", "predict": " Adds a new value to the array.\n<p>If the value is a {@link JsonObject} it will be added to the array recursively. If the value is a {@link JsonArray}, it will be added to the array recursively. If the value is a primitive, it will be converted to a JsonArray and added to the array. If the value is a {@link JsonPrimitive} and is not a number, it will be converted to a JsonArray and added to the array. If the value is a {@link JsonNull}, it will be added to the array. If the value is a {@link JsonString}, it will be added to the array. If the value is a {@link JsonNumber}, it will be added to the array. If the value is a {@link JsonSymbol}, it will be added to the array. If the value is a {@link JsonObject}, it will be added to the array recurs"}
{"ID": 1593, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JsonArray addAll(final JsonArray array) { Objects.requireNonNull(array); list.addAll(array.list); return this; } \nResponse:", "ground_truth": "Appends all of the elements in the specified array to the end of this JSON array.", "predict": " Adds all elements of the specified array to this array. @param array the array whose elements are to be added to this array @return this array\n*/"}
{"ID": 1594, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Object remove(final int pos) { Object removed = list.remove(pos); if (removed instanceof Map) { return new JsonObject((Map) removed); } if (removed instanceof ArrayList) { return new JsonArray((List) removed); } return removed; } \nResponse:", "ground_truth": "Removes the value at the specified position in the JSON array.", "predict": " Remove an element from the list. @param pos Position of the element to remove. @return Removed element."}
{"ID": 1595, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveTarget(final ActionRequest actionRequest, final String resultValue) { String resultBasePath = actionRequest.getActionRuntime().getResultBasePath(); ResultPath resultPath = resultMapper.resolveResultPath(resultBasePath, resultValue); String actionPath = resultPath.path(); String path = actionPath; String value = resultPath.value(); if (StringUtil.isEmpty(value)) { value = null; } String target; while (true) { // variant #1: with value if (value != null) { if (path == null) { // only value remains int lastSlashNdx = actionPath.lastIndexOf('/'); if (lastSlashNdx != -1) { target = actionPath.substring(0, lastSlashNdx + 1) + value; } else { target = '/' + value; } } else { target = path + '.' + value; } target = locateTarget(actionRequest, target); if (target != null) { break; } } if (path != null) { // variant #2: without value target = locateTarget(actionRequest, path); if (target != null) { break; } } // continue if (path == null) { // path not found return null; } int dotNdx = MadvocUtil.lastIndexOfDotAfterSlash(path); if (dotNdx == -1) { path = null; } else { path = path.substring(0, dotNdx); } } return target; } \nResponse:", "ground_truth": "Locates the target file from action path and the result value.", "predict": " Resolves target for the given result value. @param actionRequest Current action request. @param resultValue Result value to resolve. @return Target resolved for the given result value. May be <code>null</code>."}
{"ID": 1596, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void targetNotFound(final ActionRequest actionRequest, final String actionAndResultPath) throws IOException { final HttpServletResponse response = actionRequest.getHttpServletResponse(); if (!response.isCommitted()) { response.sendError(SC_NOT_FOUND, \"Result not found: \" + actionAndResultPath); } } \nResponse:", "ground_truth": "Called when target not found. By default sends 404 to the response.", "predict": " Respond with HTTP 404 Not Found. @param actionRequest the action request @param actionAndResultPath the action and result path @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1597, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String valueToString(final String name, final Object valueObject) { if (!valueObject.getClass().isArray()) { return valueObject.toString(); } // array String[] array = (String[]) valueObject; if (valueNameIndexes == null) { valueNameIndexes = new HashMap<>(); } MutableInteger index = valueNameIndexes.get(name); if (index == null) { index = new MutableInteger(0); valueNameIndexes.put(name, index); } if (index.value >= array.length) { return null; } String result = array[index.value]; index.value++; return result; } \nResponse:", "ground_truth": "Converts value to a string.", "predict": " Convert the valueObject to a String. The default implementation delegates to the toString() method of the valueObject. Subclasses may override this method to provide a different implementation. @param name the name of the valueObject whose value is to be converted to a String. @param valueObject the valueObject whose value is to be converted to a String. @return the String representation of the valueObject.\n*/"}
{"ID": 1598, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public <T extends ActionFilter> MadvocRouter filter(final Class<T> actionFilterClass) { filtersManager.resolve(actionFilterClass); return this; } \nResponse:", "ground_truth": "Returns action filter instance for further configuration.", "predict": " Register new Madvoc filter. The filter will be instantiated using reflection. Therefore, you can't specify generics here. Madvoc filters are Madvoc interceptors. Therefore, Madvoc Interceptor is the most suitable way to implement Madvoc filters. However, you can register Madvoc filters without Madvoc Interceptor. Madvoc filters are Madvoc interceptors too. Therefore, Madvoc Interceptor is the most suitable way to implement Madvoc filters. However, you can register Madvoc filters without Madvoc Interceptor. Therefore, Madvoc filters are Madvoc interceptors too. Therefore, Madvoc Interceptor is the most suitable way to implement Madvoc filters. However, you can register Madvoc filters without Madvoc Interceptor. Therefore, Madvoc filters are Madvoc interceptors too. Therefore, Madvoc Interceptor is the most suitable way to implement Madvoc filters. However, you can register Madvoc filters without Madvoc Interceptor. Therefore, Madvoc filters are Madvoc interceptors too. Therefore, Madvoc Interceptor is the most suitable way to"}
{"ID": 1599, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getPseudoFunctionName() { String name = getClass().getSimpleName().toLowerCase(); name = name.replace('_', '-'); return name; } \nResponse:", "ground_truth": "Returns pseudo-function name.", "predict": " Pseudo-element functions names."}
{"ID": 1600, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PropertyInjectionPoint[] resolve(Class type, final boolean autowire) { final List<PropertyInjectionPoint> list = new ArrayList<>(); final Set<String> usedPropertyNames = new HashSet<>(); // lookup fields while (type != Object.class) { final ClassDescriptor cd = ClassIntrospector.get().lookup(type); final PropertyDescriptor[] allPropertyDescriptors = cd.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : allPropertyDescriptors) { if (propertyDescriptor.isGetterOnly()) { continue; } if (usedPropertyNames.contains(propertyDescriptor.getName())) { continue; } Class propertyType = propertyDescriptor.getType(); if (ClassUtil.isTypeOf(propertyType, Collection.class)) { continue; } BeanReferences reference = referencesResolver.readReferenceFromAnnotation(propertyDescriptor); if (reference == null) { if (!autowire) { continue; } else { reference = referencesResolver.buildDefaultReference(propertyDescriptor); } } list.add(new PropertyInjectionPoint(propertyDescriptor, reference)); usedPropertyNames.add(propertyDescriptor.getName()); } // go to the supertype type = type.getSuperclass(); } final PropertyInjectionPoint[] fields; if (list.isEmpty()) { fields = PropertyInjectionPoint.EMPTY; } else { fields = list.toArray(new PropertyInjectionPoint[0]); } return fields; } \nResponse:", "ground_truth": "Resolves all properties for given type.", "predict": " Resolve all injection points for the given type. @param type The type to resolve injection points for. @param autowire Flag indicating whether autowiring should be performed. @return The resolved injection points. Shall not be <code>null</code>. Shall not be empty. Shall contain at least one element. Shall not contain duplicates. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall not contain unresolved injection points. Shall not contain unresolved autowiring references. Shall"}
{"ID": 1601, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private Socket createSocks4ProxySocket(final String host, final int port) { Socket socket = null; final String proxyHost = proxy.getProxyAddress(); final int proxyPort = proxy.getProxyPort(); final String user = proxy.getProxyUsername(); try { socket = Sockets.connect(proxyHost, proxyPort, connectionTimeout); final InputStream in = socket.getInputStream(); final OutputStream out = socket.getOutputStream(); socket.setTcpNoDelay(true); byte[] buf = new byte[1024]; // 1) CONNECT int index = 0; buf[index++] = 4; buf[index++] = 1; buf[index++] = (byte) (port >>> 8); buf[index++] = (byte) (port & 0xff); InetAddress addr = InetAddress.getByName(host); byte[] byteAddress = addr.getAddress(); for (byte byteAddres : byteAddress) { buf[index++] = byteAddres; } if (user != null) { System.arraycopy(user.getBytes(), 0, buf, index, user.length()); index += user.length(); } buf[index++] = 0; out.write(buf, 0, index); // 2) RESPONSE int len = 6; int s = 0; while (s < len) { int i = in.read(buf, s, len - s); if (i <= 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"stream is closed\"); } s += i; } if (buf[0] != 0) { throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned VN \" + buf[0]); } if (buf[1] != 90) { try { socket.close(); } catch (Exception ignore) { } throw new HttpException(ProxyInfo.ProxyType.SOCKS4, \"proxy returned CD \" + buf[1]); } byte[] temp = new byte[2]; in.read(temp, 0, 2); return socket; } catch (RuntimeException rtex) { closeSocket(socket); throw rtex; } catch (Exception ex) { closeSocket(socket); throw new HttpException(ProxyInfo.ProxyType.SOCKS4, ex.toString(), ex); } } \nResponse:", "ground_truth": "Connects to the SOCKS4 proxy and returns proxified socket.", "predict": " Establish a SOCKS4 proxy connection to the specified host and port. @param host Target host. @param port Target port. @return Socket."}
{"ID": 1602, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final int getAttributeCount() { int count = 0; Attribute attribute = this; while (attribute != null) { count += 1; attribute = attribute.nextAttribute; } return count; } \nResponse:", "ground_truth": "Returns the number of attributes of the attribute list that begins with this attribute.\n\n@return the number of attributes of the attribute list that begins with this attribute.", "predict": " Returns the number of attributes in this attribute list. @return the number of attributes in this attribute list."}
{"ID": 1603, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Set<ActionResult> getAllActionResults() { final Set<ActionResult> set = new HashSet<>(allResults.size()); allResults.forEachValue(set::add); return set; } \nResponse:", "ground_truth": "Returns all action results as new set.", "predict": " Returns all action results. Useful for debugging. @return all action results\n*/"}
{"ID": 1604, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean equalsOne(final char c, final CharSequence match) { for (int i = 0; i < match.length(); i++) { char aMatch = match.charAt(i); if (c == aMatch) { return true; } } return false; } \nResponse:", "ground_truth": "Match if one character equals to any of the given character.\n\n@return <code>true</code> if characters match any character from given array,\notherwise <code>false</code>", "predict": " Match a char against a CharSequence irrespective of case. @param c char to match against char sequence @param match CharSequence to match against @return true if char matches CharSequence ignoring case, false otherwise\n*/"}
{"ID": 1605, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstEqual(final CharSequence source, final int index, final CharSequence match) { for (int i = index; i < source.length(); i++) { if (equalsOne(source.charAt(i), match)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given charsequence the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Finds the first occurrence of a subsequence in a CharSequence, starting at a specified index. Returns -1 if the sequence is not found. @param source CharSequence to search, may be null\n@param index Index to start searching at\n@param match CharSequence to match, may be null\n@return the index of the first matching character, -1 if no match found or null input\n*/"}
{"ID": 1606, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstEqual(final char[] source, final int index, final char match) { for (int i = index; i < source.length; i++) { if (source[i] == match) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given array the matches any from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Finds the first occurrence of a char in a char array that is equal to the given char. Returns -1 if not found. @param source char array to search in. Cannot be null. @param index Index to start searching from. Cannot be negative. @param match char to match. Cannot be 0. @return The index of the first matching char or -1 if none found."}
{"ID": 1607, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CommandLine args(final String... arguments) { if (arguments != null && arguments.length > 0) { Collections.addAll(cmdLine, arguments); } return this; } \nResponse:", "ground_truth": "Adds several arguments.", "predict": " Adds arguments to the command line. @param arguments The arguments to add. @return The command line.\n*/"}
{"ID": 1608, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CommandLine env(final String key, final String value) { if (env == null) { env = new HashMap<>(); } env.put(key, value); return this; } \nResponse:", "ground_truth": "Sets environment variable.", "predict": " Adds environment variable override. @param key The environment variable key. @param value The environment variable value. @return Fluent API."}
{"ID": 1609, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProcessRunner.ProcessResult run() { ByteArrayOutputStream baos = new ByteArrayOutputStream(); out = err = baos; try { baos.write(StringUtil.join(cmdLine, ' ').getBytes()); baos.write(StringPool.BYTES_NEW_LINE); } catch (IOException ignore) { } ProcessBuilder processBuilder = new ProcessBuilder(); processBuilder.command(cmdLine); if (cleanEnvironment) { processBuilder.environment().clear(); } if (env != null) { processBuilder.environment().putAll(env); } processBuilder.directory(workingDirectory); Process process = null; try { process = processBuilder.start(); } catch (IOException ioex) { return writeException(baos, ioex); } StreamGobbler outputGobbler = new StreamGobbler(process.getInputStream(), out, outPrefix); StreamGobbler errorGobbler = new StreamGobbler(process.getErrorStream(), err, errPrefix); outputGobbler.start(); errorGobbler.start(); int result; try { result = process.waitFor(); } catch (InterruptedException iex) { return writeException(baos, iex); } outputGobbler.waitFor(); errorGobbler.waitFor(); return new ProcessRunner.ProcessResult(result, baos.toString()); } \nResponse:", "ground_truth": "Runs command and returns process result.", "predict": " Runs the process. @return The process result.\n*/"}
{"ID": 1610, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void invoke(final Object listener, final Class listenerType) { if (listenerType == Init.class) { ((Init) listener).init(); return; } if (listenerType == Start.class) { ((Start) listener).start(); return; } if (listenerType == Ready.class) { ((Ready) listener).ready(); return; } if (listenerType == Stop.class) { ((Stop) listener).stop(); return; } throw new MadvocException(\"Invalid listener\"); } \nResponse:", "ground_truth": "Invoke the listener based on type.\nNot very OOP, but works.", "predict": " Invokes the listener. @param listener listener to invoke. @param listenerType listener type. Can be Init, Start, Ready, Stop."}
{"ID": 1611, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void copyFrom(final Frame frame) { inputLocals = frame.inputLocals; inputStack = frame.inputStack; outputStackStart = 0; outputLocals = frame.outputLocals; outputStack = frame.outputStack; outputStackTop = frame.outputStackTop; initializationCount = frame.initializationCount; initializations = frame.initializations; } \nResponse:", "ground_truth": "Sets this frame to the value of the given frame.\n\n<p>WARNING: after this method is called the two frames share the same data structures. It is\nrecommended to discard the given frame to avoid unexpected side effects.\n\n@param frame The new frame value.", "predict": " Copies the state of the given frame into this frame. Previous contents are discarded."}
{"ID": 1612, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) { if (type instanceof Integer) { return CONSTANT_KIND | ((Integer) type).intValue(); } else if (type instanceof String) { String descriptor = Type.getObjectType((String) type).getDescriptor(); return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0); } else { return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset); } } \nResponse:", "ground_truth": "Returns the abstract type corresponding to the given public API frame element type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param type a frame element type described using the same format as in {@link\nMethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link\nOpcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or\n{@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating\na NEW instruction (for uninitialized types).\n@return the abstract type corresponding to the given frame element type.", "predict": " Conservatively interpret the given type as an abstract type. This assumes that the type is an internal proprietary API format and does not correspond to any actual class or interface declaration. Conservatively assumes that the type is an abstract class or interface. Conservatively assumes that the type is not an array. Conservatively assumes that the type is not a primitive. Conservatively assumes that the type is not an uninitialized type. Conservatively assumes that the type is not a phantom type. Conservatively assumes that the type is not a lambda type. Conservatively assumes that the type is not a method type. Conservatively assumes that the type is not a type variable. Conservatively assumes that the type is not a wildcard. Conservatively assumes that the type is not a synthetic interface. Conservatively assumes that the type is not a synthetic class. Conservatively assumes that the type is not a synthetic lambda. Conservatively assumes that the type is not a synthetic annotation. Conservatively assumes that the type is not a synthetic enum. Conservatively assumes that the type is not a synthetic annotation. Conservatively"}
{"ID": 1613, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getAbstractTypeFromDescriptor( final SymbolTable symbolTable, final String buffer, final int offset) { String internalName; switch (buffer.charAt(offset)) { case 'V': return 0; case 'Z': case 'C': case 'B': case 'S': case 'I': return INTEGER; case 'F': return FLOAT; case 'J': return LONG; case 'D': return DOUBLE; case 'L': internalName = buffer.substring(offset + 1, buffer.length() - 1); return REFERENCE_KIND | symbolTable.addType(internalName); case '[': int elementDescriptorOffset = offset + 1; while (buffer.charAt(elementDescriptorOffset) == '[') { ++elementDescriptorOffset; } int typeValue; switch (buffer.charAt(elementDescriptorOffset)) { case 'Z': typeValue = BOOLEAN; break; case 'C': typeValue = CHAR; break; case 'B': typeValue = BYTE; break; case 'S': typeValue = SHORT; break; case 'I': typeValue = INTEGER; break; case 'F': typeValue = FLOAT; break; case 'J': typeValue = LONG; break; case 'D': typeValue = DOUBLE; break; case 'L': internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1); typeValue = REFERENCE_KIND | symbolTable.addType(internalName); break; default: throw new IllegalArgumentException(); } return ((elementDescriptorOffset - offset) << DIM_SHIFT) | typeValue; default: throw new IllegalArgumentException(); } } \nResponse:", "ground_truth": "Returns the abstract type corresponding to the given type descriptor.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param buffer a string ending with a type descriptor.\n@param offset the start offset of the type descriptor in buffer.\n@return the abstract type corresponding to the given type descriptor.", "predict": " Reads an abstract descriptor from the given buffer. @param symbolTable the symbol table to use to lookup and add types. @param buffer the buffer to read from. @param offset the offset into the buffer. @return the abstract type descriptor read from the buffer.\n*/"}
{"ID": 1614, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final void setInputFrameFromApiFormat( final SymbolTable symbolTable, final int numLocal, final Object[] local, final int numStack, final Object[] stack) { int inputLocalIndex = 0; for (int i = 0; i < numLocal; ++i) { inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]); if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) { inputLocals[inputLocalIndex++] = TOP; } } while (inputLocalIndex < inputLocals.length) { inputLocals[inputLocalIndex++] = TOP; } int numStackTop = 0; for (int i = 0; i < numStack; ++i) { if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { ++numStackTop; } } inputStack = new int[numStack + numStackTop]; int inputStackIndex = 0; for (int i = 0; i < numStack; ++i) { inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]); if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) { inputStack[inputStackIndex++] = TOP; } } outputStackTop = 0; initializationCount = 0; } \nResponse:", "ground_truth": "Sets the input frame from the given public API frame description.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param numLocal the number of local variables.\n@param local the local variable types, described using the same format as in {@link\nMethodVisitor#visitFrame}.\n@param numStack the number of operand stack elements.\n@param stack the operand stack types, described using the same format as in {@link\nMethodVisitor#visitFrame}.", "predict": " Reinitializes the frame so that the locals array refers to the same types as the inputs array. This is useful so that you can use frame to find the index of various stack or local items. However, frames are immutable and this method cannot change the frame itself. So, this method creates a new frame that shares the locals array but with the input types."}
{"ID": 1615, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getLocal(final int localIndex) { if (outputLocals == null || localIndex >= outputLocals.length) { // If this local has never been assigned in this basic block, it is still equal to its value // in the input frame. return LOCAL_KIND | localIndex; } else { int abstractType = outputLocals[localIndex]; if (abstractType == 0) { // If this local has never been assigned in this basic block, so it is still equal to its // value in the input frame. abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex; } return abstractType; } } \nResponse:", "ground_truth": "Returns the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the local variable whose value must be returned.\n@return the abstract type stored at the given local variable index in the output frame.", "predict": " Returns the abstract type corresponding to the given local variable index. The default implementation of this method assumes that locals are not aliased, and thus no propagation is needed. If this assumption changes in a future version, then aliasing must be accounted for."}
{"ID": 1616, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setLocal(final int localIndex, final int abstractType) { // Create and/or resize the output local variables array if necessary. if (outputLocals == null) { outputLocals = new int[10]; } int outputLocalsLength = outputLocals.length; if (localIndex >= outputLocalsLength) { int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)]; System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength); outputLocals = newOutputLocals; } // Set the local variable. outputLocals[localIndex] = abstractType; } \nResponse:", "ground_truth": "Replaces the abstract type stored at the given local variable index in the output frame.\n\n@param localIndex the index of the output frame local variable that must be set.\n@param abstractType the value that must be set.", "predict": " Makes the given local variable available. Does nothing if the local variable is already available or was already set. Increases the number of locals if needed. @param localIndex the index of the local variable whose value must be set. This value must be >= 0 and <= the maximum number of local variables of the method corresponding to this Code attribute, taken into account with the special value -1. @param abstractType an abstract type. See {@link Frame#getLocal(int, int)}."}
{"ID": 1617, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void push(final int abstractType) { // Create and/or resize the output stack array if necessary. if (outputStack == null) { outputStack = new int[10]; } int outputStackLength = outputStack.length; if (outputStackTop >= outputStackLength) { int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)]; System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength); outputStack = newOutputStack; } // Pushes the abstract type on the output stack. outputStack[outputStackTop++] = abstractType; // Updates the maximum size reached by the output stack, if needed (note that this size is // relative to the input stack size, which is not known yet). short outputStackSize = (short) (outputStackStart + outputStackTop); if (outputStackSize > owner.outputStackMax) { owner.outputStackMax = outputStackSize; } } \nResponse:", "ground_truth": "Pushes the given abstract type on the output frame stack.\n\n@param abstractType an abstract type.", "predict": " Pushes an abstract type on the output stack. Contrary to the input stack, the output stack reflects the effects of the instructions rather than the abstract types pushed during the execution of the method. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary to the input stack, the output stack reflects abstract types that are pushed by instructions executed in the basic block. Moreover, contrary"}
{"ID": 1618, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void push(final SymbolTable symbolTable, final String descriptor) { int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0; int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset); if (abstractType != 0) { push(abstractType); if (abstractType == LONG || abstractType == DOUBLE) { push(TOP); } } } \nResponse:", "ground_truth": "Pushes the abstract type corresponding to the given descriptor on the output frame stack.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param descriptor a type or method descriptor (in which case its return type is pushed).", "predict": " Pushes the abstract type pushed by the given symbol. The abstract type pushed depends on the pushed symbol kind. For instance, the abstract type pushed by the \"this\" keyword is the type of the enclosing class. The abstract type pushed by an array type is the component type of the array. The abstract type pushed by a primitive type is its wrapper class. Lastly, the abstract type pushed by a void type is TOP."}
{"ID": 1619, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pop(final int elements) { if (outputStackTop >= elements) { outputStackTop -= elements; } else { // If the number of elements to be popped is greater than the number of elements in the output // stack, clear it, and pop the remaining elements from the input stack. outputStackStart -= elements - outputStackTop; outputStackTop = 0; } } \nResponse:", "ground_truth": "Pops the given number of abstract types from the output frame stack.\n\n@param elements the number of abstract types that must be popped.", "predict": " pops elements from the output stack. Used by the POP instruction. @param elements number of elements to be popped from the output stack. popped elements are numbered from the bottom of the stack starting at 0. Negative numbers indicate elements relative to the top of the stack starting at -1. Thus, -1 is the top element, -2 is the next-to-top element, and so forth.\n*/"}
{"ID": 1620, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void pop(final String descriptor) { char firstDescriptorChar = descriptor.charAt(0); if (firstDescriptorChar == '(') { pop((Type.getArgumentsAndReturnSizes(descriptor) >> 2) - 1); } else if (firstDescriptorChar == 'J' || firstDescriptorChar == 'D') { pop(2); } else { pop(1); } } \nResponse:", "ground_truth": "Pops as many abstract types from the output frame stack as described by the given descriptor.\n\n@param descriptor a type or method descriptor (in which case its argument types are popped).", "predict": " Pop one operand off the stack."}
{"ID": 1621, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addInitializedType(final int abstractType) { // Create and/or resize the initializations array if necessary. if (initializations == null) { initializations = new int[2]; } int initializationsLength = initializations.length; if (initializationCount >= initializationsLength) { int[] newInitializations = new int[Math.max(initializationCount + 1, 2 * initializationsLength)]; System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength); initializations = newInitializations; } // Store the abstract type. initializations[initializationCount++] = abstractType; } \nResponse:", "ground_truth": "Adds an abstract type to the list of types on which a constructor is invoked in the basic\nblock.\n\n@param abstractType an abstract type on a which a constructor is invoked.", "predict": " Add an initialized type to the evolving type. This will trigger the creation of an anonymous type if needed. @param abstractType the abstract type of the initialized type\n*/"}
{"ID": 1622, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private int getInitializedType(final SymbolTable symbolTable, final int abstractType) { if (abstractType == UNINITIALIZED_THIS || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) { for (int i = 0; i < initializationCount; ++i) { int initializedType = initializations[i]; int dim = initializedType & DIM_MASK; int kind = initializedType & KIND_MASK; int value = initializedType & VALUE_MASK; if (kind == LOCAL_KIND) { initializedType = dim + inputLocals[value]; } else if (kind == STACK_KIND) { initializedType = dim + inputStack[inputStack.length - value]; } if (abstractType == initializedType) { if (abstractType == UNINITIALIZED_THIS) { return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName()); } else { return REFERENCE_KIND | symbolTable.addType(symbolTable.getType(abstractType & VALUE_MASK).value); } } } } return abstractType; } \nResponse:", "ground_truth": "Returns the \"initialized\" abstract type corresponding to the given abstract type.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type.\n@return the REFERENCE_KIND abstract type corresponding to abstractType if it is\nUNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\nconstructor is invoked in the basic block. Otherwise returns abstractType.", "predict": " Returns the index of the next element to be added in the input frame."}
{"ID": 1623, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: static void putAbstractType( final SymbolTable symbolTable, final int abstractType, final ByteVector output) { int arrayDimensions = (abstractType & Frame.DIM_MASK) >> DIM_SHIFT; if (arrayDimensions == 0) { int typeValue = abstractType & VALUE_MASK; switch (abstractType & KIND_MASK) { case CONSTANT_KIND: output.putByte(typeValue); break; case REFERENCE_KIND: output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index); break; case UNINITIALIZED_KIND: output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data); break; default: throw new AssertionError(); } } else { // Case of an array type, we need to build its descriptor first. StringBuilder typeDescriptor = new StringBuilder(); while (arrayDimensions-- > 0) { typeDescriptor.append('['); } if ((abstractType & KIND_MASK) == REFERENCE_KIND) { typeDescriptor .append('L') .append(symbolTable.getType(abstractType & VALUE_MASK).value) .append(';'); } else { switch (abstractType & VALUE_MASK) { case Frame.ITEM_ASM_BOOLEAN: typeDescriptor.append('Z'); break; case Frame.ITEM_ASM_BYTE: typeDescriptor.append('B'); break; case Frame.ITEM_ASM_CHAR: typeDescriptor.append('C'); break; case Frame.ITEM_ASM_SHORT: typeDescriptor.append('S'); break; case Frame.ITEM_INTEGER: typeDescriptor.append('I'); break; case Frame.ITEM_FLOAT: typeDescriptor.append('F'); break; case Frame.ITEM_LONG: typeDescriptor.append('J'); break; case Frame.ITEM_DOUBLE: typeDescriptor.append('D'); break; default: throw new AssertionError(); } } output .putByte(ITEM_OBJECT) .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index); } } \nResponse:", "ground_truth": "Put the given abstract type in the given ByteVector, using the JVMS verification_type_info\nformat used in StackMapTable attributes.\n\n@param symbolTable the type table to use to lookup and store type {@link Symbol}.\n@param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link\nFrame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n@param output where the abstract type must be put.\n@see <a href=\"https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4\">JVMS\n4.7.4</a>", "predict": " Puts the given abstract type in the given byte vector. @param symbolTable where the type must be found or written. This is the symbol table provided with the class reader or writer. @param abstractType an abstract type. This type should be one of the constants defined in {@link Frame}. @param output where the type must be written.\n*/"}
{"ID": 1624, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected int pruneCache() { int count = 0; Iterator<CacheObject<K,V>> values = cacheMap.values().iterator(); while (values.hasNext()) { CacheObject co = values.next(); if (co.isExpired()) { values.remove(); count++; } } return count; } \nResponse:", "ground_truth": "Prunes expired elements from the cache. Returns the number of removed objects.", "predict": " Prune expired entries from the cache.\nReturns the number of expired entries pruned from the cache.\n*/"}
{"ID": 1625, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void schedulePrune(final long delay) { if (pruneTimer != null) { pruneTimer.cancel(); } pruneTimer = new Timer(); pruneTimer.schedule( new TimerTask() { @Override public void run() { prune(); } }, delay, delay ); } \nResponse:", "ground_truth": "Schedules prune.", "predict": " Schedules periodic pruning of the repository. Useful for limiting the disk space occupied by massive repositories.\n * @param delay delay in milliseconds between consecutive pruning attempts\n */ MeleeTimerTask. MeleeTimerTask(long delay) { super(delay); }\n"}
{"ID": 1626, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ModuleVisitor visitModule(final String name, final int access, final String version) { if (api < Opcodes.ASM6) { throw new UnsupportedOperationException(\"This feature requires ASM6\"); } if (cv != null) { return cv.visitModule(name, access, version); } return null; } \nResponse:", "ground_truth": "Visit the module corresponding to the class.\n\n@param name the fully qualified name (using dots) of the module.\n@param access the module access flags, among {@code ACC_OPEN}, {@code ACC_SYNTHETIC} and {@code\nACC_MANDATED}.\n@param version the module version, or {@literal null}.\n@return a visitor to visit the module values, or {@literal null} if this visitor is not\ninterested in visiting this module.", "predict": " Visit an open module. @param name the internal name of the module. @param access the module access flags. @param version the module version or 0 if the module was compiled by the compiler and thus its version is unknown. @return a visitor to visit the module values or <tt>null</tt> if this visitor is not interested in visiting this module.\n"}
{"ID": 1627, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitNestHost(final String nestHost) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestHost(nestHost); } } \nResponse:", "ground_truth": "Visits the nest host class of the class. A nest is a set of classes of the same package that\nshare access to their private members. One of these classes, called the host, lists the other\nmembers of the nest, which in turn should link to the host of their nest. This method must be\ncalled only once and only if the visited class is a non-host member of a nest. A class is\nimplicitly its own nest, so it's invalid to call this method with the visited class name as\nargument.\n\n@param nestHost the internal name of the host class of the nest.", "predict": " Visits the nest host of the given type. @param nestHost the class name of the nest host.\n */"}
{"ID": 1628, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitOuterClass(final String owner, final String name, final String descriptor) { if (cv != null) { cv.visitOuterClass(owner, name, descriptor); } } \nResponse:", "ground_truth": "Visits the enclosing class of the class. This method must be called only if the class has an\nenclosing class.\n\n@param owner internal name of the enclosing class of the class.\n@param name the name of the method that contains the class, or {@literal null} if the class is\nnot enclosed in a method of its enclosing class.\n@param descriptor the descriptor of the method that contains the class, or {@literal null} if\nthe class is not enclosed in a method of its enclosing class.", "predict": " Visits the enclosing class of the class. This method must be called only if the class has an enclosing class. @param owner internal name of the enclosing class of the class. @param name name of the enclosing class of the class. @param descriptor descriptor of the enclosing class of the class.\n"}
{"ID": 1629, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) { if (cv != null) { return cv.visitAnnotation(descriptor, visible); } return null; } \nResponse:", "ground_truth": "Visits an annotation of the class.\n\n@param descriptor the class descriptor of the annotation class.\n@param visible {@literal true} if the annotation is visible at runtime.\n@return a visitor to visit the annotation values, or {@literal null} if this visitor is not\ninterested in visiting this annotation.", "predict": " Visits an annotation of the field. @param descriptor the class descriptor of the annotation class. @param visible true if the annotation is visible at runtime. @return a visitor to visit the annotation values, or <tt>null</tt> if this visitor is not interested in visiting this annotation. <i>The annotation values must be visited before calling other methods on this annotation visitor</i>.\n*/"}
{"ID": 1630, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitNestMember(final String nestMember) { if (api < Opcodes.ASM7) { throw new UnsupportedOperationException(\"This feature requires ASM7\"); } if (cv != null) { cv.visitNestMember(nestMember); } } \nResponse:", "ground_truth": "Visits a member of the nest. A nest is a set of classes of the same package that share access\nto their private members. One of these classes, called the host, lists the other members of the\nnest, which in turn should link to the host of their nest. This method must be called only if\nthe visited class is the host of a nest. A nest host is implicitly a member of its own nest, so\nit's invalid to call this method with the visited class name as argument.\n\n@param nestMember the internal name of a nest member.", "predict": " Visits nest member. @param nestMember the nest member.\n*/"}
{"ID": 1631, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitInnerClass( final String name, final String outerName, final String innerName, final int access) { if (cv != null) { cv.visitInnerClass(name, outerName, innerName, access); } } \nResponse:", "ground_truth": "Visits information about an inner class. This inner class is not necessarily a member of the\nclass being visited.\n\n@param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@param outerName the internal name of the class to which the inner class belongs (see {@link\nType#getInternalName()}). May be {@literal null} for not member classes.\n@param innerName the (simple) name of the inner class inside its enclosing class. May be\n{@literal null} for anonymous inner classes.\n@param access the access flags of the inner class as originally declared in the enclosing\nclass.", "predict": " Visits an inner class. @param name the internal name of an inner class (see {@link Type#getInternalName() getInternalName}). @param outerName the internal name of the class to which the inner class belongs (see {@link Type#getInternalName() getInternalName}). May be <tt>null</tt> for not member classes. @param innerName the (simple) name of the inner class inside its enclosing class. May be <tt>null</tt> for anonymous inner classes. @param access the access flags of the inner class as originally declared in the enclosing class.\n"}
{"ID": 1632, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public FieldVisitor visitField( final int access, final String name, final String descriptor, final String signature, final Object value) { if (cv != null) { return cv.visitField(access, name, descriptor, signature, value); } return null; } \nResponse:", "ground_truth": "Visits a field of the class.\n\n@param access the field's access flags (see {@link Opcodes}). This parameter also indicates if\nthe field is synthetic and/or deprecated.\n@param name the field's name.\n@param descriptor the field's descriptor (see {@link Type}).\n@param signature the field's signature. May be {@literal null} if the field's type does not use\ngeneric types.\n@param value the field's initial value. This parameter, which may be {@literal null} if the\nfield does not have an initial value, must be an {@link Integer}, a {@link Float}, a {@link\nLong}, a {@link Double} or a {@link String} (for {@code int}, {@code float}, {@code long}\nor {@code String} fields respectively). <i>This parameter is only used for static\nfields</i>. Its value is ignored for non static fields, which must be initialized through\nbytecode instructions in constructors or methods.\n@return a visitor to visit field annotations and attributes, or {@literal null} if this class\nvisitor is not interested in visiting these annotations and attributes.", "predict": " Visit a field. @param access the field's access flags (see {@link Opcodes}). This parameter also indicates if the field is synthetic and/or deprecated. @param name the field's name. @param descriptor the field's descriptor (see {@link Type}). @param signature the field's signature. @param value the field's value. @return a visitor to visit field annotations and attributes, or <tt>null</tt> if this visitor is not interested in visiting these annotations and attributes. <i>The field's attributes are not visited when this method is called</i>. That should be done separately using the {@link #visitAttribute visitAttribute} method.\n"}
{"ID": 1633, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static DbThreadSession getThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session == null) { session = new DbThreadSession(); } return session; } \nResponse:", "ground_truth": "Returns existing thread session, or new one if already not exist. If session doesn't exist, it will be created\nusing default connection provider.", "predict": " Get the Thread Session. @return The Thread Session."}
{"ID": 1634, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void closeThreadSession() { DbThreadSession session = (DbThreadSession) ThreadDbSessionHolder.get(); if (session != null) { session.closeSession(); } } \nResponse:", "ground_truth": "Closes thread session.", "predict": " Close the thread session. Useful for closing the session when exiting a transactional method.\n*/"}
{"ID": 1635, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionWrapper[] createExecutionArray() { int totalInterceptors = (this.actionRuntime.getInterceptors() != null ? this.actionRuntime.getInterceptors().length : 0); int totalFilters = (this.actionRuntime.getFilters() != null ? this.actionRuntime.getFilters().length : 0); ActionWrapper[] executionArray = new ActionWrapper[totalFilters + 1 + totalInterceptors + 1]; // filters int index = 0; if (totalFilters > 0) { System.arraycopy(actionRuntime.getFilters(), 0, executionArray, index, totalFilters); index += totalFilters; } // result is executed AFTER the action AND interceptors executionArray[index++] = actionRequest -> { Object actionResult = actionRequest.invoke(); ActionRequest.this.madvocController.render(ActionRequest.this, actionResult); return actionResult; }; // interceptors if (totalInterceptors > 0) { System.arraycopy(actionRuntime.getInterceptors(), 0, executionArray, index, totalInterceptors); index += totalInterceptors; } // action executionArray[index] = actionRequest -> { actionResult = invokeActionMethod(); return actionResult; }; return executionArray; } \nResponse:", "ground_truth": "Creates execution array that will invoke all filters, actions and results\nin correct order.", "predict": " Creates an execution array. The first element is the action itself, followed by interceptors and filters. Interceptors are executed BEFORE filters. Filters are executed AFTER interceptors. @return execution array."}
{"ID": 1636, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object invokeActionMethod() throws Exception { if (actionRuntime.isActionHandlerDefined()) { actionRuntime.getActionHandler().handle(this); return null; } final Object[] params = targets.extractParametersValues(); try { return actionRuntime.getActionClassMethod().invoke(action, params); } catch(InvocationTargetException itex) { throw wrapToException(unwrapThrowable(itex)); } } \nResponse:", "ground_truth": "Invokes action method after starting all interceptors.\nAfter method invocation, all interceptors will finish, in opposite order.", "predict": " Invokes the action method. @return the result of the action method execution.\n*/"}
{"ID": 1637, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String readRequestBody() { if (requestBody == null) { try { requestBody = ServletUtil.readRequestBodyFromStream(getHttpServletRequest()); } catch (IOException ioex) { requestBody = StringPool.EMPTY; } } return requestBody; } \nResponse:", "ground_truth": "Reads request body only once and returns it to user.", "predict": " Reads the request body from the servlet request. @return the request body\n*/"}
{"ID": 1638, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int calcFirstItemIndexOfPage(int page, final int pageSize, final int total) { if (total == 0) { return 0; } if (page < 1) { page = 1; } int first = (page - 1) * pageSize; if (first >= total) { first = ((total - 1) / pageSize) * pageSize; // first item on the last page } return first; } \nResponse:", "ground_truth": "Calculates the first item index of requested page.", "predict": " Calculate the first item index of the page. @param page the page number. @param pageSize the page size. @param total the total count. @return the first item index of the page."}
{"ID": 1639, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int calcFirstItemIndexOfPage(final PageRequest pageRequest, final int total) { return calcFirstItemIndexOfPage(pageRequest.getPage(), pageRequest.getSize(), total); } \nResponse:", "ground_truth": "Calculates first item index of the page.", "predict": " Calculate the first item index of page. @param pageRequest the page request @param total the total @return the int\n*/"}
{"ID": 1640, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean match(final int value) { if (a == 0) { return value == b; } if (a > 0) { if (value < b) { return false; } return (value - b) % a == 0; } if (value > b) { return false; } return (b - value) % (-a) == 0; } \nResponse:", "ground_truth": "Matches expression with the value.", "predict": " Match the given value against the equation. @param value Value to match against. @return True if the equation matches the given value."}
{"ID": 1641, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] toRawByteArray(final char[] carr) { byte[] barr = new byte[carr.length << 1]; for (int i = 0, bpos = 0; i < carr.length; i++) { char c = carr[i]; barr[bpos++] = (byte) ((c & 0xFF00) >> 8); barr[bpos++] = (byte) (c & 0x00FF); } return barr; } \nResponse:", "ground_truth": "Converts char array into byte array by replacing each character with two bytes.", "predict": " Convert char array to byte array. @param carr char array @return byte array\n*/"}
{"ID": 1642, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findFirstDiff(final char[] source, final int index, final char[] match) { for (int i = index; i < source.length; i++) { if (!equalsOne(source[i], match)) { return i; } } return -1; } \nResponse:", "ground_truth": "Finds index of the first character in given array the differs from the\ngiven set of characters.\n\n@return index of matched character or -1", "predict": " Find the index of the first difference between two CharSequences, ignoring punctuation and whitespace. @param source the first CharSequence, may be null @param index the index to start searching from @param match the second CharSequence, may be null @return the index of the first difference found, -1 if no difference was found"}
{"ID": 1643, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveNodeName(final Node node) { switch (tagCase) { case DEFAULT: return node.getNodeName(); case RAW: return node.getNodeRawName(); case LOWERCASE: return node.getNodeRawName().toLowerCase(); case UPPERCASE: return node.getNodeRawName().toUpperCase(); } return null; } \nResponse:", "ground_truth": "Renders node name.", "predict": " Resolve the node name depending on the tagCase. @param node The node to resolve. @return The resolved node name."}
{"ID": 1644, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveAttributeName(final Node node, final Attribute attribute) { switch (attributeCase) { case DEFAULT: return attribute.getName(); case RAW: return attribute.getRawName(); case LOWERCASE: return attribute.getRawName().toLowerCase(); case UPPERCASE: return attribute.getRawName().toUpperCase(); } return null; } \nResponse:", "ground_truth": "Renders attribute name.", "predict": " Resolve the attribute name. @param node the node @param attribute the attribute @return the attribute name\n*/"}
{"ID": 1645, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void renderAttribute(final Node node, final Attribute attribute, final Appendable appendable) throws IOException { String name = resolveAttributeName(node, attribute); String value = attribute.getValue(); appendable.append(name); if (value != null) { appendable.append('='); appendable.append('\\\"'); appendable.append(HtmlEncoder.attributeDoubleQuoted(value)); appendable.append('\\\"'); } } \nResponse:", "ground_truth": "Renders attribute.", "predict": " Render the given attribute. @param node the node @param attribute the attribute @param appendable the appendable output @throws IOException Signals a formatting problem\n*/"}
{"ID": 1646, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final File file) throws IOException { final String extension = FileNameUtil.getExtension(file.getAbsolutePath()); final String data; if (extension.equalsIgnoreCase(\"properties\")) { data = FileUtil.readString(file, StringPool.ISO_8859_1); } else { data = FileUtil.readString(file); } parse(data); return this; } \nResponse:", "ground_truth": "Loads props from the file. Assumes UTF8 encoding unless\nthe file ends with '.properties', than it uses ISO 8859-1.", "predict": " Loads the properties from the given file. @param file the file to load from. @return this props instance.\n* @throws IOException if an error occurs whilst reading the file.\n*/"}
{"ID": 1647, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final File file, final String encoding) throws IOException { parse(FileUtil.readString(file, encoding)); return this; } \nResponse:", "ground_truth": "Loads properties from the file in provided encoding.", "predict": " Loads the properties from the given file. @param file The file to load from. @param encoding The encoding to use. @return The Props. Never null. May be empty. @throws IOException If there was an error loading the properties.\n*/"}
{"ID": 1648, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final InputStream in) throws IOException { final Writer out = new FastCharArrayWriter(); StreamUtil.copy(in, out); parse(out.toString()); return this; } \nResponse:", "ground_truth": "Loads properties from input stream. Stream is not closed at the end.", "predict": " Loads the props from the input stream. @param in the input stream to load from @return the props that were loaded\n */"}
{"ID": 1649, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props load(final Map<?, ?> p) { for (final Map.Entry<?, ?> entry : p.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(name, value.toString(), false); } return this; } \nResponse:", "ground_truth": "Loads base properties from the provided java properties.\nNull values are ignored.", "predict": " Load properties from a map. @param p Map of properties to load. @return this\n*/"}
{"ID": 1650, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Props load(final Map<?, ?> map, final String prefix) { String realPrefix = prefix; realPrefix += '.'; for (final Map.Entry entry : map.entrySet()) { final String name = entry.getKey().toString(); final Object value = entry.getValue(); if (value == null) { continue; } data.putBaseProperty(realPrefix + name, value.toString(), false); } return this; } \nResponse:", "ground_truth": "Loads base properties from java Map using provided prefix.\nNull values are ignored.", "predict": " Loads properties from a map. @param map Map to load from @param prefix Prefix to prepend to each property name @return this\n */"}
{"ID": 1651, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Props loadFromClasspath(final String... patterns) { ClassScanner.create() .registerEntryConsumer(entryData -> { String usedEncoding = JoddCore.encoding; if (StringUtil.endsWithIgnoreCase(entryData.name(), \".properties\")) { usedEncoding = StringPool.ISO_8859_1; } final String encoding = usedEncoding; UncheckedException.runAndWrapException(() -> load(entryData.openInputStream(), encoding)); }) .includeResources(true) .ignoreException(true) .excludeCommonJars() .excludeAllEntries(true) .includeEntries(patterns) .scanDefaultClasspath() .start(); return this; } \nResponse:", "ground_truth": "Loads props and properties from the classpath.", "predict": " Scans classpath for files matching patterns and loads them into memory. Patterns can contain Ant-style wildcards, such as *.*.txt. Moreover, you can exclude files by providing patterns, too. Moreover, you can exclude common jars by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude all entries by providing patterns, too. Moreover, you can exclude"}
{"ID": 1652, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String getValueOrDefault(final String key, final String defaultValue) { initialize(); final String value = data.lookupValue(key, activeProfiles); if (value == null) { return defaultValue; } return value; } \nResponse:", "ground_truth": "Returns value of property, using active profiles or default value if not found.", "predict": " Looks up a value from the underlying data source. If the value is not present, the default value is returned. @param key The key to lookup. @param defaultValue The default value to return if the lookup fails. @return The value from the underlying data source. If the value is not present, the default value is returned."}
{"ID": 1653, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setValue(final String key, final String value, final String profile) { if (profile == null) { data.putBaseProperty(key, value, false); } else { data.putProfileProperty(key, value, profile, false); } initialized = false; } \nResponse:", "ground_truth": "Sets value on some profile.", "predict": " Set the value for the given key in the given profile. If no profile is given, the value is set in the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the general profile. Setting the value in the general profile will trigger a save of the"}
{"ID": 1654, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractProps(final Map target) { initialize(); data.extract(target, activeProfiles, null, null); } \nResponse:", "ground_truth": "Extracts props belonging to active profiles.", "predict": " Extracts all the properties from the underlying datasource into the supplied target map. @param target The map to populate."}
{"ID": 1655, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractProps(final Map target, final String... profiles) { initialize(); data.extract(target, profiles, null, null); } \nResponse:", "ground_truth": "Extract props of given profiles.", "predict": " Extracts the properties from the profiles. @param target The target map. @param profiles The profiles."}
{"ID": 1656, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void extractSubProps(final Map target, final String... wildcardPatterns) { initialize(); data.extract(target, activeProfiles, wildcardPatterns, null); } \nResponse:", "ground_truth": "Extracts subset of properties that matches given wildcards.", "predict": " Extract sub-properties from the active profiles. @param target The target map. @param wildcardPatterns The wildcard patterns."}
{"ID": 1657, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public Map<String, Object> innerMap(final String prefix) { initialize(); return data.extract(null, activeProfiles, null, prefix); } \nResponse:", "ground_truth": "Returns inner map from the props with given prefix. Keys in returned map\nwill not have the prefix.", "predict": " Extracts the map from the underlying data structure. Useful if you want to perform further calculations on it outside of Thymeleaf. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful for manipulating forms submitted via AJAX. Useful"}
{"ID": 1658, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void addInnerMap(String prefix, final Map<?, ?> map, final String profile) { if (!StringUtil.endsWithChar(prefix, '.')) { prefix += StringPool.DOT; } for (Map.Entry<?, ?> entry : map.entrySet()) { String key = entry.getKey().toString(); key = prefix + key; setValue(key, entry.getValue().toString(), profile); } } \nResponse:", "ground_truth": "Adds child map to the props on given prefix.", "predict": " Add inner map. @param prefix the prefix @param map the map @param profile the profile\n*/"}
{"ID": 1659, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void resolveActiveProfiles() { if (activeProfilesProp == null) { activeProfiles = null; return; } final PropsEntry pv = data.getBaseProperty(activeProfilesProp); if (pv == null) { // no active profile set as the property, exit return; } final String value = pv.getValue(); if (StringUtil.isBlank(value)) { activeProfiles = null; return; } activeProfiles = StringUtil.splitc(value, ','); StringUtil.trimAll(activeProfiles); } \nResponse:", "ground_truth": "Resolves active profiles from special property.\nThis property can be only a base property!\nIf default active property is not defined, nothing happens.\nOtherwise, it will replace currently active profiles.", "predict": " Resolve active profiles from the property.\n"}
{"ID": 1660, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getAllProfiles() { String[] profiles = new String[data.profileProperties.size()]; int index = 0; for (String profileName : data.profileProperties.keySet()) { profiles[index] = profileName; index++; } return profiles; } \nResponse:", "ground_truth": "Returns all profiles names.", "predict": " Returns all profiles. @return Profiles."}
{"ID": 1661, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] getProfilesFor(final String propKeyNameWildcard) { HashSet<String> profiles = new HashSet<>(); profile: for (Map.Entry<String, Map<String, PropsEntry>> entries : data.profileProperties.entrySet()) { String profileName = entries.getKey(); Map<String, PropsEntry> value = entries.getValue(); for (String propKeyName : value.keySet()) { if (Wildcard.equalsOrMatch(propKeyName, propKeyNameWildcard)) { profiles.add(profileName); continue profile; } } } return profiles.toArray(new String[0]); } \nResponse:", "ground_truth": "Returns all the profiles that define certain prop's key name.\nKey name is given as a wildcard, or it can be matched fully.", "predict": " Get all profiles that contain the given wildcard key name. @param propKeyNameWildcard Wildcard key name to match. @return Profiles that contain the given wildcard key name. Empty array if none found.\n*/"}
{"ID": 1662, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addPropertyInjectionPoint(final PropertyInjectionPoint pip) { if (properties == null) { properties = new PropertyInjectionPoint[1]; properties[0] = pip; } else { properties = ArraysUtil.append(properties, pip); } } \nResponse:", "ground_truth": "Adds property injection point.", "predict": " Add a Property injection point. @param pip The property injection point to add.\n*/"}
{"ID": 1663, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addSetInjectionPoint(final SetInjectionPoint sip) { if (sets == null) { sets = new SetInjectionPoint[1]; sets[0] = sip; } else { sets = ArraysUtil.append(sets, sip); } } \nResponse:", "ground_truth": "Adds set injection point.", "predict": " Add a set injection point. @param sip The sip to add.\n*/"}
{"ID": 1664, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addMethodInjectionPoint(final MethodInjectionPoint mip) { if (methods == null) { methods = new MethodInjectionPoint[1]; methods[0] = mip; } else { methods = ArraysUtil.append(methods, mip); } } \nResponse:", "ground_truth": "Adds method injection point.", "predict": " Add a new MethodInjectionPoint to this interceptor. Interceptors can declare several MethodInjectionPoints. They are evaluated sequentially when determining how to weave advice around a method. Therefore, interceptors should declare their Candidates BEFORE advice is woven around methods. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Interceptor. Therefore, advice weaving begins with the first advice declared in the Intercept"}
{"ID": 1665, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addInitMethodPoints(final InitMethodPoint[] methods) { if (initMethods == null) { initMethods = methods; } else { initMethods = ArraysUtil.join(initMethods, methods); } } \nResponse:", "ground_truth": "Adds init methods.", "predict": " Add init method points. @param methods the methods\n*/"}
{"ID": 1666, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void addDestroyMethodPoints(final DestroyMethodPoint[] methods) { if (destroyMethods == null) { destroyMethods = methods; } else { destroyMethods = ArraysUtil.join(destroyMethods, methods); } } \nResponse:", "ground_truth": "Adds destroy methods.", "predict": " Add destroy method points. @param methods Destroy method points."}
{"ID": 1667, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class resolveTargetClass(final Class proxy) { final String name = proxy.getName(); if (name.endsWith(ProxettaNames.proxyClassNameSuffix)) { return proxy.getSuperclass(); } if (name.endsWith(ProxettaNames.wrapperClassNameSuffix)) { return getTargetWrapperType(proxy); } return proxy; } \nResponse:", "ground_truth": "Returns target class if proxetta applied on given class.\nIf not, returns given class as result.", "predict": " Resolve target class. @param proxy Proxy class. @return Target class."}
{"ID": 1668, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void injectTargetIntoWrapper(final Object target, final Object wrapper) { injectTargetIntoWrapper(target, wrapper, ProxettaNames.wrapperTargetFieldName); } \nResponse:", "ground_truth": "Injects target instance into proxy using default target field name.\n@see #injectTargetIntoWrapper(Object, Object, String)", "predict": " Inject target into wrapper. @param target Target. @param wrapper Wrapper."}
{"ID": 1669, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Class getTargetWrapperType(final Class wrapperClass) { try { final Field field = wrapperClass.getDeclaredField(ProxettaNames.wrapperTargetFieldName); return field.getType(); } catch (NoSuchFieldException nsfex) { throw new ProxettaException(nsfex); } } \nResponse:", "ground_truth": "Returns wrapper target type.", "predict": " Get the target type of the wrapper. Useful for casting. @param wrapperClass Wrapper class. @return Target type of the wrapper. Never null. @since 1.2.1"}
{"ID": 1670, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected FieldDescriptor findField(final String fieldName) { FieldDescriptor fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } // field descriptor not found in this class // try to locate it in the superclasses Class[] superclasses = classDescriptor.getAllSuperclasses(); for (Class superclass : superclasses) { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(superclass); fieldDescriptor = classDescriptor.getFieldDescriptor(fieldName, true); if (fieldDescriptor != null) { return fieldDescriptor; } } // nothing found return null; } \nResponse:", "ground_truth": "Locates property field. Field is being searched also in all\nsuperclasses of current class.", "predict": " Finds a field descriptor by searching upwards through all superclasses looking for a field matching the given name. Searches upwards including interfaces and superclasses. Returns null if nothing was found."}
{"ID": 1671, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class getType() { if (type == null) { if (fieldDescriptor != null) { type = fieldDescriptor.getRawType(); } else if (readMethodDescriptor != null) { type = getGetter(true).getGetterRawType(); //type = readMethodDescriptor.getGetterRawType(); } else if (writeMethodDescriptor != null) { type = getSetter(true).getSetterRawType(); //type = writeMethodDescriptor.getSetterRawType(); } } return type; } \nResponse:", "ground_truth": "Returns property type. Raw types are detected.", "predict": " Returns the generic type of the field or method. @return the generic type of the field or method\n*/"}
{"ID": 1672, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class resolveKeyType(final boolean declared) { Class keyType = null; Getter getter = getGetter(declared); if (getter != null) { keyType = getter.getGetterRawKeyComponentType(); } if (keyType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { keyType = fieldDescriptor.getRawKeyComponentType(); } } return keyType; } \nResponse:", "ground_truth": "Resolves key type for given property descriptor.", "predict": " Resolve the key type. @param declared the declaring flag @return the key type\n*/"}
{"ID": 1673, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class resolveComponentType(final boolean declared) { Class componentType = null; Getter getter = getGetter(declared); if (getter != null) { componentType = getter.getGetterRawComponentType(); } if (componentType == null) { FieldDescriptor fieldDescriptor = getFieldDescriptor(); if (fieldDescriptor != null) { componentType = fieldDescriptor.getRawComponentType(); } } return componentType; } \nResponse:", "ground_truth": "Resolves component type for given property descriptor.", "predict": " Resolve the component type of the field or getter. @param declared whether the field or getter is declared or not. @return the resolved component type.\n*/"}
{"ID": 1674, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonResult of(final Object object) { final String json = JsonSerializer.create().deep(true).serialize(object); return new JsonResult(json); } \nResponse:", "ground_truth": "Creates JSON result from given object. The object will be serialized to JSON.", "predict": " Static factory method to easily create a successful JsonResult with a JSON payload. @param object The object to serialize into JSON. @return A successful {@link JsonResult} carrying the serialized object."}
{"ID": 1675, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static JsonResult of(final Exception exception) { final HashMap<String, Object> errorMap = new HashMap<>(); errorMap.put(\"message\", ExceptionUtil.message(exception)); errorMap.put(\"error\", exception.getClass().getName()); errorMap.put(\"cause\", exception.getCause() != null ? exception.getCause().getClass().getName() : null); final ArrayList<String> details = new ArrayList<>(); final StackTraceElement[] ste = ExceptionUtil.getStackTrace(exception, null, null); for (StackTraceElement stackTraceElement : ste) { details.add(stackTraceElement.toString()); } errorMap.put(\"details\", details); final String json = JsonSerializer.create().deep(true).serialize(errorMap); return new JsonResult(json).status(HttpStatus.error500().internalError()); } \nResponse:", "ground_truth": "Creates a JSON response from an exception. Response body will have information about the\nexception and response status will be set to 500.", "predict": " Static factory method to easily create a 500 error. @param exception The exception to wrap. @return The 500 error."}
{"ID": 1676, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveHttpMethodFromMethodName(final String methodName) { int i = 0; while (i < methodName.length()) { if (CharUtil.isUppercaseAlpha(methodName.charAt(i))) { break; } i++; } final String name = methodName.substring(0, i).toUpperCase(); for (final HttpMethod httpMethod : HttpMethod.values()) { if (httpMethod.equalsName(name)) { return httpMethod.name(); } } return null; } \nResponse:", "ground_truth": "Resolves HTTP method name from method name.\nIf method name or first camel-case word of a method equals to\na HTTP method, it will be used as that HTTP methods.", "predict": " Resolve HTTP method from method name. @param methodName the method name @return the HTTP method"}
{"ID": 1677, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static boolean match(final CharSequence string, final CharSequence pattern, int sNdx, int pNdx) { int pLen = pattern.length(); if (pLen == 1) { if (pattern.charAt(0) == '*') { // speed-up return true; } } int sLen = string.length(); boolean nextIsNotWildcard = false; while (true) { // check if end of string and/or pattern occurred if ((sNdx >= sLen)) { // end of string still may have pending '*' in pattern while ((pNdx < pLen) && (pattern.charAt(pNdx) == '*')) { pNdx++; } return pNdx >= pLen; } if (pNdx >= pLen) { // end of pattern, but not end of the string return false; } char p = pattern.charAt(pNdx); // pattern char // perform logic if (!nextIsNotWildcard) { if (p == '\\\\') { pNdx++; nextIsNotWildcard = true; continue; } if (p == '?') { sNdx++; pNdx++; continue; } if (p == '*') { char pNext = 0; // next pattern char if (pNdx + 1 < pLen) { pNext = pattern.charAt(pNdx + 1); } if (pNext == '*') { // double '*' have the same effect as one '*' pNdx++; continue; } int i; pNdx++; // find recursively if there is any substring from the end of the // line that matches the rest of the pattern !!! for (i = string.length(); i >= sNdx; i--) { if (match(string, pattern, i, pNdx)) { return true; } } return false; } } else { nextIsNotWildcard = false; } // check if pattern char and string char are equals if (p != string.charAt(sNdx)) { return false; } // everything matches for now, continue sNdx++; pNdx++; } } \nResponse:", "ground_truth": "Internal matching recursive function.", "predict": " Checks if there is any substring from the end of the line that matches the rest of the pattern.\n@param string the string to analyze\n@param pattern the pattern to analyze\n@param sNdx start index into string\n@param pNdx start index into pattern\n@return true if there is any substring from the end of the line that matches the rest of the pattern\n*/"}
{"ID": 1678, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Loading resolveLoading(final boolean parentFirstStrategy, final String className) { boolean withParent = true; boolean withLoader = true; if (parentFirstStrategy) { if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } else if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } } else { if (isMatchingRules(className, parentOnlyRules)) { withLoader = false; } else if (isMatchingRules(className, loaderOnlyRules)) { withParent = false; } } return new Loading(withParent, withLoader); } \nResponse:", "ground_truth": "Resolves loading rules.", "predict": " Resolves the loading strategy for the given class name. @param parentFirstStrategy if true, considers the parent first, otherwise considers the loader first. @param className the class name to analyze. @return the loading strategy. Never null."}
{"ID": 1679, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Loading resolveResourceLoading(final boolean parentFirstStrategy, String resourceName) { if (matchResourcesAsPackages) { resourceName = StringUtil.replaceChar(resourceName, '/', '.'); } return resolveLoading(parentFirstStrategy, resourceName); } \nResponse:", "ground_truth": "Resolves resources.", "predict": " Resolve the resource loading strategy. @param parentFirstStrategy the parent first strategy @param resourceName the resource name @return the loading strategy\n*/"}
{"ID": 1680, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException { // check first if the class has already been loaded Class<?> c = findLoadedClass(className); if (c != null) { if (resolve) { resolveClass(c); } return c; } // class not loaded yet Loading loading = resolveLoading(parentFirst, className); if (parentFirst) { // PARENT FIRST if (loading.withParent) { try { c = parentClassLoader.loadClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withLoader) { c = this.findClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } else { // THIS FIRST if (loading.withLoader) { try { c = this.findClass(className); } catch (ClassNotFoundException ignore) { } } if (c == null) { if (loading.withParent) { c = parentClassLoader.loadClass(className); } else { throw new ClassNotFoundException(\"Class not found: \" + className); } } } if (resolve) { resolveClass(c); } return c; } \nResponse:", "ground_truth": "Loads class using parent-first or parent-last strategy.", "predict": " Loads a class using the delegation model. @param className the name of the class to be loaded. @param resolve indicates whether the class should be resolved. @return the loaded class. @throws ClassNotFoundException if the class could not be found.\n*/\nprotected synchronized Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException {\n\tClass<?> c = findLoadedClass(className);\n\tif (c == null) {\n\t\tLoading loading = resolveLoading(parentFirst, className);\n\t\tif (parentFirst) {\n\t\t\tif (loading.withParent) {\n\t\t\t\tc = parentClassLoader.loadClass(className);\n\t\t\t} else {\n\t\t\t\tthrow new ClassNotFoundException(\"Class not found: \" + className);\n\t\t\t}\n\t\t} else {\n\t\t\tif (loading.withLoader) {\n\t\t\t\tc = this.findClass(className);\n\t\t\t} else {\n\t\t\t\tthrow new ClassNotFoundException"}
{"ID": 1681, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public URL getResource(final String resourceName) { URL url = null; Loading loading = resolveResourceLoading(parentFirst, resourceName); if (parentFirst) { // PARENT FIRST if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } if (url == null) { if (loading.withLoader) { url = this.findResource(resourceName); } } } else { // THIS FIRST if (loading.withLoader) { url = this.findResource(resourceName); } if (url == null) { if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } } } return url; } \nResponse:", "ground_truth": "Returns a resource using parent-first or parent-last strategy.", "predict": " Get the resource with the specified name. First search in this classloader, then its parents. @param resourceName The name of the resource to load. @return The URL to the resource or null if the resource wasn't found.\n*/\npublic URL getResource(final String resourceName) {\n\tURL url = null;\n\tLoading loading = resolveResourceLoading(parentFirst, resourceName);\n\tif (parentFirst) { // PARENT FIRST if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } if (url == null) { if (loading.withLoader) { url = this.findResource(resourceName); } } } else { // THIS FIRST if (loading.withLoader) { url = this.findResource(resourceName); } if (url == null) { if (loading.withParent) { url = parentClassLoader.getResource(resourceName); } } } return url;\n}\n\n/**\n * Get the resources with the specified name."}
{"ID": 1682, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void waitFor() { try { synchronized (lock) { if (!end) { lock.wait(); } } } catch (InterruptedException ignore) { Thread.currentThread().interrupt(); } } \nResponse:", "ground_truth": "Waits for gobbler to end.", "predict": " Wait until the end of the simulation.\n*/"}
{"ID": 1683, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Class<? extends Annotation> detectAnnotationType(final Annotation[] annotations) { for (final Annotation annotation : annotations) { if (annotation instanceof In) { return annotation.annotationType(); } else if (annotation instanceof Out) { return annotation.annotationType(); } } return null; } \nResponse:", "ground_truth": "Scans annotation and returns type of Madvoc annotations.", "predict": " Detects the annotation type for the given annotations. @param annotations Annotations to inspect. @return Detected annotation type or null if none was found."}
{"ID": 1684, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected InjectionPoint buildInjectionPoint( final String annotationValue, final String propertyName, final Class propertyType, final Class<? extends MadvocScope> scope) { final String value = annotationValue.trim(); final String name, targetName; if (StringUtil.isNotBlank(value)) { name = value; targetName = propertyName; } else { name = propertyName; targetName = null; } return new InjectionPoint(propertyType, name, targetName, scopeResolver.defaultOrScopeType(scope)); } \nResponse:", "ground_truth": "Builds injection point.", "predict": " Build injection point from annotation value. @param annotationValue The annotation value. @param propertyName The property name. @param propertyType The property type. @param scope The Madvoc scope. @return Madvoc injection point. Never null."}
{"ID": 1685, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visit() { ClassDescriptor classDescriptor = ClassIntrospector.get().lookup(type); if (classMetadataName != null) { // process first 'meta' fields 'class' onProperty(classMetadataName, null, false); } PropertyDescriptor[] propertyDescriptors = classDescriptor.getAllPropertyDescriptors(); for (PropertyDescriptor propertyDescriptor : propertyDescriptors) { Getter getter = propertyDescriptor.getGetter(declared); if (getter != null) { String propertyName = propertyDescriptor.getName(); boolean isTransient = false; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor.getFieldDescriptor(); if (fieldDescriptor != null) { isTransient = Modifier.isTransient(fieldDescriptor.getField().getModifiers()); } onProperty(propertyName, propertyDescriptor, isTransient); } } } \nResponse:", "ground_truth": "Visits a type.", "predict": " Introspects the bean type and gathers all the information about the exposed properties.\n*/"}
{"ID": 1686, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static URL[] of(ClassLoader classLoader, Class clazz) { if (clazz == null) { clazz = ClassPathURLs.class; } if (classLoader == null) { classLoader = clazz.getClassLoader(); } final Set<URL> urls = new LinkedHashSet<>(); while (classLoader != null) { if (classLoader instanceof URLClassLoader) { final URLClassLoader urlClassLoader = (URLClassLoader) classLoader; return urlClassLoader.getURLs(); } final URL url = classModuleUrl(classLoader, clazz); if (url != null) { urls.add(url); } classLoader = classLoader.getParent(); } return urls.toArray(new URL[0]); } \nResponse:", "ground_truth": "Returns urls for the classloader\n\n@param classLoader classloader in which to find urls\n@return list of urls or {@code null} if not found", "predict": " Discover all URLs of the given class loader. @param classLoader the class loader to discover its URLs. Shall not be <code>null</code>. @param clazz the class to discover its own URLs. Shall not be <code>null</code>. @return the discovered URLs. Shall not be empty. Shall not be <code>null</code>. Shall contain at least one URL. Shall not be an instance of URLClassLoader. Shall not be an instance of URLStreamHandlerClassLoader. Shall not be an instance of URLClassLoader. Shall not be an instance of URLStreamHandlerBootstrapClassLoader. Shall not be an instance of URLClassLoader. Shall not be an instance of URLStreamHandlerFileSystemClassLoader. Shall not be an instance of URLStreamHandlerJarFileClassLoader. Shall not be an instance of URLStreamHandlerJarHandlerClassLoader. Shall not be an instance of URLStreamHandlerJarHandlerCacheClassLoader. Shall not be an instance of URLStreamHandlerJarHandlerCacheURLClassLoader. Shall not be an instance of"}
{"ID": 1687, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setBean(final Object bean) { this.bean = bean; this.cd = (bean == null ? null : introspector.lookup(bean.getClass())); this.first = false; this.updateProperty = true; } \nResponse:", "ground_truth": "Sets new bean instance.", "predict": " Sets the bean to introspect.\n@param bean The bean to introspect.\n*/"}
{"ID": 1688, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void updateBean(final Object bean) { this.setBean(bean); if (this.cd != null && this.cd.isSupplier()) { final Object newBean = ((Supplier)this.bean).get(); setBean(newBean); } } \nResponse:", "ground_truth": "Updates the bean. Detects special case of suppliers.", "predict": " Updates the bean in the binding. This is typically done by replacing the old bean with the new one. However, suppliers are special beasts, they need to be dealt with differently. Suppliers are essentially specialised beans, so they need to be rebound. Therefore, they need to be treated differently than ordinary beans. Therefore, this method takes care of rebinding suppliers. @param bean The new bean to replace the old one with."}
{"ID": 1689, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void loadPropertyDescriptor() { if (updateProperty) { if (cd == null) { propertyDescriptor = null; } else { propertyDescriptor = cd.getPropertyDescriptor(name, true); } updateProperty = false; } } \nResponse:", "ground_truth": "Loads property descriptor, if property was updated.", "predict": " Load the PropertyDescriptor for this bean. This method is called when the bean is first created. It also gets called whenever someone asks for the property descriptor for this bean. Therefore, it would be advisable to optimize this method considerably. Ideally, we would just cache the information somewhere rather than regenerate it every time someone asks for it. However, we aren't caching because we aren't sure how frequently people will ask for the property descriptors. Furthermore, caching introduces more complexity because someone who wants the property descriptor for day might not want it tomorrow when things have changed. Therefore, people shouldn't rely on caching much. However, caching could still be useful because people who frequently ask for beans with certain properties should tend to ask for those properties sooner rather than later. Furthermore, caching could alleviate memory leaks because people tend to forget to release references to their objects. However, caching introduces more complexity because people who frequently ask for beans with certain properties should tend to ask for those properties sooner rather than later. Therefore, caching should probably only be used sparingly. However, caching could"}
{"ID": 1690, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Getter getGetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getGetter(declared) : null; } \nResponse:", "ground_truth": "Returns getter.", "predict": " Get the getter for the property. If the property is not readable, then null is returned. @param declared If the getter is declared or not. If the getter is not declared, then a getter is searched for in superclasses. @return The getter for the property. If the property is not readable, then null is returned."}
{"ID": 1691, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Setter getSetter(final boolean declared) { loadPropertyDescriptor(); return propertyDescriptor != null ? propertyDescriptor.getSetter(declared) : null; } \nResponse:", "ground_truth": "Returns setter.", "predict": " Returns the setter for the property. If the property is not readable, then null is returned. If the property is declared, but not readable, then a settable but unreadable property is returned. If the property is neither readable nor declared, then a settable but undefined property is returned. @param declared If the getter is declared or not. @return The setter for the property. Never null. May be undefined."}
{"ID": 1692, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DbOom connect() { connectionProvider.init(); final DbDetector dbDetector = new DbDetector(); dbDetector.detectDatabaseAndConfigureDbOom(connectionProvider, dbOomConfig); return this; } \nResponse:", "ground_truth": "Initializes the DbOom by connecting to the database. Database will be detected\nand DbOom will be configured to match it.", "predict": " Open connection to database. Automatically detects database dialect and configures DbOom accordingly. @return this DbOom facade instance\n*/"}
{"ID": 1693, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(final Iterator<T> iterator) { if (allIterators.contains(iterator)) { throw new IllegalArgumentException(\"Duplicate iterator\"); } allIterators.add(iterator); } \nResponse:", "ground_truth": "Adds an iterator to this composite.", "predict": " Add an iterator to the pool. Duplicate iterators are not permitted. @param iterator The iterator to add.\n*/"}
{"ID": 1694, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void printLogo() { System.out.println(Chalk256.chalk().yellow().on(Jodd.JODD)); } \nResponse:", "ground_truth": "Prints a logo.", "predict": " Prints logo."}
{"ID": 1695, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stop() { joyProps.stop(); try { joyDb.stop(); joyPetite.stop(); } catch (Exception ignore) { } if (log != null) { log.info(\"Joy is down. Bye, bye!\"); } } \nResponse:", "ground_truth": "Stops the Joy.", "predict": " Gracefully shuts down Joy. Joy will shut down automatically when Petite shuts down.\n*/"}
{"ID": 1696, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Socket createSocket(final String host, final int port, final int connectionTimeout) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, false, false, connectionTimeout); if (connectionTimeout < 0) { return socketFactory.createSocket(host, port); } else { // creates unconnected socket Socket socket = socketFactory.createSocket(); socket.connect(new InetSocketAddress(host, port), connectionTimeout); return socket; } } \nResponse:", "ground_truth": "Creates a socket using socket factory.", "predict": " Creates a socket connection to the given host and port. The socket connection will be established within the given timeout. @param host The host to connect to. @param port The port to connect to. @param connectionTimeout The connection timeout in milliseconds. Negative values lead to wait forever. @return The socket connection. @throws IOException If the socket connection could not be established.\n*/"}
{"ID": 1697, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SSLSocket createSSLSocket( final String host, final int port, final int connectionTimeout, final boolean trustAll, final boolean verifyHttpsHost) throws IOException { final SocketFactory socketFactory = getSocketFactory(proxy, true, trustAll, connectionTimeout); final Socket socket; if (connectionTimeout < 0) { socket = socketFactory.createSocket(host, port); } else { // creates unconnected socket // unfortunately, this does not work always // sslSocket = (SSLSocket) socketFactory.createSocket(); // sslSocket.connect(new InetSocketAddress(host, port), connectionTimeout); // // Note: SSLSocketFactory has several create() methods. // Those that take arguments all connect immediately // and have no options for specifying a connection timeout. // // So, we have to create a socket and connect it (with a // connection timeout), then have the SSLSocketFactory wrap // the already-connected socket. // socket = Sockets.connect(host, port, connectionTimeout); //sock.setSoTimeout(readTimeout); //socket.connect(new InetSocketAddress(host, port), connectionTimeout); // continue to wrap this plain socket with ssl socket... } // wrap plain socket in an SSL socket SSLSocket sslSocket; if (socket instanceof SSLSocket) { sslSocket = (SSLSocket) socket; } else { if (socketFactory instanceof SSLSocketFactory) { sslSocket = (SSLSocket) ((SSLSocketFactory)socketFactory).createSocket(socket, host, port, true); } else { sslSocket = (SSLSocket) (getDefaultSSLSocketFactory(trustAll)).createSocket(socket, host, port, true); } } // sslSocket is now ready if (secureEnabledProtocols != null) { final String[] values = StringUtil.splitc(secureEnabledProtocols, ','); StringUtil.trimAll(values); sslSocket.setEnabledProtocols(values); } // set SSL parameters to allow host name verifier if (verifyHttpsHost) { final SSLParameters sslParams = new SSLParameters(); sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\"); sslSocket.setSSLParameters(sslParams); } return sslSocket; } \nResponse:", "ground_truth": "Creates a SSL socket. Enables default secure enabled protocols if specified.", "predict": " Creates a SSLSocketFactory with the TrustManager that trusts everything. This is intended for unusual situations, such as when connecting to an upstream proxy over HTTPS. Trusting all certificates minimizes the impact of malicious actors attempting to intercept traffic. However, it is still vulnerable to man-in-the-middle attacks, so it should not be used indiscriminately."}
{"ID": 1698, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SSLSocketFactory getDefaultSSLSocketFactory(final boolean trustAllCertificates) throws IOException { if (trustAllCertificates) { try { SSLContext sc = SSLContext.getInstance(sslProtocol); sc.init(null, TrustManagers.TRUST_ALL_CERTS, new java.security.SecureRandom()); return sc.getSocketFactory(); } catch (NoSuchAlgorithmException | KeyManagementException e) { throw new IOException(e); } } else { return (SSLSocketFactory) SSLSocketFactory.getDefault(); } } \nResponse:", "ground_truth": "Returns default SSL socket factory allowing setting trust managers.", "predict": " Get the default SSLSocketFactory. Trust all certificates by default. @param trustAllCertificates Trust all certificates? @return SSLSocketFactory @throws IOException Signals that an I/O exception has occurred."}
{"ID": 1699, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected SocketFactory getSocketFactory( final ProxyInfo proxy, final boolean ssl, final boolean trustAllCertificates, final int connectionTimeout) throws IOException { switch (proxy.getProxyType()) { case NONE: if (ssl) { return getDefaultSSLSocketFactory(trustAllCertificates); } else { return SocketFactory.getDefault(); } case HTTP: return new HTTPProxySocketFactory(proxy, connectionTimeout); case SOCKS4: return new Socks4ProxySocketFactory(proxy, connectionTimeout); case SOCKS5: return new Socks5ProxySocketFactory(proxy, connectionTimeout); default: return null; } } \nResponse:", "ground_truth": "Returns socket factory based on proxy type and SSL requirements.", "predict": " Get socket factory for proxy. @param proxy ProxyInfo ProxyInfo ProxyInfo @param ssl SSL socket factory @param trustAllCertificates Trust all certificates flag @param connectionTimeout Socket connection timeout in milliseconds @return SocketFactory @throws IOException IOException\n*/"}
{"ID": 1700, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String random(int count, final char[] chars) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; while (count-- > 0) { result[count] = chars[rnd.nextInt(chars.length)]; } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the set of characters specified.", "predict": " Pseudo randomly generates a string of the specified length, consisting entirely of the specified characters. @param count the length of the string to generate @param chars the characters to use in the string @return the random string\n*/"}
{"ID": 1701, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String random(int count, final char start, final char end) { if (count == 0) { return StringPool.EMPTY; } final char[] result = new char[count]; final int len = end - start + 1; while (count-- > 0) { result[count] = (char) (rnd.nextInt(len) + start); } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the provided range.", "predict": " Generates a random string of the specified length containing characters from the specified range. @param count the length of random string to generate. @param start the starting character of the random string. @param end the ending character of the random string. @return the random string."}
{"ID": 1702, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String randomRanges(int count, final char... ranges) { if (count == 0) { return StringPool.EMPTY; } int i = 0; int len = 0; final int[] lens = new int[ranges.length]; while (i < ranges.length) { int gap = ranges[i + 1] - ranges[i] + 1; len += gap; lens[i] = len; i += 2; } final char[] result = new char[count]; while (count-- > 0) { char c = 0; int r = rnd.nextInt(len); for (i = 0; i < ranges.length; i += 2) { if (r < lens[i]) { r += ranges[i]; if (i != 0) { r -= lens[i - 2]; } c = (char) r; break; } } result[count] = c; } return new String(result); } \nResponse:", "ground_truth": "Creates random string whose length is the number of characters specified.\nCharacters are chosen from the multiple sets defined by range pairs.\nAll ranges must be in acceding order.", "predict": " Generates random strings based on the given ranges. The ranges are inclusive. For example, passing in the following ranges: 65-90,91-120,121+ would yield 89 unique random strings. @param count The number of random strings to generate. @param ranges The ranges of characters to use. @return The random strings."}
{"ID": 1703, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") protected Collection<Object> newArrayInstance(final Class targetType) { if (targetType == null || targetType == List.class || targetType == Collection.class || targetType.isArray()) { return listSupplier.get(); } if (targetType == Set.class) { return new HashSet<>(); } try { return (Collection<Object>) targetType.getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new JsonException(e); } } \nResponse:", "ground_truth": "Creates new type for JSON array objects.\nIt returns a collection.\nLater, the collection will be converted into the target type.", "predict": " Create a new array instance. @param targetType The target type. @return The array instance.\n*/"}
{"ID": 1704, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void injectValueIntoObject(final Object target, final PropertyDescriptor pd, final Object value) { Object convertedValue = value; if (value != null) { Class targetClass = pd.getType(); convertedValue = convertType(value, targetClass); } try { Setter setter = pd.getSetter(true); if (setter != null) { setter.invokeSetter(target, convertedValue); } } catch (Exception ex) { throw new JsonException(ex); } } \nResponse:", "ground_truth": "Injects value into the targets property.", "predict": " Injects the value into the target object. @param target Target object. @param pd Property descriptor. @param value Value to inject."}
{"ID": 1705, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object convertType(final Object value, final Class targetType) { final Class valueClass = value.getClass(); if (valueClass == targetType) { return value; } try { return TypeConverterManager.get().convertType(value, targetType); } catch (Exception ex) { if (!strictTypes) { return null; } throw new JsonException(\"Type conversion failed\", ex); } } \nResponse:", "ground_truth": "Converts type of the given value.", "predict": " Convert the given value to the given target type. @param value Value to convert. @param targetType Target type to convert to. @return Converted value. May be the original value if no conversion was necessary. May be null if strictTypes is enabled and conversion failed.\n*/"}
{"ID": 1706, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void visitProvide(final String service, final String... providers) { if (mv != null) { mv.visitProvide(service, providers); } } \nResponse:", "ground_truth": "Visit an implementation of a service.\n\n@param service the internal name of the service.\n@param providers the internal names of the implementations of the service (there is at least\none provider).", "predict": " Visit provide statements. @param service service name @param providers providers names"}
{"ID": 1707, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unchecked\") public static <A> TypeCache<A> createDefault() { return (TypeCache<A>)Defaults.implementation.get(); } \nResponse:", "ground_truth": "Creates default implementation of the type cache.", "predict": " Create a default TypeCache. Useful for testing. @return Default TypeCache.\n*/"}
{"ID": 1708, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T put(final Class<?> type, final T value) { return map.put(type, value); } \nResponse:", "ground_truth": "Add values to the map.", "predict": " Associate the given value with the given type. @param type The type to associate with the value. @param value The value to associate with the type. @return The previous value associated with the type, or null if there was none.\n*/"}
{"ID": 1709, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MethodDescriptor[] getAllMethodDescriptors() { if (allMethods == null) { final List<MethodDescriptor> allMethodsList = new ArrayList<>(); for (MethodDescriptor[] methodDescriptors : methodsMap.values()) { Collections.addAll(allMethodsList, methodDescriptors); } final MethodDescriptor[] allMethods = allMethodsList.toArray(new MethodDescriptor[0]); Arrays.sort(allMethods, Comparator.comparing(md -> md.getMethod().getName())); this.allMethods = allMethods; } return allMethods; } \nResponse:", "ground_truth": "Returns all methods. Cached. Lazy.", "predict": " Returns all descriptors for methods defined in this interface. This includes inherited descriptors.\nReturns an empty array if there are no descriptors.\n"}
{"ID": 1710, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveIpAddress(final String hostname) { try { InetAddress netAddress; if (hostname == null || hostname.equalsIgnoreCase(LOCAL_HOST)) { netAddress = InetAddress.getLocalHost(); } else { netAddress = Inet4Address.getByName(hostname); } return netAddress.getHostAddress(); } catch (UnknownHostException ignore) { return null; } } \nResponse:", "ground_truth": "Resolves IP address from a hostname.", "predict": " Resolve the IP address of the hostname. @param hostname Hostname to resolve. @return IP address of the hostname or null if it cannot be resolved."}
{"ID": 1711, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int getIpAsInt(final String ipAddress) { int ipIntValue = 0; String[] tokens = StringUtil.splitc(ipAddress, '.'); for (String token : tokens) { if (ipIntValue > 0) { ipIntValue <<= 8; } ipIntValue += Integer.parseInt(token); } return ipIntValue; } \nResponse:", "ground_truth": "Returns IP address as integer.", "predict": " Convert dotted decimal notation IP address to integer value. @param ipAddress dotted decimal notation IP address @return IP address in integer format\n*/"}
{"ID": 1712, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean validateAgaintIPAdressV4Format(final String input) { if (input == null) { return false; } int hitDots = 0; char[] data = input.toCharArray(); for (int i = 0; i < data.length; i++) { char c = data[i]; int b = 0; do { if (c < '0' || c > '9') { return false; } b = (b * 10 + c) - 48; if (++i >= data.length) { break; } c = data[i]; } while (c != '.'); if (b > 255) { return false; } hitDots++; } return hitDots == 4; } \nResponse:", "ground_truth": "Checks given string against IP address v4 format.\n\n@param input an ip address - may be null\n@return <tt>true</tt> if param has a valid ip v4 format <tt>false</tt> otherwise\n@see <a href=\"https://en.wikipedia.org/wiki/IP_address#IPv4_addresses\">ip address v4</a>", "predict": " Validate IPv4 dotted quad notation. @param input dotted quad notation @return true if valid, false otherwise\n*/"}
{"ID": 1713, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String resolveHostName(final byte[] ip) { try { InetAddress address = InetAddress.getByAddress(ip); return address.getHostName(); } catch (UnknownHostException ignore) { return null; } } \nResponse:", "ground_truth": "Resolves host name from IP address bytes.", "predict": " Resolves the host name for the IP address. @param ip IP address to resolve @return Host name or null if cannot resolve\n*/"}
{"ID": 1714, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static byte[] downloadBytes(final String url) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return StreamUtil.readBytes(inputStream); } } \nResponse:", "ground_truth": "Downloads resource as byte array.", "predict": " Downloads bytes from the given URL. @param url The URL to download bytes from. @return The downloaded bytes. @throws IOException Something went wrong downloading the bytes."}
{"ID": 1715, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String downloadString(final String url, final String encoding) throws IOException { try (InputStream inputStream = new URL(url).openStream()) { return new String(StreamUtil.readChars(inputStream, encoding)); } } \nResponse:", "ground_truth": "Downloads resource as String.", "predict": " Downloads a string from a URL. @param url The URL to download. @param encoding The encoding to use. @return The downloaded string. @throws IOException Something went wrong."}
{"ID": 1716, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void downloadFile(final String url, final File file) throws IOException { try ( InputStream inputStream = new URL(url).openStream(); ReadableByteChannel rbc = Channels.newChannel(inputStream); FileChannel fileChannel = FileChannel.open( file.toPath(), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE) ) { fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE); } } \nResponse:", "ground_truth": "Downloads resource to a file, potentially very efficiently.", "predict": " Downloads a file from a URL. @param url The URL to download from. @param file The file to save the downloaded data to. @throws IOException If there is an error downloading the file."}
{"ID": 1717, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void inject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); final ServletContext servletContext = actionRequest.getHttpServletRequest().getServletContext(); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(servletContext, targets)); scopeResolver.forEachScope(madvocScope -> madvocScope.inject(actionRequest, targets)); } \nResponse:", "ground_truth": "Performs injection.", "predict": " Inject Madvoc scopes and targets into action request. Typically Madvoc scopes are Madvoc interceptors and targets are Madvoc interceptors too. Therefore interceptors are injected BEFORE Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected AFTER Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected BEFORE Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected AFTER Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected BEFORE Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected AFTER Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected BEFORE Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore interceptors are injected AFTER Madvoc scopes. Typically Madvoc scopes are Madvoc interceptors too. Therefore"}
{"ID": 1718, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void outject(final ActionRequest actionRequest) { final Targets targets = actionRequest.getTargets(); scopeResolver.forEachScope(madvocScope -> madvocScope.outject(actionRequest, targets)); } \nResponse:", "ground_truth": "Performs outjection.", "predict": " Outject all Targets from TargetsContainer to MadvocScope. TargetsContainer is injected to MadvocScope by MadvocContainer. MadvocScope is injected to MadvocScope by MadvocController. Therefore TargetsContainer is injected to MadvocScope BEFORE MadvocScope is injected to MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController. Therefore TargetsContainer is injected BEFORE MadvocScope is injected BEFORE MadvocController."}
{"ID": 1719, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Socket connect(final String hostname, final int port) throws IOException { final Socket socket = new Socket(); socket.connect(new InetSocketAddress(hostname, port)); return socket; } \nResponse:", "ground_truth": "Creates a socket.", "predict": " Establish a TCP socket connection to a hostname and port. @param hostname The hostname to connect to. @param port The port to connect to. @return The socket. @throws IOException If there is an error connecting to the hostname and port."}
{"ID": 1720, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Socket connect(final String hostname, final int port, final int connectionTimeout) throws IOException { final Socket socket = new Socket(); if (connectionTimeout <= 0) { socket.connect(new InetSocketAddress(hostname, port)); } else { socket.connect(new InetSocketAddress(hostname, port), connectionTimeout); } return socket; } \nResponse:", "ground_truth": "Creates a socket with a timeout.", "predict": " Establish a socket connection to a hostname and port. @param hostname The hostname to connect to. @param port The port to connect to. @param connectionTimeout The connection timeout in milliseconds. A value <= 0 implies infinity. @return The established socket. @throws IOException If there is an error establishing the connection."}
{"ID": 1721, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static int getPrimitiveClassNameIndex(final String className) { int dotIndex = className.indexOf('.'); if (dotIndex != -1) { return -1; } return Arrays.binarySearch(PRIMITIVE_TYPE_NAMES, className); } \nResponse:", "ground_truth": "Detects if provided class name is a primitive type.\nReturns >= 0 number if so.", "predict": " Looks up the primitive type name index for the given class name. Returns -1 if not found. @param className the primitive type name @return the primitive type name index\n*/"}
{"ID": 1722, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public Class loadClass(final String className, final ClassLoader classLoader) throws ClassNotFoundException { String arrayClassName = prepareArrayClassnameForLoading(className); if ((className.indexOf('.') == -1) && (arrayClassName == null)) { // maybe a primitive int primitiveNdx = getPrimitiveClassNameIndex(className); if (primitiveNdx >= 0) { return PRIMITIVE_TYPES[primitiveNdx]; } } // try #1 - using provided class loader if (classLoader != null) { Class klass = loadClass(className, arrayClassName, classLoader); if (klass != null) { return klass; } } // try #2 - using thread class loader ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader(); if ((currentThreadClassLoader != null) && (currentThreadClassLoader != classLoader)) { Class klass = loadClass(className, arrayClassName, currentThreadClassLoader); if (klass != null) { return klass; } } // try #3 - using caller classloader, similar as Class.forName() //Class callerClass = ReflectUtil.getCallerClass(2); Class callerClass = ClassUtil.getCallerClass(); ClassLoader callerClassLoader = callerClass.getClassLoader(); if ((callerClassLoader != classLoader) && (callerClassLoader != currentThreadClassLoader)) { Class klass = loadClass(className, arrayClassName, callerClassLoader); if (klass != null) { return klass; } } // try #4 - everything failed, try alternative array loader if (arrayClassName != null) { try { return loadArrayClassByComponentType(className, classLoader); } catch (ClassNotFoundException ignore) { } } throw new ClassNotFoundException(\"Class not found: \" + className); } \nResponse:", "ground_truth": "Loads class by name.", "predict": " Loads the class using the specified class loader. If the class loader is null, then the class loader of the calling class is used. If the class loader is still null, then the system class loader is used. If the system class loader is null, then the bootstrap class loader is used. If the bootstrap class loader is null, then the class loader of the caller class is used. If the caller class is null, then the system class loader is used. If the system class loader is null, then the bootstrap class loader is used. If the bootstrap class loader is null, then the class loader of the caller class is used. If the caller class is null, then the system class loader is used. If the system class loader is null, then the bootstrap class loader is used. If the bootstrap class loader is null, then the class loader of the caller class is used. If the caller class is null, then the system class loader is used. If the system class loader is null, then the bootstrap class loader is used"}
{"ID": 1723, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Class loadArrayClassByComponentType(final String className, final ClassLoader classLoader) throws ClassNotFoundException { int ndx = className.indexOf('['); int multi = StringUtil.count(className, '['); String componentTypeName = className.substring(0, ndx); Class componentType = loadClass(componentTypeName, classLoader); if (multi == 1) { return Array.newInstance(componentType, 0).getClass(); } int[] multiSizes; if (multi == 2) { multiSizes = new int[] {0, 0}; } else if (multi == 3) { multiSizes = new int[] {0, 0, 0}; } else { multiSizes = (int[]) Array.newInstance(int.class, multi); } return Array.newInstance(componentType, multiSizes).getClass(); } \nResponse:", "ground_truth": "Loads array class using component type.", "predict": " Loads the array class by component type. @param className the class name @param classLoader the class loader @return the array class @throws ClassNotFoundException Signals that a specified class could not be found.\n*/"}
{"ID": 1724, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void shutdown() { for (final BeanData beanData : instances.values()) { beanData.callDestroyMethods(); } instances.clear(); } \nResponse:", "ground_truth": "Iterate all beans and invokes registered destroy methods.", "predict": " Shut down all instances."}
{"ID": 1725, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T extends Comparable> BinarySearch<T> forArray(final T[] array) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return array[index].compareTo(element); } @Override protected int getLastIndex() { return array.length - 1; } }; } \nResponse:", "ground_truth": "Creates binary search wrapper over an array.", "predict": " Provide a binary search for comparable elements in an array. The array elements must implement Comparable. The array must be sorted ascending. The array must not contain duplicate elements. The array must be stable, ie no elements can be removed from the array during the search. The array must not be empty. The array must not be null. The array must not be mutated during the search. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch. The array must not be mutated during the lifetime of the BinarySearch"}
{"ID": 1726, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static <T> BinarySearch<T> forArray(final T[] array, final Comparator<T> comparator) { return new BinarySearch<T>() { @Override @SuppressWarnings( {\"unchecked\"}) protected int compare(final int index, final T element) { return comparator.compare(array[index], element); } @Override protected int getLastIndex() { return array.length - 1; } }; } \nResponse:", "ground_truth": "Creates binary search wrapper over an array with given comparator.", "predict": " Provide a BinarySearch tailored to work on arrays of comparable elements. @param array The array to search. @param comparator The comparator to use to compare elements. @param <T> The comparable type. @return A BinarySearch tailored to work on arrays of comparable elements. Never null."}
{"ID": 1727, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T exclude(final String... excludes) { for (String ex : excludes) { rules.exclude(ex); } return _this(); } \nResponse:", "ground_truth": "Defines excluded property names.", "predict": " Exclude rules. @param excludes The excludes. @return The builder."}
{"ID": 1728, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T include(final String... includes) { for (String in : includes) { rules.include(in); } return _this(); } \nResponse:", "ground_truth": "Defines included property names.", "predict": " Includes additional rules to the existing ones. Useful for composing rules together. @param includes The includes to add. @return The current object. Useful for chaining."}
{"ID": 1729, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public T includeAs(final Class template) { blacklist = false; String[] properties = getAllBeanPropertyNames(template, false); include(properties); return _this(); } \nResponse:", "ground_truth": "Defines included property names as public properties\nof given template class. Sets to black list mode.", "predict": " Include all bean properties of the given class as nested Groovy constructors. Equivalent to include(new GroovyClassLoader().loadClass(\"classpath:/groovy/util/GroovyCollections.groovy\", true, false) as Class). Useful for mocking frameworks. @param template The class whose properties shall be included as nested constructors. @return The DSL instance itself, to allow fluent coding. Never mind the superfluous but harmless warning about unused variable \u2018template\u2019.\n*/\nfunc IncludeAs(template interface{}) *DSL {\n\tblacklist := true\n\treturn Include(template, blacklist)\n}\n\n/*\nHere comes a strange implementation of the DSL concept. Due to the nature of Groovy, it\u2019s impossible to implement the DSL concept in a natural way. Therefore, we resort to some terrible hacks, which sadly don\u2019t behave as elegant as they should. Luckily, we can live with that, because nobody should ever inherit from DSL directly. Instead, we\u2019ll explain"}
{"ID": 1730, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start(final int startIndex) { this.tagStartIndex = startIndex; this.name = null; this.idNdx = -1; this.attributesCount = 0; this.tagLength = 0; this.modified = false; this.type = TagType.START; this.rawTag = false; } \nResponse:", "ground_truth": "Starts the tag with the index of first '<'.\nResets all tag data.", "predict": " Starts parsing of the tag. Tag name and attributes are not yet known. @param startIndex Starting index of the tag in the original XML document."}
{"ID": 1731, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> void registerComponent(final String name, final Class<T> component, final Consumer<T> consumer) { log.debug(() -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component.getName()); madpc.removeBean(name); madpc.registerPetiteBean(component, name, null, null, false, consumer); } \nResponse:", "ground_truth": "Registers Madvoc component with given name.", "predict": " Register Madvoc Petite component. Usually you don't need to call this method directly. Instead, Madvoc annotations are automatically scanned and Petite components are registered automatically. However, you can manually register Petite components too. Madvoc annotations are scanned automatically, so you don't need to worry about scanning Petite components manually. However, Petite components are not scanned automatically, so you need to manually scan Petite components yourself. Madvoc annotations are scanned automatically, so you don't need to worry about scanning Petite components manually. However, Petite components are not scanned automatically, so you need to manually scan Petite components yourself. Madvoc annotations are scanned automatically, so you don't need to worry about scanning Petite components manually. However, Petite components are not scanned automatically, so you need to manually scan Petite components yourself. Madvoc annotations are scanned automatically, so you don't need to worry about scanning Petite components manually. However, Petite components are not scanned automatically, so you need to manually scan Petite components yourself. Madvoc annotations"}
{"ID": 1732, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void resolveColumnDbSqlType(final Connection connection, final DbEntityColumnDescriptor dec) { if (dec.dbSqlType != SqlType.DB_SQLTYPE_UNKNOWN) { return; } ResultSet rs = null; DbEntityDescriptor ded = dec.getDbEntityDescriptor(); try { DatabaseMetaData dmd = connection.getMetaData(); rs = dmd.getColumns(null, ded.getSchemaName(), ded.getTableName(), dec.getColumnName()); if (rs.next()) { dec.dbSqlType = rs.getInt(\"DATA_TYPE\"); } else { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not available: \" + ded.toString() + '.' + dec.getColumnName()); } } } catch (SQLException sex) { dec.dbSqlType = SqlType.DB_SQLTYPE_NOT_AVAILABLE; if (log.isWarnEnabled()) { log.warn(\"Column SQL type not resolved: \" + ded.toString() + '.' + dec.getColumnName(), sex); } } finally { DbUtil.close(rs); } } \nResponse:", "ground_truth": "Resolves column db sql type and populates it in column descriptor if missing.", "predict": " Resolves the database column SQL type for the given column descriptor. The resolution is based on the database INFORMATION_SCHEMA.COLUMNS.DATA_TYPE column. The resolution is skipped if the column SQL type is already set. Moreover, the resolution is skipped if the column descriptor is not associated with a database entity. @param connection database connection\n * @param dec descriptor of the column whose SQL type shall be resolved\n */"}
{"ID": 1733, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String preprocessSql(String sqlString) { // detects callable statement if (sqlString.charAt(0) == '{') { return sqlString; } // quickly detect if SQL string is a key if (!CharUtil.isAlpha(sqlString.charAt(0))) { sqlString = sqlString.substring(1); } else if (sqlString.indexOf(' ') != -1) { return sqlString; } final String sqlFromMap = dbOom.queryMap().getQuery(sqlString); if (sqlFromMap != null) { sqlString = sqlFromMap.trim(); } return sqlString; } \nResponse:", "ground_truth": "Pre-process SQL before using it. If string starts with a non-ascii char\nor it has no spaces, it will be loaded from the query map.", "predict": " Preprocess SQL string. Detects CALLABLE statement if (sqlString.charAt(0) == '{'). Quickly detects if SQL string is a key if (!CharUtil.isAlpha(sqlString.charAt(0))) { sqlString = sqlString.substring(1); } else if (sqlString.indexOf(' ')!= -1) { return sqlString; } @param sqlString SQL string to be preprocessed. @return Preprocessed SQL string."}
{"ID": 1734, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ResultSetMapper createResultSetMapper(final ResultSet resultSet) { final Map<String, ColumnData> columnAliases = sqlgen != null ? sqlgen.getColumnData() : null; return new DefaultResultSetMapper(dbOom, resultSet, columnAliases, cacheEntities, this); } \nResponse:", "ground_truth": "Factory for result sets mapper.", "predict": " Creates result set mapper. @param resultSet Result set. @return Result set mapper. Shall not be null. Shall not be EMPTY. Shall not be LAZY. Shall not be LAZY_CLOSEABLE. Shall not be LAZY_SKIP_LOCKED. Shall not be LAZY_CLOSEABLE_LOCKED. Shall not be LAZY_SKIP_LOCKED_CLOSEABLE. Shall not be LAZY_CLOSEABLE_LOCKED_CLOSEABLE. Shall not be LAZY_SKIP_LOCKED_CLOSEABLE_LOCKED. Shall not be LAZY_CLOSEABLE_LOCKED_CLOSEABLE_LOCKED. Shall not be LAZY_SKIP_LOCKED_CLOSEABLE_LOCKED_CLOSEABLE. Shall not be LAZY_CLOSEABLE_LOCKED_CLOSEABLE_LOCKED_CLOSEABLE. Shall not be LAZY_CLOSEABLE_LOCKED_CLOSEABLE_LOCKED_CLOSEABLE_LOCKED. Shall not"}
{"ID": 1735, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public <T> T findGeneratedKey(final Class<T> type) { return find(new Class[] {type}, false, getGeneratedColumns()); } \nResponse:", "ground_truth": "Finds generated key column of given type.", "predict": " Finds a generated key. @param type The type of the generated key. @return The generated key.\n*/"}
{"ID": 1736, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void populateGeneratedKeys(final Object entity) { final String[] generatedColumns = getGeneratedColumnNames(); if (generatedColumns == null) { return; } DbEntityDescriptor ded = dbOom.entityManager().lookupType(entity.getClass()); // prepare key types Class[] keyTypes = new Class[generatedColumns.length]; String[] properties = new String[generatedColumns.length]; for (int i = 0; i < generatedColumns.length; i++) { String column = generatedColumns[i]; DbEntityColumnDescriptor decd = ded.findByColumnName(column); if (decd != null) { keyTypes[i] = decd.getPropertyType(); properties[i] = decd.getPropertyName(); } } final Object keyValues = findGeneratedColumns(keyTypes); if (!keyValues.getClass().isArray()) { BeanUtil.declared.setProperty(entity, properties[0], keyValues); } else { for (int i = 0; i < properties.length; i++) { BeanUtil.declared.setProperty(entity, properties[i], ((Object[]) keyValues)[i]); } } } \nResponse:", "ground_truth": "Populates entity with generated column values from executed query.", "predict": " Populate generated keys. Especially useful for Oracle DB. @param entity Entity to populate keys for."}
{"ID": 1737, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected <R extends ActionInterceptor> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \nResponse:", "ground_truth": "Acquires interceptor from Petite container.", "predict": " Creates interceptor wrapper. @param wrapperClass Interceptor wrapper class. @return Interceptor wrapper."}
{"ID": 1738, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setBean(final String beanName, final Object bean) { if (bean == null) { return _this(); } init(); final String beanNamePrefix = beanName + '.'; query.forEachNamedParameter(p -> { final String paramName = p.name; if (paramName.startsWith(beanNamePrefix)) { final String propertyName = paramName.substring(beanNamePrefix.length()); if (BeanUtil.declared.hasRootProperty(bean, propertyName)) { final Object value = BeanUtil.declared.getProperty(bean, propertyName); setObject(paramName, value); } } }); return _this(); } \nResponse:", "ground_truth": "Sets bean parameters from bean. Non-existing bean properties are ignored.", "predict": " Set the named bean in the query. @param beanName Name of the bean to set. @param bean Bean to set. @return Fluent API style reference to this. Never returns null."}
{"ID": 1739, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setMap(final Map parameters) { if (parameters == null) { return _this(); } init(); query.forEachNamedParameter(p -> { final String paramName = p.name; setObject(paramName, parameters.get(paramName)); }); return _this(); } \nResponse:", "ground_truth": "Sets properties from the map.", "predict": " Binds the named parameters from the map to the query. @param parameters The map of parameters to bind. @return The query builder.\n*/"}
{"ID": 1740, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Q setObjects(final Object... objects) { int index = 1; for (final Object object : objects) { setObject(index++, object); } return _this(); } \nResponse:", "ground_truth": "Sets an array of objects parameters in given order.", "predict": " Set the objects for this Quantified Property Restriction. @param objects The objects. @return The current object.\n*/"}
{"ID": 1741, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void insertChunkAfter(final SqlChunk previous) { SqlChunk next = previous.nextChunk; previous.nextChunk = this; this.previousChunk = previous; if (next != null) { next.previousChunk = this; this.nextChunk = next; } } \nResponse:", "ground_truth": "Appends chunk to previous one and maintains the double-linked list of the previous chunk.\nCurrent surrounding connections of this chunk will be cut-off.", "predict": " Inserts this chunk after another chunk. Moves NEXT pointers accordingly. PREVIOUS pointers are not affected. @param previous Chunk to insert this chunk after. NEXT pointers are shifted accordingly."}
{"ID": 1742, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor lookupType(final Class entity) { final DbEntityDescriptor ded = dbEntityManager.lookupType(entity); if (ded == null) { throw new DbSqlBuilderException(\"Invalid or not-persistent entity: \" + entity.getName()); } return ded; } \nResponse:", "ground_truth": "Lookups for entity name and throws an exception if entity type is invalid.", "predict": " Looks up the DbEntityDescriptor for the given entity class. Throws a DbSqlBuilderException if no such descriptor can be found. @param entity The entity class. @return The corresponding DbEntityDescriptor. Never null.\n*/"}
{"ID": 1743, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected DbEntityDescriptor findColumnRef(final String columnRef) { DbEntityDescriptor ded = templateData.findTableDescriptorByColumnRef(columnRef); if (ded == null) { throw new DbSqlBuilderException(\"Invalid column reference: [\" + columnRef + \"]\"); } return ded; } \nResponse:", "ground_truth": "Finds a table that contains given column.", "predict": " Finds the referenced column descriptor. @param columnRef the column reference (@see ColumnRefParser) @return the referenced column descriptor\n*/"}
{"ID": 1744, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveTable(final String tableRef, final DbEntityDescriptor ded) { String tableAlias = templateData.getTableAlias(tableRef); if (tableAlias != null) { return tableAlias; } return ded.getTableNameForQuery(); } \nResponse:", "ground_truth": "Resolves table name or alias that will be used in the query.", "predict": " Resolves the table name for the given tableRef. The default implementation simply returns the tableRef itself. Subclasses may override this method to resolve table aliases. @param tableRef the tableRef to resolve @param ded the dedicator @return the resolved table name\n*/"}
{"ID": 1745, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected static Class resolveClass(final Object object) { Class type = object.getClass(); return type == Class.class ? (Class) object : type; } \nResponse:", "ground_truth": "Resolves object to a class.", "predict": " Resolve the class of the given object. @param object The object whose class is to be resolved. @return The resolved class. Never {@code null}.\n*/"}
{"ID": 1746, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void appendMissingSpace(final StringBuilder out) { int len = out.length(); if (len == 0) { return; } len--; if (!CharUtil.isWhitespace(out.charAt(len))) { out.append(' '); } } \nResponse:", "ground_truth": "Appends missing space if the output doesn't end with whitespace.", "predict": " Append missing trailing whitespace. Useful for avoiding trailing whitespace issues. @param out The builder to append to. Shall not be <code>null</code>. Shall not be empty. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not be exhausted. Shall not"}
{"ID": 1747, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Enumeration<String> getFileParameterNames() { if (mreq == null) { return null; } return Collections.enumeration(mreq.getFileParameterNames()); } \nResponse:", "ground_truth": "Get an enumeration of the parameter names for uploaded files", "predict": " Returns an enumeration of the names of the files uploaded in this request. @return an enumeration of the names of the files uploaded in this request.\n*/"}
{"ID": 1748, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean include(final ServletRequest request, final ServletResponse response, final String page) throws IOException, ServletException { RequestDispatcher dispatcher = request.getRequestDispatcher(page); if (dispatcher != null) { dispatcher.include(request, response); return true; } return false; } \nResponse:", "ground_truth": "Include page which path is relative to the current HTTP request.", "predict": " Include the specified page. @param request The HTTP request. @param response The HTTP response. @param page The page to include. @return True if the page was included. @throws IOException If there was an I/O error. @throws ServletException If there was a servlet error."}
{"ID": 1749, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getUrl(final HttpServletRequest request) { String servletPath = request.getServletPath(); String query = request.getQueryString(); if ((query != null) && (query.length() != 0)) { servletPath += '?' + query; } return servletPath; } \nResponse:", "ground_truth": "Returns url, without context path, convenient for request dispatcher.", "predict": " Get the url for the current request. @param request The HTTP request. @return The url for the current request."}
{"ID": 1750, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String getRequestUri(final HttpServletRequest request) { String result = getIncludeRequestUri(request); if (result == null) { result = request.getRequestURI(); } return result; } \nResponse:", "ground_truth": "Get current request uri.", "predict": " Get the URI of the request. @param request The HTTP request. @return The URI of the request."}
{"ID": 1751, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String[] resolveParamNames(final Method actionClassMethod) { MethodParameter[] methodParameters = Paramo.resolveParameters(actionClassMethod); String[] names = new String[methodParameters.length]; for (int i = 0; i < methodParameters.length; i++) { names[i] = methodParameters[i].getName(); } return names; } \nResponse:", "ground_truth": "Returns method parameter names.", "predict": " Resolve the names of the parameters of the given action class method. @param actionClassMethod The action class method. @return The names of the parameters of the given action class method."}
{"ID": 1752, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void start() { initLogger(); log.info(\"PETITE start ----------\"); petiteContainer = createPetiteContainer(); if (externalsCache) { petiteContainer.setExternalsCache(TypeCache.createDefault()); } log.info(\"Web application? \" + isWebApplication); if (!isWebApplication) { // make session scope to act as singleton scope // if this is not a web application (and http session is not available). petiteContainer.registerScope(SessionScope.class, new SingletonScope(petiteContainer)); } // load parameters from properties files petiteContainer.defineParameters(joyPropsSupplier.get().getProps()); // automagic configuration if (autoConfiguration) { final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator(petiteContainer); automagicPetiteConfigurator.registerAsConsumer(joyScannerSupplier.get().getClassScanner()); } petiteContainerConsumers.accept(this.petiteContainer); log.info(\"PETITE OK!\"); } \nResponse:", "ground_truth": "Creates and initializes Petite container.\nIt will be auto-magically configured by scanning the classpath.", "predict": " Petite bootstrap entrance."}
{"ID": 1753, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void stop() { if (log != null) { log.info(\"PETITE stop\"); } if (petiteContainer != null) { petiteContainer.shutdown(); } petiteContainer = null; } \nResponse:", "ground_truth": "Stops Petite container.", "predict": " Shutdowns Petite Spring IoC container. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite shutdown. Fires Petite shutdown event. Petite Spring IoC container is destroyed after Petite"}
{"ID": 1754, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter subject(final String subject) { final SearchTerm subjectTerm = new SubjectTerm(subject); concat(subjectTerm); return this; } \nResponse:", "ground_truth": "Defines filter for SUBJECT field.\n\n@param subject The SUBJECT.\n@return this", "predict": " Set the subject of the email to be filtered. @param subject The subject of the email to be filtered. @return Fluent API\n*/"}
{"ID": 1755, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter messageId(final String messageId) { final SearchTerm msgIdTerm = new MessageIDTerm(messageId); concat(msgIdTerm); return this; } \nResponse:", "ground_truth": "Defines filter for message id.\n\n@param messageId The message ID.\n@return this", "predict": " Filter messages by their Message-ID header. @param messageId The value of the Message-ID header. @return The EmailFilterBuilder instance. Useful for chaining.\n*/"}
{"ID": 1756, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter from(final String fromAddress) { final SearchTerm fromTerm = new FromStringTerm(fromAddress); concat(fromTerm); return this; } \nResponse:", "ground_truth": "Defines filter for FROM field.\n\n@param fromAddress The FROM address\n@return this", "predict": " From address filter. @param fromAddress the from address @return the email filter\n*/"}
{"ID": 1757, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter to(final String toAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.TO, toAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for TO field.\n\n@param toAddress The TO address.\n@return this", "predict": " Adds TO recipients to the BCC header. @param toAddress The email address of the BCC recipient. @return An EmailFilterBuilder, to allow method chaining. Never null."}
{"ID": 1758, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter cc(final String ccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.CC, ccAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for CC field.\n\n@param ccAddress CC addreses.\n@return this", "predict": " CC recipient address match. @param ccAddress cc recipient address @return Fluent Builder"}
{"ID": 1759, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter bcc(final String bccAddress) { final SearchTerm toTerm = new RecipientStringTerm(RecipientType.BCC, bccAddress); concat(toTerm); return this; } \nResponse:", "ground_truth": "Defines filter for BCC field.\n\n@param bccAddress BCC address.\n@return this", "predict": " BCC recipient address. @param bccAddress BCC recipient address. @return Fluent API\n*/"}
{"ID": 1760, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter flags(final Flags flags, final boolean value) { final SearchTerm flagTerm = new FlagTerm(flags, value); concat(flagTerm); return this; } \nResponse:", "ground_truth": "Defines filter for many flags at once.\n\n@param flags The {@link Flags} to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " Flags to be added to the email address. @param flags Flags to be added to the email address. @param value Flag value. @return Fluent Builder."}
{"ID": 1761, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter flag(final Flag flag, final boolean value) { final Flags flags = new Flags(); flags.add(flag); return flags(flags, value); } \nResponse:", "ground_truth": "Defines filter for single flag.\n\n@param flag  The flag to filter on.\n@param value The {@link Flag} setting to check for.\n@return this", "predict": " Flags this email address with the given Flag and value. The value defaults to true. @param flag The flag to add. @param value The value for the flag. @return The EmailFilterBuilder instance. Useful for chaining.\n*/"}
{"ID": 1762, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter receivedDate(final Operator operator, final long milliseconds) { final SearchTerm term = new ReceivedDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for received date.\n\n@return this", "predict": " Restricts the results to those messages whose received date is equal to or later than the specified date. @param operator the operator to use for comparisons @param milliseconds the received date expressed as milliseconds since midnight GMT, January 1, 1970 UTC @since 0.3.1"}
{"ID": 1763, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter sentDate(final Operator operator, final long milliseconds) { final SearchTerm term = new SentDateTerm(operator.value, new Date(milliseconds)); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for sent date.\n\n@param operator     {@link Operator} to use.\n@param milliseconds the milliseconds since January 1, 1970, 00:00:00 GMT.\n@return this", "predict": " Restricts the search results to those whose documents have been sent on the specified date. @param operator The operator to use to compare the timestamp. @param milliseconds The date expressed in milliseconds since midnight GMT, January 1, 1970 UTC. @return The EmailFilter with the additional constraint.\n*/"}
{"ID": 1764, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter size(final Operator comparison, final int size) { final SearchTerm term = new SizeTerm(comparison.value, size); concat(term); return this; } \nResponse:", "ground_truth": "Defines filter for message size.\n\n@param comparison {@link Operator}.\n@param size       size of message.\n@return this", "predict": " Restricts the results to those messages that fall within the specified size range. @param comparison The comparison operator. Can be one of =,!=, <>, <=, >, BETWEEN. @param size The size range. Valid values are 0 to 32767. Negative values are not allowed. Comparison operators are supported. Legal values are: =,!=, <>, <=, >, BETWEEN. @return This email filter. Useful for chaining."}
{"ID": 1765, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter and(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new AndTerm(searchTerms)); return this; } \nResponse:", "ground_truth": "Defines AND group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to AND.\n@return this", "predict": " And together several email filters. Equivalent to constructing a composite AND searchTerm and then calling add(EmailFilter). @param emailFilters The filters to AND together. @return This email filter. Useful for chaining together multiple filters."}
{"ID": 1766, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter or(final EmailFilter... emailFilters) { final SearchTerm[] searchTerms = new SearchTerm[emailFilters.length]; for (int i = 0; i < emailFilters.length; i++) { searchTerms[i] = emailFilters[i].searchTerm; } concat(new OrTerm(searchTerms)); return this; } \nResponse:", "ground_truth": "Defines OR group of filters.\n\n@param emailFilters array of {@link EmailFilter}s to OR.\n@return this", "predict": " Applies an Or filter to the EmailFilter. @param emailFilters The EmailFilters to logically combine. @return The EmailFilter."}
{"ID": 1767, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailFilter not(final EmailFilter emailFilter) { final SearchTerm searchTerm = new NotTerm(emailFilter.searchTerm); concat(searchTerm); return this; } \nResponse:", "ground_truth": "Appends single filter as NOT.\n\n@param emailFilter {@link EmailFilter} to append.\n@return this", "predict": " Negates the given email filter. @param emailFilter The email filter to negate. @return The negated email filter."}
{"ID": 1768, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void concat(SearchTerm searchTerm) { if (nextIsNot) { searchTerm = new NotTerm(searchTerm); nextIsNot = false; } if (operatorAnd) { and(searchTerm); } else { or(searchTerm); } } \nResponse:", "ground_truth": "Concatenates last search term with new one.\n\n@param searchTerm searchTerm {@link SearchTerm} concatenate.\n@see #and(SearchTerm)\n@see #or(SearchTerm)", "predict": " Concatenates the next search term with the current one.\n*/"}
{"ID": 1769, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encode(final byte[] bytes) { StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i < bytes.length) { // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] & 255; base32.append(CHARS[currByte >> 3]); digit = (currByte & 7) << 2; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 6)]); base32.append(CHARS[(currByte >> 1) & 31]); digit = (currByte & 1) << 4; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 4)]); digit = (currByte & 15) << 1; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 7)]); base32.append(CHARS[(currByte >> 2) & 31]); digit = (currByte & 3) << 3; if (i >= bytes.length) { base32.append(CHARS[digit]); break; } // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] & 255; base32.append(CHARS[digit | (currByte >> 5)]); base32.append(CHARS[currByte & 31]); } return base32.toString(); } \nResponse:", "ground_truth": "Encode an array of binary bytes into a Base32 string.", "predict": " Encodes a byte array into a Base32 String. @param bytes Bytes to encode. @return Encoded Base32 String.\n*/\npublic static String encode(final byte[] bytes) {\n\tint i = 0;\n\tint count = bytes.length;\n\tchar[] encoded = new char[((count / 8) + 1) * 5];\n\n\twhile (i < count) {\n\t    int value = (bytes[i] >= 0)? bytes[i] : (bytes[i] + 256);\n\t    encoded[i++] = CHARS[value >> 3];\n\t    encoded[i++] = CHARS[(value & 7) << 2];\n\t    encoded[i++] = CHARS[(value >> 6) & 31];\n\t    encoded[i++] = CHARS[(value >> 1) & 31];\n\t    encoded[i++] = CHARS[(value >> 4) & 31];\n"}
{"ID": 1770, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected byte[] convertValueToArray(final Object value) { if (value instanceof Blob) { final Blob blob = (Blob) value; try { final long length = blob.length(); if (length > Integer.MAX_VALUE) { throw new TypeConversionException(\"Blob is too big.\"); } return blob.getBytes(1, (int) length); } catch (SQLException sex) { throw new TypeConversionException(value, sex); } } if (value instanceof File) { try { return FileUtil.readBytes((File) value); } catch (IOException ioex) { throw new TypeConversionException(value, ioex); } } if (value instanceof Collection) { final Collection collection = (Collection) value; final byte[] target = new byte[collection.size()]; int i = 0; for (final Object element : collection) { target[i] = convertType(element); i++; } return target; } if (value instanceof Iterable) { final Iterable iterable = (Iterable) value; final ArrayList<Byte> byteArrayList = new ArrayList<>(); for (final Object element : iterable) { final byte convertedValue = convertType(element); byteArrayList.add(Byte.valueOf(convertedValue)); } final byte[] array = new byte[byteArrayList.size()]; for (int i = 0; i < byteArrayList.size(); i++) { final Byte b = byteArrayList.get(i); array[i] = b.byteValue(); } return array; } if (value instanceof CharSequence) { final String[] strings = StringUtil.splitc(value.toString(), ArrayConverter.NUMBER_DELIMITERS); return convertArrayToArray(strings); } // everything else: return convertToSingleElementArray(value); } \nResponse:", "ground_truth": "Converts non-array value to array. Detects various\ntypes and collections, iterates them to make conversion\nand to create target array.", "predict": " Convert the given value to byte array. Depending on the value's type, different strategies are applied. @param value The value to convert. May be null. @return The converted value. Never null. May be empty.\n*/"}
{"ID": 1771, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean isGzipEligible(final HttpServletRequest request) { // request parameter name if (requestParameterName.length() != 0) { String forceGzipString = request.getParameter(requestParameterName); if (forceGzipString != null) { return Converter.get().toBooleanValue(forceGzipString, false); } } // extract uri String uri = request.getRequestURI(); if (uri == null) { return false; } uri = uri.toLowerCase(); boolean result = false; // check uri if (matches == null) { // match == * if (extensions == null) { // extensions == * return true; } // extension String extension = FileNameUtil.getExtension(uri); if (extension.length() > 0) { extension = extension.toLowerCase(); if (StringUtil.equalsOne(extension, extensions) != -1) { result = true; } } } else { if (wildcards) { result = Wildcard.matchPathOne(uri, matches) != -1; } else { for (String match : matches) { if (uri.contains(match)) { result = true; break; } } } } if ((result) && (excludes != null)) { if (wildcards) { if (Wildcard.matchPathOne(uri, excludes) != -1) { result = false; } } else { for (String exclude : excludes) { if (uri.contains(exclude)) { result = false; // excludes founded break; } } } } return result; } \nResponse:", "ground_truth": "Determine if request is eligible for GZipping.", "predict": " Check if the request is eligible to gzip compression. @param request The HTTP request. @return True if eligible, false otherwise."}
{"ID": 1772, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Violation> validate(final Object target) { return validate(ValidationContext.resolveFor(target.getClass()), target); } \nResponse:", "ground_truth": "Validate object using context from the annotations.", "predict": " Validate the target object. @param target The target object. @return Violations found during validation. May be empty but never null."}
{"ID": 1773, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public List<Violation> validate(final ValidationContext ctx, final Object target, final String targetName) { for (Map.Entry<String, List<Check>> entry : ctx.map.entrySet()) { String name = entry.getKey(); Object value = BeanUtil.declaredSilent.getProperty(target, name); String valueName = targetName != null ? (targetName + '.' + name) : name; // move up ValidationConstraintContext vcc = new ValidationConstraintContext(this, target, valueName); for (Check check : entry.getValue()) { String[] checkProfiles = check.getProfiles(); if (!matchProfiles(checkProfiles)) { continue; } if (check.getSeverity() < severity) { continue; } ValidationConstraint constraint = check.getConstraint(); if (!constraint.isValid(vcc, value)) { addViolation(new Violation(valueName, target, value, check)); } } } return getViolations(); } \nResponse:", "ground_truth": "Performs validation of provided validation context and appends violations.", "predict": " Validate the target object. @param ctx ValidationContext @param target Target object @param targetName Target name @return Violations\n*/"}
{"ID": 1774, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useProfile(final String profile) { if (profile == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } this.enabledProfiles.add(profile); } \nResponse:", "ground_truth": "Enables single profile.", "predict": " Activate profile. @param profile Profile to activate.\n*/"}
{"ID": 1775, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void useProfiles(final String... enabledProfiles) { if (enabledProfiles == null) { return; } if (this.enabledProfiles == null) { this.enabledProfiles = new HashSet<>(); } Collections.addAll(this.enabledProfiles, enabledProfiles); } \nResponse:", "ground_truth": "Enables list of profiles.", "predict": " Activate profiles. @param enabledProfiles The profiles to activate. Leave empty to activate all profiles.\n*/"}
{"ID": 1776, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected boolean matchProfiles(final String[] checkProfiles) { // test for all profiles if ((checkProfiles != null) && (checkProfiles.length == 1) && checkProfiles[0].equals(ALL_PROFILES)) { return true; } if (enabledProfiles == null || enabledProfiles.isEmpty()) { if (validateAllProfilesByDefault) { return true; // all profiles are considered as enabled } // only default profile is enabled if ((checkProfiles == null) || (checkProfiles.length == 0)) { return true; } for (String profile : checkProfiles) { if (StringUtil.isEmpty(profile)) { return true; // default profile } if (profile.equals(DEFAULT_PROFILE)) { return true; } } return false; } // there are enabled profiles if ((checkProfiles == null) || (checkProfiles.length == 0)) { return enabledProfiles.contains(DEFAULT_PROFILE); } boolean result = false; for (String profile : checkProfiles) { boolean b = true; boolean must = false; if (StringUtil.isEmpty(profile)) { profile = DEFAULT_PROFILE; } else if (profile.charAt(0) == '-') { profile = profile.substring(1); b = false; } else if (profile.charAt(0) == '+') { profile = profile.substring(1); must = true; } if (enabledProfiles.contains(profile)) { if (!b) { return false; } result = true; } else { if (must) { return false; } } } return result; } \nResponse:", "ground_truth": "Determine if any of checks profiles is among enabled profiles.", "predict": " Match profiles. @param checkProfiles the check profiles @return true, if successful\n*/"}
{"ID": 1777, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected Object parseRequestBody(final String body, final Class targetType) { return JsonParser.create().parse(body, targetType); } \nResponse:", "ground_truth": "Parses request body into the target type.", "predict": " Parse the request body into the target type. @param body The request body. @param targetType The target type. @return The parsed object."}
{"ID": 1778, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long toMilliseconds() { double then = (fraction - JD_1970.fraction) * MILLIS_IN_DAY; then += (integer - JD_1970.integer) * MILLIS_IN_DAY; then += then > 0 ? 1.0e-6 : -1.0e-6; return (long) then; } \nResponse:", "ground_truth": "Converts to milliseconds.", "predict": " Convert Gregorian date fraction expressed in days since January 1, 4713 BCE Greenwich noon to milliseconds since January 1, 1970, midnight UTC. The Gregorian calendar was adopted October 15, 1582. Leap years occur every 4 years, but not 100 years. Hence the century does not evenly divide 400 years, and the year is always expressed as a Gregorian date fraction in days. For example, the date October 15, 1582 expressed in Gregorian days is October 4, 1582 (Gregorian) February 24, 1918 (Julian). Similarly, October 15, 1918 expressed in Gregorian days is October 14, 1918 (Gregorian) February 23, 1918 (Julian). Similarly, October 14, 1918 expressed in Gregorian days is October 13, 1918 (Gregorian) February 22, 1918 (Julian). Leap years occur every 4 years, but not 100 years. Hence February 23, 1918 expressed in Gregorian days is February 23, 1918 (Gregorian) February 22, 1918 (Julian). Similarly, February 22, 1918 expressed in Gregorian days"}
{"ID": 1779, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JulianDate add(final JulianDate jds) { int i = this.integer + jds.integer; double f = this.fraction + jds.fraction; return new JulianDate(i, f); } \nResponse:", "ground_truth": "Adds a JD to current instance.", "predict": " Add JulianDate to JulianDate. @param jds JulianDate to add. @return Sum of JulianDate and JulianDate."}
{"ID": 1780, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public JulianDate sub(final JulianDate jds) { int i = this.integer - jds.integer; double f = this.fraction -jds.fraction; return new JulianDate(i, f); } \nResponse:", "ground_truth": "Subtracts a JD from current instance.", "predict": " Substracts two JulianDates. Beware, that JulianDates are immutable objects! Therefore you can't change the JulianDate afterwards! @param jds the JulianDate to substract. @return the difference between the JulianDates."}
{"ID": 1781, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void set(final int i, double f) { integer = i; int fi = (int) f; f -= fi; integer += fi; if (f < 0) { f += 1; integer--; } this.fraction = f; } \nResponse:", "ground_truth": "Sets integer and fractional part with normalization.\nNormalization means that if double is out of range,\nvalues will be correctly fixed.", "predict": " Sets the mantissa and integer components of this fraction. The fractional component is shifted by f. The integer component is shifted by fi. The fractional component is clipped to the interval [-1,1]. The integer component is clipped to the interval [-32767,32767]. Both components are limited to 16 bits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate limits. Both components are saturated to the appropriate"}
{"ID": 1782, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected void initialize(final char[] input) { super.initialize(input); this.tag = new ParsedTag(); this.doctype = new ParsedDoctype(); this.text = new char[1024]; this.textLen = 0; this.parsingTime = -1; } \nResponse:", "ground_truth": "Initializes parser.", "predict": " Initialize the parser. @param input The input to parse."}
{"ID": 1783, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void emitComment(final int from, final int to) { if (config.enableConditionalComments) { // CC: downlevel-hidden starting if (match(CC_IF, from)) { int endBracketNdx = find(']', from + 3, to); CharSequence expression = charSequence(from + 1, endBracketNdx); ndx = endBracketNdx + 1; char c = input[ndx]; if (c != '>') { errorInvalidToken(); } visitor.condComment(expression, true, true, false); state = DATA_STATE; return; } if (to > CC_ENDIF2.length && match(CC_ENDIF2, to - CC_ENDIF2.length)) { // CC: downlevel-hidden ending visitor.condComment(_ENDIF, false, true, true); state = DATA_STATE; return; } } CharSequence comment = charSequence(from, to); visitor.comment(comment); commentStart = -1; } \nResponse:", "ground_truth": "Emits a comment. Also checks for conditional comments!", "predict": " Emit a conditional or multiline comment. @param from - leading index of comment text @param to - trailing index of comment text (> trailing index of whole comment text)"}
{"ID": 1784, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void _error(String message) { if (config.calculatePosition) { Position currentPosition = position(ndx); message = message .concat(StringPool.SPACE) .concat(currentPosition.toString()); } else { message = message .concat(\" [@\") .concat(Integer.toString(ndx)) .concat(StringPool.RIGHT_SQ_BRACKET); } visitor.error(message); } \nResponse:", "ground_truth": "Prepares error message and reports it to the visitor.", "predict": " Reports an error. The location information is automatically added when CONFIG_VERY_VERBOSE is turned on. Otherwise, it is not added.\n@param message Message for the error. Shall not be <code>null</code>.\n*/"}
{"ID": 1785, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String createHash(final char[] password) { // Generate a random salt SecureRandom random = new SecureRandom(); byte[] salt = new byte[saltBytes]; random.nextBytes(salt); // Hash the password byte[] hash = pbkdf2(password, salt, pbkdf2Iterations, hashBytes); // format iterations:salt:hash return pbkdf2Iterations + \":\" + StringUtil.toHexString(salt) + \":\" + StringUtil.toHexString(hash); } \nResponse:", "ground_truth": "Returns a salted PBKDF2 hash of the password.\n\n@param password the password to hash\n@return a salted PBKDF2 hash of the password", "predict": " Generate a salted PBKDF2 hash of a password. You can specify the number of iterations to use, which can vary greatly. Most people recommend 1000 iterations. However, 2000 iterations is insanely fast. So if you're trying to crack a password, you might want to try 1000 iterations. However, if you're trying to authenticate a user, you probably want more than 1000 iterations. Again, 2000 iterations is insanely fast. So if you're trying to crack a password, you probably want more than 1000 iterations. Lastly, you might want to try more iterations than 1000, but you're probably wasting CPU cycles. Recommendations: 1000 iterations. 2000 iterations is insanely fast. 3000 iterations is insanely fast. 5000 iterations is insanely fast. 7000 iterations is insanely fast. 9000 iterations is insanely fast. 10000 iterations is insanely fast. 20000 iterations is insanely fast. 25000 iterations is insanely fast. Your favorite crackling password is probably 5000 iterations. Your favorite authentication is probably 2500 iterations. Lastly, you might want to try more iterations than 2500, but you're"}
{"ID": 1786, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] pbkdf2(final char[] password, final byte[] salt, final int iterations, final int bytes) { PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8); try { SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM); return skf.generateSecret(spec).getEncoded(); } catch (NoSuchAlgorithmException ignore) { return null; } catch (InvalidKeySpecException e) { throw new IllegalArgumentException(e); } } \nResponse:", "ground_truth": "Computes the PBKDF2 hash of a password.\n\n@param password the password to hash.\n@param salt the salt\n@param iterations the iteration count (slowness factor)\n@param bytes the length of the hash to compute in bytes\n@return the PBDKF2 hash of the password", "predict": " PBKDF2 salted password hashing. Taken from https://github.com/mitsuhiko/java-pbkdf2 @param password the password to hash @param salt the salt to hash with (perhaps generated randomly via BCrypt or similar) @param iterations how many iterations to perform. It's recommended to use at least 1000 @param bytes the number of bytes to derive - recommend at least 32 @return a sufficiently long base64-encoded string containing the hash"}
{"ID": 1787, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static byte[] fromHex(final String hex) { final byte[] binary = new byte[hex.length() / 2]; for (int i = 0; i < binary.length; i++) { binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16); } return binary; } \nResponse:", "ground_truth": "Converts a string of hexadecimal characters into a byte array.\n\n@param hex the hex string\n@return the hex string decoded into a byte array", "predict": " Convert a hexadecimal string into a byte array. @param hex Hexadecimal string to convert. @return Byte array representation of hexadecimal string."}
{"ID": 1788, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ProviderDefinition[] resolveProviderDefinitions(final Class type, final String name) { return providerResolver.resolve(type, name); } \nResponse:", "ground_truth": "Resolves provider definition defined in a bean.", "predict": " Resolves provider definitions for the given type and name. @param type The type. @param name The name. @return The providers. Never null. May be empty.\n*/"}
{"ID": 1789, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public EmailAttachmentBuilder name(final String name) { if (name != null && !name.trim().isEmpty()) { this.name = name; } return this; } \nResponse:", "ground_truth": "Sets file name.\n\n@param name File name to set.\n@return this", "predict": " Set the attachment name. @param name The name of the attachment. @return Fluent API."}
{"ID": 1790, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected EmailAttachmentBuilder setContentIdFromNameIfMissing() { if (contentId == null) { if (name != null) { contentId(FileNameUtil.getName(name)); } else { contentId(NO_NAME); } } return this; } \nResponse:", "ground_truth": "Set content ID if it is missing.\n\n@return this\n@see #contentId(String)", "predict": " Sets the content ID based on the file name if it wasn't set explicitly. This is useful when you want to attach a file to an email but don't know the content ID beforehand. The content ID will be automatically generated based on the file name. This method returns the builder instance so you can chain multiple calls together. @return The builder instance so you can chain multiple calls together.\n*/"}
{"ID": 1791, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected String resolveContentType(final String contentType) { if (contentType != null) { return contentType; } if (name == null) { return MimeTypes.MIME_APPLICATION_OCTET_STREAM; } final String extension = FileNameUtil.getExtension(name); return MimeTypes.getMimeType(extension); } \nResponse:", "ground_truth": "Resolves content type from all data.\n\n@param contentType Content type if we know it. {@code null} is fine to use.\n@return content type", "predict": " Resolves the content type. @param contentType the content type, may be {@code null} @return the resolved content type\n*/"}
{"ID": 1792, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int computeAttributesSize() { symbolTable.addConstantUtf8(Constants.MODULE); // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int size = 22 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; if (packageCount > 0) { symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES); // 6 attribute header bytes, and 2 bytes for package_count. size += 8 + packageIndex.length; } if (mainClassIndex > 0) { symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS); // 6 attribute header bytes, and 2 bytes for main_class_index. size += 8; } return size; } \nResponse:", "ground_truth": "Returns the size of the Module, ModulePackages and ModuleMainClass attributes generated by this\nModuleWriter. Also add the names of these attributes in the constant pool.\n\n@return the size in bytes of the Module, ModulePackages and ModuleMainClass attributes.", "predict": " Computes the size of a MODULE_INFO record in bytes. Also adds the attributes to the constant pool. @return the size of the MODULE_INFO record in bytes\n*/"}
{"ID": 1793, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void putAttributes(final ByteVector output) { // 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int moduleAttributeLength = 16 + requires.length + exports.length + opens.length + usesIndex.length + provides.length; output .putShort(symbolTable.addConstantUtf8(Constants.MODULE)) .putInt(moduleAttributeLength) .putShort(moduleNameIndex) .putShort(moduleFlags) .putShort(moduleVersionIndex) .putShort(requiresCount) .putByteArray(requires.data, 0, requires.length) .putShort(exportsCount) .putByteArray(exports.data, 0, exports.length) .putShort(opensCount) .putByteArray(opens.data, 0, opens.length) .putShort(usesCount) .putByteArray(usesIndex.data, 0, usesIndex.length) .putShort(providesCount) .putByteArray(provides.data, 0, provides.length); if (packageCount > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_PACKAGES)) .putInt(2 + packageIndex.length) .putShort(packageCount) .putByteArray(packageIndex.data, 0, packageIndex.length); } if (mainClassIndex > 0) { output .putShort(symbolTable.addConstantUtf8(Constants.MODULE_MAIN_CLASS)) .putInt(2) .putShort(mainClassIndex); } } \nResponse:", "ground_truth": "Puts the Module, ModulePackages and ModuleMainClass attributes generated by this ModuleWriter\nin the given ByteVector.\n\n@param output where the attributes must be put.", "predict": " Puts the attributes of this module into the given byte vector. @param output where the attributes must be put.\n*/"}
{"ID": 1794, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decode(final String source, final String encoding) { return decode(source, encoding, false); } \nResponse:", "ground_truth": "Decodes URL elements. This method may be used for all\nparts of URL, except for the query parts, since it does\nnot decode the '+' character.\n@see #decodeQuery(String, String)", "predict": " Decodes a string using the specified encoding. @param source The string to decode. @param encoding The encoding to use. @return The decoded string.\n*/"}
{"ID": 1795, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String decodeQuery(final String source, final String encoding) { return decode(source, encoding, true); } \nResponse:", "ground_truth": "Decodes query name or value.", "predict": " Decodes the query portion of a Uniform Resource Identifier (URI). @param source the URI to decode, may be relative or malformed @param encoding the character encoding to use when decoding the URI @return the decoded URI\n*/"}
{"ID": 1796, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override @SuppressWarnings(\"unchecked\") public void start() { initLogger(); if (!databaseEnabled) { log.info(\"DB not enabled.\"); return; } log.info(\"DB start ----------\"); final PetiteContainer petiteContainer = joyPetiteSupplier.get().getPetiteContainer(); // connection pool connectionProvider = createConnectionProviderIfNotSupplied(); petiteContainer.addBean(beanNamePrefix() + \"pool\", connectionProvider); if (connectionProvider instanceof CoreConnectionPool) { final CoreConnectionPool pool = (CoreConnectionPool) connectionProvider; if (pool.getDriver() == null) { databaseEnabled = false; log.warn(\"DB configuration not set (\" + beanNamePrefix() + \"pool.*). DB will be disabled.\"); return; } } connectionProvider.init(); checkConnectionProvider(); // transactions manager jtxManager = createJtxTransactionManager(connectionProvider); jtxManager.setValidateExistingTransaction(true); final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager(new LeanJtxWorker(jtxManager), jtxScopePattern); AnnotationTxAdviceSupport.manager = annTxAdviceManager; // create proxy joyProxettaSupplier.get().getProxetta().withAspect(createTxProxyAspects(annTxAdviceManager.getAnnotations())); final DbSessionProvider sessionProvider = new DbJtxSessionProvider(jtxManager); // querymap final long startTime = System.currentTimeMillis(); final QueryMap queryMap = new DbPropsQueryMap(); log.debug(\"Queries loaded in \" + (System.currentTimeMillis() - startTime) + \"ms.\"); log.debug(\"Total queries: \" + queryMap.size()); // dboom dbOom = DbOom.create() .withConnectionProvider(connectionProvider) .withSessionProvider(sessionProvider) .withQueryMap(queryMap) .get(); dbOom.connect(); final DbEntityManager dbEntityManager = dbOom.entityManager(); dbEntityManager.reset(); petiteContainer.addBean(beanNamePrefix() + \"query\", dbOom.queryConfig()); petiteContainer.addBean(beanNamePrefix() + \"oom\", dbOom.config()); // automatic configuration if (autoConfiguration) { final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator(dbEntityManager, true); automagicDbOomConfigurator.registerAsConsumer( joyScannerSupplier.get().getClassScanner()); } dbEntityManagerConsumers.accept(dbEntityManager); log.info(\"DB OK!\"); } \nResponse:", "ground_truth": "Initializes database. First, creates connection pool.\nand transaction manager. Then, Jodds DbEntityManager is\nconfigured. It is also configured automagically, by scanning\nthe class path for entities.", "predict": " Start joypetite."}
{"ID": 1797, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void checkConnectionProvider() { final Connection connection = connectionProvider.getConnection(); try { final DatabaseMetaData databaseMetaData = connection.getMetaData(); String name = databaseMetaData.getDatabaseProductName(); String version = databaseMetaData.getDatabaseProductVersion(); if (log.isInfoEnabled()) { log.info(\"Connected to database: \" + name + \" v\" + version); } } catch (SQLException sex) { log.error(\"DB connection failed: \", sex); } finally { connectionProvider.closeConnection(connection); } } \nResponse:", "ground_truth": "Checks if connection provider can return a connection.", "predict": " Check connection provider. Making sure connection is alive."}
{"ID": 1798, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { // if ((access & AsmUtil.ACC_FINAL) != 0) { // return null; // skip finals // } MethodSignatureVisitor msign = createMethodSignature(access, name, desc, signature, exceptions, thisReference, this.generics); String key = ProxettaAsmUtil.createMethodSignaturesKey(access, name, desc, thisReference); methodSignatures.put(key, msign); allMethodSignatures.add(msign.getCleanSignature()); return new MethodAnnotationReader(msign); } \nResponse:", "ground_truth": "Stores method signature for target method.", "predict": " Visit method. @param access Access flags of the visited method. @param name Name of the visited method. @param desc Method descriptor of the visited method. @param signature Method signature of the visited method. @param exceptions List of exceptions which can be thrown by the visited method. @return Method visitor."}
{"ID": 1799, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void visitEnd() { // prepare class annotations if (classAnnotations != null) { annotations = classAnnotations.toArray(new AnnotationInfo[0]); classAnnotations = null; } List<String> superList = new ArrayList<>(); Set<String> allInterfaces = new HashSet<>(); if (nextInterfaces != null) { allInterfaces.addAll(nextInterfaces); } // check all public super methods that are not overridden in superclass while (nextSupername != null) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(nextSupername, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super class: \" + nextSupername, ioex); } finally { StreamUtil.close(inputStream); } superList.add(nextSupername); superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { Collections.addAll(allInterfaces, cr.getInterfaces()); } } superClasses = superList.toArray(new String[0]); // check all interface methods that are not overridden in super-interface Set<String> todoInterfaces = new HashSet<>(allInterfaces); Set<String> newCollectedInterfaces = new HashSet<>(); while (true) { for (String next : todoInterfaces) { InputStream inputStream = null; ClassReader cr; try { inputStream = ClassLoaderUtil.getClassAsStream(next, classLoader); cr = new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(\"Unable to inspect super interface: \" + next, ioex); } finally { StreamUtil.close(inputStream); } superClassReaders.add(cr); // remember the super class reader cr.accept(new SuperClassVisitor(), 0); if (cr.getInterfaces() != null) { for (String newInterface : cr.getInterfaces()) { if (!allInterfaces.contains(newInterface) && !todoInterfaces.contains(newInterface)) { // new interface found newCollectedInterfaces.add(newInterface); } } } } // perform collection allInterfaces.addAll(todoInterfaces); if (newCollectedInterfaces.isEmpty()) { // no new interface found break; } todoInterfaces.clear(); todoInterfaces.addAll(newCollectedInterfaces); newCollectedInterfaces.clear(); } } \nResponse:", "ground_truth": "Stores signatures for all super public methods not already overridden by target class.\nAll this methods will be accepted for proxyfication.", "predict": " Visit end of class. Preparation of annotations. Collect super interfaces and super class annotations."}
{"ID": 1800, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected MethodSignatureVisitor createMethodSignature( final int access, final String methodName, final String description, final String signature, final String[] exceptions, final String classname, final Map<String, String> declaredTypeGenerics) { MethodSignatureVisitor v = new MethodSignatureVisitor(methodName, access, classname, description, exceptions, signature, declaredTypeGenerics, this); new SignatureReader(signature != null ? signature : description).accept(v); return v; } \nResponse:", "ground_truth": "Creates method signature from method name.", "predict": " Creates a MethodSignatureVisitor that will write the signature to a StringBuffer. Give it a dummy name, and you can ask it to emit the signature for any method whose name you desire. You can pass in any flags, except ACC_DEPRECATED, ACC_NATIVE or ACC_SYNTHETIC. @param access access flags for the prospective method. @param methodName name of the method whose signature will be emitted @param description a human-readable description to go along with these flags. @param signature the method's signature. You can pass null if you wish this visitor to learn whether the method's signature is generic. @param exceptions the exceptions thrown by this method. You can pass null if you wish this visitor to learn whether the method's exceptions are generic. @param classname the name of the class declaring this method. @param declaredTypeGenerics the generics information for the declaring class. May be null. @return a visitor for generating a signature for the given method.\n"}
{"ID": 1801, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String toCsvString(final Object... elements) { StringBuilder line = new StringBuilder(); int last = elements.length -1; for (int i = 0; i < elements.length; i++) { if (elements[i] == null) { if (i != last) { line.append(FIELD_SEPARATOR); } continue; } String field = elements[i].toString(); // check for special cases int ndx = field.indexOf(FIELD_SEPARATOR); if (ndx == -1) { ndx = field.indexOf(FIELD_QUOTE); } if (ndx == -1) { if (field.startsWith(StringPool.SPACE) || field.endsWith(StringPool.SPACE)) { ndx = 1; } } if (ndx == -1) { ndx = StringUtil.indexOfChars(field, SPECIAL_CHARS); } // add field if (ndx != -1) { line.append(FIELD_QUOTE); } field = StringUtil.replace(field, StringPool.QUOTE, DOUBLE_QUOTE); line.append(field); if (ndx != -1) { line.append(FIELD_QUOTE); } // last if (i != last) { line.append(FIELD_SEPARATOR); } } return line.toString(); } \nResponse:", "ground_truth": "Parse fields as csv string,", "predict": " Converts an array of Objects into a CSV string. @param elements The elements to convert. @return The CSV string."}
{"ID": 1802, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String[] toStringArray(final String line) { List<String> row = new ArrayList<>(); boolean inQuotedField = false; int fieldStart = 0; final int len = line.length(); for (int i = 0; i < len; i++) { char c = line.charAt(i); if (c == FIELD_SEPARATOR) { if (!inQuotedField) { // ignore we are quoting addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 1; } } else if (c == FIELD_QUOTE) { if (inQuotedField) { if (i + 1 == len || line.charAt(i + 1) == FIELD_SEPARATOR) { // we are already quoting - peek to see if this is the end of the field addField(row, line, fieldStart, i, inQuotedField); fieldStart = i + 2; i++; // and skip the comma inQuotedField = false; } } else if (fieldStart == i) { inQuotedField = true; // this is a beginning of a quote fieldStart++; // move field start } } } // add last field - but only if string was not empty if (len > 0 && fieldStart <= len) { addField(row, line, fieldStart, len, inQuotedField); } return row.toArray(new String[0]); } \nResponse:", "ground_truth": "Converts CSV line to string array.", "predict": " Convert a CSV line into an array of fields. Empty fields will be skipped. @param line The line to convert. @return The fields in the line.\n*/"}
{"ID": 1803, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CtorInjectionPoint resolve(final Class type, final boolean useAnnotation) { // lookup methods ClassDescriptor cd = ClassIntrospector.get().lookup(type); CtorDescriptor[] allCtors = cd.getAllCtorDescriptors(); Constructor foundedCtor = null; Constructor defaultCtor = null; BeanReferences[] references = null; for (CtorDescriptor ctorDescriptor : allCtors) { Constructor<?> ctor = ctorDescriptor.getConstructor(); Class<?>[] paramTypes = ctor.getParameterTypes(); if (paramTypes.length == 0) { defaultCtor = ctor; // detects default ctors } if (!useAnnotation) { continue; } BeanReferences[] ctorReferences = referencesResolver.readAllReferencesFromAnnotation(ctor); if (ctorReferences == null) { continue; } if (foundedCtor != null) { throw new PetiteException(\"Two or more constructors are annotated as injection points in the bean: \" + type.getName()); } foundedCtor = ctor; references = ctorReferences; } if (foundedCtor == null) { // there is no annotated constructor if (allCtors.length == 1) { foundedCtor = allCtors[0].getConstructor(); } else { foundedCtor = defaultCtor; } if (foundedCtor == null) { // no matching ctor found // still this is not an error if bean is already instantiated. return CtorInjectionPoint.EMPTY; } references = referencesResolver.readAllReferencesFromAnnotation(foundedCtor); if (references == null) { references = new BeanReferences[0]; } } return new CtorInjectionPoint(foundedCtor, references); } \nResponse:", "ground_truth": "Resolves constructor injection point from type. Looks for single annotated constructor.\nIf no annotated constructors found, the total number of constructors will be checked.\nIf there is only one constructor, that one will be used as injection point. If more\nconstructors exist, the default one will be used as injection point. Otherwise, exception\nis thrown.", "predict": " Resolves injection point based on constructor annotations. @param type bean type @param useAnnotation true if constructor injection point should be resolved based on annotations, false if based on bean class only. @return injection point\n"}
{"ID": 1804, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ClassReader createAdviceClassReader(final Class<? extends ProxyAdvice> advice) { InputStream inputStream = null; try { inputStream = ClassLoaderUtil.getClassAsStream(advice); return new ClassReader(inputStream); } catch (IOException ioex) { throw new ProxettaException(ioex); } finally { StreamUtil.close(inputStream); } } \nResponse:", "ground_truth": "Creates advice's class reader.", "predict": " Advice class reader creation. Advice class reader is needed to analyze advice class bytecode. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information. Advice class reader is needed to analyze advice class bytecode because Advice class is compiled with debug information"}
{"ID": 1805, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private ClassReader getCachedAdviceClassReader(final Class<? extends ProxyAdvice> advice) { if (adviceClassReaderCache == null) { adviceClassReaderCache = TypeCache.createDefault(); } ClassReader adviceReader = adviceClassReaderCache.get(advice); if (adviceReader == null) { adviceReader = createAdviceClassReader(advice); adviceClassReaderCache.put(advice, adviceReader); } return adviceReader; } \nResponse:", "ground_truth": "Returns class reader for advice.", "predict": " Get advice class reader from cache. @param advice advice class. @return advice class reader."}
{"ID": 1806, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String encrypt(final String str) { try { byte[] utf8 = StringUtil.getBytes(str); // encode the string into bytes using utf-8 byte[] enc = ecipher.doFinal(utf8); // encrypt return Base64.encodeToString(enc); // encode bytes to base64 to get a string } catch (Throwable ignore) { return null; } } \nResponse:", "ground_truth": "Symmetrically encrypts the string.", "predict": " Encrypt the plain text using AES-128 ECB. @param str Plain text to encrypt. @return Encrypted text.\n*/"}
{"ID": 1807, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String decrypt(String str) { try { str = StringUtil.replaceChar(str, ' ', '+'); // replace spaces with chars. byte[] dec = Base64.decode(str); // decode base64 to get bytes byte[] utf8 = dcipher.doFinal(dec); // decrypt return new String(utf8, UTF_8); // decode using utf-8 } catch (Throwable ignore) { return null; } } \nResponse:", "ground_truth": "Symmetrically decrypts the string.", "predict": " Decrypt the given string. @param str The encrypted string. @return The decrypted string. Returns null if the encryption failed."}
{"ID": 1808, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Logger getLogger(final String name) { if (loggers == null) { return loggerProvider.apply(name); } return loggers.computeIfAbsent(name, loggerProvider); } \nResponse:", "ground_truth": "Returns logger for given name. Repeated calls to this method with the\nsame argument should return the very same instance of the logger.", "predict": " Obtain a logger by name. @param name The name of the logger. @return The logger."}
{"ID": 1809, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void setName(final String name) { if (name.contains(\";\") || name.contains(\",\") || name.startsWith(\"$\")) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } for (int n = 0; n < name.length(); n++) { char c = name.charAt(n); if (c <= 0x20 || c >= 0x7f) { throw new IllegalArgumentException(\"Invalid cookie name:\" + name); } } this.name = name; } \nResponse:", "ground_truth": "Sets the cookie name and checks for validity.", "predict": " Set cookie name. @param name Cookie name.\n*/"}
{"ID": 1810, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected ActionRequest createActionRequest( final String actionPath, final String[] actionPathChunks, final ActionRuntime actionRuntime, final Object action, final HttpServletRequest servletRequest, final HttpServletResponse servletResponse) { return new ActionRequest(this, actionPath, actionPathChunks, actionRuntime, action, servletRequest, servletResponse); } \nResponse:", "ground_truth": "Creates new action request.\n@param actionPath\t\taction path\n@param actionRuntime\t\taction runtime\n@param action\t\t\taction object\n@param servletRequest\thttp request\n@param servletResponse\thttp response\n@return action request", "predict": " Creates an action request. @param actionPath The action path. @param actionPathChunks The action path chunks. @param actionRuntime The action runtime. @param action The action. @param servletRequest The servlet request. @param servletResponse The servlet response. @return The action request."}
{"ID": 1811, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override protected <R extends ActionFilter> R createWrapper(final Class<R> wrapperClass) { return petiteContainer.createBean(wrapperClass); } \nResponse:", "ground_truth": "Acquires filter from Petite container.", "predict": " Creates wrapper bean for given action filter. @param wrapperClass Wrapper bean class. @return Wrapper bean."}
{"ID": 1812, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: protected void destroyBean(final BeanData beanData) { if (destroyableBeans == null) { return; } if (!isBeanDestroyable(beanData)) { return; } if (destroyableBeans.remove(beanData)) { beanData.callDestroyMethods(); } } \nResponse:", "ground_truth": "Removes destroyable bean from the list and calls it destroy methods.\nIf bean is not destroyable, does nothing. Bean gets destroyed only once.", "predict": " Destroy the bean. Destroyable beans are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean but are not DestroyableBean are destroyed when they are garbage collected. Destroy beans that implement DestroyableBean"}
{"ID": 1813, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void shutdown() { if (destroyableBeans == null) { return; } for (final BeanData destroyableBean : destroyableBeans) { destroyableBean.callDestroyMethods(); } destroyableBeans.clear(); } \nResponse:", "ground_truth": "Shutdowns the scope and calls all collected destroyable beans.", "predict": " Shutdown destroyable beans. Destroyable beans are beans that implement Destroyable interface. Destroyable beans are destroyed when Spring IoC container shuts down. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction. Destroyable beans are destroyed BEFORE Spring IoC destruction."}
{"ID": 1814, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ReceivedEmail[] get() { if (fromFolder != null) { session.useFolder(fromFolder); } return session.receiveMessages(filter, flagsToSet, flagsToUnset, envelopeOnly, messages -> { if (targetFolder != null) { try { session.folder.copyMessages(messages, session.getFolder(targetFolder)); } catch (MessagingException e) { throw new MailException(\"Copying messages failed\"); } } }); } \nResponse:", "ground_truth": "Receives the emails as specified by the builder.", "predict": " Receives emails addressed to the mailing list. @return ReceivedEmail[] Received emails addressed to the mailing list."}
{"ID": 1815, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(final String[] args) { loadPropertiesFiles(args); try (ClusteredServiceContainer container = launch()) { container.context().shutdownSignalBarrier().await(); System.out.println(\"Shutdown ClusteredServiceContainer...\"); } } \nResponse:", "ground_truth": "Launch the clustered service container and await a shutdown signal.\n\n@param args command line argument which is a list for properties files as URLs or filenames.", "predict": " Main entry point for launching a ClusteredServiceContainer. Launches a ClusteredServiceContainer and prints out the address of the leader.\n */"}
{"ID": 1816, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void run() { do { LockSupport.parkNanos(parkNs); final long currentTotalMessages = totalMessages; final long currentTotalBytes = totalBytes; final long currentTimestamp = System.nanoTime(); final long timeSpanNs = currentTimestamp - lastTimestamp; final double messagesPerSec = ((currentTotalMessages - lastTotalMessages) * (double)reportIntervalNs) / (double)timeSpanNs; final double bytesPerSec = ((currentTotalBytes - lastTotalBytes) * (double)reportIntervalNs) / (double)timeSpanNs; reportingFunc.onReport(messagesPerSec, bytesPerSec, currentTotalMessages, currentTotalBytes); lastTotalBytes = currentTotalBytes; lastTotalMessages = currentTotalMessages; lastTimestamp = currentTimestamp; } while (!halt); } \nResponse:", "ground_truth": "Run loop for the rate reporter", "predict": " Periodically prints throughput stats to the console.\n*/"}
{"ID": 1817, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @SuppressWarnings(\"unused\") public static void printError( final String channel, final int streamId, final int sessionId, final String message, final HeaderFlyweight cause) { System.out.println(message); } \nResponse:", "ground_truth": "Generic error handler that just prints message to stdout.\n\n@param channel   for the error\n@param streamId  for the error\n@param sessionId for the error, if source\n@param message   indicating what the error was\n@param cause     of the error", "predict": " Print an error message to aid debugging. Useful for capturing unexpected errors.\n */ Lifetime: Construction."}
{"ID": 1818, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void printRate( final double messagesPerSec, final double bytesPerSec, final long totalMessages, final long totalBytes) { System.out.println(String.format( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\", messagesPerSec, bytesPerSec, totalMessages, totalBytes / (1024 * 1024))); } \nResponse:", "ground_truth": "Print the rates to stdout\n\n@param messagesPerSec being reported\n@param bytesPerSec    being reported\n@param totalMessages  being reported\n@param totalBytes     being reported", "predict": " Prints throughput summary statistics for sustained throughput measurements. @param messagesPerSec Number of messages sent per second. @param bytesPerSec Number of payload bytes sent per second. @param totalMessages Total number of messages sent. @param totalBytes Total payload size in bytes."}
{"ID": 1819, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MappedByteBuffer mapExistingFileReadOnly(final File location) { if (!location.exists()) { final String msg = \"file not found: \" + location.getAbsolutePath(); throw new IllegalStateException(msg); } MappedByteBuffer mappedByteBuffer = null; try (RandomAccessFile file = new RandomAccessFile(location, \"r\"); FileChannel channel = file.getChannel()) { mappedByteBuffer = channel.map(READ_ONLY, 0, channel.size()); } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } return mappedByteBuffer; } \nResponse:", "ground_truth": "Map an existing file as a read only buffer.\n\n@param location of file to map.\n@return the mapped file.", "predict": " Map an existing file read-only. @param location The file to map. @return The mapped byte buffer. Never null. May be empty. May throw unchecked exception."}
{"ID": 1820, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { final State state = this.state; if (State.CLOSED != state) { if (isReplayActive) { isReplayActive = false; archive.stopReplay(replaySessionId); } if (State.MERGED != state) { subscription.removeDestination(replayDestination); } state(State.CLOSED); } } \nResponse:", "ground_truth": "Close the merge and stop any active replay. Will remove the replay destination from the subscription. Will\nNOT remove the live destination if it has been added.", "predict": " Close ReplaySession.\n*/"}
{"ID": 1821, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int doWork() { int workCount = 0; switch (state) { case AWAIT_INITIAL_RECORDING_POSITION: workCount += awaitInitialRecordingPosition(); break; case AWAIT_REPLAY: workCount += awaitReplay(); break; case AWAIT_CATCH_UP: workCount += awaitCatchUp(); break; case AWAIT_CURRENT_RECORDING_POSITION: workCount += awaitUpdatedRecordingPosition(); break; case AWAIT_STOP_REPLAY: workCount += awaitStopReplay(); break; } return workCount; } \nResponse:", "ground_truth": "Process the operation of the merge. Do not call the processing of fragments on the subscription.\n\n@return indication of work done processing the merge.", "predict": " Await the initial recording position, replay, catch up, or stop replay.\n * @return The number of frames processed.\n */"}
{"ID": 1822, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long position() { if (isClosed) { return CLOSED; } final long rawTail = rawTailVolatile(logMetaDataBuffer); final int termOffset = termOffset(rawTail, termBufferLength); return computePosition(termId(rawTail), termOffset, positionBitsToShift, initialTermId); } \nResponse:", "ground_truth": "Get the current position to which the publication has advanced for this stream.\n\n@return the current position to which the publication has advanced for this stream or {@link #CLOSED}.", "predict": " Returns the approximate offset in the consuming log relative to the tail of the consuming log. This value is useful for periodically flushing the log tail, ensuring timely delivery of log messages to downstream components. Note that this approximation is likely to be inaccurate if the consuming log contains messages that were written while the log tail was being advanced but have not yet been flushed. @return The approximate offset in the consuming log relative to the tail of the consuming log.\n*/"}
{"ID": 1823, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier) { final int length = DirectBufferVector.validateAndComputeLength(vectors); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { final int result; if (length <= maxPayloadLength) { result = termAppender.appendUnfragmentedMessage( termId, termOffset, headerWriter, vectors, length, reservedValueSupplier); } else { checkMaxMessageLength(length); result = termAppender.appendFragmentedMessage( termId, termOffset, headerWriter, vectors, length, maxPayloadLength, reservedValueSupplier); } newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; } \nResponse:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message.\n\n@param vectors               which make up the message.\n@param reservedValueSupplier {@link ReservedValueSupplier} for the frame.\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.", "predict": " Offer a batch of vectors to the tail of the log. This method will block until sufficient space is available or the offer times out. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of the log. Whilst offers are blocked waiting for space to become available, no vectors may be appended to the tail of"}
{"ID": 1824, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long appendPadding(final int length) { checkMaxMessageLength(length); long newPosition = CLOSED; if (!isClosed) { final long limit = positionLimit.getVolatile(); final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex]; final long position = termBeginPosition + termOffset; if (position < limit) { checkPositiveLength(length); final int result = termAppender.appendPadding(termId, termOffset, headerWriter, length); newPosition = newPosition(result); } else { newPosition = backPressureStatus(position, length); } } return newPosition; } \nResponse:", "ground_truth": "Append a padding record log of a given length to make up the log to a position.\n\n@param length of the range to claim, in bytes..\n@return The new stream position, otherwise a negative error value of {@link #NOT_CONNECTED},\n{@link #BACK_PRESSURED}, {@link #ADMIN_ACTION}, {@link #CLOSED}, or {@link #MAX_POSITION_EXCEEDED}.\n@throws IllegalArgumentException if the length is greater than {@link #maxMessageLength()}.", "predict": " Appends padding to the term. The padding length is capped by the maximum padding length. Once the maximum padding length is reached, the call will block until sufficient space is freed up. Once sufficient space is freed up, it will resume accepting new padding. Once the padding reaches its maximum length, it will block until sufficient space is freed up. Therefore, the maximum padding length is enforced regardless of the backlog pressure situation. However, the backlog pressure situation could alleviate gradually, gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the backlog pressure situation could alleviate gradually gradually decreasing the backlog pressure gradually. Therefore, the"}
{"ID": 1825, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { lock.lock(); try { if (!isClosed) { isClosed = true; archiveProxy.closeSession(controlSessionId); if (!context.ownsAeronClient()) { CloseHelper.close(controlResponsePoller.subscription()); CloseHelper.close(archiveProxy.publication()); } context.close(); } } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Notify the archive that this control session is closed so it can promptly release resources then close the\nlocal resources associated with the client.", "predict": " Close Aeron resources associated with this AeronArchive instance. After this method is called no further calls can be made to methods of this AeronArchive instance.\n*/"}
{"ID": 1826, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String pollForErrorResponse() { lock.lock(); try { ensureOpen(); if (controlResponsePoller.poll() != 0 && controlResponsePoller.isPollComplete()) { if (controlResponsePoller.controlSessionId() == controlSessionId && controlResponsePoller.templateId() == ControlResponseDecoder.TEMPLATE_ID && controlResponsePoller.code() == ControlResponseCode.ERROR) { return controlResponsePoller.errorMessage(); } } return null; } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Poll the response stream once for an error. If another message is present then it will be skipped over\nso only call when not expecting another response.\n\n@return the error String otherwise null if no error is found.", "predict": " Poll for an ERROR control response. Will block until a ERROR control response is received or the control channel times out waiting for a response. @return The ERROR response message or null if no ERROR response was received.\n*/"}
{"ID": 1827, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void stopReplay(final long replaySessionId) { lock.lock(); try { ensureOpen(); final long correlationId = aeron.nextCorrelationId(); if (!archiveProxy.stopReplay(replaySessionId, correlationId, controlSessionId)) { throw new ArchiveException(\"failed to send stop replay request\"); } pollForResponse(correlationId); } finally { lock.unlock(); } } \nResponse:", "ground_truth": "Stop a replay session.\n\n@param replaySessionId to stop replay for.", "predict": " Instruct the media driver to stop recording a replay session. Once stopped, the replay session can no longer be resumed. @param replaySessionId to stop recording.\n */"}
{"ID": 1828, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void eventAvailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"new image on %s streamId %x sessionId %x from %s%n\", subscription.channel(), subscription.streamId(), image.sessionId(), image.sourceIdentity()); } \nResponse:", "ground_truth": "Print the information for an available image to stdout.\n\n@param image that has been created", "predict": " Event available image. @param image the image\n*/"}
{"ID": 1829, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void eventUnavailableImage(final Image image) { final Subscription subscription = image.subscription(); System.out.format( \"inactive image on %s streamId %d sessionId %x%n\", subscription.channel(), subscription.streamId(), image.sessionId()); } \nResponse:", "ground_truth": "This handler is called when image is unavailable\n\n@param image that has gone inactive", "predict": " Event unavailable image. @param image the image"}
{"ID": 1830, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StatusIndicatorReader sendChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == SendChannelStatus.SEND_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; } \nResponse:", "ground_truth": "Return the read-only status indicator for the given send channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the send channel.\n@return read-only status indicator that can be used to query the status of the send channel or null\n@see ChannelEndpointStatus for status values and indications.", "predict": " Send channel status. @param countersReader to interrogate for counters relating to SendChannelStatus. @param channel to interrogate for SendChannelStatus. @return StatusIndicatorReader positioned at the first occurrence of SendChannelStatus relating to the provided channel.\n*/"}
{"ID": 1831, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static StatusIndicatorReader receiveChannelStatus(final CountersReader countersReader, final String channel) { StatusIndicatorReader statusReader = null; final MutableInteger id = new MutableInteger(-1); countersReader.forEach( (counterId, typeId, keyBuffer, label) -> { if (typeId == ReceiveChannelStatus.RECEIVE_CHANNEL_STATUS_TYPE_ID) { if (channel.startsWith(keyBuffer.getStringAscii(ChannelEndpointStatus.CHANNEL_OFFSET))) { id.value = counterId; } } }); if (Aeron.NULL_VALUE != id.value) { statusReader = new UnsafeBufferStatusIndicator(countersReader.valuesBuffer(), id.value); } return statusReader; } \nResponse:", "ground_truth": "Return the read-only status indicator for the given receive channel URI.\n\n@param countersReader that holds the status indicator.\n@param channel        for the receive channel.\n@return read-only status indicator that can be used to query the status of the receive channel or null.\n@see ChannelEndpointStatus for status values and indications.", "predict": " Wait for a status indicator to become available. Useful for testing. @param countersReader to interrogate for counters. @param channel to wait for. @return StatusIndicatorReader providing access to the counter.\n*/"}
{"ID": 1832, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void limit(final int limit) { if (limit < 0 || limit >= buffer.capacity()) { throw new IllegalArgumentException( \"limit outside range: capacity=\" + buffer.capacity() + \" limit=\" + limit); } this.limit = limit; } \nResponse:", "ground_truth": "Set this limit for this buffer as the position at which the next append operation will occur.\n\n@param limit to be the new value.", "predict": " Limit the number of bytes held by this buffer. If the current position is beyond the limit, then the position is set to the limit. If the current position is before the limit, then the position is unchanged. @param limit The limit to impose on the buffer. Must be >= 0 and <= capacity.\n*/"}
{"ID": 1833, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public BufferBuilder append(final DirectBuffer srcBuffer, final int srcOffset, final int length) { ensureCapacity(length); buffer.putBytes(limit, srcBuffer, srcOffset, length); limit += length; return this; } \nResponse:", "ground_truth": "Append a source buffer to the end of the internal buffer, resizing the internal buffer as required.\n\n@param srcBuffer from which to copy.\n@param srcOffset in the source buffer from which to copy.\n@param length    in bytes to copy from the source buffer.\n@return the builder for fluent API usage.", "predict": " Append bytes from a direct buffer to the buffer. This will advance the write pointer forward the specified number of bytes. @param srcBuffer The direct buffer to copy bytes from. @param srcOffset The offset in the direct buffer from which to copy bytes. @param length The number of bytes to copy. @return The BufferBuilder instance for chaining."}
{"ID": 1834, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int poll() { controlSessionId = -1; correlationId = -1; relevantId = -1; templateId = -1; errorMessage = null; pollComplete = false; return subscription.controlledPoll(fragmentAssembler, fragmentLimit); } \nResponse:", "ground_truth": "Poll for control response events.\n\n@return the number of fragments read during the operation. Zero if no events are available.", "predict": " Poll for the next message fragment. The polled message fragment will be assembled into complete messages by assembling fragments belonging to the same logical subscription. Polled fragments belonging to other subscriptions will be silently dropped. Polled fragments belonging to subscriptions that are no longer active will be silently dropped. Polled fragments belonging to subscriptions that are still active will be assembled into complete messages and delivered to the appropriate consumer. @return The number of fragments polled. Zero is returned if polledFragmentCountLimit reached. Negative indicates error. Positive indicates success. Zero may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Zero may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity. Negative may indicate lack of subscription activity"}
{"ID": 1835, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static MappedByteBuffer mapLossReport(final String aeronDirectoryName, final int reportFileLength) { return mapNewFile(file(aeronDirectoryName), reportFileLength, false); } \nResponse:", "ground_truth": "Map a new loss report in the Aeron directory for a given length.\n\n@param aeronDirectoryName in which to create the file.\n@param reportFileLength   for the file.\n@return the newly mapped buffer for the file.", "predict": " Map a loss report file. The resulting mapped buffer remains owned by the caller.\n * @param aeronDirectoryName Aeron directory name to use for loss report file.\n * @param reportFileLength length of the loss report file in bytes.\n * @return the mapped buffer for the loss report file.\n */"}
{"ID": 1836, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<StreamCompositeKey, List<StreamPosition>> snapshot() { final Map<StreamCompositeKey, List<StreamPosition>> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamPosition position = new StreamPosition( keyBuffer.getLong(REGISTRATION_ID_OFFSET), counters.getCounterValue(counterId), typeId); streams .computeIfAbsent(key, (ignore) -> new ArrayList<>()) .add(position); } }); return streams; } \nResponse:", "ground_truth": "Take a snapshot of all the counters and group them by streams.\n\n@return a snapshot of all the counters and group them by streams.", "predict": " Snapshot of the counters. @return Map of snapshots."}
{"ID": 1837, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UnsafeBuffer createDefaultHeader(final int sessionId, final int streamId, final int termId) { final UnsafeBuffer buffer = new UnsafeBuffer( BufferUtil.allocateDirectAligned(HEADER_LENGTH, CACHE_LINE_LENGTH)); buffer.putByte(VERSION_FIELD_OFFSET, CURRENT_VERSION); buffer.putByte(FLAGS_FIELD_OFFSET, (byte)BEGIN_AND_END_FLAGS); buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_DATA, LITTLE_ENDIAN); buffer.putInt(SESSION_ID_FIELD_OFFSET, sessionId, LITTLE_ENDIAN); buffer.putInt(STREAM_ID_FIELD_OFFSET, streamId, LITTLE_ENDIAN); buffer.putInt(TERM_ID_FIELD_OFFSET, termId, LITTLE_ENDIAN); buffer.putLong(RESERVED_VALUE_OFFSET, DEFAULT_RESERVE_VALUE); return buffer; } \nResponse:", "ground_truth": "Return an initialised default Data Frame Header.\n\n@param sessionId for the header\n@param streamId  for the header\n@param termId    for the header\n@return byte array containing the header", "predict": " Create a default HeaderFlyweight for use in communicating with Data Receivers. The HeaderFlyweight reserves the right to change the HeaderFlyweight in the future without impacting the ability of existing applications to communicate with brokers. Applications should not assume that the HeaderFlyweight will remain unchanged. Instead, they should obtain Flyweights from HeaderFlyweight.createNew() to avoid future incompatibility. @param sessionId Session ID of the producer or consumer.\n@param streamId Stream ID of the producer or consumer.\n@param termId Term ID of the producer or consumer.\n@return Newly created HeaderFlyweight."}
{"ID": 1838, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CounterMessageFlyweight keyBuffer(final DirectBuffer keyBuffer, final int keyOffset, final int keyLength) { buffer.putInt(KEY_LENGTH_OFFSET, keyLength); if (null != keyBuffer && keyLength > 0) { buffer.putBytes(keyBufferOffset(), keyBuffer, keyOffset, keyLength); } return this; } \nResponse:", "ground_truth": "Fill the key buffer.\n\n@param keyBuffer containing the optional key for the counter.\n@param keyOffset within the keyBuffer at which the key begins.\n@param keyLength of the key in the keyBuffer.\n@return flyweight", "predict": " Provide the ability to specify a buffer to be used for the key whilst retaining the ability to retain the ability to specify a key length. Useful for when interacting with frameworks requiring a key-bearing payload such as Aeron. @param keyBuffer containing the key. Null or zero length clears the current key. @param keyOffset offset into the key buffer. Guaranteed to be non-negative and no larger than the length of the key @param keyLength length of the key excluding padding. Guaranteed to be non-negative and no larger than the length of the key buffer. May be zero to clear the key. @return this flyweight"}
{"ID": 1839, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public CounterMessageFlyweight labelBuffer( final DirectBuffer labelBuffer, final int labelOffset, final int labelLength) { buffer.putInt(labelOffset(), labelLength); buffer.putBytes(labelBufferOffset(), labelBuffer, labelOffset, labelLength); return this; } \nResponse:", "ground_truth": "Fill the label buffer.\n\n@param labelBuffer containing the mandatory label for the counter.\n@param labelOffset within the labelBuffer at which the label begins.\n@param labelLength of the label in the labelBuffer.\n@return flyweight", "predict": " Provide a buffer containing a fragmentation label. The label comprises a 24-bit IEEE 754 floating-point value, limited to 23 significant bits. The 24th bit is reserved to signify fragmentation. Fragmentation refers to the fact that the labelled message may be fragmented before transmission. @param labelBuffer containing the label. @param labelOffset at which the label begins. @param labelLength of the label in bytes. @return flyweight providing flexible management of the buffer containing the fragmentation label."}
{"ID": 1840, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean connect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); return offerWithTimeout(connectRequestEncoder.encodedLength(), null); } \nResponse:", "ground_truth": "Connect to an archive on its control interface providing the response stream details.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " Connect to archive conductor conductor subscribes to archive conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor subscribes to conductor conductor"}
{"ID": 1841, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean tryConnect(final String responseChannel, final int responseStreamId, final long correlationId) { connectRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .correlationId(correlationId) .responseStreamId(responseStreamId) .version(AeronArchive.Configuration.SEMANTIC_VERSION) .responseChannel(responseChannel); final int length = MessageHeaderEncoder.ENCODED_LENGTH + connectRequestEncoder.encodedLength(); return publication.offer(buffer, 0, length) > 0; } \nResponse:", "ground_truth": "Try Connect to an archive on its control interface providing the response stream details. Only one attempt will\nbe made to offer the request.\n\n@param responseChannel  for the control message responses.\n@param responseStreamId for the control message responses.\n@param correlationId    for this request.\n@return true if successfully offered otherwise false.", "predict": " Send a CONNECT request to the conductor. @param responseChannel to which the CONNECT response will be delivered @param responseStreamId stream id for the response @param correlationId correlation id associated with the publication @return true if the message was sent successfully otherwise false\n*/"}
{"ID": 1842, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean closeSession(final long controlSessionId) { closeSessionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId); return offer(closeSessionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Close this control session with the archive.\n\n@param controlSessionId with the archive.\n@return true if successfully offered otherwise false.", "predict": " Close control session. Once the session is closed no new requests can be routed to it. However, sessions can be reopened after they are closed. Sessions are considered inactive when they do not have outstanding requests routed to them. Therefore inactive sessions can be closed to reclaim resources. Sessions can be closed at anytime. Closing a session drains outstanding requests from the session\u2019s queue. Closing a drained session does not affect outstanding requests routed to other sessions. Closing a session drains outstanding requests from the session\u2019s queue. Closing a drained session does not affect outstanding requests routed to other sessions. Closing a session drains outstanding requests from the session\u2019s queue. Closing a drained session does not affect outstanding requests routed to other sessions. Closing a session drains outstanding requests from the session\u2019s queue. Closing a drained session does not affect outstanding requests routed to other sessions. Closing a session drains outstanding requests from the session\u2019s queue. Closing a drained session does not affect outstanding requests routed to other sessions. Closing a session drains outstanding requests from the session\u2019s queue. Closing"}
{"ID": 1843, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean startRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long correlationId, final long controlSessionId) { startRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(startRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Start recording streams for a given channel and stream id pairing.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Starts recording a multicast stream. Once recording has begun, the stream will continue to transmit packets indefinitely. The server will retain the recording indefinitely. Upon completion of this command, the server will automatically transition the recording to PAUSED state. Upon completion of this command, the server will automatically transition the recording to STOPPED state. Upon completion of this command, the server will automatically transition the recording to RECORDING state. Upon completion of this command, the server will automatically transition the recording to STOPPED state. Upon completion of this command, the server will automatically transition the recording to RECORDING state. Upon completion of this command, the server will automatically transition the recording to STOPPED state. Upon completion of this command, the server will automatically transition the recording to RECORDING state. Upon completion of this command, the server will automatically transition the recording to STOPPED state. Upon completion of this command, the server will automatically transition the recording to RECORDING state. Upon completion of this command, the server will automatically transition the recording to STOPP"}
{"ID": 1844, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean stopRecording( final String channel, final int streamId, final long correlationId, final long controlSessionId) { stopRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .streamId(streamId) .channel(channel); return offer(stopRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Stop an active recording.\n\n@param channel          to be stopped.\n@param streamId         to be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Instruct the server to stop recording a multicast stream. Once recording stops, the server will accept no more packets for this stream. Upon completion of this command, the server will send a confirmation message to the peer acknowledging receipt and acceptance of the stop command. @param channel The multicast stream for which to stop recording. @param streamId The stream ID of the multicast stream for which to stop recording. @param correlationId The correlation ID for the request. @param controlSessionId The ControlSession ID for the request. @return The decoded stop recording response."}
{"ID": 1845, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean replay( final long recordingId, final long position, final long length, final String replayChannel, final int replayStreamId, final long correlationId, final long controlSessionId) { replayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .position(position) .length(length) .replayStreamId(replayStreamId) .replayChannel(replayChannel); return offer(replayRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Replay a recording from a given position.\n\n@param recordingId      to be replayed.\n@param position         from which the replay should be started.\n@param length           of the stream to be replayed. Use {@link Long#MAX_VALUE} to follow a live stream.\n@param replayChannel    to which the replay should be sent.\n@param replayStreamId   to which the replay should be sent.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Instruct the server to begin replaying the recording identified by the recordingId. Once playback has begun, messages will be read from the replayChannel and offered to the application via the offeredMessages() method. Once playback has ended, the recording will be automatically deleted. @param recordingId The recordingId of the recording to replay. @param position The position within the recording to begin playback at. @param length The length of the recording to replay. @param replayChannel The channel to read messages from during replay. @param replayStreamId The streamId within the replayChannel to read messages from during replay. @param correlationId A client provided identifier for the replay. @param controlSessionId The ControlSessionId of the replay. @return true iff replay was successful.\n"}
{"ID": 1846, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean stopReplay(final long replaySessionId, final long correlationId, final long controlSessionId) { stopReplayRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .replaySessionId(replaySessionId); return offer(replayRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Stop an existing replay session.\n\n@param replaySessionId  that should be stopped.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Instruct the replay-actor to stop replaying replay requests for the specified replay session. The replay actor will continue accepting replay requests until replaySessionId reaches 0xffffffffffffffffL. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will refuse any replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will stop accepting replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will refuse any replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will stop accepting replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will refuse any replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will stop accepting replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will refuse any replay requests. Once replaySessionId reaches 0xffffffffffffffffL, the replay actor will stop accepting replay requests. Once replay"}
{"ID": 1847, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordings( final long fromRecordingId, final int recordCount, final long correlationId, final long controlSessionId) { listRecordingsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount); return offer(listRecordingsRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a range of recording descriptors.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Browse recordings starting from a given recording id. The BrowseRecordingsResponse is sent upon completion. @param fromRecordingId Starting recording id. @param recordCount Number of recordings to return. @param correlationId Uniquely identifies a request between two peers. @param controlSessionId Identifier of the control session.\n @return Whether the request was successful or not."}
{"ID": 1848, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordingsForUri( final long fromRecordingId, final int recordCount, final String channelFragment, final int streamId, final long correlationId, final long controlSessionId) { listRecordingsForUriRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .fromRecordingId(fromRecordingId) .recordCount(recordCount) .streamId(streamId) .channel(channelFragment); return offer(listRecordingsForUriRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a range of recording descriptors which match a channel URI fragment and stream id.\n\n@param fromRecordingId  at which to begin listing.\n@param recordCount      for the number of descriptors to be listed.\n@param channelFragment  to match recordings on from the original channel URI in the archive descriptor.\n@param streamId         to match recordings on.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Browse recordings on a stream. Provide a maximum number of recordings to return. The BrowseRecordings websocket frame carries an opaque continuation parameter which identifies the next set of recordings to return. The opaque continuation parameter is echoed back in the next set of BrowseRecordings websocket frame. The BrowseRecordings websocket frame carries an opaque continuation parameter which identifies the next set of recordings to return. The opaque continuation parameter is echoed back in the next set of BrowseRecordings websocket frame. The opaque continuation parameter identifies the next set of recordings to return. The opaque continuation parameter echoes back in the BrowseRecordings websocket frame. The BrowseRecordings websocket frame carries an opaque continuation parameter which identifies the next set of recordings to return. The opaque continuation parameter echoes back in the BrowseRecordings websocket frame. The opaque continuation parameter identifies the next set of recordings to return. The opaque continuation parameter echoes back in the BrowseRecordings websocket frame. The opaque continuation parameter identifies the next set of recordings to return. The opaque continuation parameter echoes back in the BrowseRecordings websocket"}
{"ID": 1849, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecording(final long recordingId, final long correlationId, final long controlSessionId) { listRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(listRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List a recording descriptor for a given recording id.\n\n@param recordingId      at which to begin listing.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Browse recording summaries. Once the first Summary comes back, the subsequent summaries are streamed. Stopped recordings are streamed opportunistically. Care should be taken to avoid flooding the connection with unnecessary summaries. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically. Stopped recordings are streamed opportunistically"}
{"ID": 1850, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean extendRecording( final String channel, final int streamId, final SourceLocation sourceLocation, final long recordingId, final long correlationId, final long controlSessionId) { extendRecordingRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId) .streamId(streamId) .sourceLocation(sourceLocation) .channel(channel); return offer(extendRecordingRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Extend an existing, non-active, recorded stream for a the same channel and stream id.\n\nThe channel must be configured for the initial position from which it will be extended. This can be done\nwith {@link ChannelUriStringBuilder#initialPosition(long, int, int)}. The details required to initialise can\nbe found by calling {@link #listRecording(long, long, long)}.\n\n@param channel          to be recorded.\n@param streamId         to be recorded.\n@param sourceLocation   of the publication to be recorded.\n@param recordingId      to be extended.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Extend recording request. Correlation ID is auto-generated. @param channel @param streamId @param sourceLocation @param recordingId @param correlationId @param controlSessionId @return success or failure\n*/"}
{"ID": 1851, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean getRecordingPosition(final long recordingId, final long correlationId, final long controlSessionId) { recordingPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(recordingPositionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Get the recorded position of an active recording.\n\n@param recordingId      of the active recording that the position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Instruct the server to provide the position of the recording referenced by the recording id. Once the recording reaches a stopping position, no further position updates will be sent. @param recordingId Recording Id of the recording whose position is sought. @param correlationId 32-bit unsigned integer chosen by the client. @param controlSessionId Identifier for a particular replay instance.\n * @return True if the chunk was written, false otherwise.\n */"}
{"ID": 1852, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean getStopPosition(final long recordingId, final long correlationId, final long controlSessionId) { stopPositionRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .recordingId(recordingId); return offer(stopPositionRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "Get the stop position of a recording.\n\n@param recordingId      of the recording that the stop position is being requested for.\n@param correlationId    for this request.\n@param controlSessionId for this request.\n@return true if successfully offered otherwise false.", "predict": " Instruct the server to stop writing to a recording. Once the recording reaches the stopping position, no more data will be accepted. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position, the server will accept no more commands until the client issues a resume command. Once the recording reaches the stopping position"}
{"ID": 1853, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean listRecordingSubscriptions( final int pseudoIndex, final int subscriptionCount, final String channelFragment, final int streamId, final boolean applyStreamId, final long correlationId, final long controlSessionId) { listRecordingSubscriptionsRequestEncoder .wrapAndApplyHeader(buffer, 0, messageHeaderEncoder) .controlSessionId(controlSessionId) .correlationId(correlationId) .pseudoIndex(pseudoIndex) .subscriptionCount(subscriptionCount) .applyStreamId(applyStreamId ? BooleanType.TRUE : BooleanType.FALSE) .streamId(streamId) .channel(channelFragment); return offer(listRecordingSubscriptionsRequestEncoder.encodedLength()); } \nResponse:", "ground_truth": "List registered subscriptions in the archive which have been used to record streams.\n\n@param pseudoIndex       in the list of active recording subscriptions.\n@param subscriptionCount for the number of descriptors to be listed.\n@param channelFragment   for a contains match on the stripped channel used with the registered subscription.\n@param streamId          for the subscription.\n@param applyStreamId     when matching.\n@param correlationId     for this request.\n@param controlSessionId  for this request.\n@return true if successfully offered otherwise false.", "predict": " List Recording Subscriptions @param pseudoIndex @param subscriptionCount @param channelFragment @param streamId @param applyStreamId @param correlationId @param controlSessionId @return COMPLETED_NO,OK,[channel-fragment],[stream-id],[apply-stream-id],[subscription-count],[pseudo-index],[subscription-id],[subscription-state],[subscription-info],[subscription-heartbeat],[subscription-lost],[subscription-purged],[subscription-renewal],[subscription-revocation],[subscription-heartbeat],[subscription-lost],[subscription-purged],[subscription-renewal],[subscription-revocation],[subscription-heartbeat],[subscription-lost],[subscription-purged],[subscription-renewal],[subscription-revocation],[subscription-heartbeat],[subscription-lost],[subscription-purged],[subscription-renewal],[subscription-revocation],[subscription-heartbeat],[subscription-lost"}
{"ID": 1854, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean matchesTag(final UdpChannel udpChannel) { if (!hasTag || !udpChannel.hasTag() || tag != udpChannel.tag()) { return false; } if (udpChannel.remoteData().getAddress().isAnyLocalAddress() && udpChannel.remoteData().getPort() == 0 && udpChannel.localData().getAddress().isAnyLocalAddress() && udpChannel.localData().getPort() == 0) { return true; } throw new IllegalArgumentException(\"matching tag has set endpoint or control address\"); } \nResponse:", "ground_truth": "Does this channel have a tag match to another channel including endpoints.\n\n@param udpChannel to match against.\n@return true if there is a match otherwise false.", "predict": " Matches a UDP Channel based on its tag. Only compares the tag portion of the UDPChannel. This is useful for determining if a UDPChannel is being listened on by a NAT gateway. @param udpChannel UDPChannel to match. @return True if UDPChannel has matching tag. False otherwise."}
{"ID": 1855, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static InetSocketAddress destinationAddress(final ChannelUri uri) { try { validateConfiguration(uri); return getEndpointAddress(uri); } catch (final Exception ex) { throw new InvalidChannelException(ErrorCode.INVALID_CHANNEL, ex); } } \nResponse:", "ground_truth": "Get the endpoint address from the URI.\n\n@param uri to check\n@return endpoint address for URI", "predict": " Returns the UDP packet destination address. @param uri Channel Uri. @return UDP packet destination address. @throws InvalidChannelException if unable to determine packet destination address."}
{"ID": 1856, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String description() { final StringBuilder builder = new StringBuilder(\"UdpChannel - \"); if (null != localInterface) { builder .append(\"interface: \") .append(localInterface.getDisplayName()) .append(\", \"); } builder .append(\"localData: \").append(localData) .append(\", remoteData: \").append(remoteData) .append(\", ttl: \").append(multicastTtl); return builder.toString(); } \nResponse:", "ground_truth": "Used for debugging to get a human readable description of the channel.\n\n@return a human readable description of the channel.", "predict": " Provide a verbose description of the UDP channel including the local and remote endpoints. Useful for debugging purposes. @return verbose description of UDP channel\n*/"}
{"ID": 1857, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void addDestination(final int transportIndex, final ReceiveDestinationUdpTransport transport) { imageConnections = ArrayUtil.ensureCapacity(imageConnections, transportIndex + 1); if (transport.isMulticast()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.udpChannel().remoteControl()); } else if (transport.hasExplicitControl()) { imageConnections[transportIndex] = new ImageConnection( cachedNanoClock.nanoTime(), transport.explicitControlAddress()); } } \nResponse:", "ground_truth": "Add a destination to this image so it can merge streams.\n\n@param transportIndex from which packets will arrive.\n@param transport      from which packets will arrive.", "predict": " Adds a UDP destination transport to the image. @param transportIndex The transport index. @param transport The UDP transport. */"}
{"ID": 1858, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: int insertPacket( final int termId, final int termOffset, final UnsafeBuffer buffer, final int length, final int transportIndex, final InetSocketAddress srcAddress) { final boolean isHeartbeat = DataHeaderFlyweight.isHeartbeat(buffer, length); final long packetPosition = computePosition(termId, termOffset, positionBitsToShift, initialTermId); final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length; if (!isFlowControlUnderRun(packetPosition) && !isFlowControlOverRun(proposedPosition)) { trackConnection(transportIndex, srcAddress, lastPacketTimestampNs); if (isHeartbeat) { if (DataHeaderFlyweight.isEndOfStream(buffer) && !isEndOfStream && allEos(transportIndex)) { LogBufferDescriptor.endOfStreamPosition(rawLog.metaData(), proposedPosition); isEndOfStream = true; } heartbeatsReceived.incrementOrdered(); } else { final UnsafeBuffer termBuffer = termBuffers[indexByPosition(packetPosition, positionBitsToShift)]; TermRebuilder.insert(termBuffer, termOffset, buffer, length); } lastPacketTimestampNs = cachedNanoClock.nanoTime(); hwmPosition.proposeMaxOrdered(proposedPosition); } return length; } \nResponse:", "ground_truth": "Insert frame into term buffer.\n\n@param termId         for the data packet to insert into the appropriate term.\n@param termOffset     for the start of the packet in the term.\n@param buffer         for the data packet to insert into the appropriate term.\n@param length         of the data packet\n@param transportIndex which the packet came from.\n@param srcAddress     which the packet came from.\n@return number of bytes applied as a result of this insertion.", "predict": " Insert a packet into the log retaining the order of arrival. The packet is inserted into the term at the appropriate insertion point. If insertion takes place beyond the end of the term, the packet is padded with zeros to the maximum packet length. Once the packet has been inserted into the log, it is immediately removed from the queue. Whilst the packet remains in the queue, heartbeats are sent and received as usual. Once the packet leaves the queue, heartbeats cease and congestion window permitting resumes congestion control.\n * @param termId The identifier of the current term.\n * @param termOffset The offset into the term at which the packet should be inserted.\n * @param buffer The buffer containing the packet.\n * @param length The length of the packet in bytes.\n * @param transportIndex The transport index for the connection over which this packet was received.\n * @param srcAddress The Internet address of the sender.\n * @return The length of the packet in bytes that was inserted into the log.\n */"}
{"ID": 1859, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter findControlToggle(final CountersReader counters) { final AtomicBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { final int recordOffset = CountersReader.metaDataOffset(i); if (counters.getCounterState(i) == RECORD_ALLOCATED && buffer.getInt(recordOffset + TYPE_ID_OFFSET) == CONTROL_TOGGLE_TYPE_ID) { return new AtomicCounter(counters.valuesBuffer(), i, null); } } return null; } \nResponse:", "ground_truth": "Find the control toggle counter or return null if not found.\n\n@param counters to search for the control toggle.\n@return the control toggle counter or return null if not found.", "predict": " Find the first allocated counter whose counterId is a control toggle type. @param counters counters instance @return AtomicCounter if found, otherwise null\n*/"}
{"ID": 1860, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String put(final String key, final String value) { return params.put(key, value); } \nResponse:", "ground_truth": "Put a key and value pair in the map of params.\n\n@param key   of the param to be put.\n@param value of the param to be put.\n@return the existing value otherwise null.", "predict": " Puts a new parameter to the query string. @param key The key of the parameter. @param value The value of the parameter. @return The previous value of the parameter.\n*/"}
{"ID": 1861, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String channelTag() { return (null != tags && tags.length > CHANNEL_TAG_INDEX) ? tags[CHANNEL_TAG_INDEX] : null; } \nResponse:", "ground_truth": "Get the channel tag, if it exists, that refers to an another channel.\n\n@return channel tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Channel tag. @return Channel tag."}
{"ID": 1862, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String entityTag() { return (null != tags && tags.length > ENTITY_TAG_INDEX) ? tags[ENTITY_TAG_INDEX] : null; } \nResponse:", "ground_truth": "Get the entity tag, if it exists, that refers to an entity such as subscription or publication.\n\n@return entity tag if it exists or null if not in this URI.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Entity tag of the blob. Might be null if the blob does not have an ETag. @return ETag of the blob. Might be null if the blob does not have an ETag."}
{"ID": 1863, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String addSessionId(final String channel, final int sessionId) { final ChannelUri channelUri = ChannelUri.parse(channel); channelUri.put(CommonContext.SESSION_ID_PARAM_NAME, Integer.toString(sessionId)); return channelUri.toString(); } \nResponse:", "ground_truth": "Add a sessionId to a given channel.\n\n@param channel   to add sessionId to.\n@param sessionId to add to channel.\n@return new string that represents channel with sessionId added.", "predict": " Adds the requisite session ID to the Channel URI. @param channel Channel URI. @param sessionId Session ID. @return Channel URI with Session ID."}
{"ID": 1864, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getTag(final String paramValue) { return isTagged(paramValue) ? AsciiEncoding.parseLongAscii(paramValue, 4, paramValue.length() - 4) : INVALID_TAG; } \nResponse:", "ground_truth": "Get the value of the tag from a given parameter value.\n\n@param paramValue to extract the tag value from.\n@return the value of the tag or {@link #INVALID_TAG} if not tagged.\n@see CommonContext#TAGS_PARAM_NAME\n@see CommonContext#TAG_PREFIX", "predict": " Extracts the tag from the given parameter value. @param paramValue The parameter value. Shall not be <code>null</code>. @return The tag or <code>INVALID_TAG</code> if the tag cannot be extracted. Shall not be <code>null</code>. @since 0.31"}
{"ID": 1865, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public int appendPadding( final int termId, final int termOffset, final HeaderWriter header, final int length) { final int frameLength = length + HEADER_LENGTH; final int alignedLength = align(frameLength, FRAME_ALIGNMENT); final UnsafeBuffer termBuffer = this.termBuffer; final int termLength = termBuffer.capacity(); int resultingOffset = termOffset + alignedLength; putRawTailOrdered(termId, resultingOffset); if (resultingOffset > termLength) { resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId); } else { header.write(termBuffer, termOffset, frameLength, termId); frameType(termBuffer, termOffset, PADDING_FRAME_TYPE); frameLengthOrdered(termBuffer, termOffset, frameLength); } return resultingOffset; } \nResponse:", "ground_truth": "Pad a length of the term buffer with a padding record.\n\n@param termId     for the current term.\n@param termOffset in the term at which to append.\n@param header     for writing the default header.\n@param length     of the padding to be written.\n@return the resulting offset of the term after success otherwise {@link #FAILED}.", "predict": " Writes a padding frame at the tail of the term. The padding frame improves compression efficiency by effectively making uncompressed data more compressible. Ideally, a single frame would contain sufficient information to accurately predict the subsequent uncompressed frames. However, since this is generally impractical, we settle for packing as many values into a frame as possible. Whilst sacrificing some accuracy, compression is greatly improved. Whilst sacrificing some space, the benefits outweigh the sacrifice. Whilst sacrificing some temporal redundancy, temporal redundancy is recovered whilst sacrificing some space. Whilst sacrificing some redundancy, redundancy is recovered whilst sacrificing temporal redundancy. Whilst sacrificing temporal redundancy, redundancy is recovered whilst sacrificing some space. Whilst sacrificing some space, redundancy is recovered whilst sacrificing temporal redundancy. Whilst sacrificing temporal redundancy, redundancy is recovered whilst sacrificing some space. Whilst sacrificing some space, redundancy is recovered whilst sacrificing temporal redundancy. Whilst sacrificing temporal redundancy, redundancy is recovered whilst sacrificing some space. Whilst sacrificing some space, redundancy is recovered whilst sacrificing temporal redundancy. Whilst sacrificing temporal redundancy, redundancy is recovered whilst sacrificing some space. Whilst sacrificing some space, redundancy is recovered whilst"}
{"ID": 1866, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: final int updatePublisherLimit() { int workCount = 0; final long senderPosition = this.senderPosition.getVolatile(); if (hasReceivers || (spiesSimulateConnection && spyPositions.length > 0)) { long minConsumerPosition = senderPosition; for (final ReadablePosition spyPosition : spyPositions) { minConsumerPosition = Math.min(minConsumerPosition, spyPosition.getVolatile()); } final long proposedPublisherLimit = minConsumerPosition + termWindowLength; if (publisherLimit.proposeMaxOrdered(proposedPublisherLimit)) { cleanBuffer(proposedPublisherLimit); workCount = 1; } } else if (publisherLimit.get() > senderPosition) { publisherLimit.setOrdered(senderPosition); } return workCount; } \nResponse:", "ground_truth": "Update the publishers limit for flow control as part of the conductor duty cycle.\n\n@return 1 if the limit has been updated otherwise 0.", "predict": " Respond to the arrival of a publisher limit announcement. If my current advertised position plus the largest subsequent announcement is greater than my current publisher limit, propose my current publisher limit plus the largest subsequent announcement to the leader. Otherwise, do nothing. Upon proposing a new limit, initiate cleaning in anticipation of any followers arriving behind my current position. Upon receipt of the limit information, return the number of followers cleaned. @return The number of followers cleaned."}
{"ID": 1867, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static UnsafeBufferPosition allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId, final int sessionId, final int streamId, final String channel) { return new UnsafeBufferPosition( (UnsafeBuffer)countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId, sessionId, streamId, channel), countersManager); } \nResponse:", "ground_truth": "Allocate a counter for tracking a position on a stream of messages.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@param sessionId       for the stream of messages.\n@param streamId        for the stream of messages.\n@param channel         for the stream of messages.\n@return a new {@link UnsafeBufferPosition} for tracking the stream.", "predict": " Allocate a counter for tracking the position of a published stream. Counters are freed up when the publication expires or when the stream is closed. Counters are freed up when the publication expires or when the stream is closed. @param tempBuffer The temporary buffer to use for counters. This will be recycled once the counters have been freed up. @param name The name of the counter being allocated. @param typeId The typeId of the counter being allocated. @param countersManager The counters manager to allocate the counter from. @param registrationId The registrationId of the counters being allocated. @param sessionId The sessionId of the counters being allocated. @param streamId The streamId of the counters being allocated. @param channel The channel of the counters being allocated. @return The allocated counter."}
{"ID": 1868, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String labelName(final int typeId) { switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: return PublisherLimit.NAME; case SenderPos.SENDER_POSITION_TYPE_ID: return SenderPos.NAME; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: return ReceiverHwm.NAME; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: return SubscriberPos.NAME; case ReceiverPos.RECEIVER_POS_TYPE_ID: return ReceiverPos.NAME; case SenderLimit.SENDER_LIMIT_TYPE_ID: return SenderLimit.NAME; case PublisherPos.PUBLISHER_POS_TYPE_ID: return PublisherPos.NAME; case SenderBpe.SENDER_BPE_TYPE_ID: return SenderBpe.NAME; default: return \"<unknown>\"; } } \nResponse:", "ground_truth": "Return the label name for a counter type identifier.\n\n@param typeId of the counter.\n@return the label name as a String.", "predict": " Return the name of the label corresponding to the given type id. @param typeId The type id. @return The corresponding label name."}
{"ID": 1869, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long scanForAvailability(final UnsafeBuffer termBuffer, final int offset, final int maxLength) { final int limit = Math.min(maxLength, termBuffer.capacity() - offset); int available = 0; int padding = 0; do { final int termOffset = offset + available; final int frameLength = frameLengthVolatile(termBuffer, termOffset); if (frameLength <= 0) { break; } int alignedFrameLength = align(frameLength, FRAME_ALIGNMENT); if (isPaddingFrame(termBuffer, termOffset)) { padding = alignedFrameLength - HEADER_LENGTH; alignedFrameLength = HEADER_LENGTH; } available += alignedFrameLength; if (available > limit) { available -= alignedFrameLength; padding = 0; break; } } while (0 == padding && available < limit); return pack(padding, available); } \nResponse:", "ground_truth": "Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes.\n\n@param termBuffer to be scanned for new message fragments.\n@param offset     at which the scan should begin.\n@param maxLength  in bytes of how much should be scanned.\n@return resulting status of the scan which packs the available bytes and padding into a long.", "predict": " Scan ahead to determine if a padding frame exists ahead of the proposed write position. Whilst scanning, the proposed write position will be adjusted if necessary to ensure there is sufficient space to accommodate the padding. @param termBuffer containing the padding frame.\n * @param offset at which the scan begins.\n * @param maxLength maximum length to scan ahead.\n * @return the adjusted write position if a padding frame is found, otherwise the proposed write position.\n */"}
{"ID": 1870, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder clear() { prefix = null; media = null; endpoint = null; networkInterface = null; controlEndpoint = null; controlMode = null; tags = null; alias = null; reliable = null; ttl = null; mtu = null; termLength = null; initialTermId = null; termId = null; termOffset = null; sessionId = null; linger = null; sparse = null; eos = null; tether = null; isSessionIdTagged = false; return this; } \nResponse:", "ground_truth": "Clear out all the values thus setting back to the initial state.\n\n@return this for a fluent API.", "predict": " Clears all previously set immutable options. After this method completes, the builder will contain only mutable runtime options. @return The {@link ChannelUriStringBuilder} that this method was invoked upon. Consequently, this builder may be used to build URIs that contain runtime options."}
{"ID": 1871, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder validate() { if (null == media) { throw new IllegalStateException(\"media type is mandatory\"); } if (CommonContext.UDP_MEDIA.equals(media) && (null == endpoint && null == controlEndpoint)) { throw new IllegalStateException(\"either 'endpoint' or 'control' must be specified for UDP.\"); } int count = 0; count += null == initialTermId ? 0 : 1; count += null == termId ? 0 : 1; count += null == termOffset ? 0 : 1; if (count > 0) { if (count < 3) { throw new IllegalStateException( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\"); } if (termId - initialTermId < 0) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId); } if (null != termLength && termOffset > termLength) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException(\"termOffset=\" + termOffset + \" > termLength=\" + termLength); } } return this; } \nResponse:", "ground_truth": "Validates that the collection of set parameters are valid together.\n\n@return this for a fluent API.\n@throws IllegalStateException if the combination of params is invalid.", "predict": " Validates that the immutable URI components were properly set. Specifically, the following checks are performed: 1) Neither UDP nor TCP media is set without providing at least one of 'endpoint' or 'controlEndpoint'. 2) Neither UDP nor TCP media is set along with providing both 'endpoint' and 'controlEndpoint'. 3) Neither UDP nor TCP media is set along with providing neither 'endpoint' nor 'controlEndpoint'. 4) Neither UDP nor TCP media is set along with providing both 'initialTermId' and 'termId'. 5) Neither UDP nor TCP media is set along with providing both 'termOffset' and 'termLength'. 6) Neither UDP nor TCP media is set along with providing both 'initialTermId' and 'termId'. 7) Neither UDP nor TCP media is set along with providing both 'initialTermId' and 'termOffset'. 8) Neither UDP nor TCP media is set along with providing both 'termId' and 'termOffset'. 9) Neither UDP nor TCP media is set along with providing both"}
{"ID": 1872, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder prefix(final String prefix) { if (null != prefix && !prefix.equals(\"\") && !prefix.equals(SPY_QUALIFIER)) { throw new IllegalArgumentException(\"invalid prefix: \" + prefix); } this.prefix = prefix; return this; } \nResponse:", "ground_truth": "Set the prefix for taking an addition action such as spying on an outgoing publication with \"aeron-spy\".\n\n@param prefix to be applied to the URI before the the scheme.\n@return this for a fluent API.\n@see ChannelUri#SPY_QUALIFIER", "predict": " Sets the URI prefix for subsequent URI additions. @param prefix The prefix to set. May be null or empty to clear the prefix. @return This ChannelUriStringBuilder.\n*/"}
{"ID": 1873, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder media(final String media) { switch (media) { case CommonContext.UDP_MEDIA: case CommonContext.IPC_MEDIA: break; default: throw new IllegalArgumentException(\"invalid media: \" + media); } this.media = media; return this; } \nResponse:", "ground_truth": "Set the media for this channel. Valid values are \"udp\" and \"ipc\".\n\n@param media for this channel.\n@return this for a fluent API.", "predict": " UDP or IPC transports. UDP supports reliable messaging and TCP supports unreliable messaging. For UDP, reliability can be ensured by specifying DurableSubscriptionAvailability. For TCP, reliability can be ensured by specifying DurableSubscriptionAvailability. Durable topics can be subscribed to with Exclusive or Shared durability. Durable topics can be subscribed to with Reliable or NonReliablePublishMode. NonDurable topics can be subscribed to with Exclusive or Shared availability. Durable topics can be subscribed to with Reliable or NonReliablePublishMode. Durable topics can be subscribed to with PreAcknowledgement or NoPreAcknowledgement. NonDurable topics can be subscribed to with Exclusive or Shared availability. Durable topics can be subscribed to with Reliable or NonReliablePublishMode. Durable topics can be subscribed to with PreAcknowledgement or NoPreAcknowledgement. @param media Transport medium. Valid values are UDP or TCP. UDP supports reliable messaging and TCP supports unreliable messaging. Durable topics can be subscribed to with Exclusive or Shared durability. Durable topics can be"}
{"ID": 1874, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder controlMode(final String controlMode) { if (null != controlMode && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_MANUAL) && !controlMode.equals(CommonContext.MDC_CONTROL_MODE_DYNAMIC)) { throw new IllegalArgumentException(\"invalid control mode: \" + controlMode); } this.controlMode = controlMode; return this; } \nResponse:", "ground_truth": "Set the control mode for multi-destination-cast. Set to \"manual\" for allowing control from the publication API.\n\n@param controlMode for taking control of MDC.\n@return this for a fluent API.\n@see Publication#addDestination(String)\n@see Publication#removeDestination(String)\n@see CommonContext#MDC_CONTROL_MODE_PARAM_NAME\n@see CommonContext#MDC_CONTROL_MODE_MANUAL\n@see CommonContext#MDC_CONTROL_MODE_DYNAMIC", "predict": " Sets the Aeron UDP control mode for the Aeron.Client conductor conductor. @param controlMode The UDP control mode for the Aeron.Client conductor conductor. @return this Aeron.ClientBuilder for fluent API building.\n*/"}
{"ID": 1875, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder termLength(final Integer termLength) { if (null != termLength) { LogBufferDescriptor.checkTermLength(termLength); } this.termLength = termLength; return this; } \nResponse:", "ground_truth": "Set the length of buffer used for each term of the log. Valid values are powers of 2 in the 64K - 1G range.\n\n@param termLength of the buffer used for each term of the log.\n@return this for a fluent API.\n@see CommonContext#TERM_LENGTH_PARAM_NAME", "predict": " Sets the maximum allowable length of a term. Once a channel reaches this limit, it will stop accepting more tuples. Increasing the limit increases the memory overhead, but decreases the likelihood of late arriving tuples. Increasing the limit decreases the throughput, but increases latency. Increasing the limit decreases the amount of buffering overhead incurred while delivering tuples. Increasing the limit decreases the amount of buffering overhead incurred while delivering tuples. Increasing the limit decreases the amount of buffering overhead incurred while delivering tuples. Increasing the limit decreases the amount of buffering overhead incurred while delivering tuples. @param termLength The maximum allowable length of a term. @return The updated ChannelUriBuilder.\n*/"}
{"ID": 1876, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder termOffset(final Integer termOffset) { if (null != termOffset) { if ((termOffset < 0 || termOffset > LogBufferDescriptor.TERM_MAX_LENGTH)) { throw new IllegalArgumentException(\"term offset not in range 0-1g: \" + termOffset); } if (0 != (termOffset & (FRAME_ALIGNMENT - 1))) { throw new IllegalArgumentException(\"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset); } } this.termOffset = termOffset; return this; } \nResponse:", "ground_truth": "Set the offset within a term at which a publication will start. This when combined with the term id can establish\na starting position.\n\n@param termOffset within a term at which a publication will start.\n@return this for a fluent API.\n@see CommonContext#TERM_OFFSET_PARAM_NAME", "predict": " Sets the initial offset into the log buffer to commence capture of replicated messages. The offset is relative to the start of the circular log. @param termOffset The offset into the log buffer to commence capture of replicated messages. @return The updated builder.\n*/"}
{"ID": 1877, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ChannelUriStringBuilder linger(final Long lingerNs) { if (null != lingerNs && lingerNs < 0) { throw new IllegalArgumentException(\"linger value cannot be negative: \" + lingerNs); } this.linger = lingerNs; return this; } \nResponse:", "ground_truth": "Set the time a network publication will linger in nanoseconds after being drained. This time is so that tail loss\ncan be recovered.\n\n@param lingerNs time for the publication after it is drained.\n@return this for a fluent API.\n@see CommonContext#LINGER_PARAM_NAME", "predict": " Sets the lingerNs timeout. Increasing the lingerNs decreases the likelihood of lost UDP packets, whereas decreasing the lingerNs decreases latency. Increasing the lingerNs decreases CPU utilization. However, decreasing the lingerNs decreases throughput. Default value is 0. Setting lingerNs to 0 implies disabling lingerNs timeout. @param lingerNs The lingerNs timeout in nano seconds. @return The updated ChannelUriBuilder.\n */"}
{"ID": 1878, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void openDatagramChannel(final AtomicCounter statusIndicator) { try { sendDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); receiveDatagramChannel = sendDatagramChannel; if (udpChannel.isMulticast()) { if (null != connectAddress) { receiveDatagramChannel = DatagramChannel.open(udpChannel.protocolFamily()); } receiveDatagramChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); receiveDatagramChannel.bind(new InetSocketAddress(endPointAddress.getPort())); receiveDatagramChannel.join(endPointAddress.getAddress(), udpChannel.localInterface()); sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_IF, udpChannel.localInterface()); if (udpChannel.isHasMulticastTtl()) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, udpChannel.multicastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } else if (context.socketMulticastTtl() != 0) { sendDatagramChannel.setOption(StandardSocketOptions.IP_MULTICAST_TTL, context.socketMulticastTtl()); multicastTtl = sendDatagramChannel.getOption(StandardSocketOptions.IP_MULTICAST_TTL); } } else { sendDatagramChannel.bind(bindAddress); } if (null != connectAddress) { sendDatagramChannel.connect(connectAddress); } if (0 != context.socketSndbufLength()) { sendDatagramChannel.setOption(SO_SNDBUF, context.socketSndbufLength()); } if (0 != context.socketRcvbufLength()) { receiveDatagramChannel.setOption(SO_RCVBUF, context.socketRcvbufLength()); } sendDatagramChannel.configureBlocking(false); receiveDatagramChannel.configureBlocking(false); } catch (final IOException ex) { if (null != statusIndicator) { statusIndicator.setOrdered(ChannelEndpointStatus.ERRORED); } CloseHelper.quietClose(sendDatagramChannel); if (receiveDatagramChannel != sendDatagramChannel) { CloseHelper.quietClose(receiveDatagramChannel); } sendDatagramChannel = null; receiveDatagramChannel = null; throw new AeronException( \"channel error - \" + ex.getMessage() + \" (at \" + ex.getStackTrace()[0].toString() + \"): \" + udpChannel.originalUriString(), ex); } } \nResponse:", "ground_truth": "Create the underlying channel for reading and writing.\n\n@param statusIndicator to set for error status", "predict": " Open UDP datagram channel.\n*/"}
{"ID": 1879, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (!isClosed) { isClosed = true; try { if (null != selectionKey) { selectionKey.cancel(); } if (null != transportPoller) { transportPoller.cancelRead(this); transportPoller.selectNowWithoutProcessing(); } if (null != sendDatagramChannel) { sendDatagramChannel.close(); } if (receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel) { receiveDatagramChannel.close(); } if (null != transportPoller) { transportPoller.selectNowWithoutProcessing(); } } catch (final IOException ex) { errorLog.record(ex); } } } \nResponse:", "ground_truth": "Close transport, canceling any pending read operations and closing channel", "predict": " Close this UDPConnection. This will prevent further reads and writes, but existing ones will continue. Once closed, no further reads or writes will be attempted. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does not affect the underlying UDPChannel. Closing a UDPConnection does"}
{"ID": 1880, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isValidFrame(final UnsafeBuffer buffer, final int length) { boolean isFrameValid = true; if (frameVersion(buffer, 0) != HeaderFlyweight.CURRENT_VERSION) { isFrameValid = false; invalidPackets.increment(); } else if (length < HeaderFlyweight.MIN_HEADER_LENGTH) { isFrameValid = false; invalidPackets.increment(); } return isFrameValid; } \nResponse:", "ground_truth": "Is the received frame valid. This method will do some basic checks on the header and can be\noverridden in a subclass for further validation.\n\n@param buffer containing the frame.\n@param length of the frame.\n@return true if the frame is believed valid otherwise false.", "predict": " Checks if the frame is valid or not. Frames that fail this check are rejected.\n * @param buffer containing the frame.\n * @param length of the frame in bytes.\n * @return true if the frame is valid otherwise false.\n */"}
{"ID": 1881, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public InetSocketAddress receive(final ByteBuffer buffer) { buffer.clear(); InetSocketAddress address = null; try { if (receiveDatagramChannel.isOpen()) { address = (InetSocketAddress)receiveDatagramChannel.receive(buffer); } } catch (final PortUnreachableException ignored) { } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } return address; } \nResponse:", "ground_truth": "Receive a datagram from the media layer.\n\n@param buffer into which the datagram will be received.\n@return the source address of the datagram if one is available otherwise false.", "predict": " Receives a datagram packet addressed to the local address. The buffer will be cleared upon receipt. @param buffer The buffer to receive the datagram packet into. @return The datagram packet address."}
{"ID": 1882, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void onNak( final int termId, final int termOffset, final int length, final int termLength, final RetransmitSender retransmitSender) { if (!isInvalid(termOffset, termLength)) { if (null == activeRetransmitsMap.get(termId, termOffset) && activeRetransmitsMap.size() < MAX_RETRANSMITS_DEFAULT) { final RetransmitAction action = assignRetransmitAction(); action.termId = termId; action.termOffset = termOffset; action.length = Math.min(length, termLength - termOffset); final long delay = delayGenerator.generateDelay(); if (0 == delay) { retransmitSender.resend(termId, termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else { action.delay(delay, nanoClock.nanoTime()); } activeRetransmitsMap.put(termId, termOffset, action); } } } \nResponse:", "ground_truth": "Called on reception of a NAK to start retransmits handling.\n\n@param termId           from the NAK and the term id of the buffer to retransmit from\n@param termOffset       from the NAK and the offset of the data to retransmit\n@param length           of the missing data\n@param termLength       of the term buffer.\n@param retransmitSender to call if an immediate retransmit is required", "predict": " Called when a NAK frame arrives. Drops acknowledged messages and initiates acknowledgements for unacknowledged messages. Drops trailing messages past the ACK'd term boundary. @param termId The requesting Term. @param termOffset The offset in the term at which the NAK arrived. @param length The length of the NAK payload. @param termLength The length of the entire term. */"}
{"ID": 1883, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void processTimeouts(final long nowNs, final RetransmitSender retransmitSender) { if (activeRetransmitsMap.size() > 0) { for (final RetransmitAction action : retransmitActionPool) { if (DELAYED == action.state && (action.expireNs - nowNs < 0)) { retransmitSender.resend(action.termId, action.termOffset, action.length); action.linger(lingerTimeoutGenerator.generateDelay(), nanoClock.nanoTime()); } else if (LINGERING == action.state && (action.expireNs - nowNs < 0)) { action.cancel(); activeRetransmitsMap.remove(action.termId, action.termOffset); } } } } \nResponse:", "ground_truth": "Called to process any outstanding timeouts.\n\n@param nowNs            time in nanoseconds\n@param retransmitSender to call on retransmissions", "predict": " Process expired retransmit requests. Typically occurs once per tick. Responsible for removing expired requests and sending any packets that have expired timers. Typically occurs after tick.\n@param nowNs The current time in nanoseconds.\n*/"}
{"ID": 1884, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String status(final long status) { if (INITIALIZING == status) { return \"INITIALIZING\"; } if (ERRORED == status) { return \"ERRORED\"; } if (ACTIVE == status) { return \"ACTIVE\"; } if (CLOSING == status) { return \"CLOSING\"; } return \"unknown id=\" + status; } \nResponse:", "ground_truth": "String representation of the channel status.\n\n@param status to be converted.\n@return representation of the channel status.", "predict": " Translate the given status to a human readable string. @param status The status to translate. @return The translated status.\n*/"}
{"ID": 1885, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final String channel) { final int keyLength = tempBuffer.putStringWithoutLengthAscii( CHANNEL_OFFSET + SIZE_OF_INT, channel, 0, MAX_CHANNEL_LENGTH); tempBuffer.putInt(CHANNEL_OFFSET, keyLength); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, name); labelLength += tempBuffer.putStringWithoutLengthAscii(keyLength + labelLength, \": \"); labelLength += tempBuffer.putStringWithoutLengthAscii( keyLength + labelLength, channel, 0, MAX_LABEL_LENGTH - labelLength); return countersManager.newCounter(typeId, tempBuffer, 0, keyLength, tempBuffer, keyLength, labelLength); } \nResponse:", "ground_truth": "Allocate an indicator for tracking the status of a channel endpoint.\n\n@param tempBuffer      to be used for labels and metadata.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param channel         for the stream of messages.\n@return a new {@link AtomicCounter} for tracking the status.", "predict": " Allocate a counter with a channel name and a label. The channel name will be truncated to MAX_CHANNEL_LENGTH characters. The label will be truncated to MAX_LABEL_LENGTH characters. The counter will be created in the CountersManager passed in. The counter will be created with a key formed by concatenating the channel name and the label. The counter will be created with a typeId of COUNTER_TYPE_ID. The counter will be created with a lifespan of Lifetime.FOREVER. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The counter will be initially unlocked. The"}
{"ID": 1886, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirectBufferVector reset(final DirectBuffer buffer, final int offset, final int length) { this.buffer = buffer; this.offset = offset; this.length = length; return this; } \nResponse:", "ground_truth": "Reset the values.\n\n@param buffer which is the super set.\n@param offset at which the vector begins.\n@param length of the vector.\n@return this for a fluent API.", "predict": " Reset the vector to point to the supplied buffer and offset/length. Useful for poking at internals. @param buffer DirectBuffer to point to @param offset Offset into the buffer @param length Length of the section to point to @return This vector for fluency"}
{"ID": 1887, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public DirectBufferVector validate() { final int capacity = buffer.capacity(); if (offset < 0 || offset >= capacity) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity); } if (length < 0 || length > (capacity - offset)) { throw new IllegalArgumentException(\"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length); } return this; } \nResponse:", "ground_truth": "Ensure the vector is valid for the buffer.\n\n@throws NullPointerException if the buffer is null.\n@throws IllegalArgumentException if the offset is out of range for the buffer.\n@throws IllegalArgumentException if the length is out of range for the buffer.\n@return this for a fluent API.", "predict": " Validate that the vector has been correctly initialised. @return this vector"}
{"ID": 1888, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int validateAndComputeLength(final DirectBufferVector[] vectors) { int messageLength = 0; for (final DirectBufferVector vector : vectors) { vector.validate(); messageLength += vector.length; if (messageLength < 0) { throw new IllegalStateException(\"length overflow: \" + Arrays.toString(vectors)); } } return messageLength; } \nResponse:", "ground_truth": "Validate an array of vectors to make up a message and compute the total length.\n\n@param vectors to be validated summed.\n@return the sum of the vector lengths.", "predict": " Validate and compute the total length of the DirectBufferVectors contained within the vectors array. Whilst attempting to maintain the immutability of the DirectBufferVectors, this method will alter the DirectBufferVectors in the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immutability, this method will also maintain integrity of the integrity of the DirectBufferVectors contained within the array. Whilst maintaining immut"}
{"ID": 1889, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int producerWindowLength(final int termBufferLength, final int defaultTermWindowLength) { int termWindowLength = termBufferLength / 2; if (0 != defaultTermWindowLength) { termWindowLength = Math.min(defaultTermWindowLength, termWindowLength); } return termWindowLength; } \nResponse:", "ground_truth": "How far ahead a producer can get from a consumer position.\n\n@param termBufferLength        for when default is not set and considering an appropriate minimum.\n@param defaultTermWindowLength to take priority.\n@return the length to be used for the producer window.", "predict": " Calculate the producer window length. @param termBufferLength the term buffer length @param defaultTermWindowLength the default term window length @return the producer window length\n*/"}
{"ID": 1890, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateSocketBufferLengths(final MediaDriver.Context ctx) { try (DatagramChannel probe = DatagramChannel.open()) { final int defaultSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); probe.setOption(StandardSocketOptions.SO_SNDBUF, Integer.MAX_VALUE); final int maxSoSndBuf = probe.getOption(StandardSocketOptions.SO_SNDBUF); if (maxSoSndBuf < ctx.socketSndbufLength()) { System.err.format( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.socketSndbufLength(), maxSoSndBuf); } probe.setOption(StandardSocketOptions.SO_RCVBUF, Integer.MAX_VALUE); final int maxSoRcvBuf = probe.getOption(StandardSocketOptions.SO_RCVBUF); if (maxSoRcvBuf < ctx.socketRcvbufLength()) { System.err.format( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\", SOCKET_RCVBUF_LENGTH_PROP_NAME, ctx.socketRcvbufLength(), maxSoRcvBuf); } final int soSndBuf = 0 == ctx.socketSndbufLength() ? defaultSoSndBuf : ctx.socketSndbufLength(); if (ctx.mtuLength() > soSndBuf) { throw new ConfigurationException(String.format( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\", SOCKET_SNDBUF_LENGTH_PROP_NAME, ctx.mtuLength(), soSndBuf)); } if (ctx.initialWindowLength() > maxSoRcvBuf) { throw new ConfigurationException(\"window length greater than socket SO_RCVBUF, increase '\" + Configuration.INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx.initialWindowLength() + \", SO_RCVBUF=\" + maxSoRcvBuf); } } catch (final IOException ex) { throw new AeronException(\"probe socket: \" + ex.toString(), ex); } } \nResponse:", "ground_truth": "Validate that the socket buffer lengths are sufficient for the media driver configuration.\n\n@param ctx to be validated.", "predict": " Validate that Aeron MTU and socket buffer lengths are agreeable.\n*/"}
{"ID": 1891, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validatePageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new ConfigurationException( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new ConfigurationException( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new ConfigurationException(\"page size not a power of 2: \" + pageSize); } } \nResponse:", "ground_truth": "Validate that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws ConfigurationException if the size is not as expected.", "predict": " Validate the page size. @param pageSize The page size.\n*/"}
{"ID": 1892, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateSessionIdRange(final int low, final int high) { if (low > high) { throw new ConfigurationException(\"low session id value \" + low + \" must be <= high value \" + high); } if (Math.abs((long)high - low) > Integer.MAX_VALUE) { throw new ConfigurationException(\"reserved range to too large\"); } } \nResponse:", "ground_truth": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping.\n\n@param low  value in the range.\n@param high value in the range.\n@throws ConfigurationException if the values are not valid.", "predict": " Validate that the low session id value is <= high value. Also check that the reserved high value is not too large. @param low Low session id value. @param high High session id value."}
{"ID": 1893, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateUnblockTimeout( final long publicationUnblockTimeoutNs, final long clientLivenessTimeoutNs, final long timerIntervalNs) { if (publicationUnblockTimeoutNs <= clientLivenessTimeoutNs) { throw new ConfigurationException( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs); } if (clientLivenessTimeoutNs <= timerIntervalNs) { throw new ConfigurationException( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs); } } \nResponse:", "ground_truth": "Validate that the timeouts for unblocking publications from a client are valid.\n\n@param publicationUnblockTimeoutNs after which an uncommitted publication will be unblocked.\n@param clientLivenessTimeoutNs     after which a client will be considered not alive.\n@param timerIntervalNs             interval at which the driver will check timeouts.\n@throws ConfigurationException if the values are not valid.", "predict": " Ensures that the publication unblock timeout is greater than the client liveness timeout. Also ensures that the timer interval is greater than the publication unblock timeout. @param publicationUnblockTimeoutNs The publication unblock timeout in nanoseconds. @param clientLivenessTimeoutNs The client liveness timeout in nanoseconds. @param timerIntervalNs The timer interval in nanoseconds."}
{"ID": 1894, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ErrorResponseFlyweight errorCode(final ErrorCode code) { buffer.putInt(offset + ERROR_CODE_OFFSET, code.value()); return this; } \nResponse:", "ground_truth": "Set the error code for the command.\n\n@param code for the error\n@return flyweight", "predict": " Provide the error code for the Aeron exception. @param code to be set into the buffer. @return this flyweight for fluent API style.\n*/"}
{"ID": 1895, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void reset() { isBallotSent = false; isLeader = false; hasRequestedJoin = false; hasSentTerminationAck = false; vote = null; candidateTermId = Aeron.NULL_VALUE; leadershipTermId = Aeron.NULL_VALUE; logPosition = NULL_POSITION; } \nResponse:", "ground_truth": "Reset the state of a cluster member so it can be canvassed and reestablished.", "predict": " Reset the election outcome counters.\n*/"}
{"ID": 1896, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static String encodeAsString(final ClusterMember[] clusterMembers) { final StringBuilder builder = new StringBuilder(); for (int i = 0, length = clusterMembers.length; i < length; i++) { final ClusterMember member = clusterMembers[i]; builder .append(member.id()) .append(',') .append(member.endpointsDetail()); if ((length - 1) != i) { builder.append('|'); } } return builder.toString(); } \nResponse:", "ground_truth": "Encode member details from a cluster members array to a string.\n\n@param clusterMembers to fill the details from\n@return String representation suitable for use with {@link ClusterMember#parse}", "predict": " Serialize the ClusterMember[] to a comma separated string. Useful for passing around as a JSON object. @param clusterMembers The ClusterMembers to serialize. @return The serialized string."}
{"ID": 1897, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void addMemberStatusPublications( final ClusterMember[] members, final ClusterMember exclude, final ChannelUri channelUri, final int streamId, final Aeron aeron) { for (final ClusterMember member : members) { if (member != exclude) { channelUri.put(ENDPOINT_PARAM_NAME, member.memberFacingEndpoint()); member.publication = aeron.addExclusivePublication(channelUri.toString(), streamId); } } } \nResponse:", "ground_truth": "Add the publications for sending status messages to the other members of the cluster.\n\n@param members    of the cluster.\n@param exclude    this member when adding publications.\n@param channelUri for the publication.\n@param streamId   for the publication.\n@param aeron      to add the publications to.", "predict": " Add Publication to each member of the cluster except exclude member. @param members Members of the cluster. @param exclude Exclude member. @param channelUri Channel URI to connect to. @param streamId Stream ID to connect to. @param aeron Aeron instance to connect to."}
{"ID": 1898, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void closeMemberPublications(final ClusterMember[] clusterMembers) { for (final ClusterMember member : clusterMembers) { CloseHelper.close(member.publication); } } \nResponse:", "ground_truth": "Close the publications associated with members of the cluster.\n\n@param clusterMembers to close the publications for.", "predict": " Properly close publications for all members. @param clusterMembers Members to close publications for."}
{"ID": 1899, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasActiveQuorum( final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs) { int threshold = quorumThreshold(clusterMembers.length); for (final ClusterMember member : clusterMembers) { if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs)) { if (--threshold <= 0) { return true; } } } return false; } \nResponse:", "ground_truth": "Check if the cluster leader has an active quorum of cluster followers.\n\n@param clusterMembers for the current cluster.\n@param nowMs          for the current time.\n@param timeoutMs      after which a follower is not considered active.\n@return true if quorum of cluster members are considered active.", "predict": " Checks if there is an active quorum amongst the cluster members. @param clusterMembers The cluster members. @param nowMs The current time in milliseconds. @param timeoutMs The maximum allowable time in milliseconds. @return True if there is an active quorum amongst the cluster members. False otherwise."}
{"ID": 1900, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long quorumPosition(final ClusterMember[] members, final long[] rankedPositions) { final int length = rankedPositions.length; for (int i = 0; i < length; i++) { rankedPositions[i] = 0; } for (final ClusterMember member : members) { long newPosition = member.logPosition; for (int i = 0; i < length; i++) { final long rankedPosition = rankedPositions[i]; if (newPosition > rankedPosition) { rankedPositions[i] = newPosition; newPosition = rankedPosition; } } } return rankedPositions[length - 1]; } \nResponse:", "ground_truth": "Calculate the position reached by a quorum of cluster members.\n\n@param members         of the cluster.\n@param rankedPositions temp array to be used for sorting the positions to avoid allocation.\n@return the position reached by a quorum of cluster members.", "predict": " Rank the positions of the cluster members based on their log positions. Ranked positions are used to determine which member should become the leader. @param members The cluster members. @param rankedPositions The ranked positions of the cluster members. @return The highest ranked position.\n*/"}
{"ID": 1901, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void resetLogPositions(final ClusterMember[] clusterMembers, final long logPosition) { for (final ClusterMember member : clusterMembers) { member.logPosition(logPosition); } } \nResponse:", "ground_truth": "Reset the log position of all the members to the provided value.\n\n@param clusterMembers to be reset.\n@param logPosition    to set for them all.", "predict": " Reset the log positions of all members in the cluster. Useful for recovering from a crash. @param clusterMembers The cluster members. @param logPosition The new log position."}
{"ID": 1902, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean haveVotersReachedPosition( final ClusterMember[] clusterMembers, final long position, final long leadershipTermId) { for (final ClusterMember member : clusterMembers) { if (member.vote != null && (member.logPosition < position || member.leadershipTermId != leadershipTermId)) { return false; } } return true; } \nResponse:", "ground_truth": "Has the members of the cluster the voted reached the provided position in their log.\n\n@param clusterMembers   to check.\n@param position         to compare the {@link #logPosition()} against.\n@param leadershipTermId expected of the members.\n@return true if all members have reached this position otherwise false.", "predict": " Have voters reached their positions? @param clusterMembers The cluster members. @param position The position. @param leadershipTermId The leadership term id. @return True if have reached positions. False otherwise."}
{"ID": 1903, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasWonVoteOnFullCount(final ClusterMember[] members, final long candidateTermId) { int votes = 0; for (final ClusterMember member : members) { if (null == member.vote || member.candidateTermId != candidateTermId) { return false; } votes += member.vote ? 1 : 0; } return votes >= ClusterMember.quorumThreshold(members.length); } \nResponse:", "ground_truth": "Has the candidate got unanimous support of the cluster?\n\n@param members         to check for votes.\n@param candidateTermId for the vote.\n@return false if any member has not voted for the candidate.", "predict": " Votes cast on a candidate's vote tally meets the quorum threshold. @param members Candidate members. @param candidateTermId Candidate term ID. @return True if the candidate meets the quorum threshold. False otherwise."}
{"ID": 1904, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasMajorityVote(final ClusterMember[] clusterMembers, final long candidateTermId) { int votes = 0; for (final ClusterMember member : clusterMembers) { if (Boolean.TRUE.equals(member.vote) && member.candidateTermId == candidateTermId) { ++votes; } } return votes >= ClusterMember.quorumThreshold(clusterMembers.length); } \nResponse:", "ground_truth": "Has sufficient votes being counted for a majority?\n\n@param clusterMembers  to check for votes.\n@param candidateTermId for the vote.\n@return true if a majority of positive votes.", "predict": " Returns true if majority of cluster members voted YES for the candidate term. @param clusterMembers The cluster members. @param candidateTermId The candidate term id. @return True if majority of cluster members voted YES for the candidate term."}
{"ID": 1905, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClusterMember determineMember( final ClusterMember[] clusterMembers, final int memberId, final String memberEndpoints) { ClusterMember member = NULL_VALUE != memberId ? ClusterMember.findMember(clusterMembers, memberId) : null; if ((null == clusterMembers || 0 == clusterMembers.length) && null == member) { member = ClusterMember.parseEndpoints(NULL_VALUE, memberEndpoints); } else { if (null == member) { throw new ClusterException(\"memberId=\" + memberId + \" not found in clusterMembers\"); } if (!\"\".equals(memberEndpoints)) { ClusterMember.validateMemberEndpoints(member, memberEndpoints); } } return member; } \nResponse:", "ground_truth": "Determine which member of a cluster this is and check endpoints.\n\n@param clusterMembers  for the current cluster which can be null.\n@param memberId        for this member.\n@param memberEndpoints for this member.\n@return the {@link ClusterMember} determined.", "predict": " Determine the cluster member based on the memberId and memberEndpoints. MemberEndpoints are validated. MemberId is optional. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints are validated if present. MemberId is validated if present. MemberEndpoints"}
{"ID": 1906, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void validateMemberEndpoints(final ClusterMember member, final String memberEndpoints) { final ClusterMember endpointMember = ClusterMember.parseEndpoints(Aeron.NULL_VALUE, memberEndpoints); if (!areSameEndpoints(member, endpointMember)) { throw new ClusterException( \"clusterMembers and memberEndpoints differ: \" + member.endpointsDetail() + \" != \" + memberEndpoints); } } \nResponse:", "ground_truth": "Check the member with the memberEndpoints\n\n@param member          to check memberEndpoints against\n@param memberEndpoints to check member against\n@see ConsensusModule.Context#memberEndpoints()\n@see ConsensusModule.Context#clusterMembers()", "predict": " Validate that the memberEndpoints are the same as the ClusterMember details. @param member ClusterMember to validate against. @param memberEndpoints MemberEndpoints to validate against."}
{"ID": 1907, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean areSameEndpoints(final ClusterMember lhs, final ClusterMember rhs) { return lhs.clientFacingEndpoint().equals(rhs.clientFacingEndpoint()) && lhs.memberFacingEndpoint().equals(rhs.memberFacingEndpoint()) && lhs.logEndpoint().equals(rhs.logEndpoint()) && lhs.transferEndpoint().equals(rhs.transferEndpoint()) && lhs.archiveEndpoint().equals(rhs.archiveEndpoint()); } \nResponse:", "ground_truth": "Are two cluster members using the same endpoints?\n\n@param lhs to check\n@param rhs to check\n@return true if both are using the same endpoints or false if not.", "predict": " Returns true if the two members are functionally equivalent. Two members are functionally equivalent if they have the same logical identity. That is, they must have the same IP address and ports, but they may have different SSL contexts. Two members are functionally equivalent if they have the same SSL context. Two members are functionally equivalent if they have the same archive endpoint. Two members are functionally equivalent if they have the same transfer endpoint. Two members are functionally equivalent if they have the same log endpoint. Two members are functionally equivalent if they have the same member facing endpoint. Two members are functionally equivalent if they have the same client facing endpoint. Two members are functionally equivalent if they have the same UDP port. Two members are functionally equivalent if they have the same UDP multicast group. Two members are functionally equivalent if they have the same UDP multicast TTL. Two members are functionally equivalent if they have the same UDP multicast TTL. Two members are functionally equivalent if they have the same UDP multicast TTL. Two members are functionally equivalent if they have the same UDP multicast TTL. Two members are functionally"}
{"ID": 1908, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isUnanimousCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { return false; } } return true; } \nResponse:", "ground_truth": "Has the member achieved a unanimous view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " Checks if unanimous agreement has been reached on the candidate position among the cluster members. @param clusterMembers Members of the cluster. @param candidate Candidate cluster member. @return True if unanimous agreement has been reached on the candidate position among the cluster members. False otherwise."}
{"ID": 1909, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isQuorumCandidate(final ClusterMember[] clusterMembers, final ClusterMember candidate) { int possibleVotes = 0; for (final ClusterMember member : clusterMembers) { if (NULL_POSITION == member.logPosition || compareLog(candidate, member) < 0) { continue; } ++possibleVotes; } return possibleVotes >= ClusterMember.quorumThreshold(clusterMembers.length); } \nResponse:", "ground_truth": "Has the member achieved a quorum view to be a suitable candidate in an election.\n\n@param clusterMembers to compare the candidate against.\n@param candidate      for leadership.\n@return true if the candidate is suitable otherwise false.", "predict": " Determine whether the candidate meets the quorum requirements for becoming a leader. @param clusterMembers Members of the cluster. @param candidate Candidate to evaluate. @return True if the candidate meets the quorum requirements for becoming a leader. False otherwise."}
{"ID": 1910, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isNotDuplicateEndpoints(final ClusterMember[] members, final String memberEndpoints) { for (final ClusterMember member : members) { if (member.endpointsDetail().equals(memberEndpoints)) { return false; } } return true; } \nResponse:", "ground_truth": "Is the string of member endpoints not duplicated in the members.\n\n@param members         to check if the provided endpoints have a duplicate.\n@param memberEndpoints to check for duplicates.\n@return true if no duplicate is found otherwise false.", "predict": " Checks if the given member endpoints are not duplicated among the members. @param members Members to check. @param memberEndpoints Member endpoints to check. @return True if the given member endpoints are not duplicated among the members, false otherwise."}
{"ID": 1911, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findMemberIndex(final ClusterMember[] clusterMembers, final int memberId) { final int length = clusterMembers.length; int index = ArrayUtil.UNKNOWN_INDEX; for (int i = 0; i < length; i++) { if (clusterMembers[i].id() == memberId) { index = i; } } return index; } \nResponse:", "ground_truth": "Find the index at which a member id is present.\n\n@param clusterMembers to be searched.\n@param memberId       to search for.\n@return the index at which the member id is found otherwise {@link ArrayUtil#UNKNOWN_INDEX}.", "predict": " Finds the index of the cluster member with the given id. @param clusterMembers The cluster members. @param memberId The id of the cluster member to find. @return The index of the cluster member or {@link ArrayUtil#UNKNOWN_INDEX} if not found.\n*/"}
{"ID": 1912, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static ClusterMember[] removeMember(final ClusterMember[] oldMembers, final int memberId) { return ArrayUtil.remove(oldMembers, findMemberIndex(oldMembers, memberId)); } \nResponse:", "ground_truth": "Remove a member from an array if found, otherwise return the array unmodified.\n\n@param oldMembers to remove a member from.\n@param memberId   of the member to remove.\n@return a new array with the member removed or the existing array if not found.", "predict": " Remove a member from the array. @param oldMembers Members to remove member from. @param memberId Member to remove. @return Members without the memberId.\n*/"}
{"ID": 1913, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int highMemberId(final ClusterMember[] clusterMembers) { int highId = Aeron.NULL_VALUE; for (final ClusterMember member : clusterMembers) { highId = Math.max(highId, member.id()); } return highId; } \nResponse:", "ground_truth": "Find the highest member id in an array of members.\n\n@param clusterMembers to search for the highest id.\n@return the highest id otherwise {@link Aeron#NULL_VALUE} if empty.", "predict": " Find the highest Member id in the array. @param clusterMembers Members in the cluster. @return Highest Member id in the array.\n*/"}
{"ID": 1914, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public MappedByteBuffer mapExistingCncFile(final Consumer<String> logger) { final File cncFile = new File(aeronDirectory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { if (null != logger) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); } return IoUtil.mapExistingFile(cncFile, CncFileDescriptor.CNC_FILE); } return null; } \nResponse:", "ground_truth": "Map the CnC file if it exists.\n\n@param logger for feedback\n@return a new mapping for the file if it exists otherwise null;", "predict": " Map the existing Aeron CnC file. @param logger to log warnings @return the mapped byte buffer or null if none found\n*/"}
{"ID": 1915, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isDriverActive( final File directory, final long driverTimeoutMs, final Consumer<String> logger) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { logger.accept(\"INFO: Aeron CnC file exists: \" + cncFile); final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } return false; } \nResponse:", "ground_truth": "Is a media driver active in the given directory?\n\n@param directory       to check\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " Determine if the driver is active by examining the CnC file. @param directory Aeron directory @param driverTimeoutMs driver timeout in milliseconds @param logger to report any warnings or errors to\n * @return true if the driver is active otherwise false\n */"}
{"ID": 1916, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public boolean isDriverActive(final long driverTimeoutMs, final Consumer<String> logger) { final MappedByteBuffer cncByteBuffer = mapExistingCncFile(logger); try { return isDriverActive(driverTimeoutMs, logger, cncByteBuffer); } finally { IoUtil.unmap(cncByteBuffer); } } \nResponse:", "ground_truth": "Is a media driver active in the current Aeron directory?\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@return true if a driver is active or false if not.", "predict": " Checks if the driver is still alive. The driver is considered alive as soon as it has been activated within the driver timeout period. Drivers that have never been activated will always return false. Drivers that have been activated but have expired will return false. Drivers that have been activated and haven't expired yet will return true. Drivers that have been activated and haven't expired yet will return true. @param driverTimeoutMs The driverTimeoutMs to use for determining driver liveness. Drivers that have been activated and haven't expired yet will be considered alive until they've expired. Drivers that have been activated but haven't expired yet will be considered alive until they've been deactivated. Drivers that have been activated but haven't expired yet will be considered alive until they've been deactivated. @param logger The logger to use for logging lifecycle information. @return True if the driver is still alive, false otherwise."}
{"ID": 1917, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isDriverActive( final long driverTimeoutMs, final Consumer<String> logger, final ByteBuffer cncByteBuffer) { if (null == cncByteBuffer) { return false; } final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final long startTimeMs = System.currentTimeMillis(); int cncVersion; while (0 == (cncVersion = cncMetaDataBuffer.getIntVolatile(CncFileDescriptor.cncVersionOffset(0)))) { if (System.currentTimeMillis() > (startTimeMs + driverTimeoutMs)) { throw new DriverTimeoutException(\"CnC file is created but not initialised.\"); } sleep(1); } if (CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long timestamp = toDriverBuffer.consumerHeartbeatTime(); final long now = System.currentTimeMillis(); final long timestampAge = now - timestamp; logger.accept(\"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge); return timestampAge <= driverTimeoutMs; } \nResponse:", "ground_truth": "Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait for\nup to the driverTimeoutMs by checking for the cncVersion being set.\n\n@param driverTimeoutMs for the driver liveness check.\n@param logger          for feedback as liveness checked.\n@param cncByteBuffer   for the existing CnC file.\n@return true if a driver is active or false if not.", "predict": " Is the driver active? Controlled by timeout. Controlled by cncByteBuffer. Controlled by cncMetaDataBuffer. Controlled by cncVersion. Controlled by consumerHeartbeatTime. Controlled by now. Controlled by timestampAge. Controlled by driverTimeoutMs. Controlled by logger. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName. Controlled by aeronDirectoryName"}
{"ID": 1918, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean requestDriverTermination( final File directory, final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { final File cncFile = new File(directory, CncFileDescriptor.CNC_FILE); if (cncFile.exists() && cncFile.length() > 0) { final MappedByteBuffer cncByteBuffer = IoUtil.mapExistingFile(cncFile, \"CnC file\"); try { final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor.createMetaDataBuffer(cncByteBuffer); final int cncVersion = cncMetaDataBuffer.getIntVolatile(cncVersionOffset(0)); if (CncFileDescriptor.CNC_VERSION != cncVersion) { throw new AeronException( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion); } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer( CncFileDescriptor.createToDriverBuffer(cncByteBuffer, cncMetaDataBuffer)); final long clientId = toDriverBuffer.nextCorrelationId(); final DriverProxy driverProxy = new DriverProxy(toDriverBuffer, clientId); return driverProxy.terminateDriver(tokenBuffer, tokenOffset, tokenLength); } finally { IoUtil.unmap(cncByteBuffer); } } return false; } \nResponse:", "ground_truth": "Request a driver to run its termination hook.\n\n@param directory for the driver.\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return true if request was sent or false if request could not be sent.", "predict": " Request driver termination from conductor. @param directory Aeron directory @param tokenBuffer containing the driver token @param tokenOffset offset of driver token in buffer @param tokenLength length of driver token in buffer @return true if driver was successfully terminated\n*/"}
{"ID": 1919, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int frameLengthVolatile(final UnsafeBuffer buffer, final int termOffset) { int frameLength = buffer.getIntVolatile(termOffset); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } return frameLength; } \nResponse:", "ground_truth": "Get the length of a frame from the header as a volatile read.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@return the value for the frame length.", "predict": " Volatile version of frame length. @param buffer to read the frame length from @param termOffset to read the frame length from @return frame length\n*/"}
{"ID": 1920, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameLengthOrdered(final UnsafeBuffer buffer, final int termOffset, final int frameLength) { int length = frameLength; if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { length = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(termOffset, length); } \nResponse:", "ground_truth": "Write the length header for a frame in a memory ordered fashion.\n\n@param buffer      containing the frame.\n@param termOffset  at which a frame begins.\n@param frameLength field to be set for the frame.", "predict": " Encode the length field in frame header which is always BE ordered. The length field is comprised of 4 bytes holding the length of the frame payload plus 4 bytes for the CRC. The CRC is always BE ordered.\n * @param buffer The buffer to encode into\n * @param termOffset The offset of the current term\n * @param frameLength The length of the current frame payload\n */"}
{"ID": 1921, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameType(final UnsafeBuffer buffer, final int termOffset, final int type) { buffer.putShort(typeOffset(termOffset), (short)type, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the type field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param type       type value for the frame.", "predict": " Write the frame type to the buffer at the given offset. The type occupies two bytes in the ring buffer. @param buffer to write to @param termOffset offset into the buffer @param type to write to the buffer\n */"}
{"ID": 1922, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameFlags(final UnsafeBuffer buffer, final int termOffset, final byte flags) { buffer.putByte(flagsOffset(termOffset), flags); } \nResponse:", "ground_truth": "Write the flags field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param flags      value for the frame.", "predict": " Writes the flags for a single frame to the buffer. The flags are stored in the same locations as the termOffset and frameLength so this provides efficient means of updating both at the same time. @param buffer The buffer into which the flags will be written. @param termOffset The offset of the frame within the term. @param flags The flags for the frame."}
{"ID": 1923, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameTermOffset(final UnsafeBuffer buffer, final int termOffset) { buffer.putInt(termOffsetOffset(termOffset), termOffset, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the term offset field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.", "predict": " Write the supplied term offset to the buffer.\n * @param buffer The buffer to write to.\n * @param termOffset The offset to write to the buffer.\n */"}
{"ID": 1924, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void frameTermId(final UnsafeBuffer buffer, final int termOffset, final int termId) { buffer.putInt(termIdOffset(termOffset), termId, LITTLE_ENDIAN); } \nResponse:", "ground_truth": "Write the term id field for a frame.\n\n@param buffer     containing the frame.\n@param termOffset at which a frame begins.\n@param termId     value for the frame.", "predict": " Writes the supplied term id to the frame at the supplied offset. Guaranteed to be aligned. @param buffer to write to @param termOffset at which to write the term id @param termId to write to the buffer */"}
{"ID": 1925, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterIdByRecording(final CountersReader countersReader, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for a stream based on the recording id.\n\n@param countersReader to search within.\n@param recordingId    for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Searches for the counter id of the given recording. @param countersReader to search in @param recordingId to search for @return counter id of the recording or NULL_COUNTER_ID if no counter was found\n*/"}
{"ID": 1926, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterIdBySession(final CountersReader countersReader, final int sessionId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); for (int i = 0, size = countersReader.maxCounterId(); i < size; i++) { if (countersReader.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SESSION_ID_OFFSET) == sessionId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for a stream based on the session id.\n\n@param countersReader to search within.\n@param sessionId      for the active recording.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find counter id by session id. @param countersReader counters reader @param sessionId session id @return counter id\n*/"}
{"ID": 1927, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getRecordingId(final CountersReader countersReader, final int counterId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID) { return buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET); } } return NULL_RECORDING_ID; } \nResponse:", "ground_truth": "Get the recording id for a given counter id.\n\n@param countersReader to search within.\n@param counterId      for the active recording.\n@return the counter id if found otherwise {@link #NULL_RECORDING_ID}.", "predict": " Get the recording id for the counter id. @param countersReader to read counters from @param counterId counter id to lookup @return recording id or NULL_RECORDING_ID if counterId is not allocated\n*/"}
{"ID": 1928, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean isActive(final CountersReader countersReader, final int counterId, final long recordingId) { final DirectBuffer buffer = countersReader.metaDataBuffer(); if (countersReader.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); return buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECORDING_POSITION_TYPE_ID && buffer.getLong(recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET) == recordingId; } return false; } \nResponse:", "ground_truth": "Is the recording counter still active.\n\n@param countersReader to search within.\n@param counterId      to search for.\n@param recordingId    to confirm it is still the same value.\n@return true if the counter is still active otherwise false.", "predict": " Checks if the counter is active. @param countersReader the counters reader @param counterId the counter id @param recordingId the recording id @return true if active, otherwise false\n*/"}
{"ID": 1929, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public StatusMessageFlyweight applicationSpecificFeedback(final byte[] source, final int offset, final int length) { frameLength(HEADER_LENGTH + length); putBytes(APP_SPECIFIC_FEEDBACK_FIELD_OFFSET, source, offset, length); return this; } \nResponse:", "ground_truth": "Set the Application Specific Feedback for the Status Message.\n\n@param source of the feedback to set\n@param offset of the feedback in the source\n@param length of the feedback in bytes\n@return flyweight", "predict": " Provide feedback to the remote party regarding the outcome of processing carried out by the local party. Feedback may be tailored to convey success or failure, partial success, warnings, or outright rejection. Feedback may also convey additional meta-data such as the correlation ID associated with the delivery receipt. Feedback may also convey negative acknowledgments such as rejection due to overload or other temporary congestion. Feedback may also convey negative acknowledgments due to security violations or violations of other invariants. Feedback may also convey negative acknowledgments due to violations of business rules or other business objectives. Feedback may convey negative acknowledgments due to violations of confidentiality or integrity objectives. Feedback may convey negative acknowledgments due to violations of business objectives. @param source Feedback conveyed by the publisher @param offset Offset into the source buffer @param length Length of the feedback payload @return StatusMessageFlyweight"}
{"ID": 1930, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void reload() { entries.clear(); indexByLeadershipTermIdMap.clear(); indexByLeadershipTermIdMap.compact(); nextEntryIndex = 0; byteBuffer.clear(); try { while (true) { final int bytes = fileChannel.read(byteBuffer); if (byteBuffer.remaining() == 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } if (-1 == bytes) { if (byteBuffer.position() > 0) { byteBuffer.flip(); captureEntriesFromBuffer(byteBuffer, buffer, entries); byteBuffer.clear(); } break; } } } catch (final IOException ex) { LangUtil.rethrowUnchecked(ex); } } \nResponse:", "ground_truth": "Reload the log from disk.", "predict": " Reloads the Raft log from disk. After calling this method, the Raft log will no longer contain any entries that were written before this method was called. However, the Raft log will retain entries that were written after this method was called. This method is idempotent. Specifically, if the Raft log was reloaded before it was written to disk, this method will have no effect. However, if the Raft log was written to disk before it was reloaded, this method will reload the Raft log from disk.\n*/"}
{"ID": 1931, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Entry findLastTerm() { for (int i = entries.size() - 1; i >= 0; i--) { final Entry entry = entries.get(i); if (ENTRY_TYPE_TERM == entry.type) { return entry; } } return null; } \nResponse:", "ground_truth": "Find the last leadership term in the recording log.\n\n@return the last leadership term in the recording log.", "predict": " Finds the last Term in the list. Returns null if none found. @return Term or null."}
{"ID": 1932, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public RecoveryPlan createRecoveryPlan(final AeronArchive archive, final int serviceCount) { final ArrayList<Snapshot> snapshots = new ArrayList<>(); final ArrayList<Log> logs = new ArrayList<>(); planRecovery(snapshots, logs, entries, archive, serviceCount); long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } if (!logs.isEmpty()) { final Log log = logs.get(0); lastLeadershipTermId = log.leadershipTermId; lastTermBaseLogPosition = log.termBaseLogPosition; appendedLogPosition = log.stopPosition; committedLogPosition = log.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, logs); } \nResponse:", "ground_truth": "Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the\nlatest stable state.\n\n@param archive      to lookup recording descriptors.\n@param serviceCount of services that may have snapshots.\n@return a new {@link RecoveryPlan} for the cluster.", "predict": " Create a RecoveryPlan from AeronArchive and ServiceCount. @param archive AeronArchive to recover from. @param serviceCount number of services to recover. @return RecoveryPlan."}
{"ID": 1933, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RecoveryPlan createRecoveryPlan(final ArrayList<RecordingLog.Snapshot> snapshots) { long lastLeadershipTermId = NULL_VALUE; long lastTermBaseLogPosition = 0; long committedLogPosition = -1; long appendedLogPosition = 0; final int snapshotStepsSize = snapshots.size(); if (snapshotStepsSize > 0) { final Snapshot snapshot = snapshots.get(0); lastLeadershipTermId = snapshot.leadershipTermId; lastTermBaseLogPosition = snapshot.termBaseLogPosition; appendedLogPosition = snapshot.logPosition; committedLogPosition = snapshot.logPosition; } return new RecoveryPlan( lastLeadershipTermId, lastTermBaseLogPosition, appendedLogPosition, committedLogPosition, snapshots, new ArrayList<>()); } \nResponse:", "ground_truth": "Create a recovery plan that has only snapshots. Used for dynamicJoin snapshot load.\n\n@param snapshots to construct plan from\n@return a new {@link RecoveryPlan} for the cluster", "predict": " Create a recovery plan from a list of snapshots. The snapshots must be ordered chronologically. The snapshots are expected to cover the entire log up to the committed position. The snapshots are expected to be ordered chronologically. The snapshots are expected to cover the entire log up to the committed position. The snapshots are expected to be ordered chronologically. The snapshots are expected to cover the entire log up to the committed position. @param snapshots The snapshots to recover from. @return The recovery plan."}
{"ID": 1934, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void appendTerm( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long timestamp) { final int size = entries.size(); if (size > 0) { final Entry lastEntry = entries.get(size - 1); if (lastEntry.type != NULL_VALUE && lastEntry.leadershipTermId >= leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + lastEntry.leadershipTermId + \" this \" + leadershipTermId); } } indexByLeadershipTermIdMap.put(leadershipTermId, nextEntryIndex); append( ENTRY_TYPE_TERM, recordingId, leadershipTermId, termBaseLogPosition, NULL_POSITION, timestamp, NULL_VALUE); } \nResponse:", "ground_truth": "Append a log entry for a leadership term.\n\n@param recordingId         of the log.\n@param leadershipTermId    for the current term.\n@param termBaseLogPosition reached at the beginning of the term.\n@param timestamp           at the beginning of the term.", "predict": " Append a leadership term entry. Leadership term entries are stored in ascending leadership term order. Therefore, the appendTerm() method must be called in ascending leadership term order. Leadership terms are purged when they are no longer contiguous. Therefore, leadershipTermId must ascend monotonically. Furthermore, leadershipTermId must ascend for each leadership term. Therefore, appendTerm() must be called in ascending leadershipTermId order. Lastly, leadershipTermId must ascend for each leadership term. Therefore, appendTerm() must be called in ascending leadershipTermId order. @param leadershipTermId leadershipTermId @param termBaseLogPosition termBaseLogPosition @param timestamp timestamp\n*/"}
{"ID": 1935, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void appendSnapshot( final long recordingId, final long leadershipTermId, final long termBaseLogPosition, final long logPosition, final long timestamp, final int serviceId) { final int size = entries.size(); if (size > 0) { final Entry entry = entries.get(size - 1); if (entry.type == ENTRY_TYPE_TERM && entry.leadershipTermId != leadershipTermId) { throw new ClusterException(\"leadershipTermId out of sequence: previous \" + entry.leadershipTermId + \" this \" + leadershipTermId); } } append( ENTRY_TYPE_SNAPSHOT, recordingId, leadershipTermId, termBaseLogPosition, logPosition, timestamp, serviceId); } \nResponse:", "ground_truth": "Append a log entry for a snapshot.\n\n@param recordingId         in the archive for the snapshot.\n@param leadershipTermId    for the current term\n@param termBaseLogPosition at the beginning of the leadership term.\n@param logPosition         for the position in the current term or length so far for that term.\n@param timestamp           at which the snapshot was taken.\n@param serviceId           for which the snapshot is recorded.", "predict": " Append a snapshot entry. Leadership term must be strictly increasing. @param leadershipTermId leadershipTermId @param termBaseLogPosition termBaseLogPosition @param logPosition logPosition @param timestamp timestamp @param serviceId serviceId\n*/"}
{"ID": 1936, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void commitLogPosition(final long leadershipTermId, final long logPosition) { final int index = getLeadershipTermEntryIndex(leadershipTermId); commitEntryValue(index, logPosition, LOG_POSITION_OFFSET); final Entry entry = entries.get(index); entries.set(index, new Entry( entry.recordingId, entry.leadershipTermId, entry.termBaseLogPosition, logPosition, entry.timestamp, entry.serviceId, entry.type, entry.entryIndex)); } \nResponse:", "ground_truth": "Commit the position reached in a leadership term before a clean shutdown.\n\n@param leadershipTermId for committing the term position reached.\n@param logPosition      reached in the leadership term.", "predict": " Commit leadership position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term id, log position. Leadership term"}
{"ID": 1937, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void tombstoneEntry(final long leadershipTermId, final int entryIndex) { int index = -1; for (int i = 0, size = entries.size(); i < size; i++) { final Entry entry = entries.get(i); if (entry.leadershipTermId == leadershipTermId && entry.entryIndex == entryIndex) { index = entry.entryIndex; if (ENTRY_TYPE_TERM == entry.type) { indexByLeadershipTermIdMap.remove(leadershipTermId); } break; } } if (-1 == index) { throw new ClusterException(\"unknown entry index: \" + entryIndex); } buffer.putInt(0, NULL_VALUE, LITTLE_ENDIAN); byteBuffer.limit(SIZE_OF_INT).position(0); final long filePosition = (index * (long)ENTRY_LENGTH) + ENTRY_TYPE_OFFSET; try { if (SIZE_OF_INT != fileChannel.write(byteBuffer, filePosition)) { throw new ClusterException(\"failed to write field atomically\"); } } catch (final Exception ex) { LangUtil.rethrowUnchecked(ex); } } \nResponse:", "ground_truth": "Tombstone an entry in the log so it is no longer valid.\n\n@param leadershipTermId to match for validation.\n@param entryIndex       reached in the leadership term.", "predict": " Tombstones an entry in the Raft log. Leadership must exist for the tombstone to be applied. @param leadershipTermId leadershipTermId of the tombstone @param entryIndex entryIndex of the tombstone"}
{"ID": 1938, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { if (null != publication && publication.isConnected()) { closeSession(); } if (!ctx.ownsAeronClient()) { CloseHelper.close(subscription); CloseHelper.close(publication); } ctx.close(); } \nResponse:", "ground_truth": "Close session and release associated resources.", "predict": " Close Aeron resources releasing any lingering references. Once called no new Aeron methods may be called except for close.\n*/"}
{"ID": 1939, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBufferVector[] vectors) { if (headerVector != vectors[0]) { vectors[0] = headerVector; } return publication.offer(vectors, null); } \nResponse:", "ground_truth": "Non-blocking publish by gathering buffer vectors into a message. The first vector will be replaced by the cluster\ningress header so must be left unused.\n\n@param vectors which make up the message.\n@return the same as {@link Publication#offer(DirectBufferVector[])}.\n@see Publication#offer(DirectBufferVector[])", "predict": " Offer a DirectBufferVector[] to the ringbuffer. This will overwrite any vectors offered previously. @param vectors DirectBufferVector[] offered to the ringbuffer. @return long publication id.\n*/"}
{"ID": 1940, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean unblock( final UnsafeBuffer[] termBuffers, final UnsafeBuffer logMetaDataBuffer, final long blockedPosition, final int termLength) { final int positionBitsToShift = LogBufferDescriptor.positionBitsToShift(termLength); final int blockedTermCount = (int)(blockedPosition >> positionBitsToShift); final int blockedOffset = (int)blockedPosition & (termLength - 1); final int activeTermCount = activeTermCount(logMetaDataBuffer); if (activeTermCount == (blockedTermCount - 1) && blockedOffset == 0) { final int currentTermId = termId(rawTailVolatile(logMetaDataBuffer, indexByTermCount(activeTermCount))); return rotateLog(logMetaDataBuffer, activeTermCount, currentTermId); } final int blockedIndex = indexByTermCount(blockedTermCount); final long rawTail = rawTailVolatile(logMetaDataBuffer, blockedIndex); final int termId = termId(rawTail); final int tailOffset = termOffset(rawTail, termLength); final UnsafeBuffer termBuffer = termBuffers[blockedIndex]; switch (TermUnblocker.unblock(logMetaDataBuffer, termBuffer, blockedOffset, tailOffset, termId)) { case UNBLOCKED_TO_END: rotateLog(logMetaDataBuffer, blockedTermCount, termId); // fall through case UNBLOCKED: return true; } return false; } \nResponse:", "ground_truth": "Attempt to unblock a log buffer at given position\n\n@param termBuffers       for current blockedOffset\n@param logMetaDataBuffer for log buffer\n@param blockedPosition   to attempt to unblock\n@param termLength        of the buffer for each term in the log\n@return whether unblocked or not", "predict": " Unblock a term at a particular blocked position. The term will be unblocked until the end of the log or until the term at the blocked position is committed. @param termBuffers the buffers in which the terms reside. @param logMetaDataBuffer the meta data relating to the log buffers. @param blockedPosition the blocked position. @param termLength the length of the terms. @return true if the term was unblocked, false otherwise."}
{"ID": 1941, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public String channel() { final int length = buffer.getInt(offset + CHANNEL_OFFSET); lengthOfChannel = SIZE_OF_INT + length; return buffer.getStringAscii(offset + CHANNEL_OFFSET, length); } \nResponse:", "ground_truth": "Get the channel field as ASCII\n\n@return channel field", "predict": " Returns the channel name. @return Channel name\n*/"}
{"ID": 1942, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public ImageMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; } \nResponse:", "ground_truth": "Set the channel field as ASCII\n\n@param channel field value\n@return flyweight", "predict": " Provide the Aeron channel for this publication. @param channel to be associated with publication. @return this PublicationBuilder for fluent interfacing.\n*/"}
{"ID": 1943, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkTermLength(final int termLength) { if (termLength < TERM_MIN_LENGTH) { throw new IllegalStateException( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength); } if (termLength > TERM_MAX_LENGTH) { throw new IllegalStateException( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength); } if (!BitUtil.isPowerOfTwo(termLength)) { throw new IllegalStateException(\"Term length not a power of 2: length=\" + termLength); } } \nResponse:", "ground_truth": "Check that term length is valid and alignment is valid.\n\n@param termLength to be checked.\n@throws IllegalStateException if the length is not as expected.", "predict": " Check that the term length is valid. @param termLength Term length to check.\n*/"}
{"ID": 1944, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void checkPageSize(final int pageSize) { if (pageSize < PAGE_MIN_SIZE) { throw new IllegalStateException( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize); } if (pageSize > PAGE_MAX_SIZE) { throw new IllegalStateException( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize); } if (!BitUtil.isPowerOfTwo(pageSize)) { throw new IllegalStateException(\"Page size not a power of 2: page size=\" + pageSize); } } \nResponse:", "ground_truth": "Check that page size is valid and alignment is valid.\n\n@param pageSize to be checked.\n@throws IllegalStateException if the size is not as expected.", "predict": " Check page size. @param pageSize Page size.\n*/"}
{"ID": 1945, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean casActiveTermCount( final UnsafeBuffer metadataBuffer, final int expectedTermCount, final int updateTermCount) { return metadataBuffer.compareAndSetInt(LOG_ACTIVE_TERM_COUNT_OFFSET, expectedTermCount, updateTermCount); } \nResponse:", "ground_truth": "Compare and set the value of the current active term count.\n\n@param metadataBuffer    containing the meta data.\n@param expectedTermCount value of the active term count expected in the log\n@param updateTermCount   value of the active term count to be updated in the log\n@return true if successful otherwise false.", "predict": " Atomically update the active term count in the supplied metadata buffer. The active term count is incremented by one. @param metadataBuffer containing the active term count to update. @param expectedTermCount The expected active term count. @param updateTermCount The new active term count. @return True if the CAS was successful otherwise false.\n*/"}
{"ID": 1946, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long computePosition( final int activeTermId, final int termOffset, final int positionBitsToShift, final int initialTermId) { final long termCount = activeTermId - initialTermId; // copes with negative activeTermId on rollover return (termCount << positionBitsToShift) + termOffset; } \nResponse:", "ground_truth": "Compute the current position in absolute number of bytes.\n\n@param activeTermId        active term id.\n@param termOffset          in the term.\n@param positionBitsToShift number of times to left shift the term count\n@param initialTermId       the initial term id that this stream started on\n@return the absolute position in bytes", "predict": " Compute the position value from the active term id and the term offset. The position value is shifted by the number of bits to shift and then shifted right by the number of bits in the mask. The shifted right value is then added to the term offset to produce the resulting position value. The term offset is adjusted by subtracting the term id shifted by the number of bits to shift. This adjustment ensures that the resulting position value falls within the range of a 64 bit long value. @param activeTermId Active term id. @param termOffset Term offset. @param positionBitsToShift Number of bits to shift the position value. @param initialTermId Initial term id. @return The resulting 64 bit long value."}
{"ID": 1947, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long computeLogLength(final int termLength, final int filePageSize) { if (termLength < (1024 * 1024 * 1024)) { return align((termLength * PARTITION_COUNT) + LOG_META_DATA_LENGTH, filePageSize); } return (PARTITION_COUNT * (long)termLength) + align(LOG_META_DATA_LENGTH, filePageSize); } \nResponse:", "ground_truth": "Compute the total length of a log file given the term length.\n\nAssumes {@link #TERM_MAX_LENGTH} is 1GB and that filePageSize is 1GB or less and a power of 2.\n\n@param termLength   on which to base the calculation.\n@param filePageSize to use for log.\n@return the total length of the log file.", "predict": " Compute the log length for the given term length and file page size. The formula is: alignedTermLength * PARTITION_COUNT + LOG_META_DATA_LENGTH. alignedTermLength is aligned to the nearest power of 2. PARTITION_COUNT is the number of partitions. LOG_META_DATA_LENGTH is the overhead of meta data. @param termLength the length of the term. @param filePageSize the size of the file page. @return the log length."}
{"ID": 1948, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void storeDefaultFrameHeader(final UnsafeBuffer metadataBuffer, final DirectBuffer defaultHeader) { if (defaultHeader.capacity() != HEADER_LENGTH) { throw new IllegalArgumentException( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader.capacity()); } metadataBuffer.putInt(LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET, HEADER_LENGTH); metadataBuffer.putBytes(LOG_DEFAULT_FRAME_HEADER_OFFSET, defaultHeader, 0, HEADER_LENGTH); } \nResponse:", "ground_truth": "Store the default frame header to the log meta data buffer.\n\n@param metadataBuffer into which the default headers should be stored.\n@param defaultHeader  to be stored.\n@throws IllegalArgumentException if the defaultHeader larger than {@link #LOG_DEFAULT_FRAME_HEADER_MAX_LENGTH}", "predict": " Stores the supplied default frame header into the supplied metadata buffer. The default frame header must be HEADER_LENGTH bytes long. @param metadataBuffer containing the default frame header to be stored.\n * @param defaultHeader containing the default frame header to be stored.\n */"}
{"ID": 1949, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void applyDefaultHeader( final UnsafeBuffer metadataBuffer, final UnsafeBuffer termBuffer, final int termOffset) { termBuffer.putBytes(termOffset, metadataBuffer, LOG_DEFAULT_FRAME_HEADER_OFFSET, HEADER_LENGTH); } \nResponse:", "ground_truth": "Apply the default header for a message in a term.\n\n@param metadataBuffer containing the default headers.\n@param termBuffer     to which the default header should be applied.\n@param termOffset     at which the default should be applied.", "predict": " Apply the default header to the term buffer at the given offset. @param metadataBuffer containing the default header to apply.\n * @param termBuffer into which the default header should be applied.\n * @param termOffset at which the default header should be applied.\n */"}
{"ID": 1950, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean rotateLog(final UnsafeBuffer metadataBuffer, final int termCount, final int termId) { final int nextTermId = termId + 1; final int nextTermCount = termCount + 1; final int nextIndex = indexByTermCount(nextTermCount); final int expectedTermId = nextTermId - PARTITION_COUNT; long rawTail; do { rawTail = rawTail(metadataBuffer, nextIndex); if (expectedTermId != termId(rawTail)) { break; } } while (!casRawTail(metadataBuffer, nextIndex, rawTail, packTail(nextTermId, 0))); return casActiveTermCount(metadataBuffer, termCount, nextTermCount); } \nResponse:", "ground_truth": "Rotate the log and update the tail counter for the new term.\n\nThis method is safe for concurrent use.\n\n@param metadataBuffer for the log.\n@param termCount      from which to rotate.\n@param termId         to be used in the default headers.\n@return true if log was rotated.", "predict": " Rotate the log. @param metadataBuffer The current metadata. @param termCount The current term count. @param termId The current term id. @return True if the rotated log is successfully committed. False otherwise."}
{"ID": 1951, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void initialiseTailWithTermId( final UnsafeBuffer metadataBuffer, final int partitionIndex, final int termId) { metadataBuffer.putLong(TERM_TAIL_COUNTERS_OFFSET + (partitionIndex * SIZE_OF_LONG), packTail(termId, 0)); } \nResponse:", "ground_truth": "Set the initial value for the termId in the upper bits of the tail counter.\n\n@param metadataBuffer contain the tail counter.\n@param partitionIndex to be initialised.\n@param termId         to be set.", "predict": " Initialise the tail counter for a partition to the supplied term id. The tail is maintained as a series of ordered 64-bit counters maintained in fixed memory locations in the buffer. The tail is increased monotonically as new messages are published. The tail is increased atomically and hence not vulnerable to outside influences. Furthermore, the tail is only ever increased. Therefore, once it reaches a certain predetermined value, it will remain constant. Whilst the tail is monotonically increasing, it will wrap around periodically. Therefore, care should be taken when interpreting its value. Whilst intuitively obvious, care should also be taken to ensure that the tail is initialised to a sensible value. Failure to do so could lead to loss of messages. Furthermore, care should also be taken to ensure that the tail is periodically increased. Failure to do so could lead to loss of messages. Whilst intuitively obvious, care should also be taken to ensure that the tail is periodically increased. Failure to do so could lead to loss of messages. @param metadataBuffer The metadata buffer containing the tail counters."}
{"ID": 1952, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int termOffset(final long rawTail, final long termLength) { final long tail = rawTail & 0xFFFF_FFFFL; return (int)Math.min(tail, termLength); } \nResponse:", "ground_truth": "Read the termOffset from a packed raw tail value.\n\n@param rawTail    containing the termOffset.\n@param termLength that the offset cannot exceed.\n@return the termOffset value.", "predict": " Returns the offset of the tail within the term buffer. The tail is comprised of four bytes holding the four least significant bytes of the CRC-32 of the term buffer. The CRC-32 is computed across the entire term buffer INCLUDING the four bytes comprising the tail. Therefore, the tail CRC-32 value is four CRC-32 octets shy of the actual tail CRC-32 octet. Therefore, the actual CRC-32 octet is fifth from the tail. Therefore, the fifth byte from the tail is the fourth least significant byte of the CRC-32 octet. Therefore, the fifth byte from the tail is the fourth least significant byte of the CRC-32 octet. Therefore, the fifth byte from the tail is the fourth least significant byte of the CRC-32 octet. Therefore, the fifth byte from the tail is the fourth least significant byte of the CRC-32 octet. Therefore, the fifth byte from the tail is the fourth least significant byte of the CRC-32 octet. Therefore, the fifth byte from the tail is the fourth"}
{"ID": 1953, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long rawTailVolatile(final UnsafeBuffer metadataBuffer) { final int partitionIndex = indexByTermCount(activeTermCount(metadataBuffer)); return metadataBuffer.getLongVolatile(TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex)); } \nResponse:", "ground_truth": "Get the raw value of the tail for the current active partition.\n\n@param metadataBuffer containing the tail counters.\n@return the raw value of the tail for the current active partition.", "predict": " Tail volatile read of the partition tail counter. @param metadataBuffer containing the partition meta data @return the partition tail counter value\n*/"}
{"ID": 1954, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean casRawTail( final UnsafeBuffer metadataBuffer, final int partitionIndex, final long expectedRawTail, final long updateRawTail) { final int index = TERM_TAIL_COUNTERS_OFFSET + (SIZE_OF_LONG * partitionIndex); return metadataBuffer.compareAndSetLong(index, expectedRawTail, updateRawTail); } \nResponse:", "ground_truth": "Compare and set the raw value of the tail for the given partition.\n\n@param metadataBuffer  containing the tail counters.\n@param partitionIndex  for the tail counter.\n@param expectedRawTail expected current value.\n@param updateRawTail   to be applied.\n@return true if the update was successful otherwise false.", "predict": " Atomically update the tail counter for the partition. The tail counter is updated atomically and therefore guards against simultaneous updates impacting the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile so simultaneous updates to the rawTail are reflected in the tail counter. Whilst the tail counter is being updated, the rawTail is volatile"}
{"ID": 1955, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public TerminateDriverFlyweight tokenBuffer( final DirectBuffer tokenBuffer, final int tokenOffset, final int tokenLength) { buffer.putInt(TOKEN_LENGTH_OFFSET, tokenLength); if (null != tokenBuffer && tokenLength > 0) { buffer.putBytes(tokenBufferOffset(), tokenBuffer, tokenOffset, tokenLength); } return this; } \nResponse:", "ground_truth": "Fill the token buffer.\n\n@param tokenBuffer containing the optional token for the request.\n@param tokenOffset within the tokenBuffer at which the token begins.\n@param tokenLength of the token in the tokenBuffer.\n@return flyweight", "predict": " Setup the token buffer for the Flyweight structure. The token buffer will be setup such that the tokenLength field in the Flyweight Header will be set to the length of the token data. Additionally, the token buffer will be setup such that the tokenOffset field in the Flyweight Header will be set to the offset of the token data within the overall buffer. @param tokenBuffer The buffer to setup the token data within. @param tokenOffset The offset within the overall buffer to setup the token data. @param tokenLength The length of the token data. @return The Flyweight structure to continue setup."}
{"ID": 1956, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final long leadershipTermId, final long logPosition, final long timestamp, final boolean hasReplay, final long... snapshotRecordingIds) { tempBuffer.putLong(LEADERSHIP_TERM_ID_OFFSET, leadershipTermId); tempBuffer.putLong(LOG_POSITION_OFFSET, logPosition); tempBuffer.putLong(TIMESTAMP_OFFSET, timestamp); tempBuffer.putInt(REPLAY_FLAG_OFFSET, hasReplay ? 1 : 0); final int serviceCount = snapshotRecordingIds.length; tempBuffer.putInt(SERVICE_COUNT_OFFSET, serviceCount); final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + (serviceCount * SIZE_OF_LONG); if (keyLength > MAX_KEY_LENGTH) { throw new ClusterException(keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH); } for (int i = 0; i < serviceCount; i++) { tempBuffer.putLong(SNAPSHOT_RECORDING_IDS_OFFSET + (i * SIZE_OF_LONG), snapshotRecordingIds[i]); } final int labelOffset = BitUtil.align(keyLength, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putLongAscii(keyLength + labelLength, leadershipTermId); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" logPosition=\"); labelLength += tempBuffer.putLongAscii(labelOffset + labelLength, logPosition); labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, \" hasReplay=\" + hasReplay); return aeron.addCounter(RECOVERY_STATE_TYPE_ID, tempBuffer, 0, keyLength, tempBuffer, labelOffset, labelLength); } \nResponse:", "ground_truth": "Allocate a counter to represent the snapshot services should load on start.\n\n@param aeron                to allocate the counter.\n@param tempBuffer           to use for building the key and label without allocation.\n@param leadershipTermId     at which the snapshot was taken.\n@param logPosition          at which the snapshot was taken.\n@param timestamp            the snapshot was taken.\n@param hasReplay            flag is true if all or part of the log must be replayed.\n@param snapshotRecordingIds for the services to use during recovery indexed by service id.\n@return the {@link Counter} for the recovery state.", "predict": " Allocate a counter for the leadership terms replay log.\n * @param aeron Aeron instance to use for communication.\n * @param tempBuffer reusable buffer for key storage.\n * @param leadershipTermId leadership term id.\n * @param logPosition log position.\n * @param timestamp timestamp.\n * @param hasReplay true if the counter is for replay.\n * @param snapshotRecordingIds snapshot recording ids.\n * @return the allocated counter.\n */"}
{"ID": 1957, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterId(final CountersReader counters) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for recovery state.\n\n@param counters to search within.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find counter id of counter whose allocation state is RECOVERY_STATE_TYPE_ID. @param counters counters to search through @return counter id or NULL_COUNTER_ID if not found"}
{"ID": 1958, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static boolean hasReplay(final CountersReader counters, final int counterId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { return buffer.getInt(recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET) == 1; } } return false; } \nResponse:", "ground_truth": "Has the recovery process got a log to replay?\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@return true if a replay is required.", "predict": " Determine if the counter has been marked for replay. Counters that are in the RECORD_ALLOCATED state will be tracked by the bookkeeper but not yet replicated to any of the bookies. Counters that are in the RECOVERY_STATE_TYPE will be tracked by the bookkeeper but not yet replicated to any of the bookies. @param counters counters reader @param counterId counter id @return true if the counter has been marked for replay\n*/"}
{"ID": 1959, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static long getSnapshotRecordingId(final CountersReader counters, final int counterId, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); if (counters.getCounterState(counterId) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(counterId); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == RECOVERY_STATE_TYPE_ID) { final int serviceCount = buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET); if (serviceId < 0 || serviceId >= serviceCount) { throw new ClusterException(\"invalid serviceId \" + serviceId + \" for count of \" + serviceCount); } return buffer.getLong( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + (serviceId * SIZE_OF_LONG)); } } throw new ClusterException(\"Active counter not found \" + counterId); } \nResponse:", "ground_truth": "Get the recording id of the snapshot for a service.\n\n@param counters  to search within.\n@param counterId for the active recovery counter.\n@param serviceId for the snapshot required.\n@return the count of replay terms if found otherwise {@link Aeron#NULL_VALUE}.", "predict": " Get the snapshot recording id for a given counter id and service id. @param counters counters instance @param counterId counter id @param serviceId service id @return recording id\n*/"}
{"ID": 1960, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static char[] flagsToChars(final short flags) { final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' }; final int length = chars.length; short mask = (short)(1 << (length - 1)); for (int i = 0; i < length; i++) { if ((flags & mask) == mask) { chars[i] = '1'; } mask >>= 1; } return chars; } \nResponse:", "ground_truth": "Convert header flags to an array of chars to be human readable.\n\n@param flags to be converted.\n@return header flags converted to an array of chars to be human readable.", "predict": " Convert flags to binary string. @param flags flags to convert @return binary string\n*/"}
{"ID": 1961, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PublicationMessageFlyweight channel(final String channel) { lengthOfChannel = buffer.putStringAscii(offset + CHANNEL_OFFSET, channel); return this; } \nResponse:", "ground_truth": "Set the channel field in ASCII\n\n@param channel field value\n@return flyweight", "predict": " Provide the publication channel. @param channel The publication channel. @return The PublicationMessageFlyweight."}
{"ID": 1962, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public long offer(final DirectBuffer buffer, final int offset, final int length) { return cluster.offer(id, responsePublication, buffer, offset, length); } \nResponse:", "ground_truth": "Non-blocking publish of a partial buffer containing a message to a cluster.\n\n@param buffer containing message.\n@param offset offset in the buffer at which the encoded message begins.\n@param length in bytes of the encoded message.\n@return the same as {@link Publication#offer(DirectBuffer, int, int)} when in {@link Cluster.Role#LEADER}\notherwise {@link #MOCKED_OFFER}.", "predict": " Offer the supplied buffer to the publication. Whilst offers are pipelined across a publication they are processed in strict sequence i.e. once an offer completes successfully subsequent offers to the same publication will not be accepted. Whilst offers are pipelined across a publication they are processed in strict sequence i.e. once an offer completes successfully subsequent offers to the same publication will not be accepted. Therefore, care must be taken to ensure that overlapping offers are not made concurrently across publications. Care should also be taken to ensure that overlapping offers are not made concurrently across subscriptions. Offers will always be accepted in their entirety i.e. an offer cannot be split or have its entirety rejected whilst being offered to more than one publication or subscription. Whilst overlapping offers can be made concurrently across publications they must still be processed in strict sequence i.e. an offer cannot be processed whilst an overlapping offer is being processed. Therefore, care must be taken to ensure that overlapping offers are not made concurrently across publications. Care should also be taken to ensure that overlapping offers are not made concurrently across subscriptions."}
{"ID": 1963, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void wrap(final AtomicBuffer buffer, final int offset, final int length) { this.buffer.wrap(buffer, offset, length); } \nResponse:", "ground_truth": "Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher.\n\n@param buffer to be wrapped.\n@param offset at which the claimed region begins including space for the header.\n@param length length of the underlying claimed region including space for the header.", "predict": " Wrap the provided buffer at the specified offset and length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst retaining the backing buffer, the buffer will be grown to accommodate the specified length. Whilst"}
{"ID": 1964, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void commit() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); } \nResponse:", "ground_truth": "Commit the message to the log buffer so that is it available to subscribers.", "predict": " Writes the frame length to the buffer. This is useful for framed sockets because it allows us to easily calculate the frame length even if fragmented packets are sent. Also useful for gathering statistics about frames sizes.\n */"}
{"ID": 1965, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final void abort() { int frameLength = buffer.capacity(); if (ByteOrder.nativeOrder() != LITTLE_ENDIAN) { frameLength = Integer.reverseBytes(frameLength); } buffer.putShort(TYPE_FIELD_OFFSET, (short)HDR_TYPE_PAD, LITTLE_ENDIAN); buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength); } \nResponse:", "ground_truth": "Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim.", "predict": " Abort the frame. After calling this method, no further frame will be written to the output stream.\n*/"}
{"ID": 1966, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void main(final String[] args) { loadPropertiesFiles(args); final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier(); final MediaDriver.Context ctx = new MediaDriver.Context(); ctx.terminationHook(barrier::signal); try (MediaDriver ignore = MediaDriver.launch(ctx)) { barrier.await(); System.out.println(\"Shutdown Driver...\"); } } \nResponse:", "ground_truth": "Start Media Driver as a stand-alone process.\n\n@param args command line arguments", "predict": " Demonstrate launching a MediaDriver embedded within an existing process. Once launched, shutdownBarrier can be signaled to initiate graceful shutdown of the MediaDriver.\n */"}
{"ID": 1967, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { CloseHelper.close(sharedRunner); CloseHelper.close(sharedNetworkRunner); CloseHelper.close(receiverRunner); CloseHelper.close(senderRunner); CloseHelper.close(conductorRunner); CloseHelper.close(sharedInvoker); if (ctx.useWindowsHighResTimer() && SystemUtil.osName().startsWith(\"win\")) { if (!wasHighResTimerEnabled) { HighResolutionTimer.disable(); } } } \nResponse:", "ground_truth": "Shutdown the media driver by stopping all threads and freeing resources.", "predict": " Shut down runners and wait for them to terminate.\n*/"}
{"ID": 1968, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public final long position() { final int resultingOffset = BitUtil.align(termOffset() + frameLength(), FRAME_ALIGNMENT); return computePosition(termId(), resultingOffset, positionBitsToShift, initialTermId); } \nResponse:", "ground_truth": "Get the current position to which the image has advanced on reading this message.\n\n@return the current position to which the image has advanced on reading this message.", "predict": " The position of the current term. The position points to the beginning of the term, regardless of where the consumer is actually positioned. The position will be shifted by the number of bits needed to store the frame length.\n */"}
{"ID": 1969, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static Counter allocate( final Aeron aeron, final MutableDirectBuffer tempBuffer, final int serviceId) { tempBuffer.putInt(SERVICE_ID_OFFSET, serviceId); final int labelOffset = BitUtil.align(KEY_LENGTH, SIZE_OF_INT); int labelLength = 0; labelLength += tempBuffer.putStringWithoutLengthAscii(labelOffset + labelLength, NAME); labelLength += tempBuffer.putIntAscii(labelOffset + labelLength, serviceId); return aeron.addCounter( SERVICE_HEARTBEAT_TYPE_ID, tempBuffer, 0, KEY_LENGTH, tempBuffer, labelOffset, labelLength); } \nResponse:", "ground_truth": "Allocate a counter to represent the heartbeat of a clustered service.\n\n@param aeron           to allocate the counter.\n@param tempBuffer      to use for building the key and label without allocation.\n@param serviceId       of the service heartbeat.\n@return the {@link Counter} for the commit position.", "predict": " Allocate a counter for tracking the heartbeat of a service. @param aeron Aeron instance to use for messaging. @param tempBuffer Temporary holding space for counter details. The counter label will be appended directly after this buffer up to the length of the counter key. @param serviceId Service ID to identify the heartbeat. @return The allocated counter.\n*/"}
{"ID": 1970, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static int findCounterId(final CountersReader counters, final int serviceId) { final DirectBuffer buffer = counters.metaDataBuffer(); for (int i = 0, size = counters.maxCounterId(); i < size; i++) { if (counters.getCounterState(i) == RECORD_ALLOCATED) { final int recordOffset = CountersReader.metaDataOffset(i); if (buffer.getInt(recordOffset + TYPE_ID_OFFSET) == SERVICE_HEARTBEAT_TYPE_ID && buffer.getInt(recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET) == serviceId) { return i; } } } return NULL_COUNTER_ID; } \nResponse:", "ground_truth": "Find the active counter id for heartbeat of a given service id.\n\n@param counters  to search within.\n@param serviceId to search for.\n@return the counter id if found otherwise {@link CountersReader#NULL_COUNTER_ID}.", "predict": " Find the counter id for the heartbeat service. @param counters counters instance @param serviceId heartbeat service id @return counter id or NULL_COUNTER_ID if not found"}
{"ID": 1971, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public Map<StreamCompositeKey, StreamBacklog> snapshot() { final Map<StreamCompositeKey, StreamBacklog> streams = new HashMap<>(); counters.forEach( (counterId, typeId, keyBuffer, label) -> { if ((typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID) { final StreamCompositeKey key = new StreamCompositeKey( keyBuffer.getInt(SESSION_ID_OFFSET), keyBuffer.getInt(STREAM_ID_OFFSET), keyBuffer.getStringAscii(CHANNEL_OFFSET)); final StreamBacklog streamBacklog = streams.computeIfAbsent(key, (ignore) -> new StreamBacklog()); final long registrationId = keyBuffer.getLong(REGISTRATION_ID_OFFSET); final long value = counters.getCounterValue(counterId); switch (typeId) { case PublisherLimit.PUBLISHER_LIMIT_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().limit(value); break; case PublisherPos.PUBLISHER_POS_TYPE_ID: streamBacklog.createPublisherIfAbsent().registrationId(registrationId); streamBacklog.createPublisherIfAbsent().position(value); break; case SenderPos.SENDER_POSITION_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().position(value); break; case SenderLimit.SENDER_LIMIT_TYPE_ID: streamBacklog.createSenderIfAbsent().registrationId(registrationId); streamBacklog.createSenderIfAbsent().limit(value); break; case ReceiverHwm.RECEIVER_HWM_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().highWaterMark(value); break; case ReceiverPos.RECEIVER_POS_TYPE_ID: streamBacklog.createReceiverIfAbsent().registrationId(registrationId); streamBacklog.createReceiverIfAbsent().position(value); break; case SubscriberPos.SUBSCRIBER_POSITION_TYPE_ID: streamBacklog.subscriberBacklogs().put(registrationId, new Subscriber(value)); break; } } }); return streams; } \nResponse:", "ground_truth": "Take a snapshot of all the backlog information and group by stream.\n\n@return a snapshot of all the backlog information and group by stream.", "predict": " Snapshot of counters. @return Counters snapshot."}
{"ID": 1972, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static AtomicCounter allocate( final MutableDirectBuffer tempBuffer, final String name, final int typeId, final CountersManager countersManager, final long registrationId) { return new AtomicCounter( countersManager.valuesBuffer(), allocateCounterId(tempBuffer, name, typeId, countersManager, registrationId), countersManager); } \nResponse:", "ground_truth": "Allocate a counter for tracking the last heartbeat of an entity.\n\n@param tempBuffer      to be used for labels and key.\n@param name            of the counter for the label.\n@param typeId          of the counter for classification.\n@param countersManager from which to allocated the underlying storage.\n@param registrationId  to be associated with the counter.\n@return a new {@link AtomicCounter} for tracking the last heartbeat.", "predict": " Allocate a new AtomicCounter. The counter will initially be invalid. You must call set() before attempting to increment the counter. @param tempBuffer The buffer to use as scratch space @param name The name of the counter @param typeId The typeId of the counter @param countersManager The CountersManager that owns this counter @param registrationId The registrationId that owns this counter @return The AtomicCounter that was allocated\n*/"}
{"ID": 1973, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void close() { final MappedByteBuffer cncByteBuffer = this.cncByteBuffer; this.cncByteBuffer = null; IoUtil.unmap(cncByteBuffer); super.close(); } \nResponse:", "ground_truth": "Clean up all resources that the client uses to communicate with the Media Driver.", "predict": " Close the connection.\n*/"}
{"ID": 1974, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static void dispatchDescriptor( final RecordingDescriptorDecoder decoder, final RecordingDescriptorConsumer consumer) { consumer.onRecordingDescriptor( decoder.controlSessionId(), decoder.correlationId(), decoder.recordingId(), decoder.startTimestamp(), decoder.stopTimestamp(), decoder.startPosition(), decoder.stopPosition(), decoder.initialTermId(), decoder.segmentFileLength(), decoder.termBufferLength(), decoder.mtuLength(), decoder.sessionId(), decoder.streamId(), decoder.strippedChannel(), decoder.originalChannel(), decoder.sourceIdentity()); } \nResponse:", "ground_truth": "Dispatch a descriptor message to a consumer by reading the fields in the correct order.\n\n@param decoder  which wraps the encoded message ready for reading.\n@param consumer to which the decoded fields should be passed.", "predict": " Dispatch the recording descriptor to the consumer. @param decoder the decoder to decode the recording descriptor @param consumer the consumer to dispatch the recording descriptor to"}
{"ID": 1975, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void addSlab(int minimumSize) { int nextSlabSize; if (bytesUsed == 0) { nextSlabSize = initialSlabSize; } else if (bytesUsed > maxCapacityHint / 5) { // to avoid an overhead of up to twice the needed size, we get linear when approaching target page size nextSlabSize = maxCapacityHint / 5; } else { // double the size every time nextSlabSize = bytesUsed; } if (nextSlabSize < minimumSize) { LOG.debug(\"slab size {} too small for value of size {}. Bumping up slab size\", nextSlabSize, minimumSize); nextSlabSize = minimumSize; } LOG.debug(\"used {} slabs, adding new slab of size {}\", slabs.size(), nextSlabSize); this.currentSlab = allocator.allocate(nextSlabSize); this.slabs.add(currentSlab); this.bytesAllocated += nextSlabSize; this.currentSlabIndex = 0; } \nResponse:", "ground_truth": "the new slab is guaranteed to be at least minimumSize\n@param minimumSize the size of the data we want to copy in the new slab", "predict": " Allocate more slabs. Capacity is 5% larger than needed. Slabs are grown by 50%. Therefore, the allocation request should be smaller than 50% of the slab size. Otherwise, we'll grow too much in exponential manner. Therefore, we impose a minimum slab size of 1024 bytes.\n*/"}
{"ID": 1976, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void setByte(long index, byte value) { checkArgument(index < bytesUsed, \"Index: \" + index + \" is >= the current size of: \" + bytesUsed); long seen = 0; for (int i = 0; i < slabs.size(); i++) { ByteBuffer slab = slabs.get(i); if (index < seen + slab.limit()) { // ok found index slab.put((int)(index-seen), value); break; } seen += slab.limit(); } } \nResponse:", "ground_truth": "Replace the byte stored at position index in this stream with value\n\n@param index which byte to replace\n@param value the value to replace it with", "predict": " Set the value at a particular index. This will incur a copy of the data. Care should be taken to avoid excessive copying. Ideally we'd keep freelists of our own slabs so we incur minimal copying but for now we'll keep things simple. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying. Ideally we'd keep freelists of slab chunks so we incur minimal copying."}
{"ID": 1977, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void add(Statistics<?> stats) { if (stats.hasNonNullValue()) { nullPages.add(false); Object min = stats.genericGetMin(); Object max = stats.genericGetMax(); addMinMax(min, max); pageIndexes.add(nextPageIndex); minMaxSize += sizeOf(min); minMaxSize += sizeOf(max); } else { nullPages.add(true); } nullCounts.add(stats.getNumNulls()); ++nextPageIndex; } \nResponse:", "ground_truth": "Adds the data from the specified statistics to this builder\n\n@param stats\nthe statistics to be added", "predict": " Add a new statistics object to this histogram.\n*/"}
{"ID": 1978, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount) { return filter.accept(new FilterCompat.Visitor<RowRanges>() { @Override public RowRanges visit(FilterPredicateCompat filterPredicateCompat) { try { return filterPredicateCompat.getFilterPredicate() .accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount)); } catch (MissingOffsetIndexException e) { LOGGER.info(e.getMessage()); return RowRanges.createSingle(rowCount); } } @Override public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) { return RowRanges.createSingle(rowCount); } @Override public RowRanges visit(NoOpFilter noOpFilter) { return RowRanges.createSingle(rowCount); } }); } \nResponse:", "ground_truth": "Calculates the row ranges containing the indexes of the rows might match the specified filter.\n\n@param filter\nto be used for filtering the rows\n@param columnIndexStore\nthe store for providing column/offset indexes\n@param paths\nthe paths of the columns used in the actual projection; a column not being part of the projection will be\nhandled as containing {@code null} values only even if the column has values written in the file\n@param rowCount\nthe total number of rows in the row-group\n@return the ranges of the possible matching row indexes; the returned ranges will contain all the rows if any of\nthe required offset index is missing", "predict": " Calculate row ranges for the given filter. @param filter the filter @param columnIndexStore the column index store @param paths the paths @param rowCount the row count @return the row ranges\n*/"}
{"ID": 1979, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo) { final TypeInfo subType = typeInfo.getListElementTypeInfo(); return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType(\"array_element\", subType))); } \nResponse:", "ground_truth": "1 anonymous element \"array_element\"", "predict": " Hive LIST is equivalent to an array of STRUCT containing a single STRUCT field named FIELDNAME. However, the STRUCT cannot be queried directly. Instead, a wrapper type is used: ARRAY<STRUCT<FIELDNAME:LIST>>. Luckily, Hive will automatically convert these types to the correct STRUCT during scanning. However, since Hive does not support querying the LIST type directly, a MR job will be generated translating the Hive LIST into a STRUCT containing a FIELDNAME array. Unfortunately, Hive does not provide a way to do this using the serde API, so this is done manually in the StorageHandler. Hive LIST is represented in Arrow by a singleton STRUCT containing a FIELDNAME array. Each ARRAY member is itself an array containing a single STRUCT whose tag is \"array_element\" and whose single field is FIELDNAME. So, an ARRAY<STRUCT<FIELDNAME:LIST>> becomes ARRAY<STRUCT<FIELDNAME:[LIST]>>. Each STRUCT becomes a FIELDNAME array containing a Hive"}
{"ID": 1980, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo) { final List<String> columnNames = typeInfo.getAllStructFieldNames(); final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos(); return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes)); } \nResponse:", "ground_truth": "An optional group containing multiple elements", "predict": " Convert StructTypeInfo into GroupType with OPTIONAL repetition. Fields are renamed according to Hive rules (@see StorageSchemaConverter#convertStructFieldName). Moreover, complex types (@see ComplexTypeConverter) are converted into their respective types. Moreover, decimal type (@see DecimalTypeConverter) are converted into their respective types. Moreover, binary type (@see BinaryTypeConverter) are converted into their respective types. Moreover, date type (@see DateTypeConverter) are converted into their respective types. Moreover, timestamp type (@see TimestampTypeConverter) are converted into their respective types. Moreover, varbinary type (@see BinaryTypeConverter) are converted into their respective types. Moreover, utf8 type (@see UTF8TypeConverter) are converted into their respective types. Moreover, varchar type (@see VarcharTypeConverter) are converted into their respective types. Moreover, list type (@see ListTypeConverter) are converted into their respective types."}
{"ID": 1981, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private static String annotateMessage(String message, int pos) { StringBuilder sb = new StringBuilder(message); sb.append('\\n'); for (int i = 0; i < pos; i++) { sb.append('-'); } sb.append('^'); return sb.toString(); } \nResponse:", "ground_truth": "for pretty printing which character had the error", "predict": " Annotates a message with highlighting information about the erroneous position. Highlights are printed as underlined bars ('^') standing next to the error position. The highlighting is meant to be machine readable. Thus, every character in the string returned conforms to the following regular expression: \"\\\\^(.+?)\\\\^\". That is, every occurrence of exactly one caret ('^') is followed by some number of arbitrary characters ('.'), which are printed literally, followed by another caret ('^'). Within curly braces ('{}'), numbers are printed as digits ('0'-'9'). Finally, every other character is printed in its hexadecimal notation ('\\\\xNN'). @param message The message to annotate. @param pos The position of the error. @return The annotated message."}
{"ID": 1982, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void endPreviousBitPackedRun() { if (bitPackedRunHeaderPointer == -1) { // we're not currently in a bit-packed-run return; } // create bit-packed-header, which needs to fit in 1 byte byte bitPackHeader = (byte) ((bitPackedGroupCount << 1) | 1); // update this byte baos.setByte(bitPackedRunHeaderPointer, bitPackHeader); // mark that this run is over bitPackedRunHeaderPointer = -1; // reset the number of groups bitPackedGroupCount = 0; } \nResponse:", "ground_truth": "If we are currently writing a bit-packed-run, update the\nbit-packed-header and consider this run to be over\n\ndoes nothing if we're not currently writing a bit-packed run", "predict": " Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to the baos. Ends a bit-packed-run by writing the bit-packed-header to"}
{"ID": 1983, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Override public void readOne(TProtocol in, TProtocol out) throws TException { readOneStruct(in, out); } \nResponse:", "ground_truth": "reads one record from in and writes it to out\nexceptions are not recoverable as record might be halfway written\n@param in input protocol\n@param out output protocol\n@throws TException if there is an error while reading or writing", "predict": " Reading one field from protocol. Reading primitive fields require calling PrimitiveReader.readOneStruct(..), while reading complex fields require calling ComplexReader.readOneStruct(..). Reading nested structs require calling StructReader.readOneStruct(..). Reading list requires calling ListReader.readOneStruct(..). Reading set requires calling SetReader.readOneStruct(..). Reading map requires calling MapReader.readOneStruct(..). Reading struct requires calling StructReader.readOneStruct(..). Reading union requires calling UnionReader.readOneStruct(..). Reading aliases require calling AliasReader.readOneStruct(..). Reading enums require calling EnumReader.readOneStruct(..). Reading booleans require calling PrimitiveReader.readOneStruct(..). Reading binary require calling BinaryReader.readOneStruct(..). Reading timestamp require calling PrimitiveReader.readOneStruct(..). Reading decimal require calling PrimitiveReader.readOneStruct(..). Reading decimal128 require calling PrimitiveReader.readOneStruct(.."}
{"ID": 1984, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException { return readFooters(configuration, pathStatus, false); } \nResponse:", "ground_truth": "this always returns the row groups\n@param configuration a configuration\n@param pathStatus a file status to read footers from\n@return a list of footers\n@throws IOException if an exception is thrown while reading the footers\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": " Deprecated API kept only for backward compatibility reasons. Please use overloaded method instead. @see #readFooters(Configuration, FileStatus, boolean)\n */"}
{"ID": 1985, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException { final Path parent = summaryStatus.getPath().getParent(); ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false)); return footersFromSummaryFile(parent, mergedFooters); } \nResponse:", "ground_truth": "Specifically reads a given summary file\n@param configuration a configuration\n@param summaryStatus file status for a summary file\n@return the metadata translated for each file\n@throws IOException if an exception is thrown while reading the summary file\n@deprecated metadata files are not recommended and will be removed in 2.0.0", "predict": " Deprecated API kept only for backward compatibility. Please use getFooters(Path, ParquetMetadataConverter.NO_FILTER) instead.\n */"}
{"ID": 1986, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: @Deprecated public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException { ParquetReadOptions options; if (file instanceof HadoopInputFile) { options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration()) .withMetadataFilter(filter).build(); } else { options = ParquetReadOptions.builder().withMetadataFilter(filter).build(); } try (SeekableInputStream in = file.newStream()) { return readFooter(file, options, in); } } \nResponse:", "ground_truth": "Reads the meta data block in the footer of the file using provided input stream\n@param file a {@link InputFile} to read\n@param filter the filter to apply to row groups\n@return the metadata blocks in the footer\n@throws IOException if an error occurs while reading the file\n@deprecated will be removed in 2.0.0;\nuse {@link ParquetFileReader#open(InputFile, ParquetReadOptions)}", "predict": " Deprecated. Please use the Parquet APIs directly.\n */"}
{"ID": 1987, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PageReadStore readNextRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } this.currentRowGroup = new ColumnChunkPageReadStore(block.getRowCount()); // prepare the list of consecutive parts to read them in one scan List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); BenchmarkCounter.incrementTotalBytes(mc.getTotalSize()); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { long startingPos = mc.getStartingPos(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } currentParts.addChunk(new ChunkDescriptor(columnDescriptor, mc, startingPos, (int)mc.getTotalSize())); } } // actually read all the chunks ChunkListBuilder builder = new ChunkListBuilder(); for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; } \nResponse:", "ground_truth": "Reads all the columns requested from the row group at the current file position.\n@throws IOException if an error occurs while reading\n@return the PageReadStore which can provide PageReaders for each column.", "predict": " Read the next row group. Returns null if there are no more. @return The next row group or null if there are no more.\n*/"}
{"ID": 1988, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public PageReadStore readNextFilteredRowGroup() throws IOException { if (currentBlock == blocks.size()) { return null; } if (!options.useColumnIndexFilter()) { return readNextRowGroup(); } BlockMetaData block = blocks.get(currentBlock); if (block.getRowCount() == 0) { throw new RuntimeException(\"Illegal row group of 0 rows\"); } ColumnIndexStore ciStore = getColumnIndexStore(currentBlock); RowRanges rowRanges = getRowRanges(currentBlock); long rowCount = rowRanges.rowCount(); if (rowCount == 0) { // There are no matching rows -> skipping this row-group advanceToNextBlock(); return readNextFilteredRowGroup(); } if (rowCount == block.getRowCount()) { // All rows are matching -> fall back to the non-filtering path return readNextRowGroup(); } this.currentRowGroup = new ColumnChunkPageReadStore(rowRanges); // prepare the list of consecutive parts to read them in one scan ChunkListBuilder builder = new ChunkListBuilder(); List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>(); ConsecutivePartList currentParts = null; for (ColumnChunkMetaData mc : block.getColumns()) { ColumnPath pathKey = mc.getPath(); ColumnDescriptor columnDescriptor = paths.get(pathKey); if (columnDescriptor != null) { OffsetIndex offsetIndex = ciStore.getOffsetIndex(mc.getPath()); OffsetIndex filteredOffsetIndex = filterOffsetIndex(offsetIndex, rowRanges, block.getRowCount()); for (OffsetRange range : calculateOffsetRanges(filteredOffsetIndex, mc, offsetIndex.getOffset(0))) { BenchmarkCounter.incrementTotalBytes(range.getLength()); long startingPos = range.getOffset(); // first part or not consecutive => new list if (currentParts == null || currentParts.endPos() != startingPos) { currentParts = new ConsecutivePartList(startingPos); allParts.add(currentParts); } ChunkDescriptor chunkDescriptor = new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) range.getLength()); currentParts.addChunk(chunkDescriptor); builder.setOffsetIndex(chunkDescriptor, filteredOffsetIndex); } } } // actually read all the chunks for (ConsecutivePartList consecutiveChunks : allParts) { consecutiveChunks.readAll(f, builder); } for (Chunk chunk : builder.build()) { currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages()); } // avoid re-reading bytes the dictionary reader is used after this call if (nextDictionaryReader != null) { nextDictionaryReader.setRowGroup(currentRowGroup); } advanceToNextBlock(); return currentRowGroup; } \nResponse:", "ground_truth": "Reads all the columns requested from the row group at the current file position. It may skip specific pages based\non the column indexes according to the actual filter. As the rows are not aligned among the pages of the different\ncolumns row synchronization might be required. See the documentation of the class SynchronizingColumnReader for\ndetails.\n\n@return the PageReadStore which can provide PageReaders for each column\n@throws IOException\nif any I/O error occurs while reading", "predict": " Advance to the next row group. Returns null if there are no more.\n */"}
{"ID": 1989, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException { if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) { return null; } // TODO: this should use getDictionaryPageOffset() but it isn't reliable. if (f.getPos() != meta.getStartingPos()) { f.seek(meta.getStartingPos()); } PageHeader pageHeader = Util.readPageHeader(f); if (!pageHeader.isSetDictionary_page_header()) { return null; // TODO: should this complain? } DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f); BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec()); return new DictionaryPage( decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()), compressedPage.getDictionarySize(), compressedPage.getEncoding()); } \nResponse:", "ground_truth": "Reads and decompresses a dictionary page for the given column chunk.\n\nReturns null if the given column chunk has no dictionary page.\n\n@param meta a column's ColumnChunkMetaData to read the dictionary from\n@return an uncompressed DictionaryPage or null\n@throws IOException if there is an error while reading the dictionary", "predict": " Reads dictionary page from stream and uncompressed its content to dictionaryBBuffer. Notice uncompressed size is useless information to us because it is not necessary for further processing. Therefore uncompressed size is always set to dictionaryBBuffer's limit.\n@param meta Metadata\n@return dictionary uncompressed content\n*/"}
{"ID": 1990, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation) { Long oldValue = writerList.get(writer); if (oldValue == null) { writerList.put(writer, allocation); } else { throw new IllegalArgumentException(\"[BUG] The Parquet Memory Manager should not add an \" + \"instance of InternalParquetRecordWriter more than once. The Manager already contains \" + \"the writer: \" + writer); } updateAllocation(); } \nResponse:", "ground_truth": "Add a new writer and its memory allocation to the memory manager.\n@param writer the new created writer\n@param allocation the requested buffer size", "predict": " Tracks the writers and how much memory they are consuming. Also manages the list of writers. Ensures that writers are only closed once. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that writers are told how much memory they occupy. Ensures that writers are told how much memory they occupy. Also manages the list of writers. Ensures that"}
{"ID": 1991, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: synchronized void removeWriter(InternalParquetRecordWriter writer) { if (writerList.containsKey(writer)) { writerList.remove(writer); } if (!writerList.isEmpty()) { updateAllocation(); } } \nResponse:", "ground_truth": "Remove the given writer from the memory manager.\n@param writer the writer that has been closed", "predict": " Remove a writer from the writers list and adjust the allocation accordingly. Caller must synchronize on this. @param writer the writer to remove\n*/"}
{"ID": 1992, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: private void updateAllocation() { long totalAllocations = 0; for (Long allocation : writerList.values()) { totalAllocations += allocation; } if (totalAllocations <= totalMemoryPool) { scale = 1.0; } else { scale = (double) totalMemoryPool / totalAllocations; LOG.warn(String.format( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\", 100*memoryPoolRatio, totalMemoryPool, 100*scale, writerList.size())); for (Runnable callBack : callBacks.values()) { // we do not really want to start a new thread here. callBack.run(); } } int maxColCount = 0; for (InternalParquetRecordWriter w : writerList.keySet()) { maxColCount = Math.max(w.getSchema().getColumns().size(), maxColCount); } for (Map.Entry<InternalParquetRecordWriter, Long> entry : writerList.entrySet()) { long newSize = (long) Math.floor(entry.getValue() * scale); if(scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation) { throw new ParquetRuntimeException(String.format(\"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\", newSize, minMemoryAllocation)){}; } entry.getKey().setRowGroupSizeThreshold(newSize); LOG.debug(String.format(\"Adjust block size from %,d to %,d for writer: %s\", entry.getValue(), newSize, entry.getKey())); } } \nResponse:", "ground_truth": "Update the allocated size of each writer based on the current allocations and pool size.", "predict": " Update allocations based on scale factor and minimum allocations\n*/"}
{"ID": 1993, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void registerScaleCallBack(String callBackName, Runnable callBack) { Preconditions.checkNotNull(callBackName, \"callBackName\"); Preconditions.checkNotNull(callBack, \"callBack\"); if (callBacks.containsKey(callBackName)) { throw new IllegalArgumentException(\"The callBackName \" + callBackName + \" is duplicated and has been registered already.\"); } else { callBacks.put(callBackName, callBack); } } \nResponse:", "ground_truth": "Register callback and deduplicate it if any.\n@param callBackName the name of callback. It should be identical.\n@param callBack the callback passed in from upper layer, such as Hive.", "predict": " Register a scale callback. The callback will be executed everytime the scale factor changes. The callback will be executed on the UI thread. @param callBackName The name of the callback. It must be unique. @param callBack The callback to register. It must not be null.\n*/"}
{"ID": 1994, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void start() throws IOException { state = state.start(); LOG.debug(\"{}: start\", out.getPos()); out.write(MAGIC); } \nResponse:", "ground_truth": "start the file\n@throws IOException if there is an error while writing", "predict": " Initializes the output stream for writing. Upon finishing, you have to close the output stream via close() or abort(). Closing is not really needed, but recommended, because Hadoop FS can be confused by unclean shutdown. Also recommends to flush the stream before closing, because there may be unflushed data.\n */"}
{"ID": 1995, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startBlock(long recordCount) throws IOException { state = state.startBlock(); LOG.debug(\"{}: start block\", out.getPos()); // out.write(MAGIC); // TODO: add a magic delimiter alignment.alignForRowGroup(out); currentBlock = new BlockMetaData(); currentRecordCount = recordCount; currentColumnIndexes = new ArrayList<>(); currentOffsetIndexes = new ArrayList<>(); } \nResponse:", "ground_truth": "start a block\n@param recordCount the record count in this block\n@throws IOException if there is an error while writing", "predict": " Start a new block. Once called, all columns within the block are locked against further insertions until the matching endBlock is called. @param recordCount the number of records in the block @throws IOException if an unexpected error occurs."}
{"ID": 1996, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException { state = state.startColumn(); encodingStatsBuilder.clear(); currentEncodings = new HashSet<Encoding>(); currentChunkPath = ColumnPath.get(descriptor.getPath()); currentChunkType = descriptor.getPrimitiveType(); currentChunkCodec = compressionCodecName; currentChunkValueCount = valueCount; currentChunkFirstDataPage = out.getPos(); compressedLength = 0; uncompressedLength = 0; // The statistics will be copied from the first one added at writeDataPage(s) so we have the correct typed one currentStatistics = null; columnIndexBuilder = ColumnIndexBuilder.getBuilder(currentChunkType, columnIndexTruncateLength); offsetIndexBuilder = OffsetIndexBuilder.getBuilder(); firstPageOffset = -1; } \nResponse:", "ground_truth": "start a column inside a block\n@param descriptor the column descriptor\n@param valueCount the value count in this column\n@param compressionCodecName a compression codec name\n@throws IOException if there is an error while writing", "predict": " Prepares the current column for writing. Clears accumulated stats and encodings. Begins a new column. @param descriptor the column descriptor for the current column @param valueCount the number of values in the column @param compressionCodecName compression codec name @throws IOException if preparing the column fails due to an I/O error\n*/"}
{"ID": 1997, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException { state = state.write(); LOG.debug(\"{}: write dictionary page: {} values\", out.getPos(), dictionaryPage.getDictionarySize()); currentChunkDictionaryPageOffset = out.getPos(); int uncompressedSize = dictionaryPage.getUncompressedSize(); int compressedPageSize = (int)dictionaryPage.getBytes().size(); // TODO: fix casts metadataConverter.writeDictionaryPageHeader( uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out); long headerSize = out.getPos() - currentChunkDictionaryPageOffset; this.uncompressedLength += uncompressedSize + headerSize; this.compressedLength += compressedPageSize + headerSize; LOG.debug(\"{}: write dictionary page content {}\", out.getPos(), compressedPageSize); dictionaryPage.getBytes().writeAllTo(out); encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding()); currentEncodings.add(dictionaryPage.getEncoding()); } \nResponse:", "ground_truth": "writes a dictionary page page\n@param dictionaryPage the dictionary page\n@throws IOException if there is an error while writing", "predict": " Writes dictionary page data to output stream and adds page information to pageHeaderOut. Metadata dictionary pages are written in the following format [[encoding][encoded-length][uncompressed-length][page-length]] @param dictionaryPage DictionaryPage to be written @throws IOException"}
{"ID": 1998, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void writeDataPage( int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException { long beforeHeader = out.getPos(); innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding); offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount); } \nResponse:", "ground_truth": "Writes a single page\n@param valueCount count of values\n@param uncompressedPageSize the size of the data once uncompressed\n@param bytes the compressed data for the page without header\n@param statistics the statistics of the page\n@param rowCount the number of rows in the page\n@param rlEncoding encoding of the repetition level\n@param dlEncoding encoding of the definition level\n@param valuesEncoding encoding of values\n@throws IOException if any I/O error occurs during writing the file", "predict": " Writes a data page.\n */"}
{"ID": 1999, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: void writeColumnChunk(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IOException { startColumn(descriptor, valueCount, compressionCodecName); state = state.write(); if (dictionaryPage != null) { writeDictionaryPage(dictionaryPage); } LOG.debug(\"{}: write data pages\", out.getPos()); long headersSize = bytes.size() - compressedTotalPageSize; this.uncompressedLength += uncompressedTotalPageSize + headersSize; this.compressedLength += compressedTotalPageSize + headersSize; LOG.debug(\"{}: write data pages content\", out.getPos()); firstPageOffset = out.getPos(); bytes.writeAllTo(out); encodingStatsBuilder.addDataEncodings(dataEncodings); if (rlEncodings.isEmpty()) { encodingStatsBuilder.withV2Pages(); } currentEncodings.addAll(rlEncodings); currentEncodings.addAll(dlEncodings); currentEncodings.addAll(dataEncodings); currentStatistics = totalStats; this.columnIndexBuilder = columnIndexBuilder; this.offsetIndexBuilder = offsetIndexBuilder; endColumn(); } \nResponse:", "ground_truth": "Writes a column chunk at once\n@param descriptor the descriptor of the column\n@param valueCount the value count in this column\n@param compressionCodecName the name of the compression codec used for compressing the pages\n@param dictionaryPage the dictionary page for this column chunk (might be null)\n@param bytes the encoded pages including page headers to be written as is\n@param uncompressedTotalPageSize total uncompressed size (without page headers)\n@param compressedTotalPageSize total compressed size (without page headers)\n@param totalStats accumulated statistics for the column chunk\n@param columnIndexBuilder the builder object for the column index\n@param offsetIndexBuilder the builder object for the offset index\n@param rlEncodings the RL encodings used in this column chunk\n@param dlEncodings the DL encodings used in this column chunk\n@param dataEncodings the data encodings used in this column chunk\n@throws IOException if there is an error while writing", "predict": " Writes the dictionary page if it does not exist or grows the dictionary page if new non-null dictionary additions are detected. Also updates the stats of the column. @param descriptor descriptor of the column to write @param valueCount count of values in the column @param compressionCodecName compression codec name @param dictionaryPage dictionary page to be written or null if no dictionary is packed @param bytes bytes to be written to the output stream @param uncompressedTotalPageSize total uncompressed size of all pages in the column @param compressedTotalPageSize total compressed size of all pages in the column @param totalStats total statistics of the column @param columnIndexBuilder column index builder to be updated @param offsetIndexBuilder offset index builder to be updated @param rlEncodings the RL encodings of the column @param dlEncodings the DL encodings of the column @param dataEncodings the data encodings of the column\n */"}
{"ID": 2000, "prompt": "Instruction: Generate the method-level comment for the following java Code. Code: public void endBlock() throws IOException { state = state.endBlock(); LOG.debug(\"{}: end block\", out.getPos()); currentBlock.setRowCount(currentRecordCount); blocks.add(currentBlock); columnIndexes.add(currentColumnIndexes); offsetIndexes.add(currentOffsetIndexes); currentColumnIndexes = null; currentOffsetIndexes = null; currentBlock = null; } \nResponse:", "ground_truth": "ends a block once all column chunks have been written\n@throws IOException if there is an error while writing", "predict": " End the current block. Calling this method signals the consumer that no more data will be forthcoming, so it should prepare to consume the next batch of data. @throws IOException Signals that an I/O exception has occurred.\n*/"}
